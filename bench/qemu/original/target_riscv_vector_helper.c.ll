target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ArchCPU = type { %struct.CPUState, %struct.CPUArchState, ptr, ptr, %struct.RISCVCPUConfig, ptr, i32, ptr }
%struct.CPUState = type { %struct.DeviceState, ptr, i32, i32, ptr, i32, i8, i8, ptr, i8, i8, i8, i8, i8, i8, i8, i8, i32, i32, i32, i32, i64, i64, i64, [1 x %struct.__jmp_buf_tag], %struct.QemuMutex, %struct.anon, ptr, i32, ptr, ptr, ptr, ptr, i32, i32, %union.anon, %union.anon.0, %union.anon.1, ptr, ptr, i64, i32, ptr, ptr, ptr, i32, i64, i32, %struct.QemuLockCnt, [1 x i64], ptr, i32, i32, i32, i32, i32, ptr, i8, i8, i64, i8, i8, ptr, [8 x i8], [0 x i8], %struct.CPUNegativeOffsetState }
%struct.DeviceState = type { %struct.Object, ptr, ptr, i8, i8, i64, ptr, i32, i8, ptr, %struct.NamedGPIOListHead, %struct.NamedClockListHead, %struct.BusStateHead, i32, i32, i32, %struct.ResettableState, ptr, %struct.MemReentrancyGuard }
%struct.Object = type { ptr, ptr, ptr, i32, ptr }
%struct.NamedGPIOListHead = type { ptr }
%struct.NamedClockListHead = type { ptr }
%struct.BusStateHead = type { ptr }
%struct.ResettableState = type { i32, i8, i8 }
%struct.MemReentrancyGuard = type { i8 }
%struct.__jmp_buf_tag = type { [8 x i64], i32, %struct.__sigset_t }
%struct.__sigset_t = type { [16 x i64] }
%struct.QemuMutex = type { %union.pthread_mutex_t, i8 }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { ptr, ptr }
%struct.anon = type { ptr, ptr }
%union.anon = type { %struct.QTailQLink }
%struct.QTailQLink = type { ptr, ptr }
%union.anon.0 = type { %struct.QTailQLink }
%union.anon.1 = type { %struct.QTailQLink }
%struct.QemuLockCnt = type { i32 }
%struct.CPUNegativeOffsetState = type { %struct.CPUTLB, %union.IcountDecr, i8, [11 x i8] }
%struct.CPUTLB = type { %struct.CPUTLBCommon, [16 x %struct.CPUTLBDesc], [16 x %struct.CPUTLBDescFast] }
%struct.CPUTLBCommon = type { %struct.QemuSpin, i16, i64, i64, i64 }
%struct.QemuSpin = type { i32 }
%struct.CPUTLBDesc = type { i64, i64, i64, i64, i64, i64, [8 x %union.CPUTLBEntry], [8 x %struct.CPUTLBEntryFull], ptr }
%union.CPUTLBEntry = type { %struct.anon.2 }
%struct.anon.2 = type { i64, i64, i64, i64 }
%struct.CPUTLBEntryFull = type { i64, i64, %struct.MemTxAttrs, i8, i8, [3 x i8], %union.anon.3 }
%struct.MemTxAttrs = type { i32 }
%union.anon.3 = type { %struct.anon.4 }
%struct.anon.4 = type { i8, i8, i8 }
%struct.CPUTLBDescFast = type { i64, ptr }
%union.IcountDecr = type { i32 }
%struct.CPUArchState = type { [32 x i64], [32 x i64], [512 x i64], i64, i64, i64, i64, i64, i8, i64, i64, i64, [32 x i64], i64, %struct.float_status, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, i32, i64, i64, i32, i64, i64, ptr, ptr, i8, i64, i64, [8 x i8] }
%struct.float_status = type { i16, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.RISCVCPUConfig = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i32, i64, i64, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i32, ptr, ptr, ptr, ptr, i16, i16, i16, i16, i8, i8, i8, i8, i8 }

@.str = private unnamed_addr constant [49 x i8] c"start >= 0 && length > 0 && length <= 64 - start\00", align 1
@.str.1 = private unnamed_addr constant [100 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qemu/bitops.h\00", align 1
@__PRETTY_FUNCTION__.extract64 = private unnamed_addr constant [39 x i8] c"uint64_t extract64(uint64_t, int, int)\00", align 1
@.str.2 = private unnamed_addr constant [49 x i8] c"start >= 0 && length > 0 && length <= 32 - start\00", align 1
@__PRETTY_FUNCTION__.sextract32 = private unnamed_addr constant [39 x i8] c"int32_t sextract32(uint32_t, int, int)\00", align 1
@__PRETTY_FUNCTION__.extract32 = private unnamed_addr constant [39 x i8] c"uint32_t extract32(uint32_t, int, int)\00", align 1
@guest_base = external global i64, align 8
@__PRETTY_FUNCTION__.deposit64 = private unnamed_addr constant [49 x i8] c"uint64_t deposit64(uint64_t, int, int, uint64_t)\00", align 1
@__const.frsqrt7.lookup_table = private unnamed_addr constant [128 x i8] c"4320/.,+*)('&$#\22! \1F\1E\1E\1D\1C\1B\1A\19\18\17\17\16\15\14\13\13\12\11\10\10\0F\0E\0E\0D\0C\0C\0B\0A\0A\09\09\08\07\07\06\06\05\04\04\03\03\02\02\01\01\00\7F}{ywvtrqomljigfdca`_]\\[ZXWVUTSRPONMLKJIHGFFEDCBA@??>=<;;:988765", align 16
@__const.frec7.lookup_table = private unnamed_addr constant [128 x i8] c"\7F}{ywutrpnmkihfdca`^][ZXWUTSQPOMLKJHGFEDBA@?>=<;:9876543210/.-,+*)(('&%$##\22! \1F\1F\1E\1D\1C\1C\1B\1A\19\19\18\17\17\16\15\15\14\13\13\12\11\11\10\0F\0F\0E\0E\0D\0C\0C\0B\0B\0A\09\09\08\08\07\07\06\05\05\04\04\03\03\02\02\01\01\00", align 16

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @helper_vsetvl(ptr noundef %env, i64 noundef %s1, i64 noundef %s2) #0 {
entry:
  %retval = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %s2.addr = alloca i64, align 8
  %vlmax = alloca i32, align 4
  %vl = alloca i32, align 4
  %cpu = alloca ptr, align 8
  %lmul = alloca i64, align 8
  %sew = alloca i16, align 2
  %ediv = alloca i8, align 1
  %xlen = alloca i32, align 4
  %vill = alloca i8, align 1
  %reserved = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store i64 %s2, ptr %s2.addr, align 8
  %0 = load ptr, ptr %env.addr, align 8
  %call = call ptr @env_archcpu(ptr noundef %0)
  store ptr %call, ptr %cpu, align 8
  %1 = load i64, ptr %s2.addr, align 8
  %call1 = call i64 @extract64(i64 noundef %1, i32 noundef 0, i32 noundef 3)
  store i64 %call1, ptr %lmul, align 8
  %2 = load i64, ptr %s2.addr, align 8
  %call2 = call i64 @extract64(i64 noundef %2, i32 noundef 3, i32 noundef 3)
  %sh_prom = trunc i64 %call2 to i32
  %shl = shl i32 8, %sh_prom
  %conv = trunc i32 %shl to i16
  store i16 %conv, ptr %sew, align 2
  %3 = load i64, ptr %s2.addr, align 8
  %call3 = call i64 @extract64(i64 noundef %3, i32 noundef 8, i32 noundef 2)
  %conv4 = trunc i64 %call3 to i8
  store i8 %conv4, ptr %ediv, align 1
  %4 = load ptr, ptr %env.addr, align 8
  %call5 = call i32 @riscv_cpu_xlen(ptr noundef %4)
  store i32 %call5, ptr %xlen, align 4
  %5 = load i64, ptr %s2.addr, align 8
  %6 = load i32, ptr %xlen, align 4
  %sub = sub i32 %6, 1
  %sh_prom6 = zext i32 %sub to i64
  %shr = lshr i64 %5, %sh_prom6
  %and = and i64 %shr, 1
  %tobool = icmp ne i64 %and, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %vill, align 1
  %7 = load i64, ptr %s2.addr, align 8
  %8 = load i32, ptr %xlen, align 4
  %sub7 = sub i32 %8, 1
  %sub8 = sub i32 %sub7, 10
  %sub9 = sub i32 64, %sub8
  %sh_prom10 = zext i32 %sub9 to i64
  %shr11 = lshr i64 -1, %sh_prom10
  %shl12 = shl i64 %shr11, 10
  %and13 = and i64 %7, %shl12
  store i64 %and13, ptr %reserved, align 8
  %9 = load i64, ptr %lmul, align 8
  %and14 = and i64 %9, 4
  %tobool15 = icmp ne i64 %and14, 0
  br i1 %tobool15, label %if.then, label %if.end25

if.then:                                          ; preds = %entry
  %10 = load i64, ptr %lmul, align 8
  %cmp = icmp eq i64 %10, 4
  br i1 %cmp, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %11 = load ptr, ptr %cpu, align 8
  %cfg = getelementptr inbounds %struct.ArchCPU, ptr %11, i32 0, i32 4
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %cfg, i32 0, i32 98
  %12 = load i16, ptr %vlen, align 8
  %conv17 = zext i16 %12 to i32
  %13 = load i64, ptr %lmul, align 8
  %sub18 = sub i64 8, %13
  %sh_prom19 = trunc i64 %sub18 to i32
  %shr20 = ashr i32 %conv17, %sh_prom19
  %14 = load i16, ptr %sew, align 2
  %conv21 = zext i16 %14 to i32
  %cmp22 = icmp slt i32 %shr20, %conv21
  br i1 %cmp22, label %if.then24, label %if.end

if.then24:                                        ; preds = %lor.lhs.false, %if.then
  store i8 1, ptr %vill, align 1
  br label %if.end

if.end:                                           ; preds = %if.then24, %lor.lhs.false
  br label %if.end25

if.end25:                                         ; preds = %if.end, %entry
  %15 = load i16, ptr %sew, align 2
  %conv26 = zext i16 %15 to i32
  %16 = load ptr, ptr %cpu, align 8
  %cfg27 = getelementptr inbounds %struct.ArchCPU, ptr %16, i32 0, i32 4
  %elen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %cfg27, i32 0, i32 99
  %17 = load i16, ptr %elen, align 2
  %conv28 = zext i16 %17 to i32
  %cmp29 = icmp sgt i32 %conv26, %conv28
  br i1 %cmp29, label %if.then41, label %lor.lhs.false31

lor.lhs.false31:                                  ; preds = %if.end25
  %18 = load i8, ptr %vill, align 1
  %tobool32 = trunc i8 %18 to i1
  br i1 %tobool32, label %if.then41, label %lor.lhs.false34

lor.lhs.false34:                                  ; preds = %lor.lhs.false31
  %19 = load i8, ptr %ediv, align 1
  %conv35 = zext i8 %19 to i32
  %cmp36 = icmp ne i32 %conv35, 0
  br i1 %cmp36, label %if.then41, label %lor.lhs.false38

lor.lhs.false38:                                  ; preds = %lor.lhs.false34
  %20 = load i64, ptr %reserved, align 8
  %cmp39 = icmp ne i64 %20, 0
  br i1 %cmp39, label %if.then41, label %if.end44

if.then41:                                        ; preds = %lor.lhs.false38, %lor.lhs.false34, %lor.lhs.false31, %if.end25
  %21 = load ptr, ptr %env.addr, align 8
  %vill42 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 8
  store i8 1, ptr %vill42, align 8
  %22 = load ptr, ptr %env.addr, align 8
  %vtype = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 7
  store i64 0, ptr %vtype, align 16
  %23 = load ptr, ptr %env.addr, align 8
  %vl43 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 5
  store i64 0, ptr %vl43, align 16
  %24 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart, align 8
  store i64 0, ptr %retval, align 8
  br label %return

if.end44:                                         ; preds = %lor.lhs.false38
  %25 = load ptr, ptr %cpu, align 8
  %26 = load i64, ptr %s2.addr, align 8
  %call45 = call i32 @vext_get_vlmax(ptr noundef %25, i64 noundef %26)
  store i32 %call45, ptr %vlmax, align 4
  %27 = load i64, ptr %s1.addr, align 8
  %28 = load i32, ptr %vlmax, align 4
  %conv46 = sext i32 %28 to i64
  %cmp47 = icmp ule i64 %27, %conv46
  br i1 %cmp47, label %if.then49, label %if.else

if.then49:                                        ; preds = %if.end44
  %29 = load i64, ptr %s1.addr, align 8
  %conv50 = trunc i64 %29 to i32
  store i32 %conv50, ptr %vl, align 4
  br label %if.end51

if.else:                                          ; preds = %if.end44
  %30 = load i32, ptr %vlmax, align 4
  store i32 %30, ptr %vl, align 4
  br label %if.end51

if.end51:                                         ; preds = %if.else, %if.then49
  %31 = load i32, ptr %vl, align 4
  %conv52 = sext i32 %31 to i64
  %32 = load ptr, ptr %env.addr, align 8
  %vl53 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 5
  store i64 %conv52, ptr %vl53, align 16
  %33 = load i64, ptr %s2.addr, align 8
  %34 = load ptr, ptr %env.addr, align 8
  %vtype54 = getelementptr inbounds %struct.CPUArchState, ptr %34, i32 0, i32 7
  store i64 %33, ptr %vtype54, align 16
  %35 = load ptr, ptr %env.addr, align 8
  %vstart55 = getelementptr inbounds %struct.CPUArchState, ptr %35, i32 0, i32 6
  store i64 0, ptr %vstart55, align 8
  %36 = load ptr, ptr %env.addr, align 8
  %vill56 = getelementptr inbounds %struct.CPUArchState, ptr %36, i32 0, i32 8
  store i8 0, ptr %vill56, align 8
  %37 = load i32, ptr %vl, align 4
  %conv57 = sext i32 %37 to i64
  store i64 %conv57, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end51, %if.then41
  %38 = load i64, ptr %retval, align 8
  ret i64 %38
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @env_archcpu(ptr noundef %env) #0 {
entry:
  %env.addr = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %env.addr, align 8
  %add.ptr = getelementptr i8, ptr %0, i64 -10176
  ret ptr %add.ptr
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @extract64(i64 noundef %value, i32 noundef %start, i32 noundef %length) #0 {
entry:
  %value.addr = alloca i64, align 8
  %start.addr = alloca i32, align 4
  %length.addr = alloca i32, align 4
  store i64 %value, ptr %value.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %length, ptr %length.addr, align 4
  %0 = load i32, ptr %start.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %length.addr, align 4
  %cmp1 = icmp sgt i32 %1, 0
  br i1 %cmp1, label %land.lhs.true2, label %if.else

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i32, ptr %length.addr, align 4
  %3 = load i32, ptr %start.addr, align 4
  %sub = sub i32 64, %3
  %cmp3 = icmp sle i32 %2, %sub
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true2
  br label %if.end

if.else:                                          ; preds = %land.lhs.true2, %land.lhs.true, %entry
  call void @__assert_fail(ptr noundef @.str, ptr noundef @.str.1, i32 noundef 395, ptr noundef @__PRETTY_FUNCTION__.extract64) #7
  unreachable

if.end:                                           ; preds = %if.then
  %4 = load i64, ptr %value.addr, align 8
  %5 = load i32, ptr %start.addr, align 4
  %sh_prom = zext i32 %5 to i64
  %shr = lshr i64 %4, %sh_prom
  %6 = load i32, ptr %length.addr, align 4
  %sub4 = sub i32 64, %6
  %sh_prom5 = zext i32 %sub4 to i64
  %shr6 = lshr i64 -1, %sh_prom5
  %and = and i64 %shr, %shr6
  ret i64 %and
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @riscv_cpu_xlen(ptr noundef %env) #0 {
entry:
  %env.addr = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %env.addr, align 8
  %xl = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 25
  %1 = load i32, ptr %xl, align 16
  %shl = shl i32 16, %1
  ret i32 %shl
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vext_get_vlmax(ptr noundef %cpu, i64 noundef %vtype) #0 {
entry:
  %cpu.addr = alloca ptr, align 8
  %vtype.addr = alloca i64, align 8
  %sew = alloca i8, align 1
  %lmul = alloca i8, align 1
  store ptr %cpu, ptr %cpu.addr, align 8
  store i64 %vtype, ptr %vtype.addr, align 8
  %0 = load i64, ptr %vtype.addr, align 8
  %call = call i64 @extract64(i64 noundef %0, i32 noundef 3, i32 noundef 3)
  %conv = trunc i64 %call to i8
  store i8 %conv, ptr %sew, align 1
  %1 = load i64, ptr %vtype.addr, align 8
  %call1 = call i64 @extract64(i64 noundef %1, i32 noundef 0, i32 noundef 3)
  %conv2 = trunc i64 %call1 to i32
  %call3 = call i32 @sextract32(i32 noundef %conv2, i32 noundef 0, i32 noundef 3)
  %conv4 = trunc i32 %call3 to i8
  store i8 %conv4, ptr %lmul, align 1
  %2 = load ptr, ptr %cpu.addr, align 8
  %cfg = getelementptr inbounds %struct.ArchCPU, ptr %2, i32 0, i32 4
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %cfg, i32 0, i32 98
  %3 = load i16, ptr %vlen, align 8
  %conv5 = zext i16 %3 to i32
  %4 = load i8, ptr %sew, align 1
  %conv6 = zext i8 %4 to i32
  %add = add i32 %conv6, 3
  %5 = load i8, ptr %lmul, align 1
  %conv7 = sext i8 %5 to i32
  %sub = sub i32 %add, %conv7
  %shr = ashr i32 %conv5, %sub
  ret i32 %shr
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlse8_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, i64 noundef %stride, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %stride.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i64 %stride, ptr %stride.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i64, ptr %stride.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %7 = load i32, ptr %vm, align 4
  %call1 = call i32 @ctz64(i64 noundef 1)
  %8 = call ptr @llvm.returnaddress(i32 0)
  %9 = ptrtoint ptr %8 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7, ptr noundef @lde_b, i32 noundef %call1, i64 noundef %9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vext_vm(i32 noundef %desc) #0 {
entry:
  %desc.addr = alloca i32, align 4
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @simd_data(i32 noundef %0)
  %call1 = call i32 @extract32(i32 noundef %call, i32 noundef 0, i32 noundef 1)
  ret i32 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vext_ldst_stride(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, i64 noundef %stride, ptr noundef %env, i32 noundef %desc, i32 noundef %vm, ptr noundef %ldst_elem, i32 noundef %log2_esz, i64 noundef %ra) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %stride.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm.addr = alloca i32, align 4
  %ldst_elem.addr = alloca ptr, align 8
  %log2_esz.addr = alloca i32, align 4
  %ra.addr = alloca i64, align 8
  %i = alloca i32, align 4
  %k = alloca i32, align 4
  %nf = alloca i32, align 4
  %max_elems = alloca i32, align 4
  %esz = alloca i32, align 4
  %vma = alloca i32, align 4
  %addr = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i64 %stride, ptr %stride.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  store i32 %vm, ptr %vm.addr, align 4
  store ptr %ldst_elem, ptr %ldst_elem.addr, align 8
  store i32 %log2_esz, ptr %log2_esz.addr, align 4
  store i64 %ra, ptr %ra.addr, align 8
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  store i32 %call, ptr %nf, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %2 = load i32, ptr %log2_esz.addr, align 4
  %call1 = call i32 @vext_max_elems(i32 noundef %1, i32 noundef %2)
  store i32 %call1, ptr %max_elems, align 4
  %3 = load i32, ptr %log2_esz.addr, align 4
  %shl = shl i32 1, %3
  store i32 %shl, ptr %esz, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vma(i32 noundef %4)
  store i32 %call2, ptr %vma, align 4
  %5 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %vstart, align 8
  %conv = trunc i64 %6 to i32
  store i32 %conv, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, ptr %i, align 4
  %conv3 = zext i32 %7 to i64
  %8 = load ptr, ptr %env.addr, align 8
  %vl = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 5
  %9 = load i64, ptr %vl, align 16
  %cmp = icmp ult i64 %conv3, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i32 0, ptr %k, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then, %for.body
  %10 = load i32, ptr %k, align 4
  %11 = load i32, ptr %nf, align 4
  %cmp5 = icmp ult i32 %10, %11
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i32, ptr %vm.addr, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %k, align 4
  %19 = load i32, ptr %max_elems, align 4
  %mul = mul i32 %18, %19
  %add = add i32 %17, %mul
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %k, align 4
  %23 = load i32, ptr %max_elems, align 4
  %mul10 = mul i32 %22, %23
  %add11 = add i32 %21, %mul10
  %add12 = add i32 %add11, 1
  %24 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %add12, %24
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul9, i32 noundef %mul13)
  %25 = load i32, ptr %k, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %k, align 4
  br label %while.cond, !llvm.loop !5

if.end:                                           ; preds = %land.lhs.true, %while.body
  %26 = load i64, ptr %base.addr, align 8
  %27 = load i64, ptr %stride.addr, align 8
  %28 = load i32, ptr %i, align 4
  %conv14 = zext i32 %28 to i64
  %mul15 = mul i64 %27, %conv14
  %add16 = add i64 %26, %mul15
  %29 = load i32, ptr %k, align 4
  %30 = load i32, ptr %log2_esz.addr, align 4
  %shl17 = shl i32 %29, %30
  %conv18 = zext i32 %shl17 to i64
  %add19 = add i64 %add16, %conv18
  store i64 %add19, ptr %addr, align 8
  %31 = load ptr, ptr %ldst_elem.addr, align 8
  %32 = load ptr, ptr %env.addr, align 8
  %33 = load ptr, ptr %env.addr, align 8
  %34 = load i64, ptr %addr, align 8
  %call20 = call i64 @adjust_addr(ptr noundef %33, i64 noundef %34)
  %35 = load i32, ptr %i, align 4
  %36 = load i32, ptr %k, align 4
  %37 = load i32, ptr %max_elems, align 4
  %mul21 = mul i32 %36, %37
  %add22 = add i32 %35, %mul21
  %38 = load ptr, ptr %vd.addr, align 8
  %39 = load i64, ptr %ra.addr, align 8
  call void %31(ptr noundef %32, i64 noundef %call20, i32 noundef %add22, ptr noundef %38, i64 noundef %39)
  %40 = load i32, ptr %k, align 4
  %inc23 = add i32 %40, 1
  store i32 %inc23, ptr %k, align 4
  br label %while.cond, !llvm.loop !5

while.end:                                        ; preds = %while.cond
  br label %for.inc

for.inc:                                          ; preds = %while.end
  %41 = load i32, ptr %i, align 4
  %inc24 = add i32 %41, 1
  store i32 %inc24, ptr %i, align 4
  %42 = load ptr, ptr %env.addr, align 8
  %vstart25 = getelementptr inbounds %struct.CPUArchState, ptr %42, i32 0, i32 6
  %43 = load i64, ptr %vstart25, align 8
  %inc26 = add i64 %43, 1
  store i64 %inc26, ptr %vstart25, align 8
  br label %for.cond, !llvm.loop !7

for.end:                                          ; preds = %for.cond
  %44 = load ptr, ptr %env.addr, align 8
  %vstart27 = getelementptr inbounds %struct.CPUArchState, ptr %44, i32 0, i32 6
  store i64 0, ptr %vstart27, align 8
  %45 = load ptr, ptr %env.addr, align 8
  %vl28 = getelementptr inbounds %struct.CPUArchState, ptr %45, i32 0, i32 5
  %46 = load i64, ptr %vl28, align 16
  %47 = load ptr, ptr %vd.addr, align 8
  %48 = load i32, ptr %desc.addr, align 4
  %49 = load i32, ptr %nf, align 4
  %50 = load i32, ptr %esz, align 4
  %51 = load i32, ptr %max_elems, align 4
  call void @vext_set_tail_elems_1s(i64 noundef %46, ptr noundef %47, i32 noundef %48, i32 noundef %49, i32 noundef %50, i32 noundef %51)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @lde_b(ptr noundef %env, i64 noundef %addr, i32 noundef %idx, ptr noundef %vd, i64 noundef %retaddr) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %idx.addr = alloca i32, align 4
  %vd.addr = alloca ptr, align 8
  %retaddr.addr = alloca i64, align 8
  %cur = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %retaddr, ptr %retaddr.addr, align 8
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i32, ptr %idx.addr, align 4
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  store ptr %add.ptr, ptr %cur, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i64, ptr %addr.addr, align 8
  %4 = load i64, ptr %retaddr.addr, align 8
  %call = call i32 @cpu_ldsb_data_ra(ptr noundef %2, i64 noundef %3, i64 noundef %4)
  %conv = trunc i32 %call to i8
  %5 = load ptr, ptr %cur, align 8
  store i8 %conv, ptr %5, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ctz64(i64 noundef %val) #0 {
entry:
  %val.addr = alloca i64, align 8
  store i64 %val, ptr %val.addr, align 8
  %0 = load i64, ptr %val.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %val.addr, align 8
  %2 = call i64 @llvm.cttz.i64(i64 %1, i1 true)
  %cast = trunc i64 %2 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %cast, %cond.true ], [ 64, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
declare ptr @llvm.returnaddress(i32 immarg) #1

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlse16_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, i64 noundef %stride, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %stride.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i64 %stride, ptr %stride.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i64, ptr %stride.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %7 = load i32, ptr %vm, align 4
  %call1 = call i32 @ctz64(i64 noundef 2)
  %8 = call ptr @llvm.returnaddress(i32 0)
  %9 = ptrtoint ptr %8 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7, ptr noundef @lde_h, i32 noundef %call1, i64 noundef %9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @lde_h(ptr noundef %env, i64 noundef %addr, i32 noundef %idx, ptr noundef %vd, i64 noundef %retaddr) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %idx.addr = alloca i32, align 4
  %vd.addr = alloca ptr, align 8
  %retaddr.addr = alloca i64, align 8
  %cur = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %retaddr, ptr %retaddr.addr, align 8
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i32, ptr %idx.addr, align 4
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  store ptr %add.ptr, ptr %cur, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i64, ptr %addr.addr, align 8
  %4 = load i64, ptr %retaddr.addr, align 8
  %call = call i32 @cpu_ldsw_le_data_ra(ptr noundef %2, i64 noundef %3, i64 noundef %4)
  %conv = trunc i32 %call to i16
  %5 = load ptr, ptr %cur, align 8
  store i16 %conv, ptr %5, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlse32_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, i64 noundef %stride, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %stride.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i64 %stride, ptr %stride.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i64, ptr %stride.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %7 = load i32, ptr %vm, align 4
  %call1 = call i32 @ctz64(i64 noundef 4)
  %8 = call ptr @llvm.returnaddress(i32 0)
  %9 = ptrtoint ptr %8 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7, ptr noundef @lde_w, i32 noundef %call1, i64 noundef %9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @lde_w(ptr noundef %env, i64 noundef %addr, i32 noundef %idx, ptr noundef %vd, i64 noundef %retaddr) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %idx.addr = alloca i32, align 4
  %vd.addr = alloca ptr, align 8
  %retaddr.addr = alloca i64, align 8
  %cur = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %retaddr, ptr %retaddr.addr, align 8
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i32, ptr %idx.addr, align 4
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  store ptr %add.ptr, ptr %cur, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i64, ptr %addr.addr, align 8
  %4 = load i64, ptr %retaddr.addr, align 8
  %call = call i32 @cpu_ldl_le_data_ra(ptr noundef %2, i64 noundef %3, i64 noundef %4)
  %5 = load ptr, ptr %cur, align 8
  store i32 %call, ptr %5, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlse64_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, i64 noundef %stride, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %stride.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i64 %stride, ptr %stride.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i64, ptr %stride.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %7 = load i32, ptr %vm, align 4
  %call1 = call i32 @ctz64(i64 noundef 8)
  %8 = call ptr @llvm.returnaddress(i32 0)
  %9 = ptrtoint ptr %8 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7, ptr noundef @lde_d, i32 noundef %call1, i64 noundef %9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @lde_d(ptr noundef %env, i64 noundef %addr, i32 noundef %idx, ptr noundef %vd, i64 noundef %retaddr) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %idx.addr = alloca i32, align 4
  %vd.addr = alloca ptr, align 8
  %retaddr.addr = alloca i64, align 8
  %cur = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %retaddr, ptr %retaddr.addr, align 8
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i32, ptr %idx.addr, align 4
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  store ptr %add.ptr, ptr %cur, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i64, ptr %addr.addr, align 8
  %4 = load i64, ptr %retaddr.addr, align 8
  %call = call i64 @cpu_ldq_le_data_ra(ptr noundef %2, i64 noundef %3, i64 noundef %4)
  %5 = load ptr, ptr %cur, align 8
  store i64 %call, ptr %5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsse8_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, i64 noundef %stride, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %stride.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i64 %stride, ptr %stride.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i64, ptr %stride.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %7 = load i32, ptr %vm, align 4
  %call1 = call i32 @ctz64(i64 noundef 1)
  %8 = call ptr @llvm.returnaddress(i32 0)
  %9 = ptrtoint ptr %8 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7, ptr noundef @ste_b, i32 noundef %call1, i64 noundef %9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @ste_b(ptr noundef %env, i64 noundef %addr, i32 noundef %idx, ptr noundef %vd, i64 noundef %retaddr) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %idx.addr = alloca i32, align 4
  %vd.addr = alloca ptr, align 8
  %retaddr.addr = alloca i64, align 8
  %data = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %retaddr, ptr %retaddr.addr, align 8
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i32, ptr %idx.addr, align 4
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %data, align 1
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i64, ptr %addr.addr, align 8
  %5 = load i8, ptr %data, align 1
  %conv = sext i8 %5 to i32
  %6 = load i64, ptr %retaddr.addr, align 8
  call void @cpu_stb_data_ra(ptr noundef %3, i64 noundef %4, i32 noundef %conv, i64 noundef %6)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsse16_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, i64 noundef %stride, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %stride.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i64 %stride, ptr %stride.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i64, ptr %stride.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %7 = load i32, ptr %vm, align 4
  %call1 = call i32 @ctz64(i64 noundef 2)
  %8 = call ptr @llvm.returnaddress(i32 0)
  %9 = ptrtoint ptr %8 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7, ptr noundef @ste_h, i32 noundef %call1, i64 noundef %9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @ste_h(ptr noundef %env, i64 noundef %addr, i32 noundef %idx, ptr noundef %vd, i64 noundef %retaddr) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %idx.addr = alloca i32, align 4
  %vd.addr = alloca ptr, align 8
  %retaddr.addr = alloca i64, align 8
  %data = alloca i16, align 2
  store ptr %env, ptr %env.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %retaddr, ptr %retaddr.addr, align 8
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i32, ptr %idx.addr, align 4
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %data, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i64, ptr %addr.addr, align 8
  %5 = load i16, ptr %data, align 2
  %conv = sext i16 %5 to i32
  %6 = load i64, ptr %retaddr.addr, align 8
  call void @cpu_stw_le_data_ra(ptr noundef %3, i64 noundef %4, i32 noundef %conv, i64 noundef %6)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsse32_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, i64 noundef %stride, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %stride.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i64 %stride, ptr %stride.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i64, ptr %stride.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %7 = load i32, ptr %vm, align 4
  %call1 = call i32 @ctz64(i64 noundef 4)
  %8 = call ptr @llvm.returnaddress(i32 0)
  %9 = ptrtoint ptr %8 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7, ptr noundef @ste_w, i32 noundef %call1, i64 noundef %9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @ste_w(ptr noundef %env, i64 noundef %addr, i32 noundef %idx, ptr noundef %vd, i64 noundef %retaddr) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %idx.addr = alloca i32, align 4
  %vd.addr = alloca ptr, align 8
  %retaddr.addr = alloca i64, align 8
  %data = alloca i32, align 4
  store ptr %env, ptr %env.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %retaddr, ptr %retaddr.addr, align 8
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i32, ptr %idx.addr, align 4
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %data, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i64, ptr %addr.addr, align 8
  %5 = load i32, ptr %data, align 4
  %6 = load i64, ptr %retaddr.addr, align 8
  call void @cpu_stl_le_data_ra(ptr noundef %3, i64 noundef %4, i32 noundef %5, i64 noundef %6)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsse64_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, i64 noundef %stride, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %stride.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i64 %stride, ptr %stride.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i64, ptr %stride.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %7 = load i32, ptr %vm, align 4
  %call1 = call i32 @ctz64(i64 noundef 8)
  %8 = call ptr @llvm.returnaddress(i32 0)
  %9 = ptrtoint ptr %8 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7, ptr noundef @ste_d, i32 noundef %call1, i64 noundef %9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @ste_d(ptr noundef %env, i64 noundef %addr, i32 noundef %idx, ptr noundef %vd, i64 noundef %retaddr) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %idx.addr = alloca i32, align 4
  %vd.addr = alloca ptr, align 8
  %retaddr.addr = alloca i64, align 8
  %data = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %retaddr, ptr %retaddr.addr, align 8
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i32, ptr %idx.addr, align 4
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %data, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i64, ptr %addr.addr, align 8
  %5 = load i64, ptr %data, align 8
  %6 = load i64, ptr %retaddr.addr, align 8
  call void @cpu_stq_le_data_ra(ptr noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vle8_v_mask(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %stride = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  %call1 = call i32 @ctz64(i64 noundef 1)
  %shl = shl i32 %call, %call1
  store i32 %shl, ptr %stride, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i32, ptr %stride, align 4
  %conv = zext i32 %4 to i64
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @ctz64(i64 noundef 1)
  %7 = call ptr @llvm.returnaddress(i32 0)
  %8 = ptrtoint ptr %7 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %conv, ptr noundef %5, i32 noundef %6, i32 noundef 0, ptr noundef @lde_b, i32 noundef %call2, i64 noundef %8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vext_nf(i32 noundef %desc) #0 {
entry:
  %desc.addr = alloca i32, align 4
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @simd_data(i32 noundef %0)
  %call1 = call i32 @extract32(i32 noundef %call, i32 noundef 7, i32 noundef 4)
  ret i32 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vle8_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %4 = load ptr, ptr %env.addr, align 8
  %vl = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 5
  %5 = load i64, ptr %vl, align 16
  %conv = trunc i64 %5 to i32
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_us(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_b, i32 noundef %call, i32 noundef %conv, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vext_ldst_us(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc, ptr noundef %ldst_elem, i32 noundef %log2_esz, i32 noundef %evl, i64 noundef %ra) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %ldst_elem.addr = alloca ptr, align 8
  %log2_esz.addr = alloca i32, align 4
  %evl.addr = alloca i32, align 4
  %ra.addr = alloca i64, align 8
  %i = alloca i32, align 4
  %k = alloca i32, align 4
  %nf = alloca i32, align 4
  %max_elems = alloca i32, align 4
  %esz = alloca i32, align 4
  %addr = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  store ptr %ldst_elem, ptr %ldst_elem.addr, align 8
  store i32 %log2_esz, ptr %log2_esz.addr, align 4
  store i32 %evl, ptr %evl.addr, align 4
  store i64 %ra, ptr %ra.addr, align 8
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  store i32 %call, ptr %nf, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %2 = load i32, ptr %log2_esz.addr, align 4
  %call1 = call i32 @vext_max_elems(i32 noundef %1, i32 noundef %2)
  store i32 %call1, ptr %max_elems, align 4
  %3 = load i32, ptr %log2_esz.addr, align 4
  %shl = shl i32 1, %3
  store i32 %shl, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 6
  %5 = load i64, ptr %vstart, align 8
  %conv = trunc i64 %5 to i32
  store i32 %conv, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, ptr %i, align 4
  %7 = load i32, ptr %evl.addr, align 4
  %cmp = icmp ult i32 %6, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i32 0, ptr %k, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.body
  %8 = load i32, ptr %k, align 4
  %9 = load i32, ptr %nf, align 4
  %cmp3 = icmp ult i32 %8, %9
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load i64, ptr %base.addr, align 8
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %nf, align 4
  %mul = mul i32 %11, %12
  %13 = load i32, ptr %k, align 4
  %add = add i32 %mul, %13
  %14 = load i32, ptr %log2_esz.addr, align 4
  %shl5 = shl i32 %add, %14
  %conv6 = zext i32 %shl5 to i64
  %add7 = add i64 %10, %conv6
  store i64 %add7, ptr %addr, align 8
  %15 = load ptr, ptr %ldst_elem.addr, align 8
  %16 = load ptr, ptr %env.addr, align 8
  %17 = load ptr, ptr %env.addr, align 8
  %18 = load i64, ptr %addr, align 8
  %call8 = call i64 @adjust_addr(ptr noundef %17, i64 noundef %18)
  %19 = load i32, ptr %i, align 4
  %20 = load i32, ptr %k, align 4
  %21 = load i32, ptr %max_elems, align 4
  %mul9 = mul i32 %20, %21
  %add10 = add i32 %19, %mul9
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i64, ptr %ra.addr, align 8
  call void %15(ptr noundef %16, i64 noundef %call8, i32 noundef %add10, ptr noundef %22, i64 noundef %23)
  %24 = load i32, ptr %k, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %k, align 4
  br label %while.cond, !llvm.loop !8

while.end:                                        ; preds = %while.cond
  br label %for.inc

for.inc:                                          ; preds = %while.end
  %25 = load i32, ptr %i, align 4
  %inc11 = add i32 %25, 1
  store i32 %inc11, ptr %i, align 4
  %26 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  %27 = load i64, ptr %vstart12, align 8
  %inc13 = add i64 %27, 1
  store i64 %inc13, ptr %vstart12, align 8
  br label %for.cond, !llvm.loop !9

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %29 = load i32, ptr %evl.addr, align 4
  %conv15 = zext i32 %29 to i64
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %desc.addr, align 4
  %32 = load i32, ptr %nf, align 4
  %33 = load i32, ptr %esz, align 4
  %34 = load i32, ptr %max_elems, align 4
  call void @vext_set_tail_elems_1s(i64 noundef %conv15, ptr noundef %30, i32 noundef %31, i32 noundef %32, i32 noundef %33, i32 noundef %34)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vle16_v_mask(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %stride = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  %call1 = call i32 @ctz64(i64 noundef 2)
  %shl = shl i32 %call, %call1
  store i32 %shl, ptr %stride, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i32, ptr %stride, align 4
  %conv = zext i32 %4 to i64
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @ctz64(i64 noundef 2)
  %7 = call ptr @llvm.returnaddress(i32 0)
  %8 = ptrtoint ptr %7 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %conv, ptr noundef %5, i32 noundef %6, i32 noundef 0, ptr noundef @lde_h, i32 noundef %call2, i64 noundef %8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vle16_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %4 = load ptr, ptr %env.addr, align 8
  %vl = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 5
  %5 = load i64, ptr %vl, align 16
  %conv = trunc i64 %5 to i32
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_us(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_h, i32 noundef %call, i32 noundef %conv, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vle32_v_mask(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %stride = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  %call1 = call i32 @ctz64(i64 noundef 4)
  %shl = shl i32 %call, %call1
  store i32 %shl, ptr %stride, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i32, ptr %stride, align 4
  %conv = zext i32 %4 to i64
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @ctz64(i64 noundef 4)
  %7 = call ptr @llvm.returnaddress(i32 0)
  %8 = ptrtoint ptr %7 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %conv, ptr noundef %5, i32 noundef %6, i32 noundef 0, ptr noundef @lde_w, i32 noundef %call2, i64 noundef %8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vle32_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %4 = load ptr, ptr %env.addr, align 8
  %vl = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 5
  %5 = load i64, ptr %vl, align 16
  %conv = trunc i64 %5 to i32
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_us(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_w, i32 noundef %call, i32 noundef %conv, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vle64_v_mask(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %stride = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  %call1 = call i32 @ctz64(i64 noundef 8)
  %shl = shl i32 %call, %call1
  store i32 %shl, ptr %stride, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i32, ptr %stride, align 4
  %conv = zext i32 %4 to i64
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @ctz64(i64 noundef 8)
  %7 = call ptr @llvm.returnaddress(i32 0)
  %8 = ptrtoint ptr %7 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %conv, ptr noundef %5, i32 noundef %6, i32 noundef 0, ptr noundef @lde_d, i32 noundef %call2, i64 noundef %8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vle64_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %4 = load ptr, ptr %env.addr, align 8
  %vl = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 5
  %5 = load i64, ptr %vl, align 16
  %conv = trunc i64 %5 to i32
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_us(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_d, i32 noundef %call, i32 noundef %conv, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vse8_v_mask(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %stride = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  %call1 = call i32 @ctz64(i64 noundef 1)
  %shl = shl i32 %call, %call1
  store i32 %shl, ptr %stride, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i32, ptr %stride, align 4
  %conv = zext i32 %4 to i64
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @ctz64(i64 noundef 1)
  %7 = call ptr @llvm.returnaddress(i32 0)
  %8 = ptrtoint ptr %7 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %conv, ptr noundef %5, i32 noundef %6, i32 noundef 0, ptr noundef @ste_b, i32 noundef %call2, i64 noundef %8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vse8_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %4 = load ptr, ptr %env.addr, align 8
  %vl = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 5
  %5 = load i64, ptr %vl, align 16
  %conv = trunc i64 %5 to i32
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_us(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @ste_b, i32 noundef %call, i32 noundef %conv, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vse16_v_mask(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %stride = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  %call1 = call i32 @ctz64(i64 noundef 2)
  %shl = shl i32 %call, %call1
  store i32 %shl, ptr %stride, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i32, ptr %stride, align 4
  %conv = zext i32 %4 to i64
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @ctz64(i64 noundef 2)
  %7 = call ptr @llvm.returnaddress(i32 0)
  %8 = ptrtoint ptr %7 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %conv, ptr noundef %5, i32 noundef %6, i32 noundef 0, ptr noundef @ste_h, i32 noundef %call2, i64 noundef %8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vse16_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %4 = load ptr, ptr %env.addr, align 8
  %vl = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 5
  %5 = load i64, ptr %vl, align 16
  %conv = trunc i64 %5 to i32
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_us(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @ste_h, i32 noundef %call, i32 noundef %conv, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vse32_v_mask(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %stride = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  %call1 = call i32 @ctz64(i64 noundef 4)
  %shl = shl i32 %call, %call1
  store i32 %shl, ptr %stride, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i32, ptr %stride, align 4
  %conv = zext i32 %4 to i64
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @ctz64(i64 noundef 4)
  %7 = call ptr @llvm.returnaddress(i32 0)
  %8 = ptrtoint ptr %7 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %conv, ptr noundef %5, i32 noundef %6, i32 noundef 0, ptr noundef @ste_w, i32 noundef %call2, i64 noundef %8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vse32_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %4 = load ptr, ptr %env.addr, align 8
  %vl = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 5
  %5 = load i64, ptr %vl, align 16
  %conv = trunc i64 %5 to i32
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_us(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @ste_w, i32 noundef %call, i32 noundef %conv, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vse64_v_mask(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %stride = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  %call1 = call i32 @ctz64(i64 noundef 8)
  %shl = shl i32 %call, %call1
  store i32 %shl, ptr %stride, align 4
  %1 = load ptr, ptr %vd.addr, align 8
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load i32, ptr %stride, align 4
  %conv = zext i32 %4 to i64
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @ctz64(i64 noundef 8)
  %7 = call ptr @llvm.returnaddress(i32 0)
  %8 = ptrtoint ptr %7 to i64
  call void @vext_ldst_stride(ptr noundef %1, ptr noundef %2, i64 noundef %3, i64 noundef %conv, ptr noundef %5, i32 noundef %6, i32 noundef 0, ptr noundef @ste_d, i32 noundef %call2, i64 noundef %8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vse64_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %4 = load ptr, ptr %env.addr, align 8
  %vl = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 5
  %5 = load i64, ptr %vl, align 16
  %conv = trunc i64 %5 to i32
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_us(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @ste_d, i32 noundef %call, i32 noundef %conv, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlm_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %evl = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl, align 16
  %add = add i64 %1, 7
  %shr = lshr i64 %add, 3
  %conv = trunc i64 %shr to i8
  store i8 %conv, ptr %evl, align 1
  %2 = load ptr, ptr %vd.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i8, ptr %evl, align 1
  %conv1 = zext i8 %6 to i32
  %7 = call ptr @llvm.returnaddress(i32 0)
  %8 = ptrtoint ptr %7 to i64
  call void @vext_ldst_us(ptr noundef %2, i64 noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @lde_b, i32 noundef 0, i32 noundef %conv1, i64 noundef %8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsm_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %evl = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl, align 16
  %add = add i64 %1, 7
  %shr = lshr i64 %add, 3
  %conv = trunc i64 %shr to i8
  store i8 %conv, ptr %evl, align 1
  %2 = load ptr, ptr %vd.addr, align 8
  %3 = load i64, ptr %base.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i8, ptr %evl, align 1
  %conv1 = zext i8 %6 to i32
  %7 = call ptr @llvm.returnaddress(i32 0)
  %8 = ptrtoint ptr %7 to i64
  call void @vext_ldst_us(ptr noundef %2, i64 noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @ste_b, i32 noundef 0, i32 noundef %conv1, i64 noundef %8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei8_8_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_b, ptr noundef @lde_b, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vext_ldst_index(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc, ptr noundef %get_index_addr, ptr noundef %ldst_elem, i32 noundef %log2_esz, i64 noundef %ra) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %get_index_addr.addr = alloca ptr, align 8
  %ldst_elem.addr = alloca ptr, align 8
  %log2_esz.addr = alloca i32, align 4
  %ra.addr = alloca i64, align 8
  %i = alloca i32, align 4
  %k = alloca i32, align 4
  %nf = alloca i32, align 4
  %vm = alloca i32, align 4
  %max_elems = alloca i32, align 4
  %esz = alloca i32, align 4
  %vma = alloca i32, align 4
  %addr = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  store ptr %get_index_addr, ptr %get_index_addr.addr, align 8
  store ptr %ldst_elem, ptr %ldst_elem.addr, align 8
  store i32 %log2_esz, ptr %log2_esz.addr, align 4
  store i64 %ra, ptr %ra.addr, align 8
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  store i32 %call, ptr %nf, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call1 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call1, ptr %vm, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %3 = load i32, ptr %log2_esz.addr, align 4
  %call2 = call i32 @vext_max_elems(i32 noundef %2, i32 noundef %3)
  store i32 %call2, ptr %max_elems, align 4
  %4 = load i32, ptr %log2_esz.addr, align 4
  %shl = shl i32 1, %4
  store i32 %shl, ptr %esz, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vma(i32 noundef %5)
  store i32 %call3, ptr %vma, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv = trunc i64 %7 to i32
  store i32 %conv, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %conv4 = zext i32 %8 to i64
  %9 = load ptr, ptr %env.addr, align 8
  %vl = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 5
  %10 = load i64, ptr %vl, align 16
  %cmp = icmp ult i64 %conv4, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i32 0, ptr %k, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then, %for.body
  %11 = load i32, ptr %k, align 4
  %12 = load i32, ptr %nf, align 4
  %cmp6 = icmp ult i32 %11, %12
  br i1 %cmp6, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %16 = load ptr, ptr %vd.addr, align 8
  %17 = load i32, ptr %vma, align 4
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %k, align 4
  %20 = load i32, ptr %max_elems, align 4
  %mul = mul i32 %19, %20
  %add = add i32 %18, %mul
  %21 = load i32, ptr %esz, align 4
  %mul10 = mul i32 %add, %21
  %22 = load i32, ptr %i, align 4
  %23 = load i32, ptr %k, align 4
  %24 = load i32, ptr %max_elems, align 4
  %mul11 = mul i32 %23, %24
  %add12 = add i32 %22, %mul11
  %add13 = add i32 %add12, 1
  %25 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %add13, %25
  call void @vext_set_elems_1s(ptr noundef %16, i32 noundef %17, i32 noundef %mul10, i32 noundef %mul14)
  %26 = load i32, ptr %k, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %k, align 4
  br label %while.cond, !llvm.loop !10

if.end:                                           ; preds = %land.lhs.true, %while.body
  %27 = load ptr, ptr %get_index_addr.addr, align 8
  %28 = load i64, ptr %base.addr, align 8
  %29 = load i32, ptr %i, align 4
  %30 = load ptr, ptr %vs2.addr, align 8
  %call15 = call i64 %27(i64 noundef %28, i32 noundef %29, ptr noundef %30)
  %31 = load i32, ptr %k, align 4
  %32 = load i32, ptr %log2_esz.addr, align 4
  %shl16 = shl i32 %31, %32
  %conv17 = zext i32 %shl16 to i64
  %add18 = add i64 %call15, %conv17
  store i64 %add18, ptr %addr, align 8
  %33 = load ptr, ptr %ldst_elem.addr, align 8
  %34 = load ptr, ptr %env.addr, align 8
  %35 = load ptr, ptr %env.addr, align 8
  %36 = load i64, ptr %addr, align 8
  %call19 = call i64 @adjust_addr(ptr noundef %35, i64 noundef %36)
  %37 = load i32, ptr %i, align 4
  %38 = load i32, ptr %k, align 4
  %39 = load i32, ptr %max_elems, align 4
  %mul20 = mul i32 %38, %39
  %add21 = add i32 %37, %mul20
  %40 = load ptr, ptr %vd.addr, align 8
  %41 = load i64, ptr %ra.addr, align 8
  call void %33(ptr noundef %34, i64 noundef %call19, i32 noundef %add21, ptr noundef %40, i64 noundef %41)
  %42 = load i32, ptr %k, align 4
  %inc22 = add i32 %42, 1
  store i32 %inc22, ptr %k, align 4
  br label %while.cond, !llvm.loop !10

while.end:                                        ; preds = %while.cond
  br label %for.inc

for.inc:                                          ; preds = %while.end
  %43 = load i32, ptr %i, align 4
  %inc23 = add i32 %43, 1
  store i32 %inc23, ptr %i, align 4
  %44 = load ptr, ptr %env.addr, align 8
  %vstart24 = getelementptr inbounds %struct.CPUArchState, ptr %44, i32 0, i32 6
  %45 = load i64, ptr %vstart24, align 8
  %inc25 = add i64 %45, 1
  store i64 %inc25, ptr %vstart24, align 8
  br label %for.cond, !llvm.loop !11

for.end:                                          ; preds = %for.cond
  %46 = load ptr, ptr %env.addr, align 8
  %vstart26 = getelementptr inbounds %struct.CPUArchState, ptr %46, i32 0, i32 6
  store i64 0, ptr %vstart26, align 8
  %47 = load ptr, ptr %env.addr, align 8
  %vl27 = getelementptr inbounds %struct.CPUArchState, ptr %47, i32 0, i32 5
  %48 = load i64, ptr %vl27, align 16
  %49 = load ptr, ptr %vd.addr, align 8
  %50 = load i32, ptr %desc.addr, align 4
  %51 = load i32, ptr %nf, align 4
  %52 = load i32, ptr %esz, align 4
  %53 = load i32, ptr %max_elems, align 4
  call void @vext_set_tail_elems_1s(i64 noundef %48, ptr noundef %49, i32 noundef %50, i32 noundef %51, i32 noundef %52, i32 noundef %53)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @idx_b(i64 noundef %base, i32 noundef %idx, ptr noundef %vs2) #0 {
entry:
  %base.addr = alloca i64, align 8
  %idx.addr = alloca i32, align 4
  %vs2.addr = alloca ptr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %vs2, ptr %vs2.addr, align 8
  %0 = load i64, ptr %base.addr, align 8
  %1 = load ptr, ptr %vs2.addr, align 8
  %2 = load i32, ptr %idx.addr, align 4
  %idx.ext = zext i32 %2 to i64
  %add.ptr = getelementptr i8, ptr %1, i64 %idx.ext
  %3 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %3 to i64
  %add = add i64 %0, %conv
  ret i64 %add
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei8_16_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_b, ptr noundef @lde_h, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei8_32_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_b, ptr noundef @lde_w, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei8_64_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_b, ptr noundef @lde_d, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei16_8_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_h, ptr noundef @lde_b, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @idx_h(i64 noundef %base, i32 noundef %idx, ptr noundef %vs2) #0 {
entry:
  %base.addr = alloca i64, align 8
  %idx.addr = alloca i32, align 4
  %vs2.addr = alloca ptr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %vs2, ptr %vs2.addr, align 8
  %0 = load i64, ptr %base.addr, align 8
  %1 = load ptr, ptr %vs2.addr, align 8
  %2 = load i32, ptr %idx.addr, align 4
  %idx.ext = zext i32 %2 to i64
  %add.ptr = getelementptr i16, ptr %1, i64 %idx.ext
  %3 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %3 to i64
  %add = add i64 %0, %conv
  ret i64 %add
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei16_16_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_h, ptr noundef @lde_h, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei16_32_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_h, ptr noundef @lde_w, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei16_64_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_h, ptr noundef @lde_d, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei32_8_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_w, ptr noundef @lde_b, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @idx_w(i64 noundef %base, i32 noundef %idx, ptr noundef %vs2) #0 {
entry:
  %base.addr = alloca i64, align 8
  %idx.addr = alloca i32, align 4
  %vs2.addr = alloca ptr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %vs2, ptr %vs2.addr, align 8
  %0 = load i64, ptr %base.addr, align 8
  %1 = load ptr, ptr %vs2.addr, align 8
  %2 = load i32, ptr %idx.addr, align 4
  %idx.ext = zext i32 %2 to i64
  %add.ptr = getelementptr i32, ptr %1, i64 %idx.ext
  %3 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %3 to i64
  %add = add i64 %0, %conv
  ret i64 %add
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei32_16_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_w, ptr noundef @lde_h, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei32_32_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_w, ptr noundef @lde_w, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei32_64_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_w, ptr noundef @lde_d, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei64_8_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_d, ptr noundef @lde_b, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @idx_d(i64 noundef %base, i32 noundef %idx, ptr noundef %vs2) #0 {
entry:
  %base.addr = alloca i64, align 8
  %idx.addr = alloca i32, align 4
  %vs2.addr = alloca ptr, align 8
  store i64 %base, ptr %base.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %vs2, ptr %vs2.addr, align 8
  %0 = load i64, ptr %base.addr, align 8
  %1 = load ptr, ptr %vs2.addr, align 8
  %2 = load i32, ptr %idx.addr, align 4
  %idx.ext = zext i32 %2 to i64
  %add.ptr = getelementptr i64, ptr %1, i64 %idx.ext
  %3 = load i64, ptr %add.ptr, align 8
  %add = add i64 %0, %3
  ret i64 %add
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei64_16_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_d, ptr noundef @lde_h, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei64_32_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_d, ptr noundef @lde_w, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vlxei64_64_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_d, ptr noundef @lde_d, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei8_8_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_b, ptr noundef @ste_b, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei8_16_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_b, ptr noundef @ste_h, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei8_32_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_b, ptr noundef @ste_w, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei8_64_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_b, ptr noundef @ste_d, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei16_8_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_h, ptr noundef @ste_b, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei16_16_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_h, ptr noundef @ste_h, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei16_32_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_h, ptr noundef @ste_w, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei16_64_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_h, ptr noundef @ste_d, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei32_8_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_w, ptr noundef @ste_b, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei32_16_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_w, ptr noundef @ste_h, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei32_32_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_w, ptr noundef @ste_w, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei32_64_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_w, ptr noundef @ste_d, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei64_8_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_d, ptr noundef @ste_b, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei64_16_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_d, ptr noundef @ste_h, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei64_32_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_d, ptr noundef @ste_w, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsxei64_64_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %6 = call ptr @llvm.returnaddress(i32 0)
  %7 = ptrtoint ptr %6 to i64
  call void @vext_ldst_index(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @idx_d, ptr noundef @ste_d, i32 noundef %call, i64 noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vle8ff_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %5 = call ptr @llvm.returnaddress(i32 0)
  %6 = ptrtoint ptr %5 to i64
  call void @vext_ldff(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, i32 noundef %4, ptr noundef @lde_b, i32 noundef %call, i64 noundef %6)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vext_ldff(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc, ptr noundef %ldst_elem, i32 noundef %log2_esz, i64 noundef %ra) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %ldst_elem.addr = alloca ptr, align 8
  %log2_esz.addr = alloca i32, align 4
  %ra.addr = alloca i64, align 8
  %host = alloca ptr, align 8
  %i = alloca i32, align 4
  %k = alloca i32, align 4
  %vl = alloca i32, align 4
  %nf = alloca i32, align 4
  %vm = alloca i32, align 4
  %max_elems = alloca i32, align 4
  %esz = alloca i32, align 4
  %vma = alloca i32, align 4
  %addr = alloca i64, align 8
  %offset = alloca i64, align 8
  %remain = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  store ptr %ldst_elem, ptr %ldst_elem.addr, align 8
  store i32 %log2_esz, ptr %log2_esz.addr, align 4
  store i64 %ra, ptr %ra.addr, align 8
  store i32 0, ptr %vl, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  store i32 %call, ptr %nf, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call1 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call1, ptr %vm, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %3 = load i32, ptr %log2_esz.addr, align 4
  %call2 = call i32 @vext_max_elems(i32 noundef %2, i32 noundef %3)
  store i32 %call2, ptr %max_elems, align 4
  %4 = load i32, ptr %log2_esz.addr, align 4
  %shl = shl i32 1, %4
  store i32 %shl, ptr %esz, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vma(i32 noundef %5)
  store i32 %call3, ptr %vma, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv = trunc i64 %7 to i32
  store i32 %conv, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %conv4 = zext i32 %8 to i64
  %9 = load ptr, ptr %env.addr, align 8
  %vl5 = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 5
  %10 = load i64, ptr %vl5, align 16
  %cmp = icmp ult i64 %conv4, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %14 = load ptr, ptr %env.addr, align 8
  %15 = load i64, ptr %base.addr, align 8
  %16 = load i32, ptr %i, align 4
  %17 = load i32, ptr %nf, align 4
  %18 = load i32, ptr %log2_esz.addr, align 4
  %shl9 = shl i32 %17, %18
  %mul = mul i32 %16, %shl9
  %conv10 = zext i32 %mul to i64
  %add = add i64 %15, %conv10
  %call11 = call i64 @adjust_addr(ptr noundef %14, i64 noundef %add)
  store i64 %call11, ptr %addr, align 8
  %19 = load i32, ptr %i, align 4
  %cmp12 = icmp eq i32 %19, 0
  br i1 %cmp12, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  %20 = load ptr, ptr %env.addr, align 8
  %21 = load i64, ptr %addr, align 8
  %22 = load i32, ptr %nf, align 4
  %23 = load i32, ptr %log2_esz.addr, align 4
  %shl15 = shl i32 %22, %23
  %conv16 = zext i32 %shl15 to i64
  %24 = load i64, ptr %ra.addr, align 8
  call void @probe_pages(ptr noundef %20, i64 noundef %21, i64 noundef %conv16, i64 noundef %24, i32 noundef 0)
  br label %if.end37

if.else:                                          ; preds = %if.end
  %25 = load i32, ptr %nf, align 4
  %26 = load i32, ptr %log2_esz.addr, align 4
  %shl17 = shl i32 %25, %26
  %conv18 = zext i32 %shl17 to i64
  store i64 %conv18, ptr %remain, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end33, %if.else
  %27 = load i64, ptr %remain, align 8
  %cmp19 = icmp ugt i64 %27, 0
  br i1 %cmp19, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %28 = load i64, ptr %addr, align 8
  %or = or i64 %28, -4096
  %sub = sub i64 0, %or
  store i64 %sub, ptr %offset, align 8
  %29 = load ptr, ptr %env.addr, align 8
  %30 = load i64, ptr %addr, align 8
  %31 = load ptr, ptr %env.addr, align 8
  %call21 = call i32 @riscv_cpu_mmu_index(ptr noundef %31, i1 noundef zeroext false)
  %call22 = call ptr @tlb_vaddr_to_host(ptr noundef %29, i64 noundef %30, i32 noundef 0, i32 noundef %call21)
  store ptr %call22, ptr %host, align 8
  %32 = load ptr, ptr %host, align 8
  %tobool23 = icmp ne ptr %32, null
  br i1 %tobool23, label %if.then24, label %if.else28

if.then24:                                        ; preds = %while.body
  %33 = load i64, ptr %addr, align 8
  %34 = load i64, ptr %offset, align 8
  %call25 = call zeroext i1 @page_check_range(i64 noundef %33, i64 noundef %34, i32 noundef 1)
  br i1 %call25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %if.then24
  %35 = load i32, ptr %i, align 4
  store i32 %35, ptr %vl, align 4
  br label %ProbeSuccess

if.end27:                                         ; preds = %if.then24
  br label %if.end29

if.else28:                                        ; preds = %while.body
  %36 = load i32, ptr %i, align 4
  store i32 %36, ptr %vl, align 4
  br label %ProbeSuccess

if.end29:                                         ; preds = %if.end27
  %37 = load i64, ptr %remain, align 8
  %38 = load i64, ptr %offset, align 8
  %cmp30 = icmp ule i64 %37, %38
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end29
  br label %while.end

if.end33:                                         ; preds = %if.end29
  %39 = load i64, ptr %offset, align 8
  %40 = load i64, ptr %remain, align 8
  %sub34 = sub i64 %40, %39
  store i64 %sub34, ptr %remain, align 8
  %41 = load ptr, ptr %env.addr, align 8
  %42 = load i64, ptr %addr, align 8
  %43 = load i64, ptr %offset, align 8
  %add35 = add i64 %42, %43
  %call36 = call i64 @adjust_addr(ptr noundef %41, i64 noundef %add35)
  store i64 %call36, ptr %addr, align 8
  br label %while.cond, !llvm.loop !12

while.end:                                        ; preds = %if.then32, %while.cond
  br label %if.end37

if.end37:                                         ; preds = %while.end, %if.then14
  br label %for.inc

for.inc:                                          ; preds = %if.end37, %if.then
  %44 = load i32, ptr %i, align 4
  %inc = add i32 %44, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !13

for.end:                                          ; preds = %for.cond
  br label %ProbeSuccess

ProbeSuccess:                                     ; preds = %for.end, %if.else28, %if.then26
  %45 = load i32, ptr %vl, align 4
  %cmp38 = icmp ne i32 %45, 0
  br i1 %cmp38, label %if.then40, label %if.end43

if.then40:                                        ; preds = %ProbeSuccess
  %46 = load i32, ptr %vl, align 4
  %conv41 = zext i32 %46 to i64
  %47 = load ptr, ptr %env.addr, align 8
  %vl42 = getelementptr inbounds %struct.CPUArchState, ptr %47, i32 0, i32 5
  store i64 %conv41, ptr %vl42, align 16
  br label %if.end43

if.end43:                                         ; preds = %if.then40, %ProbeSuccess
  %48 = load ptr, ptr %env.addr, align 8
  %vstart44 = getelementptr inbounds %struct.CPUArchState, ptr %48, i32 0, i32 6
  %49 = load i64, ptr %vstart44, align 8
  %conv45 = trunc i64 %49 to i32
  store i32 %conv45, ptr %i, align 4
  br label %for.cond46

for.cond46:                                       ; preds = %for.inc80, %if.end43
  %50 = load i32, ptr %i, align 4
  %conv47 = zext i32 %50 to i64
  %51 = load ptr, ptr %env.addr, align 8
  %vl48 = getelementptr inbounds %struct.CPUArchState, ptr %51, i32 0, i32 5
  %52 = load i64, ptr %vl48, align 16
  %cmp49 = icmp ult i64 %conv47, %52
  br i1 %cmp49, label %for.body51, label %for.end82

for.body51:                                       ; preds = %for.cond46
  store i32 0, ptr %k, align 4
  br label %while.cond52

while.cond52:                                     ; preds = %if.end69, %if.then60, %for.body51
  %53 = load i32, ptr %k, align 4
  %54 = load i32, ptr %nf, align 4
  %cmp53 = icmp ult i32 %53, %54
  br i1 %cmp53, label %while.body55, label %while.end79

while.body55:                                     ; preds = %while.cond52
  %55 = load i32, ptr %vm, align 4
  %tobool56 = icmp ne i32 %55, 0
  br i1 %tobool56, label %if.end69, label %land.lhs.true57

land.lhs.true57:                                  ; preds = %while.body55
  %56 = load ptr, ptr %v0.addr, align 8
  %57 = load i32, ptr %i, align 4
  %call58 = call i32 @vext_elem_mask(ptr noundef %56, i32 noundef %57)
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.end69, label %if.then60

if.then60:                                        ; preds = %land.lhs.true57
  %58 = load ptr, ptr %vd.addr, align 8
  %59 = load i32, ptr %vma, align 4
  %60 = load i32, ptr %i, align 4
  %61 = load i32, ptr %k, align 4
  %62 = load i32, ptr %max_elems, align 4
  %mul61 = mul i32 %61, %62
  %add62 = add i32 %60, %mul61
  %63 = load i32, ptr %esz, align 4
  %mul63 = mul i32 %add62, %63
  %64 = load i32, ptr %i, align 4
  %65 = load i32, ptr %k, align 4
  %66 = load i32, ptr %max_elems, align 4
  %mul64 = mul i32 %65, %66
  %add65 = add i32 %64, %mul64
  %add66 = add i32 %add65, 1
  %67 = load i32, ptr %esz, align 4
  %mul67 = mul i32 %add66, %67
  call void @vext_set_elems_1s(ptr noundef %58, i32 noundef %59, i32 noundef %mul63, i32 noundef %mul67)
  %68 = load i32, ptr %k, align 4
  %inc68 = add i32 %68, 1
  store i32 %inc68, ptr %k, align 4
  br label %while.cond52, !llvm.loop !14

if.end69:                                         ; preds = %land.lhs.true57, %while.body55
  %69 = load i64, ptr %base.addr, align 8
  %70 = load i32, ptr %i, align 4
  %71 = load i32, ptr %nf, align 4
  %mul70 = mul i32 %70, %71
  %72 = load i32, ptr %k, align 4
  %add71 = add i32 %mul70, %72
  %73 = load i32, ptr %log2_esz.addr, align 4
  %shl72 = shl i32 %add71, %73
  %conv73 = zext i32 %shl72 to i64
  %add74 = add i64 %69, %conv73
  store i64 %add74, ptr %addr, align 8
  %74 = load ptr, ptr %ldst_elem.addr, align 8
  %75 = load ptr, ptr %env.addr, align 8
  %76 = load ptr, ptr %env.addr, align 8
  %77 = load i64, ptr %addr, align 8
  %call75 = call i64 @adjust_addr(ptr noundef %76, i64 noundef %77)
  %78 = load i32, ptr %i, align 4
  %79 = load i32, ptr %k, align 4
  %80 = load i32, ptr %max_elems, align 4
  %mul76 = mul i32 %79, %80
  %add77 = add i32 %78, %mul76
  %81 = load ptr, ptr %vd.addr, align 8
  %82 = load i64, ptr %ra.addr, align 8
  call void %74(ptr noundef %75, i64 noundef %call75, i32 noundef %add77, ptr noundef %81, i64 noundef %82)
  %83 = load i32, ptr %k, align 4
  %inc78 = add i32 %83, 1
  store i32 %inc78, ptr %k, align 4
  br label %while.cond52, !llvm.loop !14

while.end79:                                      ; preds = %while.cond52
  br label %for.inc80

for.inc80:                                        ; preds = %while.end79
  %84 = load i32, ptr %i, align 4
  %inc81 = add i32 %84, 1
  store i32 %inc81, ptr %i, align 4
  br label %for.cond46, !llvm.loop !15

for.end82:                                        ; preds = %for.cond46
  %85 = load ptr, ptr %env.addr, align 8
  %vstart83 = getelementptr inbounds %struct.CPUArchState, ptr %85, i32 0, i32 6
  store i64 0, ptr %vstart83, align 8
  %86 = load ptr, ptr %env.addr, align 8
  %vl84 = getelementptr inbounds %struct.CPUArchState, ptr %86, i32 0, i32 5
  %87 = load i64, ptr %vl84, align 16
  %88 = load ptr, ptr %vd.addr, align 8
  %89 = load i32, ptr %desc.addr, align 4
  %90 = load i32, ptr %nf, align 4
  %91 = load i32, ptr %esz, align 4
  %92 = load i32, ptr %max_elems, align 4
  call void @vext_set_tail_elems_1s(i64 noundef %87, ptr noundef %88, i32 noundef %89, i32 noundef %90, i32 noundef %91, i32 noundef %92)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vle16ff_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %5 = call ptr @llvm.returnaddress(i32 0)
  %6 = ptrtoint ptr %5 to i64
  call void @vext_ldff(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, i32 noundef %4, ptr noundef @lde_h, i32 noundef %call, i64 noundef %6)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vle32ff_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %5 = call ptr @llvm.returnaddress(i32 0)
  %6 = ptrtoint ptr %5 to i64
  call void @vext_ldff(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, i32 noundef %4, ptr noundef @lde_w, i32 noundef %call, i64 noundef %6)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vle64ff_v(ptr noundef %vd, ptr noundef %v0, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %base.addr, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %5 = call ptr @llvm.returnaddress(i32 0)
  %6 = ptrtoint ptr %5 to i64
  call void @vext_ldff(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, i32 noundef %4, ptr noundef @lde_d, i32 noundef %call, i64 noundef %6)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl1re8_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_b, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vext_ldst_whole(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc, ptr noundef %ldst_elem, i32 noundef %log2_esz, i64 noundef %ra) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %ldst_elem.addr = alloca ptr, align 8
  %log2_esz.addr = alloca i32, align 4
  %ra.addr = alloca i64, align 8
  %i = alloca i32, align 4
  %k = alloca i32, align 4
  %off = alloca i32, align 4
  %pos = alloca i32, align 4
  %nf = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %max_elems = alloca i32, align 4
  %addr = alloca i64, align 8
  %addr25 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  store ptr %ldst_elem, ptr %ldst_elem.addr, align 8
  store i32 %log2_esz, ptr %log2_esz.addr, align 4
  store i64 %ra, ptr %ra.addr, align 8
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_nf(i32 noundef %0)
  store i32 %call, ptr %nf, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %call1 = call ptr @riscv_cpu_cfg(ptr noundef %1)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call1, i32 0, i32 98
  %2 = load i16, ptr %vlen, align 8
  %conv = zext i16 %2 to i32
  %shr = ashr i32 %conv, 3
  store i32 %shr, ptr %vlenb, align 4
  %3 = load i32, ptr %vlenb, align 4
  %4 = load i32, ptr %log2_esz.addr, align 4
  %shr2 = lshr i32 %3, %4
  store i32 %shr2, ptr %max_elems, align 4
  %5 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %vstart, align 8
  %7 = load i32, ptr %max_elems, align 4
  %conv3 = zext i32 %7 to i64
  %div = udiv i64 %6, %conv3
  %conv4 = trunc i64 %div to i32
  store i32 %conv4, ptr %k, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart5 = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart5, align 8
  %10 = load i32, ptr %max_elems, align 4
  %conv6 = zext i32 %10 to i64
  %rem = urem i64 %9, %conv6
  %conv7 = trunc i64 %rem to i32
  store i32 %conv7, ptr %off, align 4
  %11 = load i32, ptr %off, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %12 = load i32, ptr %off, align 4
  store i32 %12, ptr %pos, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %13 = load i32, ptr %pos, align 4
  %14 = load i32, ptr %max_elems, align 4
  %cmp = icmp ult i32 %13, %14
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load i64, ptr %base.addr, align 8
  %16 = load i32, ptr %pos, align 4
  %17 = load i32, ptr %k, align 4
  %18 = load i32, ptr %max_elems, align 4
  %mul = mul i32 %17, %18
  %add = add i32 %16, %mul
  %19 = load i32, ptr %log2_esz.addr, align 4
  %shl = shl i32 %add, %19
  %conv9 = zext i32 %shl to i64
  %add10 = add i64 %15, %conv9
  store i64 %add10, ptr %addr, align 8
  %20 = load ptr, ptr %ldst_elem.addr, align 8
  %21 = load ptr, ptr %env.addr, align 8
  %22 = load ptr, ptr %env.addr, align 8
  %23 = load i64, ptr %addr, align 8
  %call11 = call i64 @adjust_addr(ptr noundef %22, i64 noundef %23)
  %24 = load i32, ptr %pos, align 4
  %25 = load i32, ptr %k, align 4
  %26 = load i32, ptr %max_elems, align 4
  %mul12 = mul i32 %25, %26
  %add13 = add i32 %24, %mul12
  %27 = load ptr, ptr %vd.addr, align 8
  %28 = load i64, ptr %ra.addr, align 8
  call void %20(ptr noundef %21, i64 noundef %call11, i32 noundef %add13, ptr noundef %27, i64 noundef %28)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %29 = load i32, ptr %pos, align 4
  %inc = add i32 %29, 1
  store i32 %inc, ptr %pos, align 4
  %30 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %30, i32 0, i32 6
  %31 = load i64, ptr %vstart14, align 8
  %inc15 = add i64 %31, 1
  store i64 %inc15, ptr %vstart14, align 8
  br label %for.cond, !llvm.loop !16

for.end:                                          ; preds = %for.cond
  %32 = load i32, ptr %k, align 4
  %inc16 = add i32 %32, 1
  store i32 %inc16, ptr %k, align 4
  br label %if.end

if.end:                                           ; preds = %for.end, %entry
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc39, %if.end
  %33 = load i32, ptr %k, align 4
  %34 = load i32, ptr %nf, align 4
  %cmp18 = icmp ult i32 %33, %34
  br i1 %cmp18, label %for.body20, label %for.end41

for.body20:                                       ; preds = %for.cond17
  store i32 0, ptr %i, align 4
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc34, %for.body20
  %35 = load i32, ptr %i, align 4
  %36 = load i32, ptr %max_elems, align 4
  %cmp22 = icmp ult i32 %35, %36
  br i1 %cmp22, label %for.body24, label %for.end38

for.body24:                                       ; preds = %for.cond21
  %37 = load i64, ptr %base.addr, align 8
  %38 = load i32, ptr %i, align 4
  %39 = load i32, ptr %k, align 4
  %40 = load i32, ptr %max_elems, align 4
  %mul26 = mul i32 %39, %40
  %add27 = add i32 %38, %mul26
  %41 = load i32, ptr %log2_esz.addr, align 4
  %shl28 = shl i32 %add27, %41
  %conv29 = zext i32 %shl28 to i64
  %add30 = add i64 %37, %conv29
  store i64 %add30, ptr %addr25, align 8
  %42 = load ptr, ptr %ldst_elem.addr, align 8
  %43 = load ptr, ptr %env.addr, align 8
  %44 = load ptr, ptr %env.addr, align 8
  %45 = load i64, ptr %addr25, align 8
  %call31 = call i64 @adjust_addr(ptr noundef %44, i64 noundef %45)
  %46 = load i32, ptr %i, align 4
  %47 = load i32, ptr %k, align 4
  %48 = load i32, ptr %max_elems, align 4
  %mul32 = mul i32 %47, %48
  %add33 = add i32 %46, %mul32
  %49 = load ptr, ptr %vd.addr, align 8
  %50 = load i64, ptr %ra.addr, align 8
  call void %42(ptr noundef %43, i64 noundef %call31, i32 noundef %add33, ptr noundef %49, i64 noundef %50)
  br label %for.inc34

for.inc34:                                        ; preds = %for.body24
  %51 = load i32, ptr %i, align 4
  %inc35 = add i32 %51, 1
  store i32 %inc35, ptr %i, align 4
  %52 = load ptr, ptr %env.addr, align 8
  %vstart36 = getelementptr inbounds %struct.CPUArchState, ptr %52, i32 0, i32 6
  %53 = load i64, ptr %vstart36, align 8
  %inc37 = add i64 %53, 1
  store i64 %inc37, ptr %vstart36, align 8
  br label %for.cond21, !llvm.loop !17

for.end38:                                        ; preds = %for.cond21
  br label %for.inc39

for.inc39:                                        ; preds = %for.end38
  %54 = load i32, ptr %k, align 4
  %inc40 = add i32 %54, 1
  store i32 %inc40, ptr %k, align 4
  br label %for.cond17, !llvm.loop !18

for.end41:                                        ; preds = %for.cond17
  %55 = load ptr, ptr %env.addr, align 8
  %vstart42 = getelementptr inbounds %struct.CPUArchState, ptr %55, i32 0, i32 6
  store i64 0, ptr %vstart42, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl1re16_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_h, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl1re32_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_w, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl1re64_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_d, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl2re8_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_b, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl2re16_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_h, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl2re32_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_w, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl2re64_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_d, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl4re8_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_b, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl4re16_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_h, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl4re32_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_w, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl4re64_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_d, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl8re8_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_b, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl8re16_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_h, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl8re32_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_w, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vl8re64_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @lde_d, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vs1r_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @ste_b, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vs2r_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @ste_b, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vs4r_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @ste_b, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vs8r_v(ptr noundef %vd, i64 noundef %base, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %base.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %base, ptr %base.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load i64, ptr %base.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %4 = call ptr @llvm.returnaddress(i32 0)
  %5 = ptrtoint ptr %4 to i64
  call void @vext_ldst_whole(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef @ste_b, i32 noundef %call, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadd_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vadd_vv_b, i32 noundef 1)
  ret void
}

declare void @do_vext_vv(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vadd_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %conv = sext i8 %6 to i32
  %7 = load i8, ptr %s1, align 1
  %conv3 = sext i8 %7 to i32
  %add = add i32 %conv, %conv3
  %conv4 = trunc i32 %add to i8
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %9 to i64
  %add.ptr6 = getelementptr i8, ptr %8, i64 %idx.ext5
  store i8 %conv4, ptr %add.ptr6, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadd_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vadd_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vadd_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv3 = sext i16 %7 to i32
  %add = add i32 %conv, %conv3
  %conv4 = trunc i32 %add to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %9 to i64
  %add.ptr6 = getelementptr i16, ptr %8, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadd_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vadd_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vadd_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %add = add i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %add, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadd_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vadd_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vadd_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %add = add i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %add, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsub_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsub_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsub_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %conv = sext i8 %6 to i32
  %7 = load i8, ptr %s1, align 1
  %conv3 = sext i8 %7 to i32
  %sub = sub i32 %conv, %conv3
  %conv4 = trunc i32 %sub to i8
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %9 to i64
  %add.ptr6 = getelementptr i8, ptr %8, i64 %idx.ext5
  store i8 %conv4, ptr %add.ptr6, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsub_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsub_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsub_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv3 = sext i16 %7 to i32
  %sub = sub i32 %conv, %conv3
  %conv4 = trunc i32 %sub to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %9 to i64
  %add.ptr6 = getelementptr i16, ptr %8, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsub_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsub_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsub_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %sub = sub i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %sub, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsub_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsub_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsub_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %sub = sub i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %sub, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadd_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vadd_vx_b, i32 noundef 1)
  ret void
}

declare void @do_vext_vx(ptr noundef, ptr noundef, i64 noundef, ptr noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vadd_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %conv = sext i8 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = sext i8 %conv1 to i32
  %add = add i32 %conv, %conv2
  %conv3 = trunc i32 %add to i8
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i8, ptr %5, i64 %idx.ext4
  store i8 %conv3, ptr %add.ptr5, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadd_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vadd_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vadd_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = sext i16 %conv1 to i32
  %add = add i32 %conv, %conv2
  %conv3 = trunc i32 %add to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i16, ptr %5, i64 %idx.ext4
  store i16 %conv3, ptr %add.ptr5, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadd_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vadd_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vadd_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %add = add i32 %3, %conv
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %add, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadd_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vadd_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vadd_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %add = add i64 %3, %4
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %add, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsub_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsub_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsub_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %conv = sext i8 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = sext i8 %conv1 to i32
  %sub = sub i32 %conv, %conv2
  %conv3 = trunc i32 %sub to i8
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i8, ptr %5, i64 %idx.ext4
  store i8 %conv3, ptr %add.ptr5, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsub_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsub_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsub_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = sext i16 %conv1 to i32
  %sub = sub i32 %conv, %conv2
  %conv3 = trunc i32 %sub to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i16, ptr %5, i64 %idx.ext4
  store i16 %conv3, ptr %add.ptr5, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsub_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsub_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsub_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %sub = sub i32 %3, %conv
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %sub, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsub_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsub_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsub_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %sub = sub i64 %3, %4
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %sub, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrsub_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vrsub_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vrsub_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i8
  %conv1 = sext i8 %conv to i32
  %4 = load i8, ptr %s2, align 1
  %conv2 = sext i8 %4 to i32
  %sub = sub i32 %conv1, %conv2
  %conv3 = trunc i32 %sub to i8
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i8, ptr %5, i64 %idx.ext4
  store i8 %conv3, ptr %add.ptr5, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrsub_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vrsub_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vrsub_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i16
  %conv1 = sext i16 %conv to i32
  %4 = load i16, ptr %s2, align 2
  %conv2 = sext i16 %4 to i32
  %sub = sub i32 %conv1, %conv2
  %conv3 = trunc i32 %sub to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i16, ptr %5, i64 %idx.ext4
  store i16 %conv3, ptr %add.ptr5, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrsub_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vrsub_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vrsub_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i32
  %4 = load i32, ptr %s2, align 4
  %sub = sub i32 %conv, %4
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %sub, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrsub_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vrsub_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vrsub_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s1.addr, align 8
  %4 = load i64, ptr %s2, align 8
  %sub = sub i64 %3, %4
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %sub, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vec_rsubs8(ptr noundef %d, ptr noundef %a, i64 noundef %b, i32 noundef %desc) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca i64, align 8
  %desc.addr = alloca i32, align 4
  %oprsz = alloca i64, align 8
  %i = alloca i64, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i64 @simd_oprsz(i32 noundef %0)
  store i64 %call, ptr %oprsz, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %i, align 8
  %2 = load i64, ptr %oprsz, align 8
  %cmp = icmp slt i64 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, ptr %b.addr, align 8
  %conv = trunc i64 %3 to i8
  %conv1 = zext i8 %conv to i32
  %4 = load ptr, ptr %a.addr, align 8
  %5 = load i64, ptr %i, align 8
  %add.ptr = getelementptr i8, ptr %4, i64 %5
  %6 = load i8, ptr %add.ptr, align 1
  %conv2 = zext i8 %6 to i32
  %sub = sub i32 %conv1, %conv2
  %conv3 = trunc i32 %sub to i8
  %7 = load ptr, ptr %d.addr, align 8
  %8 = load i64, ptr %i, align 8
  %add.ptr4 = getelementptr i8, ptr %7, i64 %8
  store i8 %conv3, ptr %add.ptr4, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i64, ptr %i, align 8
  %add = add i64 %9, 1
  store i64 %add, ptr %i, align 8
  br label %for.cond, !llvm.loop !19

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @simd_oprsz(i32 noundef %desc) #0 {
entry:
  %desc.addr = alloca i32, align 4
  %f = alloca i32, align 4
  %o = alloca i64, align 8
  %m = alloca i64, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @extract32(i32 noundef %0, i32 noundef 8, i32 noundef 2)
  store i32 %call, ptr %f, align 4
  %1 = load i32, ptr %f, align 4
  %mul = mul i32 %1, 8
  %add = add i32 %mul, 8
  %conv = zext i32 %add to i64
  store i64 %conv, ptr %o, align 8
  %2 = load i32, ptr %desc.addr, align 4
  %call1 = call i64 @simd_maxsz(i32 noundef %2)
  store i64 %call1, ptr %m, align 8
  %3 = load i32, ptr %f, align 4
  %cmp = icmp eq i32 %3, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i64, ptr %m, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load i64, ptr %o, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %4, %cond.true ], [ %5, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vec_rsubs16(ptr noundef %d, ptr noundef %a, i64 noundef %b, i32 noundef %desc) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca i64, align 8
  %desc.addr = alloca i32, align 4
  %oprsz = alloca i64, align 8
  %i = alloca i64, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i64 @simd_oprsz(i32 noundef %0)
  store i64 %call, ptr %oprsz, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %i, align 8
  %2 = load i64, ptr %oprsz, align 8
  %cmp = icmp slt i64 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, ptr %b.addr, align 8
  %conv = trunc i64 %3 to i16
  %conv1 = zext i16 %conv to i32
  %4 = load ptr, ptr %a.addr, align 8
  %5 = load i64, ptr %i, align 8
  %add.ptr = getelementptr i8, ptr %4, i64 %5
  %6 = load i16, ptr %add.ptr, align 2
  %conv2 = zext i16 %6 to i32
  %sub = sub i32 %conv1, %conv2
  %conv3 = trunc i32 %sub to i16
  %7 = load ptr, ptr %d.addr, align 8
  %8 = load i64, ptr %i, align 8
  %add.ptr4 = getelementptr i8, ptr %7, i64 %8
  store i16 %conv3, ptr %add.ptr4, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i64, ptr %i, align 8
  %add = add i64 %9, 2
  store i64 %add, ptr %i, align 8
  br label %for.cond, !llvm.loop !20

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vec_rsubs32(ptr noundef %d, ptr noundef %a, i64 noundef %b, i32 noundef %desc) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca i64, align 8
  %desc.addr = alloca i32, align 4
  %oprsz = alloca i64, align 8
  %i = alloca i64, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i64 @simd_oprsz(i32 noundef %0)
  store i64 %call, ptr %oprsz, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %i, align 8
  %2 = load i64, ptr %oprsz, align 8
  %cmp = icmp slt i64 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, ptr %b.addr, align 8
  %conv = trunc i64 %3 to i32
  %4 = load ptr, ptr %a.addr, align 8
  %5 = load i64, ptr %i, align 8
  %add.ptr = getelementptr i8, ptr %4, i64 %5
  %6 = load i32, ptr %add.ptr, align 4
  %sub = sub i32 %conv, %6
  %7 = load ptr, ptr %d.addr, align 8
  %8 = load i64, ptr %i, align 8
  %add.ptr1 = getelementptr i8, ptr %7, i64 %8
  store i32 %sub, ptr %add.ptr1, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i64, ptr %i, align 8
  %add = add i64 %9, 4
  store i64 %add, ptr %i, align 8
  br label %for.cond, !llvm.loop !21

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vec_rsubs64(ptr noundef %d, ptr noundef %a, i64 noundef %b, i32 noundef %desc) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca i64, align 8
  %desc.addr = alloca i32, align 4
  %oprsz = alloca i64, align 8
  %i = alloca i64, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i64 @simd_oprsz(i32 noundef %0)
  store i64 %call, ptr %oprsz, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %i, align 8
  %2 = load i64, ptr %oprsz, align 8
  %cmp = icmp slt i64 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, ptr %b.addr, align 8
  %4 = load ptr, ptr %a.addr, align 8
  %5 = load i64, ptr %i, align 8
  %add.ptr = getelementptr i8, ptr %4, i64 %5
  %6 = load i64, ptr %add.ptr, align 8
  %sub = sub i64 %3, %6
  %7 = load ptr, ptr %d.addr, align 8
  %8 = load i64, ptr %i, align 8
  %add.ptr1 = getelementptr i8, ptr %7, i64 %8
  store i64 %sub, ptr %add.ptr1, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i64, ptr %i, align 8
  %add = add i64 %9, 8
  store i64 %add, ptr %i, align 8
  br label %for.cond, !llvm.loop !22

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwaddu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwaddu_vv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwaddu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  %conv3 = zext i8 %5 to i16
  store i16 %conv3, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv4 = zext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv5 = zext i16 %7 to i32
  %add = add i32 %conv4, %conv5
  %conv6 = trunc i32 %add to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %9 to i64
  %add.ptr8 = getelementptr i16, ptr %8, i64 %idx.ext7
  store i16 %conv6, ptr %add.ptr8, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwaddu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwaddu_vv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwaddu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %add = add i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i32, ptr %8, i64 %idx.ext4
  store i32 %add, ptr %add.ptr5, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwaddu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwaddu_vv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwaddu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %add = add i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i64, ptr %8, i64 %idx.ext4
  store i64 %add, ptr %add.ptr5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsubu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsubu_vv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsubu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  %conv3 = zext i8 %5 to i16
  store i16 %conv3, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv4 = zext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv5 = zext i16 %7 to i32
  %sub = sub i32 %conv4, %conv5
  %conv6 = trunc i32 %sub to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %9 to i64
  %add.ptr8 = getelementptr i16, ptr %8, i64 %idx.ext7
  store i16 %conv6, ptr %add.ptr8, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsubu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsubu_vv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsubu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %sub = sub i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i32, ptr %8, i64 %idx.ext4
  store i32 %sub, ptr %add.ptr5, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsubu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsubu_vv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsubu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %sub = sub i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i64, ptr %8, i64 %idx.ext4
  store i64 %sub, ptr %add.ptr5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwadd_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwadd_vv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwadd_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  %conv3 = sext i8 %5 to i16
  store i16 %conv3, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv4 = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv5 = sext i16 %7 to i32
  %add = add i32 %conv4, %conv5
  %conv6 = trunc i32 %add to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %9 to i64
  %add.ptr8 = getelementptr i16, ptr %8, i64 %idx.ext7
  store i16 %conv6, ptr %add.ptr8, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwadd_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwadd_vv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwadd_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = sext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %add = add i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i32, ptr %8, i64 %idx.ext4
  store i32 %add, ptr %add.ptr5, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwadd_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwadd_vv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwadd_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = sext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %add = add i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i64, ptr %8, i64 %idx.ext4
  store i64 %add, ptr %add.ptr5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsub_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsub_vv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsub_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  %conv3 = sext i8 %5 to i16
  store i16 %conv3, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv4 = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv5 = sext i16 %7 to i32
  %sub = sub i32 %conv4, %conv5
  %conv6 = trunc i32 %sub to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %9 to i64
  %add.ptr8 = getelementptr i16, ptr %8, i64 %idx.ext7
  store i16 %conv6, ptr %add.ptr8, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsub_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsub_vv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsub_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = sext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %sub = sub i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i32, ptr %8, i64 %idx.ext4
  store i32 %sub, ptr %add.ptr5, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsub_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsub_vv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsub_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = sext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %sub = sub i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i64, ptr %8, i64 %idx.ext4
  store i64 %sub, ptr %add.ptr5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwaddu_wv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwaddu_wv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwaddu_wv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv3 = zext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv4 = zext i16 %7 to i32
  %add = add i32 %conv3, %conv4
  %conv5 = trunc i32 %add to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %9 to i64
  %add.ptr7 = getelementptr i16, ptr %8, i64 %idx.ext6
  store i16 %conv5, ptr %add.ptr7, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwaddu_wv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwaddu_wv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwaddu_wv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %add = add i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %add, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwaddu_wv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwaddu_wv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwaddu_wv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %add = add i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %add, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsubu_wv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsubu_wv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsubu_wv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv3 = zext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv4 = zext i16 %7 to i32
  %sub = sub i32 %conv3, %conv4
  %conv5 = trunc i32 %sub to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %9 to i64
  %add.ptr7 = getelementptr i16, ptr %8, i64 %idx.ext6
  store i16 %conv5, ptr %add.ptr7, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsubu_wv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsubu_wv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsubu_wv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %sub = sub i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %sub, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsubu_wv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsubu_wv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsubu_wv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %sub = sub i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %sub, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwadd_wv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwadd_wv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwadd_wv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv3 = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv4 = sext i16 %7 to i32
  %add = add i32 %conv3, %conv4
  %conv5 = trunc i32 %add to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %9 to i64
  %add.ptr7 = getelementptr i16, ptr %8, i64 %idx.ext6
  store i16 %conv5, ptr %add.ptr7, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwadd_wv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwadd_wv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwadd_wv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %add = add i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %add, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwadd_wv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwadd_wv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwadd_wv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %add = add i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %add, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsub_wv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsub_wv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsub_wv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv3 = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv4 = sext i16 %7 to i32
  %sub = sub i32 %conv3, %conv4
  %conv5 = trunc i32 %sub to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %9 to i64
  %add.ptr7 = getelementptr i16, ptr %8, i64 %idx.ext6
  store i16 %conv5, ptr %add.ptr7, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsub_wv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsub_wv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsub_wv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %sub = sub i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %sub, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsub_wv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsub_wv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsub_wv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %sub = sub i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %sub, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwaddu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwaddu_vx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwaddu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv1 = zext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i8
  %conv3 = zext i8 %conv2 to i16
  %conv4 = zext i16 %conv3 to i32
  %add = add i32 %conv1, %conv4
  %conv5 = trunc i32 %add to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %6 to i64
  %add.ptr7 = getelementptr i16, ptr %5, i64 %idx.ext6
  store i16 %conv5, ptr %add.ptr7, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwaddu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwaddu_vx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwaddu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = zext i16 %conv1 to i32
  %add = add i32 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i32, ptr %5, i64 %idx.ext3
  store i32 %add, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwaddu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwaddu_vx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwaddu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i32
  %conv2 = zext i32 %conv1 to i64
  %add = add i64 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i64, ptr %5, i64 %idx.ext3
  store i64 %add, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsubu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsubu_vx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsubu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv1 = zext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i8
  %conv3 = zext i8 %conv2 to i16
  %conv4 = zext i16 %conv3 to i32
  %sub = sub i32 %conv1, %conv4
  %conv5 = trunc i32 %sub to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %6 to i64
  %add.ptr7 = getelementptr i16, ptr %5, i64 %idx.ext6
  store i16 %conv5, ptr %add.ptr7, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsubu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsubu_vx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsubu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = zext i16 %conv1 to i32
  %sub = sub i32 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i32, ptr %5, i64 %idx.ext3
  store i32 %sub, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsubu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsubu_vx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsubu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i32
  %conv2 = zext i32 %conv1 to i64
  %sub = sub i64 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i64, ptr %5, i64 %idx.ext3
  store i64 %sub, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwadd_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwadd_vx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwadd_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv1 = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i8
  %conv3 = sext i8 %conv2 to i16
  %conv4 = sext i16 %conv3 to i32
  %add = add i32 %conv1, %conv4
  %conv5 = trunc i32 %add to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %6 to i64
  %add.ptr7 = getelementptr i16, ptr %5, i64 %idx.ext6
  store i16 %conv5, ptr %add.ptr7, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwadd_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwadd_vx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwadd_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = sext i16 %conv1 to i32
  %add = add i32 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i32, ptr %5, i64 %idx.ext3
  store i32 %add, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwadd_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwadd_vx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwadd_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i32
  %conv2 = sext i32 %conv1 to i64
  %add = add i64 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i64, ptr %5, i64 %idx.ext3
  store i64 %add, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsub_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsub_vx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsub_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv1 = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i8
  %conv3 = sext i8 %conv2 to i16
  %conv4 = sext i16 %conv3 to i32
  %sub = sub i32 %conv1, %conv4
  %conv5 = trunc i32 %sub to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %6 to i64
  %add.ptr7 = getelementptr i16, ptr %5, i64 %idx.ext6
  store i16 %conv5, ptr %add.ptr7, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsub_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsub_vx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsub_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = sext i16 %conv1 to i32
  %sub = sub i32 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i32, ptr %5, i64 %idx.ext3
  store i32 %sub, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsub_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsub_vx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsub_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i32
  %conv2 = sext i32 %conv1 to i64
  %sub = sub i64 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i64, ptr %5, i64 %idx.ext3
  store i64 %sub, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwaddu_wx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwaddu_wx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwaddu_wx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = zext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = zext i8 %conv1 to i16
  %conv3 = zext i16 %conv2 to i32
  %add = add i32 %conv, %conv3
  %conv4 = trunc i32 %add to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %6 to i64
  %add.ptr6 = getelementptr i16, ptr %5, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwaddu_wx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwaddu_wx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwaddu_wx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %conv1 = zext i16 %conv to i32
  %add = add i32 %3, %conv1
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %6 to i64
  %add.ptr3 = getelementptr i32, ptr %5, i64 %idx.ext2
  store i32 %add, ptr %add.ptr3, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwaddu_wx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwaddu_wx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwaddu_wx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %conv1 = zext i32 %conv to i64
  %add = add i64 %3, %conv1
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %6 to i64
  %add.ptr3 = getelementptr i64, ptr %5, i64 %idx.ext2
  store i64 %add, ptr %add.ptr3, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsubu_wx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsubu_wx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsubu_wx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = zext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = zext i8 %conv1 to i16
  %conv3 = zext i16 %conv2 to i32
  %sub = sub i32 %conv, %conv3
  %conv4 = trunc i32 %sub to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %6 to i64
  %add.ptr6 = getelementptr i16, ptr %5, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsubu_wx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsubu_wx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsubu_wx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %conv1 = zext i16 %conv to i32
  %sub = sub i32 %3, %conv1
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %6 to i64
  %add.ptr3 = getelementptr i32, ptr %5, i64 %idx.ext2
  store i32 %sub, ptr %add.ptr3, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsubu_wx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsubu_wx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsubu_wx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %conv1 = zext i32 %conv to i64
  %sub = sub i64 %3, %conv1
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %6 to i64
  %add.ptr3 = getelementptr i64, ptr %5, i64 %idx.ext2
  store i64 %sub, ptr %add.ptr3, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwadd_wx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwadd_wx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwadd_wx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = sext i8 %conv1 to i16
  %conv3 = sext i16 %conv2 to i32
  %add = add i32 %conv, %conv3
  %conv4 = trunc i32 %add to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %6 to i64
  %add.ptr6 = getelementptr i16, ptr %5, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwadd_wx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwadd_wx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwadd_wx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %conv1 = sext i16 %conv to i32
  %add = add i32 %3, %conv1
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %6 to i64
  %add.ptr3 = getelementptr i32, ptr %5, i64 %idx.ext2
  store i32 %add, ptr %add.ptr3, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwadd_wx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwadd_wx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwadd_wx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %conv1 = sext i32 %conv to i64
  %add = add i64 %3, %conv1
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %6 to i64
  %add.ptr3 = getelementptr i64, ptr %5, i64 %idx.ext2
  store i64 %add, ptr %add.ptr3, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsub_wx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsub_wx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsub_wx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = sext i8 %conv1 to i16
  %conv3 = sext i16 %conv2 to i32
  %sub = sub i32 %conv, %conv3
  %conv4 = trunc i32 %sub to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %6 to i64
  %add.ptr6 = getelementptr i16, ptr %5, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsub_wx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsub_wx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsub_wx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %conv1 = sext i16 %conv to i32
  %sub = sub i32 %3, %conv1
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %6 to i64
  %add.ptr3 = getelementptr i32, ptr %5, i64 %idx.ext2
  store i32 %sub, ptr %add.ptr3, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwsub_wx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwsub_wx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwsub_wx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %conv1 = sext i32 %conv to i64
  %sub = sub i64 %3, %conv1
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %6 to i64
  %add.ptr3 = getelementptr i64, ptr %5, i64 %idx.ext2
  store i64 %sub, ptr %add.ptr3, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadc_vvm_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  %carry = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i8, ptr %10, i64 %idx.ext
  %12 = load i8, ptr %add.ptr, align 1
  store i8 %12, ptr %s1, align 1
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext5 = zext i32 %14 to i64
  %add.ptr6 = getelementptr i8, ptr %13, i64 %idx.ext5
  %15 = load i8, ptr %add.ptr6, align 1
  store i8 %15, ptr %s2, align 1
  %16 = load ptr, ptr %v0.addr, align 8
  %17 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %16, i32 noundef %17)
  %conv8 = trunc i32 %call7 to i8
  store i8 %conv8, ptr %carry, align 1
  %18 = load i8, ptr %s2, align 1
  %conv9 = zext i8 %18 to i32
  %19 = load i8, ptr %s1, align 1
  %conv10 = zext i8 %19 to i32
  %add = add i32 %conv9, %conv10
  %20 = load i8, ptr %carry, align 1
  %conv11 = zext i8 %20 to i32
  %add12 = add i32 %add, %conv11
  %conv13 = trunc i32 %add12 to i8
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext14 = zext i32 %22 to i64
  %add.ptr15 = getelementptr i8, ptr %21, i64 %idx.ext14
  store i8 %conv13, ptr %add.ptr15, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !23

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %28 = load i32, ptr %esz, align 4
  %mul = mul i32 %27, %28
  %29 = load i32, ptr %total_elems, align 4
  %30 = load i32, ptr %esz, align 4
  %mul17 = mul i32 %29, %30
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul, i32 noundef %mul17)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vext_get_total_elems(ptr noundef %env, i32 noundef %desc, i32 noundef %esz) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %esz.addr = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %sew = alloca i32, align 4
  %emul = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  store i32 %esz, ptr %esz.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i64 @simd_maxsz(i32 noundef %0)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %vlenb, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vtype = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 7
  %2 = load i64, ptr %vtype, align 16
  %call1 = call i64 @extract64(i64 noundef %2, i32 noundef 3, i32 noundef 3)
  %sh_prom = trunc i64 %call1 to i32
  %shl = shl i32 1, %sh_prom
  store i32 %shl, ptr %sew, align 4
  %3 = load i32, ptr %esz.addr, align 4
  %conv2 = zext i32 %3 to i64
  %call3 = call i32 @ctz64(i64 noundef %conv2)
  %4 = load i32, ptr %sew, align 4
  %conv4 = zext i32 %4 to i64
  %call5 = call i32 @ctz64(i64 noundef %conv4)
  %sub = sub i32 %call3, %call5
  %5 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_lmul(i32 noundef %5)
  %add = add i32 %sub, %call6
  %cmp = icmp slt i32 %add, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i32, ptr %esz.addr, align 4
  %conv8 = zext i32 %6 to i64
  %call9 = call i32 @ctz64(i64 noundef %conv8)
  %7 = load i32, ptr %sew, align 4
  %conv10 = zext i32 %7 to i64
  %call11 = call i32 @ctz64(i64 noundef %conv10)
  %sub12 = sub i32 %call9, %call11
  %8 = load i32, ptr %desc.addr, align 4
  %call13 = call i32 @vext_lmul(i32 noundef %8)
  %add14 = add i32 %sub12, %call13
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %add14, %cond.false ]
  %conv15 = trunc i32 %cond to i8
  store i8 %conv15, ptr %emul, align 1
  %9 = load i32, ptr %vlenb, align 4
  %10 = load i8, ptr %emul, align 1
  %conv16 = sext i8 %10 to i32
  %shl17 = shl i32 %9, %conv16
  %11 = load i32, ptr %esz.addr, align 4
  %div = udiv i32 %shl17, %11
  ret i32 %div
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vext_vta(i32 noundef %desc) #0 {
entry:
  %desc.addr = alloca i32, align 4
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @simd_data(i32 noundef %0)
  %call1 = call i32 @extract32(i32 noundef %call, i32 noundef 4, i32 noundef 1)
  ret i32 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vext_elem_mask(ptr noundef %v0, i32 noundef %index) #0 {
entry:
  %v0.addr = alloca ptr, align 8
  %index.addr = alloca i32, align 4
  %idx = alloca i32, align 4
  %pos = alloca i32, align 4
  store ptr %v0, ptr %v0.addr, align 8
  store i32 %index, ptr %index.addr, align 4
  %0 = load i32, ptr %index.addr, align 4
  %div = sdiv i32 %0, 64
  store i32 %div, ptr %idx, align 4
  %1 = load i32, ptr %index.addr, align 4
  %rem = srem i32 %1, 64
  store i32 %rem, ptr %pos, align 4
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i32, ptr %idx, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr i64, ptr %2, i64 %idxprom
  %4 = load i64, ptr %arrayidx, align 8
  %5 = load i32, ptr %pos, align 4
  %sh_prom = zext i32 %5 to i64
  %shr = lshr i64 %4, %sh_prom
  %and = and i64 %shr, 1
  %conv = trunc i64 %and to i32
  ret i32 %conv
}

declare void @vext_set_elems_1s(ptr noundef, i32 noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadc_vvm_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %carry = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i16, ptr %10, i64 %idx.ext
  %12 = load i16, ptr %add.ptr, align 2
  store i16 %12, ptr %s1, align 2
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext5 = zext i32 %14 to i64
  %add.ptr6 = getelementptr i16, ptr %13, i64 %idx.ext5
  %15 = load i16, ptr %add.ptr6, align 2
  store i16 %15, ptr %s2, align 2
  %16 = load ptr, ptr %v0.addr, align 8
  %17 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %16, i32 noundef %17)
  %conv8 = trunc i32 %call7 to i16
  store i16 %conv8, ptr %carry, align 2
  %18 = load i16, ptr %s2, align 2
  %conv9 = zext i16 %18 to i32
  %19 = load i16, ptr %s1, align 2
  %conv10 = zext i16 %19 to i32
  %add = add i32 %conv9, %conv10
  %20 = load i16, ptr %carry, align 2
  %conv11 = zext i16 %20 to i32
  %add12 = add i32 %add, %conv11
  %conv13 = trunc i32 %add12 to i16
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext14 = zext i32 %22 to i64
  %add.ptr15 = getelementptr i16, ptr %21, i64 %idx.ext14
  store i16 %conv13, ptr %add.ptr15, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !24

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %28 = load i32, ptr %esz, align 4
  %mul = mul i32 %27, %28
  %29 = load i32, ptr %total_elems, align 4
  %30 = load i32, ptr %esz, align 4
  %mul17 = mul i32 %29, %30
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul, i32 noundef %mul17)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadc_vvm_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %carry = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i32, ptr %10, i64 %idx.ext
  %12 = load i32, ptr %add.ptr, align 4
  store i32 %12, ptr %s1, align 4
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext5 = zext i32 %14 to i64
  %add.ptr6 = getelementptr i32, ptr %13, i64 %idx.ext5
  %15 = load i32, ptr %add.ptr6, align 4
  store i32 %15, ptr %s2, align 4
  %16 = load ptr, ptr %v0.addr, align 8
  %17 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %16, i32 noundef %17)
  store i32 %call7, ptr %carry, align 4
  %18 = load i32, ptr %s2, align 4
  %19 = load i32, ptr %s1, align 4
  %add = add i32 %18, %19
  %20 = load i32, ptr %carry, align 4
  %add8 = add i32 %add, %20
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext9 = zext i32 %22 to i64
  %add.ptr10 = getelementptr i32, ptr %21, i64 %idx.ext9
  store i32 %add8, ptr %add.ptr10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !25

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %28 = load i32, ptr %esz, align 4
  %mul = mul i32 %27, %28
  %29 = load i32, ptr %total_elems, align 4
  %30 = load i32, ptr %esz, align 4
  %mul12 = mul i32 %29, %30
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadc_vvm_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %carry = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i64, ptr %10, i64 %idx.ext
  %12 = load i64, ptr %add.ptr, align 8
  store i64 %12, ptr %s1, align 8
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext5 = zext i32 %14 to i64
  %add.ptr6 = getelementptr i64, ptr %13, i64 %idx.ext5
  %15 = load i64, ptr %add.ptr6, align 8
  store i64 %15, ptr %s2, align 8
  %16 = load ptr, ptr %v0.addr, align 8
  %17 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %16, i32 noundef %17)
  %conv8 = sext i32 %call7 to i64
  store i64 %conv8, ptr %carry, align 8
  %18 = load i64, ptr %s2, align 8
  %19 = load i64, ptr %s1, align 8
  %add = add i64 %18, %19
  %20 = load i64, ptr %carry, align 8
  %add9 = add i64 %add, %20
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %22 to i64
  %add.ptr11 = getelementptr i64, ptr %21, i64 %idx.ext10
  store i64 %add9, ptr %add.ptr11, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !26

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %28 = load i32, ptr %esz, align 4
  %mul = mul i32 %27, %28
  %29 = load i32, ptr %total_elems, align 4
  %30 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %29, %30
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul, i32 noundef %mul13)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsbc_vvm_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  %carry = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i8, ptr %10, i64 %idx.ext
  %12 = load i8, ptr %add.ptr, align 1
  store i8 %12, ptr %s1, align 1
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext5 = zext i32 %14 to i64
  %add.ptr6 = getelementptr i8, ptr %13, i64 %idx.ext5
  %15 = load i8, ptr %add.ptr6, align 1
  store i8 %15, ptr %s2, align 1
  %16 = load ptr, ptr %v0.addr, align 8
  %17 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %16, i32 noundef %17)
  %conv8 = trunc i32 %call7 to i8
  store i8 %conv8, ptr %carry, align 1
  %18 = load i8, ptr %s2, align 1
  %conv9 = zext i8 %18 to i32
  %19 = load i8, ptr %s1, align 1
  %conv10 = zext i8 %19 to i32
  %sub = sub i32 %conv9, %conv10
  %20 = load i8, ptr %carry, align 1
  %conv11 = zext i8 %20 to i32
  %sub12 = sub i32 %sub, %conv11
  %conv13 = trunc i32 %sub12 to i8
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext14 = zext i32 %22 to i64
  %add.ptr15 = getelementptr i8, ptr %21, i64 %idx.ext14
  store i8 %conv13, ptr %add.ptr15, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !27

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %28 = load i32, ptr %esz, align 4
  %mul = mul i32 %27, %28
  %29 = load i32, ptr %total_elems, align 4
  %30 = load i32, ptr %esz, align 4
  %mul17 = mul i32 %29, %30
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul, i32 noundef %mul17)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsbc_vvm_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %carry = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i16, ptr %10, i64 %idx.ext
  %12 = load i16, ptr %add.ptr, align 2
  store i16 %12, ptr %s1, align 2
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext5 = zext i32 %14 to i64
  %add.ptr6 = getelementptr i16, ptr %13, i64 %idx.ext5
  %15 = load i16, ptr %add.ptr6, align 2
  store i16 %15, ptr %s2, align 2
  %16 = load ptr, ptr %v0.addr, align 8
  %17 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %16, i32 noundef %17)
  %conv8 = trunc i32 %call7 to i16
  store i16 %conv8, ptr %carry, align 2
  %18 = load i16, ptr %s2, align 2
  %conv9 = zext i16 %18 to i32
  %19 = load i16, ptr %s1, align 2
  %conv10 = zext i16 %19 to i32
  %sub = sub i32 %conv9, %conv10
  %20 = load i16, ptr %carry, align 2
  %conv11 = zext i16 %20 to i32
  %sub12 = sub i32 %sub, %conv11
  %conv13 = trunc i32 %sub12 to i16
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext14 = zext i32 %22 to i64
  %add.ptr15 = getelementptr i16, ptr %21, i64 %idx.ext14
  store i16 %conv13, ptr %add.ptr15, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !28

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %28 = load i32, ptr %esz, align 4
  %mul = mul i32 %27, %28
  %29 = load i32, ptr %total_elems, align 4
  %30 = load i32, ptr %esz, align 4
  %mul17 = mul i32 %29, %30
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul, i32 noundef %mul17)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsbc_vvm_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %carry = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i32, ptr %10, i64 %idx.ext
  %12 = load i32, ptr %add.ptr, align 4
  store i32 %12, ptr %s1, align 4
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext5 = zext i32 %14 to i64
  %add.ptr6 = getelementptr i32, ptr %13, i64 %idx.ext5
  %15 = load i32, ptr %add.ptr6, align 4
  store i32 %15, ptr %s2, align 4
  %16 = load ptr, ptr %v0.addr, align 8
  %17 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %16, i32 noundef %17)
  store i32 %call7, ptr %carry, align 4
  %18 = load i32, ptr %s2, align 4
  %19 = load i32, ptr %s1, align 4
  %sub = sub i32 %18, %19
  %20 = load i32, ptr %carry, align 4
  %sub8 = sub i32 %sub, %20
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext9 = zext i32 %22 to i64
  %add.ptr10 = getelementptr i32, ptr %21, i64 %idx.ext9
  store i32 %sub8, ptr %add.ptr10, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !29

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %28 = load i32, ptr %esz, align 4
  %mul = mul i32 %27, %28
  %29 = load i32, ptr %total_elems, align 4
  %30 = load i32, ptr %esz, align 4
  %mul12 = mul i32 %29, %30
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsbc_vvm_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %carry = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i64, ptr %10, i64 %idx.ext
  %12 = load i64, ptr %add.ptr, align 8
  store i64 %12, ptr %s1, align 8
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext5 = zext i32 %14 to i64
  %add.ptr6 = getelementptr i64, ptr %13, i64 %idx.ext5
  %15 = load i64, ptr %add.ptr6, align 8
  store i64 %15, ptr %s2, align 8
  %16 = load ptr, ptr %v0.addr, align 8
  %17 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %16, i32 noundef %17)
  %conv8 = sext i32 %call7 to i64
  store i64 %conv8, ptr %carry, align 8
  %18 = load i64, ptr %s2, align 8
  %19 = load i64, ptr %s1, align 8
  %sub = sub i64 %18, %19
  %20 = load i64, ptr %carry, align 8
  %sub9 = sub i64 %sub, %20
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %22 to i64
  %add.ptr11 = getelementptr i64, ptr %21, i64 %idx.ext10
  store i64 %sub9, ptr %add.ptr11, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !30

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %28 = load i32, ptr %esz, align 4
  %mul = mul i32 %27, %28
  %29 = load i32, ptr %total_elems, align 4
  %30 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %29, %30
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul, i32 noundef %mul13)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadc_vxm_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  %carry = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i8, ptr %10, i64 %idx.ext
  %12 = load i8, ptr %add.ptr, align 1
  store i8 %12, ptr %s2, align 1
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %conv6 = trunc i32 %call5 to i8
  store i8 %conv6, ptr %carry, align 1
  %15 = load i8, ptr %s2, align 1
  %conv7 = zext i8 %15 to i32
  %16 = load i64, ptr %s1.addr, align 8
  %conv8 = trunc i64 %16 to i8
  %conv9 = zext i8 %conv8 to i32
  %add = add i32 %conv7, %conv9
  %17 = load i8, ptr %carry, align 1
  %conv10 = zext i8 %17 to i32
  %add11 = add i32 %add, %conv10
  %conv12 = trunc i32 %add11 to i8
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idx.ext13 = zext i32 %19 to i64
  %add.ptr14 = getelementptr i8, ptr %18, i64 %idx.ext13
  store i8 %conv12, ptr %add.ptr14, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !31

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %vta, align 4
  %24 = load i32, ptr %vl, align 4
  %25 = load i32, ptr %esz, align 4
  %mul = mul i32 %24, %25
  %26 = load i32, ptr %total_elems, align 4
  %27 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %26, %27
  call void @vext_set_elems_1s(ptr noundef %22, i32 noundef %23, i32 noundef %mul, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadc_vxm_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  %carry = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i16, ptr %10, i64 %idx.ext
  %12 = load i16, ptr %add.ptr, align 2
  store i16 %12, ptr %s2, align 2
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %conv6 = trunc i32 %call5 to i16
  store i16 %conv6, ptr %carry, align 2
  %15 = load i16, ptr %s2, align 2
  %conv7 = zext i16 %15 to i32
  %16 = load i64, ptr %s1.addr, align 8
  %conv8 = trunc i64 %16 to i16
  %conv9 = zext i16 %conv8 to i32
  %add = add i32 %conv7, %conv9
  %17 = load i16, ptr %carry, align 2
  %conv10 = zext i16 %17 to i32
  %add11 = add i32 %add, %conv10
  %conv12 = trunc i32 %add11 to i16
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idx.ext13 = zext i32 %19 to i64
  %add.ptr14 = getelementptr i16, ptr %18, i64 %idx.ext13
  store i16 %conv12, ptr %add.ptr14, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !32

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %vta, align 4
  %24 = load i32, ptr %vl, align 4
  %25 = load i32, ptr %esz, align 4
  %mul = mul i32 %24, %25
  %26 = load i32, ptr %total_elems, align 4
  %27 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %26, %27
  call void @vext_set_elems_1s(ptr noundef %22, i32 noundef %23, i32 noundef %mul, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadc_vxm_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  %carry = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i32, ptr %10, i64 %idx.ext
  %12 = load i32, ptr %add.ptr, align 4
  store i32 %12, ptr %s2, align 4
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  store i32 %call5, ptr %carry, align 4
  %15 = load i32, ptr %s2, align 4
  %16 = load i64, ptr %s1.addr, align 8
  %conv6 = trunc i64 %16 to i32
  %add = add i32 %15, %conv6
  %17 = load i32, ptr %carry, align 4
  %add7 = add i32 %add, %17
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %19 to i64
  %add.ptr9 = getelementptr i32, ptr %18, i64 %idx.ext8
  store i32 %add7, ptr %add.ptr9, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !33

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %vta, align 4
  %24 = load i32, ptr %vl, align 4
  %25 = load i32, ptr %esz, align 4
  %mul = mul i32 %24, %25
  %26 = load i32, ptr %total_elems, align 4
  %27 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %26, %27
  call void @vext_set_elems_1s(ptr noundef %22, i32 noundef %23, i32 noundef %mul, i32 noundef %mul11)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vadc_vxm_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  %carry = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i64, ptr %10, i64 %idx.ext
  %12 = load i64, ptr %add.ptr, align 8
  store i64 %12, ptr %s2, align 8
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %conv6 = sext i32 %call5 to i64
  store i64 %conv6, ptr %carry, align 8
  %15 = load i64, ptr %s2, align 8
  %16 = load i64, ptr %s1.addr, align 8
  %add = add i64 %15, %16
  %17 = load i64, ptr %carry, align 8
  %add7 = add i64 %add, %17
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %19 to i64
  %add.ptr9 = getelementptr i64, ptr %18, i64 %idx.ext8
  store i64 %add7, ptr %add.ptr9, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !34

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %vta, align 4
  %24 = load i32, ptr %vl, align 4
  %25 = load i32, ptr %esz, align 4
  %mul = mul i32 %24, %25
  %26 = load i32, ptr %total_elems, align 4
  %27 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %26, %27
  call void @vext_set_elems_1s(ptr noundef %22, i32 noundef %23, i32 noundef %mul, i32 noundef %mul11)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsbc_vxm_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  %carry = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i8, ptr %10, i64 %idx.ext
  %12 = load i8, ptr %add.ptr, align 1
  store i8 %12, ptr %s2, align 1
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %conv6 = trunc i32 %call5 to i8
  store i8 %conv6, ptr %carry, align 1
  %15 = load i8, ptr %s2, align 1
  %conv7 = zext i8 %15 to i32
  %16 = load i64, ptr %s1.addr, align 8
  %conv8 = trunc i64 %16 to i8
  %conv9 = zext i8 %conv8 to i32
  %sub = sub i32 %conv7, %conv9
  %17 = load i8, ptr %carry, align 1
  %conv10 = zext i8 %17 to i32
  %sub11 = sub i32 %sub, %conv10
  %conv12 = trunc i32 %sub11 to i8
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idx.ext13 = zext i32 %19 to i64
  %add.ptr14 = getelementptr i8, ptr %18, i64 %idx.ext13
  store i8 %conv12, ptr %add.ptr14, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !35

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %vta, align 4
  %24 = load i32, ptr %vl, align 4
  %25 = load i32, ptr %esz, align 4
  %mul = mul i32 %24, %25
  %26 = load i32, ptr %total_elems, align 4
  %27 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %26, %27
  call void @vext_set_elems_1s(ptr noundef %22, i32 noundef %23, i32 noundef %mul, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsbc_vxm_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  %carry = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i16, ptr %10, i64 %idx.ext
  %12 = load i16, ptr %add.ptr, align 2
  store i16 %12, ptr %s2, align 2
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %conv6 = trunc i32 %call5 to i16
  store i16 %conv6, ptr %carry, align 2
  %15 = load i16, ptr %s2, align 2
  %conv7 = zext i16 %15 to i32
  %16 = load i64, ptr %s1.addr, align 8
  %conv8 = trunc i64 %16 to i16
  %conv9 = zext i16 %conv8 to i32
  %sub = sub i32 %conv7, %conv9
  %17 = load i16, ptr %carry, align 2
  %conv10 = zext i16 %17 to i32
  %sub11 = sub i32 %sub, %conv10
  %conv12 = trunc i32 %sub11 to i16
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idx.ext13 = zext i32 %19 to i64
  %add.ptr14 = getelementptr i16, ptr %18, i64 %idx.ext13
  store i16 %conv12, ptr %add.ptr14, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !36

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %vta, align 4
  %24 = load i32, ptr %vl, align 4
  %25 = load i32, ptr %esz, align 4
  %mul = mul i32 %24, %25
  %26 = load i32, ptr %total_elems, align 4
  %27 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %26, %27
  call void @vext_set_elems_1s(ptr noundef %22, i32 noundef %23, i32 noundef %mul, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsbc_vxm_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  %carry = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i32, ptr %10, i64 %idx.ext
  %12 = load i32, ptr %add.ptr, align 4
  store i32 %12, ptr %s2, align 4
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  store i32 %call5, ptr %carry, align 4
  %15 = load i32, ptr %s2, align 4
  %16 = load i64, ptr %s1.addr, align 8
  %conv6 = trunc i64 %16 to i32
  %sub = sub i32 %15, %conv6
  %17 = load i32, ptr %carry, align 4
  %sub7 = sub i32 %sub, %17
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %19 to i64
  %add.ptr9 = getelementptr i32, ptr %18, i64 %idx.ext8
  store i32 %sub7, ptr %add.ptr9, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !37

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %vta, align 4
  %24 = load i32, ptr %vl, align 4
  %25 = load i32, ptr %esz, align 4
  %mul = mul i32 %24, %25
  %26 = load i32, ptr %total_elems, align 4
  %27 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %26, %27
  call void @vext_set_elems_1s(ptr noundef %22, i32 noundef %23, i32 noundef %mul, i32 noundef %mul11)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsbc_vxm_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  %carry = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i64, ptr %10, i64 %idx.ext
  %12 = load i64, ptr %add.ptr, align 8
  store i64 %12, ptr %s2, align 8
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %conv6 = sext i32 %call5 to i64
  store i64 %conv6, ptr %carry, align 8
  %15 = load i64, ptr %s2, align 8
  %16 = load i64, ptr %s1.addr, align 8
  %sub = sub i64 %15, %16
  %17 = load i64, ptr %carry, align 8
  %sub7 = sub i64 %sub, %17
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %19 to i64
  %add.ptr9 = getelementptr i64, ptr %18, i64 %idx.ext8
  store i64 %sub7, ptr %add.ptr9, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !38

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %vta, align 4
  %24 = load i32, ptr %vl, align 4
  %25 = load i32, ptr %esz, align 4
  %mul = mul i32 %24, %25
  %26 = load i32, ptr %total_elems, align 4
  %27 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %26, %27
  call void @vext_set_elems_1s(ptr noundef %22, i32 noundef %23, i32 noundef %mul, i32 noundef %mul11)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadc_vvm_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  %carry = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i8, ptr %10, i64 %idx.ext
  %12 = load i8, ptr %add.ptr, align 1
  store i8 %12, ptr %s1, align 1
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext7 = zext i32 %14 to i64
  %add.ptr8 = getelementptr i8, ptr %13, i64 %idx.ext7
  %15 = load i8, ptr %add.ptr8, align 1
  store i8 %15, ptr %s2, align 1
  %16 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %17 = load ptr, ptr %v0.addr, align 8
  %18 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %17, i32 noundef %18)
  %tobool10 = icmp ne i32 %call9, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %19 = phi i1 [ false, %for.body ], [ %tobool10, %land.rhs ]
  %land.ext = zext i1 %19 to i32
  %conv11 = trunc i32 %land.ext to i8
  store i8 %conv11, ptr %carry, align 1
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i8, ptr %carry, align 1
  %conv12 = zext i8 %22 to i32
  %tobool13 = icmp ne i32 %conv12, 0
  br i1 %tobool13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %23 = load i8, ptr %s2, align 1
  %conv14 = zext i8 %23 to i32
  %24 = load i8, ptr %s1, align 1
  %conv15 = zext i8 %24 to i32
  %add = add i32 %conv14, %conv15
  %add16 = add i32 %add, 1
  %conv17 = trunc i32 %add16 to i8
  %conv18 = zext i8 %conv17 to i32
  %25 = load i8, ptr %s2, align 1
  %conv19 = zext i8 %25 to i32
  %cmp20 = icmp sle i32 %conv18, %conv19
  %conv21 = zext i1 %cmp20 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %26 = load i8, ptr %s2, align 1
  %conv22 = zext i8 %26 to i32
  %27 = load i8, ptr %s1, align 1
  %conv23 = zext i8 %27 to i32
  %add24 = add i32 %conv22, %conv23
  %conv25 = trunc i32 %add24 to i8
  %conv26 = zext i8 %conv25 to i32
  %28 = load i8, ptr %s2, align 1
  %conv27 = zext i8 %28 to i32
  %cmp28 = icmp slt i32 %conv26, %conv27
  %conv29 = zext i1 %cmp28 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv21, %cond.true ], [ %conv29, %cond.false ]
  %conv30 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv30)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %29 = load i32, ptr %i, align 4
  %inc = add i32 %29, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !39

for.end:                                          ; preds = %for.cond
  %30 = load ptr, ptr %env.addr, align 8
  %vstart31 = getelementptr inbounds %struct.CPUArchState, ptr %30, i32 0, i32 6
  store i64 0, ptr %vstart31, align 8
  %31 = load i32, ptr %vta_all_1s, align 4
  %tobool32 = icmp ne i32 %31, 0
  br i1 %tobool32, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc37, %if.then
  %32 = load i32, ptr %i, align 4
  %33 = load i32, ptr %total_elems, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end39

for.body36:                                       ; preds = %for.cond33
  %34 = load ptr, ptr %vd.addr, align 8
  %35 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %34, i32 noundef %35, i8 noundef zeroext 1)
  br label %for.inc37

for.inc37:                                        ; preds = %for.body36
  %36 = load i32, ptr %i, align 4
  %inc38 = add i32 %36, 1
  store i32 %inc38, ptr %i, align 4
  br label %for.cond33, !llvm.loop !40

for.end39:                                        ; preds = %for.cond33
  br label %if.end

if.end:                                           ; preds = %for.end39, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @riscv_cpu_cfg(ptr noundef %env) #0 {
entry:
  %env.addr = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %env.addr, align 8
  %call = call ptr @env_archcpu(ptr noundef %0)
  %cfg = getelementptr inbounds %struct.ArchCPU, ptr %call, i32 0, i32 4
  ret ptr %cfg
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vext_vta_all_1s(i32 noundef %desc) #0 {
entry:
  %desc.addr = alloca i32, align 4
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @simd_data(i32 noundef %0)
  %call1 = call i32 @extract32(i32 noundef %call, i32 noundef 5, i32 noundef 1)
  ret i32 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vext_set_elem_mask(ptr noundef %v0, i32 noundef %index, i8 noundef zeroext %value) #0 {
entry:
  %v0.addr = alloca ptr, align 8
  %index.addr = alloca i32, align 4
  %value.addr = alloca i8, align 1
  %idx = alloca i32, align 4
  %pos = alloca i32, align 4
  %old = alloca i64, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i32 %index, ptr %index.addr, align 4
  store i8 %value, ptr %value.addr, align 1
  %0 = load i32, ptr %index.addr, align 4
  %div = sdiv i32 %0, 64
  store i32 %div, ptr %idx, align 4
  %1 = load i32, ptr %index.addr, align 4
  %rem = srem i32 %1, 64
  store i32 %rem, ptr %pos, align 4
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load i32, ptr %idx, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr i64, ptr %2, i64 %idxprom
  %4 = load i64, ptr %arrayidx, align 8
  store i64 %4, ptr %old, align 8
  %5 = load i64, ptr %old, align 8
  %6 = load i32, ptr %pos, align 4
  %7 = load i8, ptr %value.addr, align 1
  %conv = zext i8 %7 to i64
  %call = call i64 @deposit64(i64 noundef %5, i32 noundef %6, i32 noundef 1, i64 noundef %conv)
  %8 = load ptr, ptr %v0.addr, align 8
  %9 = load i32, ptr %idx, align 4
  %idxprom1 = sext i32 %9 to i64
  %arrayidx2 = getelementptr i64, ptr %8, i64 %idxprom1
  store i64 %call, ptr %arrayidx2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadc_vvm_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %carry = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i16, ptr %10, i64 %idx.ext
  %12 = load i16, ptr %add.ptr, align 2
  store i16 %12, ptr %s1, align 2
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext7 = zext i32 %14 to i64
  %add.ptr8 = getelementptr i16, ptr %13, i64 %idx.ext7
  %15 = load i16, ptr %add.ptr8, align 2
  store i16 %15, ptr %s2, align 2
  %16 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %17 = load ptr, ptr %v0.addr, align 8
  %18 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %17, i32 noundef %18)
  %tobool10 = icmp ne i32 %call9, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %19 = phi i1 [ false, %for.body ], [ %tobool10, %land.rhs ]
  %land.ext = zext i1 %19 to i32
  %conv11 = trunc i32 %land.ext to i16
  store i16 %conv11, ptr %carry, align 2
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %carry, align 2
  %conv12 = zext i16 %22 to i32
  %tobool13 = icmp ne i32 %conv12, 0
  br i1 %tobool13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %23 = load i16, ptr %s2, align 2
  %conv14 = zext i16 %23 to i32
  %24 = load i16, ptr %s1, align 2
  %conv15 = zext i16 %24 to i32
  %add = add i32 %conv14, %conv15
  %add16 = add i32 %add, 1
  %conv17 = trunc i32 %add16 to i16
  %conv18 = zext i16 %conv17 to i32
  %25 = load i16, ptr %s2, align 2
  %conv19 = zext i16 %25 to i32
  %cmp20 = icmp sle i32 %conv18, %conv19
  %conv21 = zext i1 %cmp20 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %26 = load i16, ptr %s2, align 2
  %conv22 = zext i16 %26 to i32
  %27 = load i16, ptr %s1, align 2
  %conv23 = zext i16 %27 to i32
  %add24 = add i32 %conv22, %conv23
  %conv25 = trunc i32 %add24 to i16
  %conv26 = zext i16 %conv25 to i32
  %28 = load i16, ptr %s2, align 2
  %conv27 = zext i16 %28 to i32
  %cmp28 = icmp slt i32 %conv26, %conv27
  %conv29 = zext i1 %cmp28 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv21, %cond.true ], [ %conv29, %cond.false ]
  %conv30 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv30)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %29 = load i32, ptr %i, align 4
  %inc = add i32 %29, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !41

for.end:                                          ; preds = %for.cond
  %30 = load ptr, ptr %env.addr, align 8
  %vstart31 = getelementptr inbounds %struct.CPUArchState, ptr %30, i32 0, i32 6
  store i64 0, ptr %vstart31, align 8
  %31 = load i32, ptr %vta_all_1s, align 4
  %tobool32 = icmp ne i32 %31, 0
  br i1 %tobool32, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc37, %if.then
  %32 = load i32, ptr %i, align 4
  %33 = load i32, ptr %total_elems, align 4
  %cmp34 = icmp ult i32 %32, %33
  br i1 %cmp34, label %for.body36, label %for.end39

for.body36:                                       ; preds = %for.cond33
  %34 = load ptr, ptr %vd.addr, align 8
  %35 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %34, i32 noundef %35, i8 noundef zeroext 1)
  br label %for.inc37

for.inc37:                                        ; preds = %for.body36
  %36 = load i32, ptr %i, align 4
  %inc38 = add i32 %36, 1
  store i32 %inc38, ptr %i, align 4
  br label %for.cond33, !llvm.loop !42

for.end39:                                        ; preds = %for.cond33
  br label %if.end

if.end:                                           ; preds = %for.end39, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadc_vvm_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %carry = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i32, ptr %10, i64 %idx.ext
  %12 = load i32, ptr %add.ptr, align 4
  store i32 %12, ptr %s1, align 4
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext7 = zext i32 %14 to i64
  %add.ptr8 = getelementptr i32, ptr %13, i64 %idx.ext7
  %15 = load i32, ptr %add.ptr8, align 4
  store i32 %15, ptr %s2, align 4
  %16 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %17 = load ptr, ptr %v0.addr, align 8
  %18 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %17, i32 noundef %18)
  %tobool10 = icmp ne i32 %call9, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %19 = phi i1 [ false, %for.body ], [ %tobool10, %land.rhs ]
  %land.ext = zext i1 %19 to i32
  store i32 %land.ext, ptr %carry, align 4
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %carry, align 4
  %tobool11 = icmp ne i32 %22, 0
  br i1 %tobool11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %23 = load i32, ptr %s2, align 4
  %24 = load i32, ptr %s1, align 4
  %add = add i32 %23, %24
  %add12 = add i32 %add, 1
  %25 = load i32, ptr %s2, align 4
  %cmp13 = icmp ule i32 %add12, %25
  %conv14 = zext i1 %cmp13 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %26 = load i32, ptr %s2, align 4
  %27 = load i32, ptr %s1, align 4
  %add15 = add i32 %26, %27
  %28 = load i32, ptr %s2, align 4
  %cmp16 = icmp ult i32 %add15, %28
  %conv17 = zext i1 %cmp16 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv14, %cond.true ], [ %conv17, %cond.false ]
  %conv18 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %29 = load i32, ptr %i, align 4
  %inc = add i32 %29, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !43

for.end:                                          ; preds = %for.cond
  %30 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %30, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %31 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %31, 0
  br i1 %tobool20, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then
  %32 = load i32, ptr %i, align 4
  %33 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %32, %33
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %34 = load ptr, ptr %vd.addr, align 8
  %35 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %34, i32 noundef %35, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %36 = load i32, ptr %i, align 4
  %inc26 = add i32 %36, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !44

for.end27:                                        ; preds = %for.cond21
  br label %if.end

if.end:                                           ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadc_vvm_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %carry = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i64, ptr %10, i64 %idx.ext
  %12 = load i64, ptr %add.ptr, align 8
  store i64 %12, ptr %s1, align 8
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext7 = zext i32 %14 to i64
  %add.ptr8 = getelementptr i64, ptr %13, i64 %idx.ext7
  %15 = load i64, ptr %add.ptr8, align 8
  store i64 %15, ptr %s2, align 8
  %16 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %17 = load ptr, ptr %v0.addr, align 8
  %18 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %17, i32 noundef %18)
  %tobool10 = icmp ne i32 %call9, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %19 = phi i1 [ false, %for.body ], [ %tobool10, %land.rhs ]
  %land.ext = zext i1 %19 to i32
  %conv11 = sext i32 %land.ext to i64
  store i64 %conv11, ptr %carry, align 8
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %carry, align 8
  %tobool12 = icmp ne i64 %22, 0
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %23 = load i64, ptr %s2, align 8
  %24 = load i64, ptr %s1, align 8
  %add = add i64 %23, %24
  %add13 = add i64 %add, 1
  %25 = load i64, ptr %s2, align 8
  %cmp14 = icmp ule i64 %add13, %25
  %conv15 = zext i1 %cmp14 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %26 = load i64, ptr %s2, align 8
  %27 = load i64, ptr %s1, align 8
  %add16 = add i64 %26, %27
  %28 = load i64, ptr %s2, align 8
  %cmp17 = icmp ult i64 %add16, %28
  %conv18 = zext i1 %cmp17 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv15, %cond.true ], [ %conv18, %cond.false ]
  %conv19 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %29 = load i32, ptr %i, align 4
  %inc = add i32 %29, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !45

for.end:                                          ; preds = %for.cond
  %30 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %30, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %31 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %31, 0
  br i1 %tobool21, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then
  %32 = load i32, ptr %i, align 4
  %33 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %32, %33
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %34 = load ptr, ptr %vd.addr, align 8
  %35 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %34, i32 noundef %35, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %36 = load i32, ptr %i, align 4
  %inc27 = add i32 %36, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !46

for.end28:                                        ; preds = %for.cond22
  br label %if.end

if.end:                                           ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsbc_vvm_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  %carry = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i8, ptr %10, i64 %idx.ext
  %12 = load i8, ptr %add.ptr, align 1
  store i8 %12, ptr %s1, align 1
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext7 = zext i32 %14 to i64
  %add.ptr8 = getelementptr i8, ptr %13, i64 %idx.ext7
  %15 = load i8, ptr %add.ptr8, align 1
  store i8 %15, ptr %s2, align 1
  %16 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %17 = load ptr, ptr %v0.addr, align 8
  %18 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %17, i32 noundef %18)
  %tobool10 = icmp ne i32 %call9, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %19 = phi i1 [ false, %for.body ], [ %tobool10, %land.rhs ]
  %land.ext = zext i1 %19 to i32
  %conv11 = trunc i32 %land.ext to i8
  store i8 %conv11, ptr %carry, align 1
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i8, ptr %carry, align 1
  %conv12 = zext i8 %22 to i32
  %tobool13 = icmp ne i32 %conv12, 0
  br i1 %tobool13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %23 = load i8, ptr %s2, align 1
  %conv14 = zext i8 %23 to i32
  %24 = load i8, ptr %s1, align 1
  %conv15 = zext i8 %24 to i32
  %cmp16 = icmp sle i32 %conv14, %conv15
  %conv17 = zext i1 %cmp16 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %25 = load i8, ptr %s2, align 1
  %conv18 = zext i8 %25 to i32
  %26 = load i8, ptr %s1, align 1
  %conv19 = zext i8 %26 to i32
  %cmp20 = icmp slt i32 %conv18, %conv19
  %conv21 = zext i1 %cmp20 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv17, %cond.true ], [ %conv21, %cond.false ]
  %conv22 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv22)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !47

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart23 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart23, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool24 = icmp ne i32 %29, 0
  br i1 %tobool24, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond25

for.cond25:                                       ; preds = %for.inc29, %if.then
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp26 = icmp ult i32 %30, %31
  br i1 %cmp26, label %for.body28, label %for.end31

for.body28:                                       ; preds = %for.cond25
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc29

for.inc29:                                        ; preds = %for.body28
  %34 = load i32, ptr %i, align 4
  %inc30 = add i32 %34, 1
  store i32 %inc30, ptr %i, align 4
  br label %for.cond25, !llvm.loop !48

for.end31:                                        ; preds = %for.cond25
  br label %if.end

if.end:                                           ; preds = %for.end31, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsbc_vvm_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %carry = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i16, ptr %10, i64 %idx.ext
  %12 = load i16, ptr %add.ptr, align 2
  store i16 %12, ptr %s1, align 2
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext7 = zext i32 %14 to i64
  %add.ptr8 = getelementptr i16, ptr %13, i64 %idx.ext7
  %15 = load i16, ptr %add.ptr8, align 2
  store i16 %15, ptr %s2, align 2
  %16 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %17 = load ptr, ptr %v0.addr, align 8
  %18 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %17, i32 noundef %18)
  %tobool10 = icmp ne i32 %call9, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %19 = phi i1 [ false, %for.body ], [ %tobool10, %land.rhs ]
  %land.ext = zext i1 %19 to i32
  %conv11 = trunc i32 %land.ext to i16
  store i16 %conv11, ptr %carry, align 2
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %carry, align 2
  %conv12 = zext i16 %22 to i32
  %tobool13 = icmp ne i32 %conv12, 0
  br i1 %tobool13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %23 = load i16, ptr %s2, align 2
  %conv14 = zext i16 %23 to i32
  %24 = load i16, ptr %s1, align 2
  %conv15 = zext i16 %24 to i32
  %cmp16 = icmp sle i32 %conv14, %conv15
  %conv17 = zext i1 %cmp16 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %25 = load i16, ptr %s2, align 2
  %conv18 = zext i16 %25 to i32
  %26 = load i16, ptr %s1, align 2
  %conv19 = zext i16 %26 to i32
  %cmp20 = icmp slt i32 %conv18, %conv19
  %conv21 = zext i1 %cmp20 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv17, %cond.true ], [ %conv21, %cond.false ]
  %conv22 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv22)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !49

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart23 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart23, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool24 = icmp ne i32 %29, 0
  br i1 %tobool24, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond25

for.cond25:                                       ; preds = %for.inc29, %if.then
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp26 = icmp ult i32 %30, %31
  br i1 %cmp26, label %for.body28, label %for.end31

for.body28:                                       ; preds = %for.cond25
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc29

for.inc29:                                        ; preds = %for.body28
  %34 = load i32, ptr %i, align 4
  %inc30 = add i32 %34, 1
  store i32 %inc30, ptr %i, align 4
  br label %for.cond25, !llvm.loop !50

for.end31:                                        ; preds = %for.cond25
  br label %if.end

if.end:                                           ; preds = %for.end31, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsbc_vvm_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %carry = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i32, ptr %10, i64 %idx.ext
  %12 = load i32, ptr %add.ptr, align 4
  store i32 %12, ptr %s1, align 4
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext7 = zext i32 %14 to i64
  %add.ptr8 = getelementptr i32, ptr %13, i64 %idx.ext7
  %15 = load i32, ptr %add.ptr8, align 4
  store i32 %15, ptr %s2, align 4
  %16 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %17 = load ptr, ptr %v0.addr, align 8
  %18 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %17, i32 noundef %18)
  %tobool10 = icmp ne i32 %call9, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %19 = phi i1 [ false, %for.body ], [ %tobool10, %land.rhs ]
  %land.ext = zext i1 %19 to i32
  store i32 %land.ext, ptr %carry, align 4
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %carry, align 4
  %tobool11 = icmp ne i32 %22, 0
  br i1 %tobool11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %23 = load i32, ptr %s2, align 4
  %24 = load i32, ptr %s1, align 4
  %cmp12 = icmp ule i32 %23, %24
  %conv13 = zext i1 %cmp12 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %25 = load i32, ptr %s2, align 4
  %26 = load i32, ptr %s1, align 4
  %cmp14 = icmp ult i32 %25, %26
  %conv15 = zext i1 %cmp14 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv13, %cond.true ], [ %conv15, %cond.false ]
  %conv16 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !51

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %29, 0
  br i1 %tobool18, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %30, %31
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %34 = load i32, ptr %i, align 4
  %inc24 = add i32 %34, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !52

for.end25:                                        ; preds = %for.cond19
  br label %if.end

if.end:                                           ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsbc_vvm_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %carry = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i64, ptr %10, i64 %idx.ext
  %12 = load i64, ptr %add.ptr, align 8
  store i64 %12, ptr %s1, align 8
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idx.ext7 = zext i32 %14 to i64
  %add.ptr8 = getelementptr i64, ptr %13, i64 %idx.ext7
  %15 = load i64, ptr %add.ptr8, align 8
  store i64 %15, ptr %s2, align 8
  %16 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %17 = load ptr, ptr %v0.addr, align 8
  %18 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %17, i32 noundef %18)
  %tobool10 = icmp ne i32 %call9, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %19 = phi i1 [ false, %for.body ], [ %tobool10, %land.rhs ]
  %land.ext = zext i1 %19 to i32
  %conv11 = sext i32 %land.ext to i64
  store i64 %conv11, ptr %carry, align 8
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %carry, align 8
  %tobool12 = icmp ne i64 %22, 0
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %23 = load i64, ptr %s2, align 8
  %24 = load i64, ptr %s1, align 8
  %cmp13 = icmp ule i64 %23, %24
  %conv14 = zext i1 %cmp13 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %25 = load i64, ptr %s2, align 8
  %26 = load i64, ptr %s1, align 8
  %cmp15 = icmp ult i64 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv14, %cond.true ], [ %conv16, %cond.false ]
  %conv17 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !53

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %30, %31
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %34 = load i32, ptr %i, align 4
  %inc25 = add i32 %34, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !54

for.end26:                                        ; preds = %for.cond20
  br label %if.end

if.end:                                           ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadc_vxm_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  %carry = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i8, ptr %10, i64 %idx.ext
  %12 = load i8, ptr %add.ptr, align 1
  store i8 %12, ptr %s2, align 1
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool8 = icmp ne i32 %call7, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %16 = phi i1 [ false, %for.body ], [ %tobool8, %land.rhs ]
  %land.ext = zext i1 %16 to i32
  %conv9 = trunc i32 %land.ext to i8
  store i8 %conv9, ptr %carry, align 1
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %i, align 4
  %19 = load i8, ptr %carry, align 1
  %conv10 = zext i8 %19 to i32
  %tobool11 = icmp ne i32 %conv10, 0
  br i1 %tobool11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %20 = load i8, ptr %s2, align 1
  %conv12 = zext i8 %20 to i32
  %21 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %21 to i8
  %conv14 = zext i8 %conv13 to i32
  %add = add i32 %conv12, %conv14
  %add15 = add i32 %add, 1
  %conv16 = trunc i32 %add15 to i8
  %conv17 = zext i8 %conv16 to i32
  %22 = load i8, ptr %s2, align 1
  %conv18 = zext i8 %22 to i32
  %cmp19 = icmp sle i32 %conv17, %conv18
  %conv20 = zext i1 %cmp19 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %23 = load i8, ptr %s2, align 1
  %conv21 = zext i8 %23 to i32
  %24 = load i64, ptr %s1.addr, align 8
  %conv22 = trunc i64 %24 to i8
  %conv23 = zext i8 %conv22 to i32
  %add24 = add i32 %conv21, %conv23
  %conv25 = trunc i32 %add24 to i8
  %conv26 = zext i8 %conv25 to i32
  %25 = load i8, ptr %s2, align 1
  %conv27 = zext i8 %25 to i32
  %cmp28 = icmp slt i32 %conv26, %conv27
  %conv29 = zext i1 %cmp28 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv20, %cond.true ], [ %conv29, %cond.false ]
  %conv30 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %17, i32 noundef %18, i8 noundef zeroext %conv30)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !55

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart31 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart31, align 8
  %28 = load i32, ptr %vta_all_1s, align 4
  %tobool32 = icmp ne i32 %28, 0
  br i1 %tobool32, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc37, %if.then
  %29 = load i32, ptr %i, align 4
  %30 = load i32, ptr %total_elems, align 4
  %cmp34 = icmp ult i32 %29, %30
  br i1 %cmp34, label %for.body36, label %for.end39

for.body36:                                       ; preds = %for.cond33
  %31 = load ptr, ptr %vd.addr, align 8
  %32 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %31, i32 noundef %32, i8 noundef zeroext 1)
  br label %for.inc37

for.inc37:                                        ; preds = %for.body36
  %33 = load i32, ptr %i, align 4
  %inc38 = add i32 %33, 1
  store i32 %inc38, ptr %i, align 4
  br label %for.cond33, !llvm.loop !56

for.end39:                                        ; preds = %for.cond33
  br label %if.end

if.end:                                           ; preds = %for.end39, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadc_vxm_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  %carry = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i16, ptr %10, i64 %idx.ext
  %12 = load i16, ptr %add.ptr, align 2
  store i16 %12, ptr %s2, align 2
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool8 = icmp ne i32 %call7, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %16 = phi i1 [ false, %for.body ], [ %tobool8, %land.rhs ]
  %land.ext = zext i1 %16 to i32
  %conv9 = trunc i32 %land.ext to i16
  store i16 %conv9, ptr %carry, align 2
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %i, align 4
  %19 = load i16, ptr %carry, align 2
  %conv10 = zext i16 %19 to i32
  %tobool11 = icmp ne i32 %conv10, 0
  br i1 %tobool11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %20 = load i16, ptr %s2, align 2
  %conv12 = zext i16 %20 to i32
  %21 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %21 to i16
  %conv14 = zext i16 %conv13 to i32
  %add = add i32 %conv12, %conv14
  %add15 = add i32 %add, 1
  %conv16 = trunc i32 %add15 to i16
  %conv17 = zext i16 %conv16 to i32
  %22 = load i16, ptr %s2, align 2
  %conv18 = zext i16 %22 to i32
  %cmp19 = icmp sle i32 %conv17, %conv18
  %conv20 = zext i1 %cmp19 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %23 = load i16, ptr %s2, align 2
  %conv21 = zext i16 %23 to i32
  %24 = load i64, ptr %s1.addr, align 8
  %conv22 = trunc i64 %24 to i16
  %conv23 = zext i16 %conv22 to i32
  %add24 = add i32 %conv21, %conv23
  %conv25 = trunc i32 %add24 to i16
  %conv26 = zext i16 %conv25 to i32
  %25 = load i16, ptr %s2, align 2
  %conv27 = zext i16 %25 to i32
  %cmp28 = icmp slt i32 %conv26, %conv27
  %conv29 = zext i1 %cmp28 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv20, %cond.true ], [ %conv29, %cond.false ]
  %conv30 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %17, i32 noundef %18, i8 noundef zeroext %conv30)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !57

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart31 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart31, align 8
  %28 = load i32, ptr %vta_all_1s, align 4
  %tobool32 = icmp ne i32 %28, 0
  br i1 %tobool32, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc37, %if.then
  %29 = load i32, ptr %i, align 4
  %30 = load i32, ptr %total_elems, align 4
  %cmp34 = icmp ult i32 %29, %30
  br i1 %cmp34, label %for.body36, label %for.end39

for.body36:                                       ; preds = %for.cond33
  %31 = load ptr, ptr %vd.addr, align 8
  %32 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %31, i32 noundef %32, i8 noundef zeroext 1)
  br label %for.inc37

for.inc37:                                        ; preds = %for.body36
  %33 = load i32, ptr %i, align 4
  %inc38 = add i32 %33, 1
  store i32 %inc38, ptr %i, align 4
  br label %for.cond33, !llvm.loop !58

for.end39:                                        ; preds = %for.cond33
  br label %if.end

if.end:                                           ; preds = %for.end39, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadc_vxm_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  %carry = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i32, ptr %10, i64 %idx.ext
  %12 = load i32, ptr %add.ptr, align 4
  store i32 %12, ptr %s2, align 4
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool8 = icmp ne i32 %call7, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %16 = phi i1 [ false, %for.body ], [ %tobool8, %land.rhs ]
  %land.ext = zext i1 %16 to i32
  store i32 %land.ext, ptr %carry, align 4
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %carry, align 4
  %tobool9 = icmp ne i32 %19, 0
  br i1 %tobool9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %20 = load i32, ptr %s2, align 4
  %21 = load i64, ptr %s1.addr, align 8
  %conv10 = trunc i64 %21 to i32
  %add = add i32 %20, %conv10
  %add11 = add i32 %add, 1
  %22 = load i32, ptr %s2, align 4
  %cmp12 = icmp ule i32 %add11, %22
  %conv13 = zext i1 %cmp12 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %23 = load i32, ptr %s2, align 4
  %24 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %24 to i32
  %add15 = add i32 %23, %conv14
  %25 = load i32, ptr %s2, align 4
  %cmp16 = icmp ult i32 %add15, %25
  %conv17 = zext i1 %cmp16 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv13, %cond.true ], [ %conv17, %cond.false ]
  %conv18 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %17, i32 noundef %18, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !59

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %28 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %28, 0
  br i1 %tobool20, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then
  %29 = load i32, ptr %i, align 4
  %30 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %29, %30
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %31 = load ptr, ptr %vd.addr, align 8
  %32 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %31, i32 noundef %32, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %33 = load i32, ptr %i, align 4
  %inc26 = add i32 %33, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !60

for.end27:                                        ; preds = %for.cond21
  br label %if.end

if.end:                                           ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadc_vxm_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  %carry = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i64, ptr %10, i64 %idx.ext
  %12 = load i64, ptr %add.ptr, align 8
  store i64 %12, ptr %s2, align 8
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool8 = icmp ne i32 %call7, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %16 = phi i1 [ false, %for.body ], [ %tobool8, %land.rhs ]
  %land.ext = zext i1 %16 to i32
  %conv9 = sext i32 %land.ext to i64
  store i64 %conv9, ptr %carry, align 8
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %i, align 4
  %19 = load i64, ptr %carry, align 8
  %tobool10 = icmp ne i64 %19, 0
  br i1 %tobool10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %20 = load i64, ptr %s2, align 8
  %21 = load i64, ptr %s1.addr, align 8
  %add = add i64 %20, %21
  %add11 = add i64 %add, 1
  %22 = load i64, ptr %s2, align 8
  %cmp12 = icmp ule i64 %add11, %22
  %conv13 = zext i1 %cmp12 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %23 = load i64, ptr %s2, align 8
  %24 = load i64, ptr %s1.addr, align 8
  %add14 = add i64 %23, %24
  %25 = load i64, ptr %s2, align 8
  %cmp15 = icmp ult i64 %add14, %25
  %conv16 = zext i1 %cmp15 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv13, %cond.true ], [ %conv16, %cond.false ]
  %conv17 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %17, i32 noundef %18, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !61

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %28 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %28, 0
  br i1 %tobool19, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then
  %29 = load i32, ptr %i, align 4
  %30 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %29, %30
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %31 = load ptr, ptr %vd.addr, align 8
  %32 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %31, i32 noundef %32, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %33 = load i32, ptr %i, align 4
  %inc25 = add i32 %33, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !62

for.end26:                                        ; preds = %for.cond20
  br label %if.end

if.end:                                           ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsbc_vxm_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  %carry = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i8, ptr %10, i64 %idx.ext
  %12 = load i8, ptr %add.ptr, align 1
  store i8 %12, ptr %s2, align 1
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool8 = icmp ne i32 %call7, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %16 = phi i1 [ false, %for.body ], [ %tobool8, %land.rhs ]
  %land.ext = zext i1 %16 to i32
  %conv9 = trunc i32 %land.ext to i8
  store i8 %conv9, ptr %carry, align 1
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %i, align 4
  %19 = load i8, ptr %carry, align 1
  %conv10 = zext i8 %19 to i32
  %tobool11 = icmp ne i32 %conv10, 0
  br i1 %tobool11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %20 = load i8, ptr %s2, align 1
  %conv12 = zext i8 %20 to i32
  %21 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %21 to i8
  %conv14 = zext i8 %conv13 to i32
  %cmp15 = icmp sle i32 %conv12, %conv14
  %conv16 = zext i1 %cmp15 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %22 = load i8, ptr %s2, align 1
  %conv17 = zext i8 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv18 = trunc i64 %23 to i8
  %conv19 = zext i8 %conv18 to i32
  %cmp20 = icmp slt i32 %conv17, %conv19
  %conv21 = zext i1 %cmp20 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv16, %cond.true ], [ %conv21, %cond.false ]
  %conv22 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %17, i32 noundef %18, i8 noundef zeroext %conv22)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !63

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart23 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart23, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool24 = icmp ne i32 %26, 0
  br i1 %tobool24, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond25

for.cond25:                                       ; preds = %for.inc29, %if.then
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp26 = icmp ult i32 %27, %28
  br i1 %cmp26, label %for.body28, label %for.end31

for.body28:                                       ; preds = %for.cond25
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc29

for.inc29:                                        ; preds = %for.body28
  %31 = load i32, ptr %i, align 4
  %inc30 = add i32 %31, 1
  store i32 %inc30, ptr %i, align 4
  br label %for.cond25, !llvm.loop !64

for.end31:                                        ; preds = %for.cond25
  br label %if.end

if.end:                                           ; preds = %for.end31, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsbc_vxm_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  %carry = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i16, ptr %10, i64 %idx.ext
  %12 = load i16, ptr %add.ptr, align 2
  store i16 %12, ptr %s2, align 2
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool8 = icmp ne i32 %call7, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %16 = phi i1 [ false, %for.body ], [ %tobool8, %land.rhs ]
  %land.ext = zext i1 %16 to i32
  %conv9 = trunc i32 %land.ext to i16
  store i16 %conv9, ptr %carry, align 2
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %i, align 4
  %19 = load i16, ptr %carry, align 2
  %conv10 = zext i16 %19 to i32
  %tobool11 = icmp ne i32 %conv10, 0
  br i1 %tobool11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %20 = load i16, ptr %s2, align 2
  %conv12 = zext i16 %20 to i32
  %21 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %21 to i16
  %conv14 = zext i16 %conv13 to i32
  %cmp15 = icmp sle i32 %conv12, %conv14
  %conv16 = zext i1 %cmp15 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %22 = load i16, ptr %s2, align 2
  %conv17 = zext i16 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv18 = trunc i64 %23 to i16
  %conv19 = zext i16 %conv18 to i32
  %cmp20 = icmp slt i32 %conv17, %conv19
  %conv21 = zext i1 %cmp20 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv16, %cond.true ], [ %conv21, %cond.false ]
  %conv22 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %17, i32 noundef %18, i8 noundef zeroext %conv22)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !65

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart23 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart23, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool24 = icmp ne i32 %26, 0
  br i1 %tobool24, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond25

for.cond25:                                       ; preds = %for.inc29, %if.then
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp26 = icmp ult i32 %27, %28
  br i1 %cmp26, label %for.body28, label %for.end31

for.body28:                                       ; preds = %for.cond25
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc29

for.inc29:                                        ; preds = %for.body28
  %31 = load i32, ptr %i, align 4
  %inc30 = add i32 %31, 1
  store i32 %inc30, ptr %i, align 4
  br label %for.cond25, !llvm.loop !66

for.end31:                                        ; preds = %for.cond25
  br label %if.end

if.end:                                           ; preds = %for.end31, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsbc_vxm_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  %carry = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i32, ptr %10, i64 %idx.ext
  %12 = load i32, ptr %add.ptr, align 4
  store i32 %12, ptr %s2, align 4
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool8 = icmp ne i32 %call7, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %16 = phi i1 [ false, %for.body ], [ %tobool8, %land.rhs ]
  %land.ext = zext i1 %16 to i32
  store i32 %land.ext, ptr %carry, align 4
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %carry, align 4
  %tobool9 = icmp ne i32 %19, 0
  br i1 %tobool9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %20 = load i32, ptr %s2, align 4
  %21 = load i64, ptr %s1.addr, align 8
  %conv10 = trunc i64 %21 to i32
  %cmp11 = icmp ule i32 %20, %conv10
  %conv12 = zext i1 %cmp11 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %cmp14 = icmp ult i32 %22, %conv13
  %conv15 = zext i1 %cmp14 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv12, %cond.true ], [ %conv15, %cond.false ]
  %conv16 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %17, i32 noundef %18, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !67

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %26, 0
  br i1 %tobool18, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %27, %28
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %31 = load i32, ptr %i, align 4
  %inc24 = add i32 %31, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !68

for.end25:                                        ; preds = %for.cond19
  br label %if.end

if.end:                                           ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsbc_vxm_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  %carry = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i64, ptr %10, i64 %idx.ext
  %12 = load i64, ptr %add.ptr, align 8
  store i64 %12, ptr %s2, align 8
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool8 = icmp ne i32 %call7, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body
  %16 = phi i1 [ false, %for.body ], [ %tobool8, %land.rhs ]
  %land.ext = zext i1 %16 to i32
  %conv9 = sext i32 %land.ext to i64
  store i64 %conv9, ptr %carry, align 8
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %i, align 4
  %19 = load i64, ptr %carry, align 8
  %tobool10 = icmp ne i64 %19, 0
  br i1 %tobool10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %20 = load i64, ptr %s2, align 8
  %21 = load i64, ptr %s1.addr, align 8
  %cmp11 = icmp ule i64 %20, %21
  %conv12 = zext i1 %cmp11 to i32
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %cmp13 = icmp ult i64 %22, %23
  %conv14 = zext i1 %cmp13 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv12, %cond.true ], [ %conv14, %cond.false ]
  %conv15 = trunc i32 %cond to i8
  call void @vext_set_elem_mask(ptr noundef %17, i32 noundef %18, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !69

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %26, 0
  br i1 %tobool17, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc22, %if.then
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp19 = icmp ult i32 %27, %28
  br i1 %cmp19, label %for.body21, label %for.end24

for.body21:                                       ; preds = %for.cond18
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc22

for.inc22:                                        ; preds = %for.body21
  %31 = load i32, ptr %i, align 4
  %inc23 = add i32 %31, 1
  store i32 %inc23, ptr %i, align 4
  br label %for.cond18, !llvm.loop !70

for.end24:                                        ; preds = %for.cond18
  br label %if.end

if.end:                                           ; preds = %for.end24, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vand_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vand_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vand_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %conv = sext i8 %6 to i32
  %7 = load i8, ptr %s1, align 1
  %conv3 = sext i8 %7 to i32
  %and = and i32 %conv, %conv3
  %conv4 = trunc i32 %and to i8
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %9 to i64
  %add.ptr6 = getelementptr i8, ptr %8, i64 %idx.ext5
  store i8 %conv4, ptr %add.ptr6, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vand_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vand_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vand_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv3 = sext i16 %7 to i32
  %and = and i32 %conv, %conv3
  %conv4 = trunc i32 %and to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %9 to i64
  %add.ptr6 = getelementptr i16, ptr %8, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vand_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vand_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vand_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %and = and i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %and, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vand_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vand_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vand_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %and = and i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %and, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vor_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vor_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vor_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %conv = sext i8 %6 to i32
  %7 = load i8, ptr %s1, align 1
  %conv3 = sext i8 %7 to i32
  %or = or i32 %conv, %conv3
  %conv4 = trunc i32 %or to i8
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %9 to i64
  %add.ptr6 = getelementptr i8, ptr %8, i64 %idx.ext5
  store i8 %conv4, ptr %add.ptr6, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vor_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vor_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vor_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv3 = sext i16 %7 to i32
  %or = or i32 %conv, %conv3
  %conv4 = trunc i32 %or to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %9 to i64
  %add.ptr6 = getelementptr i16, ptr %8, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vor_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vor_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vor_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %or = or i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %or, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vor_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vor_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vor_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %or = or i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %or, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vxor_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vxor_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vxor_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %conv = sext i8 %6 to i32
  %7 = load i8, ptr %s1, align 1
  %conv3 = sext i8 %7 to i32
  %xor = xor i32 %conv, %conv3
  %conv4 = trunc i32 %xor to i8
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %9 to i64
  %add.ptr6 = getelementptr i8, ptr %8, i64 %idx.ext5
  store i8 %conv4, ptr %add.ptr6, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vxor_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vxor_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vxor_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv3 = sext i16 %7 to i32
  %xor = xor i32 %conv, %conv3
  %conv4 = trunc i32 %xor to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %9 to i64
  %add.ptr6 = getelementptr i16, ptr %8, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vxor_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vxor_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vxor_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %xor = xor i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %xor, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vxor_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vxor_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vxor_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %xor = xor i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %xor, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vand_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vand_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vand_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %conv = sext i8 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = sext i8 %conv1 to i32
  %and = and i32 %conv, %conv2
  %conv3 = trunc i32 %and to i8
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i8, ptr %5, i64 %idx.ext4
  store i8 %conv3, ptr %add.ptr5, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vand_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vand_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vand_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = sext i16 %conv1 to i32
  %and = and i32 %conv, %conv2
  %conv3 = trunc i32 %and to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i16, ptr %5, i64 %idx.ext4
  store i16 %conv3, ptr %add.ptr5, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vand_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vand_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vand_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %and = and i32 %3, %conv
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %and, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vand_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vand_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vand_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %and = and i64 %3, %4
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %and, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vor_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vor_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vor_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %conv = sext i8 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = sext i8 %conv1 to i32
  %or = or i32 %conv, %conv2
  %conv3 = trunc i32 %or to i8
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i8, ptr %5, i64 %idx.ext4
  store i8 %conv3, ptr %add.ptr5, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vor_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vor_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vor_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = sext i16 %conv1 to i32
  %or = or i32 %conv, %conv2
  %conv3 = trunc i32 %or to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i16, ptr %5, i64 %idx.ext4
  store i16 %conv3, ptr %add.ptr5, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vor_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vor_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vor_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %or = or i32 %3, %conv
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %or, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vor_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vor_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vor_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %or = or i64 %3, %4
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %or, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vxor_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vxor_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vxor_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %conv = sext i8 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = sext i8 %conv1 to i32
  %xor = xor i32 %conv, %conv2
  %conv3 = trunc i32 %xor to i8
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i8, ptr %5, i64 %idx.ext4
  store i8 %conv3, ptr %add.ptr5, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vxor_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vxor_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vxor_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = sext i16 %conv1 to i32
  %xor = xor i32 %conv, %conv2
  %conv3 = trunc i32 %xor to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i16, ptr %5, i64 %idx.ext4
  store i16 %conv3, ptr %add.ptr5, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vxor_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vxor_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vxor_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %xor = xor i32 %3, %conv
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %xor, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vxor_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vxor_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vxor_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %xor = xor i64 %3, %4
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %xor, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsll_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  store i8 %23, ptr %s1, align 1
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i8, ptr %24, i64 %idx.ext10
  %26 = load i8, ptr %add.ptr11, align 1
  store i8 %26, ptr %s2, align 1
  %27 = load i8, ptr %s2, align 1
  %conv12 = zext i8 %27 to i32
  %28 = load i8, ptr %s1, align 1
  %conv13 = zext i8 %28 to i32
  %and = and i32 %conv13, 7
  %shl = shl i32 %conv12, %and
  %conv14 = trunc i32 %shl to i8
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext15 = zext i32 %30 to i64
  %add.ptr16 = getelementptr i8, ptr %29, i64 %idx.ext15
  store i8 %conv14, ptr %add.ptr16, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !71

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul18, i32 noundef %mul19)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vext_vma(i32 noundef %desc) #0 {
entry:
  %desc.addr = alloca i32, align 4
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @simd_data(i32 noundef %0)
  %call1 = call i32 @extract32(i32 noundef %call, i32 noundef 6, i32 noundef 1)
  ret i32 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsll_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  store i16 %23, ptr %s1, align 2
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i16, ptr %24, i64 %idx.ext10
  %26 = load i16, ptr %add.ptr11, align 2
  store i16 %26, ptr %s2, align 2
  %27 = load i16, ptr %s2, align 2
  %conv12 = zext i16 %27 to i32
  %28 = load i16, ptr %s1, align 2
  %conv13 = zext i16 %28 to i32
  %and = and i32 %conv13, 15
  %shl = shl i32 %conv12, %and
  %conv14 = trunc i32 %shl to i16
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext15 = zext i32 %30 to i64
  %add.ptr16 = getelementptr i16, ptr %29, i64 %idx.ext15
  store i16 %conv14, ptr %add.ptr16, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !72

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul18, i32 noundef %mul19)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsll_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i32, ptr %21, i64 %idx.ext
  %23 = load i32, ptr %add.ptr, align 4
  store i32 %23, ptr %s1, align 4
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i32, ptr %24, i64 %idx.ext10
  %26 = load i32, ptr %add.ptr11, align 4
  store i32 %26, ptr %s2, align 4
  %27 = load i32, ptr %s2, align 4
  %28 = load i32, ptr %s1, align 4
  %and = and i32 %28, 31
  %shl = shl i32 %27, %and
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %30 to i64
  %add.ptr13 = getelementptr i32, ptr %29, i64 %idx.ext12
  store i32 %shl, ptr %add.ptr13, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !73

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsll_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i64, ptr %21, i64 %idx.ext
  %23 = load i64, ptr %add.ptr, align 8
  store i64 %23, ptr %s1, align 8
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i64, ptr %24, i64 %idx.ext10
  %26 = load i64, ptr %add.ptr11, align 8
  store i64 %26, ptr %s2, align 8
  %27 = load i64, ptr %s2, align 8
  %28 = load i64, ptr %s1, align 8
  %and = and i64 %28, 63
  %shl = shl i64 %27, %and
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %30 to i64
  %add.ptr13 = getelementptr i64, ptr %29, i64 %idx.ext12
  store i64 %shl, ptr %add.ptr13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !74

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsrl_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  store i8 %23, ptr %s1, align 1
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i8, ptr %24, i64 %idx.ext10
  %26 = load i8, ptr %add.ptr11, align 1
  store i8 %26, ptr %s2, align 1
  %27 = load i8, ptr %s2, align 1
  %conv12 = zext i8 %27 to i32
  %28 = load i8, ptr %s1, align 1
  %conv13 = zext i8 %28 to i32
  %and = and i32 %conv13, 7
  %shr = ashr i32 %conv12, %and
  %conv14 = trunc i32 %shr to i8
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext15 = zext i32 %30 to i64
  %add.ptr16 = getelementptr i8, ptr %29, i64 %idx.ext15
  store i8 %conv14, ptr %add.ptr16, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !75

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul18, i32 noundef %mul19)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsrl_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  store i16 %23, ptr %s1, align 2
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i16, ptr %24, i64 %idx.ext10
  %26 = load i16, ptr %add.ptr11, align 2
  store i16 %26, ptr %s2, align 2
  %27 = load i16, ptr %s2, align 2
  %conv12 = zext i16 %27 to i32
  %28 = load i16, ptr %s1, align 2
  %conv13 = zext i16 %28 to i32
  %and = and i32 %conv13, 15
  %shr = ashr i32 %conv12, %and
  %conv14 = trunc i32 %shr to i16
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext15 = zext i32 %30 to i64
  %add.ptr16 = getelementptr i16, ptr %29, i64 %idx.ext15
  store i16 %conv14, ptr %add.ptr16, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !76

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul18, i32 noundef %mul19)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsrl_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i32, ptr %21, i64 %idx.ext
  %23 = load i32, ptr %add.ptr, align 4
  store i32 %23, ptr %s1, align 4
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i32, ptr %24, i64 %idx.ext10
  %26 = load i32, ptr %add.ptr11, align 4
  store i32 %26, ptr %s2, align 4
  %27 = load i32, ptr %s2, align 4
  %28 = load i32, ptr %s1, align 4
  %and = and i32 %28, 31
  %shr = lshr i32 %27, %and
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %30 to i64
  %add.ptr13 = getelementptr i32, ptr %29, i64 %idx.ext12
  store i32 %shr, ptr %add.ptr13, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !77

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsrl_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i64, ptr %21, i64 %idx.ext
  %23 = load i64, ptr %add.ptr, align 8
  store i64 %23, ptr %s1, align 8
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i64, ptr %24, i64 %idx.ext10
  %26 = load i64, ptr %add.ptr11, align 8
  store i64 %26, ptr %s2, align 8
  %27 = load i64, ptr %s2, align 8
  %28 = load i64, ptr %s1, align 8
  %and = and i64 %28, 63
  %shr = lshr i64 %27, %and
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %30 to i64
  %add.ptr13 = getelementptr i64, ptr %29, i64 %idx.ext12
  store i64 %shr, ptr %add.ptr13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !78

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsra_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  store i8 %23, ptr %s1, align 1
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i8, ptr %24, i64 %idx.ext10
  %26 = load i8, ptr %add.ptr11, align 1
  store i8 %26, ptr %s2, align 1
  %27 = load i8, ptr %s2, align 1
  %conv12 = sext i8 %27 to i32
  %28 = load i8, ptr %s1, align 1
  %conv13 = zext i8 %28 to i32
  %and = and i32 %conv13, 7
  %shr = ashr i32 %conv12, %and
  %conv14 = trunc i32 %shr to i8
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext15 = zext i32 %30 to i64
  %add.ptr16 = getelementptr i8, ptr %29, i64 %idx.ext15
  store i8 %conv14, ptr %add.ptr16, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !79

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul18, i32 noundef %mul19)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsra_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  store i16 %23, ptr %s1, align 2
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i16, ptr %24, i64 %idx.ext10
  %26 = load i16, ptr %add.ptr11, align 2
  store i16 %26, ptr %s2, align 2
  %27 = load i16, ptr %s2, align 2
  %conv12 = sext i16 %27 to i32
  %28 = load i16, ptr %s1, align 2
  %conv13 = zext i16 %28 to i32
  %and = and i32 %conv13, 15
  %shr = ashr i32 %conv12, %and
  %conv14 = trunc i32 %shr to i16
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext15 = zext i32 %30 to i64
  %add.ptr16 = getelementptr i16, ptr %29, i64 %idx.ext15
  store i16 %conv14, ptr %add.ptr16, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !80

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul18, i32 noundef %mul19)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsra_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i32, ptr %21, i64 %idx.ext
  %23 = load i32, ptr %add.ptr, align 4
  store i32 %23, ptr %s1, align 4
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i32, ptr %24, i64 %idx.ext10
  %26 = load i32, ptr %add.ptr11, align 4
  store i32 %26, ptr %s2, align 4
  %27 = load i32, ptr %s2, align 4
  %28 = load i32, ptr %s1, align 4
  %and = and i32 %28, 31
  %shr = ashr i32 %27, %and
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %30 to i64
  %add.ptr13 = getelementptr i32, ptr %29, i64 %idx.ext12
  store i32 %shr, ptr %add.ptr13, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !81

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsra_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i64, ptr %21, i64 %idx.ext
  %23 = load i64, ptr %add.ptr, align 8
  store i64 %23, ptr %s1, align 8
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i64, ptr %24, i64 %idx.ext10
  %26 = load i64, ptr %add.ptr11, align 8
  store i64 %26, ptr %s2, align 8
  %27 = load i64, ptr %s2, align 8
  %28 = load i64, ptr %s1, align 8
  %and = and i64 %28, 63
  %shr = ashr i64 %27, %and
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %30 to i64
  %add.ptr13 = getelementptr i64, ptr %29, i64 %idx.ext12
  store i64 %shr, ptr %add.ptr13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !82

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsll_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  store i8 %23, ptr %s2, align 1
  %24 = load i8, ptr %s2, align 1
  %conv10 = sext i8 %24 to i32
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 7
  %sh_prom = trunc i64 %and to i32
  %shl = shl i32 %conv10, %sh_prom
  %conv11 = trunc i32 %shl to i8
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %27 to i64
  %add.ptr13 = getelementptr i8, ptr %26, i64 %idx.ext12
  store i8 %conv11, ptr %add.ptr13, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !83

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsll_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  store i16 %23, ptr %s2, align 2
  %24 = load i16, ptr %s2, align 2
  %conv10 = sext i16 %24 to i32
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 15
  %sh_prom = trunc i64 %and to i32
  %shl = shl i32 %conv10, %sh_prom
  %conv11 = trunc i32 %shl to i16
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %27 to i64
  %add.ptr13 = getelementptr i16, ptr %26, i64 %idx.ext12
  store i16 %conv11, ptr %add.ptr13, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !84

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsll_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i32, ptr %21, i64 %idx.ext
  %23 = load i32, ptr %add.ptr, align 4
  store i32 %23, ptr %s2, align 4
  %24 = load i32, ptr %s2, align 4
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 31
  %sh_prom = trunc i64 %and to i32
  %shl = shl i32 %24, %sh_prom
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %27 to i64
  %add.ptr11 = getelementptr i32, ptr %26, i64 %idx.ext10
  store i32 %shl, ptr %add.ptr11, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !85

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul13, i32 noundef %mul14)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsll_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i64, ptr %21, i64 %idx.ext
  %23 = load i64, ptr %add.ptr, align 8
  store i64 %23, ptr %s2, align 8
  %24 = load i64, ptr %s2, align 8
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 63
  %shl = shl i64 %24, %and
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %27 to i64
  %add.ptr11 = getelementptr i64, ptr %26, i64 %idx.ext10
  store i64 %shl, ptr %add.ptr11, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !86

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul13, i32 noundef %mul14)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsrl_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  store i8 %23, ptr %s2, align 1
  %24 = load i8, ptr %s2, align 1
  %conv10 = zext i8 %24 to i32
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 7
  %sh_prom = trunc i64 %and to i32
  %shr = ashr i32 %conv10, %sh_prom
  %conv11 = trunc i32 %shr to i8
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %27 to i64
  %add.ptr13 = getelementptr i8, ptr %26, i64 %idx.ext12
  store i8 %conv11, ptr %add.ptr13, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !87

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsrl_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  store i16 %23, ptr %s2, align 2
  %24 = load i16, ptr %s2, align 2
  %conv10 = zext i16 %24 to i32
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 15
  %sh_prom = trunc i64 %and to i32
  %shr = ashr i32 %conv10, %sh_prom
  %conv11 = trunc i32 %shr to i16
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %27 to i64
  %add.ptr13 = getelementptr i16, ptr %26, i64 %idx.ext12
  store i16 %conv11, ptr %add.ptr13, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !88

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsrl_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i32, ptr %21, i64 %idx.ext
  %23 = load i32, ptr %add.ptr, align 4
  store i32 %23, ptr %s2, align 4
  %24 = load i32, ptr %s2, align 4
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 31
  %sh_prom = trunc i64 %and to i32
  %shr = lshr i32 %24, %sh_prom
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %27 to i64
  %add.ptr11 = getelementptr i32, ptr %26, i64 %idx.ext10
  store i32 %shr, ptr %add.ptr11, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !89

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul13, i32 noundef %mul14)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsrl_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i64, ptr %21, i64 %idx.ext
  %23 = load i64, ptr %add.ptr, align 8
  store i64 %23, ptr %s2, align 8
  %24 = load i64, ptr %s2, align 8
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 63
  %shr = lshr i64 %24, %and
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %27 to i64
  %add.ptr11 = getelementptr i64, ptr %26, i64 %idx.ext10
  store i64 %shr, ptr %add.ptr11, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !90

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul13, i32 noundef %mul14)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsra_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  store i8 %23, ptr %s2, align 1
  %24 = load i8, ptr %s2, align 1
  %conv10 = sext i8 %24 to i32
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 7
  %sh_prom = trunc i64 %and to i32
  %shr = ashr i32 %conv10, %sh_prom
  %conv11 = trunc i32 %shr to i8
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %27 to i64
  %add.ptr13 = getelementptr i8, ptr %26, i64 %idx.ext12
  store i8 %conv11, ptr %add.ptr13, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !91

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsra_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  store i16 %23, ptr %s2, align 2
  %24 = load i16, ptr %s2, align 2
  %conv10 = sext i16 %24 to i32
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 15
  %sh_prom = trunc i64 %and to i32
  %shr = ashr i32 %conv10, %sh_prom
  %conv11 = trunc i32 %shr to i16
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %27 to i64
  %add.ptr13 = getelementptr i16, ptr %26, i64 %idx.ext12
  store i16 %conv11, ptr %add.ptr13, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !92

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsra_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i32, ptr %21, i64 %idx.ext
  %23 = load i32, ptr %add.ptr, align 4
  store i32 %23, ptr %s2, align 4
  %24 = load i32, ptr %s2, align 4
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 31
  %sh_prom = trunc i64 %and to i32
  %shr = ashr i32 %24, %sh_prom
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %27 to i64
  %add.ptr11 = getelementptr i32, ptr %26, i64 %idx.ext10
  store i32 %shr, ptr %add.ptr11, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !93

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul13, i32 noundef %mul14)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsra_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i64, ptr %21, i64 %idx.ext
  %23 = load i64, ptr %add.ptr, align 8
  store i64 %23, ptr %s2, align 8
  %24 = load i64, ptr %s2, align 8
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 63
  %shr = ashr i64 %24, %and
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %27 to i64
  %add.ptr11 = getelementptr i64, ptr %26, i64 %idx.ext10
  store i64 %shr, ptr %add.ptr11, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !94

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul13, i32 noundef %mul14)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnsrl_wv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  store i8 %23, ptr %s1, align 1
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i16, ptr %24, i64 %idx.ext10
  %26 = load i16, ptr %add.ptr11, align 2
  store i16 %26, ptr %s2, align 2
  %27 = load i16, ptr %s2, align 2
  %conv12 = zext i16 %27 to i32
  %28 = load i8, ptr %s1, align 1
  %conv13 = zext i8 %28 to i32
  %and = and i32 %conv13, 15
  %shr = ashr i32 %conv12, %and
  %conv14 = trunc i32 %shr to i8
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext15 = zext i32 %30 to i64
  %add.ptr16 = getelementptr i8, ptr %29, i64 %idx.ext15
  store i8 %conv14, ptr %add.ptr16, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !95

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul18, i32 noundef %mul19)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnsrl_wv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  store i16 %23, ptr %s1, align 2
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i32, ptr %24, i64 %idx.ext10
  %26 = load i32, ptr %add.ptr11, align 4
  store i32 %26, ptr %s2, align 4
  %27 = load i32, ptr %s2, align 4
  %28 = load i16, ptr %s1, align 2
  %conv12 = zext i16 %28 to i32
  %and = and i32 %conv12, 31
  %shr = lshr i32 %27, %and
  %conv13 = trunc i32 %shr to i16
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext14 = zext i32 %30 to i64
  %add.ptr15 = getelementptr i16, ptr %29, i64 %idx.ext14
  store i16 %conv13, ptr %add.ptr15, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !96

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul17 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul17, i32 noundef %mul18)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnsrl_wv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i32, ptr %21, i64 %idx.ext
  %23 = load i32, ptr %add.ptr, align 4
  store i32 %23, ptr %s1, align 4
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i64, ptr %24, i64 %idx.ext10
  %26 = load i64, ptr %add.ptr11, align 8
  store i64 %26, ptr %s2, align 8
  %27 = load i64, ptr %s2, align 8
  %28 = load i32, ptr %s1, align 4
  %and = and i32 %28, 63
  %sh_prom = zext i32 %and to i64
  %shr = lshr i64 %27, %sh_prom
  %conv12 = trunc i64 %shr to i32
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext13 = zext i32 %30 to i64
  %add.ptr14 = getelementptr i32, ptr %29, i64 %idx.ext13
  store i32 %conv12, ptr %add.ptr14, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !97

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul17 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul16, i32 noundef %mul17)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnsra_wv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  store i8 %23, ptr %s1, align 1
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i16, ptr %24, i64 %idx.ext10
  %26 = load i16, ptr %add.ptr11, align 2
  store i16 %26, ptr %s2, align 2
  %27 = load i16, ptr %s2, align 2
  %conv12 = sext i16 %27 to i32
  %28 = load i8, ptr %s1, align 1
  %conv13 = zext i8 %28 to i32
  %and = and i32 %conv13, 15
  %shr = ashr i32 %conv12, %and
  %conv14 = trunc i32 %shr to i8
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext15 = zext i32 %30 to i64
  %add.ptr16 = getelementptr i8, ptr %29, i64 %idx.ext15
  store i8 %conv14, ptr %add.ptr16, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !98

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul18, i32 noundef %mul19)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnsra_wv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  store i16 %23, ptr %s1, align 2
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i32, ptr %24, i64 %idx.ext10
  %26 = load i32, ptr %add.ptr11, align 4
  store i32 %26, ptr %s2, align 4
  %27 = load i32, ptr %s2, align 4
  %28 = load i16, ptr %s1, align 2
  %conv12 = zext i16 %28 to i32
  %and = and i32 %conv12, 31
  %shr = ashr i32 %27, %and
  %conv13 = trunc i32 %shr to i16
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext14 = zext i32 %30 to i64
  %add.ptr15 = getelementptr i16, ptr %29, i64 %idx.ext14
  store i16 %conv13, ptr %add.ptr15, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !99

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul17 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul17, i32 noundef %mul18)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnsra_wv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs1.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i32, ptr %21, i64 %idx.ext
  %23 = load i32, ptr %add.ptr, align 4
  store i32 %23, ptr %s1, align 4
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %25 to i64
  %add.ptr11 = getelementptr i64, ptr %24, i64 %idx.ext10
  %26 = load i64, ptr %add.ptr11, align 8
  store i64 %26, ptr %s2, align 8
  %27 = load i64, ptr %s2, align 8
  %28 = load i32, ptr %s1, align 4
  %and = and i32 %28, 63
  %sh_prom = zext i32 %and to i64
  %shr = ashr i64 %27, %sh_prom
  %conv12 = trunc i64 %shr to i32
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext13 = zext i32 %30 to i64
  %add.ptr14 = getelementptr i32, ptr %29, i64 %idx.ext13
  store i32 %conv12, ptr %add.ptr14, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !100

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul17 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul16, i32 noundef %mul17)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnsrl_wx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  store i16 %23, ptr %s2, align 2
  %24 = load i16, ptr %s2, align 2
  %conv10 = zext i16 %24 to i32
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 15
  %sh_prom = trunc i64 %and to i32
  %shr = ashr i32 %conv10, %sh_prom
  %conv11 = trunc i32 %shr to i8
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %27 to i64
  %add.ptr13 = getelementptr i8, ptr %26, i64 %idx.ext12
  store i8 %conv11, ptr %add.ptr13, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !101

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnsrl_wx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i32, ptr %21, i64 %idx.ext
  %23 = load i32, ptr %add.ptr, align 4
  store i32 %23, ptr %s2, align 4
  %24 = load i32, ptr %s2, align 4
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 31
  %sh_prom = trunc i64 %and to i32
  %shr = lshr i32 %24, %sh_prom
  %conv10 = trunc i32 %shr to i16
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %27 to i64
  %add.ptr12 = getelementptr i16, ptr %26, i64 %idx.ext11
  store i16 %conv10, ptr %add.ptr12, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !102

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnsrl_wx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i64, ptr %21, i64 %idx.ext
  %23 = load i64, ptr %add.ptr, align 8
  store i64 %23, ptr %s2, align 8
  %24 = load i64, ptr %s2, align 8
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 63
  %shr = lshr i64 %24, %and
  %conv10 = trunc i64 %shr to i32
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %27 to i64
  %add.ptr12 = getelementptr i32, ptr %26, i64 %idx.ext11
  store i32 %conv10, ptr %add.ptr12, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !103

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnsra_wx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  store i16 %23, ptr %s2, align 2
  %24 = load i16, ptr %s2, align 2
  %conv10 = sext i16 %24 to i32
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 15
  %sh_prom = trunc i64 %and to i32
  %shr = ashr i32 %conv10, %sh_prom
  %conv11 = trunc i32 %shr to i8
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext12 = zext i32 %27 to i64
  %add.ptr13 = getelementptr i8, ptr %26, i64 %idx.ext12
  store i8 %conv11, ptr %add.ptr13, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !104

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul15, i32 noundef %mul16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnsra_wx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i32, ptr %21, i64 %idx.ext
  %23 = load i32, ptr %add.ptr, align 4
  store i32 %23, ptr %s2, align 4
  %24 = load i32, ptr %s2, align 4
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 31
  %sh_prom = trunc i64 %and to i32
  %shr = ashr i32 %24, %sh_prom
  %conv10 = trunc i32 %shr to i16
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %27 to i64
  %add.ptr12 = getelementptr i16, ptr %26, i64 %idx.ext11
  store i16 %conv10, ptr %add.ptr12, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !105

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnsra_wx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i64, ptr %21, i64 %idx.ext
  %23 = load i64, ptr %add.ptr, align 8
  store i64 %23, ptr %s2, align 8
  %24 = load i64, ptr %s2, align 8
  %25 = load i64, ptr %s1.addr, align 8
  %and = and i64 %25, 63
  %shr = ashr i64 %24, %and
  %conv10 = trunc i64 %shr to i32
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %27 to i64
  %add.ptr12 = getelementptr i32, ptr %26, i64 %idx.ext11
  store i32 %conv10, ptr %add.ptr12, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !106

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %vta, align 4
  %32 = load i32, ptr %vl, align 4
  %33 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %32, %33
  %34 = load i32, ptr %total_elems, align 4
  %35 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %34, %35
  call void @vext_set_elems_1s(ptr noundef %30, i32 noundef %31, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmseq_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s1, align 1
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i8, ptr %14, i64 %idx.ext8
  %16 = load i8, ptr %add.ptr9, align 1
  store i8 %16, ptr %s2, align 1
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i8, ptr %s2, align 1
  %conv15 = zext i8 %25 to i32
  %26 = load i8, ptr %s1, align 1
  %conv16 = zext i8 %26 to i32
  %cmp17 = icmp eq i32 %conv15, %conv16
  %conv18 = zext i1 %cmp17 to i32
  %conv19 = trunc i32 %conv18 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !107

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then22, label %if.end30

if.then22:                                        ; preds = %for.end
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp24 = icmp ult i32 %30, %31
  br i1 %cmp24, label %for.body26, label %for.end29

for.body26:                                       ; preds = %for.cond23
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body26
  %34 = load i32, ptr %i, align 4
  %inc28 = add i32 %34, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond23, !llvm.loop !108

for.end29:                                        ; preds = %for.cond23
  br label %if.end30

if.end30:                                         ; preds = %for.end29, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmseq_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s1, align 2
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i16, ptr %14, i64 %idx.ext8
  %16 = load i16, ptr %add.ptr9, align 2
  store i16 %16, ptr %s2, align 2
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i16, ptr %s2, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, ptr %s1, align 2
  %conv16 = zext i16 %26 to i32
  %cmp17 = icmp eq i32 %conv15, %conv16
  %conv18 = zext i1 %cmp17 to i32
  %conv19 = trunc i32 %conv18 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !109

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then22, label %if.end30

if.then22:                                        ; preds = %for.end
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp24 = icmp ult i32 %30, %31
  br i1 %cmp24, label %for.body26, label %for.end29

for.body26:                                       ; preds = %for.cond23
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body26
  %34 = load i32, ptr %i, align 4
  %inc28 = add i32 %34, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond23, !llvm.loop !110

for.end29:                                        ; preds = %for.cond23
  br label %if.end30

if.end30:                                         ; preds = %for.end29, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmseq_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s1, align 4
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i32, ptr %14, i64 %idx.ext8
  %16 = load i32, ptr %add.ptr9, align 4
  store i32 %16, ptr %s2, align 4
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i32, ptr %s2, align 4
  %26 = load i32, ptr %s1, align 4
  %cmp15 = icmp eq i32 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  %conv17 = trunc i32 %conv16 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !111

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then20
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %30, %31
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %34 = load i32, ptr %i, align 4
  %inc26 = add i32 %34, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !112

for.end27:                                        ; preds = %for.cond21
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmseq_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s1, align 8
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i64, ptr %14, i64 %idx.ext8
  %16 = load i64, ptr %add.ptr9, align 8
  store i64 %16, ptr %s2, align 8
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i64, ptr %s2, align 8
  %26 = load i64, ptr %s1, align 8
  %cmp15 = icmp eq i64 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  %conv17 = trunc i32 %conv16 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !113

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then20
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %30, %31
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %34 = load i32, ptr %i, align 4
  %inc26 = add i32 %34, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !114

for.end27:                                        ; preds = %for.cond21
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsne_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s1, align 1
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i8, ptr %14, i64 %idx.ext8
  %16 = load i8, ptr %add.ptr9, align 1
  store i8 %16, ptr %s2, align 1
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i8, ptr %s2, align 1
  %conv15 = zext i8 %25 to i32
  %26 = load i8, ptr %s1, align 1
  %conv16 = zext i8 %26 to i32
  %cmp17 = icmp ne i32 %conv15, %conv16
  %conv18 = zext i1 %cmp17 to i32
  %conv19 = trunc i32 %conv18 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !115

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then22, label %if.end30

if.then22:                                        ; preds = %for.end
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp24 = icmp ult i32 %30, %31
  br i1 %cmp24, label %for.body26, label %for.end29

for.body26:                                       ; preds = %for.cond23
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body26
  %34 = load i32, ptr %i, align 4
  %inc28 = add i32 %34, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond23, !llvm.loop !116

for.end29:                                        ; preds = %for.cond23
  br label %if.end30

if.end30:                                         ; preds = %for.end29, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsne_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s1, align 2
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i16, ptr %14, i64 %idx.ext8
  %16 = load i16, ptr %add.ptr9, align 2
  store i16 %16, ptr %s2, align 2
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i16, ptr %s2, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, ptr %s1, align 2
  %conv16 = zext i16 %26 to i32
  %cmp17 = icmp ne i32 %conv15, %conv16
  %conv18 = zext i1 %cmp17 to i32
  %conv19 = trunc i32 %conv18 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !117

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then22, label %if.end30

if.then22:                                        ; preds = %for.end
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp24 = icmp ult i32 %30, %31
  br i1 %cmp24, label %for.body26, label %for.end29

for.body26:                                       ; preds = %for.cond23
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body26
  %34 = load i32, ptr %i, align 4
  %inc28 = add i32 %34, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond23, !llvm.loop !118

for.end29:                                        ; preds = %for.cond23
  br label %if.end30

if.end30:                                         ; preds = %for.end29, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsne_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s1, align 4
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i32, ptr %14, i64 %idx.ext8
  %16 = load i32, ptr %add.ptr9, align 4
  store i32 %16, ptr %s2, align 4
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i32, ptr %s2, align 4
  %26 = load i32, ptr %s1, align 4
  %cmp15 = icmp ne i32 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  %conv17 = trunc i32 %conv16 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !119

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then20
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %30, %31
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %34 = load i32, ptr %i, align 4
  %inc26 = add i32 %34, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !120

for.end27:                                        ; preds = %for.cond21
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsne_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s1, align 8
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i64, ptr %14, i64 %idx.ext8
  %16 = load i64, ptr %add.ptr9, align 8
  store i64 %16, ptr %s2, align 8
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i64, ptr %s2, align 8
  %26 = load i64, ptr %s1, align 8
  %cmp15 = icmp ne i64 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  %conv17 = trunc i32 %conv16 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !121

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then20
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %30, %31
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %34 = load i32, ptr %i, align 4
  %inc26 = add i32 %34, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !122

for.end27:                                        ; preds = %for.cond21
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsltu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s1, align 1
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i8, ptr %14, i64 %idx.ext8
  %16 = load i8, ptr %add.ptr9, align 1
  store i8 %16, ptr %s2, align 1
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i8, ptr %s2, align 1
  %conv15 = zext i8 %25 to i32
  %26 = load i8, ptr %s1, align 1
  %conv16 = zext i8 %26 to i32
  %cmp17 = icmp slt i32 %conv15, %conv16
  %conv18 = zext i1 %cmp17 to i32
  %conv19 = trunc i32 %conv18 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !123

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then22, label %if.end30

if.then22:                                        ; preds = %for.end
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp24 = icmp ult i32 %30, %31
  br i1 %cmp24, label %for.body26, label %for.end29

for.body26:                                       ; preds = %for.cond23
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body26
  %34 = load i32, ptr %i, align 4
  %inc28 = add i32 %34, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond23, !llvm.loop !124

for.end29:                                        ; preds = %for.cond23
  br label %if.end30

if.end30:                                         ; preds = %for.end29, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsltu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s1, align 2
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i16, ptr %14, i64 %idx.ext8
  %16 = load i16, ptr %add.ptr9, align 2
  store i16 %16, ptr %s2, align 2
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i16, ptr %s2, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, ptr %s1, align 2
  %conv16 = zext i16 %26 to i32
  %cmp17 = icmp slt i32 %conv15, %conv16
  %conv18 = zext i1 %cmp17 to i32
  %conv19 = trunc i32 %conv18 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !125

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then22, label %if.end30

if.then22:                                        ; preds = %for.end
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp24 = icmp ult i32 %30, %31
  br i1 %cmp24, label %for.body26, label %for.end29

for.body26:                                       ; preds = %for.cond23
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body26
  %34 = load i32, ptr %i, align 4
  %inc28 = add i32 %34, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond23, !llvm.loop !126

for.end29:                                        ; preds = %for.cond23
  br label %if.end30

if.end30:                                         ; preds = %for.end29, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsltu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s1, align 4
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i32, ptr %14, i64 %idx.ext8
  %16 = load i32, ptr %add.ptr9, align 4
  store i32 %16, ptr %s2, align 4
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i32, ptr %s2, align 4
  %26 = load i32, ptr %s1, align 4
  %cmp15 = icmp ult i32 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  %conv17 = trunc i32 %conv16 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !127

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then20
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %30, %31
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %34 = load i32, ptr %i, align 4
  %inc26 = add i32 %34, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !128

for.end27:                                        ; preds = %for.cond21
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsltu_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s1, align 8
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i64, ptr %14, i64 %idx.ext8
  %16 = load i64, ptr %add.ptr9, align 8
  store i64 %16, ptr %s2, align 8
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i64, ptr %s2, align 8
  %26 = load i64, ptr %s1, align 8
  %cmp15 = icmp ult i64 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  %conv17 = trunc i32 %conv16 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !129

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then20
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %30, %31
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %34 = load i32, ptr %i, align 4
  %inc26 = add i32 %34, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !130

for.end27:                                        ; preds = %for.cond21
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmslt_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s1, align 1
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i8, ptr %14, i64 %idx.ext8
  %16 = load i8, ptr %add.ptr9, align 1
  store i8 %16, ptr %s2, align 1
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i8, ptr %s2, align 1
  %conv15 = sext i8 %25 to i32
  %26 = load i8, ptr %s1, align 1
  %conv16 = sext i8 %26 to i32
  %cmp17 = icmp slt i32 %conv15, %conv16
  %conv18 = zext i1 %cmp17 to i32
  %conv19 = trunc i32 %conv18 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !131

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then22, label %if.end30

if.then22:                                        ; preds = %for.end
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp24 = icmp ult i32 %30, %31
  br i1 %cmp24, label %for.body26, label %for.end29

for.body26:                                       ; preds = %for.cond23
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body26
  %34 = load i32, ptr %i, align 4
  %inc28 = add i32 %34, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond23, !llvm.loop !132

for.end29:                                        ; preds = %for.cond23
  br label %if.end30

if.end30:                                         ; preds = %for.end29, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmslt_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s1, align 2
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i16, ptr %14, i64 %idx.ext8
  %16 = load i16, ptr %add.ptr9, align 2
  store i16 %16, ptr %s2, align 2
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i16, ptr %s2, align 2
  %conv15 = sext i16 %25 to i32
  %26 = load i16, ptr %s1, align 2
  %conv16 = sext i16 %26 to i32
  %cmp17 = icmp slt i32 %conv15, %conv16
  %conv18 = zext i1 %cmp17 to i32
  %conv19 = trunc i32 %conv18 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !133

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then22, label %if.end30

if.then22:                                        ; preds = %for.end
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp24 = icmp ult i32 %30, %31
  br i1 %cmp24, label %for.body26, label %for.end29

for.body26:                                       ; preds = %for.cond23
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body26
  %34 = load i32, ptr %i, align 4
  %inc28 = add i32 %34, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond23, !llvm.loop !134

for.end29:                                        ; preds = %for.cond23
  br label %if.end30

if.end30:                                         ; preds = %for.end29, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmslt_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s1, align 4
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i32, ptr %14, i64 %idx.ext8
  %16 = load i32, ptr %add.ptr9, align 4
  store i32 %16, ptr %s2, align 4
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i32, ptr %s2, align 4
  %26 = load i32, ptr %s1, align 4
  %cmp15 = icmp slt i32 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  %conv17 = trunc i32 %conv16 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !135

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then20
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %30, %31
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %34 = load i32, ptr %i, align 4
  %inc26 = add i32 %34, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !136

for.end27:                                        ; preds = %for.cond21
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmslt_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s1, align 8
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i64, ptr %14, i64 %idx.ext8
  %16 = load i64, ptr %add.ptr9, align 8
  store i64 %16, ptr %s2, align 8
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i64, ptr %s2, align 8
  %26 = load i64, ptr %s1, align 8
  %cmp15 = icmp slt i64 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  %conv17 = trunc i32 %conv16 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !137

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then20
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %30, %31
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %34 = load i32, ptr %i, align 4
  %inc26 = add i32 %34, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !138

for.end27:                                        ; preds = %for.cond21
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsleu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s1, align 1
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i8, ptr %14, i64 %idx.ext8
  %16 = load i8, ptr %add.ptr9, align 1
  store i8 %16, ptr %s2, align 1
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i8, ptr %s2, align 1
  %conv15 = zext i8 %25 to i32
  %26 = load i8, ptr %s1, align 1
  %conv16 = zext i8 %26 to i32
  %cmp17 = icmp sle i32 %conv15, %conv16
  %conv18 = zext i1 %cmp17 to i32
  %conv19 = trunc i32 %conv18 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !139

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then22, label %if.end30

if.then22:                                        ; preds = %for.end
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp24 = icmp ult i32 %30, %31
  br i1 %cmp24, label %for.body26, label %for.end29

for.body26:                                       ; preds = %for.cond23
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body26
  %34 = load i32, ptr %i, align 4
  %inc28 = add i32 %34, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond23, !llvm.loop !140

for.end29:                                        ; preds = %for.cond23
  br label %if.end30

if.end30:                                         ; preds = %for.end29, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsleu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s1, align 2
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i16, ptr %14, i64 %idx.ext8
  %16 = load i16, ptr %add.ptr9, align 2
  store i16 %16, ptr %s2, align 2
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i16, ptr %s2, align 2
  %conv15 = zext i16 %25 to i32
  %26 = load i16, ptr %s1, align 2
  %conv16 = zext i16 %26 to i32
  %cmp17 = icmp sle i32 %conv15, %conv16
  %conv18 = zext i1 %cmp17 to i32
  %conv19 = trunc i32 %conv18 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !141

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then22, label %if.end30

if.then22:                                        ; preds = %for.end
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp24 = icmp ult i32 %30, %31
  br i1 %cmp24, label %for.body26, label %for.end29

for.body26:                                       ; preds = %for.cond23
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body26
  %34 = load i32, ptr %i, align 4
  %inc28 = add i32 %34, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond23, !llvm.loop !142

for.end29:                                        ; preds = %for.cond23
  br label %if.end30

if.end30:                                         ; preds = %for.end29, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsleu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s1, align 4
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i32, ptr %14, i64 %idx.ext8
  %16 = load i32, ptr %add.ptr9, align 4
  store i32 %16, ptr %s2, align 4
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i32, ptr %s2, align 4
  %26 = load i32, ptr %s1, align 4
  %cmp15 = icmp ule i32 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  %conv17 = trunc i32 %conv16 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !143

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then20
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %30, %31
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %34 = load i32, ptr %i, align 4
  %inc26 = add i32 %34, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !144

for.end27:                                        ; preds = %for.cond21
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsleu_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s1, align 8
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i64, ptr %14, i64 %idx.ext8
  %16 = load i64, ptr %add.ptr9, align 8
  store i64 %16, ptr %s2, align 8
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i64, ptr %s2, align 8
  %26 = load i64, ptr %s1, align 8
  %cmp15 = icmp ule i64 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  %conv17 = trunc i32 %conv16 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !145

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then20
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %30, %31
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %34 = load i32, ptr %i, align 4
  %inc26 = add i32 %34, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !146

for.end27:                                        ; preds = %for.cond21
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsle_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s1, align 1
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i8, ptr %14, i64 %idx.ext8
  %16 = load i8, ptr %add.ptr9, align 1
  store i8 %16, ptr %s2, align 1
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i8, ptr %s2, align 1
  %conv15 = sext i8 %25 to i32
  %26 = load i8, ptr %s1, align 1
  %conv16 = sext i8 %26 to i32
  %cmp17 = icmp sle i32 %conv15, %conv16
  %conv18 = zext i1 %cmp17 to i32
  %conv19 = trunc i32 %conv18 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !147

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then22, label %if.end30

if.then22:                                        ; preds = %for.end
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp24 = icmp ult i32 %30, %31
  br i1 %cmp24, label %for.body26, label %for.end29

for.body26:                                       ; preds = %for.cond23
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body26
  %34 = load i32, ptr %i, align 4
  %inc28 = add i32 %34, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond23, !llvm.loop !148

for.end29:                                        ; preds = %for.cond23
  br label %if.end30

if.end30:                                         ; preds = %for.end29, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsle_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s1, align 2
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i16, ptr %14, i64 %idx.ext8
  %16 = load i16, ptr %add.ptr9, align 2
  store i16 %16, ptr %s2, align 2
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i16, ptr %s2, align 2
  %conv15 = sext i16 %25 to i32
  %26 = load i16, ptr %s1, align 2
  %conv16 = sext i16 %26 to i32
  %cmp17 = icmp sle i32 %conv15, %conv16
  %conv18 = zext i1 %cmp17 to i32
  %conv19 = trunc i32 %conv18 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv19)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !149

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then22, label %if.end30

if.then22:                                        ; preds = %for.end
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp24 = icmp ult i32 %30, %31
  br i1 %cmp24, label %for.body26, label %for.end29

for.body26:                                       ; preds = %for.cond23
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body26
  %34 = load i32, ptr %i, align 4
  %inc28 = add i32 %34, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond23, !llvm.loop !150

for.end29:                                        ; preds = %for.cond23
  br label %if.end30

if.end30:                                         ; preds = %for.end29, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsle_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s1, align 4
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i32, ptr %14, i64 %idx.ext8
  %16 = load i32, ptr %add.ptr9, align 4
  store i32 %16, ptr %s2, align 4
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i32, ptr %s2, align 4
  %26 = load i32, ptr %s1, align 4
  %cmp15 = icmp sle i32 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  %conv17 = trunc i32 %conv16 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !151

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then20
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %30, %31
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %34 = load i32, ptr %i, align 4
  %inc26 = add i32 %34, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !152

for.end27:                                        ; preds = %for.cond21
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsle_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s1, align 8
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i64, ptr %14, i64 %idx.ext8
  %16 = load i64, ptr %add.ptr9, align 8
  store i64 %16, ptr %s2, align 8
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i64, ptr %s2, align 8
  %26 = load i64, ptr %s1, align 8
  %cmp15 = icmp sle i64 %25, %26
  %conv16 = zext i1 %cmp15 to i32
  %conv17 = trunc i32 %conv16 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv17)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %27 = load i32, ptr %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !153

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %29 = load i32, ptr %vta_all_1s, align 4
  %tobool19 = icmp ne i32 %29, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc25, %if.then20
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %total_elems, align 4
  %cmp22 = icmp ult i32 %30, %31
  br i1 %cmp22, label %for.body24, label %for.end27

for.body24:                                       ; preds = %for.cond21
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %32, i32 noundef %33, i8 noundef zeroext 1)
  br label %for.inc25

for.inc25:                                        ; preds = %for.body24
  %34 = load i32, ptr %i, align 4
  %inc26 = add i32 %34, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond21, !llvm.loop !154

for.end27:                                        ; preds = %for.cond21
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmseq_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i8, ptr %s2, align 1
  %conv13 = zext i8 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i8
  %conv15 = zext i8 %conv14 to i32
  %cmp16 = icmp eq i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !155

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !156

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmseq_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %conv13 = zext i16 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i16
  %conv15 = zext i16 %conv14 to i32
  %cmp16 = icmp eq i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !157

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !158

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmseq_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %cmp14 = icmp eq i32 %22, %conv13
  %conv15 = zext i1 %cmp14 to i32
  %conv16 = trunc i32 %conv15 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !159

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %26, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %27, %28
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %31 = load i32, ptr %i, align 4
  %inc25 = add i32 %31, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !160

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmseq_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %cmp13 = icmp eq i64 %22, %23
  %conv14 = zext i1 %cmp13 to i32
  %conv15 = trunc i32 %conv14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !161

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %26, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %27, %28
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %31 = load i32, ptr %i, align 4
  %inc24 = add i32 %31, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !162

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsne_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i8, ptr %s2, align 1
  %conv13 = zext i8 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i8
  %conv15 = zext i8 %conv14 to i32
  %cmp16 = icmp ne i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !163

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !164

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsne_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %conv13 = zext i16 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i16
  %conv15 = zext i16 %conv14 to i32
  %cmp16 = icmp ne i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !165

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !166

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsne_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %cmp14 = icmp ne i32 %22, %conv13
  %conv15 = zext i1 %cmp14 to i32
  %conv16 = trunc i32 %conv15 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !167

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %26, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %27, %28
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %31 = load i32, ptr %i, align 4
  %inc25 = add i32 %31, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !168

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsne_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %cmp13 = icmp ne i64 %22, %23
  %conv14 = zext i1 %cmp13 to i32
  %conv15 = trunc i32 %conv14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !169

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %26, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %27, %28
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %31 = load i32, ptr %i, align 4
  %inc24 = add i32 %31, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !170

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsltu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i8, ptr %s2, align 1
  %conv13 = zext i8 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i8
  %conv15 = zext i8 %conv14 to i32
  %cmp16 = icmp slt i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !171

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !172

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsltu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %conv13 = zext i16 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i16
  %conv15 = zext i16 %conv14 to i32
  %cmp16 = icmp slt i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !173

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !174

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsltu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %cmp14 = icmp ult i32 %22, %conv13
  %conv15 = zext i1 %cmp14 to i32
  %conv16 = trunc i32 %conv15 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !175

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %26, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %27, %28
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %31 = load i32, ptr %i, align 4
  %inc25 = add i32 %31, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !176

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsltu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %cmp13 = icmp ult i64 %22, %23
  %conv14 = zext i1 %cmp13 to i32
  %conv15 = trunc i32 %conv14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !177

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %26, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %27, %28
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %31 = load i32, ptr %i, align 4
  %inc24 = add i32 %31, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !178

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmslt_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i8, ptr %s2, align 1
  %conv13 = sext i8 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i8
  %conv15 = sext i8 %conv14 to i32
  %cmp16 = icmp slt i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !179

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !180

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmslt_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %conv13 = sext i16 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i16
  %conv15 = sext i16 %conv14 to i32
  %cmp16 = icmp slt i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !181

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !182

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmslt_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %cmp14 = icmp slt i32 %22, %conv13
  %conv15 = zext i1 %cmp14 to i32
  %conv16 = trunc i32 %conv15 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !183

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %26, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %27, %28
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %31 = load i32, ptr %i, align 4
  %inc25 = add i32 %31, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !184

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmslt_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %cmp13 = icmp slt i64 %22, %23
  %conv14 = zext i1 %cmp13 to i32
  %conv15 = trunc i32 %conv14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !185

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %26, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %27, %28
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %31 = load i32, ptr %i, align 4
  %inc24 = add i32 %31, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !186

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsleu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i8, ptr %s2, align 1
  %conv13 = zext i8 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i8
  %conv15 = zext i8 %conv14 to i32
  %cmp16 = icmp sle i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !187

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !188

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsleu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %conv13 = zext i16 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i16
  %conv15 = zext i16 %conv14 to i32
  %cmp16 = icmp sle i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !189

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !190

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsleu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %cmp14 = icmp ule i32 %22, %conv13
  %conv15 = zext i1 %cmp14 to i32
  %conv16 = trunc i32 %conv15 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !191

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %26, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %27, %28
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %31 = load i32, ptr %i, align 4
  %inc25 = add i32 %31, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !192

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsleu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %cmp13 = icmp ule i64 %22, %23
  %conv14 = zext i1 %cmp13 to i32
  %conv15 = trunc i32 %conv14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !193

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %26, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %27, %28
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %31 = load i32, ptr %i, align 4
  %inc24 = add i32 %31, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !194

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsle_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i8, ptr %s2, align 1
  %conv13 = sext i8 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i8
  %conv15 = sext i8 %conv14 to i32
  %cmp16 = icmp sle i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !195

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !196

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsle_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %conv13 = sext i16 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i16
  %conv15 = sext i16 %conv14 to i32
  %cmp16 = icmp sle i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !197

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !198

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsle_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %cmp14 = icmp sle i32 %22, %conv13
  %conv15 = zext i1 %cmp14 to i32
  %conv16 = trunc i32 %conv15 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !199

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %26, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %27, %28
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %31 = load i32, ptr %i, align 4
  %inc25 = add i32 %31, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !200

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsle_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %cmp13 = icmp sle i64 %22, %23
  %conv14 = zext i1 %cmp13 to i32
  %conv15 = trunc i32 %conv14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !201

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %26, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %27, %28
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %31 = load i32, ptr %i, align 4
  %inc24 = add i32 %31, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !202

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsgtu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i8, ptr %s2, align 1
  %conv13 = zext i8 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i8
  %conv15 = zext i8 %conv14 to i32
  %cmp16 = icmp sgt i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !203

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !204

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsgtu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %conv13 = zext i16 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i16
  %conv15 = zext i16 %conv14 to i32
  %cmp16 = icmp sgt i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !205

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !206

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsgtu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %cmp14 = icmp ugt i32 %22, %conv13
  %conv15 = zext i1 %cmp14 to i32
  %conv16 = trunc i32 %conv15 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !207

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %26, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %27, %28
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %31 = load i32, ptr %i, align 4
  %inc25 = add i32 %31, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !208

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsgtu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %cmp13 = icmp ugt i64 %22, %23
  %conv14 = zext i1 %cmp13 to i32
  %conv15 = trunc i32 %conv14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !209

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %26, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %27, %28
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %31 = load i32, ptr %i, align 4
  %inc24 = add i32 %31, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !210

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsgt_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i8, ptr %s2, align 1
  %conv13 = sext i8 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i8
  %conv15 = sext i8 %conv14 to i32
  %cmp16 = icmp sgt i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !211

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !212

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsgt_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %conv13 = sext i16 %22 to i32
  %23 = load i64, ptr %s1.addr, align 8
  %conv14 = trunc i64 %23 to i16
  %conv15 = sext i16 %conv14 to i32
  %cmp16 = icmp sgt i32 %conv13, %conv15
  %conv17 = zext i1 %cmp16 to i32
  %conv18 = trunc i32 %conv17 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv18)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !213

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %if.then21
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp23 = icmp ult i32 %27, %28
  br i1 %cmp23, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond22
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %31 = load i32, ptr %i, align 4
  %inc27 = add i32 %31, 1
  store i32 %inc27, ptr %i, align 4
  br label %for.cond22, !llvm.loop !214

for.end28:                                        ; preds = %for.cond22
  br label %if.end29

if.end29:                                         ; preds = %for.end28, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsgt_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %cmp14 = icmp sgt i32 %22, %conv13
  %conv15 = zext i1 %cmp14 to i32
  %conv16 = trunc i32 %conv15 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !215

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %26, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %27, %28
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %31 = load i32, ptr %i, align 4
  %inc25 = add i32 %31, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !216

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsgt_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %cmp13 = icmp sgt i64 %22, %23
  %conv14 = zext i1 %cmp13 to i32
  %conv15 = trunc i32 %conv14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !217

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %26 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %26, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %27, %28
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %29, i32 noundef %30, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %31 = load i32, ptr %i, align 4
  %inc24 = add i32 %31, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !218

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vminu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vminu_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vminu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %conv = zext i8 %6 to i32
  %7 = load i8, ptr %s1, align 1
  %conv3 = zext i8 %7 to i32
  %cmp = icmp sge i32 %conv, %conv3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i8, ptr %s1, align 1
  %conv5 = zext i8 %8 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i8, ptr %s2, align 1
  %conv6 = zext i8 %9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i8
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %11 to i64
  %add.ptr9 = getelementptr i8, ptr %10, i64 %idx.ext8
  store i8 %conv7, ptr %add.ptr9, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vminu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vminu_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vminu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv = zext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv3 = zext i16 %7 to i32
  %cmp = icmp sge i32 %conv, %conv3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i16, ptr %s1, align 2
  %conv5 = zext i16 %8 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i16, ptr %s2, align 2
  %conv6 = zext i16 %9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i16
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %11 to i64
  %add.ptr9 = getelementptr i16, ptr %10, i64 %idx.ext8
  store i16 %conv7, ptr %add.ptr9, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vminu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vminu_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vminu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %cmp = icmp uge i32 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i32, ptr %s1, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i32, ptr %s2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %8, %cond.true ], [ %9, %cond.false ]
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %cond, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vminu_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vminu_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vminu_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %cmp = icmp uge i64 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i64, ptr %s1, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i64, ptr %s2, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %8, %cond.true ], [ %9, %cond.false ]
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %cond, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmin_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmin_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmin_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %conv = sext i8 %6 to i32
  %7 = load i8, ptr %s1, align 1
  %conv3 = sext i8 %7 to i32
  %cmp = icmp sge i32 %conv, %conv3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i8, ptr %s1, align 1
  %conv5 = sext i8 %8 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i8, ptr %s2, align 1
  %conv6 = sext i8 %9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i8
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %11 to i64
  %add.ptr9 = getelementptr i8, ptr %10, i64 %idx.ext8
  store i8 %conv7, ptr %add.ptr9, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmin_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmin_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmin_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv3 = sext i16 %7 to i32
  %cmp = icmp sge i32 %conv, %conv3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i16, ptr %s1, align 2
  %conv5 = sext i16 %8 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i16, ptr %s2, align 2
  %conv6 = sext i16 %9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i16
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %11 to i64
  %add.ptr9 = getelementptr i16, ptr %10, i64 %idx.ext8
  store i16 %conv7, ptr %add.ptr9, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmin_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmin_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmin_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %cmp = icmp sge i32 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i32, ptr %s1, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i32, ptr %s2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %8, %cond.true ], [ %9, %cond.false ]
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %cond, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmin_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmin_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmin_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %cmp = icmp sge i64 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i64, ptr %s1, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i64, ptr %s2, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %8, %cond.true ], [ %9, %cond.false ]
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %cond, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmaxu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmaxu_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmaxu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %conv = zext i8 %6 to i32
  %7 = load i8, ptr %s1, align 1
  %conv3 = zext i8 %7 to i32
  %cmp = icmp sge i32 %conv, %conv3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i8, ptr %s2, align 1
  %conv5 = zext i8 %8 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i8, ptr %s1, align 1
  %conv6 = zext i8 %9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i8
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %11 to i64
  %add.ptr9 = getelementptr i8, ptr %10, i64 %idx.ext8
  store i8 %conv7, ptr %add.ptr9, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmaxu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmaxu_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmaxu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv = zext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv3 = zext i16 %7 to i32
  %cmp = icmp sge i32 %conv, %conv3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i16, ptr %s2, align 2
  %conv5 = zext i16 %8 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i16, ptr %s1, align 2
  %conv6 = zext i16 %9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i16
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %11 to i64
  %add.ptr9 = getelementptr i16, ptr %10, i64 %idx.ext8
  store i16 %conv7, ptr %add.ptr9, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmaxu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmaxu_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmaxu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %cmp = icmp uge i32 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i32, ptr %s2, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i32, ptr %s1, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %8, %cond.true ], [ %9, %cond.false ]
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %cond, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmaxu_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmaxu_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmaxu_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %cmp = icmp uge i64 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i64, ptr %s2, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i64, ptr %s1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %8, %cond.true ], [ %9, %cond.false ]
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %cond, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmax_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmax_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmax_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %conv = sext i8 %6 to i32
  %7 = load i8, ptr %s1, align 1
  %conv3 = sext i8 %7 to i32
  %cmp = icmp sge i32 %conv, %conv3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i8, ptr %s2, align 1
  %conv5 = sext i8 %8 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i8, ptr %s1, align 1
  %conv6 = sext i8 %9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i8
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %11 to i64
  %add.ptr9 = getelementptr i8, ptr %10, i64 %idx.ext8
  store i8 %conv7, ptr %add.ptr9, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmax_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmax_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmax_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv3 = sext i16 %7 to i32
  %cmp = icmp sge i32 %conv, %conv3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i16, ptr %s2, align 2
  %conv5 = sext i16 %8 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i16, ptr %s1, align 2
  %conv6 = sext i16 %9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i16
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %11 to i64
  %add.ptr9 = getelementptr i16, ptr %10, i64 %idx.ext8
  store i16 %conv7, ptr %add.ptr9, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmax_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmax_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmax_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %cmp = icmp sge i32 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i32, ptr %s2, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i32, ptr %s1, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %8, %cond.true ], [ %9, %cond.false ]
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %cond, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmax_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmax_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmax_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %cmp = icmp sge i64 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i64, ptr %s2, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i64, ptr %s1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %8, %cond.true ], [ %9, %cond.false ]
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %cond, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vminu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vminu_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vminu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %conv = zext i8 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = zext i8 %conv1 to i32
  %cmp = icmp sge i32 %conv, %conv2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %5 to i8
  %conv5 = zext i8 %conv4 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i8, ptr %s2, align 1
  %conv6 = zext i8 %6 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i8
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %8 to i64
  %add.ptr9 = getelementptr i8, ptr %7, i64 %idx.ext8
  store i8 %conv7, ptr %add.ptr9, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vminu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vminu_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vminu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = zext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = zext i16 %conv1 to i32
  %cmp = icmp sge i32 %conv, %conv2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %5 to i16
  %conv5 = zext i16 %conv4 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i16, ptr %s2, align 2
  %conv6 = zext i16 %6 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i16
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %8 to i64
  %add.ptr9 = getelementptr i16, ptr %7, i64 %idx.ext8
  store i16 %conv7, ptr %add.ptr9, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vminu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vminu_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vminu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %cmp = icmp uge i32 %3, %conv
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %5 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i32, ptr %s2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv2, %cond.true ], [ %6, %cond.false ]
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %8 to i64
  %add.ptr4 = getelementptr i32, ptr %7, i64 %idx.ext3
  store i32 %cond, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vminu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vminu_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vminu_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %cmp = icmp uge i64 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, ptr %s1.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, ptr %s2, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %6, %cond.false ]
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %cond, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmin_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmin_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmin_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %conv = sext i8 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = sext i8 %conv1 to i32
  %cmp = icmp sge i32 %conv, %conv2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %5 to i8
  %conv5 = sext i8 %conv4 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i8, ptr %s2, align 1
  %conv6 = sext i8 %6 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i8
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %8 to i64
  %add.ptr9 = getelementptr i8, ptr %7, i64 %idx.ext8
  store i8 %conv7, ptr %add.ptr9, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmin_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmin_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmin_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = sext i16 %conv1 to i32
  %cmp = icmp sge i32 %conv, %conv2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %5 to i16
  %conv5 = sext i16 %conv4 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i16, ptr %s2, align 2
  %conv6 = sext i16 %6 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i16
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %8 to i64
  %add.ptr9 = getelementptr i16, ptr %7, i64 %idx.ext8
  store i16 %conv7, ptr %add.ptr9, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmin_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmin_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmin_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %cmp = icmp sge i32 %3, %conv
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %5 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i32, ptr %s2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv2, %cond.true ], [ %6, %cond.false ]
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %8 to i64
  %add.ptr4 = getelementptr i32, ptr %7, i64 %idx.ext3
  store i32 %cond, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmin_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmin_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmin_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %cmp = icmp sge i64 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, ptr %s1.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, ptr %s2, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %6, %cond.false ]
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %cond, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmaxu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmaxu_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmaxu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %conv = zext i8 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = zext i8 %conv1 to i32
  %cmp = icmp sge i32 %conv, %conv2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i8, ptr %s2, align 1
  %conv4 = zext i8 %5 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, ptr %s1.addr, align 8
  %conv5 = trunc i64 %6 to i8
  %conv6 = zext i8 %conv5 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv4, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i8
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %8 to i64
  %add.ptr9 = getelementptr i8, ptr %7, i64 %idx.ext8
  store i8 %conv7, ptr %add.ptr9, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmaxu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmaxu_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmaxu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = zext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = zext i16 %conv1 to i32
  %cmp = icmp sge i32 %conv, %conv2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i16, ptr %s2, align 2
  %conv4 = zext i16 %5 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, ptr %s1.addr, align 8
  %conv5 = trunc i64 %6 to i16
  %conv6 = zext i16 %conv5 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv4, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i16
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %8 to i64
  %add.ptr9 = getelementptr i16, ptr %7, i64 %idx.ext8
  store i16 %conv7, ptr %add.ptr9, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmaxu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmaxu_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmaxu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %cmp = icmp uge i32 %3, %conv
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i32, ptr %s2, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %6 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %5, %cond.true ], [ %conv2, %cond.false ]
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %8 to i64
  %add.ptr4 = getelementptr i32, ptr %7, i64 %idx.ext3
  store i32 %cond, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmaxu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmaxu_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmaxu_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %cmp = icmp uge i64 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, ptr %s2, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, ptr %s1.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %6, %cond.false ]
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %cond, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmax_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmax_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmax_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %conv = sext i8 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = sext i8 %conv1 to i32
  %cmp = icmp sge i32 %conv, %conv2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i8, ptr %s2, align 1
  %conv4 = sext i8 %5 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, ptr %s1.addr, align 8
  %conv5 = trunc i64 %6 to i8
  %conv6 = sext i8 %conv5 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv4, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i8
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %8 to i64
  %add.ptr9 = getelementptr i8, ptr %7, i64 %idx.ext8
  store i8 %conv7, ptr %add.ptr9, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmax_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmax_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmax_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = sext i16 %conv1 to i32
  %cmp = icmp sge i32 %conv, %conv2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i16, ptr %s2, align 2
  %conv4 = sext i16 %5 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, ptr %s1.addr, align 8
  %conv5 = trunc i64 %6 to i16
  %conv6 = sext i16 %conv5 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv4, %cond.true ], [ %conv6, %cond.false ]
  %conv7 = trunc i32 %cond to i16
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %8 to i64
  %add.ptr9 = getelementptr i16, ptr %7, i64 %idx.ext8
  store i16 %conv7, ptr %add.ptr9, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmax_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmax_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmax_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %cmp = icmp sge i32 %3, %conv
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i32, ptr %s2, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %6 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %5, %cond.true ], [ %conv2, %cond.false ]
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %8 to i64
  %add.ptr4 = getelementptr i32, ptr %7, i64 %idx.ext3
  store i32 %cond, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmax_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmax_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmax_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %cmp = icmp sge i64 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, ptr %s2, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, ptr %s1.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %6, %cond.false ]
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %cond, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmul_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmul_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmul_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %conv = sext i8 %6 to i32
  %7 = load i8, ptr %s1, align 1
  %conv3 = sext i8 %7 to i32
  %mul = mul i32 %conv, %conv3
  %conv4 = trunc i32 %mul to i8
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %9 to i64
  %add.ptr6 = getelementptr i8, ptr %8, i64 %idx.ext5
  store i8 %conv4, ptr %add.ptr6, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmul_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmul_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmul_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv3 = sext i16 %7 to i32
  %mul = mul i32 %conv, %conv3
  %conv4 = trunc i32 %mul to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %9 to i64
  %add.ptr6 = getelementptr i16, ptr %8, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmul_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmul_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmul_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %mul = mul i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %mul, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmul_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmul_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmul_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %mul = mul i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %mul, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulh_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulh_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulh_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %7 = load i8, ptr %s1, align 1
  %call = call signext i8 @do_mulh_b(i8 noundef signext %6, i8 noundef signext %7)
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i8, ptr %8, i64 %idx.ext3
  store i8 %call, ptr %add.ptr4, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulh_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulh_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulh_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i16, ptr %s1, align 2
  %call = call signext i16 @do_mulh_h(i16 noundef signext %6, i16 noundef signext %7)
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i16, ptr %8, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulh_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulh_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulh_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %call = call i32 @do_mulh_w(i32 noundef %6, i32 noundef %7)
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulh_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulh_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulh_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %call = call i64 @do_mulh_d(i64 noundef %6, i64 noundef %7)
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhu_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %7 = load i8, ptr %s1, align 1
  %call = call zeroext i8 @do_mulhu_b(i8 noundef zeroext %6, i8 noundef zeroext %7)
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i8, ptr %8, i64 %idx.ext3
  store i8 %call, ptr %add.ptr4, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhu_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i16, ptr %s1, align 2
  %call = call zeroext i16 @do_mulhu_h(i16 noundef zeroext %6, i16 noundef zeroext %7)
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i16, ptr %8, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhu_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %call = call i32 @do_mulhu_w(i32 noundef %6, i32 noundef %7)
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhu_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhu_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhu_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %call = call i64 @do_mulhu_d(i64 noundef %6, i64 noundef %7)
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhsu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhsu_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhsu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s2, align 1
  %7 = load i8, ptr %s1, align 1
  %call = call signext i8 @do_mulhsu_b(i8 noundef signext %6, i8 noundef zeroext %7)
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i8, ptr %8, i64 %idx.ext3
  store i8 %call, ptr %add.ptr4, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhsu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhsu_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhsu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i16, ptr %s1, align 2
  %call = call signext i16 @do_mulhsu_h(i16 noundef signext %6, i16 noundef zeroext %7)
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i16, ptr %8, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhsu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhsu_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhsu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %call = call i32 @do_mulhsu_w(i32 noundef %6, i32 noundef %7)
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i32, ptr %8, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhsu_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhsu_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhsu_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %call = call i64 @do_mulhsu_d(i64 noundef %6, i64 noundef %7)
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %9 to i64
  %add.ptr4 = getelementptr i64, ptr %8, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmul_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmul_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmul_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %conv = sext i8 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i8
  %conv2 = sext i8 %conv1 to i32
  %mul = mul i32 %conv, %conv2
  %conv3 = trunc i32 %mul to i8
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i8, ptr %5, i64 %idx.ext4
  store i8 %conv3, ptr %add.ptr5, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmul_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmul_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmul_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = sext i16 %conv1 to i32
  %mul = mul i32 %conv, %conv2
  %conv3 = trunc i32 %mul to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr i16, ptr %5, i64 %idx.ext4
  store i16 %conv3, ptr %add.ptr5, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmul_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmul_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmul_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %mul = mul i32 %3, %conv
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %mul, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmul_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmul_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmul_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %mul = mul i64 %3, %4
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %mul, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulh_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulh_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulh_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i8
  %call = call signext i8 @do_mulh_b(i8 noundef signext %3, i8 noundef signext %conv)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i8, ptr %5, i64 %idx.ext1
  store i8 %call, ptr %add.ptr2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulh_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulh_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulh_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %call = call signext i16 @do_mulh_h(i16 noundef signext %3, i16 noundef signext %conv)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulh_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulh_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulh_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %call = call i32 @do_mulh_w(i32 noundef %3, i32 noundef %conv)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulh_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulh_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulh_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %call = call i64 @do_mulh_d(i64 noundef %3, i64 noundef %4)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhu_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i8
  %call = call zeroext i8 @do_mulhu_b(i8 noundef zeroext %3, i8 noundef zeroext %conv)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i8, ptr %5, i64 %idx.ext1
  store i8 %call, ptr %add.ptr2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhu_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %call = call zeroext i16 @do_mulhu_h(i16 noundef zeroext %3, i16 noundef zeroext %conv)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhu_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %call = call i32 @do_mulhu_w(i32 noundef %3, i32 noundef %conv)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhu_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhu_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %call = call i64 @do_mulhu_d(i64 noundef %3, i64 noundef %4)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhsu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhsu_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhsu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i8
  %call = call signext i8 @do_mulhsu_b(i8 noundef signext %3, i8 noundef zeroext %conv)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i8, ptr %5, i64 %idx.ext1
  store i8 %call, ptr %add.ptr2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhsu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhsu_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhsu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %call = call signext i16 @do_mulhsu_h(i16 noundef signext %3, i16 noundef zeroext %conv)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhsu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhsu_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhsu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %call = call i32 @do_mulhsu_w(i32 noundef %3, i32 noundef %conv)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmulhsu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmulhsu_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmulhsu_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %call = call i64 @do_mulhsu_d(i64 noundef %3, i64 noundef %4)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdivu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdivu_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdivu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s1, align 1
  %conv = zext i8 %6 to i32
  %cmp = icmp eq i32 %conv, 0
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv5, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load i8, ptr %s2, align 1
  %conv6 = zext i8 %7 to i32
  %8 = load i8, ptr %s1, align 1
  %conv7 = zext i8 %8 to i32
  %div = sdiv i32 %conv6, %conv7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 255, %cond.true ], [ %div, %cond.false ]
  %conv8 = trunc i32 %cond to i8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext9 = sext i32 %10 to i64
  %add.ptr10 = getelementptr i8, ptr %9, i64 %idx.ext9
  store i8 %conv8, ptr %add.ptr10, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdivu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdivu_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdivu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s1, align 2
  %conv = zext i16 %6 to i32
  %cmp = icmp eq i32 %conv, 0
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv5, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load i16, ptr %s2, align 2
  %conv6 = zext i16 %7 to i32
  %8 = load i16, ptr %s1, align 2
  %conv7 = zext i16 %8 to i32
  %div = sdiv i32 %conv6, %conv7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 65535, %cond.true ], [ %div, %cond.false ]
  %conv8 = trunc i32 %cond to i16
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext9 = sext i32 %10 to i64
  %add.ptr10 = getelementptr i16, ptr %9, i64 %idx.ext9
  store i16 %conv8, ptr %add.ptr10, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdivu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdivu_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdivu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s1, align 4
  %cmp = icmp eq i32 %6, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load i32, ptr %s2, align 4
  %8 = load i32, ptr %s1, align 4
  %div = udiv i32 %7, %8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %div, %cond.false ]
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %10 to i64
  %add.ptr5 = getelementptr i32, ptr %9, i64 %idx.ext4
  store i32 %cond, ptr %add.ptr5, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdivu_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdivu_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdivu_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s1, align 8
  %cmp = icmp eq i64 %6, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load i64, ptr %s2, align 8
  %8 = load i64, ptr %s1, align 8
  %div = udiv i64 %7, %8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ -1, %cond.true ], [ %div, %cond.false ]
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %10 to i64
  %add.ptr5 = getelementptr i64, ptr %9, i64 %idx.ext4
  store i64 %cond, ptr %add.ptr5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdiv_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdiv_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdiv_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s1, align 1
  %conv = sext i8 %6 to i32
  %cmp = icmp eq i32 %conv, 0
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv5, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end24

cond.false:                                       ; preds = %entry
  %7 = load i8, ptr %s2, align 1
  %conv6 = sext i8 %7 to i32
  %8 = load i8, ptr %s2, align 1
  %conv7 = sext i8 %8 to i32
  %sub = sub i32 0, %conv7
  %cmp8 = icmp eq i32 %conv6, %sub
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %9 = load i8, ptr %s1, align 1
  %conv10 = sext i8 %9 to i32
  %cmp11 = icmp eq i32 %conv10, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %10 = phi i1 [ false, %cond.false ], [ %cmp11, %land.rhs ]
  %lnot13 = xor i1 %10, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %tobool18 = icmp ne i64 %conv17, 0
  br i1 %tobool18, label %cond.true19, label %cond.false21

cond.true19:                                      ; preds = %land.end
  %11 = load i8, ptr %s2, align 1
  %conv20 = sext i8 %11 to i32
  br label %cond.end

cond.false21:                                     ; preds = %land.end
  %12 = load i8, ptr %s2, align 1
  %conv22 = sext i8 %12 to i32
  %13 = load i8, ptr %s1, align 1
  %conv23 = sext i8 %13 to i32
  %div = sdiv i32 %conv22, %conv23
  br label %cond.end

cond.end:                                         ; preds = %cond.false21, %cond.true19
  %cond = phi i32 [ %conv20, %cond.true19 ], [ %div, %cond.false21 ]
  br label %cond.end24

cond.end24:                                       ; preds = %cond.end, %cond.true
  %cond25 = phi i32 [ -1, %cond.true ], [ %cond, %cond.end ]
  %conv26 = trunc i32 %cond25 to i8
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %i.addr, align 4
  %idx.ext27 = sext i32 %15 to i64
  %add.ptr28 = getelementptr i8, ptr %14, i64 %idx.ext27
  store i8 %conv26, ptr %add.ptr28, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdiv_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdiv_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdiv_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s1, align 2
  %conv = sext i16 %6 to i32
  %cmp = icmp eq i32 %conv, 0
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv5, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end24

cond.false:                                       ; preds = %entry
  %7 = load i16, ptr %s2, align 2
  %conv6 = sext i16 %7 to i32
  %8 = load i16, ptr %s2, align 2
  %conv7 = sext i16 %8 to i32
  %sub = sub i32 0, %conv7
  %cmp8 = icmp eq i32 %conv6, %sub
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %9 = load i16, ptr %s1, align 2
  %conv10 = sext i16 %9 to i32
  %cmp11 = icmp eq i32 %conv10, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %10 = phi i1 [ false, %cond.false ], [ %cmp11, %land.rhs ]
  %lnot13 = xor i1 %10, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %tobool18 = icmp ne i64 %conv17, 0
  br i1 %tobool18, label %cond.true19, label %cond.false21

cond.true19:                                      ; preds = %land.end
  %11 = load i16, ptr %s2, align 2
  %conv20 = sext i16 %11 to i32
  br label %cond.end

cond.false21:                                     ; preds = %land.end
  %12 = load i16, ptr %s2, align 2
  %conv22 = sext i16 %12 to i32
  %13 = load i16, ptr %s1, align 2
  %conv23 = sext i16 %13 to i32
  %div = sdiv i32 %conv22, %conv23
  br label %cond.end

cond.end:                                         ; preds = %cond.false21, %cond.true19
  %cond = phi i32 [ %conv20, %cond.true19 ], [ %div, %cond.false21 ]
  br label %cond.end24

cond.end24:                                       ; preds = %cond.end, %cond.true
  %cond25 = phi i32 [ -1, %cond.true ], [ %cond, %cond.end ]
  %conv26 = trunc i32 %cond25 to i16
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %i.addr, align 4
  %idx.ext27 = sext i32 %15 to i64
  %add.ptr28 = getelementptr i16, ptr %14, i64 %idx.ext27
  store i16 %conv26, ptr %add.ptr28, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdiv_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdiv_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdiv_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s1, align 4
  %cmp = icmp eq i32 %6, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end16

cond.false:                                       ; preds = %entry
  %7 = load i32, ptr %s2, align 4
  %8 = load i32, ptr %s2, align 4
  %sub = sub i32 0, %8
  %cmp4 = icmp eq i32 %7, %sub
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %9 = load i32, ptr %s1, align 4
  %cmp6 = icmp eq i32 %9, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %10 = phi i1 [ false, %cond.false ], [ %cmp6, %land.rhs ]
  %lnot8 = xor i1 %10, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %tobool13 = icmp ne i64 %conv12, 0
  br i1 %tobool13, label %cond.true14, label %cond.false15

cond.true14:                                      ; preds = %land.end
  %11 = load i32, ptr %s2, align 4
  br label %cond.end

cond.false15:                                     ; preds = %land.end
  %12 = load i32, ptr %s2, align 4
  %13 = load i32, ptr %s1, align 4
  %div = sdiv i32 %12, %13
  br label %cond.end

cond.end:                                         ; preds = %cond.false15, %cond.true14
  %cond = phi i32 [ %11, %cond.true14 ], [ %div, %cond.false15 ]
  br label %cond.end16

cond.end16:                                       ; preds = %cond.end, %cond.true
  %cond17 = phi i32 [ -1, %cond.true ], [ %cond, %cond.end ]
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %i.addr, align 4
  %idx.ext18 = sext i32 %15 to i64
  %add.ptr19 = getelementptr i32, ptr %14, i64 %idx.ext18
  store i32 %cond17, ptr %add.ptr19, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdiv_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdiv_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdiv_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s1, align 8
  %cmp = icmp eq i64 %6, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end16

cond.false:                                       ; preds = %entry
  %7 = load i64, ptr %s2, align 8
  %8 = load i64, ptr %s2, align 8
  %sub = sub i64 0, %8
  %cmp4 = icmp eq i64 %7, %sub
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %9 = load i64, ptr %s1, align 8
  %cmp6 = icmp eq i64 %9, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %10 = phi i1 [ false, %cond.false ], [ %cmp6, %land.rhs ]
  %lnot8 = xor i1 %10, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %tobool13 = icmp ne i64 %conv12, 0
  br i1 %tobool13, label %cond.true14, label %cond.false15

cond.true14:                                      ; preds = %land.end
  %11 = load i64, ptr %s2, align 8
  br label %cond.end

cond.false15:                                     ; preds = %land.end
  %12 = load i64, ptr %s2, align 8
  %13 = load i64, ptr %s1, align 8
  %div = sdiv i64 %12, %13
  br label %cond.end

cond.end:                                         ; preds = %cond.false15, %cond.true14
  %cond = phi i64 [ %11, %cond.true14 ], [ %div, %cond.false15 ]
  br label %cond.end16

cond.end16:                                       ; preds = %cond.end, %cond.true
  %cond17 = phi i64 [ -1, %cond.true ], [ %cond, %cond.end ]
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %i.addr, align 4
  %idx.ext18 = sext i32 %15 to i64
  %add.ptr19 = getelementptr i64, ptr %14, i64 %idx.ext18
  store i64 %cond17, ptr %add.ptr19, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vremu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vremu_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vremu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s1, align 1
  %conv = zext i8 %6 to i32
  %cmp = icmp eq i32 %conv, 0
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv5, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i8, ptr %s2, align 1
  %conv6 = zext i8 %7 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %8 = load i8, ptr %s2, align 1
  %conv7 = zext i8 %8 to i32
  %9 = load i8, ptr %s1, align 1
  %conv8 = zext i8 %9 to i32
  %rem = srem i32 %conv7, %conv8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv6, %cond.true ], [ %rem, %cond.false ]
  %conv9 = trunc i32 %cond to i8
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext10 = sext i32 %11 to i64
  %add.ptr11 = getelementptr i8, ptr %10, i64 %idx.ext10
  store i8 %conv9, ptr %add.ptr11, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vremu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vremu_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vremu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s1, align 2
  %conv = zext i16 %6 to i32
  %cmp = icmp eq i32 %conv, 0
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv5, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i16, ptr %s2, align 2
  %conv6 = zext i16 %7 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %8 = load i16, ptr %s2, align 2
  %conv7 = zext i16 %8 to i32
  %9 = load i16, ptr %s1, align 2
  %conv8 = zext i16 %9 to i32
  %rem = srem i32 %conv7, %conv8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv6, %cond.true ], [ %rem, %cond.false ]
  %conv9 = trunc i32 %cond to i16
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext10 = sext i32 %11 to i64
  %add.ptr11 = getelementptr i16, ptr %10, i64 %idx.ext10
  store i16 %conv9, ptr %add.ptr11, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vremu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vremu_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vremu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s1, align 4
  %cmp = icmp eq i32 %6, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i32, ptr %s2, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s1, align 4
  %rem = urem i32 %8, %9
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %7, %cond.true ], [ %rem, %cond.false ]
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %11 to i64
  %add.ptr5 = getelementptr i32, ptr %10, i64 %idx.ext4
  store i32 %cond, ptr %add.ptr5, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vremu_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vremu_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vremu_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s1, align 8
  %cmp = icmp eq i64 %6, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i64, ptr %s2, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s1, align 8
  %rem = urem i64 %8, %9
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %7, %cond.true ], [ %rem, %cond.false ]
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %11 to i64
  %add.ptr5 = getelementptr i64, ptr %10, i64 %idx.ext4
  store i64 %cond, ptr %add.ptr5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrem_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vrem_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vrem_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load i8, ptr %s1, align 1
  %conv = sext i8 %6 to i32
  %cmp = icmp eq i32 %conv, 0
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv5, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i8, ptr %s2, align 1
  %conv6 = sext i8 %7 to i32
  br label %cond.end24

cond.false:                                       ; preds = %entry
  %8 = load i8, ptr %s2, align 1
  %conv7 = sext i8 %8 to i32
  %9 = load i8, ptr %s2, align 1
  %conv8 = sext i8 %9 to i32
  %sub = sub i32 0, %conv8
  %cmp9 = icmp eq i32 %conv7, %sub
  br i1 %cmp9, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %10 = load i8, ptr %s1, align 1
  %conv11 = sext i8 %10 to i32
  %cmp12 = icmp eq i32 %conv11, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %11 = phi i1 [ false, %cond.false ], [ %cmp12, %land.rhs ]
  %lnot14 = xor i1 %11, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  %tobool19 = icmp ne i64 %conv18, 0
  br i1 %tobool19, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %land.end
  br label %cond.end

cond.false21:                                     ; preds = %land.end
  %12 = load i8, ptr %s2, align 1
  %conv22 = sext i8 %12 to i32
  %13 = load i8, ptr %s1, align 1
  %conv23 = sext i8 %13 to i32
  %rem = srem i32 %conv22, %conv23
  br label %cond.end

cond.end:                                         ; preds = %cond.false21, %cond.true20
  %cond = phi i32 [ 0, %cond.true20 ], [ %rem, %cond.false21 ]
  br label %cond.end24

cond.end24:                                       ; preds = %cond.end, %cond.true
  %cond25 = phi i32 [ %conv6, %cond.true ], [ %cond, %cond.end ]
  %conv26 = trunc i32 %cond25 to i8
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %i.addr, align 4
  %idx.ext27 = sext i32 %15 to i64
  %add.ptr28 = getelementptr i8, ptr %14, i64 %idx.ext27
  store i8 %conv26, ptr %add.ptr28, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrem_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vrem_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vrem_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s1, align 2
  %conv = sext i16 %6 to i32
  %cmp = icmp eq i32 %conv, 0
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv5, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i16, ptr %s2, align 2
  %conv6 = sext i16 %7 to i32
  br label %cond.end24

cond.false:                                       ; preds = %entry
  %8 = load i16, ptr %s2, align 2
  %conv7 = sext i16 %8 to i32
  %9 = load i16, ptr %s2, align 2
  %conv8 = sext i16 %9 to i32
  %sub = sub i32 0, %conv8
  %cmp9 = icmp eq i32 %conv7, %sub
  br i1 %cmp9, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %10 = load i16, ptr %s1, align 2
  %conv11 = sext i16 %10 to i32
  %cmp12 = icmp eq i32 %conv11, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %11 = phi i1 [ false, %cond.false ], [ %cmp12, %land.rhs ]
  %lnot14 = xor i1 %11, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  %tobool19 = icmp ne i64 %conv18, 0
  br i1 %tobool19, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %land.end
  br label %cond.end

cond.false21:                                     ; preds = %land.end
  %12 = load i16, ptr %s2, align 2
  %conv22 = sext i16 %12 to i32
  %13 = load i16, ptr %s1, align 2
  %conv23 = sext i16 %13 to i32
  %rem = srem i32 %conv22, %conv23
  br label %cond.end

cond.end:                                         ; preds = %cond.false21, %cond.true20
  %cond = phi i32 [ 0, %cond.true20 ], [ %rem, %cond.false21 ]
  br label %cond.end24

cond.end24:                                       ; preds = %cond.end, %cond.true
  %cond25 = phi i32 [ %conv6, %cond.true ], [ %cond, %cond.end ]
  %conv26 = trunc i32 %cond25 to i16
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %i.addr, align 4
  %idx.ext27 = sext i32 %15 to i64
  %add.ptr28 = getelementptr i16, ptr %14, i64 %idx.ext27
  store i16 %conv26, ptr %add.ptr28, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrem_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vrem_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vrem_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s1, align 4
  %cmp = icmp eq i32 %6, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i32, ptr %s2, align 4
  br label %cond.end16

cond.false:                                       ; preds = %entry
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s2, align 4
  %sub = sub i32 0, %9
  %cmp4 = icmp eq i32 %8, %sub
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %10 = load i32, ptr %s1, align 4
  %cmp6 = icmp eq i32 %10, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %11 = phi i1 [ false, %cond.false ], [ %cmp6, %land.rhs ]
  %lnot8 = xor i1 %11, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %tobool13 = icmp ne i64 %conv12, 0
  br i1 %tobool13, label %cond.true14, label %cond.false15

cond.true14:                                      ; preds = %land.end
  br label %cond.end

cond.false15:                                     ; preds = %land.end
  %12 = load i32, ptr %s2, align 4
  %13 = load i32, ptr %s1, align 4
  %rem = srem i32 %12, %13
  br label %cond.end

cond.end:                                         ; preds = %cond.false15, %cond.true14
  %cond = phi i32 [ 0, %cond.true14 ], [ %rem, %cond.false15 ]
  br label %cond.end16

cond.end16:                                       ; preds = %cond.end, %cond.true
  %cond17 = phi i32 [ %7, %cond.true ], [ %cond, %cond.end ]
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %i.addr, align 4
  %idx.ext18 = sext i32 %15 to i64
  %add.ptr19 = getelementptr i32, ptr %14, i64 %idx.ext18
  store i32 %cond17, ptr %add.ptr19, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrem_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vrem_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vrem_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s1, align 8
  %cmp = icmp eq i64 %6, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i64, ptr %s2, align 8
  br label %cond.end16

cond.false:                                       ; preds = %entry
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s2, align 8
  %sub = sub i64 0, %9
  %cmp4 = icmp eq i64 %8, %sub
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %10 = load i64, ptr %s1, align 8
  %cmp6 = icmp eq i64 %10, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %11 = phi i1 [ false, %cond.false ], [ %cmp6, %land.rhs ]
  %lnot8 = xor i1 %11, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %tobool13 = icmp ne i64 %conv12, 0
  br i1 %tobool13, label %cond.true14, label %cond.false15

cond.true14:                                      ; preds = %land.end
  br label %cond.end

cond.false15:                                     ; preds = %land.end
  %12 = load i64, ptr %s2, align 8
  %13 = load i64, ptr %s1, align 8
  %rem = srem i64 %12, %13
  br label %cond.end

cond.end:                                         ; preds = %cond.false15, %cond.true14
  %cond = phi i64 [ 0, %cond.true14 ], [ %rem, %cond.false15 ]
  br label %cond.end16

cond.end16:                                       ; preds = %cond.end, %cond.true
  %cond17 = phi i64 [ %7, %cond.true ], [ %cond, %cond.end ]
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %i.addr, align 4
  %idx.ext18 = sext i32 %15 to i64
  %add.ptr19 = getelementptr i64, ptr %14, i64 %idx.ext18
  store i64 %cond17, ptr %add.ptr19, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdivu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdivu_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdivu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i8
  %conv1 = zext i8 %conv to i32
  %cmp = icmp eq i32 %conv1, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv4, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i8, ptr %s2, align 1
  %conv5 = zext i8 %4 to i32
  %5 = load i64, ptr %s1.addr, align 8
  %conv6 = trunc i64 %5 to i8
  %conv7 = zext i8 %conv6 to i32
  %div = sdiv i32 %conv5, %conv7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 255, %cond.true ], [ %div, %cond.false ]
  %conv8 = trunc i32 %cond to i8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext9 = sext i32 %7 to i64
  %add.ptr10 = getelementptr i8, ptr %6, i64 %idx.ext9
  store i8 %conv8, ptr %add.ptr10, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdivu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdivu_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdivu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i16
  %conv1 = zext i16 %conv to i32
  %cmp = icmp eq i32 %conv1, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv4, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i16, ptr %s2, align 2
  %conv5 = zext i16 %4 to i32
  %5 = load i64, ptr %s1.addr, align 8
  %conv6 = trunc i64 %5 to i16
  %conv7 = zext i16 %conv6 to i32
  %div = sdiv i32 %conv5, %conv7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 65535, %cond.true ], [ %div, %cond.false ]
  %conv8 = trunc i32 %cond to i16
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext9 = sext i32 %7 to i64
  %add.ptr10 = getelementptr i16, ptr %6, i64 %idx.ext9
  store i16 %conv8, ptr %add.ptr10, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdivu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdivu_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdivu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i32
  %cmp = icmp eq i32 %conv, 0
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv3, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, ptr %s2, align 4
  %5 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %5 to i32
  %div = udiv i32 %4, %conv4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %div, %cond.false ]
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %7 to i64
  %add.ptr6 = getelementptr i32, ptr %6, i64 %idx.ext5
  store i32 %cond, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdivu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdivu_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdivu_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s1.addr, align 8
  %cmp = icmp eq i64 %3, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i64, ptr %s2, align 8
  %5 = load i64, ptr %s1.addr, align 8
  %div = udiv i64 %4, %5
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ -1, %cond.true ], [ %div, %cond.false ]
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %7 to i64
  %add.ptr3 = getelementptr i64, ptr %6, i64 %idx.ext2
  store i64 %cond, ptr %add.ptr3, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdiv_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdiv_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdiv_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i8
  %conv1 = sext i8 %conv to i32
  %cmp = icmp eq i32 %conv1, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv4, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end25

cond.false:                                       ; preds = %entry
  %4 = load i8, ptr %s2, align 1
  %conv5 = sext i8 %4 to i32
  %5 = load i8, ptr %s2, align 1
  %conv6 = sext i8 %5 to i32
  %sub = sub i32 0, %conv6
  %cmp7 = icmp eq i32 %conv5, %sub
  br i1 %cmp7, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %6 = load i64, ptr %s1.addr, align 8
  %conv9 = trunc i64 %6 to i8
  %conv10 = sext i8 %conv9 to i32
  %cmp11 = icmp eq i32 %conv10, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %7 = phi i1 [ false, %cond.false ], [ %cmp11, %land.rhs ]
  %lnot13 = xor i1 %7, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %tobool18 = icmp ne i64 %conv17, 0
  br i1 %tobool18, label %cond.true19, label %cond.false21

cond.true19:                                      ; preds = %land.end
  %8 = load i8, ptr %s2, align 1
  %conv20 = sext i8 %8 to i32
  br label %cond.end

cond.false21:                                     ; preds = %land.end
  %9 = load i8, ptr %s2, align 1
  %conv22 = sext i8 %9 to i32
  %10 = load i64, ptr %s1.addr, align 8
  %conv23 = trunc i64 %10 to i8
  %conv24 = sext i8 %conv23 to i32
  %div = sdiv i32 %conv22, %conv24
  br label %cond.end

cond.end:                                         ; preds = %cond.false21, %cond.true19
  %cond = phi i32 [ %conv20, %cond.true19 ], [ %div, %cond.false21 ]
  br label %cond.end25

cond.end25:                                       ; preds = %cond.end, %cond.true
  %cond26 = phi i32 [ -1, %cond.true ], [ %cond, %cond.end ]
  %conv27 = trunc i32 %cond26 to i8
  %11 = load ptr, ptr %vd.addr, align 8
  %12 = load i32, ptr %i.addr, align 4
  %idx.ext28 = sext i32 %12 to i64
  %add.ptr29 = getelementptr i8, ptr %11, i64 %idx.ext28
  store i8 %conv27, ptr %add.ptr29, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdiv_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdiv_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdiv_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i16
  %conv1 = sext i16 %conv to i32
  %cmp = icmp eq i32 %conv1, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv4, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end25

cond.false:                                       ; preds = %entry
  %4 = load i16, ptr %s2, align 2
  %conv5 = sext i16 %4 to i32
  %5 = load i16, ptr %s2, align 2
  %conv6 = sext i16 %5 to i32
  %sub = sub i32 0, %conv6
  %cmp7 = icmp eq i32 %conv5, %sub
  br i1 %cmp7, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %6 = load i64, ptr %s1.addr, align 8
  %conv9 = trunc i64 %6 to i16
  %conv10 = sext i16 %conv9 to i32
  %cmp11 = icmp eq i32 %conv10, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %7 = phi i1 [ false, %cond.false ], [ %cmp11, %land.rhs ]
  %lnot13 = xor i1 %7, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %tobool18 = icmp ne i64 %conv17, 0
  br i1 %tobool18, label %cond.true19, label %cond.false21

cond.true19:                                      ; preds = %land.end
  %8 = load i16, ptr %s2, align 2
  %conv20 = sext i16 %8 to i32
  br label %cond.end

cond.false21:                                     ; preds = %land.end
  %9 = load i16, ptr %s2, align 2
  %conv22 = sext i16 %9 to i32
  %10 = load i64, ptr %s1.addr, align 8
  %conv23 = trunc i64 %10 to i16
  %conv24 = sext i16 %conv23 to i32
  %div = sdiv i32 %conv22, %conv24
  br label %cond.end

cond.end:                                         ; preds = %cond.false21, %cond.true19
  %cond = phi i32 [ %conv20, %cond.true19 ], [ %div, %cond.false21 ]
  br label %cond.end25

cond.end25:                                       ; preds = %cond.end, %cond.true
  %cond26 = phi i32 [ -1, %cond.true ], [ %cond, %cond.end ]
  %conv27 = trunc i32 %cond26 to i16
  %11 = load ptr, ptr %vd.addr, align 8
  %12 = load i32, ptr %i.addr, align 4
  %idx.ext28 = sext i32 %12 to i64
  %add.ptr29 = getelementptr i16, ptr %11, i64 %idx.ext28
  store i16 %conv27, ptr %add.ptr29, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdiv_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdiv_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdiv_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i32
  %cmp = icmp eq i32 %conv, 0
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv3, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end18

cond.false:                                       ; preds = %entry
  %4 = load i32, ptr %s2, align 4
  %5 = load i32, ptr %s2, align 4
  %sub = sub i32 0, %5
  %cmp4 = icmp eq i32 %4, %sub
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %6 = load i64, ptr %s1.addr, align 8
  %conv6 = trunc i64 %6 to i32
  %cmp7 = icmp eq i32 %conv6, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %7 = phi i1 [ false, %cond.false ], [ %cmp7, %land.rhs ]
  %lnot9 = xor i1 %7, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %tobool14 = icmp ne i64 %conv13, 0
  br i1 %tobool14, label %cond.true15, label %cond.false16

cond.true15:                                      ; preds = %land.end
  %8 = load i32, ptr %s2, align 4
  br label %cond.end

cond.false16:                                     ; preds = %land.end
  %9 = load i32, ptr %s2, align 4
  %10 = load i64, ptr %s1.addr, align 8
  %conv17 = trunc i64 %10 to i32
  %div = sdiv i32 %9, %conv17
  br label %cond.end

cond.end:                                         ; preds = %cond.false16, %cond.true15
  %cond = phi i32 [ %8, %cond.true15 ], [ %div, %cond.false16 ]
  br label %cond.end18

cond.end18:                                       ; preds = %cond.end, %cond.true
  %cond19 = phi i32 [ -1, %cond.true ], [ %cond, %cond.end ]
  %11 = load ptr, ptr %vd.addr, align 8
  %12 = load i32, ptr %i.addr, align 4
  %idx.ext20 = sext i32 %12 to i64
  %add.ptr21 = getelementptr i32, ptr %11, i64 %idx.ext20
  store i32 %cond19, ptr %add.ptr21, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vdiv_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vdiv_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vdiv_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s1.addr, align 8
  %cmp = icmp eq i64 %3, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end14

cond.false:                                       ; preds = %entry
  %4 = load i64, ptr %s2, align 8
  %5 = load i64, ptr %s2, align 8
  %sub = sub i64 0, %5
  %cmp2 = icmp eq i64 %4, %sub
  br i1 %cmp2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %6 = load i64, ptr %s1.addr, align 8
  %cmp4 = icmp eq i64 %6, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %7 = phi i1 [ false, %cond.false ], [ %cmp4, %land.rhs ]
  %lnot6 = xor i1 %7, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv10 = sext i32 %lnot.ext9 to i64
  %tobool11 = icmp ne i64 %conv10, 0
  br i1 %tobool11, label %cond.true12, label %cond.false13

cond.true12:                                      ; preds = %land.end
  %8 = load i64, ptr %s2, align 8
  br label %cond.end

cond.false13:                                     ; preds = %land.end
  %9 = load i64, ptr %s2, align 8
  %10 = load i64, ptr %s1.addr, align 8
  %div = sdiv i64 %9, %10
  br label %cond.end

cond.end:                                         ; preds = %cond.false13, %cond.true12
  %cond = phi i64 [ %8, %cond.true12 ], [ %div, %cond.false13 ]
  br label %cond.end14

cond.end14:                                       ; preds = %cond.end, %cond.true
  %cond15 = phi i64 [ -1, %cond.true ], [ %cond, %cond.end ]
  %11 = load ptr, ptr %vd.addr, align 8
  %12 = load i32, ptr %i.addr, align 4
  %idx.ext16 = sext i32 %12 to i64
  %add.ptr17 = getelementptr i64, ptr %11, i64 %idx.ext16
  store i64 %cond15, ptr %add.ptr17, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vremu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vremu_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vremu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i8
  %conv1 = zext i8 %conv to i32
  %cmp = icmp eq i32 %conv1, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv4, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i8, ptr %s2, align 1
  %conv5 = zext i8 %4 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load i8, ptr %s2, align 1
  %conv6 = zext i8 %5 to i32
  %6 = load i64, ptr %s1.addr, align 8
  %conv7 = trunc i64 %6 to i8
  %conv8 = zext i8 %conv7 to i32
  %rem = srem i32 %conv6, %conv8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %rem, %cond.false ]
  %conv9 = trunc i32 %cond to i8
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext10 = sext i32 %8 to i64
  %add.ptr11 = getelementptr i8, ptr %7, i64 %idx.ext10
  store i8 %conv9, ptr %add.ptr11, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vremu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vremu_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vremu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i16
  %conv1 = zext i16 %conv to i32
  %cmp = icmp eq i32 %conv1, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv4, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i16, ptr %s2, align 2
  %conv5 = zext i16 %4 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load i16, ptr %s2, align 2
  %conv6 = zext i16 %5 to i32
  %6 = load i64, ptr %s1.addr, align 8
  %conv7 = trunc i64 %6 to i16
  %conv8 = zext i16 %conv7 to i32
  %rem = srem i32 %conv6, %conv8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %rem, %cond.false ]
  %conv9 = trunc i32 %cond to i16
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext10 = sext i32 %8 to i64
  %add.ptr11 = getelementptr i16, ptr %7, i64 %idx.ext10
  store i16 %conv9, ptr %add.ptr11, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vremu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vremu_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vremu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i32
  %cmp = icmp eq i32 %conv, 0
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv3, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i32, ptr %s2, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %6 to i32
  %rem = urem i32 %5, %conv4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %4, %cond.true ], [ %rem, %cond.false ]
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %8 to i64
  %add.ptr6 = getelementptr i32, ptr %7, i64 %idx.ext5
  store i32 %cond, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vremu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vremu_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vremu_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s1.addr, align 8
  %cmp = icmp eq i64 %3, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i64, ptr %s2, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %rem = urem i64 %5, %6
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %4, %cond.true ], [ %rem, %cond.false ]
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %8 to i64
  %add.ptr3 = getelementptr i64, ptr %7, i64 %idx.ext2
  store i64 %cond, ptr %add.ptr3, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrem_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vrem_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vrem_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i8
  %conv1 = sext i8 %conv to i32
  %cmp = icmp eq i32 %conv1, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv4, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i8, ptr %s2, align 1
  %conv5 = sext i8 %4 to i32
  br label %cond.end25

cond.false:                                       ; preds = %entry
  %5 = load i8, ptr %s2, align 1
  %conv6 = sext i8 %5 to i32
  %6 = load i8, ptr %s2, align 1
  %conv7 = sext i8 %6 to i32
  %sub = sub i32 0, %conv7
  %cmp8 = icmp eq i32 %conv6, %sub
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %7 = load i64, ptr %s1.addr, align 8
  %conv10 = trunc i64 %7 to i8
  %conv11 = sext i8 %conv10 to i32
  %cmp12 = icmp eq i32 %conv11, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %8 = phi i1 [ false, %cond.false ], [ %cmp12, %land.rhs ]
  %lnot14 = xor i1 %8, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  %tobool19 = icmp ne i64 %conv18, 0
  br i1 %tobool19, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %land.end
  br label %cond.end

cond.false21:                                     ; preds = %land.end
  %9 = load i8, ptr %s2, align 1
  %conv22 = sext i8 %9 to i32
  %10 = load i64, ptr %s1.addr, align 8
  %conv23 = trunc i64 %10 to i8
  %conv24 = sext i8 %conv23 to i32
  %rem = srem i32 %conv22, %conv24
  br label %cond.end

cond.end:                                         ; preds = %cond.false21, %cond.true20
  %cond = phi i32 [ 0, %cond.true20 ], [ %rem, %cond.false21 ]
  br label %cond.end25

cond.end25:                                       ; preds = %cond.end, %cond.true
  %cond26 = phi i32 [ %conv5, %cond.true ], [ %cond, %cond.end ]
  %conv27 = trunc i32 %cond26 to i8
  %11 = load ptr, ptr %vd.addr, align 8
  %12 = load i32, ptr %i.addr, align 4
  %idx.ext28 = sext i32 %12 to i64
  %add.ptr29 = getelementptr i8, ptr %11, i64 %idx.ext28
  store i8 %conv27, ptr %add.ptr29, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrem_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vrem_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vrem_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i16
  %conv1 = sext i16 %conv to i32
  %cmp = icmp eq i32 %conv1, 0
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv4, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i16, ptr %s2, align 2
  %conv5 = sext i16 %4 to i32
  br label %cond.end25

cond.false:                                       ; preds = %entry
  %5 = load i16, ptr %s2, align 2
  %conv6 = sext i16 %5 to i32
  %6 = load i16, ptr %s2, align 2
  %conv7 = sext i16 %6 to i32
  %sub = sub i32 0, %conv7
  %cmp8 = icmp eq i32 %conv6, %sub
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %7 = load i64, ptr %s1.addr, align 8
  %conv10 = trunc i64 %7 to i16
  %conv11 = sext i16 %conv10 to i32
  %cmp12 = icmp eq i32 %conv11, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %8 = phi i1 [ false, %cond.false ], [ %cmp12, %land.rhs ]
  %lnot14 = xor i1 %8, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  %tobool19 = icmp ne i64 %conv18, 0
  br i1 %tobool19, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %land.end
  br label %cond.end

cond.false21:                                     ; preds = %land.end
  %9 = load i16, ptr %s2, align 2
  %conv22 = sext i16 %9 to i32
  %10 = load i64, ptr %s1.addr, align 8
  %conv23 = trunc i64 %10 to i16
  %conv24 = sext i16 %conv23 to i32
  %rem = srem i32 %conv22, %conv24
  br label %cond.end

cond.end:                                         ; preds = %cond.false21, %cond.true20
  %cond = phi i32 [ 0, %cond.true20 ], [ %rem, %cond.false21 ]
  br label %cond.end25

cond.end25:                                       ; preds = %cond.end, %cond.true
  %cond26 = phi i32 [ %conv5, %cond.true ], [ %cond, %cond.end ]
  %conv27 = trunc i32 %cond26 to i16
  %11 = load ptr, ptr %vd.addr, align 8
  %12 = load i32, ptr %i.addr, align 4
  %idx.ext28 = sext i32 %12 to i64
  %add.ptr29 = getelementptr i16, ptr %11, i64 %idx.ext28
  store i16 %conv27, ptr %add.ptr29, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrem_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vrem_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vrem_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %3 to i32
  %cmp = icmp eq i32 %conv, 0
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv3, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i32, ptr %s2, align 4
  br label %cond.end18

cond.false:                                       ; preds = %entry
  %5 = load i32, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %sub = sub i32 0, %6
  %cmp4 = icmp eq i32 %5, %sub
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %7 = load i64, ptr %s1.addr, align 8
  %conv6 = trunc i64 %7 to i32
  %cmp7 = icmp eq i32 %conv6, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %8 = phi i1 [ false, %cond.false ], [ %cmp7, %land.rhs ]
  %lnot9 = xor i1 %8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %tobool14 = icmp ne i64 %conv13, 0
  br i1 %tobool14, label %cond.true15, label %cond.false16

cond.true15:                                      ; preds = %land.end
  br label %cond.end

cond.false16:                                     ; preds = %land.end
  %9 = load i32, ptr %s2, align 4
  %10 = load i64, ptr %s1.addr, align 8
  %conv17 = trunc i64 %10 to i32
  %rem = srem i32 %9, %conv17
  br label %cond.end

cond.end:                                         ; preds = %cond.false16, %cond.true15
  %cond = phi i32 [ 0, %cond.true15 ], [ %rem, %cond.false16 ]
  br label %cond.end18

cond.end18:                                       ; preds = %cond.end, %cond.true
  %cond19 = phi i32 [ %4, %cond.true ], [ %cond, %cond.end ]
  %11 = load ptr, ptr %vd.addr, align 8
  %12 = load i32, ptr %i.addr, align 4
  %idx.ext20 = sext i32 %12 to i64
  %add.ptr21 = getelementptr i32, ptr %11, i64 %idx.ext20
  store i32 %cond19, ptr %add.ptr21, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrem_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vrem_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vrem_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s1.addr, align 8
  %cmp = icmp eq i64 %3, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i64, ptr %s2, align 8
  br label %cond.end14

cond.false:                                       ; preds = %entry
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %sub = sub i64 0, %6
  %cmp2 = icmp eq i64 %5, %sub
  br i1 %cmp2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %7 = load i64, ptr %s1.addr, align 8
  %cmp4 = icmp eq i64 %7, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %8 = phi i1 [ false, %cond.false ], [ %cmp4, %land.rhs ]
  %lnot6 = xor i1 %8, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv10 = sext i32 %lnot.ext9 to i64
  %tobool11 = icmp ne i64 %conv10, 0
  br i1 %tobool11, label %cond.true12, label %cond.false13

cond.true12:                                      ; preds = %land.end
  br label %cond.end

cond.false13:                                     ; preds = %land.end
  %9 = load i64, ptr %s2, align 8
  %10 = load i64, ptr %s1.addr, align 8
  %rem = srem i64 %9, %10
  br label %cond.end

cond.end:                                         ; preds = %cond.false13, %cond.true12
  %cond = phi i64 [ 0, %cond.true12 ], [ %rem, %cond.false13 ]
  br label %cond.end14

cond.end14:                                       ; preds = %cond.end, %cond.true
  %cond15 = phi i64 [ %4, %cond.true ], [ %cond, %cond.end ]
  %11 = load ptr, ptr %vd.addr, align 8
  %12 = load i32, ptr %i.addr, align 4
  %idx.ext16 = sext i32 %12 to i64
  %add.ptr17 = getelementptr i64, ptr %11, i64 %idx.ext16
  store i64 %cond15, ptr %add.ptr17, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmul_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmul_vv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmul_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  %conv3 = sext i8 %5 to i16
  store i16 %conv3, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv4 = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv5 = sext i16 %7 to i32
  %mul = mul i32 %conv4, %conv5
  %conv6 = trunc i32 %mul to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %9 to i64
  %add.ptr8 = getelementptr i16, ptr %8, i64 %idx.ext7
  store i16 %conv6, ptr %add.ptr8, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmul_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmul_vv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmul_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = sext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %mul = mul i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i32, ptr %8, i64 %idx.ext4
  store i32 %mul, ptr %add.ptr5, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmul_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmul_vv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmul_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = sext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %mul = mul i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i64, ptr %8, i64 %idx.ext4
  store i64 %mul, ptr %add.ptr5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmulu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmulu_vv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmulu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  %conv3 = zext i8 %5 to i16
  store i16 %conv3, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv4 = zext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv5 = zext i16 %7 to i32
  %mul = mul i32 %conv4, %conv5
  %conv6 = trunc i32 %mul to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %9 to i64
  %add.ptr8 = getelementptr i16, ptr %8, i64 %idx.ext7
  store i16 %conv6, ptr %add.ptr8, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmulu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmulu_vv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmulu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %mul = mul i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i32, ptr %8, i64 %idx.ext4
  store i32 %mul, ptr %add.ptr5, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmulu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmulu_vv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmulu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %mul = mul i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i64, ptr %8, i64 %idx.ext4
  store i64 %mul, ptr %add.ptr5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmulsu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmulsu_vv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmulsu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  %conv3 = sext i8 %5 to i16
  store i16 %conv3, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %conv4 = sext i16 %6 to i32
  %7 = load i16, ptr %s1, align 2
  %conv5 = zext i16 %7 to i32
  %mul = mul i32 %conv4, %conv5
  %conv6 = trunc i32 %mul to i16
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %9 to i64
  %add.ptr8 = getelementptr i16, ptr %8, i64 %idx.ext7
  store i16 %conv6, ptr %add.ptr8, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmulsu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmulsu_vv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmulsu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = sext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %mul = mul i32 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i32, ptr %8, i64 %idx.ext4
  store i32 %mul, ptr %add.ptr5, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmulsu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmulsu_vv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmulsu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = sext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %mul = mul i64 %6, %7
  %8 = load ptr, ptr %vd.addr, align 8
  %9 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %9 to i64
  %add.ptr5 = getelementptr i64, ptr %8, i64 %idx.ext4
  store i64 %mul, ptr %add.ptr5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmul_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmul_vx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmul_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv1 = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i8
  %conv3 = sext i8 %conv2 to i16
  %conv4 = sext i16 %conv3 to i32
  %mul = mul i32 %conv1, %conv4
  %conv5 = trunc i32 %mul to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %6 to i64
  %add.ptr7 = getelementptr i16, ptr %5, i64 %idx.ext6
  store i16 %conv5, ptr %add.ptr7, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmul_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmul_vx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmul_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = sext i16 %conv1 to i32
  %mul = mul i32 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i32, ptr %5, i64 %idx.ext3
  store i32 %mul, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmul_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmul_vx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmul_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i32
  %conv2 = sext i32 %conv1 to i64
  %mul = mul i64 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i64, ptr %5, i64 %idx.ext3
  store i64 %mul, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmulu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmulu_vx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmulu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv1 = zext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i8
  %conv3 = zext i8 %conv2 to i16
  %conv4 = zext i16 %conv3 to i32
  %mul = mul i32 %conv1, %conv4
  %conv5 = trunc i32 %mul to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %6 to i64
  %add.ptr7 = getelementptr i16, ptr %5, i64 %idx.ext6
  store i16 %conv5, ptr %add.ptr7, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmulu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmulu_vx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmulu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = zext i16 %conv1 to i32
  %mul = mul i32 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i32, ptr %5, i64 %idx.ext3
  store i32 %mul, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmulu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmulu_vx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmulu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i32
  %conv2 = zext i32 %conv1 to i64
  %mul = mul i64 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i64, ptr %5, i64 %idx.ext3
  store i64 %mul, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmulsu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmulsu_vx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmulsu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv1 = sext i16 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i8
  %conv3 = zext i8 %conv2 to i16
  %conv4 = zext i16 %conv3 to i32
  %mul = mul i32 %conv1, %conv4
  %conv5 = trunc i32 %mul to i16
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %6 to i64
  %add.ptr7 = getelementptr i16, ptr %5, i64 %idx.ext6
  store i16 %conv5, ptr %add.ptr7, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmulsu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmulsu_vx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmulsu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i16
  %conv2 = zext i16 %conv1 to i32
  %mul = mul i32 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i32, ptr %5, i64 %idx.ext3
  store i32 %mul, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmulsu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmulsu_vx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmulsu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %4 to i32
  %conv2 = zext i32 %conv1 to i64
  %mul = mul i64 %3, %conv2
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr i64, ptr %5, i64 %idx.ext3
  store i64 %mul, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmacc_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmacc_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmacc_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  %d = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i8, ptr %6, i64 %idx.ext3
  %8 = load i8, ptr %add.ptr4, align 1
  store i8 %8, ptr %d, align 1
  %9 = load i8, ptr %s1, align 1
  %conv = sext i8 %9 to i32
  %10 = load i8, ptr %s2, align 1
  %conv5 = sext i8 %10 to i32
  %mul = mul i32 %conv, %conv5
  %11 = load i8, ptr %d, align 1
  %conv6 = sext i8 %11 to i32
  %add = add i32 %mul, %conv6
  %conv7 = trunc i32 %add to i8
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %13 to i64
  %add.ptr9 = getelementptr i8, ptr %12, i64 %idx.ext8
  store i8 %conv7, ptr %add.ptr9, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmacc_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmacc_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmacc_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i16, ptr %6, i64 %idx.ext3
  %8 = load i16, ptr %add.ptr4, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s1, align 2
  %conv = sext i16 %9 to i32
  %10 = load i16, ptr %s2, align 2
  %conv5 = sext i16 %10 to i32
  %mul = mul i32 %conv, %conv5
  %11 = load i16, ptr %d, align 2
  %conv6 = sext i16 %11 to i32
  %add = add i32 %mul, %conv6
  %conv7 = trunc i32 %add to i16
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %13 to i64
  %add.ptr9 = getelementptr i16, ptr %12, i64 %idx.ext8
  store i16 %conv7, ptr %add.ptr9, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmacc_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmacc_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmacc_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  %8 = load i32, ptr %add.ptr4, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s1, align 4
  %10 = load i32, ptr %s2, align 4
  %mul = mul i32 %9, %10
  %11 = load i32, ptr %d, align 4
  %add = add i32 %mul, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %13 to i64
  %add.ptr6 = getelementptr i32, ptr %12, i64 %idx.ext5
  store i32 %add, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmacc_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmacc_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmacc_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  %8 = load i64, ptr %add.ptr4, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s1, align 8
  %10 = load i64, ptr %s2, align 8
  %mul = mul i64 %9, %10
  %11 = load i64, ptr %d, align 8
  %add = add i64 %mul, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %13 to i64
  %add.ptr6 = getelementptr i64, ptr %12, i64 %idx.ext5
  store i64 %add, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsac_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsac_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsac_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  %d = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i8, ptr %6, i64 %idx.ext3
  %8 = load i8, ptr %add.ptr4, align 1
  store i8 %8, ptr %d, align 1
  %9 = load i8, ptr %s1, align 1
  %conv = sext i8 %9 to i32
  %10 = load i8, ptr %s2, align 1
  %conv5 = sext i8 %10 to i32
  %mul = mul i32 %conv, %conv5
  %sub = sub i32 0, %mul
  %11 = load i8, ptr %d, align 1
  %conv6 = sext i8 %11 to i32
  %add = add i32 %sub, %conv6
  %conv7 = trunc i32 %add to i8
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %13 to i64
  %add.ptr9 = getelementptr i8, ptr %12, i64 %idx.ext8
  store i8 %conv7, ptr %add.ptr9, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsac_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsac_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsac_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i16, ptr %6, i64 %idx.ext3
  %8 = load i16, ptr %add.ptr4, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s1, align 2
  %conv = sext i16 %9 to i32
  %10 = load i16, ptr %s2, align 2
  %conv5 = sext i16 %10 to i32
  %mul = mul i32 %conv, %conv5
  %sub = sub i32 0, %mul
  %11 = load i16, ptr %d, align 2
  %conv6 = sext i16 %11 to i32
  %add = add i32 %sub, %conv6
  %conv7 = trunc i32 %add to i16
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %13 to i64
  %add.ptr9 = getelementptr i16, ptr %12, i64 %idx.ext8
  store i16 %conv7, ptr %add.ptr9, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsac_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsac_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsac_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  %8 = load i32, ptr %add.ptr4, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s1, align 4
  %10 = load i32, ptr %s2, align 4
  %mul = mul i32 %9, %10
  %sub = sub i32 0, %mul
  %11 = load i32, ptr %d, align 4
  %add = add i32 %sub, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %13 to i64
  %add.ptr6 = getelementptr i32, ptr %12, i64 %idx.ext5
  store i32 %add, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsac_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsac_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsac_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  %8 = load i64, ptr %add.ptr4, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s1, align 8
  %10 = load i64, ptr %s2, align 8
  %mul = mul i64 %9, %10
  %sub = sub i64 0, %mul
  %11 = load i64, ptr %d, align 8
  %add = add i64 %sub, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %13 to i64
  %add.ptr6 = getelementptr i64, ptr %12, i64 %idx.ext5
  store i64 %add, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadd_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmadd_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmadd_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  %d = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i8, ptr %6, i64 %idx.ext3
  %8 = load i8, ptr %add.ptr4, align 1
  store i8 %8, ptr %d, align 1
  %9 = load i8, ptr %s1, align 1
  %conv = sext i8 %9 to i32
  %10 = load i8, ptr %d, align 1
  %conv5 = sext i8 %10 to i32
  %mul = mul i32 %conv, %conv5
  %11 = load i8, ptr %s2, align 1
  %conv6 = sext i8 %11 to i32
  %add = add i32 %mul, %conv6
  %conv7 = trunc i32 %add to i8
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %13 to i64
  %add.ptr9 = getelementptr i8, ptr %12, i64 %idx.ext8
  store i8 %conv7, ptr %add.ptr9, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadd_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmadd_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmadd_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i16, ptr %6, i64 %idx.ext3
  %8 = load i16, ptr %add.ptr4, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s1, align 2
  %conv = sext i16 %9 to i32
  %10 = load i16, ptr %d, align 2
  %conv5 = sext i16 %10 to i32
  %mul = mul i32 %conv, %conv5
  %11 = load i16, ptr %s2, align 2
  %conv6 = sext i16 %11 to i32
  %add = add i32 %mul, %conv6
  %conv7 = trunc i32 %add to i16
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %13 to i64
  %add.ptr9 = getelementptr i16, ptr %12, i64 %idx.ext8
  store i16 %conv7, ptr %add.ptr9, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadd_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmadd_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmadd_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  %8 = load i32, ptr %add.ptr4, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s1, align 4
  %10 = load i32, ptr %d, align 4
  %mul = mul i32 %9, %10
  %11 = load i32, ptr %s2, align 4
  %add = add i32 %mul, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %13 to i64
  %add.ptr6 = getelementptr i32, ptr %12, i64 %idx.ext5
  store i32 %add, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadd_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmadd_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmadd_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  %8 = load i64, ptr %add.ptr4, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s1, align 8
  %10 = load i64, ptr %d, align 8
  %mul = mul i64 %9, %10
  %11 = load i64, ptr %s2, align 8
  %add = add i64 %mul, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %13 to i64
  %add.ptr6 = getelementptr i64, ptr %12, i64 %idx.ext5
  store i64 %add, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsub_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsub_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsub_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  %d = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i8, ptr %6, i64 %idx.ext3
  %8 = load i8, ptr %add.ptr4, align 1
  store i8 %8, ptr %d, align 1
  %9 = load i8, ptr %s1, align 1
  %conv = sext i8 %9 to i32
  %10 = load i8, ptr %d, align 1
  %conv5 = sext i8 %10 to i32
  %mul = mul i32 %conv, %conv5
  %sub = sub i32 0, %mul
  %11 = load i8, ptr %s2, align 1
  %conv6 = sext i8 %11 to i32
  %add = add i32 %sub, %conv6
  %conv7 = trunc i32 %add to i8
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %13 to i64
  %add.ptr9 = getelementptr i8, ptr %12, i64 %idx.ext8
  store i8 %conv7, ptr %add.ptr9, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsub_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsub_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsub_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i16, ptr %6, i64 %idx.ext3
  %8 = load i16, ptr %add.ptr4, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s1, align 2
  %conv = sext i16 %9 to i32
  %10 = load i16, ptr %d, align 2
  %conv5 = sext i16 %10 to i32
  %mul = mul i32 %conv, %conv5
  %sub = sub i32 0, %mul
  %11 = load i16, ptr %s2, align 2
  %conv6 = sext i16 %11 to i32
  %add = add i32 %sub, %conv6
  %conv7 = trunc i32 %add to i16
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %13 to i64
  %add.ptr9 = getelementptr i16, ptr %12, i64 %idx.ext8
  store i16 %conv7, ptr %add.ptr9, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsub_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsub_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsub_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  %8 = load i32, ptr %add.ptr4, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s1, align 4
  %10 = load i32, ptr %d, align 4
  %mul = mul i32 %9, %10
  %sub = sub i32 0, %mul
  %11 = load i32, ptr %s2, align 4
  %add = add i32 %sub, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %13 to i64
  %add.ptr6 = getelementptr i32, ptr %12, i64 %idx.ext5
  store i32 %add, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsub_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsub_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsub_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  %8 = load i64, ptr %add.ptr4, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s1, align 8
  %10 = load i64, ptr %d, align 8
  %mul = mul i64 %9, %10
  %sub = sub i64 0, %mul
  %11 = load i64, ptr %s2, align 8
  %add = add i64 %sub, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %13 to i64
  %add.ptr6 = getelementptr i64, ptr %12, i64 %idx.ext5
  store i64 %add, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmacc_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmacc_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmacc_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  %d = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %d, align 1
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %conv3 = sext i8 %conv to i32
  %7 = load i8, ptr %s2, align 1
  %conv4 = sext i8 %7 to i32
  %mul = mul i32 %conv3, %conv4
  %8 = load i8, ptr %d, align 1
  %conv5 = sext i8 %8 to i32
  %add = add i32 %mul, %conv5
  %conv6 = trunc i32 %add to i8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %10 to i64
  %add.ptr8 = getelementptr i8, ptr %9, i64 %idx.ext7
  store i8 %conv6, ptr %add.ptr8, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmacc_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmacc_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmacc_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %conv3 = sext i16 %conv to i32
  %7 = load i16, ptr %s2, align 2
  %conv4 = sext i16 %7 to i32
  %mul = mul i32 %conv3, %conv4
  %8 = load i16, ptr %d, align 2
  %conv5 = sext i16 %8 to i32
  %add = add i32 %mul, %conv5
  %conv6 = trunc i32 %add to i16
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %10 to i64
  %add.ptr8 = getelementptr i16, ptr %9, i64 %idx.ext7
  store i16 %conv6, ptr %add.ptr8, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmacc_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmacc_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmacc_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %7 = load i32, ptr %s2, align 4
  %mul = mul i32 %conv, %7
  %8 = load i32, ptr %d, align 4
  %add = add i32 %mul, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %add, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmacc_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmacc_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmacc_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %7 = load i64, ptr %s2, align 8
  %mul = mul i64 %6, %7
  %8 = load i64, ptr %d, align 8
  %add = add i64 %mul, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %add, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsac_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsac_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsac_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  %d = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %d, align 1
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %conv3 = sext i8 %conv to i32
  %7 = load i8, ptr %s2, align 1
  %conv4 = sext i8 %7 to i32
  %mul = mul i32 %conv3, %conv4
  %sub = sub i32 0, %mul
  %8 = load i8, ptr %d, align 1
  %conv5 = sext i8 %8 to i32
  %add = add i32 %sub, %conv5
  %conv6 = trunc i32 %add to i8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %10 to i64
  %add.ptr8 = getelementptr i8, ptr %9, i64 %idx.ext7
  store i8 %conv6, ptr %add.ptr8, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsac_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsac_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsac_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %conv3 = sext i16 %conv to i32
  %7 = load i16, ptr %s2, align 2
  %conv4 = sext i16 %7 to i32
  %mul = mul i32 %conv3, %conv4
  %sub = sub i32 0, %mul
  %8 = load i16, ptr %d, align 2
  %conv5 = sext i16 %8 to i32
  %add = add i32 %sub, %conv5
  %conv6 = trunc i32 %add to i16
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %10 to i64
  %add.ptr8 = getelementptr i16, ptr %9, i64 %idx.ext7
  store i16 %conv6, ptr %add.ptr8, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsac_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsac_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsac_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %7 = load i32, ptr %s2, align 4
  %mul = mul i32 %conv, %7
  %sub = sub i32 0, %mul
  %8 = load i32, ptr %d, align 4
  %add = add i32 %sub, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %add, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsac_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsac_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsac_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %7 = load i64, ptr %s2, align 8
  %mul = mul i64 %6, %7
  %sub = sub i64 0, %mul
  %8 = load i64, ptr %d, align 8
  %add = add i64 %sub, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %add, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadd_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmadd_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmadd_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  %d = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %d, align 1
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %conv3 = sext i8 %conv to i32
  %7 = load i8, ptr %d, align 1
  %conv4 = sext i8 %7 to i32
  %mul = mul i32 %conv3, %conv4
  %8 = load i8, ptr %s2, align 1
  %conv5 = sext i8 %8 to i32
  %add = add i32 %mul, %conv5
  %conv6 = trunc i32 %add to i8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %10 to i64
  %add.ptr8 = getelementptr i8, ptr %9, i64 %idx.ext7
  store i8 %conv6, ptr %add.ptr8, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadd_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmadd_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmadd_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %conv3 = sext i16 %conv to i32
  %7 = load i16, ptr %d, align 2
  %conv4 = sext i16 %7 to i32
  %mul = mul i32 %conv3, %conv4
  %8 = load i16, ptr %s2, align 2
  %conv5 = sext i16 %8 to i32
  %add = add i32 %mul, %conv5
  %conv6 = trunc i32 %add to i16
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %10 to i64
  %add.ptr8 = getelementptr i16, ptr %9, i64 %idx.ext7
  store i16 %conv6, ptr %add.ptr8, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadd_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmadd_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmadd_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %7 = load i32, ptr %d, align 4
  %mul = mul i32 %conv, %7
  %8 = load i32, ptr %s2, align 4
  %add = add i32 %mul, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %add, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmadd_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vmadd_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vmadd_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %7 = load i64, ptr %d, align 8
  %mul = mul i64 %6, %7
  %8 = load i64, ptr %s2, align 8
  %add = add i64 %mul, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %add, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsub_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsub_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsub_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  %d = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %d, align 1
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %conv3 = sext i8 %conv to i32
  %7 = load i8, ptr %d, align 1
  %conv4 = sext i8 %7 to i32
  %mul = mul i32 %conv3, %conv4
  %sub = sub i32 0, %mul
  %8 = load i8, ptr %s2, align 1
  %conv5 = sext i8 %8 to i32
  %add = add i32 %sub, %conv5
  %conv6 = trunc i32 %add to i8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %10 to i64
  %add.ptr8 = getelementptr i8, ptr %9, i64 %idx.ext7
  store i8 %conv6, ptr %add.ptr8, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsub_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsub_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsub_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %conv3 = sext i16 %conv to i32
  %7 = load i16, ptr %d, align 2
  %conv4 = sext i16 %7 to i32
  %mul = mul i32 %conv3, %conv4
  %sub = sub i32 0, %mul
  %8 = load i16, ptr %s2, align 2
  %conv5 = sext i16 %8 to i32
  %add = add i32 %sub, %conv5
  %conv6 = trunc i32 %add to i16
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %10 to i64
  %add.ptr8 = getelementptr i16, ptr %9, i64 %idx.ext7
  store i16 %conv6, ptr %add.ptr8, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsub_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsub_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsub_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %7 = load i32, ptr %d, align 4
  %mul = mul i32 %conv, %7
  %sub = sub i32 0, %mul
  %8 = load i32, ptr %s2, align 4
  %add = add i32 %sub, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %add, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnmsub_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnmsub_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnmsub_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %7 = load i64, ptr %d, align 8
  %mul = mul i64 %6, %7
  %sub = sub i64 0, %mul
  %8 = load i64, ptr %s2, align 8
  %add = add i64 %sub, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %add, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccu_vv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  %conv3 = zext i8 %5 to i16
  store i16 %conv3, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i16, ptr %6, i64 %idx.ext4
  %8 = load i16, ptr %add.ptr5, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s1, align 2
  %conv6 = zext i16 %9 to i32
  %10 = load i16, ptr %s2, align 2
  %conv7 = zext i16 %10 to i32
  %mul = mul i32 %conv6, %conv7
  %11 = load i16, ptr %d, align 2
  %conv8 = zext i16 %11 to i32
  %add = add i32 %mul, %conv8
  %conv9 = trunc i32 %add to i16
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext10 = sext i32 %13 to i64
  %add.ptr11 = getelementptr i16, ptr %12, i64 %idx.ext10
  store i16 %conv9, ptr %add.ptr11, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccu_vv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i32, ptr %6, i64 %idx.ext4
  %8 = load i32, ptr %add.ptr5, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s1, align 4
  %10 = load i32, ptr %s2, align 4
  %mul = mul i32 %9, %10
  %11 = load i32, ptr %d, align 4
  %add = add i32 %mul, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %13 to i64
  %add.ptr7 = getelementptr i32, ptr %12, i64 %idx.ext6
  store i32 %add, ptr %add.ptr7, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccu_vv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i64, ptr %6, i64 %idx.ext4
  %8 = load i64, ptr %add.ptr5, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s1, align 8
  %10 = load i64, ptr %s2, align 8
  %mul = mul i64 %9, %10
  %11 = load i64, ptr %d, align 8
  %add = add i64 %mul, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %13 to i64
  %add.ptr7 = getelementptr i64, ptr %12, i64 %idx.ext6
  store i64 %add, ptr %add.ptr7, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmacc_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmacc_vv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmacc_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  %conv3 = sext i8 %5 to i16
  store i16 %conv3, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i16, ptr %6, i64 %idx.ext4
  %8 = load i16, ptr %add.ptr5, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s1, align 2
  %conv6 = sext i16 %9 to i32
  %10 = load i16, ptr %s2, align 2
  %conv7 = sext i16 %10 to i32
  %mul = mul i32 %conv6, %conv7
  %11 = load i16, ptr %d, align 2
  %conv8 = sext i16 %11 to i32
  %add = add i32 %mul, %conv8
  %conv9 = trunc i32 %add to i16
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext10 = sext i32 %13 to i64
  %add.ptr11 = getelementptr i16, ptr %12, i64 %idx.ext10
  store i16 %conv9, ptr %add.ptr11, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmacc_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmacc_vv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmacc_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = sext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i32, ptr %6, i64 %idx.ext4
  %8 = load i32, ptr %add.ptr5, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s1, align 4
  %10 = load i32, ptr %s2, align 4
  %mul = mul i32 %9, %10
  %11 = load i32, ptr %d, align 4
  %add = add i32 %mul, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %13 to i64
  %add.ptr7 = getelementptr i32, ptr %12, i64 %idx.ext6
  store i32 %add, ptr %add.ptr7, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmacc_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmacc_vv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmacc_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = sext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i64, ptr %6, i64 %idx.ext4
  %8 = load i64, ptr %add.ptr5, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s1, align 8
  %10 = load i64, ptr %s2, align 8
  %mul = mul i64 %9, %10
  %11 = load i64, ptr %d, align 8
  %add = add i64 %mul, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %13 to i64
  %add.ptr7 = getelementptr i64, ptr %12, i64 %idx.ext6
  store i64 %add, ptr %add.ptr7, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccsu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccsu_vv_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccsu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  %conv3 = zext i8 %5 to i16
  store i16 %conv3, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i16, ptr %6, i64 %idx.ext4
  %8 = load i16, ptr %add.ptr5, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s1, align 2
  %conv6 = sext i16 %9 to i32
  %10 = load i16, ptr %s2, align 2
  %conv7 = zext i16 %10 to i32
  %mul = mul i32 %conv6, %conv7
  %11 = load i16, ptr %d, align 2
  %conv8 = sext i16 %11 to i32
  %add = add i32 %mul, %conv8
  %conv9 = trunc i32 %add to i16
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext10 = sext i32 %13 to i64
  %add.ptr11 = getelementptr i16, ptr %12, i64 %idx.ext10
  store i16 %conv9, ptr %add.ptr11, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccsu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccsu_vv_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccsu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i32, ptr %6, i64 %idx.ext4
  %8 = load i32, ptr %add.ptr5, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s1, align 4
  %10 = load i32, ptr %s2, align 4
  %mul = mul i32 %9, %10
  %11 = load i32, ptr %d, align 4
  %add = add i32 %mul, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %13 to i64
  %add.ptr7 = getelementptr i32, ptr %12, i64 %idx.ext6
  store i32 %add, ptr %add.ptr7, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccsu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vv(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccsu_vv_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccsu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i64, ptr %6, i64 %idx.ext4
  %8 = load i64, ptr %add.ptr5, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s1, align 8
  %10 = load i64, ptr %s2, align 8
  %mul = mul i64 %9, %10
  %11 = load i64, ptr %d, align 8
  %add = add i64 %mul, %11
  %12 = load ptr, ptr %vd.addr, align 8
  %13 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %13 to i64
  %add.ptr7 = getelementptr i64, ptr %12, i64 %idx.ext6
  store i64 %add, ptr %add.ptr7, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccu_vx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv3 = trunc i64 %6 to i8
  %conv4 = zext i8 %conv3 to i16
  %conv5 = zext i16 %conv4 to i32
  %7 = load i16, ptr %s2, align 2
  %conv6 = zext i16 %7 to i32
  %mul = mul i32 %conv5, %conv6
  %8 = load i16, ptr %d, align 2
  %conv7 = zext i16 %8 to i32
  %add = add i32 %mul, %conv7
  %conv8 = trunc i32 %add to i16
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext9 = sext i32 %10 to i64
  %add.ptr10 = getelementptr i16, ptr %9, i64 %idx.ext9
  store i16 %conv8, ptr %add.ptr10, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccu_vx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv3 = trunc i64 %6 to i16
  %conv4 = zext i16 %conv3 to i32
  %7 = load i32, ptr %s2, align 4
  %mul = mul i32 %conv4, %7
  %8 = load i32, ptr %d, align 4
  %add = add i32 %mul, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %10 to i64
  %add.ptr6 = getelementptr i32, ptr %9, i64 %idx.ext5
  store i32 %add, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccu_vx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %conv3 = trunc i64 %6 to i32
  %conv4 = zext i32 %conv3 to i64
  %7 = load i64, ptr %s2, align 8
  %mul = mul i64 %conv4, %7
  %8 = load i64, ptr %d, align 8
  %add = add i64 %mul, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %10 to i64
  %add.ptr6 = getelementptr i64, ptr %9, i64 %idx.ext5
  store i64 %add, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmacc_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmacc_vx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmacc_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv3 = trunc i64 %6 to i8
  %conv4 = sext i8 %conv3 to i16
  %conv5 = sext i16 %conv4 to i32
  %7 = load i16, ptr %s2, align 2
  %conv6 = sext i16 %7 to i32
  %mul = mul i32 %conv5, %conv6
  %8 = load i16, ptr %d, align 2
  %conv7 = sext i16 %8 to i32
  %add = add i32 %mul, %conv7
  %conv8 = trunc i32 %add to i16
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext9 = sext i32 %10 to i64
  %add.ptr10 = getelementptr i16, ptr %9, i64 %idx.ext9
  store i16 %conv8, ptr %add.ptr10, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmacc_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmacc_vx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmacc_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv3 = trunc i64 %6 to i16
  %conv4 = sext i16 %conv3 to i32
  %7 = load i32, ptr %s2, align 4
  %mul = mul i32 %conv4, %7
  %8 = load i32, ptr %d, align 4
  %add = add i32 %mul, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %10 to i64
  %add.ptr6 = getelementptr i32, ptr %9, i64 %idx.ext5
  store i32 %add, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmacc_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmacc_vx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmacc_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %conv3 = trunc i64 %6 to i32
  %conv4 = sext i32 %conv3 to i64
  %7 = load i64, ptr %s2, align 8
  %mul = mul i64 %conv4, %7
  %8 = load i64, ptr %d, align 8
  %add = add i64 %mul, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %10 to i64
  %add.ptr6 = getelementptr i64, ptr %9, i64 %idx.ext5
  store i64 %add, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccsu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccsu_vx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccsu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv3 = trunc i64 %6 to i8
  %conv4 = sext i8 %conv3 to i16
  %conv5 = sext i16 %conv4 to i32
  %7 = load i16, ptr %s2, align 2
  %conv6 = zext i16 %7 to i32
  %mul = mul i32 %conv5, %conv6
  %8 = load i16, ptr %d, align 2
  %conv7 = sext i16 %8 to i32
  %add = add i32 %mul, %conv7
  %conv8 = trunc i32 %add to i16
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext9 = sext i32 %10 to i64
  %add.ptr10 = getelementptr i16, ptr %9, i64 %idx.ext9
  store i16 %conv8, ptr %add.ptr10, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccsu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccsu_vx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccsu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv3 = trunc i64 %6 to i16
  %conv4 = sext i16 %conv3 to i32
  %7 = load i32, ptr %s2, align 4
  %mul = mul i32 %conv4, %7
  %8 = load i32, ptr %d, align 4
  %add = add i32 %mul, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %10 to i64
  %add.ptr6 = getelementptr i32, ptr %9, i64 %idx.ext5
  store i32 %add, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccsu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccsu_vx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccsu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %conv3 = trunc i64 %6 to i32
  %conv4 = sext i32 %conv3 to i64
  %7 = load i64, ptr %s2, align 8
  %mul = mul i64 %conv4, %7
  %8 = load i64, ptr %d, align 8
  %add = add i64 %mul, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %10 to i64
  %add.ptr6 = getelementptr i64, ptr %9, i64 %idx.ext5
  store i64 %add, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccus_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccus_vx_b, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccus_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  %conv = sext i8 %2 to i16
  store i16 %conv, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv3 = trunc i64 %6 to i8
  %conv4 = zext i8 %conv3 to i16
  %conv5 = zext i16 %conv4 to i32
  %7 = load i16, ptr %s2, align 2
  %conv6 = sext i16 %7 to i32
  %mul = mul i32 %conv5, %conv6
  %8 = load i16, ptr %d, align 2
  %conv7 = sext i16 %8 to i32
  %add = add i32 %mul, %conv7
  %conv8 = trunc i32 %add to i16
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext9 = sext i32 %10 to i64
  %add.ptr10 = getelementptr i16, ptr %9, i64 %idx.ext9
  store i16 %conv8, ptr %add.ptr10, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccus_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccus_vx_h, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccus_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = sext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv3 = trunc i64 %6 to i16
  %conv4 = zext i16 %conv3 to i32
  %7 = load i32, ptr %s2, align 4
  %mul = mul i32 %conv4, %7
  %8 = load i32, ptr %d, align 4
  %add = add i32 %mul, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %10 to i64
  %add.ptr6 = getelementptr i32, ptr %9, i64 %idx.ext5
  store i32 %add, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwmaccus_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @do_vext_vx(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vwmaccus_vx_w, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vwmaccus_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %conv3 = trunc i64 %6 to i32
  %conv4 = zext i32 %conv3 to i64
  %7 = load i64, ptr %s2, align 8
  %mul = mul i64 %conv4, %7
  %8 = load i64, ptr %d, align 8
  %add = add i64 %mul, %8
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %10 to i64
  %add.ptr6 = getelementptr i64, ptr %9, i64 %idx.ext5
  store i64 %add, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmv_v_v_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i8, ptr %10, i64 %idx.ext
  %12 = load i8, ptr %add.ptr, align 1
  store i8 %12, ptr %s1, align 1
  %13 = load i8, ptr %s1, align 1
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext5 = zext i32 %15 to i64
  %add.ptr6 = getelementptr i8, ptr %14, i64 %idx.ext5
  store i8 %13, ptr %add.ptr6, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, ptr %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !219

for.end:                                          ; preds = %for.cond
  %17 = load ptr, ptr %env.addr, align 8
  %vstart7 = getelementptr inbounds %struct.CPUArchState, ptr %17, i32 0, i32 6
  store i64 0, ptr %vstart7, align 8
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %vta, align 4
  %20 = load i32, ptr %vl, align 4
  %21 = load i32, ptr %esz, align 4
  %mul = mul i32 %20, %21
  %22 = load i32, ptr %total_elems, align 4
  %23 = load i32, ptr %esz, align 4
  %mul8 = mul i32 %22, %23
  call void @vext_set_elems_1s(ptr noundef %18, i32 noundef %19, i32 noundef %mul, i32 noundef %mul8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmv_v_v_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i16, ptr %10, i64 %idx.ext
  %12 = load i16, ptr %add.ptr, align 2
  store i16 %12, ptr %s1, align 2
  %13 = load i16, ptr %s1, align 2
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext5 = zext i32 %15 to i64
  %add.ptr6 = getelementptr i16, ptr %14, i64 %idx.ext5
  store i16 %13, ptr %add.ptr6, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, ptr %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !220

for.end:                                          ; preds = %for.cond
  %17 = load ptr, ptr %env.addr, align 8
  %vstart7 = getelementptr inbounds %struct.CPUArchState, ptr %17, i32 0, i32 6
  store i64 0, ptr %vstart7, align 8
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %vta, align 4
  %20 = load i32, ptr %vl, align 4
  %21 = load i32, ptr %esz, align 4
  %mul = mul i32 %20, %21
  %22 = load i32, ptr %total_elems, align 4
  %23 = load i32, ptr %esz, align 4
  %mul8 = mul i32 %22, %23
  call void @vext_set_elems_1s(ptr noundef %18, i32 noundef %19, i32 noundef %mul, i32 noundef %mul8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmv_v_v_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i32, ptr %10, i64 %idx.ext
  %12 = load i32, ptr %add.ptr, align 4
  store i32 %12, ptr %s1, align 4
  %13 = load i32, ptr %s1, align 4
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext5 = zext i32 %15 to i64
  %add.ptr6 = getelementptr i32, ptr %14, i64 %idx.ext5
  store i32 %13, ptr %add.ptr6, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, ptr %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !221

for.end:                                          ; preds = %for.cond
  %17 = load ptr, ptr %env.addr, align 8
  %vstart7 = getelementptr inbounds %struct.CPUArchState, ptr %17, i32 0, i32 6
  store i64 0, ptr %vstart7, align 8
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %vta, align 4
  %20 = load i32, ptr %vl, align 4
  %21 = load i32, ptr %esz, align 4
  %mul = mul i32 %20, %21
  %22 = load i32, ptr %total_elems, align 4
  %23 = load i32, ptr %esz, align 4
  %mul8 = mul i32 %22, %23
  call void @vext_set_elems_1s(ptr noundef %18, i32 noundef %19, i32 noundef %mul, i32 noundef %mul8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmv_v_v_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i64, ptr %10, i64 %idx.ext
  %12 = load i64, ptr %add.ptr, align 8
  store i64 %12, ptr %s1, align 8
  %13 = load i64, ptr %s1, align 8
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext5 = zext i32 %15 to i64
  %add.ptr6 = getelementptr i64, ptr %14, i64 %idx.ext5
  store i64 %13, ptr %add.ptr6, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, ptr %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !222

for.end:                                          ; preds = %for.cond
  %17 = load ptr, ptr %env.addr, align 8
  %vstart7 = getelementptr inbounds %struct.CPUArchState, ptr %17, i32 0, i32 6
  store i64 0, ptr %vstart7, align 8
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %vta, align 4
  %20 = load i32, ptr %vl, align 4
  %21 = load i32, ptr %esz, align 4
  %mul = mul i32 %20, %21
  %22 = load i32, ptr %total_elems, align 4
  %23 = load i32, ptr %esz, align 4
  %mul8 = mul i32 %22, %23
  call void @vext_set_elems_1s(ptr noundef %18, i32 noundef %19, i32 noundef %mul, i32 noundef %mul8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmv_v_x_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i64, ptr %s1.addr, align 8
  %conv5 = trunc i64 %10 to i8
  %11 = load ptr, ptr %vd.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i8, ptr %11, i64 %idx.ext
  store i8 %conv5, ptr %add.ptr, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32, ptr %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !223

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %env.addr, align 8
  %vstart6 = getelementptr inbounds %struct.CPUArchState, ptr %14, i32 0, i32 6
  store i64 0, ptr %vstart6, align 8
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vta, align 4
  %17 = load i32, ptr %vl, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %total_elems, align 4
  %20 = load i32, ptr %esz, align 4
  %mul7 = mul i32 %19, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmv_v_x_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i64, ptr %s1.addr, align 8
  %conv5 = trunc i64 %10 to i16
  %11 = load ptr, ptr %vd.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  store i16 %conv5, ptr %add.ptr, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32, ptr %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !224

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %env.addr, align 8
  %vstart6 = getelementptr inbounds %struct.CPUArchState, ptr %14, i32 0, i32 6
  store i64 0, ptr %vstart6, align 8
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vta, align 4
  %17 = load i32, ptr %vl, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %total_elems, align 4
  %20 = load i32, ptr %esz, align 4
  %mul7 = mul i32 %19, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmv_v_x_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i64, ptr %s1.addr, align 8
  %conv5 = trunc i64 %10 to i32
  %11 = load ptr, ptr %vd.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  store i32 %conv5, ptr %add.ptr, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32, ptr %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !225

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %env.addr, align 8
  %vstart6 = getelementptr inbounds %struct.CPUArchState, ptr %14, i32 0, i32 6
  store i64 0, ptr %vstart6, align 8
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vta, align 4
  %17 = load i32, ptr %vl, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %total_elems, align 4
  %20 = load i32, ptr %esz, align 4
  %mul7 = mul i32 %19, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmv_v_x_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i64, ptr %s1.addr, align 8
  %11 = load ptr, ptr %vd.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  store i64 %10, ptr %add.ptr, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32, ptr %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !226

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %env.addr, align 8
  %vstart5 = getelementptr inbounds %struct.CPUArchState, ptr %14, i32 0, i32 6
  store i64 0, ptr %vstart5, align 8
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vta, align 4
  %17 = load i32, ptr %vl, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %total_elems, align 4
  %20 = load i32, ptr %esz, align 4
  %mul6 = mul i32 %19, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul6)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmerge_vvm_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %vt = alloca ptr, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %v0.addr, align 8
  %11 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %10, i32 noundef %11)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %for.body
  %12 = load ptr, ptr %vs2.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %13 = load ptr, ptr %vs1.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %12, %cond.true ], [ %13, %cond.false ]
  store ptr %cond, ptr %vt, align 8
  %14 = load ptr, ptr %vt, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %15 to i64
  %add.ptr = getelementptr i8, ptr %14, i64 %idx.ext
  %16 = load i8, ptr %add.ptr, align 1
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %i, align 4
  %idx.ext6 = zext i32 %18 to i64
  %add.ptr7 = getelementptr i8, ptr %17, i64 %idx.ext6
  store i8 %16, ptr %add.ptr7, align 1
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !227

for.end:                                          ; preds = %for.cond
  %20 = load ptr, ptr %env.addr, align 8
  %vstart8 = getelementptr inbounds %struct.CPUArchState, ptr %20, i32 0, i32 6
  store i64 0, ptr %vstart8, align 8
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %vta, align 4
  %23 = load i32, ptr %vl, align 4
  %24 = load i32, ptr %esz, align 4
  %mul = mul i32 %23, %24
  %25 = load i32, ptr %total_elems, align 4
  %26 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %25, %26
  call void @vext_set_elems_1s(ptr noundef %21, i32 noundef %22, i32 noundef %mul, i32 noundef %mul9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmerge_vvm_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %vt = alloca ptr, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %v0.addr, align 8
  %11 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %10, i32 noundef %11)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %for.body
  %12 = load ptr, ptr %vs2.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %13 = load ptr, ptr %vs1.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %12, %cond.true ], [ %13, %cond.false ]
  store ptr %cond, ptr %vt, align 8
  %14 = load ptr, ptr %vt, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %15 to i64
  %add.ptr = getelementptr i16, ptr %14, i64 %idx.ext
  %16 = load i16, ptr %add.ptr, align 2
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %i, align 4
  %idx.ext6 = zext i32 %18 to i64
  %add.ptr7 = getelementptr i16, ptr %17, i64 %idx.ext6
  store i16 %16, ptr %add.ptr7, align 2
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !228

for.end:                                          ; preds = %for.cond
  %20 = load ptr, ptr %env.addr, align 8
  %vstart8 = getelementptr inbounds %struct.CPUArchState, ptr %20, i32 0, i32 6
  store i64 0, ptr %vstart8, align 8
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %vta, align 4
  %23 = load i32, ptr %vl, align 4
  %24 = load i32, ptr %esz, align 4
  %mul = mul i32 %23, %24
  %25 = load i32, ptr %total_elems, align 4
  %26 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %25, %26
  call void @vext_set_elems_1s(ptr noundef %21, i32 noundef %22, i32 noundef %mul, i32 noundef %mul9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmerge_vvm_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %vt = alloca ptr, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %v0.addr, align 8
  %11 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %10, i32 noundef %11)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %for.body
  %12 = load ptr, ptr %vs2.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %13 = load ptr, ptr %vs1.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %12, %cond.true ], [ %13, %cond.false ]
  store ptr %cond, ptr %vt, align 8
  %14 = load ptr, ptr %vt, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %15 to i64
  %add.ptr = getelementptr i32, ptr %14, i64 %idx.ext
  %16 = load i32, ptr %add.ptr, align 4
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %i, align 4
  %idx.ext6 = zext i32 %18 to i64
  %add.ptr7 = getelementptr i32, ptr %17, i64 %idx.ext6
  store i32 %16, ptr %add.ptr7, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !229

for.end:                                          ; preds = %for.cond
  %20 = load ptr, ptr %env.addr, align 8
  %vstart8 = getelementptr inbounds %struct.CPUArchState, ptr %20, i32 0, i32 6
  store i64 0, ptr %vstart8, align 8
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %vta, align 4
  %23 = load i32, ptr %vl, align 4
  %24 = load i32, ptr %esz, align 4
  %mul = mul i32 %23, %24
  %25 = load i32, ptr %total_elems, align 4
  %26 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %25, %26
  call void @vext_set_elems_1s(ptr noundef %21, i32 noundef %22, i32 noundef %mul, i32 noundef %mul9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmerge_vvm_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %vt = alloca ptr, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %v0.addr, align 8
  %11 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %10, i32 noundef %11)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %for.body
  %12 = load ptr, ptr %vs2.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %13 = load ptr, ptr %vs1.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %12, %cond.true ], [ %13, %cond.false ]
  store ptr %cond, ptr %vt, align 8
  %14 = load ptr, ptr %vt, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %15 to i64
  %add.ptr = getelementptr i64, ptr %14, i64 %idx.ext
  %16 = load i64, ptr %add.ptr, align 8
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %i, align 4
  %idx.ext6 = zext i32 %18 to i64
  %add.ptr7 = getelementptr i64, ptr %17, i64 %idx.ext6
  store i64 %16, ptr %add.ptr7, align 8
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !230

for.end:                                          ; preds = %for.cond
  %20 = load ptr, ptr %env.addr, align 8
  %vstart8 = getelementptr inbounds %struct.CPUArchState, ptr %20, i32 0, i32 6
  store i64 0, ptr %vstart8, align 8
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %vta, align 4
  %23 = load i32, ptr %vl, align 4
  %24 = load i32, ptr %esz, align 4
  %mul = mul i32 %23, %24
  %25 = load i32, ptr %total_elems, align 4
  %26 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %25, %26
  call void @vext_set_elems_1s(ptr noundef %21, i32 noundef %22, i32 noundef %mul, i32 noundef %mul9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmerge_vxm_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i8, align 1
  %d = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i8, ptr %10, i64 %idx.ext
  %12 = load i8, ptr %add.ptr, align 1
  store i8 %12, ptr %s2, align 1
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %for.body
  %15 = load i8, ptr %s2, align 1
  %conv6 = sext i8 %15 to i32
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %16 = load i64, ptr %s1.addr, align 8
  %conv7 = trunc i64 %16 to i8
  %conv8 = sext i8 %conv7 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv6, %cond.true ], [ %conv8, %cond.false ]
  %conv9 = trunc i32 %cond to i8
  store i8 %conv9, ptr %d, align 1
  %17 = load i8, ptr %d, align 1
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %19 to i64
  %add.ptr11 = getelementptr i8, ptr %18, i64 %idx.ext10
  store i8 %17, ptr %add.ptr11, align 1
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !231

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %vta, align 4
  %24 = load i32, ptr %vl, align 4
  %25 = load i32, ptr %esz, align 4
  %mul = mul i32 %24, %25
  %26 = load i32, ptr %total_elems, align 4
  %27 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %26, %27
  call void @vext_set_elems_1s(ptr noundef %22, i32 noundef %23, i32 noundef %mul, i32 noundef %mul13)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmerge_vxm_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i16, ptr %10, i64 %idx.ext
  %12 = load i16, ptr %add.ptr, align 2
  store i16 %12, ptr %s2, align 2
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %for.body
  %15 = load i16, ptr %s2, align 2
  %conv6 = sext i16 %15 to i32
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %16 = load i64, ptr %s1.addr, align 8
  %conv7 = trunc i64 %16 to i16
  %conv8 = sext i16 %conv7 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv6, %cond.true ], [ %conv8, %cond.false ]
  %conv9 = trunc i32 %cond to i16
  store i16 %conv9, ptr %d, align 2
  %17 = load i16, ptr %d, align 2
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %19 to i64
  %add.ptr11 = getelementptr i16, ptr %18, i64 %idx.ext10
  store i16 %17, ptr %add.ptr11, align 2
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !232

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %vta, align 4
  %24 = load i32, ptr %vl, align 4
  %25 = load i32, ptr %esz, align 4
  %mul = mul i32 %24, %25
  %26 = load i32, ptr %total_elems, align 4
  %27 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %26, %27
  call void @vext_set_elems_1s(ptr noundef %22, i32 noundef %23, i32 noundef %mul, i32 noundef %mul13)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmerge_vxm_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i32, ptr %10, i64 %idx.ext
  %12 = load i32, ptr %add.ptr, align 4
  store i32 %12, ptr %s2, align 4
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %for.body
  %15 = load i32, ptr %s2, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %16 = load i64, ptr %s1.addr, align 8
  %conv6 = trunc i64 %16 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %15, %cond.true ], [ %conv6, %cond.false ]
  store i32 %cond, ptr %d, align 4
  %17 = load i32, ptr %d, align 4
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idx.ext7 = zext i32 %19 to i64
  %add.ptr8 = getelementptr i32, ptr %18, i64 %idx.ext7
  store i32 %17, ptr %add.ptr8, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !233

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %vta, align 4
  %24 = load i32, ptr %vl, align 4
  %25 = load i32, ptr %esz, align 4
  %mul = mul i32 %24, %25
  %26 = load i32, ptr %total_elems, align 4
  %27 = load i32, ptr %esz, align 4
  %mul10 = mul i32 %26, %27
  call void @vext_set_elems_1s(ptr noundef %22, i32 noundef %23, i32 noundef %mul, i32 noundef %mul10)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmerge_vxm_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr i64, ptr %10, i64 %idx.ext
  %12 = load i64, ptr %add.ptr, align 8
  store i64 %12, ptr %s2, align 8
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %for.body
  %15 = load i64, ptr %s2, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %16 = load i64, ptr %s1.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %15, %cond.true ], [ %16, %cond.false ]
  store i64 %cond, ptr %d, align 8
  %17 = load i64, ptr %d, align 8
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idx.ext6 = zext i32 %19 to i64
  %add.ptr7 = getelementptr i64, ptr %18, i64 %idx.ext6
  store i64 %17, ptr %add.ptr7, align 8
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !234

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart8 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart8, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %vta, align 4
  %24 = load i32, ptr %vl, align 4
  %25 = load i32, ptr %esz, align 4
  %mul = mul i32 %24, %25
  %26 = load i32, ptr %total_elems, align 4
  %27 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %26, %27
  call void @vext_set_elems_1s(ptr noundef %22, i32 noundef %23, i32 noundef %mul, i32 noundef %mul9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsaddu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsaddu_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vext_vv_rm_2(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc, ptr noundef %fn, i32 noundef %esz) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %fn.addr = alloca ptr, align 8
  %esz.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  store ptr %fn, ptr %fn.addr, align 8
  store i32 %esz, ptr %esz.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vxrm = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 3
  %9 = load i64, ptr %vxrm, align 16
  switch i64 %9, label %sw.default [
    i64 0, label %sw.bb
    i64 1, label %sw.bb5
    i64 2, label %sw.bb6
  ]

sw.bb:                                            ; preds = %entry
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load ptr, ptr %v0.addr, align 8
  %12 = load ptr, ptr %vs1.addr, align 8
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load ptr, ptr %env.addr, align 8
  %15 = load i32, ptr %vl, align 4
  %16 = load i32, ptr %vm, align 4
  %17 = load ptr, ptr %fn.addr, align 8
  %18 = load i32, ptr %vma, align 4
  %19 = load i32, ptr %esz.addr, align 4
  call void @vext_vv_rm_1(ptr noundef %10, ptr noundef %11, ptr noundef %12, ptr noundef %13, ptr noundef %14, i32 noundef %15, i32 noundef %16, i32 noundef 0, ptr noundef %17, i32 noundef %18, i32 noundef %19)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load ptr, ptr %v0.addr, align 8
  %22 = load ptr, ptr %vs1.addr, align 8
  %23 = load ptr, ptr %vs2.addr, align 8
  %24 = load ptr, ptr %env.addr, align 8
  %25 = load i32, ptr %vl, align 4
  %26 = load i32, ptr %vm, align 4
  %27 = load ptr, ptr %fn.addr, align 8
  %28 = load i32, ptr %vma, align 4
  %29 = load i32, ptr %esz.addr, align 4
  call void @vext_vv_rm_1(ptr noundef %20, ptr noundef %21, ptr noundef %22, ptr noundef %23, ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef 1, ptr noundef %27, i32 noundef %28, i32 noundef %29)
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load ptr, ptr %v0.addr, align 8
  %32 = load ptr, ptr %vs1.addr, align 8
  %33 = load ptr, ptr %vs2.addr, align 8
  %34 = load ptr, ptr %env.addr, align 8
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %vm, align 4
  %37 = load ptr, ptr %fn.addr, align 8
  %38 = load i32, ptr %vma, align 4
  %39 = load i32, ptr %esz.addr, align 4
  call void @vext_vv_rm_1(ptr noundef %30, ptr noundef %31, ptr noundef %32, ptr noundef %33, ptr noundef %34, i32 noundef %35, i32 noundef %36, i32 noundef 2, ptr noundef %37, i32 noundef %38, i32 noundef %39)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %40 = load ptr, ptr %vd.addr, align 8
  %41 = load ptr, ptr %v0.addr, align 8
  %42 = load ptr, ptr %vs1.addr, align 8
  %43 = load ptr, ptr %vs2.addr, align 8
  %44 = load ptr, ptr %env.addr, align 8
  %45 = load i32, ptr %vl, align 4
  %46 = load i32, ptr %vm, align 4
  %47 = load ptr, ptr %fn.addr, align 8
  %48 = load i32, ptr %vma, align 4
  %49 = load i32, ptr %esz.addr, align 4
  call void @vext_vv_rm_1(ptr noundef %40, ptr noundef %41, ptr noundef %42, ptr noundef %43, ptr noundef %44, i32 noundef %45, i32 noundef %46, i32 noundef 3, ptr noundef %47, i32 noundef %48, i32 noundef %49)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb6, %sw.bb5, %sw.bb
  %50 = load ptr, ptr %vd.addr, align 8
  %51 = load i32, ptr %vta, align 4
  %52 = load i32, ptr %vl, align 4
  %53 = load i32, ptr %esz.addr, align 4
  %mul = mul i32 %52, %53
  %54 = load i32, ptr %total_elems, align 4
  %55 = load i32, ptr %esz.addr, align 4
  %mul7 = mul i32 %54, %55
  call void @vext_set_elems_1s(ptr noundef %50, i32 noundef %51, i32 noundef %mul, i32 noundef %mul7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsaddu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i8, ptr %s2, align 1
  %9 = load i8, ptr %s1, align 1
  %call = call zeroext i8 @saddu8(ptr noundef %6, i32 noundef %7, i8 noundef zeroext %8, i8 noundef zeroext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i8, ptr %10, i64 %idx.ext3
  store i8 %call, ptr %add.ptr4, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsaddu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsaddu_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsaddu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %9 = load i16, ptr %s1, align 2
  %call = call zeroext i16 @saddu16(ptr noundef %6, i32 noundef %7, i16 noundef zeroext %8, i16 noundef zeroext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsaddu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsaddu_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsaddu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @saddu32(ptr noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsaddu_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsaddu_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsaddu_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s1, align 8
  %call = call i64 @saddu64(ptr noundef %6, i32 noundef %7, i64 noundef %8, i64 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsaddu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsaddu_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vext_vx_rm_2(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc, ptr noundef %fn, i32 noundef %esz) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %fn.addr = alloca ptr, align 8
  %esz.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  store ptr %fn, ptr %fn.addr, align 8
  store i32 %esz, ptr %esz.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vxrm = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 3
  %9 = load i64, ptr %vxrm, align 16
  switch i64 %9, label %sw.default [
    i64 0, label %sw.bb
    i64 1, label %sw.bb5
    i64 2, label %sw.bb6
  ]

sw.bb:                                            ; preds = %entry
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load ptr, ptr %v0.addr, align 8
  %12 = load i64, ptr %s1.addr, align 8
  %13 = load ptr, ptr %vs2.addr, align 8
  %14 = load ptr, ptr %env.addr, align 8
  %15 = load i32, ptr %vl, align 4
  %16 = load i32, ptr %vm, align 4
  %17 = load ptr, ptr %fn.addr, align 8
  %18 = load i32, ptr %vma, align 4
  %19 = load i32, ptr %esz.addr, align 4
  call void @vext_vx_rm_1(ptr noundef %10, ptr noundef %11, i64 noundef %12, ptr noundef %13, ptr noundef %14, i32 noundef %15, i32 noundef %16, i32 noundef 0, ptr noundef %17, i32 noundef %18, i32 noundef %19)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load ptr, ptr %v0.addr, align 8
  %22 = load i64, ptr %s1.addr, align 8
  %23 = load ptr, ptr %vs2.addr, align 8
  %24 = load ptr, ptr %env.addr, align 8
  %25 = load i32, ptr %vl, align 4
  %26 = load i32, ptr %vm, align 4
  %27 = load ptr, ptr %fn.addr, align 8
  %28 = load i32, ptr %vma, align 4
  %29 = load i32, ptr %esz.addr, align 4
  call void @vext_vx_rm_1(ptr noundef %20, ptr noundef %21, i64 noundef %22, ptr noundef %23, ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef 1, ptr noundef %27, i32 noundef %28, i32 noundef %29)
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load ptr, ptr %v0.addr, align 8
  %32 = load i64, ptr %s1.addr, align 8
  %33 = load ptr, ptr %vs2.addr, align 8
  %34 = load ptr, ptr %env.addr, align 8
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %vm, align 4
  %37 = load ptr, ptr %fn.addr, align 8
  %38 = load i32, ptr %vma, align 4
  %39 = load i32, ptr %esz.addr, align 4
  call void @vext_vx_rm_1(ptr noundef %30, ptr noundef %31, i64 noundef %32, ptr noundef %33, ptr noundef %34, i32 noundef %35, i32 noundef %36, i32 noundef 2, ptr noundef %37, i32 noundef %38, i32 noundef %39)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %40 = load ptr, ptr %vd.addr, align 8
  %41 = load ptr, ptr %v0.addr, align 8
  %42 = load i64, ptr %s1.addr, align 8
  %43 = load ptr, ptr %vs2.addr, align 8
  %44 = load ptr, ptr %env.addr, align 8
  %45 = load i32, ptr %vl, align 4
  %46 = load i32, ptr %vm, align 4
  %47 = load ptr, ptr %fn.addr, align 8
  %48 = load i32, ptr %vma, align 4
  %49 = load i32, ptr %esz.addr, align 4
  call void @vext_vx_rm_1(ptr noundef %40, ptr noundef %41, i64 noundef %42, ptr noundef %43, ptr noundef %44, i32 noundef %45, i32 noundef %46, i32 noundef 3, ptr noundef %47, i32 noundef %48, i32 noundef %49)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb6, %sw.bb5, %sw.bb
  %50 = load ptr, ptr %vd.addr, align 8
  %51 = load i32, ptr %vta, align 4
  %52 = load i32, ptr %vl, align 4
  %53 = load i32, ptr %esz.addr, align 4
  %mul = mul i32 %52, %53
  %54 = load i32, ptr %total_elems, align 4
  %55 = load i32, ptr %esz.addr, align 4
  %mul7 = mul i32 %54, %55
  call void @vext_set_elems_1s(ptr noundef %50, i32 noundef %51, i32 noundef %mul, i32 noundef %mul7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsaddu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i8, ptr %s2, align 1
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %call = call zeroext i8 @saddu8(ptr noundef %3, i32 noundef %4, i8 noundef zeroext %5, i8 noundef zeroext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i8, ptr %7, i64 %idx.ext1
  store i8 %call, ptr %add.ptr2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsaddu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsaddu_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsaddu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %call = call zeroext i16 @saddu16(ptr noundef %3, i32 noundef %4, i16 noundef zeroext %5, i16 noundef zeroext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i16, ptr %7, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsaddu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsaddu_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsaddu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @saddu32(ptr noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsaddu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsaddu_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsaddu_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %call = call i64 @saddu64(ptr noundef %3, i32 noundef %4, i64 noundef %5, i64 noundef %6)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsadd_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsadd_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsadd_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i8, ptr %s2, align 1
  %9 = load i8, ptr %s1, align 1
  %call = call signext i8 @sadd8(ptr noundef %6, i32 noundef %7, i8 noundef signext %8, i8 noundef signext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i8, ptr %10, i64 %idx.ext3
  store i8 %call, ptr %add.ptr4, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsadd_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsadd_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsadd_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %9 = load i16, ptr %s1, align 2
  %call = call signext i16 @sadd16(ptr noundef %6, i32 noundef %7, i16 noundef signext %8, i16 noundef signext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsadd_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsadd_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsadd_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @sadd32(ptr noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsadd_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsadd_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsadd_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s1, align 8
  %call = call i64 @sadd64(ptr noundef %6, i32 noundef %7, i64 noundef %8, i64 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsadd_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsadd_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsadd_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i8, ptr %s2, align 1
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %call = call signext i8 @sadd8(ptr noundef %3, i32 noundef %4, i8 noundef signext %5, i8 noundef signext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i8, ptr %7, i64 %idx.ext1
  store i8 %call, ptr %add.ptr2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsadd_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsadd_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsadd_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %call = call signext i16 @sadd16(ptr noundef %3, i32 noundef %4, i16 noundef signext %5, i16 noundef signext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i16, ptr %7, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsadd_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsadd_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsadd_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @sadd32(ptr noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsadd_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsadd_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsadd_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %call = call i64 @sadd64(ptr noundef %3, i32 noundef %4, i64 noundef %5, i64 noundef %6)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssubu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssubu_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssubu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i8, ptr %s2, align 1
  %9 = load i8, ptr %s1, align 1
  %call = call zeroext i8 @ssubu8(ptr noundef %6, i32 noundef %7, i8 noundef zeroext %8, i8 noundef zeroext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i8, ptr %10, i64 %idx.ext3
  store i8 %call, ptr %add.ptr4, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssubu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssubu_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssubu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %9 = load i16, ptr %s1, align 2
  %call = call zeroext i16 @ssubu16(ptr noundef %6, i32 noundef %7, i16 noundef zeroext %8, i16 noundef zeroext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssubu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssubu_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssubu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @ssubu32(ptr noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssubu_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssubu_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssubu_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s1, align 8
  %call = call i64 @ssubu64(ptr noundef %6, i32 noundef %7, i64 noundef %8, i64 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssubu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssubu_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssubu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i8, ptr %s2, align 1
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %call = call zeroext i8 @ssubu8(ptr noundef %3, i32 noundef %4, i8 noundef zeroext %5, i8 noundef zeroext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i8, ptr %7, i64 %idx.ext1
  store i8 %call, ptr %add.ptr2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssubu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssubu_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssubu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %call = call zeroext i16 @ssubu16(ptr noundef %3, i32 noundef %4, i16 noundef zeroext %5, i16 noundef zeroext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i16, ptr %7, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssubu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssubu_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssubu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @ssubu32(ptr noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssubu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssubu_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssubu_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %call = call i64 @ssubu64(ptr noundef %3, i32 noundef %4, i64 noundef %5, i64 noundef %6)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssub_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssub_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssub_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i8, ptr %s2, align 1
  %9 = load i8, ptr %s1, align 1
  %call = call signext i8 @ssub8(ptr noundef %6, i32 noundef %7, i8 noundef signext %8, i8 noundef signext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i8, ptr %10, i64 %idx.ext3
  store i8 %call, ptr %add.ptr4, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssub_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssub_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssub_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %9 = load i16, ptr %s1, align 2
  %call = call signext i16 @ssub16(ptr noundef %6, i32 noundef %7, i16 noundef signext %8, i16 noundef signext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssub_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssub_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssub_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @ssub32(ptr noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssub_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssub_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssub_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s1, align 8
  %call = call i64 @ssub64(ptr noundef %6, i32 noundef %7, i64 noundef %8, i64 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssub_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssub_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssub_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i8, ptr %s2, align 1
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %call = call signext i8 @ssub8(ptr noundef %3, i32 noundef %4, i8 noundef signext %5, i8 noundef signext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i8, ptr %7, i64 %idx.ext1
  store i8 %call, ptr %add.ptr2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssub_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssub_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssub_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %call = call signext i16 @ssub16(ptr noundef %3, i32 noundef %4, i16 noundef signext %5, i16 noundef signext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i16, ptr %7, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssub_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssub_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssub_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @ssub32(ptr noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssub_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssub_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssub_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %call = call i64 @ssub64(ptr noundef %3, i32 noundef %4, i64 noundef %5, i64 noundef %6)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaadd_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaadd_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaadd_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i8, ptr %s2, align 1
  %conv = sext i8 %8 to i32
  %9 = load i8, ptr %s1, align 1
  %conv3 = sext i8 %9 to i32
  %call = call i32 @aadd32(ptr noundef %6, i32 noundef %7, i32 noundef %conv, i32 noundef %conv3)
  %conv4 = trunc i32 %call to i8
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %11 to i64
  %add.ptr6 = getelementptr i8, ptr %10, i64 %idx.ext5
  store i8 %conv4, ptr %add.ptr6, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaadd_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaadd_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaadd_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %conv = sext i16 %8 to i32
  %9 = load i16, ptr %s1, align 2
  %conv3 = sext i16 %9 to i32
  %call = call i32 @aadd32(ptr noundef %6, i32 noundef %7, i32 noundef %conv, i32 noundef %conv3)
  %conv4 = trunc i32 %call to i16
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %11 to i64
  %add.ptr6 = getelementptr i16, ptr %10, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaadd_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaadd_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaadd_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @aadd32(ptr noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaadd_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaadd_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaadd_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s1, align 8
  %call = call i64 @aadd64(ptr noundef %6, i32 noundef %7, i64 noundef %8, i64 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaadd_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaadd_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaadd_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i8, ptr %s2, align 1
  %conv = sext i8 %5 to i32
  %6 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %6 to i8
  %conv2 = sext i8 %conv1 to i32
  %call = call i32 @aadd32(ptr noundef %3, i32 noundef %4, i32 noundef %conv, i32 noundef %conv2)
  %conv3 = trunc i32 %call to i8
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %8 to i64
  %add.ptr5 = getelementptr i8, ptr %7, i64 %idx.ext4
  store i8 %conv3, ptr %add.ptr5, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaadd_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaadd_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaadd_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %conv = sext i16 %5 to i32
  %6 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %6 to i16
  %conv2 = sext i16 %conv1 to i32
  %call = call i32 @aadd32(ptr noundef %3, i32 noundef %4, i32 noundef %conv, i32 noundef %conv2)
  %conv3 = trunc i32 %call to i16
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %8 to i64
  %add.ptr5 = getelementptr i16, ptr %7, i64 %idx.ext4
  store i16 %conv3, ptr %add.ptr5, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaadd_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaadd_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaadd_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @aadd32(ptr noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaadd_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaadd_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaadd_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %call = call i64 @aadd64(ptr noundef %3, i32 noundef %4, i64 noundef %5, i64 noundef %6)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaaddu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaaddu_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaaddu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i8, ptr %s2, align 1
  %conv = zext i8 %8 to i32
  %9 = load i8, ptr %s1, align 1
  %conv3 = zext i8 %9 to i32
  %call = call i32 @aaddu32(ptr noundef %6, i32 noundef %7, i32 noundef %conv, i32 noundef %conv3)
  %conv4 = trunc i32 %call to i8
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %11 to i64
  %add.ptr6 = getelementptr i8, ptr %10, i64 %idx.ext5
  store i8 %conv4, ptr %add.ptr6, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaaddu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaaddu_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaaddu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %conv = zext i16 %8 to i32
  %9 = load i16, ptr %s1, align 2
  %conv3 = zext i16 %9 to i32
  %call = call i32 @aaddu32(ptr noundef %6, i32 noundef %7, i32 noundef %conv, i32 noundef %conv3)
  %conv4 = trunc i32 %call to i16
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %11 to i64
  %add.ptr6 = getelementptr i16, ptr %10, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaaddu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaaddu_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaaddu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @aaddu32(ptr noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaaddu_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaaddu_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaaddu_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s1, align 8
  %call = call i64 @aaddu64(ptr noundef %6, i32 noundef %7, i64 noundef %8, i64 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaaddu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaaddu_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaaddu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i8, ptr %s2, align 1
  %conv = zext i8 %5 to i32
  %6 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %6 to i8
  %conv2 = zext i8 %conv1 to i32
  %call = call i32 @aaddu32(ptr noundef %3, i32 noundef %4, i32 noundef %conv, i32 noundef %conv2)
  %conv3 = trunc i32 %call to i8
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %8 to i64
  %add.ptr5 = getelementptr i8, ptr %7, i64 %idx.ext4
  store i8 %conv3, ptr %add.ptr5, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaaddu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaaddu_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaaddu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %conv = zext i16 %5 to i32
  %6 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %6 to i16
  %conv2 = zext i16 %conv1 to i32
  %call = call i32 @aaddu32(ptr noundef %3, i32 noundef %4, i32 noundef %conv, i32 noundef %conv2)
  %conv3 = trunc i32 %call to i16
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %8 to i64
  %add.ptr5 = getelementptr i16, ptr %7, i64 %idx.ext4
  store i16 %conv3, ptr %add.ptr5, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaaddu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaaddu_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaaddu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @aaddu32(ptr noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vaaddu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vaaddu_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vaaddu_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %call = call i64 @aaddu64(ptr noundef %3, i32 noundef %4, i64 noundef %5, i64 noundef %6)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasub_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasub_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasub_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i8, ptr %s2, align 1
  %conv = sext i8 %8 to i32
  %9 = load i8, ptr %s1, align 1
  %conv3 = sext i8 %9 to i32
  %call = call i32 @asub32(ptr noundef %6, i32 noundef %7, i32 noundef %conv, i32 noundef %conv3)
  %conv4 = trunc i32 %call to i8
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %11 to i64
  %add.ptr6 = getelementptr i8, ptr %10, i64 %idx.ext5
  store i8 %conv4, ptr %add.ptr6, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasub_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasub_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasub_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %conv = sext i16 %8 to i32
  %9 = load i16, ptr %s1, align 2
  %conv3 = sext i16 %9 to i32
  %call = call i32 @asub32(ptr noundef %6, i32 noundef %7, i32 noundef %conv, i32 noundef %conv3)
  %conv4 = trunc i32 %call to i16
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %11 to i64
  %add.ptr6 = getelementptr i16, ptr %10, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasub_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasub_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasub_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @asub32(ptr noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasub_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasub_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasub_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s1, align 8
  %call = call i64 @asub64(ptr noundef %6, i32 noundef %7, i64 noundef %8, i64 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasub_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasub_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasub_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i8, ptr %s2, align 1
  %conv = sext i8 %5 to i32
  %6 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %6 to i8
  %conv2 = sext i8 %conv1 to i32
  %call = call i32 @asub32(ptr noundef %3, i32 noundef %4, i32 noundef %conv, i32 noundef %conv2)
  %conv3 = trunc i32 %call to i8
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %8 to i64
  %add.ptr5 = getelementptr i8, ptr %7, i64 %idx.ext4
  store i8 %conv3, ptr %add.ptr5, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasub_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasub_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasub_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %conv = sext i16 %5 to i32
  %6 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %6 to i16
  %conv2 = sext i16 %conv1 to i32
  %call = call i32 @asub32(ptr noundef %3, i32 noundef %4, i32 noundef %conv, i32 noundef %conv2)
  %conv3 = trunc i32 %call to i16
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %8 to i64
  %add.ptr5 = getelementptr i16, ptr %7, i64 %idx.ext4
  store i16 %conv3, ptr %add.ptr5, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasub_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasub_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasub_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @asub32(ptr noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasub_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasub_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasub_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %call = call i64 @asub64(ptr noundef %3, i32 noundef %4, i64 noundef %5, i64 noundef %6)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasubu_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasubu_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasubu_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i8, ptr %s2, align 1
  %conv = zext i8 %8 to i32
  %9 = load i8, ptr %s1, align 1
  %conv3 = zext i8 %9 to i32
  %call = call i32 @asubu32(ptr noundef %6, i32 noundef %7, i32 noundef %conv, i32 noundef %conv3)
  %conv4 = trunc i32 %call to i8
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %11 to i64
  %add.ptr6 = getelementptr i8, ptr %10, i64 %idx.ext5
  store i8 %conv4, ptr %add.ptr6, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasubu_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasubu_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasubu_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %conv = zext i16 %8 to i32
  %9 = load i16, ptr %s1, align 2
  %conv3 = zext i16 %9 to i32
  %call = call i32 @asubu32(ptr noundef %6, i32 noundef %7, i32 noundef %conv, i32 noundef %conv3)
  %conv4 = trunc i32 %call to i16
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %11 to i64
  %add.ptr6 = getelementptr i16, ptr %10, i64 %idx.ext5
  store i16 %conv4, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasubu_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasubu_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasubu_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @asubu32(ptr noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasubu_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasubu_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasubu_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s1, align 8
  %call = call i64 @asubu64(ptr noundef %6, i32 noundef %7, i64 noundef %8, i64 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasubu_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasubu_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasubu_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i8, ptr %s2, align 1
  %conv = zext i8 %5 to i32
  %6 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %6 to i8
  %conv2 = zext i8 %conv1 to i32
  %call = call i32 @asubu32(ptr noundef %3, i32 noundef %4, i32 noundef %conv, i32 noundef %conv2)
  %conv3 = trunc i32 %call to i8
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %8 to i64
  %add.ptr5 = getelementptr i8, ptr %7, i64 %idx.ext4
  store i8 %conv3, ptr %add.ptr5, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasubu_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasubu_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasubu_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %conv = zext i16 %5 to i32
  %6 = load i64, ptr %s1.addr, align 8
  %conv1 = trunc i64 %6 to i16
  %conv2 = zext i16 %conv1 to i32
  %call = call i32 @asubu32(ptr noundef %3, i32 noundef %4, i32 noundef %conv, i32 noundef %conv2)
  %conv3 = trunc i32 %call to i16
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %8 to i64
  %add.ptr5 = getelementptr i16, ptr %7, i64 %idx.ext4
  store i16 %conv3, ptr %add.ptr5, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasubu_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasubu_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasubu_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @asubu32(ptr noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vasubu_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vasubu_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vasubu_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %call = call i64 @asubu64(ptr noundef %3, i32 noundef %4, i64 noundef %5, i64 noundef %6)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsmul_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsmul_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsmul_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i8, ptr %s2, align 1
  %9 = load i8, ptr %s1, align 1
  %call = call signext i8 @vsmul8(ptr noundef %6, i32 noundef %7, i8 noundef signext %8, i8 noundef signext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i8, ptr %10, i64 %idx.ext3
  store i8 %call, ptr %add.ptr4, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsmul_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsmul_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsmul_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %9 = load i16, ptr %s1, align 2
  %call = call signext i16 @vsmul16(ptr noundef %6, i32 noundef %7, i16 noundef signext %8, i16 noundef signext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsmul_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsmul_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsmul_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @vsmul32(ptr noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsmul_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsmul_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsmul_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s1, align 8
  %call = call i64 @vsmul64(ptr noundef %6, i32 noundef %7, i64 noundef %8, i64 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsmul_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsmul_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsmul_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i8, ptr %s2, align 1
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %call = call signext i8 @vsmul8(ptr noundef %3, i32 noundef %4, i8 noundef signext %5, i8 noundef signext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i8, ptr %7, i64 %idx.ext1
  store i8 %call, ptr %add.ptr2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsmul_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsmul_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsmul_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %call = call signext i16 @vsmul16(ptr noundef %3, i32 noundef %4, i16 noundef signext %5, i16 noundef signext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i16, ptr %7, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsmul_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsmul_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsmul_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @vsmul32(ptr noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsmul_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vsmul_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vsmul_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %call = call i64 @vsmul64(ptr noundef %3, i32 noundef %4, i64 noundef %5, i64 noundef %6)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssrl_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssrl_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssrl_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i8, ptr %s2, align 1
  %9 = load i8, ptr %s1, align 1
  %call = call zeroext i8 @vssrl8(ptr noundef %6, i32 noundef %7, i8 noundef zeroext %8, i8 noundef zeroext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i8, ptr %10, i64 %idx.ext3
  store i8 %call, ptr %add.ptr4, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssrl_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssrl_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssrl_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %9 = load i16, ptr %s1, align 2
  %call = call zeroext i16 @vssrl16(ptr noundef %6, i32 noundef %7, i16 noundef zeroext %8, i16 noundef zeroext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssrl_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssrl_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssrl_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @vssrl32(ptr noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssrl_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssrl_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssrl_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s1, align 8
  %call = call i64 @vssrl64(ptr noundef %6, i32 noundef %7, i64 noundef %8, i64 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssrl_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssrl_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssrl_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i8, ptr %s2, align 1
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %call = call zeroext i8 @vssrl8(ptr noundef %3, i32 noundef %4, i8 noundef zeroext %5, i8 noundef zeroext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i8, ptr %7, i64 %idx.ext1
  store i8 %call, ptr %add.ptr2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssrl_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssrl_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssrl_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %call = call zeroext i16 @vssrl16(ptr noundef %3, i32 noundef %4, i16 noundef zeroext %5, i16 noundef zeroext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i16, ptr %7, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssrl_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssrl_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssrl_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @vssrl32(ptr noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssrl_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssrl_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssrl_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %call = call i64 @vssrl64(ptr noundef %3, i32 noundef %4, i64 noundef %5, i64 noundef %6)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssra_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssra_vv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssra_vv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i8, ptr %3, i64 %idx.ext1
  %5 = load i8, ptr %add.ptr2, align 1
  store i8 %5, ptr %s2, align 1
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i8, ptr %s2, align 1
  %9 = load i8, ptr %s1, align 1
  %call = call signext i8 @vssra8(ptr noundef %6, i32 noundef %7, i8 noundef signext %8, i8 noundef signext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i8, ptr %10, i64 %idx.ext3
  store i8 %call, ptr %add.ptr4, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssra_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssra_vv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssra_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %9 = load i16, ptr %s1, align 2
  %call = call signext i16 @vssra16(ptr noundef %6, i32 noundef %7, i16 noundef signext %8, i16 noundef signext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssra_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssra_vv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssra_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @vssra32(ptr noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssra_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssra_vv_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssra_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i64, ptr %s1, align 8
  %call = call i64 @vssra64(ptr noundef %6, i32 noundef %7, i64 noundef %8, i64 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssra_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssra_vx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssra_vx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i8, ptr %s2, align 1
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %call = call signext i8 @vssra8(ptr noundef %3, i32 noundef %4, i8 noundef signext %5, i8 noundef signext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i8, ptr %7, i64 %idx.ext1
  store i8 %call, ptr %add.ptr2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssra_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssra_vx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssra_vx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %call = call signext i16 @vssra16(ptr noundef %3, i32 noundef %4, i16 noundef signext %5, i16 noundef signext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i16, ptr %7, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssra_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssra_vx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssra_vx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @vssra32(ptr noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vssra_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vssra_vx_d, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vssra_vx_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %call = call i64 @vssra64(ptr noundef %3, i32 noundef %4, i64 noundef %5, i64 noundef %6)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i64, ptr %7, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnclip_wv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnclip_wv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnclip_wv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %9 = load i8, ptr %s1, align 1
  %call = call signext i8 @vnclip8(ptr noundef %6, i32 noundef %7, i16 noundef signext %8, i8 noundef signext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i8, ptr %10, i64 %idx.ext3
  store i8 %call, ptr %add.ptr4, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnclip_wv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnclip_wv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnclip_wv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i16, ptr %s1, align 2
  %call = call signext i16 @vnclip16(ptr noundef %6, i32 noundef %7, i32 noundef %8, i16 noundef signext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnclip_wv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnclip_wv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnclip_wv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @vnclip32(ptr noundef %6, i32 noundef %7, i64 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnclip_wx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnclip_wx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnclip_wx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %call = call signext i8 @vnclip8(ptr noundef %3, i32 noundef %4, i16 noundef signext %5, i8 noundef signext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i8, ptr %7, i64 %idx.ext1
  store i8 %call, ptr %add.ptr2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnclip_wx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnclip_wx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnclip_wx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %call = call signext i16 @vnclip16(ptr noundef %3, i32 noundef %4, i32 noundef %5, i16 noundef signext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i16, ptr %7, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnclip_wx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnclip_wx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnclip_wx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @vnclip32(ptr noundef %3, i32 noundef %4, i64 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnclipu_wv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnclipu_wv_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnclipu_wv_b(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s1, align 1
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i16, ptr %s2, align 2
  %9 = load i8, ptr %s1, align 1
  %call = call zeroext i8 @vnclipu8(ptr noundef %6, i32 noundef %7, i16 noundef zeroext %8, i8 noundef zeroext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i8, ptr %10, i64 %idx.ext3
  store i8 %call, ptr %add.ptr4, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnclipu_wv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnclipu_wv_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnclipu_wv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i32, ptr %s2, align 4
  %9 = load i16, ptr %s1, align 2
  %call = call zeroext i16 @vnclipu16(ptr noundef %6, i32 noundef %7, i32 noundef %8, i16 noundef zeroext %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnclipu_wv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vv_rm_2(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnclipu_wv_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnclipu_wv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %env.addr, align 8
  %7 = load i32, ptr %vxrm.addr, align 4
  %8 = load i64, ptr %s2, align 8
  %9 = load i32, ptr %s1, align 4
  %call = call i32 @vnclipu32(ptr noundef %6, i32 noundef %7, i64 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnclipu_wx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnclipu_wx_b, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnclipu_wx_b(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i16, ptr %s2, align 2
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i8
  %call = call zeroext i8 @vnclipu8(ptr noundef %3, i32 noundef %4, i16 noundef zeroext %5, i8 noundef zeroext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i8, ptr %7, i64 %idx.ext1
  store i8 %call, ptr %add.ptr2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnclipu_wx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnclipu_wx_h, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnclipu_wx_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i32, ptr %s2, align 4
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i16
  %call = call zeroext i16 @vnclipu16(ptr noundef %3, i32 noundef %4, i32 noundef %5, i16 noundef zeroext %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i16, ptr %7, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vnclipu_wx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vext_vx_rm_2(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef @do_vnclipu_wx_w, i32 noundef 4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vnclipu_wx_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env, i32 noundef %vxrm) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %vxrm.addr, align 4
  %5 = load i64, ptr %s2, align 8
  %6 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %6 to i32
  %call = call i32 @vnclipu32(ptr noundef %3, i32 noundef %4, i64 noundef %5, i32 noundef %conv)
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %8 to i64
  %add.ptr2 = getelementptr i32, ptr %7, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfadd_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfadd_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !235

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfadd_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i16, ptr %s1, align 2
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call zeroext i16 @float16_add(i16 noundef zeroext %6, i16 noundef zeroext %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i16, ptr %9, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfadd_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfadd_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !236

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfadd_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @float32_add(i32 noundef %6, i32 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfadd_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfadd_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !237

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfadd_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @float64_add(i64 noundef %6, i64 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfadd_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfadd_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !238

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfadd_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call zeroext i16 @float16_add(i16 noundef zeroext %3, i16 noundef zeroext %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i16, ptr %6, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfadd_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfadd_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !239

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfadd_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @float32_add(i32 noundef %3, i32 noundef %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i32, ptr %6, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfadd_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfadd_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !240

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfadd_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @float64_add(i64 noundef %3, i64 noundef %4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i64, ptr %6, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsub_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsub_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !241

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsub_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i16, ptr %s1, align 2
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call zeroext i16 @float16_sub(i16 noundef zeroext %6, i16 noundef zeroext %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i16, ptr %9, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsub_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsub_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !242

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsub_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @float32_sub(i32 noundef %6, i32 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsub_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsub_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !243

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsub_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @float64_sub(i64 noundef %6, i64 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsub_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsub_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !244

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsub_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call zeroext i16 @float16_sub(i16 noundef zeroext %3, i16 noundef zeroext %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i16, ptr %6, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsub_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsub_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !245

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsub_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @float32_sub(i32 noundef %3, i32 noundef %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i32, ptr %6, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsub_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsub_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !246

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsub_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @float64_sub(i64 noundef %3, i64 noundef %4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i64, ptr %6, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfrsub_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfrsub_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !247

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfrsub_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call zeroext i16 @float16_rsub(i16 noundef zeroext %3, i16 noundef zeroext %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i16, ptr %6, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfrsub_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfrsub_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !248

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfrsub_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @float32_rsub(i32 noundef %3, i32 noundef %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i32, ptr %6, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfrsub_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfrsub_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !249

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfrsub_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @float64_rsub(i64 noundef %3, i64 noundef %4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i64, ptr %6, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwadd_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwadd_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !250

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwadd_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %conv4 = trunc i32 %6 to i16
  %7 = load i32, ptr %s1, align 4
  %conv5 = trunc i32 %7 to i16
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @vfwadd16(i16 noundef zeroext %conv4, i16 noundef zeroext %conv5, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %10 to i64
  %add.ptr7 = getelementptr i32, ptr %9, i64 %idx.ext6
  store i32 %call, ptr %add.ptr7, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwadd_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwadd_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !251

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwadd_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %conv4 = trunc i64 %6 to i32
  %7 = load i64, ptr %s1, align 8
  %conv5 = trunc i64 %7 to i32
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @vfwadd32(i32 noundef %conv4, i32 noundef %conv5, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %10 to i64
  %add.ptr7 = getelementptr i64, ptr %9, i64 %idx.ext6
  store i64 %call, ptr %add.ptr7, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwadd_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwadd_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !252

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwadd_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %conv1 = trunc i32 %3 to i16
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i16
  %conv3 = zext i16 %conv2 to i32
  %conv4 = trunc i32 %conv3 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @vfwadd16(i16 noundef zeroext %conv1, i16 noundef zeroext %conv4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %7 to i64
  %add.ptr6 = getelementptr i32, ptr %6, i64 %idx.ext5
  store i32 %call, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwadd_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwadd_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !253

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwadd_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %conv1 = trunc i64 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i32
  %conv3 = zext i32 %conv2 to i64
  %conv4 = trunc i64 %conv3 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @vfwadd32(i32 noundef %conv1, i32 noundef %conv4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %7 to i64
  %add.ptr6 = getelementptr i64, ptr %6, i64 %idx.ext5
  store i64 %call, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwsub_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwsub_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !254

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwsub_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %conv4 = trunc i32 %6 to i16
  %7 = load i32, ptr %s1, align 4
  %conv5 = trunc i32 %7 to i16
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @vfwsub16(i16 noundef zeroext %conv4, i16 noundef zeroext %conv5, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %10 to i64
  %add.ptr7 = getelementptr i32, ptr %9, i64 %idx.ext6
  store i32 %call, ptr %add.ptr7, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwsub_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwsub_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !255

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwsub_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %conv4 = trunc i64 %6 to i32
  %7 = load i64, ptr %s1, align 8
  %conv5 = trunc i64 %7 to i32
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @vfwsub32(i32 noundef %conv4, i32 noundef %conv5, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %10 to i64
  %add.ptr7 = getelementptr i64, ptr %9, i64 %idx.ext6
  store i64 %call, ptr %add.ptr7, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwsub_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwsub_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !256

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwsub_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %conv1 = trunc i32 %3 to i16
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i16
  %conv3 = zext i16 %conv2 to i32
  %conv4 = trunc i32 %conv3 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @vfwsub16(i16 noundef zeroext %conv1, i16 noundef zeroext %conv4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %7 to i64
  %add.ptr6 = getelementptr i32, ptr %6, i64 %idx.ext5
  store i32 %call, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwsub_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwsub_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !257

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwsub_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %conv1 = trunc i64 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i32
  %conv3 = zext i32 %conv2 to i64
  %conv4 = trunc i64 %conv3 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @vfwsub32(i32 noundef %conv1, i32 noundef %conv4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %7 to i64
  %add.ptr6 = getelementptr i64, ptr %6, i64 %idx.ext5
  store i64 %call, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwadd_wv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwadd_wv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !258

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwadd_wv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %conv3 = trunc i32 %7 to i16
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @vfwaddw16(i32 noundef %6, i16 noundef zeroext %conv3, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %10 to i64
  %add.ptr5 = getelementptr i32, ptr %9, i64 %idx.ext4
  store i32 %call, ptr %add.ptr5, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwadd_wv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwadd_wv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !259

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwadd_wv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %conv3 = trunc i64 %7 to i32
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @vfwaddw32(i64 noundef %6, i32 noundef %conv3, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %10 to i64
  %add.ptr5 = getelementptr i64, ptr %9, i64 %idx.ext4
  store i64 %call, ptr %add.ptr5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwadd_wf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwadd_wf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !260

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwadd_wf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %conv1 = zext i16 %conv to i32
  %conv2 = trunc i32 %conv1 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @vfwaddw16(i32 noundef %3, i16 noundef zeroext %conv2, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwadd_wf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwadd_wf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !261

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwadd_wf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %conv1 = zext i32 %conv to i64
  %conv2 = trunc i64 %conv1 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @vfwaddw32(i64 noundef %3, i32 noundef %conv2, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwsub_wv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwsub_wv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !262

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwsub_wv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %conv3 = trunc i32 %7 to i16
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @vfwsubw16(i32 noundef %6, i16 noundef zeroext %conv3, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %10 to i64
  %add.ptr5 = getelementptr i32, ptr %9, i64 %idx.ext4
  store i32 %call, ptr %add.ptr5, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwsub_wv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwsub_wv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !263

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwsub_wv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %conv3 = trunc i64 %7 to i32
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @vfwsubw32(i64 noundef %6, i32 noundef %conv3, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %10 to i64
  %add.ptr5 = getelementptr i64, ptr %9, i64 %idx.ext4
  store i64 %call, ptr %add.ptr5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwsub_wf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwsub_wf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !264

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwsub_wf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %conv1 = zext i16 %conv to i32
  %conv2 = trunc i32 %conv1 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @vfwsubw16(i32 noundef %3, i16 noundef zeroext %conv2, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwsub_wf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwsub_wf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !265

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwsub_wf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %conv1 = zext i32 %conv to i64
  %conv2 = trunc i64 %conv1 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @vfwsubw32(i64 noundef %3, i32 noundef %conv2, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmul_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmul_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !266

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmul_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i16, ptr %s1, align 2
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call zeroext i16 @float16_mul(i16 noundef zeroext %6, i16 noundef zeroext %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i16, ptr %9, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmul_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmul_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !267

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmul_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @float32_mul(i32 noundef %6, i32 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmul_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmul_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !268

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmul_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @float64_mul(i64 noundef %6, i64 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmul_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmul_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !269

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmul_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call zeroext i16 @float16_mul(i16 noundef zeroext %3, i16 noundef zeroext %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i16, ptr %6, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmul_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmul_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !270

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmul_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @float32_mul(i32 noundef %3, i32 noundef %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i32, ptr %6, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmul_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmul_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !271

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmul_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @float64_mul(i64 noundef %3, i64 noundef %4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i64, ptr %6, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfdiv_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfdiv_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !272

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfdiv_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i16, ptr %s1, align 2
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call zeroext i16 @float16_div(i16 noundef zeroext %6, i16 noundef zeroext %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i16, ptr %9, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfdiv_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfdiv_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !273

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfdiv_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @float32_div(i32 noundef %6, i32 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfdiv_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfdiv_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !274

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfdiv_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @float64_div(i64 noundef %6, i64 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfdiv_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfdiv_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !275

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfdiv_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call zeroext i16 @float16_div(i16 noundef zeroext %3, i16 noundef zeroext %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i16, ptr %6, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfdiv_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfdiv_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !276

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfdiv_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @float32_div(i32 noundef %3, i32 noundef %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i32, ptr %6, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfdiv_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfdiv_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !277

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfdiv_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @float64_div(i64 noundef %3, i64 noundef %4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i64, ptr %6, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfrdiv_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfrdiv_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !278

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfrdiv_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call zeroext i16 @float16_rdiv(i16 noundef zeroext %3, i16 noundef zeroext %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i16, ptr %6, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfrdiv_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfrdiv_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !279

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfrdiv_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @float32_rdiv(i32 noundef %3, i32 noundef %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i32, ptr %6, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfrdiv_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfrdiv_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !280

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfrdiv_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @float64_rdiv(i64 noundef %3, i64 noundef %4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i64, ptr %6, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmul_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmul_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !281

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmul_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %conv4 = trunc i32 %6 to i16
  %7 = load i32, ptr %s1, align 4
  %conv5 = trunc i32 %7 to i16
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @vfwmul16(i16 noundef zeroext %conv4, i16 noundef zeroext %conv5, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %10 to i64
  %add.ptr7 = getelementptr i32, ptr %9, i64 %idx.ext6
  store i32 %call, ptr %add.ptr7, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmul_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmul_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !282

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmul_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %conv4 = trunc i64 %6 to i32
  %7 = load i64, ptr %s1, align 8
  %conv5 = trunc i64 %7 to i32
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @vfwmul32(i32 noundef %conv4, i32 noundef %conv5, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext6 = sext i32 %10 to i64
  %add.ptr7 = getelementptr i64, ptr %9, i64 %idx.ext6
  store i64 %call, ptr %add.ptr7, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmul_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmul_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !283

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmul_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %conv1 = trunc i32 %3 to i16
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i16
  %conv3 = zext i16 %conv2 to i32
  %conv4 = trunc i32 %conv3 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @vfwmul16(i16 noundef zeroext %conv1, i16 noundef zeroext %conv4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %7 to i64
  %add.ptr6 = getelementptr i32, ptr %6, i64 %idx.ext5
  store i32 %call, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmul_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmul_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !284

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmul_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %conv1 = trunc i64 %3 to i32
  %4 = load i64, ptr %s1.addr, align 8
  %conv2 = trunc i64 %4 to i32
  %conv3 = zext i32 %conv2 to i64
  %conv4 = trunc i64 %conv3 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @vfwmul32(i32 noundef %conv1, i32 noundef %conv4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %7 to i64
  %add.ptr6 = getelementptr i64, ptr %6, i64 %idx.ext5
  store i64 %call, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmacc_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmacc_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !285

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmacc_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i16, ptr %6, i64 %idx.ext3
  %8 = load i16, ptr %add.ptr4, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s2, align 2
  %10 = load i16, ptr %s1, align 2
  %11 = load i16, ptr %d, align 2
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call zeroext i16 @fmacc16(i16 noundef zeroext %9, i16 noundef zeroext %10, i16 noundef zeroext %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i16, ptr %13, i64 %idx.ext5
  store i16 %call, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmacc_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmacc_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !286

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmacc_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  %8 = load i32, ptr %add.ptr4, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %10 = load i32, ptr %s1, align 4
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fmacc32(i32 noundef %9, i32 noundef %10, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i32, ptr %13, i64 %idx.ext5
  store i32 %call, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmacc_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmacc_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !287

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmacc_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  %8 = load i64, ptr %add.ptr4, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s2, align 8
  %10 = load i64, ptr %s1, align 8
  %11 = load i64, ptr %d, align 8
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i64 @fmacc64(i64 noundef %9, i64 noundef %10, i64 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i64, ptr %13, i64 %idx.ext5
  store i64 %call, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmacc_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmacc_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !288

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmacc_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i16
  %8 = load i16, ptr %d, align 2
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call zeroext i16 @fmacc16(i16 noundef zeroext %6, i16 noundef zeroext %conv, i16 noundef zeroext %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmacc_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmacc_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !289

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmacc_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i32
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fmacc32(i32 noundef %6, i32 noundef %conv, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmacc_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmacc_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !290

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmacc_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1.addr, align 8
  %8 = load i64, ptr %d, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i64 @fmacc64(i64 noundef %6, i64 noundef %7, i64 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmacc_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmacc_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !291

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmacc_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i16, ptr %6, i64 %idx.ext3
  %8 = load i16, ptr %add.ptr4, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s2, align 2
  %10 = load i16, ptr %s1, align 2
  %11 = load i16, ptr %d, align 2
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call zeroext i16 @fnmacc16(i16 noundef zeroext %9, i16 noundef zeroext %10, i16 noundef zeroext %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i16, ptr %13, i64 %idx.ext5
  store i16 %call, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmacc_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmacc_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !292

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmacc_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  %8 = load i32, ptr %add.ptr4, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %10 = load i32, ptr %s1, align 4
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fnmacc32(i32 noundef %9, i32 noundef %10, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i32, ptr %13, i64 %idx.ext5
  store i32 %call, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmacc_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmacc_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !293

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmacc_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  %8 = load i64, ptr %add.ptr4, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s2, align 8
  %10 = load i64, ptr %s1, align 8
  %11 = load i64, ptr %d, align 8
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i64 @fnmacc64(i64 noundef %9, i64 noundef %10, i64 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i64, ptr %13, i64 %idx.ext5
  store i64 %call, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmacc_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmacc_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !294

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmacc_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i16
  %8 = load i16, ptr %d, align 2
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call zeroext i16 @fnmacc16(i16 noundef zeroext %6, i16 noundef zeroext %conv, i16 noundef zeroext %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmacc_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmacc_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !295

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmacc_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i32
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fnmacc32(i32 noundef %6, i32 noundef %conv, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmacc_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmacc_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !296

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmacc_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1.addr, align 8
  %8 = load i64, ptr %d, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i64 @fnmacc64(i64 noundef %6, i64 noundef %7, i64 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmsac_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmsac_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !297

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmsac_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i16, ptr %6, i64 %idx.ext3
  %8 = load i16, ptr %add.ptr4, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s2, align 2
  %10 = load i16, ptr %s1, align 2
  %11 = load i16, ptr %d, align 2
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call zeroext i16 @fmsac16(i16 noundef zeroext %9, i16 noundef zeroext %10, i16 noundef zeroext %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i16, ptr %13, i64 %idx.ext5
  store i16 %call, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmsac_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmsac_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !298

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmsac_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  %8 = load i32, ptr %add.ptr4, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %10 = load i32, ptr %s1, align 4
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fmsac32(i32 noundef %9, i32 noundef %10, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i32, ptr %13, i64 %idx.ext5
  store i32 %call, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmsac_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmsac_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !299

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmsac_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  %8 = load i64, ptr %add.ptr4, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s2, align 8
  %10 = load i64, ptr %s1, align 8
  %11 = load i64, ptr %d, align 8
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i64 @fmsac64(i64 noundef %9, i64 noundef %10, i64 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i64, ptr %13, i64 %idx.ext5
  store i64 %call, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmsac_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmsac_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !300

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmsac_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i16
  %8 = load i16, ptr %d, align 2
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call zeroext i16 @fmsac16(i16 noundef zeroext %6, i16 noundef zeroext %conv, i16 noundef zeroext %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmsac_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmsac_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !301

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmsac_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i32
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fmsac32(i32 noundef %6, i32 noundef %conv, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmsac_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmsac_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !302

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmsac_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1.addr, align 8
  %8 = load i64, ptr %d, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i64 @fmsac64(i64 noundef %6, i64 noundef %7, i64 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmsac_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmsac_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !303

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmsac_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i16, ptr %6, i64 %idx.ext3
  %8 = load i16, ptr %add.ptr4, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s2, align 2
  %10 = load i16, ptr %s1, align 2
  %11 = load i16, ptr %d, align 2
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call zeroext i16 @fnmsac16(i16 noundef zeroext %9, i16 noundef zeroext %10, i16 noundef zeroext %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i16, ptr %13, i64 %idx.ext5
  store i16 %call, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmsac_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmsac_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !304

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmsac_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  %8 = load i32, ptr %add.ptr4, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %10 = load i32, ptr %s1, align 4
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fnmsac32(i32 noundef %9, i32 noundef %10, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i32, ptr %13, i64 %idx.ext5
  store i32 %call, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmsac_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmsac_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !305

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmsac_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  %8 = load i64, ptr %add.ptr4, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s2, align 8
  %10 = load i64, ptr %s1, align 8
  %11 = load i64, ptr %d, align 8
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i64 @fnmsac64(i64 noundef %9, i64 noundef %10, i64 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i64, ptr %13, i64 %idx.ext5
  store i64 %call, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmsac_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmsac_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !306

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmsac_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i16
  %8 = load i16, ptr %d, align 2
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call zeroext i16 @fnmsac16(i16 noundef zeroext %6, i16 noundef zeroext %conv, i16 noundef zeroext %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmsac_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmsac_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !307

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmsac_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i32
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fnmsac32(i32 noundef %6, i32 noundef %conv, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmsac_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmsac_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !308

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmsac_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1.addr, align 8
  %8 = load i64, ptr %d, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i64 @fnmsac64(i64 noundef %6, i64 noundef %7, i64 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmadd_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmadd_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !309

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmadd_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i16, ptr %6, i64 %idx.ext3
  %8 = load i16, ptr %add.ptr4, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s2, align 2
  %10 = load i16, ptr %s1, align 2
  %11 = load i16, ptr %d, align 2
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call zeroext i16 @fmadd16(i16 noundef zeroext %9, i16 noundef zeroext %10, i16 noundef zeroext %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i16, ptr %13, i64 %idx.ext5
  store i16 %call, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmadd_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmadd_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !310

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmadd_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  %8 = load i32, ptr %add.ptr4, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %10 = load i32, ptr %s1, align 4
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fmadd32(i32 noundef %9, i32 noundef %10, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i32, ptr %13, i64 %idx.ext5
  store i32 %call, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmadd_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmadd_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !311

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmadd_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  %8 = load i64, ptr %add.ptr4, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s2, align 8
  %10 = load i64, ptr %s1, align 8
  %11 = load i64, ptr %d, align 8
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i64 @fmadd64(i64 noundef %9, i64 noundef %10, i64 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i64, ptr %13, i64 %idx.ext5
  store i64 %call, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmadd_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmadd_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !312

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmadd_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i16
  %8 = load i16, ptr %d, align 2
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call zeroext i16 @fmadd16(i16 noundef zeroext %6, i16 noundef zeroext %conv, i16 noundef zeroext %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmadd_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmadd_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !313

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmadd_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i32
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fmadd32(i32 noundef %6, i32 noundef %conv, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmadd_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmadd_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !314

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmadd_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1.addr, align 8
  %8 = load i64, ptr %d, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i64 @fmadd64(i64 noundef %6, i64 noundef %7, i64 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmadd_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmadd_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !315

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmadd_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i16, ptr %6, i64 %idx.ext3
  %8 = load i16, ptr %add.ptr4, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s2, align 2
  %10 = load i16, ptr %s1, align 2
  %11 = load i16, ptr %d, align 2
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call zeroext i16 @fnmadd16(i16 noundef zeroext %9, i16 noundef zeroext %10, i16 noundef zeroext %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i16, ptr %13, i64 %idx.ext5
  store i16 %call, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmadd_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmadd_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !316

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmadd_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  %8 = load i32, ptr %add.ptr4, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %10 = load i32, ptr %s1, align 4
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fnmadd32(i32 noundef %9, i32 noundef %10, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i32, ptr %13, i64 %idx.ext5
  store i32 %call, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmadd_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmadd_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !317

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmadd_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  %8 = load i64, ptr %add.ptr4, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s2, align 8
  %10 = load i64, ptr %s1, align 8
  %11 = load i64, ptr %d, align 8
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i64 @fnmadd64(i64 noundef %9, i64 noundef %10, i64 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i64, ptr %13, i64 %idx.ext5
  store i64 %call, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmadd_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmadd_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !318

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmadd_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i16
  %8 = load i16, ptr %d, align 2
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call zeroext i16 @fnmadd16(i16 noundef zeroext %6, i16 noundef zeroext %conv, i16 noundef zeroext %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmadd_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmadd_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !319

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmadd_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i32
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fnmadd32(i32 noundef %6, i32 noundef %conv, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmadd_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmadd_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !320

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmadd_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1.addr, align 8
  %8 = load i64, ptr %d, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i64 @fnmadd64(i64 noundef %6, i64 noundef %7, i64 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmsub_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmsub_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !321

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmsub_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i16, ptr %6, i64 %idx.ext3
  %8 = load i16, ptr %add.ptr4, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s2, align 2
  %10 = load i16, ptr %s1, align 2
  %11 = load i16, ptr %d, align 2
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call zeroext i16 @fmsub16(i16 noundef zeroext %9, i16 noundef zeroext %10, i16 noundef zeroext %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i16, ptr %13, i64 %idx.ext5
  store i16 %call, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmsub_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmsub_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !322

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmsub_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  %8 = load i32, ptr %add.ptr4, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %10 = load i32, ptr %s1, align 4
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fmsub32(i32 noundef %9, i32 noundef %10, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i32, ptr %13, i64 %idx.ext5
  store i32 %call, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmsub_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmsub_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !323

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmsub_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  %8 = load i64, ptr %add.ptr4, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s2, align 8
  %10 = load i64, ptr %s1, align 8
  %11 = load i64, ptr %d, align 8
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i64 @fmsub64(i64 noundef %9, i64 noundef %10, i64 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i64, ptr %13, i64 %idx.ext5
  store i64 %call, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmsub_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmsub_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !324

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmsub_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i16
  %8 = load i16, ptr %d, align 2
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call zeroext i16 @fmsub16(i16 noundef zeroext %6, i16 noundef zeroext %conv, i16 noundef zeroext %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmsub_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmsub_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !325

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmsub_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i32
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fmsub32(i32 noundef %6, i32 noundef %conv, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmsub_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmsub_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !326

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmsub_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1.addr, align 8
  %8 = load i64, ptr %d, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i64 @fmsub64(i64 noundef %6, i64 noundef %7, i64 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmsub_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmsub_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !327

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmsub_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i16, ptr %6, i64 %idx.ext3
  %8 = load i16, ptr %add.ptr4, align 2
  store i16 %8, ptr %d, align 2
  %9 = load i16, ptr %s2, align 2
  %10 = load i16, ptr %s1, align 2
  %11 = load i16, ptr %d, align 2
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call zeroext i16 @fnmsub16(i16 noundef zeroext %9, i16 noundef zeroext %10, i16 noundef zeroext %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i16, ptr %13, i64 %idx.ext5
  store i16 %call, ptr %add.ptr6, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmsub_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmsub_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !328

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmsub_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i32, ptr %6, i64 %idx.ext3
  %8 = load i32, ptr %add.ptr4, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %10 = load i32, ptr %s1, align 4
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fnmsub32(i32 noundef %9, i32 noundef %10, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i32, ptr %13, i64 %idx.ext5
  store i32 %call, ptr %add.ptr6, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmsub_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmsub_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !329

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmsub_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr i64, ptr %6, i64 %idx.ext3
  %8 = load i64, ptr %add.ptr4, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s2, align 8
  %10 = load i64, ptr %s1, align 8
  %11 = load i64, ptr %d, align 8
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i64 @fnmsub64(i64 noundef %9, i64 noundef %10, i64 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext5 = sext i32 %14 to i64
  %add.ptr6 = getelementptr i64, ptr %13, i64 %idx.ext5
  store i64 %call, ptr %add.ptr6, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmsub_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmsub_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !330

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmsub_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  %d = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %d, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i16
  %8 = load i16, ptr %d, align 2
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call zeroext i16 @fnmsub16(i16 noundef zeroext %6, i16 noundef zeroext %conv, i16 noundef zeroext %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i16, ptr %10, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmsub_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmsub_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !331

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmsub_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %7 to i32
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fnmsub32(i32 noundef %6, i32 noundef %conv, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i32, ptr %10, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfnmsub_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfnmsub_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !332

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfnmsub_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1.addr, align 8
  %8 = load i64, ptr %d, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i64 @fnmsub64(i64 noundef %6, i64 noundef %7, i64 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %11 to i64
  %add.ptr4 = getelementptr i64, ptr %10, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmacc_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmacc_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !333

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmacc_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i32, ptr %6, i64 %idx.ext4
  %8 = load i32, ptr %add.ptr5, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %conv6 = trunc i32 %9 to i16
  %10 = load i32, ptr %s1, align 4
  %conv7 = trunc i32 %10 to i16
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fwmacc16(i16 noundef zeroext %conv6, i16 noundef zeroext %conv7, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %14 to i64
  %add.ptr9 = getelementptr i32, ptr %13, i64 %idx.ext8
  store i32 %call, ptr %add.ptr9, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmacc_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmacc_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !334

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmacc_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i64, ptr %6, i64 %idx.ext4
  %8 = load i64, ptr %add.ptr5, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s2, align 8
  %conv6 = trunc i64 %9 to i32
  %10 = load i64, ptr %s1, align 8
  %conv7 = trunc i64 %10 to i32
  %11 = load i64, ptr %d, align 8
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i64 @fwmacc32(i32 noundef %conv6, i32 noundef %conv7, i64 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %14 to i64
  %add.ptr9 = getelementptr i64, ptr %13, i64 %idx.ext8
  store i64 %call, ptr %add.ptr9, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmacc_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmacc_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !335

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmacc_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %conv3 = trunc i32 %6 to i16
  %7 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %7 to i16
  %conv5 = zext i16 %conv4 to i32
  %conv6 = trunc i32 %conv5 to i16
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fwmacc16(i16 noundef zeroext %conv3, i16 noundef zeroext %conv6, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %11 to i64
  %add.ptr8 = getelementptr i32, ptr %10, i64 %idx.ext7
  store i32 %call, ptr %add.ptr8, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmacc_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmacc_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !336

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmacc_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s2, align 8
  %conv3 = trunc i64 %6 to i32
  %7 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %7 to i32
  %conv5 = zext i32 %conv4 to i64
  %conv6 = trunc i64 %conv5 to i32
  %8 = load i64, ptr %d, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i64 @fwmacc32(i32 noundef %conv3, i32 noundef %conv6, i64 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %11 to i64
  %add.ptr8 = getelementptr i64, ptr %10, i64 %idx.ext7
  store i64 %call, ptr %add.ptr8, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmaccbf16_vv(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmaccbf16_vv(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !337

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmaccbf16_vv(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i32, ptr %6, i64 %idx.ext4
  %8 = load i32, ptr %add.ptr5, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %conv6 = trunc i32 %9 to i16
  %10 = load i32, ptr %s1, align 4
  %conv7 = trunc i32 %10 to i16
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fwmaccbf16(i16 noundef zeroext %conv6, i16 noundef zeroext %conv7, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %14 to i64
  %add.ptr9 = getelementptr i32, ptr %13, i64 %idx.ext8
  store i32 %call, ptr %add.ptr9, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmaccbf16_vf(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmaccbf16_vf(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !338

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmaccbf16_vf(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %conv3 = trunc i32 %6 to i16
  %7 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %7 to i16
  %conv5 = zext i16 %conv4 to i32
  %conv6 = trunc i32 %conv5 to i16
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fwmaccbf16(i16 noundef zeroext %conv3, i16 noundef zeroext %conv6, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %11 to i64
  %add.ptr8 = getelementptr i32, ptr %10, i64 %idx.ext7
  store i32 %call, ptr %add.ptr8, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwnmacc_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwnmacc_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !339

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwnmacc_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i32, ptr %6, i64 %idx.ext4
  %8 = load i32, ptr %add.ptr5, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %conv6 = trunc i32 %9 to i16
  %10 = load i32, ptr %s1, align 4
  %conv7 = trunc i32 %10 to i16
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fwnmacc16(i16 noundef zeroext %conv6, i16 noundef zeroext %conv7, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %14 to i64
  %add.ptr9 = getelementptr i32, ptr %13, i64 %idx.ext8
  store i32 %call, ptr %add.ptr9, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwnmacc_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwnmacc_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !340

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwnmacc_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i64, ptr %6, i64 %idx.ext4
  %8 = load i64, ptr %add.ptr5, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s2, align 8
  %conv6 = trunc i64 %9 to i32
  %10 = load i64, ptr %s1, align 8
  %conv7 = trunc i64 %10 to i32
  %11 = load i64, ptr %d, align 8
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i64 @fwnmacc32(i32 noundef %conv6, i32 noundef %conv7, i64 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %14 to i64
  %add.ptr9 = getelementptr i64, ptr %13, i64 %idx.ext8
  store i64 %call, ptr %add.ptr9, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwnmacc_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwnmacc_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !341

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwnmacc_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %conv3 = trunc i32 %6 to i16
  %7 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %7 to i16
  %conv5 = zext i16 %conv4 to i32
  %conv6 = trunc i32 %conv5 to i16
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fwnmacc16(i16 noundef zeroext %conv3, i16 noundef zeroext %conv6, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %11 to i64
  %add.ptr8 = getelementptr i32, ptr %10, i64 %idx.ext7
  store i32 %call, ptr %add.ptr8, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwnmacc_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwnmacc_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !342

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwnmacc_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s2, align 8
  %conv3 = trunc i64 %6 to i32
  %7 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %7 to i32
  %conv5 = zext i32 %conv4 to i64
  %conv6 = trunc i64 %conv5 to i32
  %8 = load i64, ptr %d, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i64 @fwnmacc32(i32 noundef %conv3, i32 noundef %conv6, i64 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %11 to i64
  %add.ptr8 = getelementptr i64, ptr %10, i64 %idx.ext7
  store i64 %call, ptr %add.ptr8, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmsac_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmsac_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !343

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmsac_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i32, ptr %6, i64 %idx.ext4
  %8 = load i32, ptr %add.ptr5, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %conv6 = trunc i32 %9 to i16
  %10 = load i32, ptr %s1, align 4
  %conv7 = trunc i32 %10 to i16
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fwmsac16(i16 noundef zeroext %conv6, i16 noundef zeroext %conv7, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %14 to i64
  %add.ptr9 = getelementptr i32, ptr %13, i64 %idx.ext8
  store i32 %call, ptr %add.ptr9, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmsac_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmsac_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !344

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmsac_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i64, ptr %6, i64 %idx.ext4
  %8 = load i64, ptr %add.ptr5, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s2, align 8
  %conv6 = trunc i64 %9 to i32
  %10 = load i64, ptr %s1, align 8
  %conv7 = trunc i64 %10 to i32
  %11 = load i64, ptr %d, align 8
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i64 @fwmsac32(i32 noundef %conv6, i32 noundef %conv7, i64 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %14 to i64
  %add.ptr9 = getelementptr i64, ptr %13, i64 %idx.ext8
  store i64 %call, ptr %add.ptr9, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmsac_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmsac_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !345

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmsac_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %conv3 = trunc i32 %6 to i16
  %7 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %7 to i16
  %conv5 = zext i16 %conv4 to i32
  %conv6 = trunc i32 %conv5 to i16
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fwmsac16(i16 noundef zeroext %conv3, i16 noundef zeroext %conv6, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %11 to i64
  %add.ptr8 = getelementptr i32, ptr %10, i64 %idx.ext7
  store i32 %call, ptr %add.ptr8, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwmsac_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwmsac_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !346

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwmsac_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s2, align 8
  %conv3 = trunc i64 %6 to i32
  %7 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %7 to i32
  %conv5 = zext i32 %conv4 to i64
  %conv6 = trunc i64 %conv5 to i32
  %8 = load i64, ptr %d, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i64 @fwmsac32(i32 noundef %conv3, i32 noundef %conv6, i64 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %11 to i64
  %add.ptr8 = getelementptr i64, ptr %10, i64 %idx.ext7
  store i64 %call, ptr %add.ptr8, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwnmsac_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwnmsac_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !347

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwnmsac_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  %conv3 = zext i16 %5 to i32
  store i32 %conv3, ptr %s2, align 4
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i32, ptr %6, i64 %idx.ext4
  %8 = load i32, ptr %add.ptr5, align 4
  store i32 %8, ptr %d, align 4
  %9 = load i32, ptr %s2, align 4
  %conv6 = trunc i32 %9 to i16
  %10 = load i32, ptr %s1, align 4
  %conv7 = trunc i32 %10 to i16
  %11 = load i32, ptr %d, align 4
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i32 @fwnmsac16(i16 noundef zeroext %conv6, i16 noundef zeroext %conv7, i32 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %14 to i64
  %add.ptr9 = getelementptr i32, ptr %13, i64 %idx.ext8
  store i32 %call, ptr %add.ptr9, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwnmsac_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwnmsac_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !348

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwnmsac_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %s2, align 8
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr i64, ptr %6, i64 %idx.ext4
  %8 = load i64, ptr %add.ptr5, align 8
  store i64 %8, ptr %d, align 8
  %9 = load i64, ptr %s2, align 8
  %conv6 = trunc i64 %9 to i32
  %10 = load i64, ptr %s1, align 8
  %conv7 = trunc i64 %10 to i32
  %11 = load i64, ptr %d, align 8
  %12 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %12, i32 0, i32 14
  %call = call i64 @fwnmsac32(i32 noundef %conv6, i32 noundef %conv7, i64 noundef %11, ptr noundef %fp_status)
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i.addr, align 4
  %idx.ext8 = sext i32 %14 to i64
  %add.ptr9 = getelementptr i64, ptr %13, i64 %idx.ext8
  store i64 %call, ptr %add.ptr9, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwnmsac_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwnmsac_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !349

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwnmsac_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  %d = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %d, align 4
  %6 = load i32, ptr %s2, align 4
  %conv3 = trunc i32 %6 to i16
  %7 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %7 to i16
  %conv5 = zext i16 %conv4 to i32
  %conv6 = trunc i32 %conv5 to i16
  %8 = load i32, ptr %d, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i32 @fwnmsac16(i16 noundef zeroext %conv3, i16 noundef zeroext %conv6, i32 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %11 to i64
  %add.ptr8 = getelementptr i32, ptr %10, i64 %idx.ext7
  store i32 %call, ptr %add.ptr8, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwnmsac_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwnmsac_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !350

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwnmsac_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  %conv = zext i32 %2 to i64
  store i64 %conv, ptr %s2, align 8
  %3 = load ptr, ptr %vd.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %d, align 8
  %6 = load i64, ptr %s2, align 8
  %conv3 = trunc i64 %6 to i32
  %7 = load i64, ptr %s1.addr, align 8
  %conv4 = trunc i64 %7 to i32
  %conv5 = zext i32 %conv4 to i64
  %conv6 = trunc i64 %conv5 to i32
  %8 = load i64, ptr %d, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 14
  %call = call i64 @fwnmsac32(i32 noundef %conv3, i32 noundef %conv6, i64 noundef %8, ptr noundef %fp_status)
  %10 = load ptr, ptr %vd.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idx.ext7 = sext i32 %11 to i64
  %add.ptr8 = getelementptr i64, ptr %10, i64 %idx.ext7
  store i64 %call, ptr %add.ptr8, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsqrt_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsqrt_v_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !351

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsqrt_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @float16_sqrt(i16 noundef zeroext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsqrt_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsqrt_v_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !352

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsqrt_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @float32_sqrt(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsqrt_v_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 8
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsqrt_v_d(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !353

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsqrt_v_d(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i64 @float64_sqrt(i64 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfrsqrt7_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfrsqrt7_v_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !354

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfrsqrt7_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @frsqrt7_h(i16 noundef zeroext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfrsqrt7_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfrsqrt7_v_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !355

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfrsqrt7_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @frsqrt7_s(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfrsqrt7_v_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 8
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfrsqrt7_v_d(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !356

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfrsqrt7_v_d(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i64 @frsqrt7_d(i64 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfrec7_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfrec7_v_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !357

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfrec7_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @frec7_h(i16 noundef zeroext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfrec7_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfrec7_v_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !358

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfrec7_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @frec7_s(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfrec7_v_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 8
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfrec7_v_d(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !359

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfrec7_v_d(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i64 @frec7_d(i64 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmin_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmin_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !360

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmin_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i16, ptr %s1, align 2
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call zeroext i16 @float16_minimum_number(i16 noundef zeroext %6, i16 noundef zeroext %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i16, ptr %9, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmin_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmin_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !361

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmin_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @float32_minimum_number(i32 noundef %6, i32 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmin_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmin_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !362

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmin_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @float64_minimum_number(i64 noundef %6, i64 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmin_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmin_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !363

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmin_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call zeroext i16 @float16_minimum_number(i16 noundef zeroext %3, i16 noundef zeroext %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i16, ptr %6, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmin_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmin_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !364

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmin_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @float32_minimum_number(i32 noundef %3, i32 noundef %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i32, ptr %6, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmin_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmin_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !365

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmin_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @float64_minimum_number(i64 noundef %3, i64 noundef %4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i64, ptr %6, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmax_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmax_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !366

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmax_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i16, ptr %s1, align 2
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call zeroext i16 @float16_maximum_number(i16 noundef zeroext %6, i16 noundef zeroext %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i16, ptr %9, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmax_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmax_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !367

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmax_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @float32_maximum_number(i32 noundef %6, i32 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmax_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmax_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !368

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmax_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @float64_maximum_number(i64 noundef %6, i64 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmax_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmax_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !369

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmax_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call zeroext i16 @float16_maximum_number(i16 noundef zeroext %3, i16 noundef zeroext %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i16, ptr %6, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmax_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmax_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !370

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmax_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @float32_maximum_number(i32 noundef %3, i32 noundef %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i32, ptr %6, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmax_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfmax_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !371

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfmax_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @float64_maximum_number(i64 noundef %3, i64 noundef %4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i64, ptr %6, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnj_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnj_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !372

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnj_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i16, ptr %s1, align 2
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call zeroext i16 @fsgnj16(i16 noundef zeroext %6, i16 noundef zeroext %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i16, ptr %9, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnj_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnj_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !373

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnj_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @fsgnj32(i32 noundef %6, i32 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnj_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnj_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !374

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnj_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @fsgnj64(i64 noundef %6, i64 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnj_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnj_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !375

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnj_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call zeroext i16 @fsgnj16(i16 noundef zeroext %3, i16 noundef zeroext %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i16, ptr %6, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnj_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnj_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !376

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnj_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @fsgnj32(i32 noundef %3, i32 noundef %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i32, ptr %6, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnj_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnj_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !377

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnj_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @fsgnj64(i64 noundef %3, i64 noundef %4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i64, ptr %6, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnjn_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnjn_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !378

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnjn_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i16, ptr %s1, align 2
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call zeroext i16 @fsgnjn16(i16 noundef zeroext %6, i16 noundef zeroext %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i16, ptr %9, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnjn_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnjn_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !379

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnjn_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @fsgnjn32(i32 noundef %6, i32 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnjn_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnjn_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !380

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnjn_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @fsgnjn64(i64 noundef %6, i64 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnjn_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnjn_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !381

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnjn_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call zeroext i16 @fsgnjn16(i16 noundef zeroext %3, i16 noundef zeroext %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i16, ptr %6, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnjn_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnjn_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !382

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnjn_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @fsgnjn32(i32 noundef %3, i32 noundef %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i32, ptr %6, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnjn_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnjn_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !383

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnjn_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @fsgnjn64(i64 noundef %3, i64 noundef %4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i64, ptr %6, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnjx_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnjx_vv_h(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !384

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnjx_vv_h(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s1, align 2
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i16, ptr %3, i64 %idx.ext1
  %5 = load i16, ptr %add.ptr2, align 2
  store i16 %5, ptr %s2, align 2
  %6 = load i16, ptr %s2, align 2
  %7 = load i16, ptr %s1, align 2
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call zeroext i16 @fsgnjx16(i16 noundef zeroext %6, i16 noundef zeroext %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i16, ptr %9, i64 %idx.ext3
  store i16 %call, ptr %add.ptr4, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnjx_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnjx_vv_w(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !385

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnjx_vv_w(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s1, align 4
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i32, ptr %3, i64 %idx.ext1
  %5 = load i32, ptr %add.ptr2, align 4
  store i32 %5, ptr %s2, align 4
  %6 = load i32, ptr %s2, align 4
  %7 = load i32, ptr %s1, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i32 @fsgnjx32(i32 noundef %6, i32 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i32, ptr %9, i64 %idx.ext3
  store i32 %call, ptr %add.ptr4, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnjx_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnjx_vv_d(ptr noundef %18, ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !386

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnjx_vv_d(ptr noundef %vd, ptr noundef %vs1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs1.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s1, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %4 to i64
  %add.ptr2 = getelementptr i64, ptr %3, i64 %idx.ext1
  %5 = load i64, ptr %add.ptr2, align 8
  store i64 %5, ptr %s2, align 8
  %6 = load i64, ptr %s2, align 8
  %7 = load i64, ptr %s1, align 8
  %8 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 14
  %call = call i64 @fsgnjx64(i64 noundef %6, i64 noundef %7, ptr noundef %fp_status)
  %9 = load ptr, ptr %vd.addr, align 8
  %10 = load i32, ptr %i.addr, align 4
  %idx.ext3 = sext i32 %10 to i64
  %add.ptr4 = getelementptr i64, ptr %9, i64 %idx.ext3
  store i64 %call, ptr %add.ptr4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnjx_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnjx_vf_h(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !387

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnjx_vf_h(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i16
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call zeroext i16 @fsgnjx16(i16 noundef zeroext %3, i16 noundef zeroext %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i16, ptr %6, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnjx_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnjx_vf_w(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !388

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnjx_vf_w(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load i64, ptr %s1.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i32 @fsgnjx32(i32 noundef %3, i32 noundef %conv, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i32, ptr %6, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfsgnjx_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i64, ptr %s1.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfsgnjx_vf_d(ptr noundef %18, i64 noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !389

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfsgnjx_vf_d(ptr noundef %vd, i64 noundef %s1, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load i64, ptr %s1.addr, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 14
  %call = call i64 @fsgnjx64(i64 noundef %3, i64 noundef %4, ptr noundef %fp_status)
  %6 = load ptr, ptr %vd.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %7 to i64
  %add.ptr2 = getelementptr i64, ptr %6, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfeq_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s1, align 2
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i16, ptr %14, i64 %idx.ext8
  %16 = load i16, ptr %add.ptr9, align 2
  store i16 %16, ptr %s2, align 2
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i16, ptr %s2, align 2
  %26 = load i16, ptr %s1, align 2
  %27 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 14
  %call15 = call zeroext i1 @float16_eq_quiet(i16 noundef zeroext %25, i16 noundef zeroext %26, ptr noundef %fp_status)
  %conv16 = zext i1 %call15 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !390

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %30 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %31, %32
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %33, i32 noundef %34, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %35 = load i32, ptr %i, align 4
  %inc25 = add i32 %35, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !391

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float16_eq_quiet(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_compare_quiet(i16 noundef zeroext %0, i16 noundef zeroext %1, ptr noundef %2)
  %cmp = icmp eq i32 %call, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfeq_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s1, align 4
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i32, ptr %14, i64 %idx.ext8
  %16 = load i32, ptr %add.ptr9, align 4
  store i32 %16, ptr %s2, align 4
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i32, ptr %s2, align 4
  %26 = load i32, ptr %s1, align 4
  %27 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 14
  %call15 = call zeroext i1 @float32_eq_quiet(i32 noundef %25, i32 noundef %26, ptr noundef %fp_status)
  %conv16 = zext i1 %call15 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !392

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %30 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %31, %32
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %33, i32 noundef %34, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %35 = load i32, ptr %i, align 4
  %inc25 = add i32 %35, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !393

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float32_eq_quiet(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_compare_quiet(i32 noundef %0, i32 noundef %1, ptr noundef %2)
  %cmp = icmp eq i32 %call, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfeq_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s1, align 8
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i64, ptr %14, i64 %idx.ext8
  %16 = load i64, ptr %add.ptr9, align 8
  store i64 %16, ptr %s2, align 8
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i64, ptr %s2, align 8
  %26 = load i64, ptr %s1, align 8
  %27 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 14
  %call15 = call zeroext i1 @float64_eq_quiet(i64 noundef %25, i64 noundef %26, ptr noundef %fp_status)
  %conv16 = zext i1 %call15 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !394

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %30 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %31, %32
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %33, i32 noundef %34, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %35 = load i32, ptr %i, align 4
  %inc25 = add i32 %35, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !395

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float64_eq_quiet(i64 noundef %a, i64 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float64_compare_quiet(i64 noundef %0, i64 noundef %1, ptr noundef %2)
  %cmp = icmp eq i32 %call, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfeq_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i16
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call14 = call zeroext i1 @float16_eq_quiet(i16 noundef zeroext %22, i16 noundef zeroext %conv13, ptr noundef %fp_status)
  %conv15 = zext i1 %call14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !396

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %27, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %28, %29
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %32 = load i32, ptr %i, align 4
  %inc24 = add i32 %32, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !397

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfeq_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call14 = call zeroext i1 @float32_eq_quiet(i32 noundef %22, i32 noundef %conv13, ptr noundef %fp_status)
  %conv15 = zext i1 %call14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !398

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %27, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %28, %29
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %32 = load i32, ptr %i, align 4
  %inc24 = add i32 %32, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !399

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfeq_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call13 = call zeroext i1 @float64_eq_quiet(i64 noundef %22, i64 noundef %23, ptr noundef %fp_status)
  %conv14 = zext i1 %call13 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv14)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !400

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool16 = icmp ne i32 %27, 0
  br i1 %tobool16, label %if.then17, label %if.end25

if.then17:                                        ; preds = %for.end
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc22, %if.then17
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp19 = icmp ult i32 %28, %29
  br i1 %cmp19, label %for.body21, label %for.end24

for.body21:                                       ; preds = %for.cond18
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc22

for.inc22:                                        ; preds = %for.body21
  %32 = load i32, ptr %i, align 4
  %inc23 = add i32 %32, 1
  store i32 %inc23, ptr %i, align 4
  br label %for.cond18, !llvm.loop !401

for.end24:                                        ; preds = %for.cond18
  br label %if.end25

if.end25:                                         ; preds = %for.end24, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfne_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s1, align 2
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i16, ptr %14, i64 %idx.ext8
  %16 = load i16, ptr %add.ptr9, align 2
  store i16 %16, ptr %s2, align 2
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i16, ptr %s2, align 2
  %26 = load i16, ptr %s1, align 2
  %27 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 14
  %call15 = call zeroext i1 @vmfne16(i16 noundef zeroext %25, i16 noundef zeroext %26, ptr noundef %fp_status)
  %conv16 = zext i1 %call15 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !402

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %30 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %31, %32
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %33, i32 noundef %34, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %35 = load i32, ptr %i, align 4
  %inc25 = add i32 %35, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !403

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @vmfne16(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  %compare = alloca i32, align 4
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_compare_quiet(i16 noundef zeroext %0, i16 noundef zeroext %1, ptr noundef %2)
  store i32 %call, ptr %compare, align 4
  %3 = load i32, ptr %compare, align 4
  %cmp = icmp ne i32 %3, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfne_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s1, align 4
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i32, ptr %14, i64 %idx.ext8
  %16 = load i32, ptr %add.ptr9, align 4
  store i32 %16, ptr %s2, align 4
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i32, ptr %s2, align 4
  %26 = load i32, ptr %s1, align 4
  %27 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 14
  %call15 = call zeroext i1 @vmfne32(i32 noundef %25, i32 noundef %26, ptr noundef %fp_status)
  %conv16 = zext i1 %call15 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !404

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %30 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %31, %32
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %33, i32 noundef %34, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %35 = load i32, ptr %i, align 4
  %inc25 = add i32 %35, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !405

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @vmfne32(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %compare = alloca i32, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_compare_quiet(i32 noundef %0, i32 noundef %1, ptr noundef %2)
  store i32 %call, ptr %compare, align 4
  %3 = load i32, ptr %compare, align 4
  %cmp = icmp ne i32 %3, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfne_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s1, align 8
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i64, ptr %14, i64 %idx.ext8
  %16 = load i64, ptr %add.ptr9, align 8
  store i64 %16, ptr %s2, align 8
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i64, ptr %s2, align 8
  %26 = load i64, ptr %s1, align 8
  %27 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 14
  %call15 = call zeroext i1 @vmfne64(i64 noundef %25, i64 noundef %26, ptr noundef %fp_status)
  %conv16 = zext i1 %call15 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !406

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %30 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %31, %32
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %33, i32 noundef %34, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %35 = load i32, ptr %i, align 4
  %inc25 = add i32 %35, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !407

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @vmfne64(i64 noundef %a, i64 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %compare = alloca i32, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float64_compare_quiet(i64 noundef %0, i64 noundef %1, ptr noundef %2)
  store i32 %call, ptr %compare, align 4
  %3 = load i32, ptr %compare, align 4
  %cmp = icmp ne i32 %3, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfne_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i16
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call14 = call zeroext i1 @vmfne16(i16 noundef zeroext %22, i16 noundef zeroext %conv13, ptr noundef %fp_status)
  %conv15 = zext i1 %call14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !408

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %27, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %28, %29
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %32 = load i32, ptr %i, align 4
  %inc24 = add i32 %32, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !409

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfne_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call14 = call zeroext i1 @vmfne32(i32 noundef %22, i32 noundef %conv13, ptr noundef %fp_status)
  %conv15 = zext i1 %call14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !410

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %27, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %28, %29
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %32 = load i32, ptr %i, align 4
  %inc24 = add i32 %32, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !411

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfne_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call13 = call zeroext i1 @vmfne64(i64 noundef %22, i64 noundef %23, ptr noundef %fp_status)
  %conv14 = zext i1 %call13 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv14)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !412

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool16 = icmp ne i32 %27, 0
  br i1 %tobool16, label %if.then17, label %if.end25

if.then17:                                        ; preds = %for.end
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc22, %if.then17
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp19 = icmp ult i32 %28, %29
  br i1 %cmp19, label %for.body21, label %for.end24

for.body21:                                       ; preds = %for.cond18
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc22

for.inc22:                                        ; preds = %for.body21
  %32 = load i32, ptr %i, align 4
  %inc23 = add i32 %32, 1
  store i32 %inc23, ptr %i, align 4
  br label %for.cond18, !llvm.loop !413

for.end24:                                        ; preds = %for.cond18
  br label %if.end25

if.end25:                                         ; preds = %for.end24, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmflt_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s1, align 2
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i16, ptr %14, i64 %idx.ext8
  %16 = load i16, ptr %add.ptr9, align 2
  store i16 %16, ptr %s2, align 2
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i16, ptr %s2, align 2
  %26 = load i16, ptr %s1, align 2
  %27 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 14
  %call15 = call zeroext i1 @float16_lt(i16 noundef zeroext %25, i16 noundef zeroext %26, ptr noundef %fp_status)
  %conv16 = zext i1 %call15 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !414

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %30 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %31, %32
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %33, i32 noundef %34, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %35 = load i32, ptr %i, align 4
  %inc25 = add i32 %35, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !415

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float16_lt(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_compare(i16 noundef zeroext %0, i16 noundef zeroext %1, ptr noundef %2)
  %cmp = icmp slt i32 %call, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmflt_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s1, align 4
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i32, ptr %14, i64 %idx.ext8
  %16 = load i32, ptr %add.ptr9, align 4
  store i32 %16, ptr %s2, align 4
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i32, ptr %s2, align 4
  %26 = load i32, ptr %s1, align 4
  %27 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 14
  %call15 = call zeroext i1 @float32_lt(i32 noundef %25, i32 noundef %26, ptr noundef %fp_status)
  %conv16 = zext i1 %call15 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !416

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %30 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %31, %32
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %33, i32 noundef %34, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %35 = load i32, ptr %i, align 4
  %inc25 = add i32 %35, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !417

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float32_lt(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_compare(i32 noundef %0, i32 noundef %1, ptr noundef %2)
  %cmp = icmp slt i32 %call, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmflt_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s1, align 8
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i64, ptr %14, i64 %idx.ext8
  %16 = load i64, ptr %add.ptr9, align 8
  store i64 %16, ptr %s2, align 8
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i64, ptr %s2, align 8
  %26 = load i64, ptr %s1, align 8
  %27 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 14
  %call15 = call zeroext i1 @float64_lt(i64 noundef %25, i64 noundef %26, ptr noundef %fp_status)
  %conv16 = zext i1 %call15 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !418

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %30 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %31, %32
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %33, i32 noundef %34, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %35 = load i32, ptr %i, align 4
  %inc25 = add i32 %35, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !419

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float64_lt(i64 noundef %a, i64 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float64_compare(i64 noundef %0, i64 noundef %1, ptr noundef %2)
  %cmp = icmp slt i32 %call, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmflt_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i16
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call14 = call zeroext i1 @float16_lt(i16 noundef zeroext %22, i16 noundef zeroext %conv13, ptr noundef %fp_status)
  %conv15 = zext i1 %call14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !420

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %27, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %28, %29
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %32 = load i32, ptr %i, align 4
  %inc24 = add i32 %32, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !421

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmflt_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call14 = call zeroext i1 @float32_lt(i32 noundef %22, i32 noundef %conv13, ptr noundef %fp_status)
  %conv15 = zext i1 %call14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !422

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %27, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %28, %29
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %32 = load i32, ptr %i, align 4
  %inc24 = add i32 %32, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !423

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmflt_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call13 = call zeroext i1 @float64_lt(i64 noundef %22, i64 noundef %23, ptr noundef %fp_status)
  %conv14 = zext i1 %call13 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv14)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !424

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool16 = icmp ne i32 %27, 0
  br i1 %tobool16, label %if.then17, label %if.end25

if.then17:                                        ; preds = %for.end
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc22, %if.then17
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp19 = icmp ult i32 %28, %29
  br i1 %cmp19, label %for.body21, label %for.end24

for.body21:                                       ; preds = %for.cond18
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc22

for.inc22:                                        ; preds = %for.body21
  %32 = load i32, ptr %i, align 4
  %inc23 = add i32 %32, 1
  store i32 %inc23, ptr %i, align 4
  br label %for.cond18, !llvm.loop !425

for.end24:                                        ; preds = %for.cond18
  br label %if.end25

if.end25:                                         ; preds = %for.end24, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfle_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s1, align 2
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i16, ptr %14, i64 %idx.ext8
  %16 = load i16, ptr %add.ptr9, align 2
  store i16 %16, ptr %s2, align 2
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i16, ptr %s2, align 2
  %26 = load i16, ptr %s1, align 2
  %27 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 14
  %call15 = call zeroext i1 @float16_le(i16 noundef zeroext %25, i16 noundef zeroext %26, ptr noundef %fp_status)
  %conv16 = zext i1 %call15 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !426

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %30 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %31, %32
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %33, i32 noundef %34, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %35 = load i32, ptr %i, align 4
  %inc25 = add i32 %35, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !427

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float16_le(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_compare(i16 noundef zeroext %0, i16 noundef zeroext %1, ptr noundef %2)
  %cmp = icmp sle i32 %call, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfle_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s1, align 4
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i32, ptr %14, i64 %idx.ext8
  %16 = load i32, ptr %add.ptr9, align 4
  store i32 %16, ptr %s2, align 4
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i32, ptr %s2, align 4
  %26 = load i32, ptr %s1, align 4
  %27 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 14
  %call15 = call zeroext i1 @float32_le(i32 noundef %25, i32 noundef %26, ptr noundef %fp_status)
  %conv16 = zext i1 %call15 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !428

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %30 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %31, %32
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %33, i32 noundef %34, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %35 = load i32, ptr %i, align 4
  %inc25 = add i32 %35, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !429

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float32_le(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_compare(i32 noundef %0, i32 noundef %1, ptr noundef %2)
  %cmp = icmp sle i32 %call, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfle_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs1.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s1, align 8
  %14 = load ptr, ptr %vs2.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %15 to i64
  %add.ptr9 = getelementptr i64, ptr %14, i64 %idx.ext8
  %16 = load i64, ptr %add.ptr9, align 8
  store i64 %16, ptr %s2, align 8
  %17 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %18, i32 noundef %19)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %20 = load i32, ptr %vma, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.then
  %21 = load ptr, ptr %vd.addr, align 8
  %22 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %21, i32 noundef %22, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then
  br label %for.inc

if.end14:                                         ; preds = %land.lhs.true, %for.body
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %25 = load i64, ptr %s2, align 8
  %26 = load i64, ptr %s1, align 8
  %27 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 14
  %call15 = call zeroext i1 @float64_le(i64 noundef %25, i64 noundef %26, ptr noundef %fp_status)
  %conv16 = zext i1 %call15 to i8
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext %conv16)
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.end
  %28 = load i32, ptr %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !430

for.end:                                          ; preds = %for.cond
  %29 = load ptr, ptr %env.addr, align 8
  %vstart17 = getelementptr inbounds %struct.CPUArchState, ptr %29, i32 0, i32 6
  store i64 0, ptr %vstart17, align 8
  %30 = load i32, ptr %vta_all_1s, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %for.end
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc24, %if.then19
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %total_elems, align 4
  %cmp21 = icmp ult i32 %31, %32
  br i1 %cmp21, label %for.body23, label %for.end26

for.body23:                                       ; preds = %for.cond20
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %33, i32 noundef %34, i8 noundef zeroext 1)
  br label %for.inc24

for.inc24:                                        ; preds = %for.body23
  %35 = load i32, ptr %i, align 4
  %inc25 = add i32 %35, 1
  store i32 %inc25, ptr %i, align 4
  br label %for.cond20, !llvm.loop !431

for.end26:                                        ; preds = %for.cond20
  br label %if.end27

if.end27:                                         ; preds = %for.end26, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float64_le(i64 noundef %a, i64 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float64_compare(i64 noundef %0, i64 noundef %1, ptr noundef %2)
  %cmp = icmp sle i32 %call, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfle_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i16
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call14 = call zeroext i1 @float16_le(i16 noundef zeroext %22, i16 noundef zeroext %conv13, ptr noundef %fp_status)
  %conv15 = zext i1 %call14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !432

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %27, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %28, %29
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %32 = load i32, ptr %i, align 4
  %inc24 = add i32 %32, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !433

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfle_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call14 = call zeroext i1 @float32_le(i32 noundef %22, i32 noundef %conv13, ptr noundef %fp_status)
  %conv15 = zext i1 %call14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !434

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %27, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %28, %29
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %32 = load i32, ptr %i, align 4
  %inc24 = add i32 %32, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !435

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfle_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call13 = call zeroext i1 @float64_le(i64 noundef %22, i64 noundef %23, ptr noundef %fp_status)
  %conv14 = zext i1 %call13 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv14)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !436

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool16 = icmp ne i32 %27, 0
  br i1 %tobool16, label %if.then17, label %if.end25

if.then17:                                        ; preds = %for.end
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc22, %if.then17
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp19 = icmp ult i32 %28, %29
  br i1 %cmp19, label %for.body21, label %for.end24

for.body21:                                       ; preds = %for.cond18
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc22

for.inc22:                                        ; preds = %for.body21
  %32 = load i32, ptr %i, align 4
  %inc23 = add i32 %32, 1
  store i32 %inc23, ptr %i, align 4
  br label %for.cond18, !llvm.loop !437

for.end24:                                        ; preds = %for.cond18
  br label %if.end25

if.end25:                                         ; preds = %for.end24, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfgt_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i16
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call14 = call zeroext i1 @vmfgt16(i16 noundef zeroext %22, i16 noundef zeroext %conv13, ptr noundef %fp_status)
  %conv15 = zext i1 %call14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !438

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %27, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %28, %29
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %32 = load i32, ptr %i, align 4
  %inc24 = add i32 %32, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !439

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @vmfgt16(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  %compare = alloca i32, align 4
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_compare(i16 noundef zeroext %0, i16 noundef zeroext %1, ptr noundef %2)
  store i32 %call, ptr %compare, align 4
  %3 = load i32, ptr %compare, align 4
  %cmp = icmp eq i32 %3, 1
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfgt_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call14 = call zeroext i1 @vmfgt32(i32 noundef %22, i32 noundef %conv13, ptr noundef %fp_status)
  %conv15 = zext i1 %call14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !440

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %27, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %28, %29
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %32 = load i32, ptr %i, align 4
  %inc24 = add i32 %32, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !441

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @vmfgt32(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %compare = alloca i32, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_compare(i32 noundef %0, i32 noundef %1, ptr noundef %2)
  store i32 %call, ptr %compare, align 4
  %3 = load i32, ptr %compare, align 4
  %cmp = icmp eq i32 %3, 1
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfgt_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call13 = call zeroext i1 @vmfgt64(i64 noundef %22, i64 noundef %23, ptr noundef %fp_status)
  %conv14 = zext i1 %call13 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv14)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !442

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool16 = icmp ne i32 %27, 0
  br i1 %tobool16, label %if.then17, label %if.end25

if.then17:                                        ; preds = %for.end
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc22, %if.then17
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp19 = icmp ult i32 %28, %29
  br i1 %cmp19, label %for.body21, label %for.end24

for.body21:                                       ; preds = %for.cond18
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc22

for.inc22:                                        ; preds = %for.body21
  %32 = load i32, ptr %i, align 4
  %inc23 = add i32 %32, 1
  store i32 %inc23, ptr %i, align 4
  br label %for.cond18, !llvm.loop !443

for.end24:                                        ; preds = %for.cond18
  br label %if.end25

if.end25:                                         ; preds = %for.end24, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @vmfgt64(i64 noundef %a, i64 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %compare = alloca i32, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float64_compare(i64 noundef %0, i64 noundef %1, ptr noundef %2)
  store i32 %call, ptr %compare, align 4
  %3 = load i32, ptr %compare, align 4
  %cmp = icmp eq i32 %3, 1
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfge_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i16, ptr %s2, align 2
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i16
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call14 = call zeroext i1 @vmfge16(i16 noundef zeroext %22, i16 noundef zeroext %conv13, ptr noundef %fp_status)
  %conv15 = zext i1 %call14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !444

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %27, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %28, %29
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %32 = load i32, ptr %i, align 4
  %inc24 = add i32 %32, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !445

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @vmfge16(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  %compare = alloca i32, align 4
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_compare(i16 noundef zeroext %0, i16 noundef zeroext %1, ptr noundef %2)
  store i32 %call, ptr %compare, align 4
  %3 = load i32, ptr %compare, align 4
  %cmp = icmp eq i32 %3, 1
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %4 = load i32, ptr %compare, align 4
  %cmp1 = icmp eq i32 %4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %5 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %5
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfge_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %s2, align 4
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call14 = call zeroext i1 @vmfge32(i32 noundef %22, i32 noundef %conv13, ptr noundef %fp_status)
  %conv15 = zext i1 %call14 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv15)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !446

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool17 = icmp ne i32 %27, 0
  br i1 %tobool17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %for.end
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc23, %if.then18
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp20 = icmp ult i32 %28, %29
  br i1 %cmp20, label %for.body22, label %for.end25

for.body22:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc23

for.inc23:                                        ; preds = %for.body22
  %32 = load i32, ptr %i, align 4
  %inc24 = add i32 %32, 1
  store i32 %inc24, ptr %i, align 4
  br label %for.cond19, !llvm.loop !447

for.end25:                                        ; preds = %for.cond19
  br label %if.end26

if.end26:                                         ; preds = %for.end25, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @vmfge32(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %compare = alloca i32, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_compare(i32 noundef %0, i32 noundef %1, ptr noundef %2)
  store i32 %call, ptr %compare, align 4
  %3 = load i32, ptr %compare, align 4
  %cmp = icmp eq i32 %3, 1
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %4 = load i32, ptr %compare, align 4
  %cmp1 = icmp eq i32 %4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %5 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %5
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmfge_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %17, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load i64, ptr %s2, align 8
  %23 = load i64, ptr %s1.addr, align 8
  %24 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 14
  %call13 = call zeroext i1 @vmfge64(i64 noundef %22, i64 noundef %23, ptr noundef %fp_status)
  %conv14 = zext i1 %call13 to i8
  call void @vext_set_elem_mask(ptr noundef %20, i32 noundef %21, i8 noundef zeroext %conv14)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.end
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !448

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %26, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %27 = load i32, ptr %vta_all_1s, align 4
  %tobool16 = icmp ne i32 %27, 0
  br i1 %tobool16, label %if.then17, label %if.end25

if.then17:                                        ; preds = %for.end
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc22, %if.then17
  %28 = load i32, ptr %i, align 4
  %29 = load i32, ptr %total_elems, align 4
  %cmp19 = icmp ult i32 %28, %29
  br i1 %cmp19, label %for.body21, label %for.end24

for.body21:                                       ; preds = %for.cond18
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %for.inc22

for.inc22:                                        ; preds = %for.body21
  %32 = load i32, ptr %i, align 4
  %inc23 = add i32 %32, 1
  store i32 %inc23, ptr %i, align 4
  br label %for.cond18, !llvm.loop !449

for.end24:                                        ; preds = %for.cond18
  br label %if.end25

if.end25:                                         ; preds = %for.end24, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @vmfge64(i64 noundef %a, i64 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %compare = alloca i32, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float64_compare(i64 noundef %0, i64 noundef %1, ptr noundef %2)
  store i32 %call, ptr %compare, align 4
  %3 = load i32, ptr %compare, align 4
  %cmp = icmp eq i32 %3, 1
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %4 = load i32, ptr %compare, align 4
  %cmp1 = icmp eq i32 %4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %5 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %5
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @fclass_h(i64 noundef %frs1) #0 {
entry:
  %retval = alloca i64, align 8
  %frs1.addr = alloca i64, align 8
  %f = alloca i16, align 2
  %sign = alloca i8, align 1
  %s = alloca %struct.float_status, align 2
  store i64 %frs1, ptr %frs1.addr, align 8
  %0 = load i64, ptr %frs1.addr, align 8
  %conv = trunc i64 %0 to i16
  store i16 %conv, ptr %f, align 2
  %1 = load i16, ptr %f, align 2
  %call = call zeroext i1 @float16_is_neg(i16 noundef zeroext %1)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %sign, align 1
  %2 = load i16, ptr %f, align 2
  %call1 = call zeroext i1 @float16_is_infinity(i16 noundef zeroext %2)
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i8, ptr %sign, align 1
  %tobool = trunc i8 %3 to i1
  %cond = select i1 %tobool, i32 1, i32 128
  %conv3 = sext i32 %cond to i64
  store i64 %conv3, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %4 = load i16, ptr %f, align 2
  %call4 = call zeroext i1 @float16_is_zero(i16 noundef zeroext %4)
  br i1 %call4, label %if.then5, label %if.else10

if.then5:                                         ; preds = %if.else
  %5 = load i8, ptr %sign, align 1
  %tobool6 = trunc i8 %5 to i1
  %cond8 = select i1 %tobool6, i32 8, i32 16
  %conv9 = sext i32 %cond8 to i64
  store i64 %conv9, ptr %retval, align 8
  br label %return

if.else10:                                        ; preds = %if.else
  %6 = load i16, ptr %f, align 2
  %call11 = call zeroext i1 @float16_is_zero_or_denormal(i16 noundef zeroext %6)
  br i1 %call11, label %if.then12, label %if.else17

if.then12:                                        ; preds = %if.else10
  %7 = load i8, ptr %sign, align 1
  %tobool13 = trunc i8 %7 to i1
  %cond15 = select i1 %tobool13, i32 4, i32 32
  %conv16 = sext i32 %cond15 to i64
  store i64 %conv16, ptr %retval, align 8
  br label %return

if.else17:                                        ; preds = %if.else10
  %8 = load i16, ptr %f, align 2
  %call18 = call zeroext i1 @float16_is_any_nan(i16 noundef zeroext %8)
  br i1 %call18, label %if.then19, label %if.else24

if.then19:                                        ; preds = %if.else17
  call void @llvm.memset.p0.i64(ptr align 2 %s, i8 0, i64 14, i1 false)
  %9 = load i16, ptr %f, align 2
  %call20 = call zeroext i1 @float16_is_quiet_nan(i16 noundef zeroext %9, ptr noundef %s)
  %cond22 = select i1 %call20, i32 512, i32 256
  %conv23 = sext i32 %cond22 to i64
  store i64 %conv23, ptr %retval, align 8
  br label %return

if.else24:                                        ; preds = %if.else17
  %10 = load i8, ptr %sign, align 1
  %tobool25 = trunc i8 %10 to i1
  %cond27 = select i1 %tobool25, i32 2, i32 64
  %conv28 = sext i32 %cond27 to i64
  store i64 %conv28, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else24, %if.then19, %if.then12, %if.then5, %if.then
  %11 = load i64, ptr %retval, align 8
  ret i64 %11
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float16_is_neg(i16 noundef zeroext %a) #0 {
entry:
  %a.addr = alloca i16, align 2
  store i16 %a, ptr %a.addr, align 2
  %0 = load i16, ptr %a.addr, align 2
  %conv = zext i16 %0 to i32
  %shr = ashr i32 %conv, 15
  %tobool = icmp ne i32 %shr, 0
  ret i1 %tobool
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float16_is_infinity(i16 noundef zeroext %a) #0 {
entry:
  %a.addr = alloca i16, align 2
  store i16 %a, ptr %a.addr, align 2
  %0 = load i16, ptr %a.addr, align 2
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 32767
  %cmp = icmp eq i32 %and, 31744
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float16_is_zero(i16 noundef zeroext %a) #0 {
entry:
  %a.addr = alloca i16, align 2
  store i16 %a, ptr %a.addr, align 2
  %0 = load i16, ptr %a.addr, align 2
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 32767
  %cmp = icmp eq i32 %and, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float16_is_zero_or_denormal(i16 noundef zeroext %a) #0 {
entry:
  %a.addr = alloca i16, align 2
  store i16 %a, ptr %a.addr, align 2
  %0 = load i16, ptr %a.addr, align 2
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 31744
  %cmp = icmp eq i32 %and, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float16_is_any_nan(i16 noundef zeroext %a) #0 {
entry:
  %a.addr = alloca i16, align 2
  store i16 %a, ptr %a.addr, align 2
  %0 = load i16, ptr %a.addr, align 2
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, -32769
  %cmp = icmp sgt i32 %and, 31744
  ret i1 %cmp
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #3

declare zeroext i1 @float16_is_quiet_nan(i16 noundef zeroext, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @fclass_s(i64 noundef %frs1) #0 {
entry:
  %retval = alloca i64, align 8
  %frs1.addr = alloca i64, align 8
  %f = alloca i32, align 4
  %sign = alloca i8, align 1
  %s = alloca %struct.float_status, align 2
  store i64 %frs1, ptr %frs1.addr, align 8
  %0 = load i64, ptr %frs1.addr, align 8
  %conv = trunc i64 %0 to i32
  store i32 %conv, ptr %f, align 4
  %1 = load i32, ptr %f, align 4
  %call = call zeroext i1 @float32_is_neg(i32 noundef %1)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %sign, align 1
  %2 = load i32, ptr %f, align 4
  %call1 = call zeroext i1 @float32_is_infinity(i32 noundef %2)
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i8, ptr %sign, align 1
  %tobool = trunc i8 %3 to i1
  %cond = select i1 %tobool, i32 1, i32 128
  %conv3 = sext i32 %cond to i64
  store i64 %conv3, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %4 = load i32, ptr %f, align 4
  %call4 = call zeroext i1 @float32_is_zero(i32 noundef %4)
  br i1 %call4, label %if.then5, label %if.else10

if.then5:                                         ; preds = %if.else
  %5 = load i8, ptr %sign, align 1
  %tobool6 = trunc i8 %5 to i1
  %cond8 = select i1 %tobool6, i32 8, i32 16
  %conv9 = sext i32 %cond8 to i64
  store i64 %conv9, ptr %retval, align 8
  br label %return

if.else10:                                        ; preds = %if.else
  %6 = load i32, ptr %f, align 4
  %call11 = call zeroext i1 @float32_is_zero_or_denormal(i32 noundef %6)
  br i1 %call11, label %if.then12, label %if.else17

if.then12:                                        ; preds = %if.else10
  %7 = load i8, ptr %sign, align 1
  %tobool13 = trunc i8 %7 to i1
  %cond15 = select i1 %tobool13, i32 4, i32 32
  %conv16 = sext i32 %cond15 to i64
  store i64 %conv16, ptr %retval, align 8
  br label %return

if.else17:                                        ; preds = %if.else10
  %8 = load i32, ptr %f, align 4
  %call18 = call zeroext i1 @float32_is_any_nan(i32 noundef %8)
  br i1 %call18, label %if.then19, label %if.else24

if.then19:                                        ; preds = %if.else17
  call void @llvm.memset.p0.i64(ptr align 2 %s, i8 0, i64 14, i1 false)
  %9 = load i32, ptr %f, align 4
  %call20 = call zeroext i1 @float32_is_quiet_nan(i32 noundef %9, ptr noundef %s)
  %cond22 = select i1 %call20, i32 512, i32 256
  %conv23 = sext i32 %cond22 to i64
  store i64 %conv23, ptr %retval, align 8
  br label %return

if.else24:                                        ; preds = %if.else17
  %10 = load i8, ptr %sign, align 1
  %tobool25 = trunc i8 %10 to i1
  %cond27 = select i1 %tobool25, i32 2, i32 64
  %conv28 = sext i32 %cond27 to i64
  store i64 %conv28, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else24, %if.then19, %if.then12, %if.then5, %if.then
  %11 = load i64, ptr %retval, align 8
  ret i64 %11
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float32_is_neg(i32 noundef %a) #0 {
entry:
  %a.addr = alloca i32, align 4
  store i32 %a, ptr %a.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %shr = lshr i32 %0, 31
  %tobool = icmp ne i32 %shr, 0
  ret i1 %tobool
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float32_is_infinity(i32 noundef %a) #0 {
entry:
  %a.addr = alloca i32, align 4
  store i32 %a, ptr %a.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %and = and i32 %0, 2147483647
  %cmp = icmp eq i32 %and, 2139095040
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float32_is_zero(i32 noundef %a) #0 {
entry:
  %a.addr = alloca i32, align 4
  store i32 %a, ptr %a.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %and = and i32 %0, 2147483647
  %cmp = icmp eq i32 %and, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float32_is_zero_or_denormal(i32 noundef %a) #0 {
entry:
  %a.addr = alloca i32, align 4
  store i32 %a, ptr %a.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %and = and i32 %0, 2139095040
  %cmp = icmp eq i32 %and, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float32_is_any_nan(i32 noundef %a) #0 {
entry:
  %a.addr = alloca i32, align 4
  store i32 %a, ptr %a.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %and = and i32 %0, 2147483647
  %conv = zext i32 %and to i64
  %cmp = icmp ugt i64 %conv, 2139095040
  ret i1 %cmp
}

declare zeroext i1 @float32_is_quiet_nan(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @fclass_d(i64 noundef %frs1) #0 {
entry:
  %retval = alloca i64, align 8
  %frs1.addr = alloca i64, align 8
  %f = alloca i64, align 8
  %sign = alloca i8, align 1
  %s = alloca %struct.float_status, align 2
  store i64 %frs1, ptr %frs1.addr, align 8
  %0 = load i64, ptr %frs1.addr, align 8
  store i64 %0, ptr %f, align 8
  %1 = load i64, ptr %f, align 8
  %call = call zeroext i1 @float64_is_neg(i64 noundef %1)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %sign, align 1
  %2 = load i64, ptr %f, align 8
  %call1 = call zeroext i1 @float64_is_infinity(i64 noundef %2)
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i8, ptr %sign, align 1
  %tobool = trunc i8 %3 to i1
  %cond = select i1 %tobool, i32 1, i32 128
  %conv = sext i32 %cond to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %4 = load i64, ptr %f, align 8
  %call2 = call zeroext i1 @float64_is_zero(i64 noundef %4)
  br i1 %call2, label %if.then3, label %if.else8

if.then3:                                         ; preds = %if.else
  %5 = load i8, ptr %sign, align 1
  %tobool4 = trunc i8 %5 to i1
  %cond6 = select i1 %tobool4, i32 8, i32 16
  %conv7 = sext i32 %cond6 to i64
  store i64 %conv7, ptr %retval, align 8
  br label %return

if.else8:                                         ; preds = %if.else
  %6 = load i64, ptr %f, align 8
  %call9 = call zeroext i1 @float64_is_zero_or_denormal(i64 noundef %6)
  br i1 %call9, label %if.then10, label %if.else15

if.then10:                                        ; preds = %if.else8
  %7 = load i8, ptr %sign, align 1
  %tobool11 = trunc i8 %7 to i1
  %cond13 = select i1 %tobool11, i32 4, i32 32
  %conv14 = sext i32 %cond13 to i64
  store i64 %conv14, ptr %retval, align 8
  br label %return

if.else15:                                        ; preds = %if.else8
  %8 = load i64, ptr %f, align 8
  %call16 = call zeroext i1 @float64_is_any_nan(i64 noundef %8)
  br i1 %call16, label %if.then17, label %if.else22

if.then17:                                        ; preds = %if.else15
  call void @llvm.memset.p0.i64(ptr align 2 %s, i8 0, i64 14, i1 false)
  %9 = load i64, ptr %f, align 8
  %call18 = call zeroext i1 @float64_is_quiet_nan(i64 noundef %9, ptr noundef %s)
  %cond20 = select i1 %call18, i32 512, i32 256
  %conv21 = sext i32 %cond20 to i64
  store i64 %conv21, ptr %retval, align 8
  br label %return

if.else22:                                        ; preds = %if.else15
  %10 = load i8, ptr %sign, align 1
  %tobool23 = trunc i8 %10 to i1
  %cond25 = select i1 %tobool23, i32 2, i32 64
  %conv26 = sext i32 %cond25 to i64
  store i64 %conv26, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else22, %if.then17, %if.then10, %if.then3, %if.then
  %11 = load i64, ptr %retval, align 8
  ret i64 %11
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float64_is_neg(i64 noundef %a) #0 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, ptr %a.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %shr = lshr i64 %0, 63
  %tobool = icmp ne i64 %shr, 0
  ret i1 %tobool
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float64_is_infinity(i64 noundef %a) #0 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, ptr %a.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %and = and i64 %0, 9223372036854775807
  %cmp = icmp eq i64 %and, 9218868437227405312
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float64_is_zero(i64 noundef %a) #0 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, ptr %a.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %and = and i64 %0, 9223372036854775807
  %cmp = icmp eq i64 %and, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float64_is_zero_or_denormal(i64 noundef %a) #0 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, ptr %a.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %and = and i64 %0, 9218868437227405312
  %cmp = icmp eq i64 %and, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float64_is_any_nan(i64 noundef %a) #0 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, ptr %a.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %and = and i64 %0, 9223372036854775807
  %cmp = icmp ugt i64 %and, 9218868437227405312
  ret i1 %cmp
}

declare zeroext i1 @float64_is_quiet_nan(i64 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfclass_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 2
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs2.addr, align 8
  %20 = load i32, ptr %i, align 4
  call void @do_vfclass_v_h(ptr noundef %18, ptr noundef %19, i32 noundef %20)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !450

for.end:                                          ; preds = %for.cond
  %22 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %25, 2
  %26 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %26, 2
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfclass_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %conv = zext i16 %3 to i64
  %call = call i64 @fclass_h(i64 noundef %conv)
  %conv1 = trunc i64 %call to i16
  %4 = load ptr, ptr %vd.addr, align 8
  %5 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %5 to i64
  %add.ptr3 = getelementptr i16, ptr %4, i64 %idx.ext2
  store i16 %conv1, ptr %add.ptr3, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfclass_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 4
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs2.addr, align 8
  %20 = load i32, ptr %i, align 4
  call void @do_vfclass_v_w(ptr noundef %18, ptr noundef %19, i32 noundef %20)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !451

for.end:                                          ; preds = %for.cond
  %22 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %25, 4
  %26 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %26, 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfclass_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %conv = zext i32 %3 to i64
  %call = call i64 @fclass_s(i64 noundef %conv)
  %conv1 = trunc i64 %call to i32
  %4 = load ptr, ptr %vd.addr, align 8
  %5 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %5 to i64
  %add.ptr3 = getelementptr i32, ptr %4, i64 %idx.ext2
  store i32 %conv1, ptr %add.ptr3, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfclass_v_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i32, ptr %vma, align 4
  %16 = load i32, ptr %i, align 4
  %mul = mul i32 %16, 8
  %17 = load i32, ptr %i, align 4
  %add = add i32 %17, 1
  %mul9 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %14, i32 noundef %15, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load ptr, ptr %vs2.addr, align 8
  %20 = load i32, ptr %i, align 4
  call void @do_vfclass_v_d(ptr noundef %18, ptr noundef %19, i32 noundef %20)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !452

for.end:                                          ; preds = %for.cond
  %22 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %vl, align 4
  %mul11 = mul i32 %25, 8
  %26 = load i32, ptr %total_elems, align 4
  %mul12 = mul i32 %26, 8
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfclass_v_d(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %call = call i64 @fclass_d(i64 noundef %3)
  %4 = load ptr, ptr %vd.addr, align 8
  %5 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %5 to i64
  %add.ptr2 = getelementptr i64, ptr %4, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmerge_vfm_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv4 = trunc i64 %8 to i32
  store i32 %conv4, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  %17 = load i16, ptr %s2, align 2
  %conv8 = sext i16 %17 to i64
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.body
  %18 = load i64, ptr %s1.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %conv8, %cond.true ], [ %18, %cond.false ]
  %conv9 = trunc i64 %cond to i16
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %20 to i64
  %add.ptr11 = getelementptr i16, ptr %19, i64 %idx.ext10
  store i16 %conv9, ptr %add.ptr11, align 2
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !453

for.end:                                          ; preds = %for.cond
  %22 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %vl, align 4
  %26 = load i32, ptr %esz, align 4
  %mul = mul i32 %25, %26
  %27 = load i32, ptr %total_elems, align 4
  %28 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %27, %28
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %mul, i32 noundef %mul13)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmerge_vfm_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv4 = trunc i64 %8 to i32
  store i32 %conv4, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  %17 = load i32, ptr %s2, align 4
  %conv8 = sext i32 %17 to i64
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.body
  %18 = load i64, ptr %s1.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %conv8, %cond.true ], [ %18, %cond.false ]
  %conv9 = trunc i64 %cond to i32
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load i32, ptr %i, align 4
  %idx.ext10 = zext i32 %20 to i64
  %add.ptr11 = getelementptr i32, ptr %19, i64 %idx.ext10
  store i32 %conv9, ptr %add.ptr11, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !454

for.end:                                          ; preds = %for.cond
  %22 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %vl, align 4
  %26 = load i32, ptr %esz, align 4
  %mul = mul i32 %25, %26
  %27 = load i32, ptr %total_elems, align 4
  %28 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %27, %28
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %mul, i32 noundef %mul13)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfmerge_vfm_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv4 = trunc i64 %8 to i32
  store i32 %conv4, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  %17 = load i64, ptr %s2, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.body
  %18 = load i64, ptr %s1.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %17, %cond.true ], [ %18, %cond.false ]
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load i32, ptr %i, align 4
  %idx.ext8 = zext i32 %20 to i64
  %add.ptr9 = getelementptr i64, ptr %19, i64 %idx.ext8
  store i64 %cond, ptr %add.ptr9, align 8
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !455

for.end:                                          ; preds = %for.cond
  %22 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %vl, align 4
  %26 = load i32, ptr %esz, align 4
  %mul = mul i32 %25, %26
  %27 = load i32, ptr %total_elems, align 4
  %28 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %27, %28
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %mul, i32 noundef %mul11)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfcvt_xu_f_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfcvt_xu_f_v_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !456

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfcvt_xu_f_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @float16_to_uint16(i16 noundef zeroext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfcvt_xu_f_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfcvt_xu_f_v_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !457

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfcvt_xu_f_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @float32_to_uint32(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfcvt_xu_f_v_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 8
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfcvt_xu_f_v_d(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !458

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfcvt_xu_f_v_d(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i64 @float64_to_uint64(i64 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfcvt_x_f_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfcvt_x_f_v_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !459

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfcvt_x_f_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call signext i16 @float16_to_int16(i16 noundef zeroext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfcvt_x_f_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfcvt_x_f_v_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !460

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfcvt_x_f_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @float32_to_int32(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfcvt_x_f_v_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 8
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfcvt_x_f_v_d(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !461

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfcvt_x_f_v_d(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i64 @float64_to_int64(i64 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfcvt_f_xu_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfcvt_f_xu_v_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !462

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfcvt_f_xu_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @uint16_to_float16(i16 noundef zeroext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfcvt_f_xu_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfcvt_f_xu_v_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !463

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfcvt_f_xu_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @uint32_to_float32(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfcvt_f_xu_v_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 8
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfcvt_f_xu_v_d(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !464

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfcvt_f_xu_v_d(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i64 @uint64_to_float64(i64 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfcvt_f_x_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfcvt_f_x_v_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !465

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfcvt_f_x_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @int16_to_float16(i16 noundef signext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfcvt_f_x_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfcvt_f_x_v_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !466

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfcvt_f_x_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @int32_to_float32(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfcvt_f_x_v_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 8
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfcvt_f_x_v_d(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !467

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfcvt_f_x_v_d(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i64 @int64_to_float64(i64 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvt_xu_f_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvt_xu_f_v_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !468

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvt_xu_f_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @float16_to_uint32(i16 noundef zeroext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvt_xu_f_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 8
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvt_xu_f_v_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !469

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvt_xu_f_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i64 @float32_to_uint64(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvt_x_f_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvt_x_f_v_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !470

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvt_x_f_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @float16_to_int32(i16 noundef zeroext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvt_x_f_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 8
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvt_x_f_v_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !471

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvt_x_f_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i64 @float32_to_int64(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvt_f_xu_v_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvt_f_xu_v_b(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !472

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvt_f_xu_v_b(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @uint8_to_float16(i8 noundef zeroext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvt_f_xu_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvt_f_xu_v_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !473

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvt_f_xu_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @uint16_to_float32(i16 noundef zeroext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvt_f_xu_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 8
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvt_f_xu_v_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !474

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvt_f_xu_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i64 @uint32_to_float64(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvt_f_x_v_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvt_f_x_v_b(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !475

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvt_f_x_v_b(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i8, ptr %0, i64 %idx.ext
  %2 = load i8, ptr %add.ptr, align 1
  store i8 %2, ptr %s2, align 1
  %3 = load i8, ptr %s2, align 1
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @int8_to_float16(i8 noundef signext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvt_f_x_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvt_f_x_v_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !476

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvt_f_x_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @int16_to_float32(i16 noundef signext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvt_f_x_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 8
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvt_f_x_v_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !477

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvt_f_x_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i64 @int32_to_float64(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvt_f_f_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvt_f_f_v_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !478

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvt_f_f_v_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @vfwcvtffv16(i16 noundef zeroext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvt_f_f_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 8)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 8
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 8
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvt_f_f_v_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !479

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 8
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 8
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvt_f_f_v_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i64 @float32_to_float64(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i64, ptr %5, i64 %idx.ext1
  store i64 %call, ptr %add.ptr2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwcvtbf16_f_f_v(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfwcvtbf16_f_f_v(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !480

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfwcvtbf16_f_f_v(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  store i16 %2, ptr %s2, align 2
  %3 = load i16, ptr %s2, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @bfloat16_to_float32(i16 noundef zeroext %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvt_xu_f_w_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 1)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 1
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 1
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvt_xu_f_w_b(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !481

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 1
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 1
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvt_xu_f_w_b(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %conv1 = trunc i32 %3 to i16
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i8 @float16_to_uint8(i16 noundef zeroext %conv1, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %6 to i64
  %add.ptr3 = getelementptr i8, ptr %5, i64 %idx.ext2
  store i8 %call, ptr %add.ptr3, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvt_xu_f_w_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvt_xu_f_w_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !482

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvt_xu_f_w_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @float32_to_uint16(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvt_xu_f_w_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvt_xu_f_w_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !483

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvt_xu_f_w_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @float64_to_uint32(i64 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvt_x_f_w_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 1)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 1
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 1
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvt_x_f_w_b(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !484

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 1
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 1
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvt_x_f_w_b(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i16, ptr %0, i64 %idx.ext
  %2 = load i16, ptr %add.ptr, align 2
  %conv = zext i16 %2 to i32
  store i32 %conv, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %conv1 = trunc i32 %3 to i16
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call signext i8 @float16_to_int8(i16 noundef zeroext %conv1, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext2 = sext i32 %6 to i64
  %add.ptr3 = getelementptr i8, ptr %5, i64 %idx.ext2
  store i8 %call, ptr %add.ptr3, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvt_x_f_w_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvt_x_f_w_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !485

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvt_x_f_w_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call signext i16 @float32_to_int16(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvt_x_f_w_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvt_x_f_w_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !486

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvt_x_f_w_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @float64_to_int32(i64 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvt_f_xu_w_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvt_f_xu_w_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !487

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvt_f_xu_w_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @uint32_to_float16(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvt_f_xu_w_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvt_f_xu_w_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !488

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvt_f_xu_w_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @uint64_to_float32(i64 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvt_f_x_w_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvt_f_x_w_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !489

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvt_f_x_w_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @int32_to_float16(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvt_f_x_w_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvt_f_x_w_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !490

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvt_f_x_w_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @int64_to_float32(i64 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvt_f_f_w_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvt_f_f_w_h(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !491

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvt_f_f_w_h(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @vfncvtffv16(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvt_f_f_w_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 4)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 4
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 4
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvt_f_f_w_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !492

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 4
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvt_f_f_w_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i64, ptr %0, i64 %idx.ext
  %2 = load i64, ptr %add.ptr, align 8
  store i64 %2, ptr %s2, align 8
  %3 = load i64, ptr %s2, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call i32 @float64_to_float32(i64 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i32, ptr %5, i64 %idx.ext1
  store i32 %call, ptr %add.ptr2, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfncvtbf16_f_f_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef 2)
  store i32 %call2, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call3, ptr %vta, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call4, ptr %vma, align 4
  %7 = load i32, ptr %vl, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %9 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %mul = mul i32 %17, 2
  %18 = load i32, ptr %i, align 4
  %add = add i32 %18, 1
  %mul12 = mul i32 %add, 2
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul12)
  br label %for.inc

if.end13:                                         ; preds = %land.lhs.true, %for.body
  %19 = load ptr, ptr %vd.addr, align 8
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %env.addr, align 8
  call void @do_vfncvtbf16_f_f_w(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then11
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !493

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %vl, align 4
  %mul15 = mul i32 %27, 2
  %28 = load i32, ptr %total_elems, align 4
  %mul16 = mul i32 %28, 2
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %mul15, i32 noundef %mul16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_vfncvtbf16_f_f_w(ptr noundef %vd, ptr noundef %vs2, i32 noundef %i, ptr noundef %env) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %vs2.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %add.ptr, align 4
  store i32 %2, ptr %s2, align 4
  %3 = load i32, ptr %s2, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 14
  %call = call zeroext i16 @float32_to_bfloat16(i32 noundef %3, ptr noundef %fp_status)
  %5 = load ptr, ptr %vd.addr, align 8
  %6 = load i32, ptr %i.addr, align 4
  %idx.ext1 = sext i32 %6 to i64
  %add.ptr2 = getelementptr i16, ptr %5, i64 %idx.ext1
  store i16 %call, ptr %add.ptr2, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredsum_vs_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i8, ptr %5, i64 0
  %6 = load i8, ptr %add.ptr, align 1
  store i8 %6, ptr %s1, align 1
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr7, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i8, ptr %s1, align 1
  %conv10 = sext i8 %17 to i32
  %18 = load i8, ptr %s2, align 1
  %conv11 = sext i8 %18 to i32
  %add = add i32 %conv10, %conv11
  %conv12 = trunc i32 %add to i8
  store i8 %conv12, ptr %s1, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !494

for.end:                                          ; preds = %for.cond
  %20 = load i8, ptr %s1, align 1
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr13 = getelementptr i8, ptr %21, i64 0
  store i8 %20, ptr %add.ptr13, align 1
  %22 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @simd_maxsz(i32 noundef %desc) #0 {
entry:
  %desc.addr = alloca i32, align 4
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @extract32(i32 noundef %0, i32 noundef 0, i32 noundef 8)
  %mul = mul i32 %call, 8
  %add = add i32 %mul, 8
  %conv = zext i32 %add to i64
  ret i64 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredsum_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %conv10 = sext i16 %17 to i32
  %18 = load i16, ptr %s2, align 2
  %conv11 = sext i16 %18 to i32
  %add = add i32 %conv10, %conv11
  %conv12 = trunc i32 %add to i16
  store i16 %conv12, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !495

for.end:                                          ; preds = %for.cond
  %20 = load i16, ptr %s1, align 2
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr13 = getelementptr i16, ptr %21, i64 0
  store i16 %20, ptr %add.ptr13, align 2
  %22 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredsum_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i32, ptr %s2, align 4
  %add = add i32 %17, %18
  store i32 %add, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !496

for.end:                                          ; preds = %for.cond
  %20 = load i32, ptr %s1, align 4
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr10 = getelementptr i32, ptr %21, i64 0
  store i32 %20, ptr %add.ptr10, align 4
  %22 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredsum_vs_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr7, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i64, ptr %s2, align 8
  %add = add i64 %17, %18
  store i64 %add, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !497

for.end:                                          ; preds = %for.cond
  %20 = load i64, ptr %s1, align 8
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr10 = getelementptr i64, ptr %21, i64 0
  store i64 %20, ptr %add.ptr10, align 8
  %22 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredmaxu_vs_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i8, ptr %5, i64 0
  %6 = load i8, ptr %add.ptr, align 1
  store i8 %6, ptr %s1, align 1
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr7, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i8, ptr %s1, align 1
  %conv10 = zext i8 %17 to i32
  %18 = load i8, ptr %s2, align 1
  %conv11 = zext i8 %18 to i32
  %cmp12 = icmp sge i32 %conv10, %conv11
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i8, ptr %s1, align 1
  %conv14 = zext i8 %19 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i8, ptr %s2, align 1
  %conv15 = zext i8 %20 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv14, %cond.true ], [ %conv15, %cond.false ]
  %conv16 = trunc i32 %cond to i8
  store i8 %conv16, ptr %s1, align 1
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !498

for.end:                                          ; preds = %for.cond
  %22 = load i8, ptr %s1, align 1
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr17 = getelementptr i8, ptr %23, i64 0
  store i8 %22, ptr %add.ptr17, align 1
  %24 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredmaxu_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %conv10 = zext i16 %17 to i32
  %18 = load i16, ptr %s2, align 2
  %conv11 = zext i16 %18 to i32
  %cmp12 = icmp sge i32 %conv10, %conv11
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i16, ptr %s1, align 2
  %conv14 = zext i16 %19 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i16, ptr %s2, align 2
  %conv15 = zext i16 %20 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv14, %cond.true ], [ %conv15, %cond.false ]
  %conv16 = trunc i32 %cond to i16
  store i16 %conv16, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !499

for.end:                                          ; preds = %for.cond
  %22 = load i16, ptr %s1, align 2
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr17 = getelementptr i16, ptr %23, i64 0
  store i16 %22, ptr %add.ptr17, align 2
  %24 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredmaxu_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i32, ptr %s2, align 4
  %cmp10 = icmp uge i32 %17, %18
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i32, ptr %s1, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i32, ptr %s2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %19, %cond.true ], [ %20, %cond.false ]
  store i32 %cond, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !500

for.end:                                          ; preds = %for.cond
  %22 = load i32, ptr %s1, align 4
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr12 = getelementptr i32, ptr %23, i64 0
  store i32 %22, ptr %add.ptr12, align 4
  %24 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredmaxu_vs_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr7, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i64, ptr %s2, align 8
  %cmp10 = icmp uge i64 %17, %18
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i64, ptr %s1, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i64, ptr %s2, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %19, %cond.true ], [ %20, %cond.false ]
  store i64 %cond, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !501

for.end:                                          ; preds = %for.cond
  %22 = load i64, ptr %s1, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr12 = getelementptr i64, ptr %23, i64 0
  store i64 %22, ptr %add.ptr12, align 8
  %24 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredmax_vs_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i8, ptr %5, i64 0
  %6 = load i8, ptr %add.ptr, align 1
  store i8 %6, ptr %s1, align 1
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr7, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i8, ptr %s1, align 1
  %conv10 = sext i8 %17 to i32
  %18 = load i8, ptr %s2, align 1
  %conv11 = sext i8 %18 to i32
  %cmp12 = icmp sge i32 %conv10, %conv11
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i8, ptr %s1, align 1
  %conv14 = sext i8 %19 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i8, ptr %s2, align 1
  %conv15 = sext i8 %20 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv14, %cond.true ], [ %conv15, %cond.false ]
  %conv16 = trunc i32 %cond to i8
  store i8 %conv16, ptr %s1, align 1
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !502

for.end:                                          ; preds = %for.cond
  %22 = load i8, ptr %s1, align 1
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr17 = getelementptr i8, ptr %23, i64 0
  store i8 %22, ptr %add.ptr17, align 1
  %24 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredmax_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %conv10 = sext i16 %17 to i32
  %18 = load i16, ptr %s2, align 2
  %conv11 = sext i16 %18 to i32
  %cmp12 = icmp sge i32 %conv10, %conv11
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i16, ptr %s1, align 2
  %conv14 = sext i16 %19 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i16, ptr %s2, align 2
  %conv15 = sext i16 %20 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv14, %cond.true ], [ %conv15, %cond.false ]
  %conv16 = trunc i32 %cond to i16
  store i16 %conv16, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !503

for.end:                                          ; preds = %for.cond
  %22 = load i16, ptr %s1, align 2
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr17 = getelementptr i16, ptr %23, i64 0
  store i16 %22, ptr %add.ptr17, align 2
  %24 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredmax_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i32, ptr %s2, align 4
  %cmp10 = icmp sge i32 %17, %18
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i32, ptr %s1, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i32, ptr %s2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %19, %cond.true ], [ %20, %cond.false ]
  store i32 %cond, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !504

for.end:                                          ; preds = %for.cond
  %22 = load i32, ptr %s1, align 4
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr12 = getelementptr i32, ptr %23, i64 0
  store i32 %22, ptr %add.ptr12, align 4
  %24 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredmax_vs_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr7, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i64, ptr %s2, align 8
  %cmp10 = icmp sge i64 %17, %18
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i64, ptr %s1, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i64, ptr %s2, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %19, %cond.true ], [ %20, %cond.false ]
  store i64 %cond, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !505

for.end:                                          ; preds = %for.cond
  %22 = load i64, ptr %s1, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr12 = getelementptr i64, ptr %23, i64 0
  store i64 %22, ptr %add.ptr12, align 8
  %24 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredminu_vs_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i8, ptr %5, i64 0
  %6 = load i8, ptr %add.ptr, align 1
  store i8 %6, ptr %s1, align 1
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr7, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i8, ptr %s1, align 1
  %conv10 = zext i8 %17 to i32
  %18 = load i8, ptr %s2, align 1
  %conv11 = zext i8 %18 to i32
  %cmp12 = icmp sge i32 %conv10, %conv11
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i8, ptr %s2, align 1
  %conv14 = zext i8 %19 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i8, ptr %s1, align 1
  %conv15 = zext i8 %20 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv14, %cond.true ], [ %conv15, %cond.false ]
  %conv16 = trunc i32 %cond to i8
  store i8 %conv16, ptr %s1, align 1
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !506

for.end:                                          ; preds = %for.cond
  %22 = load i8, ptr %s1, align 1
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr17 = getelementptr i8, ptr %23, i64 0
  store i8 %22, ptr %add.ptr17, align 1
  %24 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredminu_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %conv10 = zext i16 %17 to i32
  %18 = load i16, ptr %s2, align 2
  %conv11 = zext i16 %18 to i32
  %cmp12 = icmp sge i32 %conv10, %conv11
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i16, ptr %s2, align 2
  %conv14 = zext i16 %19 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i16, ptr %s1, align 2
  %conv15 = zext i16 %20 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv14, %cond.true ], [ %conv15, %cond.false ]
  %conv16 = trunc i32 %cond to i16
  store i16 %conv16, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !507

for.end:                                          ; preds = %for.cond
  %22 = load i16, ptr %s1, align 2
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr17 = getelementptr i16, ptr %23, i64 0
  store i16 %22, ptr %add.ptr17, align 2
  %24 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredminu_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i32, ptr %s2, align 4
  %cmp10 = icmp uge i32 %17, %18
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i32, ptr %s2, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i32, ptr %s1, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %19, %cond.true ], [ %20, %cond.false ]
  store i32 %cond, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !508

for.end:                                          ; preds = %for.cond
  %22 = load i32, ptr %s1, align 4
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr12 = getelementptr i32, ptr %23, i64 0
  store i32 %22, ptr %add.ptr12, align 4
  %24 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredminu_vs_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr7, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i64, ptr %s2, align 8
  %cmp10 = icmp uge i64 %17, %18
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i64, ptr %s2, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i64, ptr %s1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %19, %cond.true ], [ %20, %cond.false ]
  store i64 %cond, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !509

for.end:                                          ; preds = %for.cond
  %22 = load i64, ptr %s1, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr12 = getelementptr i64, ptr %23, i64 0
  store i64 %22, ptr %add.ptr12, align 8
  %24 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredmin_vs_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i8, ptr %5, i64 0
  %6 = load i8, ptr %add.ptr, align 1
  store i8 %6, ptr %s1, align 1
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr7, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i8, ptr %s1, align 1
  %conv10 = sext i8 %17 to i32
  %18 = load i8, ptr %s2, align 1
  %conv11 = sext i8 %18 to i32
  %cmp12 = icmp sge i32 %conv10, %conv11
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i8, ptr %s2, align 1
  %conv14 = sext i8 %19 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i8, ptr %s1, align 1
  %conv15 = sext i8 %20 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv14, %cond.true ], [ %conv15, %cond.false ]
  %conv16 = trunc i32 %cond to i8
  store i8 %conv16, ptr %s1, align 1
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !510

for.end:                                          ; preds = %for.cond
  %22 = load i8, ptr %s1, align 1
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr17 = getelementptr i8, ptr %23, i64 0
  store i8 %22, ptr %add.ptr17, align 1
  %24 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredmin_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %conv10 = sext i16 %17 to i32
  %18 = load i16, ptr %s2, align 2
  %conv11 = sext i16 %18 to i32
  %cmp12 = icmp sge i32 %conv10, %conv11
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i16, ptr %s2, align 2
  %conv14 = sext i16 %19 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i16, ptr %s1, align 2
  %conv15 = sext i16 %20 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv14, %cond.true ], [ %conv15, %cond.false ]
  %conv16 = trunc i32 %cond to i16
  store i16 %conv16, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !511

for.end:                                          ; preds = %for.cond
  %22 = load i16, ptr %s1, align 2
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr17 = getelementptr i16, ptr %23, i64 0
  store i16 %22, ptr %add.ptr17, align 2
  %24 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredmin_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i32, ptr %s2, align 4
  %cmp10 = icmp sge i32 %17, %18
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i32, ptr %s2, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i32, ptr %s1, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %19, %cond.true ], [ %20, %cond.false ]
  store i32 %cond, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !512

for.end:                                          ; preds = %for.cond
  %22 = load i32, ptr %s1, align 4
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr12 = getelementptr i32, ptr %23, i64 0
  store i32 %22, ptr %add.ptr12, align 4
  %24 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredmin_vs_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr7, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i64, ptr %s2, align 8
  %cmp10 = icmp sge i64 %17, %18
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %19 = load i64, ptr %s2, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %20 = load i64, ptr %s1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %19, %cond.true ], [ %20, %cond.false ]
  store i64 %cond, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !513

for.end:                                          ; preds = %for.cond
  %22 = load i64, ptr %s1, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %add.ptr12 = getelementptr i64, ptr %23, i64 0
  store i64 %22, ptr %add.ptr12, align 8
  %24 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %24, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %vta, align 4
  %27 = load i32, ptr %esz, align 4
  %28 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredand_vs_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i8, ptr %5, i64 0
  %6 = load i8, ptr %add.ptr, align 1
  store i8 %6, ptr %s1, align 1
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr7, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i8, ptr %s1, align 1
  %conv10 = sext i8 %17 to i32
  %18 = load i8, ptr %s2, align 1
  %conv11 = sext i8 %18 to i32
  %and = and i32 %conv10, %conv11
  %conv12 = trunc i32 %and to i8
  store i8 %conv12, ptr %s1, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !514

for.end:                                          ; preds = %for.cond
  %20 = load i8, ptr %s1, align 1
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr13 = getelementptr i8, ptr %21, i64 0
  store i8 %20, ptr %add.ptr13, align 1
  %22 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredand_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %conv10 = sext i16 %17 to i32
  %18 = load i16, ptr %s2, align 2
  %conv11 = sext i16 %18 to i32
  %and = and i32 %conv10, %conv11
  %conv12 = trunc i32 %and to i16
  store i16 %conv12, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !515

for.end:                                          ; preds = %for.cond
  %20 = load i16, ptr %s1, align 2
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr13 = getelementptr i16, ptr %21, i64 0
  store i16 %20, ptr %add.ptr13, align 2
  %22 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredand_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i32, ptr %s2, align 4
  %and = and i32 %17, %18
  store i32 %and, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !516

for.end:                                          ; preds = %for.cond
  %20 = load i32, ptr %s1, align 4
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr10 = getelementptr i32, ptr %21, i64 0
  store i32 %20, ptr %add.ptr10, align 4
  %22 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredand_vs_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr7, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i64, ptr %s2, align 8
  %and = and i64 %17, %18
  store i64 %and, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !517

for.end:                                          ; preds = %for.cond
  %20 = load i64, ptr %s1, align 8
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr10 = getelementptr i64, ptr %21, i64 0
  store i64 %20, ptr %add.ptr10, align 8
  %22 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredor_vs_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i8, ptr %5, i64 0
  %6 = load i8, ptr %add.ptr, align 1
  store i8 %6, ptr %s1, align 1
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr7, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i8, ptr %s1, align 1
  %conv10 = sext i8 %17 to i32
  %18 = load i8, ptr %s2, align 1
  %conv11 = sext i8 %18 to i32
  %or = or i32 %conv10, %conv11
  %conv12 = trunc i32 %or to i8
  store i8 %conv12, ptr %s1, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !518

for.end:                                          ; preds = %for.cond
  %20 = load i8, ptr %s1, align 1
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr13 = getelementptr i8, ptr %21, i64 0
  store i8 %20, ptr %add.ptr13, align 1
  %22 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredor_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %conv10 = sext i16 %17 to i32
  %18 = load i16, ptr %s2, align 2
  %conv11 = sext i16 %18 to i32
  %or = or i32 %conv10, %conv11
  %conv12 = trunc i32 %or to i16
  store i16 %conv12, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !519

for.end:                                          ; preds = %for.cond
  %20 = load i16, ptr %s1, align 2
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr13 = getelementptr i16, ptr %21, i64 0
  store i16 %20, ptr %add.ptr13, align 2
  %22 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredor_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i32, ptr %s2, align 4
  %or = or i32 %17, %18
  store i32 %or, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !520

for.end:                                          ; preds = %for.cond
  %20 = load i32, ptr %s1, align 4
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr10 = getelementptr i32, ptr %21, i64 0
  store i32 %20, ptr %add.ptr10, align 4
  %22 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredor_vs_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr7, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i64, ptr %s2, align 8
  %or = or i64 %17, %18
  store i64 %or, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !521

for.end:                                          ; preds = %for.cond
  %20 = load i64, ptr %s1, align 8
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr10 = getelementptr i64, ptr %21, i64 0
  store i64 %20, ptr %add.ptr10, align 8
  %22 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredxor_vs_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i8, align 1
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i8, ptr %5, i64 0
  %6 = load i8, ptr %add.ptr, align 1
  store i8 %6, ptr %s1, align 1
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr7, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i8, ptr %s1, align 1
  %conv10 = sext i8 %17 to i32
  %18 = load i8, ptr %s2, align 1
  %conv11 = sext i8 %18 to i32
  %xor = xor i32 %conv10, %conv11
  %conv12 = trunc i32 %xor to i8
  store i8 %conv12, ptr %s1, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !522

for.end:                                          ; preds = %for.cond
  %20 = load i8, ptr %s1, align 1
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr13 = getelementptr i8, ptr %21, i64 0
  store i8 %20, ptr %add.ptr13, align 1
  %22 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredxor_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %conv10 = sext i16 %17 to i32
  %18 = load i16, ptr %s2, align 2
  %conv11 = sext i16 %18 to i32
  %xor = xor i32 %conv10, %conv11
  %conv12 = trunc i32 %xor to i16
  store i16 %conv12, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !523

for.end:                                          ; preds = %for.cond
  %20 = load i16, ptr %s1, align 2
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr13 = getelementptr i16, ptr %21, i64 0
  store i16 %20, ptr %add.ptr13, align 2
  %22 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredxor_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i32, ptr %s2, align 4
  %xor = xor i32 %17, %18
  store i32 %xor, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !524

for.end:                                          ; preds = %for.cond
  %20 = load i32, ptr %s1, align 4
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr10 = getelementptr i32, ptr %21, i64 0
  store i32 %20, ptr %add.ptr10, align 4
  %22 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vredxor_vs_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr7, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i64, ptr %s2, align 8
  %xor = xor i64 %17, %18
  store i64 %xor, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !525

for.end:                                          ; preds = %for.cond
  %20 = load i64, ptr %s1, align 8
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr10 = getelementptr i64, ptr %21, i64 0
  store i64 %20, ptr %add.ptr10, align 8
  %22 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwredsum_vs_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr7, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %conv10 = sext i16 %17 to i32
  %18 = load i8, ptr %s2, align 1
  %conv11 = sext i8 %18 to i16
  %conv12 = sext i16 %conv11 to i32
  %add = add i32 %conv10, %conv12
  %conv13 = trunc i32 %add to i16
  store i16 %conv13, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !526

for.end:                                          ; preds = %for.cond
  %20 = load i16, ptr %s1, align 2
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr14 = getelementptr i16, ptr %21, i64 0
  store i16 %20, ptr %add.ptr14, align 2
  %22 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwredsum_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i16, ptr %s2, align 2
  %conv10 = sext i16 %18 to i32
  %add = add i32 %17, %conv10
  store i32 %add, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !527

for.end:                                          ; preds = %for.cond
  %20 = load i32, ptr %s1, align 4
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i32, ptr %21, i64 0
  store i32 %20, ptr %add.ptr11, align 4
  %22 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwredsum_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i32, ptr %s2, align 4
  %conv10 = sext i32 %18 to i64
  %add = add i64 %17, %conv10
  store i64 %add, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !528

for.end:                                          ; preds = %for.cond
  %20 = load i64, ptr %s1, align 8
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i64, ptr %21, i64 0
  store i64 %20, ptr %add.ptr11, align 8
  %22 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwredsumu_vs_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i8, ptr %11, i64 %idx.ext
  %13 = load i8, ptr %add.ptr7, align 1
  store i8 %13, ptr %s2, align 1
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %conv10 = zext i16 %17 to i32
  %18 = load i8, ptr %s2, align 1
  %conv11 = zext i8 %18 to i16
  %conv12 = zext i16 %conv11 to i32
  %add = add i32 %conv10, %conv12
  %conv13 = trunc i32 %add to i16
  store i16 %conv13, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !529

for.end:                                          ; preds = %for.cond
  %20 = load i16, ptr %s1, align 2
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr14 = getelementptr i16, ptr %21, i64 0
  store i16 %20, ptr %add.ptr14, align 2
  %22 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwredsumu_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i16, ptr %s2, align 2
  %conv10 = zext i16 %18 to i32
  %add = add i32 %17, %conv10
  store i32 %add, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !530

for.end:                                          ; preds = %for.cond
  %20 = load i32, ptr %s1, align 4
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i32, ptr %21, i64 0
  store i32 %20, ptr %add.ptr11, align 4
  %22 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vwredsumu_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i32, ptr %s2, align 4
  %conv10 = zext i32 %18 to i64
  %add = add i64 %17, %conv10
  store i64 %add, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !531

for.end:                                          ; preds = %for.cond
  %20 = load i64, ptr %s1, align 8
  %21 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i64, ptr %21, i64 0
  store i64 %20, ptr %add.ptr11, align 8
  %22 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %22, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vta, align 4
  %25 = load i32, ptr %esz, align 4
  %26 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfredusum_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %18 = load i16, ptr %s2, align 2
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call10 = call zeroext i16 @float16_add(i16 noundef zeroext %17, i16 noundef zeroext %18, ptr noundef %fp_status)
  store i16 %call10, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !532

for.end:                                          ; preds = %for.cond
  %21 = load i16, ptr %s1, align 2
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i16, ptr %22, i64 0
  store i16 %21, ptr %add.ptr11, align 2
  %23 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

declare zeroext i16 @float16_add(i16 noundef zeroext, i16 noundef zeroext, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfredusum_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i32, ptr %s2, align 4
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call10 = call i32 @float32_add(i32 noundef %17, i32 noundef %18, ptr noundef %fp_status)
  store i32 %call10, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !533

for.end:                                          ; preds = %for.cond
  %21 = load i32, ptr %s1, align 4
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i32, ptr %22, i64 0
  store i32 %21, ptr %add.ptr11, align 4
  %23 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

declare i32 @float32_add(i32 noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfredusum_vs_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr7, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i64, ptr %s2, align 8
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call10 = call i64 @float64_add(i64 noundef %17, i64 noundef %18, ptr noundef %fp_status)
  store i64 %call10, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !534

for.end:                                          ; preds = %for.cond
  %21 = load i64, ptr %s1, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i64, ptr %22, i64 0
  store i64 %21, ptr %add.ptr11, align 8
  %23 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

declare i64 @float64_add(i64 noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfredosum_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %18 = load i16, ptr %s2, align 2
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call10 = call zeroext i16 @float16_add(i16 noundef zeroext %17, i16 noundef zeroext %18, ptr noundef %fp_status)
  store i16 %call10, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !535

for.end:                                          ; preds = %for.cond
  %21 = load i16, ptr %s1, align 2
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i16, ptr %22, i64 0
  store i16 %21, ptr %add.ptr11, align 2
  %23 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfredosum_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i32, ptr %s2, align 4
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call10 = call i32 @float32_add(i32 noundef %17, i32 noundef %18, ptr noundef %fp_status)
  store i32 %call10, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !536

for.end:                                          ; preds = %for.cond
  %21 = load i32, ptr %s1, align 4
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i32, ptr %22, i64 0
  store i32 %21, ptr %add.ptr11, align 4
  %23 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfredosum_vs_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr7, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i64, ptr %s2, align 8
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call10 = call i64 @float64_add(i64 noundef %17, i64 noundef %18, ptr noundef %fp_status)
  store i64 %call10, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !537

for.end:                                          ; preds = %for.cond
  %21 = load i64, ptr %s1, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i64, ptr %22, i64 0
  store i64 %21, ptr %add.ptr11, align 8
  %23 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfredmax_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %18 = load i16, ptr %s2, align 2
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call10 = call zeroext i16 @float16_maximum_number(i16 noundef zeroext %17, i16 noundef zeroext %18, ptr noundef %fp_status)
  store i16 %call10, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !538

for.end:                                          ; preds = %for.cond
  %21 = load i16, ptr %s1, align 2
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i16, ptr %22, i64 0
  store i16 %21, ptr %add.ptr11, align 2
  %23 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

declare zeroext i16 @float16_maximum_number(i16 noundef zeroext, i16 noundef zeroext, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfredmax_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i32, ptr %s2, align 4
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call10 = call i32 @float32_maximum_number(i32 noundef %17, i32 noundef %18, ptr noundef %fp_status)
  store i32 %call10, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !539

for.end:                                          ; preds = %for.cond
  %21 = load i32, ptr %s1, align 4
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i32, ptr %22, i64 0
  store i32 %21, ptr %add.ptr11, align 4
  %23 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

declare i32 @float32_maximum_number(i32 noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfredmax_vs_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr7, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i64, ptr %s2, align 8
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call10 = call i64 @float64_maximum_number(i64 noundef %17, i64 noundef %18, ptr noundef %fp_status)
  store i64 %call10, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !540

for.end:                                          ; preds = %for.cond
  %21 = load i64, ptr %s1, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i64, ptr %22, i64 0
  store i64 %21, ptr %add.ptr11, align 8
  %23 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

declare i64 @float64_maximum_number(i64 noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfredmin_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i16, align 2
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i16, ptr %5, i64 0
  %6 = load i16, ptr %add.ptr, align 2
  store i16 %6, ptr %s1, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i16, ptr %s1, align 2
  %18 = load i16, ptr %s2, align 2
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call10 = call zeroext i16 @float16_minimum_number(i16 noundef zeroext %17, i16 noundef zeroext %18, ptr noundef %fp_status)
  store i16 %call10, ptr %s1, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !541

for.end:                                          ; preds = %for.cond
  %21 = load i16, ptr %s1, align 2
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i16, ptr %22, i64 0
  store i16 %21, ptr %add.ptr11, align 2
  %23 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

declare zeroext i16 @float16_minimum_number(i16 noundef zeroext, i16 noundef zeroext, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfredmin_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i32, ptr %s2, align 4
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call10 = call i32 @float32_minimum_number(i32 noundef %17, i32 noundef %18, ptr noundef %fp_status)
  store i32 %call10, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !542

for.end:                                          ; preds = %for.cond
  %21 = load i32, ptr %s1, align 4
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i32, ptr %22, i64 0
  store i32 %21, ptr %add.ptr11, align 4
  %23 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

declare i32 @float32_minimum_number(i32 noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfredmin_vs_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i64, ptr %11, i64 %idx.ext
  %13 = load i64, ptr %add.ptr7, align 8
  store i64 %13, ptr %s2, align 8
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i64, ptr %s2, align 8
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call10 = call i64 @float64_minimum_number(i64 noundef %17, i64 noundef %18, ptr noundef %fp_status)
  store i64 %call10, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !543

for.end:                                          ; preds = %for.cond
  %21 = load i64, ptr %s1, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr11 = getelementptr i64, ptr %22, i64 0
  store i64 %21, ptr %add.ptr11, align 8
  %23 = load ptr, ptr %env.addr, align 8
  %vstart12 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart12, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

declare i64 @float64_minimum_number(i64 noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwredusum_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i16, ptr %s2, align 2
  %conv10 = zext i16 %18 to i32
  %conv11 = trunc i32 %conv10 to i16
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call12 = call i32 @fwadd16(i32 noundef %17, i16 noundef zeroext %conv11, ptr noundef %fp_status)
  store i32 %call12, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !544

for.end:                                          ; preds = %for.cond
  %21 = load i32, ptr %s1, align 4
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr13 = getelementptr i32, ptr %22, i64 0
  store i32 %21, ptr %add.ptr13, align 4
  %23 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fwadd16(i32 noundef %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i16, ptr %b.addr, align 2
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_to_float32(i16 noundef zeroext %1, i1 noundef zeroext true, ptr noundef %2)
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i32 @float32_add(i32 noundef %0, i32 noundef %call, ptr noundef %3)
  ret i32 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwredusum_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i32, ptr %s2, align 4
  %conv10 = zext i32 %18 to i64
  %conv11 = trunc i64 %conv10 to i32
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call12 = call i64 @fwadd32(i64 noundef %17, i32 noundef %conv11, ptr noundef %fp_status)
  store i64 %call12, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !545

for.end:                                          ; preds = %for.cond
  %21 = load i64, ptr %s1, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr13 = getelementptr i64, ptr %22, i64 0
  store i64 %21, ptr %add.ptr13, align 8
  %23 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fwadd32(i64 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i32, ptr %b.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float32_to_float64(i32 noundef %1, ptr noundef %2)
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i64 @float64_add(i64 noundef %0, i64 noundef %call, ptr noundef %3)
  ret i64 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwredosum_vs_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i32, align 4
  %s2 = alloca i16, align 2
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %add.ptr, align 4
  store i32 %6, ptr %s1, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i16, ptr %11, i64 %idx.ext
  %13 = load i16, ptr %add.ptr7, align 2
  store i16 %13, ptr %s2, align 2
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i32, ptr %s1, align 4
  %18 = load i16, ptr %s2, align 2
  %conv10 = zext i16 %18 to i32
  %conv11 = trunc i32 %conv10 to i16
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call12 = call i32 @fwadd16(i32 noundef %17, i16 noundef zeroext %conv11, ptr noundef %fp_status)
  store i32 %call12, ptr %s1, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !546

for.end:                                          ; preds = %for.cond
  %21 = load i32, ptr %s1, align 4
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr13 = getelementptr i32, ptr %22, i64 0
  store i32 %21, ptr %add.ptr13, align 4
  %23 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfwredosum_vs_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %vta = alloca i32, align 4
  %i = alloca i32, align 4
  %s1 = alloca i64, align 8
  %s2 = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load i32, ptr %desc.addr, align 4
  %call2 = call i64 @simd_maxsz(i32 noundef %3)
  %conv3 = trunc i64 %call2 to i32
  store i32 %conv3, ptr %vlenb, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta(i32 noundef %4)
  store i32 %call4, ptr %vta, align 4
  %5 = load ptr, ptr %vs1.addr, align 8
  %add.ptr = getelementptr i64, ptr %5, i64 0
  %6 = load i64, ptr %add.ptr, align 8
  store i64 %6, ptr %s1, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %8 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr7 = getelementptr i32, ptr %11, i64 %idx.ext
  %13 = load i32, ptr %add.ptr7, align 4
  store i32 %13, ptr %s2, align 4
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %17 = load i64, ptr %s1, align 8
  %18 = load i32, ptr %s2, align 4
  %conv10 = zext i32 %18 to i64
  %conv11 = trunc i64 %conv10 to i32
  %19 = load ptr, ptr %env.addr, align 8
  %fp_status = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 14
  %call12 = call i64 @fwadd32(i64 noundef %17, i32 noundef %conv11, ptr noundef %fp_status)
  store i64 %call12, ptr %s1, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !547

for.end:                                          ; preds = %for.cond
  %21 = load i64, ptr %s1, align 8
  %22 = load ptr, ptr %vd.addr, align 8
  %add.ptr13 = getelementptr i64, ptr %22, i64 0
  store i64 %21, ptr %add.ptr13, align 8
  %23 = load ptr, ptr %env.addr, align 8
  %vstart14 = getelementptr inbounds %struct.CPUArchState, ptr %23, i32 0, i32 6
  store i64 0, ptr %vstart14, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %vta, align 4
  %26 = load i32, ptr %esz, align 4
  %27 = load i32, ptr %vlenb, align 4
  call void @vext_set_elems_1s(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmand_mm(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %call = call ptr @riscv_cpu_cfg(ptr noundef %2)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call, i32 0, i32 98
  %3 = load i16, ptr %vlen, align 8
  %conv2 = zext i16 %3 to i32
  store i32 %conv2, ptr %total_elems, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta_all_1s(i32 noundef %4)
  store i32 %call3, ptr %vta_all_1s, align 4
  %5 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %vstart, align 8
  %conv4 = trunc i64 %6 to i32
  store i32 %conv4, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %vs1.addr, align 8
  %10 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %9, i32 noundef %10)
  store i32 %call6, ptr %a, align 4
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %11, i32 noundef %12)
  store i32 %call7, ptr %b, align 4
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i, align 4
  %15 = load i32, ptr %b, align 4
  %16 = load i32, ptr %a, align 4
  %and = and i32 %15, %16
  %conv8 = trunc i32 %and to i8
  call void @vext_set_elem_mask(ptr noundef %13, i32 noundef %14, i8 noundef zeroext %conv8)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !548

for.end:                                          ; preds = %for.cond
  %18 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %18, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %19 = load i32, ptr %vta_all_1s, align 4
  %tobool = icmp ne i32 %19, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc14, %if.then
  %20 = load i32, ptr %i, align 4
  %21 = load i32, ptr %total_elems, align 4
  %cmp11 = icmp ult i32 %20, %21
  br i1 %cmp11, label %for.body13, label %for.end16

for.body13:                                       ; preds = %for.cond10
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %22, i32 noundef %23, i8 noundef zeroext 1)
  br label %for.inc14

for.inc14:                                        ; preds = %for.body13
  %24 = load i32, ptr %i, align 4
  %inc15 = add i32 %24, 1
  store i32 %inc15, ptr %i, align 4
  br label %for.cond10, !llvm.loop !549

for.end16:                                        ; preds = %for.cond10
  br label %if.end

if.end:                                           ; preds = %for.end16, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmnand_mm(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %call = call ptr @riscv_cpu_cfg(ptr noundef %2)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call, i32 0, i32 98
  %3 = load i16, ptr %vlen, align 8
  %conv2 = zext i16 %3 to i32
  store i32 %conv2, ptr %total_elems, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta_all_1s(i32 noundef %4)
  store i32 %call3, ptr %vta_all_1s, align 4
  %5 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %vstart, align 8
  %conv4 = trunc i64 %6 to i32
  store i32 %conv4, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %vs1.addr, align 8
  %10 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %9, i32 noundef %10)
  store i32 %call6, ptr %a, align 4
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %11, i32 noundef %12)
  store i32 %call7, ptr %b, align 4
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i, align 4
  %15 = load i32, ptr %b, align 4
  %16 = load i32, ptr %a, align 4
  %and = and i32 %15, %16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %conv8 = trunc i32 %lnot.ext to i8
  call void @vext_set_elem_mask(ptr noundef %13, i32 noundef %14, i8 noundef zeroext %conv8)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !550

for.end:                                          ; preds = %for.cond
  %18 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %18, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %19 = load i32, ptr %vta_all_1s, align 4
  %tobool10 = icmp ne i32 %19, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc15, %if.then
  %20 = load i32, ptr %i, align 4
  %21 = load i32, ptr %total_elems, align 4
  %cmp12 = icmp ult i32 %20, %21
  br i1 %cmp12, label %for.body14, label %for.end17

for.body14:                                       ; preds = %for.cond11
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %22, i32 noundef %23, i8 noundef zeroext 1)
  br label %for.inc15

for.inc15:                                        ; preds = %for.body14
  %24 = load i32, ptr %i, align 4
  %inc16 = add i32 %24, 1
  store i32 %inc16, ptr %i, align 4
  br label %for.cond11, !llvm.loop !551

for.end17:                                        ; preds = %for.cond11
  br label %if.end

if.end:                                           ; preds = %for.end17, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmandn_mm(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %call = call ptr @riscv_cpu_cfg(ptr noundef %2)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call, i32 0, i32 98
  %3 = load i16, ptr %vlen, align 8
  %conv2 = zext i16 %3 to i32
  store i32 %conv2, ptr %total_elems, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta_all_1s(i32 noundef %4)
  store i32 %call3, ptr %vta_all_1s, align 4
  %5 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %vstart, align 8
  %conv4 = trunc i64 %6 to i32
  store i32 %conv4, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %vs1.addr, align 8
  %10 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %9, i32 noundef %10)
  store i32 %call6, ptr %a, align 4
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %11, i32 noundef %12)
  store i32 %call7, ptr %b, align 4
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i, align 4
  %15 = load i32, ptr %b, align 4
  %16 = load i32, ptr %a, align 4
  %tobool = icmp ne i32 %16, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %and = and i32 %15, %lnot.ext
  %conv8 = trunc i32 %and to i8
  call void @vext_set_elem_mask(ptr noundef %13, i32 noundef %14, i8 noundef zeroext %conv8)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !552

for.end:                                          ; preds = %for.cond
  %18 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %18, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %19 = load i32, ptr %vta_all_1s, align 4
  %tobool10 = icmp ne i32 %19, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc15, %if.then
  %20 = load i32, ptr %i, align 4
  %21 = load i32, ptr %total_elems, align 4
  %cmp12 = icmp ult i32 %20, %21
  br i1 %cmp12, label %for.body14, label %for.end17

for.body14:                                       ; preds = %for.cond11
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %22, i32 noundef %23, i8 noundef zeroext 1)
  br label %for.inc15

for.inc15:                                        ; preds = %for.body14
  %24 = load i32, ptr %i, align 4
  %inc16 = add i32 %24, 1
  store i32 %inc16, ptr %i, align 4
  br label %for.cond11, !llvm.loop !553

for.end17:                                        ; preds = %for.cond11
  br label %if.end

if.end:                                           ; preds = %for.end17, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmxor_mm(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %call = call ptr @riscv_cpu_cfg(ptr noundef %2)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call, i32 0, i32 98
  %3 = load i16, ptr %vlen, align 8
  %conv2 = zext i16 %3 to i32
  store i32 %conv2, ptr %total_elems, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta_all_1s(i32 noundef %4)
  store i32 %call3, ptr %vta_all_1s, align 4
  %5 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %vstart, align 8
  %conv4 = trunc i64 %6 to i32
  store i32 %conv4, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %vs1.addr, align 8
  %10 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %9, i32 noundef %10)
  store i32 %call6, ptr %a, align 4
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %11, i32 noundef %12)
  store i32 %call7, ptr %b, align 4
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i, align 4
  %15 = load i32, ptr %b, align 4
  %16 = load i32, ptr %a, align 4
  %xor = xor i32 %15, %16
  %conv8 = trunc i32 %xor to i8
  call void @vext_set_elem_mask(ptr noundef %13, i32 noundef %14, i8 noundef zeroext %conv8)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !554

for.end:                                          ; preds = %for.cond
  %18 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %18, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %19 = load i32, ptr %vta_all_1s, align 4
  %tobool = icmp ne i32 %19, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc14, %if.then
  %20 = load i32, ptr %i, align 4
  %21 = load i32, ptr %total_elems, align 4
  %cmp11 = icmp ult i32 %20, %21
  br i1 %cmp11, label %for.body13, label %for.end16

for.body13:                                       ; preds = %for.cond10
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %22, i32 noundef %23, i8 noundef zeroext 1)
  br label %for.inc14

for.inc14:                                        ; preds = %for.body13
  %24 = load i32, ptr %i, align 4
  %inc15 = add i32 %24, 1
  store i32 %inc15, ptr %i, align 4
  br label %for.cond10, !llvm.loop !555

for.end16:                                        ; preds = %for.cond10
  br label %if.end

if.end:                                           ; preds = %for.end16, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmor_mm(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %call = call ptr @riscv_cpu_cfg(ptr noundef %2)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call, i32 0, i32 98
  %3 = load i16, ptr %vlen, align 8
  %conv2 = zext i16 %3 to i32
  store i32 %conv2, ptr %total_elems, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta_all_1s(i32 noundef %4)
  store i32 %call3, ptr %vta_all_1s, align 4
  %5 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %vstart, align 8
  %conv4 = trunc i64 %6 to i32
  store i32 %conv4, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %vs1.addr, align 8
  %10 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %9, i32 noundef %10)
  store i32 %call6, ptr %a, align 4
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %11, i32 noundef %12)
  store i32 %call7, ptr %b, align 4
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i, align 4
  %15 = load i32, ptr %b, align 4
  %16 = load i32, ptr %a, align 4
  %or = or i32 %15, %16
  %conv8 = trunc i32 %or to i8
  call void @vext_set_elem_mask(ptr noundef %13, i32 noundef %14, i8 noundef zeroext %conv8)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !556

for.end:                                          ; preds = %for.cond
  %18 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %18, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %19 = load i32, ptr %vta_all_1s, align 4
  %tobool = icmp ne i32 %19, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc14, %if.then
  %20 = load i32, ptr %i, align 4
  %21 = load i32, ptr %total_elems, align 4
  %cmp11 = icmp ult i32 %20, %21
  br i1 %cmp11, label %for.body13, label %for.end16

for.body13:                                       ; preds = %for.cond10
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %22, i32 noundef %23, i8 noundef zeroext 1)
  br label %for.inc14

for.inc14:                                        ; preds = %for.body13
  %24 = load i32, ptr %i, align 4
  %inc15 = add i32 %24, 1
  store i32 %inc15, ptr %i, align 4
  br label %for.cond10, !llvm.loop !557

for.end16:                                        ; preds = %for.cond10
  br label %if.end

if.end:                                           ; preds = %for.end16, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmnor_mm(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %call = call ptr @riscv_cpu_cfg(ptr noundef %2)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call, i32 0, i32 98
  %3 = load i16, ptr %vlen, align 8
  %conv2 = zext i16 %3 to i32
  store i32 %conv2, ptr %total_elems, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta_all_1s(i32 noundef %4)
  store i32 %call3, ptr %vta_all_1s, align 4
  %5 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %vstart, align 8
  %conv4 = trunc i64 %6 to i32
  store i32 %conv4, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %vs1.addr, align 8
  %10 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %9, i32 noundef %10)
  store i32 %call6, ptr %a, align 4
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %11, i32 noundef %12)
  store i32 %call7, ptr %b, align 4
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i, align 4
  %15 = load i32, ptr %b, align 4
  %16 = load i32, ptr %a, align 4
  %or = or i32 %15, %16
  %tobool = icmp ne i32 %or, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %conv8 = trunc i32 %lnot.ext to i8
  call void @vext_set_elem_mask(ptr noundef %13, i32 noundef %14, i8 noundef zeroext %conv8)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !558

for.end:                                          ; preds = %for.cond
  %18 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %18, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %19 = load i32, ptr %vta_all_1s, align 4
  %tobool10 = icmp ne i32 %19, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc15, %if.then
  %20 = load i32, ptr %i, align 4
  %21 = load i32, ptr %total_elems, align 4
  %cmp12 = icmp ult i32 %20, %21
  br i1 %cmp12, label %for.body14, label %for.end17

for.body14:                                       ; preds = %for.cond11
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %22, i32 noundef %23, i8 noundef zeroext 1)
  br label %for.inc15

for.inc15:                                        ; preds = %for.body14
  %24 = load i32, ptr %i, align 4
  %inc16 = add i32 %24, 1
  store i32 %inc16, ptr %i, align 4
  br label %for.cond11, !llvm.loop !559

for.end17:                                        ; preds = %for.cond11
  br label %if.end

if.end:                                           ; preds = %for.end17, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmorn_mm(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %call = call ptr @riscv_cpu_cfg(ptr noundef %2)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call, i32 0, i32 98
  %3 = load i16, ptr %vlen, align 8
  %conv2 = zext i16 %3 to i32
  store i32 %conv2, ptr %total_elems, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta_all_1s(i32 noundef %4)
  store i32 %call3, ptr %vta_all_1s, align 4
  %5 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %vstart, align 8
  %conv4 = trunc i64 %6 to i32
  store i32 %conv4, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %vs1.addr, align 8
  %10 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %9, i32 noundef %10)
  store i32 %call6, ptr %a, align 4
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %11, i32 noundef %12)
  store i32 %call7, ptr %b, align 4
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i, align 4
  %15 = load i32, ptr %b, align 4
  %16 = load i32, ptr %a, align 4
  %tobool = icmp ne i32 %16, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %or = or i32 %15, %lnot.ext
  %conv8 = trunc i32 %or to i8
  call void @vext_set_elem_mask(ptr noundef %13, i32 noundef %14, i8 noundef zeroext %conv8)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !560

for.end:                                          ; preds = %for.cond
  %18 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %18, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %19 = load i32, ptr %vta_all_1s, align 4
  %tobool10 = icmp ne i32 %19, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc15, %if.then
  %20 = load i32, ptr %i, align 4
  %21 = load i32, ptr %total_elems, align 4
  %cmp12 = icmp ult i32 %20, %21
  br i1 %cmp12, label %for.body14, label %for.end17

for.body14:                                       ; preds = %for.cond11
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %22, i32 noundef %23, i8 noundef zeroext 1)
  br label %for.inc15

for.inc15:                                        ; preds = %for.body14
  %24 = load i32, ptr %i, align 4
  %inc16 = add i32 %24, 1
  store i32 %inc16, ptr %i, align 4
  br label %for.cond11, !llvm.loop !561

for.end17:                                        ; preds = %for.cond11
  br label %if.end

if.end:                                           ; preds = %for.end17, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmxnor_mm(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %call = call ptr @riscv_cpu_cfg(ptr noundef %2)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call, i32 0, i32 98
  %3 = load i16, ptr %vlen, align 8
  %conv2 = zext i16 %3 to i32
  store i32 %conv2, ptr %total_elems, align 4
  %4 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta_all_1s(i32 noundef %4)
  store i32 %call3, ptr %vta_all_1s, align 4
  %5 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %vstart, align 8
  %conv4 = trunc i64 %6 to i32
  store i32 %conv4, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %vs1.addr, align 8
  %10 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %9, i32 noundef %10)
  store i32 %call6, ptr %a, align 4
  %11 = load ptr, ptr %vs2.addr, align 8
  %12 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %11, i32 noundef %12)
  store i32 %call7, ptr %b, align 4
  %13 = load ptr, ptr %vd.addr, align 8
  %14 = load i32, ptr %i, align 4
  %15 = load i32, ptr %b, align 4
  %16 = load i32, ptr %a, align 4
  %xor = xor i32 %15, %16
  %tobool = icmp ne i32 %xor, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %conv8 = trunc i32 %lnot.ext to i8
  call void @vext_set_elem_mask(ptr noundef %13, i32 noundef %14, i8 noundef zeroext %conv8)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !562

for.end:                                          ; preds = %for.cond
  %18 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %18, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %19 = load i32, ptr %vta_all_1s, align 4
  %tobool10 = icmp ne i32 %19, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc15, %if.then
  %20 = load i32, ptr %i, align 4
  %21 = load i32, ptr %total_elems, align 4
  %cmp12 = icmp ult i32 %20, %21
  br i1 %cmp12, label %for.body14, label %for.end17

for.body14:                                       ; preds = %for.cond11
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %22, i32 noundef %23, i8 noundef zeroext 1)
  br label %for.inc15

for.inc15:                                        ; preds = %for.body14
  %24 = load i32, ptr %i, align 4
  %inc16 = add i32 %24, 1
  store i32 %inc16, ptr %i, align 4
  br label %for.cond11, !llvm.loop !563

for.end17:                                        ; preds = %for.cond11
  br label %if.end

if.end:                                           ; preds = %for.end17, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @helper_vcpop_m(ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %cnt = alloca i64, align 8
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  store i64 0, ptr %cnt, align 8
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %3, i32 0, i32 6
  %4 = load i64, ptr %vstart, align 8
  %conv2 = trunc i64 %4 to i32
  store i32 %conv2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, ptr %i, align 4
  %6 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %8 = load ptr, ptr %v0.addr, align 8
  %9 = load i32, ptr %i, align 4
  %call4 = call i32 @vext_elem_mask(ptr noundef %8, i32 noundef %9)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then, label %if.end9

if.then:                                          ; preds = %lor.lhs.false, %for.body
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %10, i32 noundef %11)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then
  %12 = load i64, ptr %cnt, align 8
  %inc = add i64 %12, 1
  store i64 %inc, ptr %cnt, align 8
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.then
  br label %if.end9

if.end9:                                          ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %13 = load i32, ptr %i, align 4
  %inc10 = add i32 %13, 1
  store i32 %inc10, ptr %i, align 4
  br label %for.cond, !llvm.loop !564

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %14, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %15 = load i64, ptr %cnt, align 8
  ret i64 %15
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @helper_vfirst_m(ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %retval = alloca i64, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %3, i32 0, i32 6
  %4 = load i64, ptr %vstart, align 8
  %conv2 = trunc i64 %4 to i32
  store i32 %conv2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, ptr %i, align 4
  %6 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %8 = load ptr, ptr %v0.addr, align 8
  %9 = load i32, ptr %i, align 4
  %call4 = call i32 @vext_elem_mask(ptr noundef %8, i32 noundef %9)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then, label %if.end10

if.then:                                          ; preds = %lor.lhs.false, %for.body
  %10 = load ptr, ptr %vs2.addr, align 8
  %11 = load i32, ptr %i, align 4
  %call6 = call i32 @vext_elem_mask(ptr noundef %10, i32 noundef %11)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then
  %12 = load i32, ptr %i, align 4
  %conv9 = sext i32 %12 to i64
  store i64 %conv9, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end10

if.end10:                                         ; preds = %if.end, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end10
  %13 = load i32, ptr %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !565

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %14, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  store i64 -1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then8
  %15 = load i64, ptr %retval, align 8
  ret i64 %15
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsbf_m(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs2.addr, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  call void @vmsetm(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, i32 noundef %4, i32 noundef 3)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vmsetm(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc, i32 noundef %type) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta_all_1s = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  %first_mask_bit = alloca i8, align 1
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  store i32 %type, ptr %type.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %3)
  %vlen = getelementptr inbounds %struct.RISCVCPUConfig, ptr %call2, i32 0, i32 98
  %4 = load i16, ptr %vlen, align 8
  %conv3 = zext i16 %4 to i32
  store i32 %conv3, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vta_all_1s(i32 noundef %5)
  store i32 %call4, ptr %vta_all_1s, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vma(i32 noundef %6)
  store i32 %call5, ptr %vma, align 4
  store i8 0, ptr %first_mask_bit, align 1
  %7 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 6
  %8 = load i64, ptr %vstart, align 8
  %conv6 = trunc i64 %8 to i32
  store i32 %conv6, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %v0.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call8 = call i32 @vext_elem_mask(ptr noundef %12, i32 noundef %13)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %14 = load i32, ptr %vma, align 4
  %tobool10 = icmp ne i32 %14, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %15, i32 noundef %16, i8 noundef zeroext 1)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then
  br label %for.inc

if.end12:                                         ; preds = %land.lhs.true, %for.body
  %17 = load i8, ptr %first_mask_bit, align 1
  %tobool13 = trunc i8 %17 to i1
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end12
  %18 = load ptr, ptr %vd.addr, align 8
  %19 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %18, i32 noundef %19, i8 noundef zeroext 0)
  br label %for.inc

if.end15:                                         ; preds = %if.end12
  %20 = load ptr, ptr %vs2.addr, align 8
  %21 = load i32, ptr %i, align 4
  %call16 = call i32 @vext_elem_mask(ptr noundef %20, i32 noundef %21)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %if.else23

if.then18:                                        ; preds = %if.end15
  store i8 1, ptr %first_mask_bit, align 1
  %22 = load i32, ptr %type.addr, align 4
  %cmp19 = icmp eq i32 %22, 3
  br i1 %cmp19, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.then18
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %23, i32 noundef %24, i8 noundef zeroext 0)
  br label %if.end22

if.else:                                          ; preds = %if.then18
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %25, i32 noundef %26, i8 noundef zeroext 1)
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then21
  br label %if.end29

if.else23:                                        ; preds = %if.end15
  %27 = load i32, ptr %type.addr, align 4
  %cmp24 = icmp eq i32 %27, 1
  br i1 %cmp24, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else23
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %28, i32 noundef %29, i8 noundef zeroext 0)
  br label %if.end28

if.else27:                                        ; preds = %if.else23
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %30, i32 noundef %31, i8 noundef zeroext 1)
  br label %if.end28

if.end28:                                         ; preds = %if.else27, %if.then26
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.end22
  br label %for.inc

for.inc:                                          ; preds = %if.end29, %if.then14, %if.end
  %32 = load i32, ptr %i, align 4
  %inc = add i32 %32, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !566

for.end:                                          ; preds = %for.cond
  %33 = load ptr, ptr %env.addr, align 8
  %vstart30 = getelementptr inbounds %struct.CPUArchState, ptr %33, i32 0, i32 6
  store i64 0, ptr %vstart30, align 8
  %34 = load i32, ptr %vta_all_1s, align 4
  %tobool31 = icmp ne i32 %34, 0
  br i1 %tobool31, label %if.then32, label %if.end40

if.then32:                                        ; preds = %for.end
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc37, %if.then32
  %35 = load i32, ptr %i, align 4
  %36 = load i32, ptr %total_elems, align 4
  %cmp34 = icmp ult i32 %35, %36
  br i1 %cmp34, label %for.body36, label %for.end39

for.body36:                                       ; preds = %for.cond33
  %37 = load ptr, ptr %vd.addr, align 8
  %38 = load i32, ptr %i, align 4
  call void @vext_set_elem_mask(ptr noundef %37, i32 noundef %38, i8 noundef zeroext 1)
  br label %for.inc37

for.inc37:                                        ; preds = %for.body36
  %39 = load i32, ptr %i, align 4
  %inc38 = add i32 %39, 1
  store i32 %inc38, ptr %i, align 4
  br label %for.cond33, !llvm.loop !567

for.end39:                                        ; preds = %for.cond33
  br label %if.end40

if.end40:                                         ; preds = %for.end39, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsif_m(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs2.addr, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  call void @vmsetm(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, i32 noundef %4, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmsof_m(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load ptr, ptr %vs2.addr, align 8
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  call void @vmsetm(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, i32 noundef %4, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_viota_m_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %sum = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  store i32 0, ptr %sum, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %sum, align 4
  %conv10 = trunc i32 %21 to i8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %23 to i64
  %add.ptr = getelementptr i8, ptr %22, i64 %idx.ext
  store i8 %conv10, ptr %add.ptr, align 1
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %call11 = call i32 @vext_elem_mask(ptr noundef %24, i32 noundef %25)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  %26 = load i32, ptr %sum, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %sum, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.then
  %27 = load i32, ptr %i, align 4
  %inc15 = add i32 %27, 1
  store i32 %inc15, ptr %i, align 4
  br label %for.cond, !llvm.loop !568

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %vta, align 4
  %31 = load i32, ptr %vl, align 4
  %32 = load i32, ptr %esz, align 4
  %mul17 = mul i32 %31, %32
  %33 = load i32, ptr %total_elems, align 4
  %34 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %33, %34
  call void @vext_set_elems_1s(ptr noundef %29, i32 noundef %30, i32 noundef %mul17, i32 noundef %mul18)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_viota_m_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %sum = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  store i32 0, ptr %sum, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %sum, align 4
  %conv10 = trunc i32 %21 to i16
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %23 to i64
  %add.ptr = getelementptr i16, ptr %22, i64 %idx.ext
  store i16 %conv10, ptr %add.ptr, align 2
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %call11 = call i32 @vext_elem_mask(ptr noundef %24, i32 noundef %25)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  %26 = load i32, ptr %sum, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %sum, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.then
  %27 = load i32, ptr %i, align 4
  %inc15 = add i32 %27, 1
  store i32 %inc15, ptr %i, align 4
  br label %for.cond, !llvm.loop !569

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %vta, align 4
  %31 = load i32, ptr %vl, align 4
  %32 = load i32, ptr %esz, align 4
  %mul17 = mul i32 %31, %32
  %33 = load i32, ptr %total_elems, align 4
  %34 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %33, %34
  call void @vext_set_elems_1s(ptr noundef %29, i32 noundef %30, i32 noundef %mul17, i32 noundef %mul18)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_viota_m_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %sum = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  store i32 0, ptr %sum, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %sum, align 4
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %23 to i64
  %add.ptr = getelementptr i32, ptr %22, i64 %idx.ext
  store i32 %21, ptr %add.ptr, align 4
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %call10 = call i32 @vext_elem_mask(ptr noundef %24, i32 noundef %25)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  %26 = load i32, ptr %sum, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %sum, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then
  %27 = load i32, ptr %i, align 4
  %inc14 = add i32 %27, 1
  store i32 %inc14, ptr %i, align 4
  br label %for.cond, !llvm.loop !570

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart15 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart15, align 8
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %vta, align 4
  %31 = load i32, ptr %vl, align 4
  %32 = load i32, ptr %esz, align 4
  %mul16 = mul i32 %31, %32
  %33 = load i32, ptr %total_elems, align 4
  %34 = load i32, ptr %esz, align 4
  %mul17 = mul i32 %33, %34
  call void @vext_set_elems_1s(ptr noundef %29, i32 noundef %30, i32 noundef %mul16, i32 noundef %mul17)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_viota_m_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %sum = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  store i32 0, ptr %sum, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %sum, align 4
  %conv10 = zext i32 %21 to i64
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %23 to i64
  %add.ptr = getelementptr i64, ptr %22, i64 %idx.ext
  store i64 %conv10, ptr %add.ptr, align 8
  %24 = load ptr, ptr %vs2.addr, align 8
  %25 = load i32, ptr %i, align 4
  %call11 = call i32 @vext_elem_mask(ptr noundef %24, i32 noundef %25)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  %26 = load i32, ptr %sum, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %sum, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end14, %if.then
  %27 = load i32, ptr %i, align 4
  %inc15 = add i32 %27, 1
  store i32 %inc15, ptr %i, align 4
  br label %for.cond, !llvm.loop !571

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %env.addr, align 8
  %vstart16 = getelementptr inbounds %struct.CPUArchState, ptr %28, i32 0, i32 6
  store i64 0, ptr %vstart16, align 8
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %vta, align 4
  %31 = load i32, ptr %vl, align 4
  %32 = load i32, ptr %esz, align 4
  %mul17 = mul i32 %31, %32
  %33 = load i32, ptr %total_elems, align 4
  %34 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %33, %34
  call void @vext_set_elems_1s(ptr noundef %29, i32 noundef %30, i32 noundef %mul17, i32 noundef %mul18)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vid_v_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %i, align 4
  %conv10 = trunc i32 %21 to i8
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %23 to i64
  %add.ptr = getelementptr i8, ptr %22, i64 %idx.ext
  store i8 %conv10, ptr %add.ptr, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !572

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %vta, align 4
  %28 = load i32, ptr %vl, align 4
  %29 = load i32, ptr %esz, align 4
  %mul12 = mul i32 %28, %29
  %30 = load i32, ptr %total_elems, align 4
  %31 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %30, %31
  call void @vext_set_elems_1s(ptr noundef %26, i32 noundef %27, i32 noundef %mul12, i32 noundef %mul13)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vid_v_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %i, align 4
  %conv10 = trunc i32 %21 to i16
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %23 to i64
  %add.ptr = getelementptr i16, ptr %22, i64 %idx.ext
  store i16 %conv10, ptr %add.ptr, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !573

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %vta, align 4
  %28 = load i32, ptr %vl, align 4
  %29 = load i32, ptr %esz, align 4
  %mul12 = mul i32 %28, %29
  %30 = load i32, ptr %total_elems, align 4
  %31 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %30, %31
  call void @vext_set_elems_1s(ptr noundef %26, i32 noundef %27, i32 noundef %mul12, i32 noundef %mul13)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vid_v_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %23 to i64
  %add.ptr = getelementptr i32, ptr %22, i64 %idx.ext
  store i32 %21, ptr %add.ptr, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !574

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart10 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart10, align 8
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %vta, align 4
  %28 = load i32, ptr %vl, align 4
  %29 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %28, %29
  %30 = load i32, ptr %total_elems, align 4
  %31 = load i32, ptr %esz, align 4
  %mul12 = mul i32 %30, %31
  call void @vext_set_elems_1s(ptr noundef %26, i32 noundef %27, i32 noundef %mul11, i32 noundef %mul12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vid_v_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %i, align 4
  %conv10 = sext i32 %21 to i64
  %22 = load ptr, ptr %vd.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %23 to i64
  %add.ptr = getelementptr i64, ptr %22, i64 %idx.ext
  store i64 %conv10, ptr %add.ptr, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %24 = load i32, ptr %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !575

for.end:                                          ; preds = %for.cond
  %25 = load ptr, ptr %env.addr, align 8
  %vstart11 = getelementptr inbounds %struct.CPUArchState, ptr %25, i32 0, i32 6
  store i64 0, ptr %vstart11, align 8
  %26 = load ptr, ptr %vd.addr, align 8
  %27 = load i32, ptr %vta, align 4
  %28 = load i32, ptr %vl, align 4
  %29 = load i32, ptr %esz, align 4
  %mul12 = mul i32 %28, %29
  %30 = load i32, ptr %total_elems, align 4
  %31 = load i32, ptr %esz, align 4
  %mul13 = mul i32 %30, %31
  call void @vext_set_elems_1s(ptr noundef %26, i32 noundef %27, i32 noundef %mul12, i32 noundef %mul13)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslideup_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %offset = alloca i64, align 8
  %i_min = alloca i64, align 8
  %i = alloca i64, align 8
  %_a2 = alloca i64, align 8
  %_b3 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load i64, ptr %s1.addr, align 8
  store i64 %8, ptr %offset, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %vstart, align 8
  store i64 %10, ptr %_a2, align 8
  %11 = load i64, ptr %offset, align 8
  store i64 %11, ptr %_b3, align 8
  %12 = load i64, ptr %_a2, align 8
  %13 = load i64, ptr %_b3, align 8
  %cmp = icmp ugt i64 %12, %13
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %14 = load i64, ptr %_a2, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %15 = load i64, ptr %_b3, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %14, %cond.true ], [ %15, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %16 = load i64, ptr %tmp, align 8
  store i64 %16, ptr %i_min, align 8
  %17 = load i64, ptr %i_min, align 8
  store i64 %17, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %18 = load i64, ptr %i, align 8
  %19 = load i32, ptr %vl, align 4
  %conv6 = zext i32 %19 to i64
  %cmp7 = icmp ult i64 %18, %conv6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %20, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %21 = load ptr, ptr %v0.addr, align 8
  %22 = load i64, ptr %i, align 8
  %conv9 = trunc i64 %22 to i32
  %call10 = call i32 @vext_elem_mask(ptr noundef %21, i32 noundef %conv9)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vma, align 4
  %25 = load i64, ptr %i, align 8
  %26 = load i32, ptr %esz, align 4
  %conv12 = zext i32 %26 to i64
  %mul = mul i64 %25, %conv12
  %conv13 = trunc i64 %mul to i32
  %27 = load i64, ptr %i, align 8
  %add = add i64 %27, 1
  %28 = load i32, ptr %esz, align 4
  %conv14 = zext i32 %28 to i64
  %mul15 = mul i64 %add, %conv14
  %conv16 = trunc i64 %mul15 to i32
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %conv13, i32 noundef %conv16)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %29 = load ptr, ptr %vs2.addr, align 8
  %30 = load i64, ptr %i, align 8
  %31 = load i64, ptr %offset, align 8
  %sub = sub i64 %30, %31
  %add.ptr = getelementptr i8, ptr %29, i64 %sub
  %32 = load i8, ptr %add.ptr, align 1
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i64, ptr %i, align 8
  %add.ptr17 = getelementptr i8, ptr %33, i64 %34
  store i8 %32, ptr %add.ptr17, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %35 = load i64, ptr %i, align 8
  %inc = add i64 %35, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !576

for.end:                                          ; preds = %for.cond
  %36 = load ptr, ptr %vd.addr, align 8
  %37 = load i32, ptr %vta, align 4
  %38 = load i32, ptr %vl, align 4
  %39 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %38, %39
  %40 = load i32, ptr %total_elems, align 4
  %41 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %40, %41
  call void @vext_set_elems_1s(ptr noundef %36, i32 noundef %37, i32 noundef %mul18, i32 noundef %mul19)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslideup_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %offset = alloca i64, align 8
  %i_min = alloca i64, align 8
  %i = alloca i64, align 8
  %_a4 = alloca i64, align 8
  %_b5 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load i64, ptr %s1.addr, align 8
  store i64 %8, ptr %offset, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %vstart, align 8
  store i64 %10, ptr %_a4, align 8
  %11 = load i64, ptr %offset, align 8
  store i64 %11, ptr %_b5, align 8
  %12 = load i64, ptr %_a4, align 8
  %13 = load i64, ptr %_b5, align 8
  %cmp = icmp ugt i64 %12, %13
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %14 = load i64, ptr %_a4, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %15 = load i64, ptr %_b5, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %14, %cond.true ], [ %15, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %16 = load i64, ptr %tmp, align 8
  store i64 %16, ptr %i_min, align 8
  %17 = load i64, ptr %i_min, align 8
  store i64 %17, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %18 = load i64, ptr %i, align 8
  %19 = load i32, ptr %vl, align 4
  %conv6 = zext i32 %19 to i64
  %cmp7 = icmp ult i64 %18, %conv6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %20, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %21 = load ptr, ptr %v0.addr, align 8
  %22 = load i64, ptr %i, align 8
  %conv9 = trunc i64 %22 to i32
  %call10 = call i32 @vext_elem_mask(ptr noundef %21, i32 noundef %conv9)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vma, align 4
  %25 = load i64, ptr %i, align 8
  %26 = load i32, ptr %esz, align 4
  %conv12 = zext i32 %26 to i64
  %mul = mul i64 %25, %conv12
  %conv13 = trunc i64 %mul to i32
  %27 = load i64, ptr %i, align 8
  %add = add i64 %27, 1
  %28 = load i32, ptr %esz, align 4
  %conv14 = zext i32 %28 to i64
  %mul15 = mul i64 %add, %conv14
  %conv16 = trunc i64 %mul15 to i32
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %conv13, i32 noundef %conv16)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %29 = load ptr, ptr %vs2.addr, align 8
  %30 = load i64, ptr %i, align 8
  %31 = load i64, ptr %offset, align 8
  %sub = sub i64 %30, %31
  %add.ptr = getelementptr i16, ptr %29, i64 %sub
  %32 = load i16, ptr %add.ptr, align 2
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i64, ptr %i, align 8
  %add.ptr17 = getelementptr i16, ptr %33, i64 %34
  store i16 %32, ptr %add.ptr17, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %35 = load i64, ptr %i, align 8
  %inc = add i64 %35, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !577

for.end:                                          ; preds = %for.cond
  %36 = load ptr, ptr %vd.addr, align 8
  %37 = load i32, ptr %vta, align 4
  %38 = load i32, ptr %vl, align 4
  %39 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %38, %39
  %40 = load i32, ptr %total_elems, align 4
  %41 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %40, %41
  call void @vext_set_elems_1s(ptr noundef %36, i32 noundef %37, i32 noundef %mul18, i32 noundef %mul19)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslideup_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %offset = alloca i64, align 8
  %i_min = alloca i64, align 8
  %i = alloca i64, align 8
  %_a6 = alloca i64, align 8
  %_b7 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load i64, ptr %s1.addr, align 8
  store i64 %8, ptr %offset, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %vstart, align 8
  store i64 %10, ptr %_a6, align 8
  %11 = load i64, ptr %offset, align 8
  store i64 %11, ptr %_b7, align 8
  %12 = load i64, ptr %_a6, align 8
  %13 = load i64, ptr %_b7, align 8
  %cmp = icmp ugt i64 %12, %13
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %14 = load i64, ptr %_a6, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %15 = load i64, ptr %_b7, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %14, %cond.true ], [ %15, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %16 = load i64, ptr %tmp, align 8
  store i64 %16, ptr %i_min, align 8
  %17 = load i64, ptr %i_min, align 8
  store i64 %17, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %18 = load i64, ptr %i, align 8
  %19 = load i32, ptr %vl, align 4
  %conv6 = zext i32 %19 to i64
  %cmp7 = icmp ult i64 %18, %conv6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %20, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %21 = load ptr, ptr %v0.addr, align 8
  %22 = load i64, ptr %i, align 8
  %conv9 = trunc i64 %22 to i32
  %call10 = call i32 @vext_elem_mask(ptr noundef %21, i32 noundef %conv9)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vma, align 4
  %25 = load i64, ptr %i, align 8
  %26 = load i32, ptr %esz, align 4
  %conv12 = zext i32 %26 to i64
  %mul = mul i64 %25, %conv12
  %conv13 = trunc i64 %mul to i32
  %27 = load i64, ptr %i, align 8
  %add = add i64 %27, 1
  %28 = load i32, ptr %esz, align 4
  %conv14 = zext i32 %28 to i64
  %mul15 = mul i64 %add, %conv14
  %conv16 = trunc i64 %mul15 to i32
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %conv13, i32 noundef %conv16)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %29 = load ptr, ptr %vs2.addr, align 8
  %30 = load i64, ptr %i, align 8
  %31 = load i64, ptr %offset, align 8
  %sub = sub i64 %30, %31
  %add.ptr = getelementptr i32, ptr %29, i64 %sub
  %32 = load i32, ptr %add.ptr, align 4
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i64, ptr %i, align 8
  %add.ptr17 = getelementptr i32, ptr %33, i64 %34
  store i32 %32, ptr %add.ptr17, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %35 = load i64, ptr %i, align 8
  %inc = add i64 %35, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !578

for.end:                                          ; preds = %for.cond
  %36 = load ptr, ptr %vd.addr, align 8
  %37 = load i32, ptr %vta, align 4
  %38 = load i32, ptr %vl, align 4
  %39 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %38, %39
  %40 = load i32, ptr %total_elems, align 4
  %41 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %40, %41
  call void @vext_set_elems_1s(ptr noundef %36, i32 noundef %37, i32 noundef %mul18, i32 noundef %mul19)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslideup_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %offset = alloca i64, align 8
  %i_min = alloca i64, align 8
  %i = alloca i64, align 8
  %_a8 = alloca i64, align 8
  %_b9 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load i64, ptr %s1.addr, align 8
  store i64 %8, ptr %offset, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %vstart, align 8
  store i64 %10, ptr %_a8, align 8
  %11 = load i64, ptr %offset, align 8
  store i64 %11, ptr %_b9, align 8
  %12 = load i64, ptr %_a8, align 8
  %13 = load i64, ptr %_b9, align 8
  %cmp = icmp ugt i64 %12, %13
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %14 = load i64, ptr %_a8, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %15 = load i64, ptr %_b9, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %14, %cond.true ], [ %15, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %16 = load i64, ptr %tmp, align 8
  store i64 %16, ptr %i_min, align 8
  %17 = load i64, ptr %i_min, align 8
  store i64 %17, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %18 = load i64, ptr %i, align 8
  %19 = load i32, ptr %vl, align 4
  %conv6 = zext i32 %19 to i64
  %cmp7 = icmp ult i64 %18, %conv6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %20, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %21 = load ptr, ptr %v0.addr, align 8
  %22 = load i64, ptr %i, align 8
  %conv9 = trunc i64 %22 to i32
  %call10 = call i32 @vext_elem_mask(ptr noundef %21, i32 noundef %conv9)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %vma, align 4
  %25 = load i64, ptr %i, align 8
  %26 = load i32, ptr %esz, align 4
  %conv12 = zext i32 %26 to i64
  %mul = mul i64 %25, %conv12
  %conv13 = trunc i64 %mul to i32
  %27 = load i64, ptr %i, align 8
  %add = add i64 %27, 1
  %28 = load i32, ptr %esz, align 4
  %conv14 = zext i32 %28 to i64
  %mul15 = mul i64 %add, %conv14
  %conv16 = trunc i64 %mul15 to i32
  call void @vext_set_elems_1s(ptr noundef %23, i32 noundef %24, i32 noundef %conv13, i32 noundef %conv16)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %29 = load ptr, ptr %vs2.addr, align 8
  %30 = load i64, ptr %i, align 8
  %31 = load i64, ptr %offset, align 8
  %sub = sub i64 %30, %31
  %add.ptr = getelementptr i64, ptr %29, i64 %sub
  %32 = load i64, ptr %add.ptr, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i64, ptr %i, align 8
  %add.ptr17 = getelementptr i64, ptr %33, i64 %34
  store i64 %32, ptr %add.ptr17, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %35 = load i64, ptr %i, align 8
  %inc = add i64 %35, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !579

for.end:                                          ; preds = %for.cond
  %36 = load ptr, ptr %vd.addr, align 8
  %37 = load i32, ptr %vta, align 4
  %38 = load i32, ptr %vl, align 4
  %39 = load i32, ptr %esz, align 4
  %mul18 = mul i32 %38, %39
  %40 = load i32, ptr %total_elems, align 4
  %41 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %40, %41
  call void @vext_set_elems_1s(ptr noundef %36, i32 noundef %37, i32 noundef %mul18, i32 noundef %mul19)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslidedown_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i_max = alloca i64, align 8
  %i_min = alloca i64, align 8
  %i = alloca i64, align 8
  %_a10 = alloca i64, align 8
  %_b11 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %_a12 = alloca i64, align 8
  %_b13 = alloca i64, align 8
  %tmp17 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load i64, ptr %s1.addr, align 8
  %10 = load i32, ptr %vlmax, align 4
  %conv7 = zext i32 %10 to i64
  %cmp = icmp ult i64 %9, %conv7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %11 = load i32, ptr %vlmax, align 4
  %conv9 = zext i32 %11 to i64
  %12 = load i64, ptr %s1.addr, align 8
  %sub = sub i64 %conv9, %12
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %_a10, align 8
  %13 = load i32, ptr %vl, align 4
  %conv10 = zext i32 %13 to i64
  store i64 %conv10, ptr %_b11, align 8
  %14 = load i64, ptr %_a10, align 8
  %15 = load i64, ptr %_b11, align 8
  %cmp11 = icmp ult i64 %14, %15
  br i1 %cmp11, label %cond.true13, label %cond.false14

cond.true13:                                      ; preds = %cond.end
  %16 = load i64, ptr %_a10, align 8
  br label %cond.end15

cond.false14:                                     ; preds = %cond.end
  %17 = load i64, ptr %_b11, align 8
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false14, %cond.true13
  %cond16 = phi i64 [ %16, %cond.true13 ], [ %17, %cond.false14 ]
  store i64 %cond16, ptr %tmp, align 8
  %18 = load i64, ptr %tmp, align 8
  store i64 %18, ptr %i_min, align 8
  %19 = load i64, ptr %i_min, align 8
  store i64 %19, ptr %_a12, align 8
  %20 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %20, i32 0, i32 6
  %21 = load i64, ptr %vstart, align 8
  store i64 %21, ptr %_b13, align 8
  %22 = load i64, ptr %_a12, align 8
  %23 = load i64, ptr %_b13, align 8
  %cmp18 = icmp ugt i64 %22, %23
  br i1 %cmp18, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %cond.end15
  %24 = load i64, ptr %_a12, align 8
  br label %cond.end22

cond.false21:                                     ; preds = %cond.end15
  %25 = load i64, ptr %_b13, align 8
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false21, %cond.true20
  %cond23 = phi i64 [ %24, %cond.true20 ], [ %25, %cond.false21 ]
  store i64 %cond23, ptr %tmp17, align 8
  %26 = load i64, ptr %tmp17, align 8
  store i64 %26, ptr %i_max, align 8
  %27 = load ptr, ptr %env.addr, align 8
  %vstart24 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  %28 = load i64, ptr %vstart24, align 8
  store i64 %28, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end22
  %29 = load i64, ptr %i, align 8
  %30 = load i64, ptr %i_max, align 8
  %cmp25 = icmp ult i64 %29, %30
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %31 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %31, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %32 = load ptr, ptr %v0.addr, align 8
  %33 = load i64, ptr %i, align 8
  %conv27 = trunc i64 %33 to i32
  %call28 = call i32 @vext_elem_mask(ptr noundef %32, i32 noundef %conv27)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %34 = load ptr, ptr %vd.addr, align 8
  %35 = load i32, ptr %vma, align 4
  %36 = load i64, ptr %i, align 8
  %37 = load i32, ptr %esz, align 4
  %conv30 = zext i32 %37 to i64
  %mul = mul i64 %36, %conv30
  %conv31 = trunc i64 %mul to i32
  %38 = load i64, ptr %i, align 8
  %add = add i64 %38, 1
  %39 = load i32, ptr %esz, align 4
  %conv32 = zext i32 %39 to i64
  %mul33 = mul i64 %add, %conv32
  %conv34 = trunc i64 %mul33 to i32
  call void @vext_set_elems_1s(ptr noundef %34, i32 noundef %35, i32 noundef %conv31, i32 noundef %conv34)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %40 = load ptr, ptr %vs2.addr, align 8
  %41 = load i64, ptr %i, align 8
  %42 = load i64, ptr %s1.addr, align 8
  %add35 = add i64 %41, %42
  %add.ptr = getelementptr i8, ptr %40, i64 %add35
  %43 = load i8, ptr %add.ptr, align 1
  %44 = load ptr, ptr %vd.addr, align 8
  %45 = load i64, ptr %i, align 8
  %add.ptr36 = getelementptr i8, ptr %44, i64 %45
  store i8 %43, ptr %add.ptr36, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %46 = load i64, ptr %i, align 8
  %inc = add i64 %46, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !580

for.end:                                          ; preds = %for.cond
  %47 = load i64, ptr %i_max, align 8
  store i64 %47, ptr %i, align 8
  br label %for.cond37

for.cond37:                                       ; preds = %for.inc49, %for.end
  %48 = load i64, ptr %i, align 8
  %49 = load i32, ptr %vl, align 4
  %conv38 = zext i32 %49 to i64
  %cmp39 = icmp ult i64 %48, %conv38
  br i1 %cmp39, label %for.body41, label %for.end51

for.body41:                                       ; preds = %for.cond37
  %50 = load i32, ptr %vm, align 4
  %tobool42 = icmp ne i32 %50, 0
  br i1 %tobool42, label %if.then46, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body41
  %51 = load ptr, ptr %v0.addr, align 8
  %52 = load i64, ptr %i, align 8
  %conv43 = trunc i64 %52 to i32
  %call44 = call i32 @vext_elem_mask(ptr noundef %51, i32 noundef %conv43)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %lor.lhs.false, %for.body41
  %53 = load ptr, ptr %vd.addr, align 8
  %54 = load i64, ptr %i, align 8
  %add.ptr47 = getelementptr i8, ptr %53, i64 %54
  store i8 0, ptr %add.ptr47, align 1
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %lor.lhs.false
  br label %for.inc49

for.inc49:                                        ; preds = %if.end48
  %55 = load i64, ptr %i, align 8
  %inc50 = add i64 %55, 1
  store i64 %inc50, ptr %i, align 8
  br label %for.cond37, !llvm.loop !581

for.end51:                                        ; preds = %for.cond37
  %56 = load ptr, ptr %env.addr, align 8
  %vstart52 = getelementptr inbounds %struct.CPUArchState, ptr %56, i32 0, i32 6
  store i64 0, ptr %vstart52, align 8
  %57 = load ptr, ptr %vd.addr, align 8
  %58 = load i32, ptr %vta, align 4
  %59 = load i32, ptr %vl, align 4
  %60 = load i32, ptr %esz, align 4
  %mul53 = mul i32 %59, %60
  %61 = load i32, ptr %total_elems, align 4
  %62 = load i32, ptr %esz, align 4
  %mul54 = mul i32 %61, %62
  call void @vext_set_elems_1s(ptr noundef %57, i32 noundef %58, i32 noundef %mul53, i32 noundef %mul54)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vext_max_elems(i32 noundef %desc, i32 noundef %log2_esz) #0 {
entry:
  %desc.addr = alloca i32, align 4
  %log2_esz.addr = alloca i32, align 4
  %vlenb = alloca i32, align 4
  %scale = alloca i32, align 4
  store i32 %desc, ptr %desc.addr, align 4
  store i32 %log2_esz, ptr %log2_esz.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i64 @simd_maxsz(i32 noundef %0)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %vlenb, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call1 = call i32 @vext_lmul(i32 noundef %1)
  %2 = load i32, ptr %log2_esz.addr, align 4
  %sub = sub i32 %call1, %2
  store i32 %sub, ptr %scale, align 4
  %3 = load i32, ptr %scale, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i32, ptr %vlenb, align 4
  %5 = load i32, ptr %scale, align 4
  %sub3 = sub i32 0, %5
  %shr = lshr i32 %4, %sub3
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i32, ptr %vlenb, align 4
  %7 = load i32, ptr %scale, align 4
  %shl = shl i32 %6, %7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %shr, %cond.true ], [ %shl, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslidedown_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i_max = alloca i64, align 8
  %i_min = alloca i64, align 8
  %i = alloca i64, align 8
  %_a14 = alloca i64, align 8
  %_b15 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %_a16 = alloca i64, align 8
  %_b17 = alloca i64, align 8
  %tmp17 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load i64, ptr %s1.addr, align 8
  %10 = load i32, ptr %vlmax, align 4
  %conv7 = zext i32 %10 to i64
  %cmp = icmp ult i64 %9, %conv7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %11 = load i32, ptr %vlmax, align 4
  %conv9 = zext i32 %11 to i64
  %12 = load i64, ptr %s1.addr, align 8
  %sub = sub i64 %conv9, %12
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %_a14, align 8
  %13 = load i32, ptr %vl, align 4
  %conv10 = zext i32 %13 to i64
  store i64 %conv10, ptr %_b15, align 8
  %14 = load i64, ptr %_a14, align 8
  %15 = load i64, ptr %_b15, align 8
  %cmp11 = icmp ult i64 %14, %15
  br i1 %cmp11, label %cond.true13, label %cond.false14

cond.true13:                                      ; preds = %cond.end
  %16 = load i64, ptr %_a14, align 8
  br label %cond.end15

cond.false14:                                     ; preds = %cond.end
  %17 = load i64, ptr %_b15, align 8
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false14, %cond.true13
  %cond16 = phi i64 [ %16, %cond.true13 ], [ %17, %cond.false14 ]
  store i64 %cond16, ptr %tmp, align 8
  %18 = load i64, ptr %tmp, align 8
  store i64 %18, ptr %i_min, align 8
  %19 = load i64, ptr %i_min, align 8
  store i64 %19, ptr %_a16, align 8
  %20 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %20, i32 0, i32 6
  %21 = load i64, ptr %vstart, align 8
  store i64 %21, ptr %_b17, align 8
  %22 = load i64, ptr %_a16, align 8
  %23 = load i64, ptr %_b17, align 8
  %cmp18 = icmp ugt i64 %22, %23
  br i1 %cmp18, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %cond.end15
  %24 = load i64, ptr %_a16, align 8
  br label %cond.end22

cond.false21:                                     ; preds = %cond.end15
  %25 = load i64, ptr %_b17, align 8
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false21, %cond.true20
  %cond23 = phi i64 [ %24, %cond.true20 ], [ %25, %cond.false21 ]
  store i64 %cond23, ptr %tmp17, align 8
  %26 = load i64, ptr %tmp17, align 8
  store i64 %26, ptr %i_max, align 8
  %27 = load ptr, ptr %env.addr, align 8
  %vstart24 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  %28 = load i64, ptr %vstart24, align 8
  store i64 %28, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end22
  %29 = load i64, ptr %i, align 8
  %30 = load i64, ptr %i_max, align 8
  %cmp25 = icmp ult i64 %29, %30
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %31 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %31, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %32 = load ptr, ptr %v0.addr, align 8
  %33 = load i64, ptr %i, align 8
  %conv27 = trunc i64 %33 to i32
  %call28 = call i32 @vext_elem_mask(ptr noundef %32, i32 noundef %conv27)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %34 = load ptr, ptr %vd.addr, align 8
  %35 = load i32, ptr %vma, align 4
  %36 = load i64, ptr %i, align 8
  %37 = load i32, ptr %esz, align 4
  %conv30 = zext i32 %37 to i64
  %mul = mul i64 %36, %conv30
  %conv31 = trunc i64 %mul to i32
  %38 = load i64, ptr %i, align 8
  %add = add i64 %38, 1
  %39 = load i32, ptr %esz, align 4
  %conv32 = zext i32 %39 to i64
  %mul33 = mul i64 %add, %conv32
  %conv34 = trunc i64 %mul33 to i32
  call void @vext_set_elems_1s(ptr noundef %34, i32 noundef %35, i32 noundef %conv31, i32 noundef %conv34)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %40 = load ptr, ptr %vs2.addr, align 8
  %41 = load i64, ptr %i, align 8
  %42 = load i64, ptr %s1.addr, align 8
  %add35 = add i64 %41, %42
  %add.ptr = getelementptr i16, ptr %40, i64 %add35
  %43 = load i16, ptr %add.ptr, align 2
  %44 = load ptr, ptr %vd.addr, align 8
  %45 = load i64, ptr %i, align 8
  %add.ptr36 = getelementptr i16, ptr %44, i64 %45
  store i16 %43, ptr %add.ptr36, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %46 = load i64, ptr %i, align 8
  %inc = add i64 %46, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !582

for.end:                                          ; preds = %for.cond
  %47 = load i64, ptr %i_max, align 8
  store i64 %47, ptr %i, align 8
  br label %for.cond37

for.cond37:                                       ; preds = %for.inc49, %for.end
  %48 = load i64, ptr %i, align 8
  %49 = load i32, ptr %vl, align 4
  %conv38 = zext i32 %49 to i64
  %cmp39 = icmp ult i64 %48, %conv38
  br i1 %cmp39, label %for.body41, label %for.end51

for.body41:                                       ; preds = %for.cond37
  %50 = load i32, ptr %vm, align 4
  %tobool42 = icmp ne i32 %50, 0
  br i1 %tobool42, label %if.then46, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body41
  %51 = load ptr, ptr %v0.addr, align 8
  %52 = load i64, ptr %i, align 8
  %conv43 = trunc i64 %52 to i32
  %call44 = call i32 @vext_elem_mask(ptr noundef %51, i32 noundef %conv43)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %lor.lhs.false, %for.body41
  %53 = load ptr, ptr %vd.addr, align 8
  %54 = load i64, ptr %i, align 8
  %add.ptr47 = getelementptr i16, ptr %53, i64 %54
  store i16 0, ptr %add.ptr47, align 2
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %lor.lhs.false
  br label %for.inc49

for.inc49:                                        ; preds = %if.end48
  %55 = load i64, ptr %i, align 8
  %inc50 = add i64 %55, 1
  store i64 %inc50, ptr %i, align 8
  br label %for.cond37, !llvm.loop !583

for.end51:                                        ; preds = %for.cond37
  %56 = load ptr, ptr %env.addr, align 8
  %vstart52 = getelementptr inbounds %struct.CPUArchState, ptr %56, i32 0, i32 6
  store i64 0, ptr %vstart52, align 8
  %57 = load ptr, ptr %vd.addr, align 8
  %58 = load i32, ptr %vta, align 4
  %59 = load i32, ptr %vl, align 4
  %60 = load i32, ptr %esz, align 4
  %mul53 = mul i32 %59, %60
  %61 = load i32, ptr %total_elems, align 4
  %62 = load i32, ptr %esz, align 4
  %mul54 = mul i32 %61, %62
  call void @vext_set_elems_1s(ptr noundef %57, i32 noundef %58, i32 noundef %mul53, i32 noundef %mul54)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslidedown_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i_max = alloca i64, align 8
  %i_min = alloca i64, align 8
  %i = alloca i64, align 8
  %_a18 = alloca i64, align 8
  %_b19 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %_a20 = alloca i64, align 8
  %_b21 = alloca i64, align 8
  %tmp17 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load i64, ptr %s1.addr, align 8
  %10 = load i32, ptr %vlmax, align 4
  %conv7 = zext i32 %10 to i64
  %cmp = icmp ult i64 %9, %conv7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %11 = load i32, ptr %vlmax, align 4
  %conv9 = zext i32 %11 to i64
  %12 = load i64, ptr %s1.addr, align 8
  %sub = sub i64 %conv9, %12
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %_a18, align 8
  %13 = load i32, ptr %vl, align 4
  %conv10 = zext i32 %13 to i64
  store i64 %conv10, ptr %_b19, align 8
  %14 = load i64, ptr %_a18, align 8
  %15 = load i64, ptr %_b19, align 8
  %cmp11 = icmp ult i64 %14, %15
  br i1 %cmp11, label %cond.true13, label %cond.false14

cond.true13:                                      ; preds = %cond.end
  %16 = load i64, ptr %_a18, align 8
  br label %cond.end15

cond.false14:                                     ; preds = %cond.end
  %17 = load i64, ptr %_b19, align 8
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false14, %cond.true13
  %cond16 = phi i64 [ %16, %cond.true13 ], [ %17, %cond.false14 ]
  store i64 %cond16, ptr %tmp, align 8
  %18 = load i64, ptr %tmp, align 8
  store i64 %18, ptr %i_min, align 8
  %19 = load i64, ptr %i_min, align 8
  store i64 %19, ptr %_a20, align 8
  %20 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %20, i32 0, i32 6
  %21 = load i64, ptr %vstart, align 8
  store i64 %21, ptr %_b21, align 8
  %22 = load i64, ptr %_a20, align 8
  %23 = load i64, ptr %_b21, align 8
  %cmp18 = icmp ugt i64 %22, %23
  br i1 %cmp18, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %cond.end15
  %24 = load i64, ptr %_a20, align 8
  br label %cond.end22

cond.false21:                                     ; preds = %cond.end15
  %25 = load i64, ptr %_b21, align 8
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false21, %cond.true20
  %cond23 = phi i64 [ %24, %cond.true20 ], [ %25, %cond.false21 ]
  store i64 %cond23, ptr %tmp17, align 8
  %26 = load i64, ptr %tmp17, align 8
  store i64 %26, ptr %i_max, align 8
  %27 = load ptr, ptr %env.addr, align 8
  %vstart24 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  %28 = load i64, ptr %vstart24, align 8
  store i64 %28, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end22
  %29 = load i64, ptr %i, align 8
  %30 = load i64, ptr %i_max, align 8
  %cmp25 = icmp ult i64 %29, %30
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %31 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %31, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %32 = load ptr, ptr %v0.addr, align 8
  %33 = load i64, ptr %i, align 8
  %conv27 = trunc i64 %33 to i32
  %call28 = call i32 @vext_elem_mask(ptr noundef %32, i32 noundef %conv27)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %34 = load ptr, ptr %vd.addr, align 8
  %35 = load i32, ptr %vma, align 4
  %36 = load i64, ptr %i, align 8
  %37 = load i32, ptr %esz, align 4
  %conv30 = zext i32 %37 to i64
  %mul = mul i64 %36, %conv30
  %conv31 = trunc i64 %mul to i32
  %38 = load i64, ptr %i, align 8
  %add = add i64 %38, 1
  %39 = load i32, ptr %esz, align 4
  %conv32 = zext i32 %39 to i64
  %mul33 = mul i64 %add, %conv32
  %conv34 = trunc i64 %mul33 to i32
  call void @vext_set_elems_1s(ptr noundef %34, i32 noundef %35, i32 noundef %conv31, i32 noundef %conv34)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %40 = load ptr, ptr %vs2.addr, align 8
  %41 = load i64, ptr %i, align 8
  %42 = load i64, ptr %s1.addr, align 8
  %add35 = add i64 %41, %42
  %add.ptr = getelementptr i32, ptr %40, i64 %add35
  %43 = load i32, ptr %add.ptr, align 4
  %44 = load ptr, ptr %vd.addr, align 8
  %45 = load i64, ptr %i, align 8
  %add.ptr36 = getelementptr i32, ptr %44, i64 %45
  store i32 %43, ptr %add.ptr36, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %46 = load i64, ptr %i, align 8
  %inc = add i64 %46, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !584

for.end:                                          ; preds = %for.cond
  %47 = load i64, ptr %i_max, align 8
  store i64 %47, ptr %i, align 8
  br label %for.cond37

for.cond37:                                       ; preds = %for.inc49, %for.end
  %48 = load i64, ptr %i, align 8
  %49 = load i32, ptr %vl, align 4
  %conv38 = zext i32 %49 to i64
  %cmp39 = icmp ult i64 %48, %conv38
  br i1 %cmp39, label %for.body41, label %for.end51

for.body41:                                       ; preds = %for.cond37
  %50 = load i32, ptr %vm, align 4
  %tobool42 = icmp ne i32 %50, 0
  br i1 %tobool42, label %if.then46, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body41
  %51 = load ptr, ptr %v0.addr, align 8
  %52 = load i64, ptr %i, align 8
  %conv43 = trunc i64 %52 to i32
  %call44 = call i32 @vext_elem_mask(ptr noundef %51, i32 noundef %conv43)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %lor.lhs.false, %for.body41
  %53 = load ptr, ptr %vd.addr, align 8
  %54 = load i64, ptr %i, align 8
  %add.ptr47 = getelementptr i32, ptr %53, i64 %54
  store i32 0, ptr %add.ptr47, align 4
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %lor.lhs.false
  br label %for.inc49

for.inc49:                                        ; preds = %if.end48
  %55 = load i64, ptr %i, align 8
  %inc50 = add i64 %55, 1
  store i64 %inc50, ptr %i, align 8
  br label %for.cond37, !llvm.loop !585

for.end51:                                        ; preds = %for.cond37
  %56 = load ptr, ptr %env.addr, align 8
  %vstart52 = getelementptr inbounds %struct.CPUArchState, ptr %56, i32 0, i32 6
  store i64 0, ptr %vstart52, align 8
  %57 = load ptr, ptr %vd.addr, align 8
  %58 = load i32, ptr %vta, align 4
  %59 = load i32, ptr %vl, align 4
  %60 = load i32, ptr %esz, align 4
  %mul53 = mul i32 %59, %60
  %61 = load i32, ptr %total_elems, align 4
  %62 = load i32, ptr %esz, align 4
  %mul54 = mul i32 %61, %62
  call void @vext_set_elems_1s(ptr noundef %57, i32 noundef %58, i32 noundef %mul53, i32 noundef %mul54)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslidedown_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i_max = alloca i64, align 8
  %i_min = alloca i64, align 8
  %i = alloca i64, align 8
  %_a22 = alloca i64, align 8
  %_b23 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %_a24 = alloca i64, align 8
  %_b25 = alloca i64, align 8
  %tmp17 = alloca i64, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load i64, ptr %s1.addr, align 8
  %10 = load i32, ptr %vlmax, align 4
  %conv7 = zext i32 %10 to i64
  %cmp = icmp ult i64 %9, %conv7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %11 = load i32, ptr %vlmax, align 4
  %conv9 = zext i32 %11 to i64
  %12 = load i64, ptr %s1.addr, align 8
  %sub = sub i64 %conv9, %12
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %_a22, align 8
  %13 = load i32, ptr %vl, align 4
  %conv10 = zext i32 %13 to i64
  store i64 %conv10, ptr %_b23, align 8
  %14 = load i64, ptr %_a22, align 8
  %15 = load i64, ptr %_b23, align 8
  %cmp11 = icmp ult i64 %14, %15
  br i1 %cmp11, label %cond.true13, label %cond.false14

cond.true13:                                      ; preds = %cond.end
  %16 = load i64, ptr %_a22, align 8
  br label %cond.end15

cond.false14:                                     ; preds = %cond.end
  %17 = load i64, ptr %_b23, align 8
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false14, %cond.true13
  %cond16 = phi i64 [ %16, %cond.true13 ], [ %17, %cond.false14 ]
  store i64 %cond16, ptr %tmp, align 8
  %18 = load i64, ptr %tmp, align 8
  store i64 %18, ptr %i_min, align 8
  %19 = load i64, ptr %i_min, align 8
  store i64 %19, ptr %_a24, align 8
  %20 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %20, i32 0, i32 6
  %21 = load i64, ptr %vstart, align 8
  store i64 %21, ptr %_b25, align 8
  %22 = load i64, ptr %_a24, align 8
  %23 = load i64, ptr %_b25, align 8
  %cmp18 = icmp ugt i64 %22, %23
  br i1 %cmp18, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %cond.end15
  %24 = load i64, ptr %_a24, align 8
  br label %cond.end22

cond.false21:                                     ; preds = %cond.end15
  %25 = load i64, ptr %_b25, align 8
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false21, %cond.true20
  %cond23 = phi i64 [ %24, %cond.true20 ], [ %25, %cond.false21 ]
  store i64 %cond23, ptr %tmp17, align 8
  %26 = load i64, ptr %tmp17, align 8
  store i64 %26, ptr %i_max, align 8
  %27 = load ptr, ptr %env.addr, align 8
  %vstart24 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  %28 = load i64, ptr %vstart24, align 8
  store i64 %28, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end22
  %29 = load i64, ptr %i, align 8
  %30 = load i64, ptr %i_max, align 8
  %cmp25 = icmp ult i64 %29, %30
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %31 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %31, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %32 = load ptr, ptr %v0.addr, align 8
  %33 = load i64, ptr %i, align 8
  %conv27 = trunc i64 %33 to i32
  %call28 = call i32 @vext_elem_mask(ptr noundef %32, i32 noundef %conv27)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %34 = load ptr, ptr %vd.addr, align 8
  %35 = load i32, ptr %vma, align 4
  %36 = load i64, ptr %i, align 8
  %37 = load i32, ptr %esz, align 4
  %conv30 = zext i32 %37 to i64
  %mul = mul i64 %36, %conv30
  %conv31 = trunc i64 %mul to i32
  %38 = load i64, ptr %i, align 8
  %add = add i64 %38, 1
  %39 = load i32, ptr %esz, align 4
  %conv32 = zext i32 %39 to i64
  %mul33 = mul i64 %add, %conv32
  %conv34 = trunc i64 %mul33 to i32
  call void @vext_set_elems_1s(ptr noundef %34, i32 noundef %35, i32 noundef %conv31, i32 noundef %conv34)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %40 = load ptr, ptr %vs2.addr, align 8
  %41 = load i64, ptr %i, align 8
  %42 = load i64, ptr %s1.addr, align 8
  %add35 = add i64 %41, %42
  %add.ptr = getelementptr i64, ptr %40, i64 %add35
  %43 = load i64, ptr %add.ptr, align 8
  %44 = load ptr, ptr %vd.addr, align 8
  %45 = load i64, ptr %i, align 8
  %add.ptr36 = getelementptr i64, ptr %44, i64 %45
  store i64 %43, ptr %add.ptr36, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %46 = load i64, ptr %i, align 8
  %inc = add i64 %46, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !586

for.end:                                          ; preds = %for.cond
  %47 = load i64, ptr %i_max, align 8
  store i64 %47, ptr %i, align 8
  br label %for.cond37

for.cond37:                                       ; preds = %for.inc49, %for.end
  %48 = load i64, ptr %i, align 8
  %49 = load i32, ptr %vl, align 4
  %conv38 = zext i32 %49 to i64
  %cmp39 = icmp ult i64 %48, %conv38
  br i1 %cmp39, label %for.body41, label %for.end51

for.body41:                                       ; preds = %for.cond37
  %50 = load i32, ptr %vm, align 4
  %tobool42 = icmp ne i32 %50, 0
  br i1 %tobool42, label %if.then46, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body41
  %51 = load ptr, ptr %v0.addr, align 8
  %52 = load i64, ptr %i, align 8
  %conv43 = trunc i64 %52 to i32
  %call44 = call i32 @vext_elem_mask(ptr noundef %51, i32 noundef %conv43)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %lor.lhs.false, %for.body41
  %53 = load ptr, ptr %vd.addr, align 8
  %54 = load i64, ptr %i, align 8
  %add.ptr47 = getelementptr i64, ptr %53, i64 %54
  store i64 0, ptr %add.ptr47, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %lor.lhs.false
  br label %for.inc49

for.inc49:                                        ; preds = %if.end48
  %55 = load i64, ptr %i, align 8
  %inc50 = add i64 %55, 1
  store i64 %inc50, ptr %i, align 8
  br label %for.cond37, !llvm.loop !587

for.end51:                                        ; preds = %for.cond37
  %56 = load ptr, ptr %env.addr, align 8
  %vstart52 = getelementptr inbounds %struct.CPUArchState, ptr %56, i32 0, i32 6
  store i64 0, ptr %vstart52, align 8
  %57 = load ptr, ptr %vd.addr, align 8
  %58 = load i32, ptr %vta, align 4
  %59 = load i32, ptr %vl, align 4
  %60 = load i32, ptr %esz, align 4
  %mul53 = mul i32 %59, %60
  %61 = load i32, ptr %total_elems, align 4
  %62 = load i32, ptr %esz, align 4
  %mul54 = mul i32 %61, %62
  call void @vext_set_elems_1s(ptr noundef %57, i32 noundef %58, i32 noundef %mul53, i32 noundef %mul54)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslide1up_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1up_8(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vslide1up_8(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %i, align 4
  %cmp10 = icmp eq i32 %21, 0
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %22 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %22 to i8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %24 to i64
  %add.ptr = getelementptr i8, ptr %23, i64 %idx.ext
  store i8 %conv13, ptr %add.ptr, align 1
  br label %if.end18

if.else:                                          ; preds = %if.end
  %25 = load ptr, ptr %vs2.addr, align 8
  %26 = load i32, ptr %i, align 4
  %sub = sub i32 %26, 1
  %idx.ext14 = zext i32 %sub to i64
  %add.ptr15 = getelementptr i8, ptr %25, i64 %idx.ext14
  %27 = load i8, ptr %add.ptr15, align 1
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %i, align 4
  %idx.ext16 = zext i32 %29 to i64
  %add.ptr17 = getelementptr i8, ptr %28, i64 %idx.ext16
  store i8 %27, ptr %add.ptr17, align 1
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then12
  br label %for.inc

for.inc:                                          ; preds = %if.end18, %if.then
  %30 = load i32, ptr %i, align 4
  %inc = add i32 %30, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !588

for.end:                                          ; preds = %for.cond
  %31 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %31, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %vta, align 4
  %34 = load i32, ptr %vl, align 4
  %35 = load i32, ptr %esz, align 4
  %mul20 = mul i32 %34, %35
  %36 = load i32, ptr %total_elems, align 4
  %37 = load i32, ptr %esz, align 4
  %mul21 = mul i32 %36, %37
  call void @vext_set_elems_1s(ptr noundef %32, i32 noundef %33, i32 noundef %mul20, i32 noundef %mul21)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslide1up_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1up_16(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vslide1up_16(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %i, align 4
  %cmp10 = icmp eq i32 %21, 0
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %22 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %22 to i16
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %24 to i64
  %add.ptr = getelementptr i16, ptr %23, i64 %idx.ext
  store i16 %conv13, ptr %add.ptr, align 2
  br label %if.end18

if.else:                                          ; preds = %if.end
  %25 = load ptr, ptr %vs2.addr, align 8
  %26 = load i32, ptr %i, align 4
  %sub = sub i32 %26, 1
  %idx.ext14 = zext i32 %sub to i64
  %add.ptr15 = getelementptr i16, ptr %25, i64 %idx.ext14
  %27 = load i16, ptr %add.ptr15, align 2
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %i, align 4
  %idx.ext16 = zext i32 %29 to i64
  %add.ptr17 = getelementptr i16, ptr %28, i64 %idx.ext16
  store i16 %27, ptr %add.ptr17, align 2
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then12
  br label %for.inc

for.inc:                                          ; preds = %if.end18, %if.then
  %30 = load i32, ptr %i, align 4
  %inc = add i32 %30, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !589

for.end:                                          ; preds = %for.cond
  %31 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %31, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %vta, align 4
  %34 = load i32, ptr %vl, align 4
  %35 = load i32, ptr %esz, align 4
  %mul20 = mul i32 %34, %35
  %36 = load i32, ptr %total_elems, align 4
  %37 = load i32, ptr %esz, align 4
  %mul21 = mul i32 %36, %37
  call void @vext_set_elems_1s(ptr noundef %32, i32 noundef %33, i32 noundef %mul20, i32 noundef %mul21)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslide1up_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1up_32(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vslide1up_32(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %i, align 4
  %cmp10 = icmp eq i32 %21, 0
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %22 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %22 to i32
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %24 to i64
  %add.ptr = getelementptr i32, ptr %23, i64 %idx.ext
  store i32 %conv13, ptr %add.ptr, align 4
  br label %if.end18

if.else:                                          ; preds = %if.end
  %25 = load ptr, ptr %vs2.addr, align 8
  %26 = load i32, ptr %i, align 4
  %sub = sub i32 %26, 1
  %idx.ext14 = zext i32 %sub to i64
  %add.ptr15 = getelementptr i32, ptr %25, i64 %idx.ext14
  %27 = load i32, ptr %add.ptr15, align 4
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %i, align 4
  %idx.ext16 = zext i32 %29 to i64
  %add.ptr17 = getelementptr i32, ptr %28, i64 %idx.ext16
  store i32 %27, ptr %add.ptr17, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then12
  br label %for.inc

for.inc:                                          ; preds = %if.end18, %if.then
  %30 = load i32, ptr %i, align 4
  %inc = add i32 %30, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !590

for.end:                                          ; preds = %for.cond
  %31 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %31, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %vta, align 4
  %34 = load i32, ptr %vl, align 4
  %35 = load i32, ptr %esz, align 4
  %mul20 = mul i32 %34, %35
  %36 = load i32, ptr %total_elems, align 4
  %37 = load i32, ptr %esz, align 4
  %mul21 = mul i32 %36, %37
  call void @vext_set_elems_1s(ptr noundef %32, i32 noundef %33, i32 noundef %mul20, i32 noundef %mul21)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslide1up_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1up_64(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vslide1up_64(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %i, align 4
  %cmp10 = icmp eq i32 %21, 0
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %22 = load i64, ptr %s1.addr, align 8
  %23 = load ptr, ptr %vd.addr, align 8
  %24 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %24 to i64
  %add.ptr = getelementptr i64, ptr %23, i64 %idx.ext
  store i64 %22, ptr %add.ptr, align 8
  br label %if.end17

if.else:                                          ; preds = %if.end
  %25 = load ptr, ptr %vs2.addr, align 8
  %26 = load i32, ptr %i, align 4
  %sub = sub i32 %26, 1
  %idx.ext13 = zext i32 %sub to i64
  %add.ptr14 = getelementptr i64, ptr %25, i64 %idx.ext13
  %27 = load i64, ptr %add.ptr14, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %i, align 4
  %idx.ext15 = zext i32 %29 to i64
  %add.ptr16 = getelementptr i64, ptr %28, i64 %idx.ext15
  store i64 %27, ptr %add.ptr16, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then12
  br label %for.inc

for.inc:                                          ; preds = %if.end17, %if.then
  %30 = load i32, ptr %i, align 4
  %inc = add i32 %30, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !591

for.end:                                          ; preds = %for.cond
  %31 = load ptr, ptr %env.addr, align 8
  %vstart18 = getelementptr inbounds %struct.CPUArchState, ptr %31, i32 0, i32 6
  store i64 0, ptr %vstart18, align 8
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %vta, align 4
  %34 = load i32, ptr %vl, align 4
  %35 = load i32, ptr %esz, align 4
  %mul19 = mul i32 %34, %35
  %36 = load i32, ptr %total_elems, align 4
  %37 = load i32, ptr %esz, align 4
  %mul20 = mul i32 %36, %37
  call void @vext_set_elems_1s(ptr noundef %32, i32 noundef %33, i32 noundef %mul19, i32 noundef %mul20)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslide1down_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1down_8(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vslide1down_8(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %vl, align 4
  %sub = sub i32 %22, 1
  %cmp10 = icmp eq i32 %21, %sub
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %25 to i64
  %add.ptr = getelementptr i8, ptr %24, i64 %idx.ext
  store i8 %conv13, ptr %add.ptr, align 1
  br label %if.end19

if.else:                                          ; preds = %if.end
  %26 = load ptr, ptr %vs2.addr, align 8
  %27 = load i32, ptr %i, align 4
  %add14 = add i32 %27, 1
  %idx.ext15 = zext i32 %add14 to i64
  %add.ptr16 = getelementptr i8, ptr %26, i64 %idx.ext15
  %28 = load i8, ptr %add.ptr16, align 1
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %30 to i64
  %add.ptr18 = getelementptr i8, ptr %29, i64 %idx.ext17
  store i8 %28, ptr %add.ptr18, align 1
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then12
  br label %for.inc

for.inc:                                          ; preds = %if.end19, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !592

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul21 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul22 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul21, i32 noundef %mul22)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslide1down_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1down_16(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vslide1down_16(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %vl, align 4
  %sub = sub i32 %22, 1
  %cmp10 = icmp eq i32 %21, %sub
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i16
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %25 to i64
  %add.ptr = getelementptr i16, ptr %24, i64 %idx.ext
  store i16 %conv13, ptr %add.ptr, align 2
  br label %if.end19

if.else:                                          ; preds = %if.end
  %26 = load ptr, ptr %vs2.addr, align 8
  %27 = load i32, ptr %i, align 4
  %add14 = add i32 %27, 1
  %idx.ext15 = zext i32 %add14 to i64
  %add.ptr16 = getelementptr i16, ptr %26, i64 %idx.ext15
  %28 = load i16, ptr %add.ptr16, align 2
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %30 to i64
  %add.ptr18 = getelementptr i16, ptr %29, i64 %idx.ext17
  store i16 %28, ptr %add.ptr18, align 2
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then12
  br label %for.inc

for.inc:                                          ; preds = %if.end19, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !593

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul21 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul22 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul21, i32 noundef %mul22)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslide1down_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1down_32(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vslide1down_32(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %vl, align 4
  %sub = sub i32 %22, 1
  %cmp10 = icmp eq i32 %21, %sub
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %23 = load i64, ptr %s1.addr, align 8
  %conv13 = trunc i64 %23 to i32
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %25 to i64
  %add.ptr = getelementptr i32, ptr %24, i64 %idx.ext
  store i32 %conv13, ptr %add.ptr, align 4
  br label %if.end19

if.else:                                          ; preds = %if.end
  %26 = load ptr, ptr %vs2.addr, align 8
  %27 = load i32, ptr %i, align 4
  %add14 = add i32 %27, 1
  %idx.ext15 = zext i32 %add14 to i64
  %add.ptr16 = getelementptr i32, ptr %26, i64 %idx.ext15
  %28 = load i32, ptr %add.ptr16, align 4
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %30 to i64
  %add.ptr18 = getelementptr i32, ptr %29, i64 %idx.ext17
  store i32 %28, ptr %add.ptr18, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then12
  br label %for.inc

for.inc:                                          ; preds = %if.end19, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !594

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul21 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul22 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul21, i32 noundef %mul22)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vslide1down_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1down_64(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vslide1down_64(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %0)
  store i32 %call, ptr %vm, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %vl, align 4
  %sub = sub i32 %22, 1
  %cmp10 = icmp eq i32 %21, %sub
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %23 = load i64, ptr %s1.addr, align 8
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %25 to i64
  %add.ptr = getelementptr i64, ptr %24, i64 %idx.ext
  store i64 %23, ptr %add.ptr, align 8
  br label %if.end18

if.else:                                          ; preds = %if.end
  %26 = load ptr, ptr %vs2.addr, align 8
  %27 = load i32, ptr %i, align 4
  %add13 = add i32 %27, 1
  %idx.ext14 = zext i32 %add13 to i64
  %add.ptr15 = getelementptr i64, ptr %26, i64 %idx.ext14
  %28 = load i64, ptr %add.ptr15, align 8
  %29 = load ptr, ptr %vd.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idx.ext16 = zext i32 %30 to i64
  %add.ptr17 = getelementptr i64, ptr %29, i64 %idx.ext16
  store i64 %28, ptr %add.ptr17, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then12
  br label %for.inc

for.inc:                                          ; preds = %if.end18, %if.then
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !595

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %env.addr, align 8
  %vstart19 = getelementptr inbounds %struct.CPUArchState, ptr %32, i32 0, i32 6
  store i64 0, ptr %vstart19, align 8
  %33 = load ptr, ptr %vd.addr, align 8
  %34 = load i32, ptr %vta, align 4
  %35 = load i32, ptr %vl, align 4
  %36 = load i32, ptr %esz, align 4
  %mul20 = mul i32 %35, %36
  %37 = load i32, ptr %total_elems, align 4
  %38 = load i32, ptr %esz, align 4
  %mul21 = mul i32 %37, %38
  call void @vext_set_elems_1s(ptr noundef %33, i32 noundef %34, i32 noundef %mul20, i32 noundef %mul21)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfslide1up_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1up_16(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfslide1up_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1up_32(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfslide1up_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1up_64(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfslide1down_vf_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1down_16(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfslide1down_vf_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1down_32(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vfslide1down_vf_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %vd.addr, align 8
  %1 = load ptr, ptr %v0.addr, align 8
  %2 = load i64, ptr %s1.addr, align 8
  %3 = load ptr, ptr %vs2.addr, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  call void @vslide1down_64(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrgather_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %index = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %vstart, align 8
  %conv7 = trunc i64 %10 to i32
  store i32 %conv7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %16 = load ptr, ptr %vd.addr, align 8
  %17 = load i32, ptr %vma, align 4
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %esz, align 4
  %mul = mul i32 %18, %19
  %20 = load i32, ptr %i, align 4
  %add = add i32 %20, 1
  %21 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %add, %21
  call void @vext_set_elems_1s(ptr noundef %16, i32 noundef %17, i32 noundef %mul, i32 noundef %mul11)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %22 = load ptr, ptr %vs1.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %23 to i64
  %add.ptr = getelementptr i8, ptr %22, i64 %idx.ext
  %24 = load i8, ptr %add.ptr, align 1
  %conv12 = zext i8 %24 to i64
  store i64 %conv12, ptr %index, align 8
  %25 = load i64, ptr %index, align 8
  %26 = load i32, ptr %vlmax, align 4
  %conv13 = zext i32 %26 to i64
  %cmp14 = icmp uge i64 %25, %conv13
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end
  %27 = load ptr, ptr %vd.addr, align 8
  %28 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %28 to i64
  %add.ptr18 = getelementptr i8, ptr %27, i64 %idx.ext17
  store i8 0, ptr %add.ptr18, align 1
  br label %if.end22

if.else:                                          ; preds = %if.end
  %29 = load ptr, ptr %vs2.addr, align 8
  %30 = load i64, ptr %index, align 8
  %add.ptr19 = getelementptr i8, ptr %29, i64 %30
  %31 = load i8, ptr %add.ptr19, align 1
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  %idx.ext20 = zext i32 %33 to i64
  %add.ptr21 = getelementptr i8, ptr %32, i64 %idx.ext20
  store i8 %31, ptr %add.ptr21, align 1
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then16
  br label %for.inc

for.inc:                                          ; preds = %if.end22, %if.then
  %34 = load i32, ptr %i, align 4
  %inc = add i32 %34, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !596

for.end:                                          ; preds = %for.cond
  %35 = load ptr, ptr %env.addr, align 8
  %vstart23 = getelementptr inbounds %struct.CPUArchState, ptr %35, i32 0, i32 6
  store i64 0, ptr %vstart23, align 8
  %36 = load ptr, ptr %vd.addr, align 8
  %37 = load i32, ptr %vta, align 4
  %38 = load i32, ptr %vl, align 4
  %39 = load i32, ptr %esz, align 4
  %mul24 = mul i32 %38, %39
  %40 = load i32, ptr %total_elems, align 4
  %41 = load i32, ptr %esz, align 4
  %mul25 = mul i32 %40, %41
  call void @vext_set_elems_1s(ptr noundef %36, i32 noundef %37, i32 noundef %mul24, i32 noundef %mul25)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrgather_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %index = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %vstart, align 8
  %conv7 = trunc i64 %10 to i32
  store i32 %conv7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %16 = load ptr, ptr %vd.addr, align 8
  %17 = load i32, ptr %vma, align 4
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %esz, align 4
  %mul = mul i32 %18, %19
  %20 = load i32, ptr %i, align 4
  %add = add i32 %20, 1
  %21 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %add, %21
  call void @vext_set_elems_1s(ptr noundef %16, i32 noundef %17, i32 noundef %mul, i32 noundef %mul11)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %22 = load ptr, ptr %vs1.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %23 to i64
  %add.ptr = getelementptr i16, ptr %22, i64 %idx.ext
  %24 = load i16, ptr %add.ptr, align 2
  %conv12 = zext i16 %24 to i64
  store i64 %conv12, ptr %index, align 8
  %25 = load i64, ptr %index, align 8
  %26 = load i32, ptr %vlmax, align 4
  %conv13 = zext i32 %26 to i64
  %cmp14 = icmp uge i64 %25, %conv13
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end
  %27 = load ptr, ptr %vd.addr, align 8
  %28 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %28 to i64
  %add.ptr18 = getelementptr i16, ptr %27, i64 %idx.ext17
  store i16 0, ptr %add.ptr18, align 2
  br label %if.end22

if.else:                                          ; preds = %if.end
  %29 = load ptr, ptr %vs2.addr, align 8
  %30 = load i64, ptr %index, align 8
  %add.ptr19 = getelementptr i16, ptr %29, i64 %30
  %31 = load i16, ptr %add.ptr19, align 2
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  %idx.ext20 = zext i32 %33 to i64
  %add.ptr21 = getelementptr i16, ptr %32, i64 %idx.ext20
  store i16 %31, ptr %add.ptr21, align 2
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then16
  br label %for.inc

for.inc:                                          ; preds = %if.end22, %if.then
  %34 = load i32, ptr %i, align 4
  %inc = add i32 %34, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !597

for.end:                                          ; preds = %for.cond
  %35 = load ptr, ptr %env.addr, align 8
  %vstart23 = getelementptr inbounds %struct.CPUArchState, ptr %35, i32 0, i32 6
  store i64 0, ptr %vstart23, align 8
  %36 = load ptr, ptr %vd.addr, align 8
  %37 = load i32, ptr %vta, align 4
  %38 = load i32, ptr %vl, align 4
  %39 = load i32, ptr %esz, align 4
  %mul24 = mul i32 %38, %39
  %40 = load i32, ptr %total_elems, align 4
  %41 = load i32, ptr %esz, align 4
  %mul25 = mul i32 %40, %41
  call void @vext_set_elems_1s(ptr noundef %36, i32 noundef %37, i32 noundef %mul24, i32 noundef %mul25)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrgather_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %index = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %vstart, align 8
  %conv7 = trunc i64 %10 to i32
  store i32 %conv7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %16 = load ptr, ptr %vd.addr, align 8
  %17 = load i32, ptr %vma, align 4
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %esz, align 4
  %mul = mul i32 %18, %19
  %20 = load i32, ptr %i, align 4
  %add = add i32 %20, 1
  %21 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %add, %21
  call void @vext_set_elems_1s(ptr noundef %16, i32 noundef %17, i32 noundef %mul, i32 noundef %mul11)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %22 = load ptr, ptr %vs1.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %23 to i64
  %add.ptr = getelementptr i32, ptr %22, i64 %idx.ext
  %24 = load i32, ptr %add.ptr, align 4
  %conv12 = zext i32 %24 to i64
  store i64 %conv12, ptr %index, align 8
  %25 = load i64, ptr %index, align 8
  %26 = load i32, ptr %vlmax, align 4
  %conv13 = zext i32 %26 to i64
  %cmp14 = icmp uge i64 %25, %conv13
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end
  %27 = load ptr, ptr %vd.addr, align 8
  %28 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %28 to i64
  %add.ptr18 = getelementptr i32, ptr %27, i64 %idx.ext17
  store i32 0, ptr %add.ptr18, align 4
  br label %if.end22

if.else:                                          ; preds = %if.end
  %29 = load ptr, ptr %vs2.addr, align 8
  %30 = load i64, ptr %index, align 8
  %add.ptr19 = getelementptr i32, ptr %29, i64 %30
  %31 = load i32, ptr %add.ptr19, align 4
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  %idx.ext20 = zext i32 %33 to i64
  %add.ptr21 = getelementptr i32, ptr %32, i64 %idx.ext20
  store i32 %31, ptr %add.ptr21, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then16
  br label %for.inc

for.inc:                                          ; preds = %if.end22, %if.then
  %34 = load i32, ptr %i, align 4
  %inc = add i32 %34, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !598

for.end:                                          ; preds = %for.cond
  %35 = load ptr, ptr %env.addr, align 8
  %vstart23 = getelementptr inbounds %struct.CPUArchState, ptr %35, i32 0, i32 6
  store i64 0, ptr %vstart23, align 8
  %36 = load ptr, ptr %vd.addr, align 8
  %37 = load i32, ptr %vta, align 4
  %38 = load i32, ptr %vl, align 4
  %39 = load i32, ptr %esz, align 4
  %mul24 = mul i32 %38, %39
  %40 = load i32, ptr %total_elems, align 4
  %41 = load i32, ptr %esz, align 4
  %mul25 = mul i32 %40, %41
  call void @vext_set_elems_1s(ptr noundef %36, i32 noundef %37, i32 noundef %mul24, i32 noundef %mul25)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrgather_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %index = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %vstart, align 8
  %conv7 = trunc i64 %10 to i32
  store i32 %conv7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %16 = load ptr, ptr %vd.addr, align 8
  %17 = load i32, ptr %vma, align 4
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %esz, align 4
  %mul = mul i32 %18, %19
  %20 = load i32, ptr %i, align 4
  %add = add i32 %20, 1
  %21 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %add, %21
  call void @vext_set_elems_1s(ptr noundef %16, i32 noundef %17, i32 noundef %mul, i32 noundef %mul11)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %22 = load ptr, ptr %vs1.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %23 to i64
  %add.ptr = getelementptr i64, ptr %22, i64 %idx.ext
  %24 = load i64, ptr %add.ptr, align 8
  store i64 %24, ptr %index, align 8
  %25 = load i64, ptr %index, align 8
  %26 = load i32, ptr %vlmax, align 4
  %conv12 = zext i32 %26 to i64
  %cmp13 = icmp uge i64 %25, %conv12
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end
  %27 = load ptr, ptr %vd.addr, align 8
  %28 = load i32, ptr %i, align 4
  %idx.ext16 = zext i32 %28 to i64
  %add.ptr17 = getelementptr i64, ptr %27, i64 %idx.ext16
  store i64 0, ptr %add.ptr17, align 8
  br label %if.end21

if.else:                                          ; preds = %if.end
  %29 = load ptr, ptr %vs2.addr, align 8
  %30 = load i64, ptr %index, align 8
  %add.ptr18 = getelementptr i64, ptr %29, i64 %30
  %31 = load i64, ptr %add.ptr18, align 8
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  %idx.ext19 = zext i32 %33 to i64
  %add.ptr20 = getelementptr i64, ptr %32, i64 %idx.ext19
  store i64 %31, ptr %add.ptr20, align 8
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then15
  br label %for.inc

for.inc:                                          ; preds = %if.end21, %if.then
  %34 = load i32, ptr %i, align 4
  %inc = add i32 %34, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !599

for.end:                                          ; preds = %for.cond
  %35 = load ptr, ptr %env.addr, align 8
  %vstart22 = getelementptr inbounds %struct.CPUArchState, ptr %35, i32 0, i32 6
  store i64 0, ptr %vstart22, align 8
  %36 = load ptr, ptr %vd.addr, align 8
  %37 = load i32, ptr %vta, align 4
  %38 = load i32, ptr %vl, align 4
  %39 = load i32, ptr %esz, align 4
  %mul23 = mul i32 %38, %39
  %40 = load i32, ptr %total_elems, align 4
  %41 = load i32, ptr %esz, align 4
  %mul24 = mul i32 %40, %41
  call void @vext_set_elems_1s(ptr noundef %36, i32 noundef %37, i32 noundef %mul23, i32 noundef %mul24)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrgatherei16_vv_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %index = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %vstart, align 8
  %conv7 = trunc i64 %10 to i32
  store i32 %conv7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %16 = load ptr, ptr %vd.addr, align 8
  %17 = load i32, ptr %vma, align 4
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %esz, align 4
  %mul = mul i32 %18, %19
  %20 = load i32, ptr %i, align 4
  %add = add i32 %20, 1
  %21 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %add, %21
  call void @vext_set_elems_1s(ptr noundef %16, i32 noundef %17, i32 noundef %mul, i32 noundef %mul11)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %22 = load ptr, ptr %vs1.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %23 to i64
  %add.ptr = getelementptr i16, ptr %22, i64 %idx.ext
  %24 = load i16, ptr %add.ptr, align 2
  %conv12 = zext i16 %24 to i64
  store i64 %conv12, ptr %index, align 8
  %25 = load i64, ptr %index, align 8
  %26 = load i32, ptr %vlmax, align 4
  %conv13 = zext i32 %26 to i64
  %cmp14 = icmp uge i64 %25, %conv13
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end
  %27 = load ptr, ptr %vd.addr, align 8
  %28 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %28 to i64
  %add.ptr18 = getelementptr i8, ptr %27, i64 %idx.ext17
  store i8 0, ptr %add.ptr18, align 1
  br label %if.end22

if.else:                                          ; preds = %if.end
  %29 = load ptr, ptr %vs2.addr, align 8
  %30 = load i64, ptr %index, align 8
  %add.ptr19 = getelementptr i8, ptr %29, i64 %30
  %31 = load i8, ptr %add.ptr19, align 1
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  %idx.ext20 = zext i32 %33 to i64
  %add.ptr21 = getelementptr i8, ptr %32, i64 %idx.ext20
  store i8 %31, ptr %add.ptr21, align 1
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then16
  br label %for.inc

for.inc:                                          ; preds = %if.end22, %if.then
  %34 = load i32, ptr %i, align 4
  %inc = add i32 %34, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !600

for.end:                                          ; preds = %for.cond
  %35 = load ptr, ptr %env.addr, align 8
  %vstart23 = getelementptr inbounds %struct.CPUArchState, ptr %35, i32 0, i32 6
  store i64 0, ptr %vstart23, align 8
  %36 = load ptr, ptr %vd.addr, align 8
  %37 = load i32, ptr %vta, align 4
  %38 = load i32, ptr %vl, align 4
  %39 = load i32, ptr %esz, align 4
  %mul24 = mul i32 %38, %39
  %40 = load i32, ptr %total_elems, align 4
  %41 = load i32, ptr %esz, align 4
  %mul25 = mul i32 %40, %41
  call void @vext_set_elems_1s(ptr noundef %36, i32 noundef %37, i32 noundef %mul24, i32 noundef %mul25)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrgatherei16_vv_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %index = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %vstart, align 8
  %conv7 = trunc i64 %10 to i32
  store i32 %conv7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %16 = load ptr, ptr %vd.addr, align 8
  %17 = load i32, ptr %vma, align 4
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %esz, align 4
  %mul = mul i32 %18, %19
  %20 = load i32, ptr %i, align 4
  %add = add i32 %20, 1
  %21 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %add, %21
  call void @vext_set_elems_1s(ptr noundef %16, i32 noundef %17, i32 noundef %mul, i32 noundef %mul11)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %22 = load ptr, ptr %vs1.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %23 to i64
  %add.ptr = getelementptr i16, ptr %22, i64 %idx.ext
  %24 = load i16, ptr %add.ptr, align 2
  %conv12 = zext i16 %24 to i64
  store i64 %conv12, ptr %index, align 8
  %25 = load i64, ptr %index, align 8
  %26 = load i32, ptr %vlmax, align 4
  %conv13 = zext i32 %26 to i64
  %cmp14 = icmp uge i64 %25, %conv13
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end
  %27 = load ptr, ptr %vd.addr, align 8
  %28 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %28 to i64
  %add.ptr18 = getelementptr i16, ptr %27, i64 %idx.ext17
  store i16 0, ptr %add.ptr18, align 2
  br label %if.end22

if.else:                                          ; preds = %if.end
  %29 = load ptr, ptr %vs2.addr, align 8
  %30 = load i64, ptr %index, align 8
  %add.ptr19 = getelementptr i16, ptr %29, i64 %30
  %31 = load i16, ptr %add.ptr19, align 2
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  %idx.ext20 = zext i32 %33 to i64
  %add.ptr21 = getelementptr i16, ptr %32, i64 %idx.ext20
  store i16 %31, ptr %add.ptr21, align 2
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then16
  br label %for.inc

for.inc:                                          ; preds = %if.end22, %if.then
  %34 = load i32, ptr %i, align 4
  %inc = add i32 %34, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !601

for.end:                                          ; preds = %for.cond
  %35 = load ptr, ptr %env.addr, align 8
  %vstart23 = getelementptr inbounds %struct.CPUArchState, ptr %35, i32 0, i32 6
  store i64 0, ptr %vstart23, align 8
  %36 = load ptr, ptr %vd.addr, align 8
  %37 = load i32, ptr %vta, align 4
  %38 = load i32, ptr %vl, align 4
  %39 = load i32, ptr %esz, align 4
  %mul24 = mul i32 %38, %39
  %40 = load i32, ptr %total_elems, align 4
  %41 = load i32, ptr %esz, align 4
  %mul25 = mul i32 %40, %41
  call void @vext_set_elems_1s(ptr noundef %36, i32 noundef %37, i32 noundef %mul24, i32 noundef %mul25)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrgatherei16_vv_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %index = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %vstart, align 8
  %conv7 = trunc i64 %10 to i32
  store i32 %conv7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %16 = load ptr, ptr %vd.addr, align 8
  %17 = load i32, ptr %vma, align 4
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %esz, align 4
  %mul = mul i32 %18, %19
  %20 = load i32, ptr %i, align 4
  %add = add i32 %20, 1
  %21 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %add, %21
  call void @vext_set_elems_1s(ptr noundef %16, i32 noundef %17, i32 noundef %mul, i32 noundef %mul11)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %22 = load ptr, ptr %vs1.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %23 to i64
  %add.ptr = getelementptr i16, ptr %22, i64 %idx.ext
  %24 = load i16, ptr %add.ptr, align 2
  %conv12 = zext i16 %24 to i64
  store i64 %conv12, ptr %index, align 8
  %25 = load i64, ptr %index, align 8
  %26 = load i32, ptr %vlmax, align 4
  %conv13 = zext i32 %26 to i64
  %cmp14 = icmp uge i64 %25, %conv13
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end
  %27 = load ptr, ptr %vd.addr, align 8
  %28 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %28 to i64
  %add.ptr18 = getelementptr i32, ptr %27, i64 %idx.ext17
  store i32 0, ptr %add.ptr18, align 4
  br label %if.end22

if.else:                                          ; preds = %if.end
  %29 = load ptr, ptr %vs2.addr, align 8
  %30 = load i64, ptr %index, align 8
  %add.ptr19 = getelementptr i32, ptr %29, i64 %30
  %31 = load i32, ptr %add.ptr19, align 4
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  %idx.ext20 = zext i32 %33 to i64
  %add.ptr21 = getelementptr i32, ptr %32, i64 %idx.ext20
  store i32 %31, ptr %add.ptr21, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then16
  br label %for.inc

for.inc:                                          ; preds = %if.end22, %if.then
  %34 = load i32, ptr %i, align 4
  %inc = add i32 %34, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !602

for.end:                                          ; preds = %for.cond
  %35 = load ptr, ptr %env.addr, align 8
  %vstart23 = getelementptr inbounds %struct.CPUArchState, ptr %35, i32 0, i32 6
  store i64 0, ptr %vstart23, align 8
  %36 = load ptr, ptr %vd.addr, align 8
  %37 = load i32, ptr %vta, align 4
  %38 = load i32, ptr %vl, align 4
  %39 = load i32, ptr %esz, align 4
  %mul24 = mul i32 %38, %39
  %40 = load i32, ptr %total_elems, align 4
  %41 = load i32, ptr %esz, align 4
  %mul25 = mul i32 %40, %41
  call void @vext_set_elems_1s(ptr noundef %36, i32 noundef %37, i32 noundef %mul24, i32 noundef %mul25)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrgatherei16_vv_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %index = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %vstart, align 8
  %conv7 = trunc i64 %10 to i32
  store i32 %conv7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %14 = load ptr, ptr %v0.addr, align 8
  %15 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %14, i32 noundef %15)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %16 = load ptr, ptr %vd.addr, align 8
  %17 = load i32, ptr %vma, align 4
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %esz, align 4
  %mul = mul i32 %18, %19
  %20 = load i32, ptr %i, align 4
  %add = add i32 %20, 1
  %21 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %add, %21
  call void @vext_set_elems_1s(ptr noundef %16, i32 noundef %17, i32 noundef %mul, i32 noundef %mul11)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %22 = load ptr, ptr %vs1.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %23 to i64
  %add.ptr = getelementptr i16, ptr %22, i64 %idx.ext
  %24 = load i16, ptr %add.ptr, align 2
  %conv12 = zext i16 %24 to i64
  store i64 %conv12, ptr %index, align 8
  %25 = load i64, ptr %index, align 8
  %26 = load i32, ptr %vlmax, align 4
  %conv13 = zext i32 %26 to i64
  %cmp14 = icmp uge i64 %25, %conv13
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end
  %27 = load ptr, ptr %vd.addr, align 8
  %28 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %28 to i64
  %add.ptr18 = getelementptr i64, ptr %27, i64 %idx.ext17
  store i64 0, ptr %add.ptr18, align 8
  br label %if.end22

if.else:                                          ; preds = %if.end
  %29 = load ptr, ptr %vs2.addr, align 8
  %30 = load i64, ptr %index, align 8
  %add.ptr19 = getelementptr i64, ptr %29, i64 %30
  %31 = load i64, ptr %add.ptr19, align 8
  %32 = load ptr, ptr %vd.addr, align 8
  %33 = load i32, ptr %i, align 4
  %idx.ext20 = zext i32 %33 to i64
  %add.ptr21 = getelementptr i64, ptr %32, i64 %idx.ext20
  store i64 %31, ptr %add.ptr21, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then16
  br label %for.inc

for.inc:                                          ; preds = %if.end22, %if.then
  %34 = load i32, ptr %i, align 4
  %inc = add i32 %34, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !603

for.end:                                          ; preds = %for.cond
  %35 = load ptr, ptr %env.addr, align 8
  %vstart23 = getelementptr inbounds %struct.CPUArchState, ptr %35, i32 0, i32 6
  store i64 0, ptr %vstart23, align 8
  %36 = load ptr, ptr %vd.addr, align 8
  %37 = load i32, ptr %vta, align 4
  %38 = load i32, ptr %vl, align 4
  %39 = load i32, ptr %esz, align 4
  %mul24 = mul i32 %38, %39
  %40 = load i32, ptr %total_elems, align 4
  %41 = load i32, ptr %esz, align 4
  %mul25 = mul i32 %40, %41
  call void @vext_set_elems_1s(ptr noundef %36, i32 noundef %37, i32 noundef %mul24, i32 noundef %mul25)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrgather_vx_b(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %index = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 1)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load i64, ptr %s1.addr, align 8
  store i64 %9, ptr %index, align 8
  %10 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %10, i32 0, i32 6
  %11 = load i64, ptr %vstart, align 8
  %conv7 = trunc i64 %11 to i32
  store i32 %conv7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %12 = load i32, ptr %i, align 4
  %13 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %12, %13
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %vma, align 4
  %19 = load i32, ptr %i, align 4
  %20 = load i32, ptr %esz, align 4
  %mul = mul i32 %19, %20
  %21 = load i32, ptr %i, align 4
  %add = add i32 %21, 1
  %22 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %add, %22
  call void @vext_set_elems_1s(ptr noundef %17, i32 noundef %18, i32 noundef %mul, i32 noundef %mul11)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %23 = load i64, ptr %index, align 8
  %24 = load i32, ptr %vlmax, align 4
  %conv12 = zext i32 %24 to i64
  %cmp13 = icmp uge i64 %23, %conv12
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %26 to i64
  %add.ptr = getelementptr i8, ptr %25, i64 %idx.ext
  store i8 0, ptr %add.ptr, align 1
  br label %if.end19

if.else:                                          ; preds = %if.end
  %27 = load ptr, ptr %vs2.addr, align 8
  %28 = load i64, ptr %index, align 8
  %add.ptr16 = getelementptr i8, ptr %27, i64 %28
  %29 = load i8, ptr %add.ptr16, align 1
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %31 to i64
  %add.ptr18 = getelementptr i8, ptr %30, i64 %idx.ext17
  store i8 %29, ptr %add.ptr18, align 1
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then15
  br label %for.inc

for.inc:                                          ; preds = %if.end19, %if.then
  %32 = load i32, ptr %i, align 4
  %inc = add i32 %32, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !604

for.end:                                          ; preds = %for.cond
  %33 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %33, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %34 = load ptr, ptr %vd.addr, align 8
  %35 = load i32, ptr %vta, align 4
  %36 = load i32, ptr %vl, align 4
  %37 = load i32, ptr %esz, align 4
  %mul21 = mul i32 %36, %37
  %38 = load i32, ptr %total_elems, align 4
  %39 = load i32, ptr %esz, align 4
  %mul22 = mul i32 %38, %39
  call void @vext_set_elems_1s(ptr noundef %34, i32 noundef %35, i32 noundef %mul21, i32 noundef %mul22)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrgather_vx_h(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %index = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 2)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load i64, ptr %s1.addr, align 8
  store i64 %9, ptr %index, align 8
  %10 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %10, i32 0, i32 6
  %11 = load i64, ptr %vstart, align 8
  %conv7 = trunc i64 %11 to i32
  store i32 %conv7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %12 = load i32, ptr %i, align 4
  %13 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %12, %13
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %vma, align 4
  %19 = load i32, ptr %i, align 4
  %20 = load i32, ptr %esz, align 4
  %mul = mul i32 %19, %20
  %21 = load i32, ptr %i, align 4
  %add = add i32 %21, 1
  %22 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %add, %22
  call void @vext_set_elems_1s(ptr noundef %17, i32 noundef %18, i32 noundef %mul, i32 noundef %mul11)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %23 = load i64, ptr %index, align 8
  %24 = load i32, ptr %vlmax, align 4
  %conv12 = zext i32 %24 to i64
  %cmp13 = icmp uge i64 %23, %conv12
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %26 to i64
  %add.ptr = getelementptr i16, ptr %25, i64 %idx.ext
  store i16 0, ptr %add.ptr, align 2
  br label %if.end19

if.else:                                          ; preds = %if.end
  %27 = load ptr, ptr %vs2.addr, align 8
  %28 = load i64, ptr %index, align 8
  %add.ptr16 = getelementptr i16, ptr %27, i64 %28
  %29 = load i16, ptr %add.ptr16, align 2
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %31 to i64
  %add.ptr18 = getelementptr i16, ptr %30, i64 %idx.ext17
  store i16 %29, ptr %add.ptr18, align 2
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then15
  br label %for.inc

for.inc:                                          ; preds = %if.end19, %if.then
  %32 = load i32, ptr %i, align 4
  %inc = add i32 %32, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !605

for.end:                                          ; preds = %for.cond
  %33 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %33, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %34 = load ptr, ptr %vd.addr, align 8
  %35 = load i32, ptr %vta, align 4
  %36 = load i32, ptr %vl, align 4
  %37 = load i32, ptr %esz, align 4
  %mul21 = mul i32 %36, %37
  %38 = load i32, ptr %total_elems, align 4
  %39 = load i32, ptr %esz, align 4
  %mul22 = mul i32 %38, %39
  call void @vext_set_elems_1s(ptr noundef %34, i32 noundef %35, i32 noundef %mul21, i32 noundef %mul22)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrgather_vx_w(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %index = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 4)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load i64, ptr %s1.addr, align 8
  store i64 %9, ptr %index, align 8
  %10 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %10, i32 0, i32 6
  %11 = load i64, ptr %vstart, align 8
  %conv7 = trunc i64 %11 to i32
  store i32 %conv7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %12 = load i32, ptr %i, align 4
  %13 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %12, %13
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %vma, align 4
  %19 = load i32, ptr %i, align 4
  %20 = load i32, ptr %esz, align 4
  %mul = mul i32 %19, %20
  %21 = load i32, ptr %i, align 4
  %add = add i32 %21, 1
  %22 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %add, %22
  call void @vext_set_elems_1s(ptr noundef %17, i32 noundef %18, i32 noundef %mul, i32 noundef %mul11)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %23 = load i64, ptr %index, align 8
  %24 = load i32, ptr %vlmax, align 4
  %conv12 = zext i32 %24 to i64
  %cmp13 = icmp uge i64 %23, %conv12
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %26 to i64
  %add.ptr = getelementptr i32, ptr %25, i64 %idx.ext
  store i32 0, ptr %add.ptr, align 4
  br label %if.end19

if.else:                                          ; preds = %if.end
  %27 = load ptr, ptr %vs2.addr, align 8
  %28 = load i64, ptr %index, align 8
  %add.ptr16 = getelementptr i32, ptr %27, i64 %28
  %29 = load i32, ptr %add.ptr16, align 4
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %31 to i64
  %add.ptr18 = getelementptr i32, ptr %30, i64 %idx.ext17
  store i32 %29, ptr %add.ptr18, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then15
  br label %for.inc

for.inc:                                          ; preds = %if.end19, %if.then
  %32 = load i32, ptr %i, align 4
  %inc = add i32 %32, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !606

for.end:                                          ; preds = %for.cond
  %33 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %33, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %34 = load ptr, ptr %vd.addr, align 8
  %35 = load i32, ptr %vta, align 4
  %36 = load i32, ptr %vl, align 4
  %37 = load i32, ptr %esz, align 4
  %mul21 = mul i32 %36, %37
  %38 = load i32, ptr %total_elems, align 4
  %39 = load i32, ptr %esz, align 4
  %mul22 = mul i32 %38, %39
  call void @vext_set_elems_1s(ptr noundef %34, i32 noundef %35, i32 noundef %mul21, i32 noundef %mul22)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vrgather_vx_d(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vlmax = alloca i32, align 4
  %vm = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %index = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @ctz64(i64 noundef 8)
  %call1 = call i32 @vext_max_elems(i32 noundef %0, i32 noundef %call)
  store i32 %call1, ptr %vlmax, align 4
  %1 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vm(i32 noundef %1)
  store i32 %call2, ptr %vm, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %vl3 = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %vl3, align 16
  %conv = trunc i64 %3 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %5 = load i32, ptr %desc.addr, align 4
  %6 = load i32, ptr %esz, align 4
  %call4 = call i32 @vext_get_total_elems(ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %total_elems, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call5 = call i32 @vext_vta(i32 noundef %7)
  store i32 %call5, ptr %vta, align 4
  %8 = load i32, ptr %desc.addr, align 4
  %call6 = call i32 @vext_vma(i32 noundef %8)
  store i32 %call6, ptr %vma, align 4
  %9 = load i64, ptr %s1.addr, align 8
  store i64 %9, ptr %index, align 8
  %10 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %10, i32 0, i32 6
  %11 = load i64, ptr %vstart, align 8
  %conv7 = trunc i64 %11 to i32
  store i32 %conv7, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %12 = load i32, ptr %i, align 4
  %13 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %12, %13
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %15 = load ptr, ptr %v0.addr, align 8
  %16 = load i32, ptr %i, align 4
  %call9 = call i32 @vext_elem_mask(ptr noundef %15, i32 noundef %16)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %17 = load ptr, ptr %vd.addr, align 8
  %18 = load i32, ptr %vma, align 4
  %19 = load i32, ptr %i, align 4
  %20 = load i32, ptr %esz, align 4
  %mul = mul i32 %19, %20
  %21 = load i32, ptr %i, align 4
  %add = add i32 %21, 1
  %22 = load i32, ptr %esz, align 4
  %mul11 = mul i32 %add, %22
  call void @vext_set_elems_1s(ptr noundef %17, i32 noundef %18, i32 noundef %mul, i32 noundef %mul11)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %23 = load i64, ptr %index, align 8
  %24 = load i32, ptr %vlmax, align 4
  %conv12 = zext i32 %24 to i64
  %cmp13 = icmp uge i64 %23, %conv12
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end
  %25 = load ptr, ptr %vd.addr, align 8
  %26 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %26 to i64
  %add.ptr = getelementptr i64, ptr %25, i64 %idx.ext
  store i64 0, ptr %add.ptr, align 8
  br label %if.end19

if.else:                                          ; preds = %if.end
  %27 = load ptr, ptr %vs2.addr, align 8
  %28 = load i64, ptr %index, align 8
  %add.ptr16 = getelementptr i64, ptr %27, i64 %28
  %29 = load i64, ptr %add.ptr16, align 8
  %30 = load ptr, ptr %vd.addr, align 8
  %31 = load i32, ptr %i, align 4
  %idx.ext17 = zext i32 %31 to i64
  %add.ptr18 = getelementptr i64, ptr %30, i64 %idx.ext17
  store i64 %29, ptr %add.ptr18, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then15
  br label %for.inc

for.inc:                                          ; preds = %if.end19, %if.then
  %32 = load i32, ptr %i, align 4
  %inc = add i32 %32, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !607

for.end:                                          ; preds = %for.cond
  %33 = load ptr, ptr %env.addr, align 8
  %vstart20 = getelementptr inbounds %struct.CPUArchState, ptr %33, i32 0, i32 6
  store i64 0, ptr %vstart20, align 8
  %34 = load ptr, ptr %vd.addr, align 8
  %35 = load i32, ptr %vta, align 4
  %36 = load i32, ptr %vl, align 4
  %37 = load i32, ptr %esz, align 4
  %mul21 = mul i32 %36, %37
  %38 = load i32, ptr %total_elems, align 4
  %39 = load i32, ptr %esz, align 4
  %mul22 = mul i32 %38, %39
  call void @vext_set_elems_1s(ptr noundef %34, i32 noundef %35, i32 noundef %mul21, i32 noundef %mul22)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vcompress_vm_b(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %num = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 1, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  store i32 0, ptr %num, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %10, i32 noundef %11)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %12 = load ptr, ptr %vs2.addr, align 8
  %13 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %13 to i64
  %add.ptr = getelementptr i8, ptr %12, i64 %idx.ext
  %14 = load i8, ptr %add.ptr, align 1
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %num, align 4
  %idx.ext6 = zext i32 %16 to i64
  %add.ptr7 = getelementptr i8, ptr %15, i64 %idx.ext6
  store i8 %14, ptr %add.ptr7, align 1
  %17 = load i32, ptr %num, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %num, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %18 = load i32, ptr %i, align 4
  %inc8 = add i32 %18, 1
  store i32 %inc8, ptr %i, align 4
  br label %for.cond, !llvm.loop !608

for.end:                                          ; preds = %for.cond
  %19 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %vta, align 4
  %22 = load i32, ptr %vl, align 4
  %23 = load i32, ptr %esz, align 4
  %mul = mul i32 %22, %23
  %24 = load i32, ptr %total_elems, align 4
  %25 = load i32, ptr %esz, align 4
  %mul10 = mul i32 %24, %25
  call void @vext_set_elems_1s(ptr noundef %20, i32 noundef %21, i32 noundef %mul, i32 noundef %mul10)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vcompress_vm_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %num = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 2, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  store i32 0, ptr %num, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %10, i32 noundef %11)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %12 = load ptr, ptr %vs2.addr, align 8
  %13 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %13 to i64
  %add.ptr = getelementptr i16, ptr %12, i64 %idx.ext
  %14 = load i16, ptr %add.ptr, align 2
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %num, align 4
  %idx.ext6 = zext i32 %16 to i64
  %add.ptr7 = getelementptr i16, ptr %15, i64 %idx.ext6
  store i16 %14, ptr %add.ptr7, align 2
  %17 = load i32, ptr %num, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %num, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %18 = load i32, ptr %i, align 4
  %inc8 = add i32 %18, 1
  store i32 %inc8, ptr %i, align 4
  br label %for.cond, !llvm.loop !609

for.end:                                          ; preds = %for.cond
  %19 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %vta, align 4
  %22 = load i32, ptr %vl, align 4
  %23 = load i32, ptr %esz, align 4
  %mul = mul i32 %22, %23
  %24 = load i32, ptr %total_elems, align 4
  %25 = load i32, ptr %esz, align 4
  %mul10 = mul i32 %24, %25
  call void @vext_set_elems_1s(ptr noundef %20, i32 noundef %21, i32 noundef %mul, i32 noundef %mul10)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vcompress_vm_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %num = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 4, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  store i32 0, ptr %num, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %10, i32 noundef %11)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %12 = load ptr, ptr %vs2.addr, align 8
  %13 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %13 to i64
  %add.ptr = getelementptr i32, ptr %12, i64 %idx.ext
  %14 = load i32, ptr %add.ptr, align 4
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %num, align 4
  %idx.ext6 = zext i32 %16 to i64
  %add.ptr7 = getelementptr i32, ptr %15, i64 %idx.ext6
  store i32 %14, ptr %add.ptr7, align 4
  %17 = load i32, ptr %num, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %num, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %18 = load i32, ptr %i, align 4
  %inc8 = add i32 %18, 1
  store i32 %inc8, ptr %i, align 4
  br label %for.cond, !llvm.loop !610

for.end:                                          ; preds = %for.cond
  %19 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %vta, align 4
  %22 = load i32, ptr %vl, align 4
  %23 = load i32, ptr %esz, align 4
  %mul = mul i32 %22, %23
  %24 = load i32, ptr %total_elems, align 4
  %25 = load i32, ptr %esz, align 4
  %mul10 = mul i32 %24, %25
  call void @vext_set_elems_1s(ptr noundef %20, i32 noundef %21, i32 noundef %mul, i32 noundef %mul10)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vcompress_vm_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %num = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  store i32 8, ptr %esz, align 4
  %2 = load ptr, ptr %env.addr, align 8
  %3 = load i32, ptr %desc.addr, align 4
  %4 = load i32, ptr %esz, align 4
  %call = call i32 @vext_get_total_elems(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  store i32 %call, ptr %total_elems, align 4
  %5 = load i32, ptr %desc.addr, align 4
  %call2 = call i32 @vext_vta(i32 noundef %5)
  store i32 %call2, ptr %vta, align 4
  store i32 0, ptr %num, align 4
  %6 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %vstart, align 8
  %conv3 = trunc i64 %7 to i32
  store i32 %conv3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %vs1.addr, align 8
  %11 = load i32, ptr %i, align 4
  %call5 = call i32 @vext_elem_mask(ptr noundef %10, i32 noundef %11)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %12 = load ptr, ptr %vs2.addr, align 8
  %13 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %13 to i64
  %add.ptr = getelementptr i64, ptr %12, i64 %idx.ext
  %14 = load i64, ptr %add.ptr, align 8
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %num, align 4
  %idx.ext6 = zext i32 %16 to i64
  %add.ptr7 = getelementptr i64, ptr %15, i64 %idx.ext6
  store i64 %14, ptr %add.ptr7, align 8
  %17 = load i32, ptr %num, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %num, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %18 = load i32, ptr %i, align 4
  %inc8 = add i32 %18, 1
  store i32 %inc8, ptr %i, align 4
  br label %for.cond, !llvm.loop !611

for.end:                                          ; preds = %for.cond
  %19 = load ptr, ptr %env.addr, align 8
  %vstart9 = getelementptr inbounds %struct.CPUArchState, ptr %19, i32 0, i32 6
  store i64 0, ptr %vstart9, align 8
  %20 = load ptr, ptr %vd.addr, align 8
  %21 = load i32, ptr %vta, align 4
  %22 = load i32, ptr %vl, align 4
  %23 = load i32, ptr %esz, align 4
  %mul = mul i32 %22, %23
  %24 = load i32, ptr %total_elems, align 4
  %25 = load i32, ptr %esz, align 4
  %mul10 = mul i32 %24, %25
  call void @vext_set_elems_1s(ptr noundef %20, i32 noundef %21, i32 noundef %mul, i32 noundef %mul10)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vmvr_v(ptr noundef %vd, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %maxsz = alloca i32, align 4
  %sewb = alloca i32, align 4
  %startb = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i64 @simd_maxsz(i32 noundef %0)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %maxsz, align 4
  %1 = load ptr, ptr %env.addr, align 8
  %vtype = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 7
  %2 = load i64, ptr %vtype, align 16
  %call1 = call i64 @extract64(i64 noundef %2, i32 noundef 3, i32 noundef 3)
  %sh_prom = trunc i64 %call1 to i32
  %shl = shl i32 1, %sh_prom
  store i32 %shl, ptr %sewb, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %3, i32 0, i32 6
  %4 = load i64, ptr %vstart, align 8
  %5 = load i32, ptr %sewb, align 4
  %conv2 = zext i32 %5 to i64
  %mul = mul i64 %4, %conv2
  %conv3 = trunc i64 %mul to i32
  store i32 %conv3, ptr %startb, align 4
  %6 = load i32, ptr %startb, align 4
  store i32 %6, ptr %i, align 4
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %8 to i64
  %add.ptr = getelementptr i8, ptr %7, i64 %idx.ext
  %9 = load ptr, ptr %vs2.addr, align 8
  %10 = load i32, ptr %i, align 4
  %idx.ext4 = zext i32 %10 to i64
  %add.ptr5 = getelementptr i8, ptr %9, i64 %idx.ext4
  %11 = load i32, ptr %maxsz, align 4
  %12 = load i32, ptr %startb, align 4
  %sub = sub i32 %11, %12
  %conv6 = zext i32 %sub to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr, ptr align 1 %add.ptr5, i64 %conv6, i1 false)
  %13 = load ptr, ptr %env.addr, align 8
  %vstart7 = getelementptr inbounds %struct.CPUArchState, ptr %13, i32 0, i32 6
  store i64 0, ptr %vstart7, align 8
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #4

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vzext_vf2_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  %conv10 = zext i8 %23 to i16
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr i16, ptr %24, i64 %idx.ext11
  store i16 %conv10, ptr %add.ptr12, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !612

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %vta, align 4
  %30 = load i32, ptr %vl, align 4
  %31 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %30, %31
  %32 = load i32, ptr %total_elems, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  call void @vext_set_elems_1s(ptr noundef %28, i32 noundef %29, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vzext_vf2_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  %conv10 = zext i16 %23 to i32
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr i32, ptr %24, i64 %idx.ext11
  store i32 %conv10, ptr %add.ptr12, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !613

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %vta, align 4
  %30 = load i32, ptr %vl, align 4
  %31 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %30, %31
  %32 = load i32, ptr %total_elems, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  call void @vext_set_elems_1s(ptr noundef %28, i32 noundef %29, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vzext_vf2_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i32, ptr %21, i64 %idx.ext
  %23 = load i32, ptr %add.ptr, align 4
  %conv10 = zext i32 %23 to i64
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr i64, ptr %24, i64 %idx.ext11
  store i64 %conv10, ptr %add.ptr12, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !614

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %vta, align 4
  %30 = load i32, ptr %vl, align 4
  %31 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %30, %31
  %32 = load i32, ptr %total_elems, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  call void @vext_set_elems_1s(ptr noundef %28, i32 noundef %29, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vzext_vf4_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  %conv10 = zext i8 %23 to i32
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr i32, ptr %24, i64 %idx.ext11
  store i32 %conv10, ptr %add.ptr12, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !615

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %vta, align 4
  %30 = load i32, ptr %vl, align 4
  %31 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %30, %31
  %32 = load i32, ptr %total_elems, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  call void @vext_set_elems_1s(ptr noundef %28, i32 noundef %29, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vzext_vf4_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  %conv10 = zext i16 %23 to i64
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr i64, ptr %24, i64 %idx.ext11
  store i64 %conv10, ptr %add.ptr12, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !616

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %vta, align 4
  %30 = load i32, ptr %vl, align 4
  %31 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %30, %31
  %32 = load i32, ptr %total_elems, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  call void @vext_set_elems_1s(ptr noundef %28, i32 noundef %29, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vzext_vf8_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  %conv10 = zext i8 %23 to i64
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr i64, ptr %24, i64 %idx.ext11
  store i64 %conv10, ptr %add.ptr12, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !617

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %vta, align 4
  %30 = load i32, ptr %vl, align 4
  %31 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %30, %31
  %32 = load i32, ptr %total_elems, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  call void @vext_set_elems_1s(ptr noundef %28, i32 noundef %29, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsext_vf2_h(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  store i32 2, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  %conv10 = sext i8 %23 to i16
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr i16, ptr %24, i64 %idx.ext11
  store i16 %conv10, ptr %add.ptr12, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !618

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %vta, align 4
  %30 = load i32, ptr %vl, align 4
  %31 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %30, %31
  %32 = load i32, ptr %total_elems, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  call void @vext_set_elems_1s(ptr noundef %28, i32 noundef %29, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsext_vf2_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  %conv10 = sext i16 %23 to i32
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr i32, ptr %24, i64 %idx.ext11
  store i32 %conv10, ptr %add.ptr12, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !619

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %vta, align 4
  %30 = load i32, ptr %vl, align 4
  %31 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %30, %31
  %32 = load i32, ptr %total_elems, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  call void @vext_set_elems_1s(ptr noundef %28, i32 noundef %29, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsext_vf2_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i32, ptr %21, i64 %idx.ext
  %23 = load i32, ptr %add.ptr, align 4
  %conv10 = sext i32 %23 to i64
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr i64, ptr %24, i64 %idx.ext11
  store i64 %conv10, ptr %add.ptr12, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !620

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %vta, align 4
  %30 = load i32, ptr %vl, align 4
  %31 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %30, %31
  %32 = load i32, ptr %total_elems, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  call void @vext_set_elems_1s(ptr noundef %28, i32 noundef %29, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsext_vf4_w(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  store i32 4, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  %conv10 = sext i8 %23 to i32
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr i32, ptr %24, i64 %idx.ext11
  store i32 %conv10, ptr %add.ptr12, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !621

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %vta, align 4
  %30 = load i32, ptr %vl, align 4
  %31 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %30, %31
  %32 = load i32, ptr %total_elems, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  call void @vext_set_elems_1s(ptr noundef %28, i32 noundef %29, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsext_vf4_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i16, ptr %21, i64 %idx.ext
  %23 = load i16, ptr %add.ptr, align 2
  %conv10 = sext i16 %23 to i64
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr i64, ptr %24, i64 %idx.ext11
  store i64 %conv10, ptr %add.ptr12, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !622

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %vta, align 4
  %30 = load i32, ptr %vl, align 4
  %31 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %30, %31
  %32 = load i32, ptr %total_elems, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  call void @vext_set_elems_1s(ptr noundef %28, i32 noundef %29, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @helper_vsext_vf8_d(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs2, ptr noundef %env, i32 noundef %desc) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %vl = alloca i32, align 4
  %vm = alloca i32, align 4
  %esz = alloca i32, align 4
  %total_elems = alloca i32, align 4
  %vta = alloca i32, align 4
  %vma = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vl1 = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %vl1, align 16
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %vl, align 4
  %2 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vm(i32 noundef %2)
  store i32 %call, ptr %vm, align 4
  store i32 8, ptr %esz, align 4
  %3 = load ptr, ptr %env.addr, align 8
  %4 = load i32, ptr %desc.addr, align 4
  %5 = load i32, ptr %esz, align 4
  %call2 = call i32 @vext_get_total_elems(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  store i32 %call2, ptr %total_elems, align 4
  %6 = load i32, ptr %desc.addr, align 4
  %call3 = call i32 @vext_vta(i32 noundef %6)
  store i32 %call3, ptr %vta, align 4
  %7 = load i32, ptr %desc.addr, align 4
  %call4 = call i32 @vext_vma(i32 noundef %7)
  store i32 %call4, ptr %vma, align 4
  %8 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %vstart, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, ptr %i, align 4
  %11 = load i32, ptr %vl, align 4
  %cmp = icmp ult i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %vm, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load i32, ptr %i, align 4
  %call7 = call i32 @vext_elem_mask(ptr noundef %13, i32 noundef %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %15 = load ptr, ptr %vd.addr, align 8
  %16 = load i32, ptr %vma, align 4
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %esz, align 4
  %mul = mul i32 %17, %18
  %19 = load i32, ptr %i, align 4
  %add = add i32 %19, 1
  %20 = load i32, ptr %esz, align 4
  %mul9 = mul i32 %add, %20
  call void @vext_set_elems_1s(ptr noundef %15, i32 noundef %16, i32 noundef %mul, i32 noundef %mul9)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %21 = load ptr, ptr %vs2.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %22 to i64
  %add.ptr = getelementptr i8, ptr %21, i64 %idx.ext
  %23 = load i8, ptr %add.ptr, align 1
  %conv10 = sext i8 %23 to i64
  %24 = load ptr, ptr %vd.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idx.ext11 = zext i32 %25 to i64
  %add.ptr12 = getelementptr i64, ptr %24, i64 %idx.ext11
  store i64 %conv10, ptr %add.ptr12, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %26 = load i32, ptr %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !623

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %env.addr, align 8
  %vstart13 = getelementptr inbounds %struct.CPUArchState, ptr %27, i32 0, i32 6
  store i64 0, ptr %vstart13, align 8
  %28 = load ptr, ptr %vd.addr, align 8
  %29 = load i32, ptr %vta, align 4
  %30 = load i32, ptr %vl, align 4
  %31 = load i32, ptr %esz, align 4
  %mul14 = mul i32 %30, %31
  %32 = load i32, ptr %total_elems, align 4
  %33 = load i32, ptr %esz, align 4
  %mul15 = mul i32 %32, %33
  call void @vext_set_elems_1s(ptr noundef %28, i32 noundef %29, i32 noundef %mul14, i32 noundef %mul15)
  ret void
}

; Function Attrs: noreturn nounwind
declare void @__assert_fail(ptr noundef, ptr noundef, i32 noundef, ptr noundef) #5

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sextract32(i32 noundef %value, i32 noundef %start, i32 noundef %length) #0 {
entry:
  %value.addr = alloca i32, align 4
  %start.addr = alloca i32, align 4
  %length.addr = alloca i32, align 4
  store i32 %value, ptr %value.addr, align 4
  store i32 %start, ptr %start.addr, align 4
  store i32 %length, ptr %length.addr, align 4
  %0 = load i32, ptr %start.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %length.addr, align 4
  %cmp1 = icmp sgt i32 %1, 0
  br i1 %cmp1, label %land.lhs.true2, label %if.else

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i32, ptr %length.addr, align 4
  %3 = load i32, ptr %start.addr, align 4
  %sub = sub i32 32, %3
  %cmp3 = icmp sle i32 %2, %sub
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true2
  br label %if.end

if.else:                                          ; preds = %land.lhs.true2, %land.lhs.true, %entry
  call void @__assert_fail(ptr noundef @.str.2, ptr noundef @.str.1, i32 noundef 417, ptr noundef @__PRETTY_FUNCTION__.sextract32) #7
  unreachable

if.end:                                           ; preds = %if.then
  %4 = load i32, ptr %value.addr, align 4
  %5 = load i32, ptr %length.addr, align 4
  %sub4 = sub i32 32, %5
  %6 = load i32, ptr %start.addr, align 4
  %sub5 = sub i32 %sub4, %6
  %shl = shl i32 %4, %sub5
  %7 = load i32, ptr %length.addr, align 4
  %sub6 = sub i32 32, %7
  %shr = ashr i32 %shl, %sub6
  ret i32 %shr
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @extract32(i32 noundef %value, i32 noundef %start, i32 noundef %length) #0 {
entry:
  %value.addr = alloca i32, align 4
  %start.addr = alloca i32, align 4
  %length.addr = alloca i32, align 4
  store i32 %value, ptr %value.addr, align 4
  store i32 %start, ptr %start.addr, align 4
  store i32 %length, ptr %length.addr, align 4
  %0 = load i32, ptr %start.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %length.addr, align 4
  %cmp1 = icmp sgt i32 %1, 0
  br i1 %cmp1, label %land.lhs.true2, label %if.else

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i32, ptr %length.addr, align 4
  %3 = load i32, ptr %start.addr, align 4
  %sub = sub i32 32, %3
  %cmp3 = icmp sle i32 %2, %sub
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true2
  br label %if.end

if.else:                                          ; preds = %land.lhs.true2, %land.lhs.true, %entry
  call void @__assert_fail(ptr noundef @.str.2, ptr noundef @.str.1, i32 noundef 338, ptr noundef @__PRETTY_FUNCTION__.extract32) #7
  unreachable

if.end:                                           ; preds = %if.then
  %4 = load i32, ptr %value.addr, align 4
  %5 = load i32, ptr %start.addr, align 4
  %shr = lshr i32 %4, %5
  %6 = load i32, ptr %length.addr, align 4
  %sub4 = sub i32 32, %6
  %shr5 = lshr i32 -1, %sub4
  %and = and i32 %shr, %shr5
  ret i32 %and
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @simd_data(i32 noundef %desc) #0 {
entry:
  %desc.addr = alloca i32, align 4
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @sextract32(i32 noundef %0, i32 noundef 10, i32 noundef 22)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @adjust_addr(ptr noundef %env, i64 noundef %addr) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i64, ptr %addr.addr, align 8
  %1 = load ptr, ptr %env.addr, align 8
  %cur_pmmask = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 29
  %2 = load i64, ptr %cur_pmmask, align 16
  %not = xor i64 %2, -1
  %and = and i64 %0, %not
  %3 = load ptr, ptr %env.addr, align 8
  %cur_pmbase = getelementptr inbounds %struct.CPUArchState, ptr %3, i32 0, i32 30
  %4 = load i64, ptr %cur_pmbase, align 8
  %or = or i64 %and, %4
  ret i64 %or
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vext_set_tail_elems_1s(i64 noundef %vl, ptr noundef %vd, i32 noundef %desc, i32 noundef %nf, i32 noundef %esz, i32 noundef %max_elems) #0 {
entry:
  %vl.addr = alloca i64, align 8
  %vd.addr = alloca ptr, align 8
  %desc.addr = alloca i32, align 4
  %nf.addr = alloca i32, align 4
  %esz.addr = alloca i32, align 4
  %max_elems.addr = alloca i32, align 4
  %vta = alloca i32, align 4
  %k = alloca i32, align 4
  store i64 %vl, ptr %vl.addr, align 8
  store ptr %vd, ptr %vd.addr, align 8
  store i32 %desc, ptr %desc.addr, align 4
  store i32 %nf, ptr %nf.addr, align 4
  store i32 %esz, ptr %esz.addr, align 4
  store i32 %max_elems, ptr %max_elems.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @vext_vta(i32 noundef %0)
  store i32 %call, ptr %vta, align 4
  %1 = load i32, ptr %vta, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, ptr %k, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load i32, ptr %k, align 4
  %3 = load i32, ptr %nf.addr, align 4
  %cmp1 = icmp ult i32 %2, %3
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %vd.addr, align 8
  %5 = load i32, ptr %vta, align 4
  %6 = load i32, ptr %k, align 4
  %7 = load i32, ptr %max_elems.addr, align 4
  %mul = mul i32 %6, %7
  %conv = zext i32 %mul to i64
  %8 = load i64, ptr %vl.addr, align 8
  %add = add i64 %conv, %8
  %9 = load i32, ptr %esz.addr, align 4
  %conv2 = zext i32 %9 to i64
  %mul3 = mul i64 %add, %conv2
  %conv4 = trunc i64 %mul3 to i32
  %10 = load i32, ptr %k, align 4
  %11 = load i32, ptr %max_elems.addr, align 4
  %mul5 = mul i32 %10, %11
  %12 = load i32, ptr %max_elems.addr, align 4
  %add6 = add i32 %mul5, %12
  %13 = load i32, ptr %esz.addr, align 4
  %mul7 = mul i32 %add6, %13
  call void @vext_set_elems_1s(ptr noundef %4, i32 noundef %5, i32 noundef %conv4, i32 noundef %mul7)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, ptr %k, align 4
  %inc = add i32 %14, 1
  store i32 %inc, ptr %k, align 4
  br label %for.cond, !llvm.loop !624

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

declare i32 @cpu_ldsb_data_ra(ptr noundef, i64 noundef, i64 noundef) #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.cttz.i64(i64, i1 immarg) #6

declare i32 @cpu_ldsw_le_data_ra(ptr noundef, i64 noundef, i64 noundef) #2

declare i32 @cpu_ldl_le_data_ra(ptr noundef, i64 noundef, i64 noundef) #2

declare i64 @cpu_ldq_le_data_ra(ptr noundef, i64 noundef, i64 noundef) #2

declare void @cpu_stb_data_ra(ptr noundef, i64 noundef, i32 noundef, i64 noundef) #2

declare void @cpu_stw_le_data_ra(ptr noundef, i64 noundef, i32 noundef, i64 noundef) #2

declare void @cpu_stl_le_data_ra(ptr noundef, i64 noundef, i32 noundef, i64 noundef) #2

declare void @cpu_stq_le_data_ra(ptr noundef, i64 noundef, i64 noundef, i64 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @probe_pages(ptr noundef %env, i64 noundef %addr, i64 noundef %len, i64 noundef %ra, i32 noundef %access_type) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %ra.addr = alloca i64, align 8
  %access_type.addr = alloca i32, align 4
  %pagelen = alloca i64, align 8
  %curlen = alloca i64, align 8
  %_a0 = alloca i64, align 8
  %_b1 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i64 %ra, ptr %ra.addr, align 8
  store i32 %access_type, ptr %access_type.addr, align 4
  %0 = load i64, ptr %addr.addr, align 8
  %or = or i64 %0, -4096
  %sub = sub i64 0, %or
  store i64 %sub, ptr %pagelen, align 8
  %1 = load i64, ptr %pagelen, align 8
  store i64 %1, ptr %_a0, align 8
  %2 = load i64, ptr %len.addr, align 8
  store i64 %2, ptr %_b1, align 8
  %3 = load i64, ptr %_a0, align 8
  %4 = load i64, ptr %_b1, align 8
  %cmp = icmp ult i64 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, ptr %_a0, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, ptr %_b1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %6, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %7 = load i64, ptr %tmp, align 8
  store i64 %7, ptr %curlen, align 8
  %8 = load ptr, ptr %env.addr, align 8
  %9 = load ptr, ptr %env.addr, align 8
  %10 = load i64, ptr %addr.addr, align 8
  %call = call i64 @adjust_addr(ptr noundef %9, i64 noundef %10)
  %11 = load i64, ptr %curlen, align 8
  %conv = trunc i64 %11 to i32
  %12 = load i32, ptr %access_type.addr, align 4
  %13 = load ptr, ptr %env.addr, align 8
  %call1 = call i32 @riscv_cpu_mmu_index(ptr noundef %13, i1 noundef zeroext false)
  %14 = load i64, ptr %ra.addr, align 8
  %call2 = call ptr @probe_access(ptr noundef %8, i64 noundef %call, i32 noundef %conv, i32 noundef %12, i32 noundef %call1, i64 noundef %14)
  %15 = load i64, ptr %len.addr, align 8
  %16 = load i64, ptr %curlen, align 8
  %cmp3 = icmp ugt i64 %15, %16
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %17 = load i64, ptr %curlen, align 8
  %18 = load i64, ptr %addr.addr, align 8
  %add = add i64 %18, %17
  store i64 %add, ptr %addr.addr, align 8
  %19 = load i64, ptr %len.addr, align 8
  %20 = load i64, ptr %curlen, align 8
  %sub5 = sub i64 %19, %20
  store i64 %sub5, ptr %curlen, align 8
  %21 = load ptr, ptr %env.addr, align 8
  %22 = load ptr, ptr %env.addr, align 8
  %23 = load i64, ptr %addr.addr, align 8
  %call6 = call i64 @adjust_addr(ptr noundef %22, i64 noundef %23)
  %24 = load i64, ptr %curlen, align 8
  %conv7 = trunc i64 %24 to i32
  %25 = load i32, ptr %access_type.addr, align 4
  %26 = load ptr, ptr %env.addr, align 8
  %call8 = call i32 @riscv_cpu_mmu_index(ptr noundef %26, i1 noundef zeroext false)
  %27 = load i64, ptr %ra.addr, align 8
  %call9 = call ptr @probe_access(ptr noundef %21, i64 noundef %call6, i32 noundef %conv7, i32 noundef %25, i32 noundef %call8, i64 noundef %27)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tlb_vaddr_to_host(ptr noundef %env, i64 noundef %addr, i32 noundef %access_type, i32 noundef %mmu_idx) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %access_type.addr = alloca i32, align 4
  %mmu_idx.addr = alloca i32, align 4
  store ptr %env, ptr %env.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %access_type, ptr %access_type.addr, align 4
  store i32 %mmu_idx, ptr %mmu_idx.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %call = call ptr @env_cpu(ptr noundef %0)
  %1 = load i64, ptr %addr.addr, align 8
  %call1 = call ptr @g2h(ptr noundef %call, i64 noundef %1)
  ret ptr %call1
}

declare i32 @riscv_cpu_mmu_index(ptr noundef, i1 noundef zeroext) #2

declare zeroext i1 @page_check_range(i64 noundef, i64 noundef, i32 noundef) #2

declare ptr @probe_access(ptr noundef, i64 noundef, i32 noundef, i32 noundef, i32 noundef, i64 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @g2h(ptr noundef %cs, i64 noundef %x) #0 {
entry:
  %cs.addr = alloca ptr, align 8
  %x.addr = alloca i64, align 8
  store ptr %cs, ptr %cs.addr, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %cs.addr, align 8
  %1 = load i64, ptr %x.addr, align 8
  %call = call i64 @cpu_untagged_addr(ptr noundef %0, i64 noundef %1)
  %call1 = call ptr @g2h_untagged(i64 noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @env_cpu(ptr noundef %env) #0 {
entry:
  %env.addr = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %env.addr, align 8
  %add.ptr = getelementptr i8, ptr %0, i64 -10176
  ret ptr %add.ptr
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @g2h_untagged(i64 noundef %x) #0 {
entry:
  %x.addr = alloca i64, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load i64, ptr %x.addr, align 8
  %1 = load i64, ptr @guest_base, align 8
  %add = add i64 %0, %1
  %2 = inttoptr i64 %add to ptr
  ret ptr %2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @cpu_untagged_addr(ptr noundef %cs, i64 noundef %x) #0 {
entry:
  %cs.addr = alloca ptr, align 8
  %x.addr = alloca i64, align 8
  store ptr %cs, ptr %cs.addr, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load i64, ptr %x.addr, align 8
  ret i64 %0
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vext_lmul(i32 noundef %desc) #0 {
entry:
  %desc.addr = alloca i32, align 4
  store i32 %desc, ptr %desc.addr, align 4
  %0 = load i32, ptr %desc.addr, align 4
  %call = call i32 @simd_data(i32 noundef %0)
  %call1 = call i32 @extract32(i32 noundef %call, i32 noundef 1, i32 noundef 3)
  %call2 = call i32 @sextract32(i32 noundef %call1, i32 noundef 0, i32 noundef 3)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @deposit64(i64 noundef %value, i32 noundef %start, i32 noundef %length, i64 noundef %fieldval) #0 {
entry:
  %value.addr = alloca i64, align 8
  %start.addr = alloca i32, align 4
  %length.addr = alloca i32, align 4
  %fieldval.addr = alloca i64, align 8
  %mask = alloca i64, align 8
  store i64 %value, ptr %value.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %length, ptr %length.addr, align 4
  store i64 %fieldval, ptr %fieldval.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %length.addr, align 4
  %cmp1 = icmp sgt i32 %1, 0
  br i1 %cmp1, label %land.lhs.true2, label %if.else

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i32, ptr %length.addr, align 4
  %3 = load i32, ptr %start.addr, align 4
  %sub = sub i32 64, %3
  %cmp3 = icmp sle i32 %2, %sub
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true2
  br label %if.end

if.else:                                          ; preds = %land.lhs.true2, %land.lhs.true, %entry
  call void @__assert_fail(ptr noundef @.str, ptr noundef @.str.1, i32 noundef 496, ptr noundef @__PRETTY_FUNCTION__.deposit64) #7
  unreachable

if.end:                                           ; preds = %if.then
  %4 = load i32, ptr %length.addr, align 4
  %sub4 = sub i32 64, %4
  %sh_prom = zext i32 %sub4 to i64
  %shr = lshr i64 -1, %sh_prom
  %5 = load i32, ptr %start.addr, align 4
  %sh_prom5 = zext i32 %5 to i64
  %shl = shl i64 %shr, %sh_prom5
  store i64 %shl, ptr %mask, align 8
  %6 = load i64, ptr %value.addr, align 8
  %7 = load i64, ptr %mask, align 8
  %not = xor i64 %7, -1
  %and = and i64 %6, %not
  %8 = load i64, ptr %fieldval.addr, align 8
  %9 = load i32, ptr %start.addr, align 4
  %sh_prom6 = zext i32 %9 to i64
  %shl7 = shl i64 %8, %sh_prom6
  %10 = load i64, ptr %mask, align 8
  %and8 = and i64 %shl7, %10
  %or = or i64 %and, %and8
  ret i64 %or
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i8 @do_mulh_b(i8 noundef signext %s2, i8 noundef signext %s1) #0 {
entry:
  %s2.addr = alloca i8, align 1
  %s1.addr = alloca i8, align 1
  store i8 %s2, ptr %s2.addr, align 1
  store i8 %s1, ptr %s1.addr, align 1
  %0 = load i8, ptr %s2.addr, align 1
  %conv = sext i8 %0 to i16
  %conv1 = sext i16 %conv to i32
  %1 = load i8, ptr %s1.addr, align 1
  %conv2 = sext i8 %1 to i16
  %conv3 = sext i16 %conv2 to i32
  %mul = mul i32 %conv1, %conv3
  %shr = ashr i32 %mul, 8
  %conv4 = trunc i32 %shr to i8
  ret i8 %conv4
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i16 @do_mulh_h(i16 noundef signext %s2, i16 noundef signext %s1) #0 {
entry:
  %s2.addr = alloca i16, align 2
  %s1.addr = alloca i16, align 2
  store i16 %s2, ptr %s2.addr, align 2
  store i16 %s1, ptr %s1.addr, align 2
  %0 = load i16, ptr %s2.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, ptr %s1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %mul = mul i32 %conv, %conv1
  %shr = ashr i32 %mul, 16
  %conv2 = trunc i32 %shr to i16
  ret i16 %conv2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @do_mulh_w(i32 noundef %s2, i32 noundef %s1) #0 {
entry:
  %s2.addr = alloca i32, align 4
  %s1.addr = alloca i32, align 4
  store i32 %s2, ptr %s2.addr, align 4
  store i32 %s1, ptr %s1.addr, align 4
  %0 = load i32, ptr %s2.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load i32, ptr %s1.addr, align 4
  %conv1 = sext i32 %1 to i64
  %mul = mul i64 %conv, %conv1
  %shr = ashr i64 %mul, 32
  %conv2 = trunc i64 %shr to i32
  ret i32 %conv2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_mulh_d(i64 noundef %s2, i64 noundef %s1) #0 {
entry:
  %s2.addr = alloca i64, align 8
  %s1.addr = alloca i64, align 8
  %hi_64 = alloca i64, align 8
  %lo_64 = alloca i64, align 8
  store i64 %s2, ptr %s2.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  %0 = load i64, ptr %s1.addr, align 8
  %1 = load i64, ptr %s2.addr, align 8
  call void @muls64(ptr noundef %lo_64, ptr noundef %hi_64, i64 noundef %0, i64 noundef %1)
  %2 = load i64, ptr %hi_64, align 8
  ret i64 %2
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @muls64(ptr noundef %plow, ptr noundef %phigh, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %plow.addr = alloca ptr, align 8
  %phigh.addr = alloca ptr, align 8
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %r = alloca i128, align 16
  store ptr %plow, ptr %plow.addr, align 8
  store ptr %phigh, ptr %phigh.addr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %conv = sext i64 %0 to i128
  %1 = load i64, ptr %b.addr, align 8
  %conv1 = sext i64 %1 to i128
  %mul = mul i128 %conv, %conv1
  store i128 %mul, ptr %r, align 16
  %2 = load i128, ptr %r, align 16
  %conv2 = trunc i128 %2 to i64
  %3 = load ptr, ptr %plow.addr, align 8
  store i64 %conv2, ptr %3, align 8
  %4 = load i128, ptr %r, align 16
  %shr = ashr i128 %4, 64
  %conv3 = trunc i128 %shr to i64
  %5 = load ptr, ptr %phigh.addr, align 8
  store i64 %conv3, ptr %5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i8 @do_mulhu_b(i8 noundef zeroext %s2, i8 noundef zeroext %s1) #0 {
entry:
  %s2.addr = alloca i8, align 1
  %s1.addr = alloca i8, align 1
  store i8 %s2, ptr %s2.addr, align 1
  store i8 %s1, ptr %s1.addr, align 1
  %0 = load i8, ptr %s2.addr, align 1
  %conv = zext i8 %0 to i16
  %conv1 = zext i16 %conv to i32
  %1 = load i8, ptr %s1.addr, align 1
  %conv2 = zext i8 %1 to i16
  %conv3 = zext i16 %conv2 to i32
  %mul = mul i32 %conv1, %conv3
  %shr = ashr i32 %mul, 8
  %conv4 = trunc i32 %shr to i8
  ret i8 %conv4
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @do_mulhu_h(i16 noundef zeroext %s2, i16 noundef zeroext %s1) #0 {
entry:
  %s2.addr = alloca i16, align 2
  %s1.addr = alloca i16, align 2
  store i16 %s2, ptr %s2.addr, align 2
  store i16 %s1, ptr %s1.addr, align 2
  %0 = load i16, ptr %s2.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, ptr %s1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %mul = mul i32 %conv, %conv1
  %shr = lshr i32 %mul, 16
  %conv2 = trunc i32 %shr to i16
  ret i16 %conv2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @do_mulhu_w(i32 noundef %s2, i32 noundef %s1) #0 {
entry:
  %s2.addr = alloca i32, align 4
  %s1.addr = alloca i32, align 4
  store i32 %s2, ptr %s2.addr, align 4
  store i32 %s1, ptr %s1.addr, align 4
  %0 = load i32, ptr %s2.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = load i32, ptr %s1.addr, align 4
  %conv1 = zext i32 %1 to i64
  %mul = mul i64 %conv, %conv1
  %shr = lshr i64 %mul, 32
  %conv2 = trunc i64 %shr to i32
  ret i32 %conv2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_mulhu_d(i64 noundef %s2, i64 noundef %s1) #0 {
entry:
  %s2.addr = alloca i64, align 8
  %s1.addr = alloca i64, align 8
  %hi_64 = alloca i64, align 8
  %lo_64 = alloca i64, align 8
  store i64 %s2, ptr %s2.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  %0 = load i64, ptr %s2.addr, align 8
  %1 = load i64, ptr %s1.addr, align 8
  call void @mulu64(ptr noundef %lo_64, ptr noundef %hi_64, i64 noundef %0, i64 noundef %1)
  %2 = load i64, ptr %hi_64, align 8
  ret i64 %2
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @mulu64(ptr noundef %plow, ptr noundef %phigh, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %plow.addr = alloca ptr, align 8
  %phigh.addr = alloca ptr, align 8
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %r = alloca i128, align 16
  store ptr %plow, ptr %plow.addr, align 8
  store ptr %phigh, ptr %phigh.addr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %conv = zext i64 %0 to i128
  %1 = load i64, ptr %b.addr, align 8
  %conv1 = zext i64 %1 to i128
  %mul = mul i128 %conv, %conv1
  store i128 %mul, ptr %r, align 16
  %2 = load i128, ptr %r, align 16
  %conv2 = trunc i128 %2 to i64
  %3 = load ptr, ptr %plow.addr, align 8
  store i64 %conv2, ptr %3, align 8
  %4 = load i128, ptr %r, align 16
  %shr = lshr i128 %4, 64
  %conv3 = trunc i128 %shr to i64
  %5 = load ptr, ptr %phigh.addr, align 8
  store i64 %conv3, ptr %5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i8 @do_mulhsu_b(i8 noundef signext %s2, i8 noundef zeroext %s1) #0 {
entry:
  %s2.addr = alloca i8, align 1
  %s1.addr = alloca i8, align 1
  store i8 %s2, ptr %s2.addr, align 1
  store i8 %s1, ptr %s1.addr, align 1
  %0 = load i8, ptr %s2.addr, align 1
  %conv = sext i8 %0 to i16
  %conv1 = sext i16 %conv to i32
  %1 = load i8, ptr %s1.addr, align 1
  %conv2 = zext i8 %1 to i16
  %conv3 = zext i16 %conv2 to i32
  %mul = mul i32 %conv1, %conv3
  %shr = ashr i32 %mul, 8
  %conv4 = trunc i32 %shr to i8
  ret i8 %conv4
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i16 @do_mulhsu_h(i16 noundef signext %s2, i16 noundef zeroext %s1) #0 {
entry:
  %s2.addr = alloca i16, align 2
  %s1.addr = alloca i16, align 2
  store i16 %s2, ptr %s2.addr, align 2
  store i16 %s1, ptr %s1.addr, align 2
  %0 = load i16, ptr %s2.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, ptr %s1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %mul = mul i32 %conv, %conv1
  %shr = lshr i32 %mul, 16
  %conv2 = trunc i32 %shr to i16
  ret i16 %conv2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @do_mulhsu_w(i32 noundef %s2, i32 noundef %s1) #0 {
entry:
  %s2.addr = alloca i32, align 4
  %s1.addr = alloca i32, align 4
  store i32 %s2, ptr %s2.addr, align 4
  store i32 %s1, ptr %s1.addr, align 4
  %0 = load i32, ptr %s2.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load i32, ptr %s1.addr, align 4
  %conv1 = zext i32 %1 to i64
  %mul = mul i64 %conv, %conv1
  %shr = lshr i64 %mul, 32
  %conv2 = trunc i64 %shr to i32
  ret i32 %conv2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_mulhsu_d(i64 noundef %s2, i64 noundef %s1) #0 {
entry:
  %s2.addr = alloca i64, align 8
  %s1.addr = alloca i64, align 8
  %hi_64 = alloca i64, align 8
  %lo_64 = alloca i64, align 8
  store i64 %s2, ptr %s2.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  %0 = load i64, ptr %s2.addr, align 8
  %1 = load i64, ptr %s1.addr, align 8
  call void @mulu64(ptr noundef %lo_64, ptr noundef %hi_64, i64 noundef %0, i64 noundef %1)
  %2 = load i64, ptr %s2.addr, align 8
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i64, ptr %s1.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %3, %cond.true ], [ 0, %cond.false ]
  %4 = load i64, ptr %hi_64, align 8
  %sub = sub i64 %4, %cond
  store i64 %sub, ptr %hi_64, align 8
  %5 = load i64, ptr %hi_64, align 8
  ret i64 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vext_vv_rm_1(ptr noundef %vd, ptr noundef %v0, ptr noundef %vs1, ptr noundef %vs2, ptr noundef %env, i32 noundef %vl, i32 noundef %vm, i32 noundef %vxrm, ptr noundef %fn, i32 noundef %vma, i32 noundef %esz) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %vs1.addr = alloca ptr, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %vl.addr = alloca i32, align 4
  %vm.addr = alloca i32, align 4
  %vxrm.addr = alloca i32, align 4
  %fn.addr = alloca ptr, align 8
  %vma.addr = alloca i32, align 4
  %esz.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %vs1, ptr %vs1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vl, ptr %vl.addr, align 4
  store i32 %vm, ptr %vm.addr, align 4
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store ptr %fn, ptr %fn.addr, align 8
  store i32 %vma, ptr %vma.addr, align 4
  store i32 %esz, ptr %esz.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 6
  %1 = load i64, ptr %vstart, align 8
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load i32, ptr %vl.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, ptr %vm.addr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %5 = load ptr, ptr %v0.addr, align 8
  %6 = load i32, ptr %i, align 4
  %call = call i32 @vext_elem_mask(ptr noundef %5, i32 noundef %6)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %vma.addr, align 4
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %esz.addr, align 4
  %mul = mul i32 %9, %10
  %11 = load i32, ptr %i, align 4
  %add = add i32 %11, 1
  %12 = load i32, ptr %esz.addr, align 4
  %mul3 = mul i32 %add, %12
  call void @vext_set_elems_1s(ptr noundef %7, i32 noundef %8, i32 noundef %mul, i32 noundef %mul3)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %13 = load ptr, ptr %fn.addr, align 8
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load ptr, ptr %vs1.addr, align 8
  %16 = load ptr, ptr %vs2.addr, align 8
  %17 = load i32, ptr %i, align 4
  %18 = load ptr, ptr %env.addr, align 8
  %19 = load i32, ptr %vxrm.addr, align 4
  call void %13(ptr noundef %14, ptr noundef %15, ptr noundef %16, i32 noundef %17, ptr noundef %18, i32 noundef %19)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !625

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart4 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i8 @saddu8(ptr noundef %env, i32 noundef %vxrm, i8 noundef zeroext %a, i8 noundef zeroext %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %res = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i8 %a, ptr %a.addr, align 1
  store i8 %b, ptr %b.addr, align 1
  %0 = load i8, ptr %a.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, ptr %b.addr, align 1
  %conv1 = zext i8 %1 to i32
  %add = add i32 %conv, %conv1
  %conv2 = trunc i32 %add to i8
  store i8 %conv2, ptr %res, align 1
  %2 = load i8, ptr %res, align 1
  %conv3 = zext i8 %2 to i32
  %3 = load i8, ptr %a.addr, align 1
  %conv4 = zext i8 %3 to i32
  %cmp = icmp slt i32 %conv3, %conv4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 -1, ptr %res, align 1
  %4 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i8, ptr %res, align 1
  ret i8 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @saddu16(ptr noundef %env, i32 noundef %vxrm, i16 noundef zeroext %a, i16 noundef zeroext %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %res = alloca i16, align 2
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  %0 = load i16, ptr %a.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, ptr %b.addr, align 2
  %conv1 = zext i16 %1 to i32
  %add = add i32 %conv, %conv1
  %conv2 = trunc i32 %add to i16
  store i16 %conv2, ptr %res, align 2
  %2 = load i16, ptr %res, align 2
  %conv3 = zext i16 %2 to i32
  %3 = load i16, ptr %a.addr, align 2
  %conv4 = zext i16 %3 to i32
  %cmp = icmp slt i32 %conv3, %conv4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 -1, ptr %res, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i16, ptr %res, align 2
  ret i16 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @saddu32(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i32 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %add = add i32 %0, %1
  store i32 %add, ptr %res, align 4
  %2 = load i32, ptr %res, align 4
  %3 = load i32, ptr %a.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %res, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, ptr %res, align 4
  ret i32 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @saddu64(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %add = add i64 %0, %1
  store i64 %add, ptr %res, align 8
  %2 = load i64, ptr %res, align 8
  %3 = load i64, ptr %a.addr, align 8
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -1, ptr %res, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i64, ptr %res, align 8
  ret i64 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @vext_vx_rm_1(ptr noundef %vd, ptr noundef %v0, i64 noundef %s1, ptr noundef %vs2, ptr noundef %env, i32 noundef %vl, i32 noundef %vm, i32 noundef %vxrm, ptr noundef %fn, i32 noundef %vma, i32 noundef %esz) #0 {
entry:
  %vd.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %s1.addr = alloca i64, align 8
  %vs2.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %vl.addr = alloca i32, align 4
  %vm.addr = alloca i32, align 4
  %vxrm.addr = alloca i32, align 4
  %fn.addr = alloca ptr, align 8
  %vma.addr = alloca i32, align 4
  %esz.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %vd, ptr %vd.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store i64 %s1, ptr %s1.addr, align 8
  store ptr %vs2, ptr %vs2.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vl, ptr %vl.addr, align 4
  store i32 %vm, ptr %vm.addr, align 4
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store ptr %fn, ptr %fn.addr, align 8
  store i32 %vma, ptr %vma.addr, align 4
  store i32 %esz, ptr %esz.addr, align 4
  %0 = load ptr, ptr %env.addr, align 8
  %vstart = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 6
  %1 = load i64, ptr %vstart, align 8
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load i32, ptr %vl.addr, align 4
  %cmp = icmp ult i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, ptr %vm.addr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %5 = load ptr, ptr %v0.addr, align 8
  %6 = load i32, ptr %i, align 4
  %call = call i32 @vext_elem_mask(ptr noundef %5, i32 noundef %6)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %7 = load ptr, ptr %vd.addr, align 8
  %8 = load i32, ptr %vma.addr, align 4
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %esz.addr, align 4
  %mul = mul i32 %9, %10
  %11 = load i32, ptr %i, align 4
  %add = add i32 %11, 1
  %12 = load i32, ptr %esz.addr, align 4
  %mul3 = mul i32 %add, %12
  call void @vext_set_elems_1s(ptr noundef %7, i32 noundef %8, i32 noundef %mul, i32 noundef %mul3)
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %13 = load ptr, ptr %fn.addr, align 8
  %14 = load ptr, ptr %vd.addr, align 8
  %15 = load i64, ptr %s1.addr, align 8
  %16 = load ptr, ptr %vs2.addr, align 8
  %17 = load i32, ptr %i, align 4
  %18 = load ptr, ptr %env.addr, align 8
  %19 = load i32, ptr %vxrm.addr, align 4
  call void %13(ptr noundef %14, i64 noundef %15, ptr noundef %16, i32 noundef %17, ptr noundef %18, i32 noundef %19)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !626

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %env.addr, align 8
  %vstart4 = getelementptr inbounds %struct.CPUArchState, ptr %21, i32 0, i32 6
  store i64 0, ptr %vstart4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i8 @sadd8(ptr noundef %env, i32 noundef %vxrm, i8 noundef signext %a, i8 noundef signext %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %res = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i8 %a, ptr %a.addr, align 1
  store i8 %b, ptr %b.addr, align 1
  %0 = load i8, ptr %a.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, ptr %b.addr, align 1
  %conv1 = sext i8 %1 to i32
  %add = add i32 %conv, %conv1
  %conv2 = trunc i32 %add to i8
  store i8 %conv2, ptr %res, align 1
  %2 = load i8, ptr %res, align 1
  %conv3 = sext i8 %2 to i32
  %3 = load i8, ptr %a.addr, align 1
  %conv4 = sext i8 %3 to i32
  %xor = xor i32 %conv3, %conv4
  %4 = load i8, ptr %res, align 1
  %conv5 = sext i8 %4 to i32
  %5 = load i8, ptr %b.addr, align 1
  %conv6 = sext i8 %5 to i32
  %xor7 = xor i32 %conv5, %conv6
  %and = and i32 %xor, %xor7
  %and8 = and i32 %and, -128
  %tobool = icmp ne i32 %and8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i8, ptr %a.addr, align 1
  %conv9 = sext i8 %6 to i32
  %cmp = icmp sgt i32 %conv9, 0
  %cond = select i1 %cmp, i32 127, i32 -128
  %conv11 = trunc i32 %cond to i8
  store i8 %conv11, ptr %res, align 1
  %7 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i8, ptr %res, align 1
  ret i8 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i16 @sadd16(ptr noundef %env, i32 noundef %vxrm, i16 noundef signext %a, i16 noundef signext %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %res = alloca i16, align 2
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  %0 = load i16, ptr %a.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, ptr %b.addr, align 2
  %conv1 = sext i16 %1 to i32
  %add = add i32 %conv, %conv1
  %conv2 = trunc i32 %add to i16
  store i16 %conv2, ptr %res, align 2
  %2 = load i16, ptr %res, align 2
  %conv3 = sext i16 %2 to i32
  %3 = load i16, ptr %a.addr, align 2
  %conv4 = sext i16 %3 to i32
  %xor = xor i32 %conv3, %conv4
  %4 = load i16, ptr %res, align 2
  %conv5 = sext i16 %4 to i32
  %5 = load i16, ptr %b.addr, align 2
  %conv6 = sext i16 %5 to i32
  %xor7 = xor i32 %conv5, %conv6
  %and = and i32 %xor, %xor7
  %and8 = and i32 %and, -32768
  %tobool = icmp ne i32 %and8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i16, ptr %a.addr, align 2
  %conv9 = sext i16 %6 to i32
  %cmp = icmp sgt i32 %conv9, 0
  %cond = select i1 %cmp, i32 32767, i32 -32768
  %conv11 = trunc i32 %cond to i16
  store i16 %conv11, ptr %res, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i16, ptr %res, align 2
  ret i16 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sadd32(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i32 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %add = add i32 %0, %1
  store i32 %add, ptr %res, align 4
  %2 = load i32, ptr %res, align 4
  %3 = load i32, ptr %a.addr, align 4
  %xor = xor i32 %2, %3
  %4 = load i32, ptr %res, align 4
  %5 = load i32, ptr %b.addr, align 4
  %xor1 = xor i32 %4, %5
  %and = and i32 %xor, %xor1
  %and2 = and i32 %and, -2147483648
  %tobool = icmp ne i32 %and2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, ptr %a.addr, align 4
  %cmp = icmp sgt i32 %6, 0
  %cond = select i1 %cmp, i32 2147483647, i32 -2147483648
  store i32 %cond, ptr %res, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i32, ptr %res, align 4
  ret i32 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @sadd64(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %add = add i64 %0, %1
  store i64 %add, ptr %res, align 8
  %2 = load i64, ptr %res, align 8
  %3 = load i64, ptr %a.addr, align 8
  %xor = xor i64 %2, %3
  %4 = load i64, ptr %res, align 8
  %5 = load i64, ptr %b.addr, align 8
  %xor1 = xor i64 %4, %5
  %and = and i64 %xor, %xor1
  %and2 = and i64 %and, -9223372036854775808
  %tobool = icmp ne i64 %and2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i64, ptr %a.addr, align 8
  %cmp = icmp sgt i64 %6, 0
  %cond = select i1 %cmp, i64 9223372036854775807, i64 -9223372036854775808
  store i64 %cond, ptr %res, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i64, ptr %res, align 8
  ret i64 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i8 @ssubu8(ptr noundef %env, i32 noundef %vxrm, i8 noundef zeroext %a, i8 noundef zeroext %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %res = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i8 %a, ptr %a.addr, align 1
  store i8 %b, ptr %b.addr, align 1
  %0 = load i8, ptr %a.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, ptr %b.addr, align 1
  %conv1 = zext i8 %1 to i32
  %sub = sub i32 %conv, %conv1
  %conv2 = trunc i32 %sub to i8
  store i8 %conv2, ptr %res, align 1
  %2 = load i8, ptr %res, align 1
  %conv3 = zext i8 %2 to i32
  %3 = load i8, ptr %a.addr, align 1
  %conv4 = zext i8 %3 to i32
  %cmp = icmp sgt i32 %conv3, %conv4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 0, ptr %res, align 1
  %4 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i8, ptr %res, align 1
  ret i8 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @ssubu16(ptr noundef %env, i32 noundef %vxrm, i16 noundef zeroext %a, i16 noundef zeroext %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %res = alloca i16, align 2
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  %0 = load i16, ptr %a.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, ptr %b.addr, align 2
  %conv1 = zext i16 %1 to i32
  %sub = sub i32 %conv, %conv1
  %conv2 = trunc i32 %sub to i16
  store i16 %conv2, ptr %res, align 2
  %2 = load i16, ptr %res, align 2
  %conv3 = zext i16 %2 to i32
  %3 = load i16, ptr %a.addr, align 2
  %conv4 = zext i16 %3 to i32
  %cmp = icmp sgt i32 %conv3, %conv4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 0, ptr %res, align 2
  %4 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i16, ptr %res, align 2
  ret i16 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ssubu32(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i32 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %sub = sub i32 %0, %1
  store i32 %sub, ptr %res, align 4
  %2 = load i32, ptr %res, align 4
  %3 = load i32, ptr %a.addr, align 4
  %cmp = icmp ugt i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %res, align 4
  %4 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, ptr %res, align 4
  ret i32 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @ssubu64(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %sub = sub i64 %0, %1
  store i64 %sub, ptr %res, align 8
  %2 = load i64, ptr %res, align 8
  %3 = load i64, ptr %a.addr, align 8
  %cmp = icmp ugt i64 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %res, align 8
  %4 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %4, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i64, ptr %res, align 8
  ret i64 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i8 @ssub8(ptr noundef %env, i32 noundef %vxrm, i8 noundef signext %a, i8 noundef signext %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %res = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i8 %a, ptr %a.addr, align 1
  store i8 %b, ptr %b.addr, align 1
  %0 = load i8, ptr %a.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, ptr %b.addr, align 1
  %conv1 = sext i8 %1 to i32
  %sub = sub i32 %conv, %conv1
  %conv2 = trunc i32 %sub to i8
  store i8 %conv2, ptr %res, align 1
  %2 = load i8, ptr %res, align 1
  %conv3 = sext i8 %2 to i32
  %3 = load i8, ptr %a.addr, align 1
  %conv4 = sext i8 %3 to i32
  %xor = xor i32 %conv3, %conv4
  %4 = load i8, ptr %a.addr, align 1
  %conv5 = sext i8 %4 to i32
  %5 = load i8, ptr %b.addr, align 1
  %conv6 = sext i8 %5 to i32
  %xor7 = xor i32 %conv5, %conv6
  %and = and i32 %xor, %xor7
  %and8 = and i32 %and, -128
  %tobool = icmp ne i32 %and8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i8, ptr %a.addr, align 1
  %conv9 = sext i8 %6 to i32
  %cmp = icmp sge i32 %conv9, 0
  %cond = select i1 %cmp, i32 127, i32 -128
  %conv11 = trunc i32 %cond to i8
  store i8 %conv11, ptr %res, align 1
  %7 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i8, ptr %res, align 1
  ret i8 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i16 @ssub16(ptr noundef %env, i32 noundef %vxrm, i16 noundef signext %a, i16 noundef signext %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %res = alloca i16, align 2
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  %0 = load i16, ptr %a.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, ptr %b.addr, align 2
  %conv1 = sext i16 %1 to i32
  %sub = sub i32 %conv, %conv1
  %conv2 = trunc i32 %sub to i16
  store i16 %conv2, ptr %res, align 2
  %2 = load i16, ptr %res, align 2
  %conv3 = sext i16 %2 to i32
  %3 = load i16, ptr %a.addr, align 2
  %conv4 = sext i16 %3 to i32
  %xor = xor i32 %conv3, %conv4
  %4 = load i16, ptr %a.addr, align 2
  %conv5 = sext i16 %4 to i32
  %5 = load i16, ptr %b.addr, align 2
  %conv6 = sext i16 %5 to i32
  %xor7 = xor i32 %conv5, %conv6
  %and = and i32 %xor, %xor7
  %and8 = and i32 %and, -32768
  %tobool = icmp ne i32 %and8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i16, ptr %a.addr, align 2
  %conv9 = sext i16 %6 to i32
  %cmp = icmp sge i32 %conv9, 0
  %cond = select i1 %cmp, i32 32767, i32 -32768
  %conv11 = trunc i32 %cond to i16
  store i16 %conv11, ptr %res, align 2
  %7 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i16, ptr %res, align 2
  ret i16 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ssub32(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i32 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %sub = sub i32 %0, %1
  store i32 %sub, ptr %res, align 4
  %2 = load i32, ptr %res, align 4
  %3 = load i32, ptr %a.addr, align 4
  %xor = xor i32 %2, %3
  %4 = load i32, ptr %a.addr, align 4
  %5 = load i32, ptr %b.addr, align 4
  %xor1 = xor i32 %4, %5
  %and = and i32 %xor, %xor1
  %and2 = and i32 %and, -2147483648
  %tobool = icmp ne i32 %and2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, ptr %a.addr, align 4
  %cmp = icmp sge i32 %6, 0
  %cond = select i1 %cmp, i32 2147483647, i32 -2147483648
  store i32 %cond, ptr %res, align 4
  %7 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i32, ptr %res, align 4
  ret i32 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @ssub64(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %sub = sub i64 %0, %1
  store i64 %sub, ptr %res, align 8
  %2 = load i64, ptr %res, align 8
  %3 = load i64, ptr %a.addr, align 8
  %xor = xor i64 %2, %3
  %4 = load i64, ptr %a.addr, align 8
  %5 = load i64, ptr %b.addr, align 8
  %xor1 = xor i64 %4, %5
  %and = and i64 %xor, %xor1
  %and2 = and i64 %and, -9223372036854775808
  %tobool = icmp ne i64 %and2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i64, ptr %a.addr, align 8
  %cmp = icmp sge i64 %6, 0
  %cond = select i1 %cmp, i64 9223372036854775807, i64 -9223372036854775808
  store i64 %cond, ptr %res, align 8
  %7 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i64, ptr %res, align 8
  ret i64 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @aadd32(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i32 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i64, align 8
  %round = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load i32, ptr %b.addr, align 4
  %conv1 = sext i32 %1 to i64
  %add = add i64 %conv, %conv1
  store i64 %add, ptr %res, align 8
  %2 = load i32, ptr %vxrm.addr, align 4
  %3 = load i64, ptr %res, align 8
  %call = call zeroext i8 @get_round(i32 noundef %2, i64 noundef %3, i8 noundef zeroext 1)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %res, align 8
  %shr = ashr i64 %4, 1
  %5 = load i8, ptr %round, align 1
  %conv2 = zext i8 %5 to i64
  %add3 = add i64 %shr, %conv2
  %conv4 = trunc i64 %add3 to i32
  ret i32 %conv4
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i8 @get_round(i32 noundef %vxrm, i64 noundef %v, i8 noundef zeroext %shift) #0 {
entry:
  %retval = alloca i8, align 1
  %vxrm.addr = alloca i32, align 4
  %v.addr = alloca i64, align 8
  %shift.addr = alloca i8, align 1
  %d = alloca i8, align 1
  %d1 = alloca i8, align 1
  %D1 = alloca i64, align 8
  %D2 = alloca i64, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %v, ptr %v.addr, align 8
  store i8 %shift, ptr %shift.addr, align 1
  %0 = load i64, ptr %v.addr, align 8
  %1 = load i8, ptr %shift.addr, align 1
  %conv = zext i8 %1 to i32
  %call = call i64 @extract64(i64 noundef %0, i32 noundef %conv, i32 noundef 1)
  %conv1 = trunc i64 %call to i8
  store i8 %conv1, ptr %d, align 1
  %2 = load i8, ptr %shift.addr, align 1
  %conv2 = zext i8 %2 to i32
  %cmp = icmp eq i32 %conv2, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i8, ptr %shift.addr, align 1
  %conv4 = zext i8 %3 to i32
  %cmp5 = icmp sgt i32 %conv4, 64
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i8 0, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load i64, ptr %v.addr, align 8
  %5 = load i8, ptr %shift.addr, align 1
  %conv7 = zext i8 %5 to i32
  %sub = sub i32 %conv7, 1
  %call8 = call i64 @extract64(i64 noundef %4, i32 noundef %sub, i32 noundef 1)
  %conv9 = trunc i64 %call8 to i8
  store i8 %conv9, ptr %d1, align 1
  %6 = load i64, ptr %v.addr, align 8
  %7 = load i8, ptr %shift.addr, align 1
  %conv10 = zext i8 %7 to i32
  %call11 = call i64 @extract64(i64 noundef %6, i32 noundef 0, i32 noundef %conv10)
  store i64 %call11, ptr %D1, align 8
  %8 = load i32, ptr %vxrm.addr, align 4
  %cmp12 = icmp eq i32 %8, 0
  br i1 %cmp12, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  %9 = load i8, ptr %d1, align 1
  store i8 %9, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %if.end
  %10 = load i32, ptr %vxrm.addr, align 4
  %cmp15 = icmp eq i32 %10, 1
  br i1 %cmp15, label %if.then17, label %if.else35

if.then17:                                        ; preds = %if.else
  %11 = load i8, ptr %shift.addr, align 1
  %conv18 = zext i8 %11 to i32
  %cmp19 = icmp sgt i32 %conv18, 1
  br i1 %cmp19, label %if.then21, label %if.else30

if.then21:                                        ; preds = %if.then17
  %12 = load i64, ptr %v.addr, align 8
  %13 = load i8, ptr %shift.addr, align 1
  %conv22 = zext i8 %13 to i32
  %sub23 = sub i32 %conv22, 1
  %call24 = call i64 @extract64(i64 noundef %12, i32 noundef 0, i32 noundef %sub23)
  store i64 %call24, ptr %D2, align 8
  %14 = load i8, ptr %d1, align 1
  %conv25 = zext i8 %14 to i32
  %15 = load i64, ptr %D2, align 8
  %cmp26 = icmp ne i64 %15, 0
  %conv27 = zext i1 %cmp26 to i32
  %16 = load i8, ptr %d, align 1
  %conv28 = zext i8 %16 to i32
  %or = or i32 %conv27, %conv28
  %and = and i32 %conv25, %or
  %conv29 = trunc i32 %and to i8
  store i8 %conv29, ptr %retval, align 1
  br label %return

if.else30:                                        ; preds = %if.then17
  %17 = load i8, ptr %d1, align 1
  %conv31 = zext i8 %17 to i32
  %18 = load i8, ptr %d, align 1
  %conv32 = zext i8 %18 to i32
  %and33 = and i32 %conv31, %conv32
  %conv34 = trunc i32 %and33 to i8
  store i8 %conv34, ptr %retval, align 1
  br label %return

if.else35:                                        ; preds = %if.else
  %19 = load i32, ptr %vxrm.addr, align 4
  %cmp36 = icmp eq i32 %19, 3
  br i1 %cmp36, label %if.then38, label %if.end43

if.then38:                                        ; preds = %if.else35
  %20 = load i8, ptr %d, align 1
  %tobool = icmp ne i8 %20, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %21 = load i64, ptr %D1, align 8
  %cmp39 = icmp ne i64 %21, 0
  %conv40 = zext i1 %cmp39 to i32
  %and41 = and i32 %lnot.ext, %conv40
  %conv42 = trunc i32 %and41 to i8
  store i8 %conv42, ptr %retval, align 1
  br label %return

if.end43:                                         ; preds = %if.else35
  br label %if.end44

if.end44:                                         ; preds = %if.end43
  br label %if.end45

if.end45:                                         ; preds = %if.end44
  store i8 0, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end45, %if.then38, %if.else30, %if.then21, %if.then14, %if.then
  %22 = load i8, ptr %retval, align 1
  ret i8 %22
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @aadd64(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  %round = alloca i8, align 1
  %over = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %add = add i64 %0, %1
  store i64 %add, ptr %res, align 8
  %2 = load i32, ptr %vxrm.addr, align 4
  %3 = load i64, ptr %res, align 8
  %call = call zeroext i8 @get_round(i32 noundef %2, i64 noundef %3, i8 noundef zeroext 1)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %res, align 8
  %5 = load i64, ptr %a.addr, align 8
  %xor = xor i64 %4, %5
  %6 = load i64, ptr %res, align 8
  %7 = load i64, ptr %b.addr, align 8
  %xor1 = xor i64 %6, %7
  %and = and i64 %xor, %xor1
  %and2 = and i64 %and, -9223372036854775808
  store i64 %and2, ptr %over, align 8
  %8 = load i64, ptr %res, align 8
  %shr = ashr i64 %8, 1
  %9 = load i64, ptr %over, align 8
  %xor3 = xor i64 %shr, %9
  %10 = load i8, ptr %round, align 1
  %conv = zext i8 %10 to i64
  %add4 = add i64 %xor3, %conv
  ret i64 %add4
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @aaddu32(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i32 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i64, align 8
  %round = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = load i32, ptr %b.addr, align 4
  %conv1 = zext i32 %1 to i64
  %add = add i64 %conv, %conv1
  store i64 %add, ptr %res, align 8
  %2 = load i32, ptr %vxrm.addr, align 4
  %3 = load i64, ptr %res, align 8
  %call = call zeroext i8 @get_round(i32 noundef %2, i64 noundef %3, i8 noundef zeroext 1)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %res, align 8
  %shr = lshr i64 %4, 1
  %5 = load i8, ptr %round, align 1
  %conv2 = zext i8 %5 to i64
  %add3 = add i64 %shr, %conv2
  %conv4 = trunc i64 %add3 to i32
  ret i32 %conv4
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @aaddu64(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  %round = alloca i8, align 1
  %over = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %add = add i64 %0, %1
  store i64 %add, ptr %res, align 8
  %2 = load i32, ptr %vxrm.addr, align 4
  %3 = load i64, ptr %res, align 8
  %call = call zeroext i8 @get_round(i32 noundef %2, i64 noundef %3, i8 noundef zeroext 1)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %res, align 8
  %5 = load i64, ptr %a.addr, align 8
  %cmp = icmp ult i64 %4, %5
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %shl = shl i64 %conv1, 63
  store i64 %shl, ptr %over, align 8
  %6 = load i64, ptr %res, align 8
  %shr = lshr i64 %6, 1
  %7 = load i64, ptr %over, align 8
  %or = or i64 %shr, %7
  %8 = load i8, ptr %round, align 1
  %conv2 = zext i8 %8 to i64
  %add3 = add i64 %or, %conv2
  ret i64 %add3
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @asub32(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i32 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i64, align 8
  %round = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load i32, ptr %b.addr, align 4
  %conv1 = sext i32 %1 to i64
  %sub = sub i64 %conv, %conv1
  store i64 %sub, ptr %res, align 8
  %2 = load i32, ptr %vxrm.addr, align 4
  %3 = load i64, ptr %res, align 8
  %call = call zeroext i8 @get_round(i32 noundef %2, i64 noundef %3, i8 noundef zeroext 1)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %res, align 8
  %shr = ashr i64 %4, 1
  %5 = load i8, ptr %round, align 1
  %conv2 = zext i8 %5 to i64
  %add = add i64 %shr, %conv2
  %conv3 = trunc i64 %add to i32
  ret i32 %conv3
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @asub64(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  %round = alloca i8, align 1
  %over = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %sub = sub i64 %0, %1
  store i64 %sub, ptr %res, align 8
  %2 = load i32, ptr %vxrm.addr, align 4
  %3 = load i64, ptr %res, align 8
  %call = call zeroext i8 @get_round(i32 noundef %2, i64 noundef %3, i8 noundef zeroext 1)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %res, align 8
  %5 = load i64, ptr %a.addr, align 8
  %xor = xor i64 %4, %5
  %6 = load i64, ptr %a.addr, align 8
  %7 = load i64, ptr %b.addr, align 8
  %xor1 = xor i64 %6, %7
  %and = and i64 %xor, %xor1
  %and2 = and i64 %and, -9223372036854775808
  store i64 %and2, ptr %over, align 8
  %8 = load i64, ptr %res, align 8
  %shr = ashr i64 %8, 1
  %9 = load i64, ptr %over, align 8
  %xor3 = xor i64 %shr, %9
  %10 = load i8, ptr %round, align 1
  %conv = zext i8 %10 to i64
  %add = add i64 %xor3, %conv
  ret i64 %add
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @asubu32(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i32 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i64, align 8
  %round = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = load i32, ptr %b.addr, align 4
  %conv1 = zext i32 %1 to i64
  %sub = sub i64 %conv, %conv1
  store i64 %sub, ptr %res, align 8
  %2 = load i32, ptr %vxrm.addr, align 4
  %3 = load i64, ptr %res, align 8
  %call = call zeroext i8 @get_round(i32 noundef %2, i64 noundef %3, i8 noundef zeroext 1)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %res, align 8
  %shr = ashr i64 %4, 1
  %5 = load i8, ptr %round, align 1
  %conv2 = zext i8 %5 to i64
  %add = add i64 %shr, %conv2
  %conv3 = trunc i64 %add to i32
  ret i32 %conv3
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @asubu64(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  %round = alloca i8, align 1
  %over = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %sub = sub i64 %0, %1
  store i64 %sub, ptr %res, align 8
  %2 = load i32, ptr %vxrm.addr, align 4
  %3 = load i64, ptr %res, align 8
  %call = call zeroext i8 @get_round(i32 noundef %2, i64 noundef %3, i8 noundef zeroext 1)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %res, align 8
  %5 = load i64, ptr %a.addr, align 8
  %cmp = icmp ugt i64 %4, %5
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %shl = shl i64 %conv1, 63
  store i64 %shl, ptr %over, align 8
  %6 = load i64, ptr %res, align 8
  %shr = lshr i64 %6, 1
  %7 = load i64, ptr %over, align 8
  %or = or i64 %shr, %7
  %8 = load i8, ptr %round, align 1
  %conv2 = zext i8 %8 to i64
  %add = add i64 %or, %conv2
  ret i64 %add
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i8 @vsmul8(ptr noundef %env, i32 noundef %vxrm, i8 noundef signext %a, i8 noundef signext %b) #0 {
entry:
  %retval = alloca i8, align 1
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %round = alloca i8, align 1
  %res = alloca i16, align 2
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i8 %a, ptr %a.addr, align 1
  store i8 %b, ptr %b.addr, align 1
  %0 = load i8, ptr %a.addr, align 1
  %conv = sext i8 %0 to i16
  %conv1 = sext i16 %conv to i32
  %1 = load i8, ptr %b.addr, align 1
  %conv2 = sext i8 %1 to i16
  %conv3 = sext i16 %conv2 to i32
  %mul = mul i32 %conv1, %conv3
  %conv4 = trunc i32 %mul to i16
  store i16 %conv4, ptr %res, align 2
  %2 = load i32, ptr %vxrm.addr, align 4
  %3 = load i16, ptr %res, align 2
  %conv5 = sext i16 %3 to i64
  %call = call zeroext i8 @get_round(i32 noundef %2, i64 noundef %conv5, i8 noundef zeroext 7)
  store i8 %call, ptr %round, align 1
  %4 = load i16, ptr %res, align 2
  %conv6 = sext i16 %4 to i32
  %shr = ashr i32 %conv6, 7
  %5 = load i8, ptr %round, align 1
  %conv7 = zext i8 %5 to i32
  %add = add i32 %shr, %conv7
  %conv8 = trunc i32 %add to i16
  store i16 %conv8, ptr %res, align 2
  %6 = load i16, ptr %res, align 2
  %conv9 = sext i16 %6 to i32
  %cmp = icmp sgt i32 %conv9, 127
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  store i8 127, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %entry
  %8 = load i16, ptr %res, align 2
  %conv11 = sext i16 %8 to i32
  %cmp12 = icmp slt i32 %conv11, -128
  br i1 %cmp12, label %if.then14, label %if.else16

if.then14:                                        ; preds = %if.else
  %9 = load ptr, ptr %env.addr, align 8
  %vxsat15 = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 4
  store i64 1, ptr %vxsat15, align 8
  store i8 -128, ptr %retval, align 1
  br label %return

if.else16:                                        ; preds = %if.else
  %10 = load i16, ptr %res, align 2
  %conv17 = trunc i16 %10 to i8
  store i8 %conv17, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.else16, %if.then14, %if.then
  %11 = load i8, ptr %retval, align 1
  ret i8 %11
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i16 @vsmul16(ptr noundef %env, i32 noundef %vxrm, i16 noundef signext %a, i16 noundef signext %b) #0 {
entry:
  %retval = alloca i16, align 2
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %round = alloca i8, align 1
  %res = alloca i32, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  %0 = load i16, ptr %a.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, ptr %b.addr, align 2
  %conv1 = sext i16 %1 to i32
  %mul = mul i32 %conv, %conv1
  store i32 %mul, ptr %res, align 4
  %2 = load i32, ptr %vxrm.addr, align 4
  %3 = load i32, ptr %res, align 4
  %conv2 = sext i32 %3 to i64
  %call = call zeroext i8 @get_round(i32 noundef %2, i64 noundef %conv2, i8 noundef zeroext 15)
  store i8 %call, ptr %round, align 1
  %4 = load i32, ptr %res, align 4
  %shr = ashr i32 %4, 15
  %5 = load i8, ptr %round, align 1
  %conv3 = zext i8 %5 to i32
  %add = add i32 %shr, %conv3
  store i32 %add, ptr %res, align 4
  %6 = load i32, ptr %res, align 4
  %cmp = icmp sgt i32 %6, 32767
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  store i16 32767, ptr %retval, align 2
  br label %return

if.else:                                          ; preds = %entry
  %8 = load i32, ptr %res, align 4
  %cmp5 = icmp slt i32 %8, -32768
  br i1 %cmp5, label %if.then7, label %if.else9

if.then7:                                         ; preds = %if.else
  %9 = load ptr, ptr %env.addr, align 8
  %vxsat8 = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 4
  store i64 1, ptr %vxsat8, align 8
  store i16 -32768, ptr %retval, align 2
  br label %return

if.else9:                                         ; preds = %if.else
  %10 = load i32, ptr %res, align 4
  %conv10 = trunc i32 %10 to i16
  store i16 %conv10, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.else9, %if.then7, %if.then
  %11 = load i16, ptr %retval, align 2
  ret i16 %11
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vsmul32(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i32 noundef %b) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %round = alloca i8, align 1
  %res = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load i32, ptr %b.addr, align 4
  %conv1 = sext i32 %1 to i64
  %mul = mul i64 %conv, %conv1
  store i64 %mul, ptr %res, align 8
  %2 = load i32, ptr %vxrm.addr, align 4
  %3 = load i64, ptr %res, align 8
  %call = call zeroext i8 @get_round(i32 noundef %2, i64 noundef %3, i8 noundef zeroext 31)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %res, align 8
  %shr = ashr i64 %4, 31
  %5 = load i8, ptr %round, align 1
  %conv2 = zext i8 %5 to i64
  %add = add i64 %shr, %conv2
  store i64 %add, ptr %res, align 8
  %6 = load i64, ptr %res, align 8
  %cmp = icmp sgt i64 %6, 2147483647
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %7, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  store i32 2147483647, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %8 = load i64, ptr %res, align 8
  %cmp4 = icmp slt i64 %8, -2147483648
  br i1 %cmp4, label %if.then6, label %if.else8

if.then6:                                         ; preds = %if.else
  %9 = load ptr, ptr %env.addr, align 8
  %vxsat7 = getelementptr inbounds %struct.CPUArchState, ptr %9, i32 0, i32 4
  store i64 1, ptr %vxsat7, align 8
  store i32 -2147483648, ptr %retval, align 4
  br label %return

if.else8:                                         ; preds = %if.else
  %10 = load i64, ptr %res, align 8
  %conv9 = trunc i64 %10 to i32
  store i32 %conv9, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else8, %if.then6, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @vsmul64(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %retval = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %round = alloca i8, align 1
  %hi_64 = alloca i64, align 8
  %lo_64 = alloca i64, align 8
  %res = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %cmp = icmp eq i64 %0, -9223372036854775808
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %b.addr, align 8
  %cmp1 = icmp eq i64 %1, -9223372036854775808
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  store i64 9223372036854775807, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load i64, ptr %a.addr, align 8
  %4 = load i64, ptr %b.addr, align 8
  call void @muls64(ptr noundef %lo_64, ptr noundef %hi_64, i64 noundef %3, i64 noundef %4)
  %5 = load i32, ptr %vxrm.addr, align 4
  %6 = load i64, ptr %lo_64, align 8
  %call = call zeroext i8 @get_round(i32 noundef %5, i64 noundef %6, i8 noundef zeroext 63)
  store i8 %call, ptr %round, align 1
  %7 = load i64, ptr %hi_64, align 8
  %shl = shl i64 %7, 1
  %8 = load i64, ptr %lo_64, align 8
  %shr = lshr i64 %8, 63
  %or = or i64 %shl, %shr
  store i64 %or, ptr %res, align 8
  %9 = load i8, ptr %round, align 1
  %tobool = icmp ne i8 %9, 0
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %10 = load i64, ptr %res, align 8
  %cmp3 = icmp eq i64 %10, 9223372036854775807
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then2
  %11 = load ptr, ptr %env.addr, align 8
  %vxsat5 = getelementptr inbounds %struct.CPUArchState, ptr %11, i32 0, i32 4
  store i64 1, ptr %vxsat5, align 8
  br label %if.end6

if.else:                                          ; preds = %if.then2
  %12 = load i64, ptr %res, align 8
  %add = add i64 %12, 1
  store i64 %add, ptr %res, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then4
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %if.end
  %13 = load i64, ptr %res, align 8
  store i64 %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end7, %if.then
  %14 = load i64, ptr %retval, align 8
  ret i64 %14
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i8 @vssrl8(ptr noundef %env, i32 noundef %vxrm, i8 noundef zeroext %a, i8 noundef zeroext %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  %res = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i8 %a, ptr %a.addr, align 1
  store i8 %b, ptr %b.addr, align 1
  %0 = load i8, ptr %b.addr, align 1
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 7
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i8, ptr %a.addr, align 1
  %conv2 = zext i8 %2 to i64
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %conv2, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i8, ptr %a.addr, align 1
  %conv3 = zext i8 %4 to i32
  %5 = load i8, ptr %shift, align 1
  %conv4 = zext i8 %5 to i32
  %shr = ashr i32 %conv3, %conv4
  %6 = load i8, ptr %round, align 1
  %conv5 = zext i8 %6 to i32
  %add = add i32 %shr, %conv5
  %conv6 = trunc i32 %add to i8
  store i8 %conv6, ptr %res, align 1
  %7 = load i8, ptr %res, align 1
  ret i8 %7
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @vssrl16(ptr noundef %env, i32 noundef %vxrm, i16 noundef zeroext %a, i16 noundef zeroext %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  %0 = load i16, ptr %b.addr, align 2
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 15
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i16, ptr %a.addr, align 2
  %conv2 = zext i16 %2 to i64
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %conv2, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i16, ptr %a.addr, align 2
  %conv3 = zext i16 %4 to i32
  %5 = load i8, ptr %shift, align 1
  %conv4 = zext i8 %5 to i32
  %shr = ashr i32 %conv3, %conv4
  %6 = load i8, ptr %round, align 1
  %conv5 = zext i8 %6 to i32
  %add = add i32 %shr, %conv5
  %conv6 = trunc i32 %add to i16
  ret i16 %conv6
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vssrl32(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i32 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %b.addr, align 4
  %and = and i32 %0, 31
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i32, ptr %a.addr, align 4
  %conv1 = zext i32 %2 to i64
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %conv1, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i32, ptr %a.addr, align 4
  %5 = load i8, ptr %shift, align 1
  %conv2 = zext i8 %5 to i32
  %shr = lshr i32 %4, %conv2
  %6 = load i8, ptr %round, align 1
  %conv3 = zext i8 %6 to i32
  %add = add i32 %shr, %conv3
  ret i32 %add
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @vssrl64(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %b.addr, align 8
  %and = and i64 %0, 63
  %conv = trunc i64 %and to i8
  store i8 %conv, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i64, ptr %a.addr, align 8
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %2, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %a.addr, align 8
  %5 = load i8, ptr %shift, align 1
  %conv1 = zext i8 %5 to i32
  %sh_prom = zext i32 %conv1 to i64
  %shr = lshr i64 %4, %sh_prom
  %6 = load i8, ptr %round, align 1
  %conv2 = zext i8 %6 to i64
  %add = add i64 %shr, %conv2
  ret i64 %add
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i8 @vssra8(ptr noundef %env, i32 noundef %vxrm, i8 noundef signext %a, i8 noundef signext %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i8 %a, ptr %a.addr, align 1
  store i8 %b, ptr %b.addr, align 1
  %0 = load i8, ptr %b.addr, align 1
  %conv = sext i8 %0 to i32
  %and = and i32 %conv, 7
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i8, ptr %a.addr, align 1
  %conv2 = sext i8 %2 to i64
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %conv2, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i8, ptr %a.addr, align 1
  %conv3 = sext i8 %4 to i32
  %5 = load i8, ptr %shift, align 1
  %conv4 = zext i8 %5 to i32
  %shr = ashr i32 %conv3, %conv4
  %6 = load i8, ptr %round, align 1
  %conv5 = zext i8 %6 to i32
  %add = add i32 %shr, %conv5
  %conv6 = trunc i32 %add to i8
  ret i8 %conv6
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i16 @vssra16(ptr noundef %env, i32 noundef %vxrm, i16 noundef signext %a, i16 noundef signext %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  %0 = load i16, ptr %b.addr, align 2
  %conv = sext i16 %0 to i32
  %and = and i32 %conv, 15
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i16, ptr %a.addr, align 2
  %conv2 = sext i16 %2 to i64
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %conv2, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i16, ptr %a.addr, align 2
  %conv3 = sext i16 %4 to i32
  %5 = load i8, ptr %shift, align 1
  %conv4 = zext i8 %5 to i32
  %shr = ashr i32 %conv3, %conv4
  %6 = load i8, ptr %round, align 1
  %conv5 = zext i8 %6 to i32
  %add = add i32 %shr, %conv5
  %conv6 = trunc i32 %add to i16
  ret i16 %conv6
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vssra32(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i32 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %b.addr, align 4
  %and = and i32 %0, 31
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i32, ptr %a.addr, align 4
  %conv1 = sext i32 %2 to i64
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %conv1, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i32, ptr %a.addr, align 4
  %5 = load i8, ptr %shift, align 1
  %conv2 = zext i8 %5 to i32
  %shr = ashr i32 %4, %conv2
  %6 = load i8, ptr %round, align 1
  %conv3 = zext i8 %6 to i32
  %add = add i32 %shr, %conv3
  ret i32 %add
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @vssra64(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i64 noundef %b) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %b.addr, align 8
  %and = and i64 %0, 63
  %conv = trunc i64 %and to i8
  store i8 %conv, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i64, ptr %a.addr, align 8
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %2, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %a.addr, align 8
  %5 = load i8, ptr %shift, align 1
  %conv1 = zext i8 %5 to i32
  %sh_prom = zext i32 %conv1 to i64
  %shr = ashr i64 %4, %sh_prom
  %6 = load i8, ptr %round, align 1
  %conv2 = zext i8 %6 to i64
  %add = add i64 %shr, %conv2
  ret i64 %add
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i8 @vnclip8(ptr noundef %env, i32 noundef %vxrm, i16 noundef signext %a, i8 noundef signext %b) #0 {
entry:
  %retval = alloca i8, align 1
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i16, align 2
  %b.addr = alloca i8, align 1
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  %res = alloca i16, align 2
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i16 %a, ptr %a.addr, align 2
  store i8 %b, ptr %b.addr, align 1
  %0 = load i8, ptr %b.addr, align 1
  %conv = sext i8 %0 to i32
  %and = and i32 %conv, 15
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i16, ptr %a.addr, align 2
  %conv2 = sext i16 %2 to i64
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %conv2, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i16, ptr %a.addr, align 2
  %conv3 = sext i16 %4 to i32
  %5 = load i8, ptr %shift, align 1
  %conv4 = zext i8 %5 to i32
  %shr = ashr i32 %conv3, %conv4
  %6 = load i8, ptr %round, align 1
  %conv5 = zext i8 %6 to i32
  %add = add i32 %shr, %conv5
  %conv6 = trunc i32 %add to i16
  store i16 %conv6, ptr %res, align 2
  %7 = load i16, ptr %res, align 2
  %conv7 = sext i16 %7 to i32
  %cmp = icmp sgt i32 %conv7, 127
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  store i8 127, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %entry
  %9 = load i16, ptr %res, align 2
  %conv9 = sext i16 %9 to i32
  %cmp10 = icmp slt i32 %conv9, -128
  br i1 %cmp10, label %if.then12, label %if.else14

if.then12:                                        ; preds = %if.else
  %10 = load ptr, ptr %env.addr, align 8
  %vxsat13 = getelementptr inbounds %struct.CPUArchState, ptr %10, i32 0, i32 4
  store i64 1, ptr %vxsat13, align 8
  store i8 -128, ptr %retval, align 1
  br label %return

if.else14:                                        ; preds = %if.else
  %11 = load i16, ptr %res, align 2
  %conv15 = trunc i16 %11 to i8
  store i8 %conv15, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.else14, %if.then12, %if.then
  %12 = load i8, ptr %retval, align 1
  ret i8 %12
}

; Function Attrs: nounwind sspstrong uwtable
define internal signext i16 @vnclip16(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i16 noundef signext %b) #0 {
entry:
  %retval = alloca i16, align 2
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i16, align 2
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  %res = alloca i32, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i16 %b, ptr %b.addr, align 2
  %0 = load i16, ptr %b.addr, align 2
  %conv = sext i16 %0 to i32
  %and = and i32 %conv, 31
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i32, ptr %a.addr, align 4
  %conv2 = sext i32 %2 to i64
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %conv2, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i32, ptr %a.addr, align 4
  %5 = load i8, ptr %shift, align 1
  %conv3 = zext i8 %5 to i32
  %shr = ashr i32 %4, %conv3
  %6 = load i8, ptr %round, align 1
  %conv4 = zext i8 %6 to i32
  %add = add i32 %shr, %conv4
  store i32 %add, ptr %res, align 4
  %7 = load i32, ptr %res, align 4
  %cmp = icmp sgt i32 %7, 32767
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  store i16 32767, ptr %retval, align 2
  br label %return

if.else:                                          ; preds = %entry
  %9 = load i32, ptr %res, align 4
  %cmp6 = icmp slt i32 %9, -32768
  br i1 %cmp6, label %if.then8, label %if.else10

if.then8:                                         ; preds = %if.else
  %10 = load ptr, ptr %env.addr, align 8
  %vxsat9 = getelementptr inbounds %struct.CPUArchState, ptr %10, i32 0, i32 4
  store i64 1, ptr %vxsat9, align 8
  store i16 -32768, ptr %retval, align 2
  br label %return

if.else10:                                        ; preds = %if.else
  %11 = load i32, ptr %res, align 4
  %conv11 = trunc i32 %11 to i16
  store i16 %conv11, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.else10, %if.then8, %if.then
  %12 = load i16, ptr %retval, align 2
  ret i16 %12
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vnclip32(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i32 noundef %b) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i32, align 4
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  %res = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %b.addr, align 4
  %and = and i32 %0, 63
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i64, ptr %a.addr, align 8
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %2, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %a.addr, align 8
  %5 = load i8, ptr %shift, align 1
  %conv1 = zext i8 %5 to i32
  %sh_prom = zext i32 %conv1 to i64
  %shr = ashr i64 %4, %sh_prom
  %6 = load i8, ptr %round, align 1
  %conv2 = zext i8 %6 to i64
  %add = add i64 %shr, %conv2
  store i64 %add, ptr %res, align 8
  %7 = load i64, ptr %res, align 8
  %cmp = icmp sgt i64 %7, 2147483647
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  store i32 2147483647, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %9 = load i64, ptr %res, align 8
  %cmp4 = icmp slt i64 %9, -2147483648
  br i1 %cmp4, label %if.then6, label %if.else8

if.then6:                                         ; preds = %if.else
  %10 = load ptr, ptr %env.addr, align 8
  %vxsat7 = getelementptr inbounds %struct.CPUArchState, ptr %10, i32 0, i32 4
  store i64 1, ptr %vxsat7, align 8
  store i32 -2147483648, ptr %retval, align 4
  br label %return

if.else8:                                         ; preds = %if.else
  %11 = load i64, ptr %res, align 8
  %conv9 = trunc i64 %11 to i32
  store i32 %conv9, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else8, %if.then6, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i8 @vnclipu8(ptr noundef %env, i32 noundef %vxrm, i16 noundef zeroext %a, i8 noundef zeroext %b) #0 {
entry:
  %retval = alloca i8, align 1
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i16, align 2
  %b.addr = alloca i8, align 1
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  %res = alloca i16, align 2
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i16 %a, ptr %a.addr, align 2
  store i8 %b, ptr %b.addr, align 1
  %0 = load i8, ptr %b.addr, align 1
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i16, ptr %a.addr, align 2
  %conv2 = zext i16 %2 to i64
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %conv2, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i16, ptr %a.addr, align 2
  %conv3 = zext i16 %4 to i32
  %5 = load i8, ptr %shift, align 1
  %conv4 = zext i8 %5 to i32
  %shr = ashr i32 %conv3, %conv4
  %6 = load i8, ptr %round, align 1
  %conv5 = zext i8 %6 to i32
  %add = add i32 %shr, %conv5
  %conv6 = trunc i32 %add to i16
  store i16 %conv6, ptr %res, align 2
  %7 = load i16, ptr %res, align 2
  %conv7 = zext i16 %7 to i32
  %cmp = icmp sgt i32 %conv7, 255
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  store i8 -1, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %entry
  %9 = load i16, ptr %res, align 2
  %conv9 = trunc i16 %9 to i8
  store i8 %conv9, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.else, %if.then
  %10 = load i8, ptr %retval, align 1
  ret i8 %10
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @vnclipu16(ptr noundef %env, i32 noundef %vxrm, i32 noundef %a, i16 noundef zeroext %b) #0 {
entry:
  %retval = alloca i16, align 2
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i16, align 2
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  %res = alloca i32, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  store i16 %b, ptr %b.addr, align 2
  %0 = load i16, ptr %b.addr, align 2
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 31
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i32, ptr %a.addr, align 4
  %conv2 = zext i32 %2 to i64
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %conv2, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i32, ptr %a.addr, align 4
  %5 = load i8, ptr %shift, align 1
  %conv3 = zext i8 %5 to i32
  %shr = lshr i32 %4, %conv3
  %6 = load i8, ptr %round, align 1
  %conv4 = zext i8 %6 to i32
  %add = add i32 %shr, %conv4
  store i32 %add, ptr %res, align 4
  %7 = load i32, ptr %res, align 4
  %cmp = icmp ugt i32 %7, 65535
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  store i16 -1, ptr %retval, align 2
  br label %return

if.else:                                          ; preds = %entry
  %9 = load i32, ptr %res, align 4
  %conv6 = trunc i32 %9 to i16
  store i16 %conv6, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.else, %if.then
  %10 = load i16, ptr %retval, align 2
  ret i16 %10
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vnclipu32(ptr noundef %env, i32 noundef %vxrm, i64 noundef %a, i32 noundef %b) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %vxrm.addr = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i32, align 4
  %round = alloca i8, align 1
  %shift = alloca i8, align 1
  %res = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %vxrm, ptr %vxrm.addr, align 4
  store i64 %a, ptr %a.addr, align 8
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %b.addr, align 4
  %and = and i32 %0, 63
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %shift, align 1
  %1 = load i32, ptr %vxrm.addr, align 4
  %2 = load i64, ptr %a.addr, align 8
  %3 = load i8, ptr %shift, align 1
  %call = call zeroext i8 @get_round(i32 noundef %1, i64 noundef %2, i8 noundef zeroext %3)
  store i8 %call, ptr %round, align 1
  %4 = load i64, ptr %a.addr, align 8
  %5 = load i8, ptr %shift, align 1
  %conv1 = zext i8 %5 to i32
  %sh_prom = zext i32 %conv1 to i64
  %shr = lshr i64 %4, %sh_prom
  %6 = load i8, ptr %round, align 1
  %conv2 = zext i8 %6 to i64
  %add = add i64 %shr, %conv2
  store i64 %add, ptr %res, align 8
  %7 = load i64, ptr %res, align 8
  %cmp = icmp ugt i64 %7, 4294967295
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %env.addr, align 8
  %vxsat = getelementptr inbounds %struct.CPUArchState, ptr %8, i32 0, i32 4
  store i64 1, ptr %vxsat, align 8
  store i32 -1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %9 = load i64, ptr %res, align 8
  %conv4 = trunc i64 %9 to i32
  store i32 %conv4, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

declare zeroext i16 @float16_sub(i16 noundef zeroext, i16 noundef zeroext, ptr noundef) #2

declare i32 @float32_sub(i32 noundef, i32 noundef, ptr noundef) #2

declare i64 @float64_sub(i64 noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @float16_rsub(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %b.addr, align 2
  %1 = load i16, ptr %a.addr, align 2
  %2 = load ptr, ptr %s.addr, align 8
  %call = call zeroext i16 @float16_sub(i16 noundef zeroext %0, i16 noundef zeroext %1, ptr noundef %2)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @float32_rsub(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %b.addr, align 4
  %1 = load i32, ptr %a.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_sub(i32 noundef %0, i32 noundef %1, ptr noundef %2)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @float64_rsub(i64 noundef %a, i64 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %b.addr, align 8
  %1 = load i64, ptr %a.addr, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float64_sub(i64 noundef %0, i64 noundef %1, ptr noundef %2)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vfwadd16(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_to_float32(i16 noundef zeroext %0, i1 noundef zeroext true, ptr noundef %1)
  %2 = load i16, ptr %b.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i32 @float16_to_float32(i16 noundef zeroext %2, i1 noundef zeroext true, ptr noundef %3)
  %4 = load ptr, ptr %s.addr, align 8
  %call2 = call i32 @float32_add(i32 noundef %call, i32 noundef %call1, ptr noundef %4)
  ret i32 %call2
}

declare i32 @float16_to_float32(i16 noundef zeroext, i1 noundef zeroext, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @vfwadd32(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float32_to_float64(i32 noundef %0, ptr noundef %1)
  %2 = load i32, ptr %b.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i64 @float32_to_float64(i32 noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %s.addr, align 8
  %call2 = call i64 @float64_add(i64 noundef %call, i64 noundef %call1, ptr noundef %4)
  ret i64 %call2
}

declare i64 @float32_to_float64(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vfwsub16(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_to_float32(i16 noundef zeroext %0, i1 noundef zeroext true, ptr noundef %1)
  %2 = load i16, ptr %b.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i32 @float16_to_float32(i16 noundef zeroext %2, i1 noundef zeroext true, ptr noundef %3)
  %4 = load ptr, ptr %s.addr, align 8
  %call2 = call i32 @float32_sub(i32 noundef %call, i32 noundef %call1, ptr noundef %4)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @vfwsub32(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float32_to_float64(i32 noundef %0, ptr noundef %1)
  %2 = load i32, ptr %b.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i64 @float32_to_float64(i32 noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %s.addr, align 8
  %call2 = call i64 @float64_sub(i64 noundef %call, i64 noundef %call1, ptr noundef %4)
  ret i64 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vfwaddw16(i32 noundef %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i16, ptr %b.addr, align 2
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_to_float32(i16 noundef zeroext %1, i1 noundef zeroext true, ptr noundef %2)
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i32 @float32_add(i32 noundef %0, i32 noundef %call, ptr noundef %3)
  ret i32 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @vfwaddw32(i64 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i32, ptr %b.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float32_to_float64(i32 noundef %1, ptr noundef %2)
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i64 @float64_add(i64 noundef %0, i64 noundef %call, ptr noundef %3)
  ret i64 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vfwsubw16(i32 noundef %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i16, ptr %b.addr, align 2
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_to_float32(i16 noundef zeroext %1, i1 noundef zeroext true, ptr noundef %2)
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i32 @float32_sub(i32 noundef %0, i32 noundef %call, ptr noundef %3)
  ret i32 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @vfwsubw32(i64 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i32, ptr %b.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float32_to_float64(i32 noundef %1, ptr noundef %2)
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i64 @float64_sub(i64 noundef %0, i64 noundef %call, ptr noundef %3)
  ret i64 %call1
}

declare zeroext i16 @float16_mul(i16 noundef zeroext, i16 noundef zeroext, ptr noundef) #2

declare i32 @float32_mul(i32 noundef, i32 noundef, ptr noundef) #2

declare i64 @float64_mul(i64 noundef, i64 noundef, ptr noundef) #2

declare zeroext i16 @float16_div(i16 noundef zeroext, i16 noundef zeroext, ptr noundef) #2

declare i32 @float32_div(i32 noundef, i32 noundef, ptr noundef) #2

declare i64 @float64_div(i64 noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @float16_rdiv(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %b.addr, align 2
  %1 = load i16, ptr %a.addr, align 2
  %2 = load ptr, ptr %s.addr, align 8
  %call = call zeroext i16 @float16_div(i16 noundef zeroext %0, i16 noundef zeroext %1, ptr noundef %2)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @float32_rdiv(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %b.addr, align 4
  %1 = load i32, ptr %a.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_div(i32 noundef %0, i32 noundef %1, ptr noundef %2)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @float64_rdiv(i64 noundef %a, i64 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %b.addr, align 8
  %1 = load i64, ptr %a.addr, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float64_div(i64 noundef %0, i64 noundef %1, ptr noundef %2)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vfwmul16(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_to_float32(i16 noundef zeroext %0, i1 noundef zeroext true, ptr noundef %1)
  %2 = load i16, ptr %b.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i32 @float16_to_float32(i16 noundef zeroext %2, i1 noundef zeroext true, ptr noundef %3)
  %4 = load ptr, ptr %s.addr, align 8
  %call2 = call i32 @float32_mul(i32 noundef %call, i32 noundef %call1, ptr noundef %4)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @vfwmul32(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float32_to_float64(i32 noundef %0, ptr noundef %1)
  %2 = load i32, ptr %b.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i64 @float32_to_float64(i32 noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %s.addr, align 8
  %call2 = call i64 @float64_mul(i64 noundef %call, i64 noundef %call1, ptr noundef %4)
  ret i64 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @fmacc16(i16 noundef zeroext %a, i16 noundef zeroext %b, i16 noundef zeroext %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i16 %d, ptr %d.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load i16, ptr %d.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call = call zeroext i16 @float16_muladd(i16 noundef zeroext %0, i16 noundef zeroext %1, i16 noundef zeroext %2, i32 noundef 0, ptr noundef %3)
  ret i16 %call
}

declare zeroext i16 @float16_muladd(i16 noundef zeroext, i16 noundef zeroext, i16 noundef zeroext, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fmacc32(i32 noundef %a, i32 noundef %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load i32, ptr %d.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_muladd(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 0, ptr noundef %3)
  ret i32 %call
}

declare i32 @float32_muladd(i32 noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fmacc64(i64 noundef %a, i64 noundef %b, i64 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %d.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i64 %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load i64, ptr %d.addr, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float64_muladd(i64 noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 0, ptr noundef %3)
  ret i64 %call
}

declare i64 @float64_muladd(i64 noundef, i64 noundef, i64 noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @fnmacc16(i16 noundef zeroext %a, i16 noundef zeroext %b, i16 noundef zeroext %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i16 %d, ptr %d.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load i16, ptr %d.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call = call zeroext i16 @float16_muladd(i16 noundef zeroext %0, i16 noundef zeroext %1, i16 noundef zeroext %2, i32 noundef 3, ptr noundef %3)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fnmacc32(i32 noundef %a, i32 noundef %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load i32, ptr %d.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_muladd(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 3, ptr noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fnmacc64(i64 noundef %a, i64 noundef %b, i64 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %d.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i64 %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load i64, ptr %d.addr, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float64_muladd(i64 noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 3, ptr noundef %3)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @fmsac16(i16 noundef zeroext %a, i16 noundef zeroext %b, i16 noundef zeroext %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i16 %d, ptr %d.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load i16, ptr %d.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call = call zeroext i16 @float16_muladd(i16 noundef zeroext %0, i16 noundef zeroext %1, i16 noundef zeroext %2, i32 noundef 1, ptr noundef %3)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fmsac32(i32 noundef %a, i32 noundef %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load i32, ptr %d.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_muladd(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 1, ptr noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fmsac64(i64 noundef %a, i64 noundef %b, i64 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %d.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i64 %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load i64, ptr %d.addr, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float64_muladd(i64 noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 1, ptr noundef %3)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @fnmsac16(i16 noundef zeroext %a, i16 noundef zeroext %b, i16 noundef zeroext %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i16 %d, ptr %d.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load i16, ptr %d.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call = call zeroext i16 @float16_muladd(i16 noundef zeroext %0, i16 noundef zeroext %1, i16 noundef zeroext %2, i32 noundef 2, ptr noundef %3)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fnmsac32(i32 noundef %a, i32 noundef %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load i32, ptr %d.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_muladd(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 2, ptr noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fnmsac64(i64 noundef %a, i64 noundef %b, i64 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %d.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i64 %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load i64, ptr %d.addr, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float64_muladd(i64 noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 2, ptr noundef %3)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @fmadd16(i16 noundef zeroext %a, i16 noundef zeroext %b, i16 noundef zeroext %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i16 %d, ptr %d.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %d.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load i16, ptr %a.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call = call zeroext i16 @float16_muladd(i16 noundef zeroext %0, i16 noundef zeroext %1, i16 noundef zeroext %2, i32 noundef 0, ptr noundef %3)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fmadd32(i32 noundef %a, i32 noundef %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %d.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load i32, ptr %a.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_muladd(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 0, ptr noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fmadd64(i64 noundef %a, i64 noundef %b, i64 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %d.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i64 %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %d.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load i64, ptr %a.addr, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float64_muladd(i64 noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 0, ptr noundef %3)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @fnmadd16(i16 noundef zeroext %a, i16 noundef zeroext %b, i16 noundef zeroext %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i16 %d, ptr %d.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %d.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load i16, ptr %a.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call = call zeroext i16 @float16_muladd(i16 noundef zeroext %0, i16 noundef zeroext %1, i16 noundef zeroext %2, i32 noundef 3, ptr noundef %3)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fnmadd32(i32 noundef %a, i32 noundef %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %d.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load i32, ptr %a.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_muladd(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 3, ptr noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fnmadd64(i64 noundef %a, i64 noundef %b, i64 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %d.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i64 %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %d.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load i64, ptr %a.addr, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float64_muladd(i64 noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 3, ptr noundef %3)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @fmsub16(i16 noundef zeroext %a, i16 noundef zeroext %b, i16 noundef zeroext %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i16 %d, ptr %d.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %d.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load i16, ptr %a.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call = call zeroext i16 @float16_muladd(i16 noundef zeroext %0, i16 noundef zeroext %1, i16 noundef zeroext %2, i32 noundef 1, ptr noundef %3)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fmsub32(i32 noundef %a, i32 noundef %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %d.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load i32, ptr %a.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_muladd(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 1, ptr noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fmsub64(i64 noundef %a, i64 noundef %b, i64 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %d.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i64 %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %d.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load i64, ptr %a.addr, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float64_muladd(i64 noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 1, ptr noundef %3)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @fnmsub16(i16 noundef zeroext %a, i16 noundef zeroext %b, i16 noundef zeroext %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i16 %d, ptr %d.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %d.addr, align 2
  %1 = load i16, ptr %b.addr, align 2
  %2 = load i16, ptr %a.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call = call zeroext i16 @float16_muladd(i16 noundef zeroext %0, i16 noundef zeroext %1, i16 noundef zeroext %2, i32 noundef 2, ptr noundef %3)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fnmsub32(i32 noundef %a, i32 noundef %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %d.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %2 = load i32, ptr %a.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float32_muladd(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 2, ptr noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fnmsub64(i64 noundef %a, i64 noundef %b, i64 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %d.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store i64 %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %d.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %2 = load i64, ptr %a.addr, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float64_muladd(i64 noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef 2, ptr noundef %3)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fwmacc16(i16 noundef zeroext %a, i16 noundef zeroext %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_to_float32(i16 noundef zeroext %0, i1 noundef zeroext true, ptr noundef %1)
  %2 = load i16, ptr %b.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i32 @float16_to_float32(i16 noundef zeroext %2, i1 noundef zeroext true, ptr noundef %3)
  %4 = load i32, ptr %d.addr, align 4
  %5 = load ptr, ptr %s.addr, align 8
  %call2 = call i32 @float32_muladd(i32 noundef %call, i32 noundef %call1, i32 noundef %4, i32 noundef 0, ptr noundef %5)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fwmacc32(i32 noundef %a, i32 noundef %b, i64 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %d.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store i64 %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float32_to_float64(i32 noundef %0, ptr noundef %1)
  %2 = load i32, ptr %b.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i64 @float32_to_float64(i32 noundef %2, ptr noundef %3)
  %4 = load i64, ptr %d.addr, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %call2 = call i64 @float64_muladd(i64 noundef %call, i64 noundef %call1, i64 noundef %4, i32 noundef 0, ptr noundef %5)
  ret i64 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fwmaccbf16(i16 noundef zeroext %a, i16 noundef zeroext %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i32 @bfloat16_to_float32(i16 noundef zeroext %0, ptr noundef %1)
  %2 = load i16, ptr %b.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i32 @bfloat16_to_float32(i16 noundef zeroext %2, ptr noundef %3)
  %4 = load i32, ptr %d.addr, align 4
  %5 = load ptr, ptr %s.addr, align 8
  %call2 = call i32 @float32_muladd(i32 noundef %call, i32 noundef %call1, i32 noundef %4, i32 noundef 0, ptr noundef %5)
  ret i32 %call2
}

declare i32 @bfloat16_to_float32(i16 noundef zeroext, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fwnmacc16(i16 noundef zeroext %a, i16 noundef zeroext %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_to_float32(i16 noundef zeroext %0, i1 noundef zeroext true, ptr noundef %1)
  %2 = load i16, ptr %b.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i32 @float16_to_float32(i16 noundef zeroext %2, i1 noundef zeroext true, ptr noundef %3)
  %4 = load i32, ptr %d.addr, align 4
  %5 = load ptr, ptr %s.addr, align 8
  %call2 = call i32 @float32_muladd(i32 noundef %call, i32 noundef %call1, i32 noundef %4, i32 noundef 3, ptr noundef %5)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fwnmacc32(i32 noundef %a, i32 noundef %b, i64 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %d.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store i64 %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float32_to_float64(i32 noundef %0, ptr noundef %1)
  %2 = load i32, ptr %b.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i64 @float32_to_float64(i32 noundef %2, ptr noundef %3)
  %4 = load i64, ptr %d.addr, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %call2 = call i64 @float64_muladd(i64 noundef %call, i64 noundef %call1, i64 noundef %4, i32 noundef 3, ptr noundef %5)
  ret i64 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fwmsac16(i16 noundef zeroext %a, i16 noundef zeroext %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_to_float32(i16 noundef zeroext %0, i1 noundef zeroext true, ptr noundef %1)
  %2 = load i16, ptr %b.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i32 @float16_to_float32(i16 noundef zeroext %2, i1 noundef zeroext true, ptr noundef %3)
  %4 = load i32, ptr %d.addr, align 4
  %5 = load ptr, ptr %s.addr, align 8
  %call2 = call i32 @float32_muladd(i32 noundef %call, i32 noundef %call1, i32 noundef %4, i32 noundef 1, ptr noundef %5)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fwmsac32(i32 noundef %a, i32 noundef %b, i64 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %d.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store i64 %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float32_to_float64(i32 noundef %0, ptr noundef %1)
  %2 = load i32, ptr %b.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i64 @float32_to_float64(i32 noundef %2, ptr noundef %3)
  %4 = load i64, ptr %d.addr, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %call2 = call i64 @float64_muladd(i64 noundef %call, i64 noundef %call1, i64 noundef %4, i32 noundef 1, ptr noundef %5)
  ret i64 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fwnmsac16(i16 noundef zeroext %a, i16 noundef zeroext %b, i32 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %d.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store i32 %d, ptr %d.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_to_float32(i16 noundef zeroext %0, i1 noundef zeroext true, ptr noundef %1)
  %2 = load i16, ptr %b.addr, align 2
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i32 @float16_to_float32(i16 noundef zeroext %2, i1 noundef zeroext true, ptr noundef %3)
  %4 = load i32, ptr %d.addr, align 4
  %5 = load ptr, ptr %s.addr, align 8
  %call2 = call i32 @float32_muladd(i32 noundef %call, i32 noundef %call1, i32 noundef %4, i32 noundef 2, ptr noundef %5)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fwnmsac32(i32 noundef %a, i32 noundef %b, i64 noundef %d, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %d.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store i64 %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i64 @float32_to_float64(i32 noundef %0, ptr noundef %1)
  %2 = load i32, ptr %b.addr, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call i64 @float32_to_float64(i32 noundef %2, ptr noundef %3)
  %4 = load i64, ptr %d.addr, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %call2 = call i64 @float64_muladd(i64 noundef %call, i64 noundef %call1, i64 noundef %4, i32 noundef 2, ptr noundef %5)
  ret i64 %call2
}

declare zeroext i16 @float16_sqrt(i16 noundef zeroext, ptr noundef) #2

declare i32 @float32_sqrt(i32 noundef, ptr noundef) #2

declare i64 @float64_sqrt(i64 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @frsqrt7_h(i16 noundef zeroext %f, ptr noundef %s) #0 {
entry:
  %retval = alloca i16, align 2
  %f.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  %exp_size = alloca i32, align 4
  %frac_size = alloca i32, align 4
  %sign = alloca i8, align 1
  %val = alloca i64, align 8
  store i16 %f, ptr %f.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  store i32 5, ptr %exp_size, align 4
  store i32 10, ptr %frac_size, align 4
  %0 = load i16, ptr %f.addr, align 2
  %call = call zeroext i1 @float16_is_neg(i16 noundef zeroext %0)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %sign, align 1
  %1 = load i16, ptr %f.addr, align 2
  %2 = load ptr, ptr %s.addr, align 8
  %call1 = call zeroext i1 @float16_is_signaling_nan(i16 noundef zeroext %1, ptr noundef %2)
  br i1 %call1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i16, ptr %f.addr, align 2
  %call2 = call zeroext i1 @float16_is_infinity(i16 noundef zeroext %3)
  br i1 %call2, label %land.lhs.true, label %lor.lhs.false3

land.lhs.true:                                    ; preds = %lor.lhs.false
  %4 = load i8, ptr %sign, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %land.lhs.true, %lor.lhs.false
  %5 = load i16, ptr %f.addr, align 2
  %call4 = call zeroext i1 @float16_is_normal(i16 noundef zeroext %5)
  br i1 %call4, label %land.lhs.true5, label %lor.lhs.false7

land.lhs.true5:                                   ; preds = %lor.lhs.false3
  %6 = load i8, ptr %sign, align 1
  %tobool6 = trunc i8 %6 to i1
  br i1 %tobool6, label %if.then, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %land.lhs.true5, %lor.lhs.false3
  %7 = load i16, ptr %f.addr, align 2
  %call8 = call zeroext i1 @float16_is_zero_or_denormal(i16 noundef zeroext %7)
  br i1 %call8, label %land.lhs.true9, label %if.end

land.lhs.true9:                                   ; preds = %lor.lhs.false7
  %8 = load i16, ptr %f.addr, align 2
  %call10 = call zeroext i1 @float16_is_zero(i16 noundef zeroext %8)
  br i1 %call10, label %if.end, label %land.lhs.true11

land.lhs.true11:                                  ; preds = %land.lhs.true9
  %9 = load i8, ptr %sign, align 1
  %tobool12 = trunc i8 %9 to i1
  br i1 %tobool12, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true11, %land.lhs.true5, %land.lhs.true, %entry
  %10 = load ptr, ptr %s.addr, align 8
  %float_exception_flags = getelementptr inbounds %struct.float_status, ptr %10, i32 0, i32 0
  %11 = load i16, ptr %float_exception_flags, align 2
  %conv = zext i16 %11 to i32
  %or = or i32 %conv, 1
  %conv13 = trunc i32 %or to i16
  store i16 %conv13, ptr %float_exception_flags, align 2
  %12 = load ptr, ptr %s.addr, align 8
  %call14 = call zeroext i16 @float16_default_nan(ptr noundef %12)
  store i16 %call14, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %land.lhs.true11, %land.lhs.true9, %lor.lhs.false7
  %13 = load i16, ptr %f.addr, align 2
  %14 = load ptr, ptr %s.addr, align 8
  %call15 = call zeroext i1 @float16_is_quiet_nan(i16 noundef zeroext %13, ptr noundef %14)
  br i1 %call15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end
  %15 = load ptr, ptr %s.addr, align 8
  %call17 = call zeroext i16 @float16_default_nan(ptr noundef %15)
  store i16 %call17, ptr %retval, align 2
  br label %return

if.end18:                                         ; preds = %if.end
  %16 = load i16, ptr %f.addr, align 2
  %call19 = call zeroext i1 @float16_is_zero(i16 noundef zeroext %16)
  br i1 %call19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %if.end18
  %17 = load ptr, ptr %s.addr, align 8
  %float_exception_flags21 = getelementptr inbounds %struct.float_status, ptr %17, i32 0, i32 0
  %18 = load i16, ptr %float_exception_flags21, align 2
  %conv22 = zext i16 %18 to i32
  %or23 = or i32 %conv22, 2
  %conv24 = trunc i32 %or23 to i16
  store i16 %conv24, ptr %float_exception_flags21, align 2
  %19 = load i8, ptr %sign, align 1
  %tobool25 = trunc i8 %19 to i1
  %conv26 = zext i1 %tobool25 to i32
  %call27 = call zeroext i16 @float16_set_sign(i16 noundef zeroext 31744, i32 noundef %conv26)
  store i16 %call27, ptr %retval, align 2
  br label %return

if.end28:                                         ; preds = %if.end18
  %20 = load i16, ptr %f.addr, align 2
  %call29 = call zeroext i1 @float16_is_infinity(i16 noundef zeroext %20)
  br i1 %call29, label %land.lhs.true31, label %if.end37

land.lhs.true31:                                  ; preds = %if.end28
  %21 = load i8, ptr %sign, align 1
  %tobool32 = trunc i8 %21 to i1
  br i1 %tobool32, label %if.end37, label %if.then33

if.then33:                                        ; preds = %land.lhs.true31
  %22 = load i8, ptr %sign, align 1
  %tobool34 = trunc i8 %22 to i1
  %conv35 = zext i1 %tobool34 to i32
  %call36 = call zeroext i16 @float16_set_sign(i16 noundef zeroext 0, i32 noundef %conv35)
  store i16 %call36, ptr %retval, align 2
  br label %return

if.end37:                                         ; preds = %land.lhs.true31, %if.end28
  %23 = load i16, ptr %f.addr, align 2
  %conv38 = zext i16 %23 to i64
  %24 = load i32, ptr %exp_size, align 4
  %25 = load i32, ptr %frac_size, align 4
  %call39 = call i64 @frsqrt7(i64 noundef %conv38, i32 noundef %24, i32 noundef %25)
  store i64 %call39, ptr %val, align 8
  %26 = load i64, ptr %val, align 8
  %conv40 = trunc i64 %26 to i16
  store i16 %conv40, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end37, %if.then33, %if.then20, %if.then16, %if.then
  %27 = load i16, ptr %retval, align 2
  ret i16 %27
}

declare zeroext i1 @float16_is_signaling_nan(i16 noundef zeroext, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float16_is_normal(i16 noundef zeroext %a) #0 {
entry:
  %a.addr = alloca i16, align 2
  store i16 %a, ptr %a.addr, align 2
  %0 = load i16, ptr %a.addr, align 2
  %conv = zext i16 %0 to i32
  %shr = ashr i32 %conv, 10
  %add = add i32 %shr, 1
  %and = and i32 %add, 31
  %cmp = icmp sge i32 %and, 2
  ret i1 %cmp
}

declare zeroext i16 @float16_default_nan(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @float16_set_sign(i16 noundef zeroext %a, i32 noundef %sign) #0 {
entry:
  %a.addr = alloca i16, align 2
  %sign.addr = alloca i32, align 4
  store i16 %a, ptr %a.addr, align 2
  store i32 %sign, ptr %sign.addr, align 4
  %0 = load i16, ptr %a.addr, align 2
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 32767
  %1 = load i32, ptr %sign.addr, align 4
  %shl = shl i32 %1, 15
  %or = or i32 %and, %shl
  %conv1 = trunc i32 %or to i16
  ret i16 %conv1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @frsqrt7(i64 noundef %f, i32 noundef %exp_size, i32 noundef %frac_size) #0 {
entry:
  %f.addr = alloca i64, align 8
  %exp_size.addr = alloca i32, align 4
  %frac_size.addr = alloca i32, align 4
  %sign = alloca i64, align 8
  %exp = alloca i64, align 8
  %frac = alloca i64, align 8
  %lookup_table = alloca [128 x i8], align 16
  %precision = alloca i32, align 4
  %idx = alloca i32, align 4
  %out_frac = alloca i64, align 8
  %out_exp = alloca i64, align 8
  %val = alloca i64, align 8
  store i64 %f, ptr %f.addr, align 8
  store i32 %exp_size, ptr %exp_size.addr, align 4
  store i32 %frac_size, ptr %frac_size.addr, align 4
  %0 = load i64, ptr %f.addr, align 8
  %1 = load i32, ptr %frac_size.addr, align 4
  %2 = load i32, ptr %exp_size.addr, align 4
  %add = add i32 %1, %2
  %call = call i64 @extract64(i64 noundef %0, i32 noundef %add, i32 noundef 1)
  store i64 %call, ptr %sign, align 8
  %3 = load i64, ptr %f.addr, align 8
  %4 = load i32, ptr %frac_size.addr, align 4
  %5 = load i32, ptr %exp_size.addr, align 4
  %call1 = call i64 @extract64(i64 noundef %3, i32 noundef %4, i32 noundef %5)
  store i64 %call1, ptr %exp, align 8
  %6 = load i64, ptr %f.addr, align 8
  %7 = load i32, ptr %frac_size.addr, align 4
  %call2 = call i64 @extract64(i64 noundef %6, i32 noundef 0, i32 noundef %7)
  store i64 %call2, ptr %frac, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %lookup_table, ptr align 16 @__const.frsqrt7.lookup_table, i64 128, i1 false)
  store i32 7, ptr %precision, align 4
  %8 = load i64, ptr %exp, align 8
  %cmp = icmp eq i64 %8, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %9 = load i64, ptr %frac, align 8
  %cmp3 = icmp ne i64 %9, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %10 = load i64, ptr %frac, align 8
  %11 = load i32, ptr %frac_size.addr, align 4
  %sub = sub i32 %11, 1
  %call4 = call i64 @extract64(i64 noundef %10, i32 noundef %sub, i32 noundef 1)
  %cmp5 = icmp eq i64 %call4, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i64, ptr %exp, align 8
  %dec = add i64 %12, -1
  store i64 %dec, ptr %exp, align 8
  %13 = load i64, ptr %frac, align 8
  %shl = shl i64 %13, 1
  store i64 %shl, ptr %frac, align 8
  br label %while.cond, !llvm.loop !627

while.end:                                        ; preds = %while.cond
  %14 = load i64, ptr %frac, align 8
  %shl6 = shl i64 %14, 1
  %15 = load i32, ptr %frac_size.addr, align 4
  %sub7 = sub i32 64, %15
  %sh_prom = zext i32 %sub7 to i64
  %shr = lshr i64 -1, %sh_prom
  %shl8 = shl i64 %shr, 0
  %and = and i64 %shl6, %shl8
  store i64 %and, ptr %frac, align 8
  br label %if.end

if.end:                                           ; preds = %while.end, %land.lhs.true, %entry
  %16 = load i64, ptr %exp, align 8
  %and9 = and i64 %16, 1
  %shl10 = shl i64 %and9, 6
  %17 = load i64, ptr %frac, align 8
  %18 = load i32, ptr %frac_size.addr, align 4
  %sub11 = sub i32 %18, 7
  %add12 = add i32 %sub11, 1
  %sh_prom13 = zext i32 %add12 to i64
  %shr14 = lshr i64 %17, %sh_prom13
  %or = or i64 %shl10, %shr14
  %conv = trunc i64 %or to i32
  store i32 %conv, ptr %idx, align 4
  %19 = load i32, ptr %idx, align 4
  %idxprom = sext i32 %19 to i64
  %arrayidx = getelementptr [128 x i8], ptr %lookup_table, i64 0, i64 %idxprom
  %20 = load i8, ptr %arrayidx, align 1
  %conv15 = zext i8 %20 to i64
  %21 = load i32, ptr %frac_size.addr, align 4
  %sub16 = sub i32 %21, 7
  %sh_prom17 = zext i32 %sub16 to i64
  %shl18 = shl i64 %conv15, %sh_prom17
  store i64 %shl18, ptr %out_frac, align 8
  %22 = load i32, ptr %exp_size.addr, align 4
  %sub19 = sub i32 %22, 1
  %sub20 = sub i32 64, %sub19
  %sh_prom21 = zext i32 %sub20 to i64
  %shr22 = lshr i64 -1, %sh_prom21
  %shl23 = shl i64 %shr22, 0
  %mul = mul i64 3, %shl23
  %23 = load i64, ptr %exp, align 8
  %not = xor i64 %23, -1
  %add24 = add i64 %mul, %not
  %div = udiv i64 %add24, 2
  store i64 %div, ptr %out_exp, align 8
  store i64 0, ptr %val, align 8
  %24 = load i64, ptr %val, align 8
  %25 = load i32, ptr %frac_size.addr, align 4
  %26 = load i64, ptr %out_frac, align 8
  %call25 = call i64 @deposit64(i64 noundef %24, i32 noundef 0, i32 noundef %25, i64 noundef %26)
  store i64 %call25, ptr %val, align 8
  %27 = load i64, ptr %val, align 8
  %28 = load i32, ptr %frac_size.addr, align 4
  %29 = load i32, ptr %exp_size.addr, align 4
  %30 = load i64, ptr %out_exp, align 8
  %call26 = call i64 @deposit64(i64 noundef %27, i32 noundef %28, i32 noundef %29, i64 noundef %30)
  store i64 %call26, ptr %val, align 8
  %31 = load i64, ptr %val, align 8
  %32 = load i32, ptr %frac_size.addr, align 4
  %33 = load i32, ptr %exp_size.addr, align 4
  %add27 = add i32 %32, %33
  %34 = load i64, ptr %sign, align 8
  %call28 = call i64 @deposit64(i64 noundef %31, i32 noundef %add27, i32 noundef 1, i64 noundef %34)
  store i64 %call28, ptr %val, align 8
  %35 = load i64, ptr %val, align 8
  ret i64 %35
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @frsqrt7_s(i32 noundef %f, ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %f.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %exp_size = alloca i32, align 4
  %frac_size = alloca i32, align 4
  %sign = alloca i8, align 1
  %val = alloca i64, align 8
  store i32 %f, ptr %f.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 8, ptr %exp_size, align 4
  store i32 23, ptr %frac_size, align 4
  %0 = load i32, ptr %f.addr, align 4
  %call = call zeroext i1 @float32_is_neg(i32 noundef %0)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %sign, align 1
  %1 = load i32, ptr %f.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %call1 = call zeroext i1 @float32_is_signaling_nan(i32 noundef %1, ptr noundef %2)
  br i1 %call1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i32, ptr %f.addr, align 4
  %call2 = call zeroext i1 @float32_is_infinity(i32 noundef %3)
  br i1 %call2, label %land.lhs.true, label %lor.lhs.false3

land.lhs.true:                                    ; preds = %lor.lhs.false
  %4 = load i8, ptr %sign, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %land.lhs.true, %lor.lhs.false
  %5 = load i32, ptr %f.addr, align 4
  %call4 = call zeroext i1 @float32_is_normal(i32 noundef %5)
  br i1 %call4, label %land.lhs.true5, label %lor.lhs.false7

land.lhs.true5:                                   ; preds = %lor.lhs.false3
  %6 = load i8, ptr %sign, align 1
  %tobool6 = trunc i8 %6 to i1
  br i1 %tobool6, label %if.then, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %land.lhs.true5, %lor.lhs.false3
  %7 = load i32, ptr %f.addr, align 4
  %call8 = call zeroext i1 @float32_is_zero_or_denormal(i32 noundef %7)
  br i1 %call8, label %land.lhs.true9, label %if.end

land.lhs.true9:                                   ; preds = %lor.lhs.false7
  %8 = load i32, ptr %f.addr, align 4
  %call10 = call zeroext i1 @float32_is_zero(i32 noundef %8)
  br i1 %call10, label %if.end, label %land.lhs.true11

land.lhs.true11:                                  ; preds = %land.lhs.true9
  %9 = load i8, ptr %sign, align 1
  %tobool12 = trunc i8 %9 to i1
  br i1 %tobool12, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true11, %land.lhs.true5, %land.lhs.true, %entry
  %10 = load ptr, ptr %s.addr, align 8
  %float_exception_flags = getelementptr inbounds %struct.float_status, ptr %10, i32 0, i32 0
  %11 = load i16, ptr %float_exception_flags, align 2
  %conv = zext i16 %11 to i32
  %or = or i32 %conv, 1
  %conv13 = trunc i32 %or to i16
  store i16 %conv13, ptr %float_exception_flags, align 2
  %12 = load ptr, ptr %s.addr, align 8
  %call14 = call i32 @float32_default_nan(ptr noundef %12)
  store i32 %call14, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true11, %land.lhs.true9, %lor.lhs.false7
  %13 = load i32, ptr %f.addr, align 4
  %14 = load ptr, ptr %s.addr, align 8
  %call15 = call zeroext i1 @float32_is_quiet_nan(i32 noundef %13, ptr noundef %14)
  br i1 %call15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end
  %15 = load ptr, ptr %s.addr, align 8
  %call17 = call i32 @float32_default_nan(ptr noundef %15)
  store i32 %call17, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end
  %16 = load i32, ptr %f.addr, align 4
  %call19 = call zeroext i1 @float32_is_zero(i32 noundef %16)
  br i1 %call19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %if.end18
  %17 = load ptr, ptr %s.addr, align 8
  %float_exception_flags21 = getelementptr inbounds %struct.float_status, ptr %17, i32 0, i32 0
  %18 = load i16, ptr %float_exception_flags21, align 2
  %conv22 = zext i16 %18 to i32
  %or23 = or i32 %conv22, 2
  %conv24 = trunc i32 %or23 to i16
  store i16 %conv24, ptr %float_exception_flags21, align 2
  %19 = load i8, ptr %sign, align 1
  %tobool25 = trunc i8 %19 to i1
  %conv26 = zext i1 %tobool25 to i32
  %call27 = call i32 @float32_set_sign(i32 noundef 2139095040, i32 noundef %conv26)
  store i32 %call27, ptr %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end18
  %20 = load i32, ptr %f.addr, align 4
  %call29 = call zeroext i1 @float32_is_infinity(i32 noundef %20)
  br i1 %call29, label %land.lhs.true31, label %if.end37

land.lhs.true31:                                  ; preds = %if.end28
  %21 = load i8, ptr %sign, align 1
  %tobool32 = trunc i8 %21 to i1
  br i1 %tobool32, label %if.end37, label %if.then33

if.then33:                                        ; preds = %land.lhs.true31
  %22 = load i8, ptr %sign, align 1
  %tobool34 = trunc i8 %22 to i1
  %conv35 = zext i1 %tobool34 to i32
  %call36 = call i32 @float32_set_sign(i32 noundef 0, i32 noundef %conv35)
  store i32 %call36, ptr %retval, align 4
  br label %return

if.end37:                                         ; preds = %land.lhs.true31, %if.end28
  %23 = load i32, ptr %f.addr, align 4
  %conv38 = zext i32 %23 to i64
  %24 = load i32, ptr %exp_size, align 4
  %25 = load i32, ptr %frac_size, align 4
  %call39 = call i64 @frsqrt7(i64 noundef %conv38, i32 noundef %24, i32 noundef %25)
  store i64 %call39, ptr %val, align 8
  %26 = load i64, ptr %val, align 8
  %conv40 = trunc i64 %26 to i32
  store i32 %conv40, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %if.then33, %if.then20, %if.then16, %if.then
  %27 = load i32, ptr %retval, align 4
  ret i32 %27
}

declare zeroext i1 @float32_is_signaling_nan(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float32_is_normal(i32 noundef %a) #0 {
entry:
  %a.addr = alloca i32, align 4
  store i32 %a, ptr %a.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %shr = lshr i32 %0, 23
  %add = add i32 %shr, 1
  %and = and i32 %add, 255
  %cmp = icmp uge i32 %and, 2
  ret i1 %cmp
}

declare i32 @float32_default_nan(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @float32_set_sign(i32 noundef %a, i32 noundef %sign) #0 {
entry:
  %a.addr = alloca i32, align 4
  %sign.addr = alloca i32, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %sign, ptr %sign.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %and = and i32 %0, 2147483647
  %1 = load i32, ptr %sign.addr, align 4
  %shl = shl i32 %1, 31
  %or = or i32 %and, %shl
  ret i32 %or
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @frsqrt7_d(i64 noundef %f, ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %f.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %exp_size = alloca i32, align 4
  %frac_size = alloca i32, align 4
  %sign = alloca i8, align 1
  %val = alloca i64, align 8
  store i64 %f, ptr %f.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 11, ptr %exp_size, align 4
  store i32 52, ptr %frac_size, align 4
  %0 = load i64, ptr %f.addr, align 8
  %call = call zeroext i1 @float64_is_neg(i64 noundef %0)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %sign, align 1
  %1 = load i64, ptr %f.addr, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %call1 = call zeroext i1 @float64_is_signaling_nan(i64 noundef %1, ptr noundef %2)
  br i1 %call1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i64, ptr %f.addr, align 8
  %call2 = call zeroext i1 @float64_is_infinity(i64 noundef %3)
  br i1 %call2, label %land.lhs.true, label %lor.lhs.false3

land.lhs.true:                                    ; preds = %lor.lhs.false
  %4 = load i8, ptr %sign, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %land.lhs.true, %lor.lhs.false
  %5 = load i64, ptr %f.addr, align 8
  %call4 = call zeroext i1 @float64_is_normal(i64 noundef %5)
  br i1 %call4, label %land.lhs.true5, label %lor.lhs.false7

land.lhs.true5:                                   ; preds = %lor.lhs.false3
  %6 = load i8, ptr %sign, align 1
  %tobool6 = trunc i8 %6 to i1
  br i1 %tobool6, label %if.then, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %land.lhs.true5, %lor.lhs.false3
  %7 = load i64, ptr %f.addr, align 8
  %call8 = call zeroext i1 @float64_is_zero_or_denormal(i64 noundef %7)
  br i1 %call8, label %land.lhs.true9, label %if.end

land.lhs.true9:                                   ; preds = %lor.lhs.false7
  %8 = load i64, ptr %f.addr, align 8
  %call10 = call zeroext i1 @float64_is_zero(i64 noundef %8)
  br i1 %call10, label %if.end, label %land.lhs.true11

land.lhs.true11:                                  ; preds = %land.lhs.true9
  %9 = load i8, ptr %sign, align 1
  %tobool12 = trunc i8 %9 to i1
  br i1 %tobool12, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true11, %land.lhs.true5, %land.lhs.true, %entry
  %10 = load ptr, ptr %s.addr, align 8
  %float_exception_flags = getelementptr inbounds %struct.float_status, ptr %10, i32 0, i32 0
  %11 = load i16, ptr %float_exception_flags, align 2
  %conv = zext i16 %11 to i32
  %or = or i32 %conv, 1
  %conv13 = trunc i32 %or to i16
  store i16 %conv13, ptr %float_exception_flags, align 2
  %12 = load ptr, ptr %s.addr, align 8
  %call14 = call i64 @float64_default_nan(ptr noundef %12)
  store i64 %call14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true11, %land.lhs.true9, %lor.lhs.false7
  %13 = load i64, ptr %f.addr, align 8
  %14 = load ptr, ptr %s.addr, align 8
  %call15 = call zeroext i1 @float64_is_quiet_nan(i64 noundef %13, ptr noundef %14)
  br i1 %call15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end
  %15 = load ptr, ptr %s.addr, align 8
  %call17 = call i64 @float64_default_nan(ptr noundef %15)
  store i64 %call17, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %if.end
  %16 = load i64, ptr %f.addr, align 8
  %call19 = call zeroext i1 @float64_is_zero(i64 noundef %16)
  br i1 %call19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %if.end18
  %17 = load ptr, ptr %s.addr, align 8
  %float_exception_flags21 = getelementptr inbounds %struct.float_status, ptr %17, i32 0, i32 0
  %18 = load i16, ptr %float_exception_flags21, align 2
  %conv22 = zext i16 %18 to i32
  %or23 = or i32 %conv22, 2
  %conv24 = trunc i32 %or23 to i16
  store i16 %conv24, ptr %float_exception_flags21, align 2
  %19 = load i8, ptr %sign, align 1
  %tobool25 = trunc i8 %19 to i1
  %conv26 = zext i1 %tobool25 to i32
  %call27 = call i64 @float64_set_sign(i64 noundef 9218868437227405312, i32 noundef %conv26)
  store i64 %call27, ptr %retval, align 8
  br label %return

if.end28:                                         ; preds = %if.end18
  %20 = load i64, ptr %f.addr, align 8
  %call29 = call zeroext i1 @float64_is_infinity(i64 noundef %20)
  br i1 %call29, label %land.lhs.true31, label %if.end37

land.lhs.true31:                                  ; preds = %if.end28
  %21 = load i8, ptr %sign, align 1
  %tobool32 = trunc i8 %21 to i1
  br i1 %tobool32, label %if.end37, label %if.then33

if.then33:                                        ; preds = %land.lhs.true31
  %22 = load i8, ptr %sign, align 1
  %tobool34 = trunc i8 %22 to i1
  %conv35 = zext i1 %tobool34 to i32
  %call36 = call i64 @float64_set_sign(i64 noundef 0, i32 noundef %conv35)
  store i64 %call36, ptr %retval, align 8
  br label %return

if.end37:                                         ; preds = %land.lhs.true31, %if.end28
  %23 = load i64, ptr %f.addr, align 8
  %24 = load i32, ptr %exp_size, align 4
  %25 = load i32, ptr %frac_size, align 4
  %call38 = call i64 @frsqrt7(i64 noundef %23, i32 noundef %24, i32 noundef %25)
  store i64 %call38, ptr %val, align 8
  %26 = load i64, ptr %val, align 8
  store i64 %26, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end37, %if.then33, %if.then20, %if.then16, %if.then
  %27 = load i64, ptr %retval, align 8
  ret i64 %27
}

declare zeroext i1 @float64_is_signaling_nan(i64 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @float64_is_normal(i64 noundef %a) #0 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, ptr %a.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %shr = lshr i64 %0, 52
  %add = add i64 %shr, 1
  %and = and i64 %add, 2047
  %cmp = icmp uge i64 %and, 2
  ret i1 %cmp
}

declare i64 @float64_default_nan(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @float64_set_sign(i64 noundef %a, i32 noundef %sign) #0 {
entry:
  %a.addr = alloca i64, align 8
  %sign.addr = alloca i32, align 4
  store i64 %a, ptr %a.addr, align 8
  store i32 %sign, ptr %sign.addr, align 4
  %0 = load i64, ptr %a.addr, align 8
  %and = and i64 %0, 9223372036854775807
  %1 = load i32, ptr %sign.addr, align 4
  %conv = sext i32 %1 to i64
  %shl = shl i64 %conv, 63
  %or = or i64 %and, %shl
  ret i64 %or
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @frec7_h(i16 noundef zeroext %f, ptr noundef %s) #0 {
entry:
  %retval = alloca i16, align 2
  %f.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  %exp_size = alloca i32, align 4
  %frac_size = alloca i32, align 4
  %sign = alloca i8, align 1
  %val = alloca i64, align 8
  store i16 %f, ptr %f.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  store i32 5, ptr %exp_size, align 4
  store i32 10, ptr %frac_size, align 4
  %0 = load i16, ptr %f.addr, align 2
  %call = call zeroext i1 @float16_is_neg(i16 noundef zeroext %0)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %sign, align 1
  %1 = load i16, ptr %f.addr, align 2
  %call1 = call zeroext i1 @float16_is_infinity(i16 noundef zeroext %1)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i8, ptr %sign, align 1
  %tobool = trunc i8 %2 to i1
  %conv = zext i1 %tobool to i32
  %call2 = call zeroext i16 @float16_set_sign(i16 noundef zeroext 0, i32 noundef %conv)
  store i16 %call2, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i16, ptr %f.addr, align 2
  %call3 = call zeroext i1 @float16_is_zero(i16 noundef zeroext %3)
  br i1 %call3, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.end
  %4 = load ptr, ptr %s.addr, align 8
  %float_exception_flags = getelementptr inbounds %struct.float_status, ptr %4, i32 0, i32 0
  %5 = load i16, ptr %float_exception_flags, align 2
  %conv5 = zext i16 %5 to i32
  %or = or i32 %conv5, 2
  %conv6 = trunc i32 %or to i16
  store i16 %conv6, ptr %float_exception_flags, align 2
  %6 = load i8, ptr %sign, align 1
  %tobool7 = trunc i8 %6 to i1
  %conv8 = zext i1 %tobool7 to i32
  %call9 = call zeroext i16 @float16_set_sign(i16 noundef zeroext 31744, i32 noundef %conv8)
  store i16 %call9, ptr %retval, align 2
  br label %return

if.end10:                                         ; preds = %if.end
  %7 = load i16, ptr %f.addr, align 2
  %8 = load ptr, ptr %s.addr, align 8
  %call11 = call zeroext i1 @float16_is_signaling_nan(i16 noundef zeroext %7, ptr noundef %8)
  br i1 %call11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %if.end10
  %9 = load ptr, ptr %s.addr, align 8
  %float_exception_flags13 = getelementptr inbounds %struct.float_status, ptr %9, i32 0, i32 0
  %10 = load i16, ptr %float_exception_flags13, align 2
  %conv14 = zext i16 %10 to i32
  %or15 = or i32 %conv14, 1
  %conv16 = trunc i32 %or15 to i16
  store i16 %conv16, ptr %float_exception_flags13, align 2
  %11 = load ptr, ptr %s.addr, align 8
  %call17 = call zeroext i16 @float16_default_nan(ptr noundef %11)
  store i16 %call17, ptr %retval, align 2
  br label %return

if.end18:                                         ; preds = %if.end10
  %12 = load i16, ptr %f.addr, align 2
  %13 = load ptr, ptr %s.addr, align 8
  %call19 = call zeroext i1 @float16_is_quiet_nan(i16 noundef zeroext %12, ptr noundef %13)
  br i1 %call19, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.end18
  %14 = load ptr, ptr %s.addr, align 8
  %call21 = call zeroext i16 @float16_default_nan(ptr noundef %14)
  store i16 %call21, ptr %retval, align 2
  br label %return

if.end22:                                         ; preds = %if.end18
  %15 = load i16, ptr %f.addr, align 2
  %conv23 = zext i16 %15 to i64
  %16 = load i32, ptr %exp_size, align 4
  %17 = load i32, ptr %frac_size, align 4
  %18 = load ptr, ptr %s.addr, align 8
  %call24 = call i64 @frec7(i64 noundef %conv23, i32 noundef %16, i32 noundef %17, ptr noundef %18)
  store i64 %call24, ptr %val, align 8
  %19 = load i64, ptr %val, align 8
  %conv25 = trunc i64 %19 to i16
  store i16 %conv25, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end22, %if.then20, %if.then12, %if.then4, %if.then
  %20 = load i16, ptr %retval, align 2
  ret i16 %20
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @frec7(i64 noundef %f, i32 noundef %exp_size, i32 noundef %frac_size, ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %f.addr = alloca i64, align 8
  %exp_size.addr = alloca i32, align 4
  %frac_size.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sign = alloca i64, align 8
  %exp = alloca i64, align 8
  %frac = alloca i64, align 8
  %lookup_table = alloca [128 x i8], align 16
  %precision = alloca i32, align 4
  %idx = alloca i32, align 4
  %out_frac = alloca i64, align 8
  %out_exp = alloca i64, align 8
  %val = alloca i64, align 8
  store i64 %f, ptr %f.addr, align 8
  store i32 %exp_size, ptr %exp_size.addr, align 4
  store i32 %frac_size, ptr %frac_size.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %f.addr, align 8
  %1 = load i32, ptr %frac_size.addr, align 4
  %2 = load i32, ptr %exp_size.addr, align 4
  %add = add i32 %1, %2
  %call = call i64 @extract64(i64 noundef %0, i32 noundef %add, i32 noundef 1)
  store i64 %call, ptr %sign, align 8
  %3 = load i64, ptr %f.addr, align 8
  %4 = load i32, ptr %frac_size.addr, align 4
  %5 = load i32, ptr %exp_size.addr, align 4
  %call1 = call i64 @extract64(i64 noundef %3, i32 noundef %4, i32 noundef %5)
  store i64 %call1, ptr %exp, align 8
  %6 = load i64, ptr %f.addr, align 8
  %7 = load i32, ptr %frac_size.addr, align 4
  %call2 = call i64 @extract64(i64 noundef %6, i32 noundef 0, i32 noundef %7)
  store i64 %call2, ptr %frac, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %lookup_table, ptr align 16 @__const.frec7.lookup_table, i64 128, i1 false)
  store i32 7, ptr %precision, align 4
  %8 = load i64, ptr %exp, align 8
  %cmp = icmp eq i64 %8, 0
  br i1 %cmp, label %land.lhs.true, label %if.end49

land.lhs.true:                                    ; preds = %entry
  %9 = load i64, ptr %frac, align 8
  %cmp3 = icmp ne i64 %9, 0
  br i1 %cmp3, label %if.then, label %if.end49

if.then:                                          ; preds = %land.lhs.true
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %10 = load i64, ptr %frac, align 8
  %11 = load i32, ptr %frac_size.addr, align 4
  %sub = sub i32 %11, 1
  %call4 = call i64 @extract64(i64 noundef %10, i32 noundef %sub, i32 noundef 1)
  %cmp5 = icmp eq i64 %call4, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load i64, ptr %exp, align 8
  %dec = add i64 %12, -1
  store i64 %dec, ptr %exp, align 8
  %13 = load i64, ptr %frac, align 8
  %shl = shl i64 %13, 1
  store i64 %shl, ptr %frac, align 8
  br label %while.cond, !llvm.loop !628

while.end:                                        ; preds = %while.cond
  %14 = load i64, ptr %frac, align 8
  %shl6 = shl i64 %14, 1
  %15 = load i32, ptr %frac_size.addr, align 4
  %sub7 = sub i32 64, %15
  %sh_prom = zext i32 %sub7 to i64
  %shr = lshr i64 -1, %sh_prom
  %shl8 = shl i64 %shr, 0
  %and = and i64 %shl6, %shl8
  store i64 %and, ptr %frac, align 8
  %16 = load i64, ptr %exp, align 8
  %cmp9 = icmp ne i64 %16, 0
  br i1 %cmp9, label %land.lhs.true10, label %if.end

land.lhs.true10:                                  ; preds = %while.end
  %17 = load i64, ptr %exp, align 8
  %cmp11 = icmp ne i64 %17, -1
  br i1 %cmp11, label %if.then12, label %if.end

if.then12:                                        ; preds = %land.lhs.true10
  %18 = load ptr, ptr %s.addr, align 8
  %float_exception_flags = getelementptr inbounds %struct.float_status, ptr %18, i32 0, i32 0
  %19 = load i16, ptr %float_exception_flags, align 2
  %conv = zext i16 %19 to i32
  %or = or i32 %conv, 20
  %conv13 = trunc i32 %or to i16
  store i16 %conv13, ptr %float_exception_flags, align 2
  %20 = load ptr, ptr %s.addr, align 8
  %float_rounding_mode = getelementptr inbounds %struct.float_status, ptr %20, i32 0, i32 1
  %21 = load i8, ptr %float_rounding_mode, align 2
  %conv14 = zext i8 %21 to i32
  %cmp15 = icmp eq i32 %conv14, 3
  br i1 %cmp15, label %if.then29, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then12
  %22 = load ptr, ptr %s.addr, align 8
  %float_rounding_mode17 = getelementptr inbounds %struct.float_status, ptr %22, i32 0, i32 1
  %23 = load i8, ptr %float_rounding_mode17, align 2
  %conv18 = zext i8 %23 to i32
  %cmp19 = icmp eq i32 %conv18, 1
  br i1 %cmp19, label %land.lhs.true21, label %lor.lhs.false22

land.lhs.true21:                                  ; preds = %lor.lhs.false
  %24 = load i64, ptr %sign, align 8
  %tobool = icmp ne i64 %24, 0
  br i1 %tobool, label %lor.lhs.false22, label %if.then29

lor.lhs.false22:                                  ; preds = %land.lhs.true21, %lor.lhs.false
  %25 = load ptr, ptr %s.addr, align 8
  %float_rounding_mode23 = getelementptr inbounds %struct.float_status, ptr %25, i32 0, i32 1
  %26 = load i8, ptr %float_rounding_mode23, align 2
  %conv24 = zext i8 %26 to i32
  %cmp25 = icmp eq i32 %conv24, 2
  br i1 %cmp25, label %land.lhs.true27, label %if.else

land.lhs.true27:                                  ; preds = %lor.lhs.false22
  %27 = load i64, ptr %sign, align 8
  %tobool28 = icmp ne i64 %27, 0
  br i1 %tobool28, label %if.then29, label %if.else

if.then29:                                        ; preds = %land.lhs.true27, %land.lhs.true21, %if.then12
  %28 = load i64, ptr %sign, align 8
  %29 = load i32, ptr %exp_size.addr, align 4
  %30 = load i32, ptr %frac_size.addr, align 4
  %add30 = add i32 %29, %30
  %sh_prom31 = zext i32 %add30 to i64
  %shl32 = shl i64 %28, %sh_prom31
  %31 = load i32, ptr %exp_size.addr, align 4
  %sub33 = sub i32 64, %31
  %sh_prom34 = zext i32 %sub33 to i64
  %shr35 = lshr i64 -1, %sh_prom34
  %32 = load i32, ptr %frac_size.addr, align 4
  %sh_prom36 = zext i32 %32 to i64
  %shl37 = shl i64 %shr35, %sh_prom36
  %sub38 = sub i64 %shl37, 1
  %or39 = or i64 %shl32, %sub38
  store i64 %or39, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %land.lhs.true27, %lor.lhs.false22
  %33 = load i64, ptr %sign, align 8
  %34 = load i32, ptr %exp_size.addr, align 4
  %35 = load i32, ptr %frac_size.addr, align 4
  %add40 = add i32 %34, %35
  %sh_prom41 = zext i32 %add40 to i64
  %shl42 = shl i64 %33, %sh_prom41
  %36 = load i32, ptr %exp_size.addr, align 4
  %sub43 = sub i32 64, %36
  %sh_prom44 = zext i32 %sub43 to i64
  %shr45 = lshr i64 -1, %sh_prom44
  %37 = load i32, ptr %frac_size.addr, align 4
  %sh_prom46 = zext i32 %37 to i64
  %shl47 = shl i64 %shr45, %sh_prom46
  %or48 = or i64 %shl42, %shl47
  store i64 %or48, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true10, %while.end
  br label %if.end49

if.end49:                                         ; preds = %if.end, %land.lhs.true, %entry
  %38 = load i64, ptr %frac, align 8
  %39 = load i32, ptr %frac_size.addr, align 4
  %sub50 = sub i32 %39, 7
  %sh_prom51 = zext i32 %sub50 to i64
  %shr52 = lshr i64 %38, %sh_prom51
  %conv53 = trunc i64 %shr52 to i32
  store i32 %conv53, ptr %idx, align 4
  %40 = load i32, ptr %idx, align 4
  %idxprom = sext i32 %40 to i64
  %arrayidx = getelementptr [128 x i8], ptr %lookup_table, i64 0, i64 %idxprom
  %41 = load i8, ptr %arrayidx, align 1
  %conv54 = zext i8 %41 to i64
  %42 = load i32, ptr %frac_size.addr, align 4
  %sub55 = sub i32 %42, 7
  %sh_prom56 = zext i32 %sub55 to i64
  %shl57 = shl i64 %conv54, %sh_prom56
  store i64 %shl57, ptr %out_frac, align 8
  %43 = load i32, ptr %exp_size.addr, align 4
  %sub58 = sub i32 %43, 1
  %sub59 = sub i32 64, %sub58
  %sh_prom60 = zext i32 %sub59 to i64
  %shr61 = lshr i64 -1, %sh_prom60
  %shl62 = shl i64 %shr61, 0
  %mul = mul i64 2, %shl62
  %44 = load i64, ptr %exp, align 8
  %not = xor i64 %44, -1
  %add63 = add i64 %mul, %not
  store i64 %add63, ptr %out_exp, align 8
  %45 = load i64, ptr %out_exp, align 8
  %cmp64 = icmp eq i64 %45, 0
  br i1 %cmp64, label %if.then69, label %lor.lhs.false66

lor.lhs.false66:                                  ; preds = %if.end49
  %46 = load i64, ptr %out_exp, align 8
  %cmp67 = icmp eq i64 %46, -1
  br i1 %cmp67, label %if.then69, label %if.end80

if.then69:                                        ; preds = %lor.lhs.false66, %if.end49
  %47 = load i64, ptr %out_frac, align 8
  %shr70 = lshr i64 %47, 1
  %48 = load i32, ptr %frac_size.addr, align 4
  %sub71 = sub i32 %48, 1
  %sh_prom72 = zext i32 %sub71 to i64
  %shl73 = shl i64 1, %sh_prom72
  %or74 = or i64 %shr70, %shl73
  store i64 %or74, ptr %out_frac, align 8
  %49 = load i64, ptr %out_exp, align 8
  %cmp75 = icmp eq i64 %49, -1
  br i1 %cmp75, label %if.then77, label %if.end79

if.then77:                                        ; preds = %if.then69
  %50 = load i64, ptr %out_frac, align 8
  %shr78 = lshr i64 %50, 1
  store i64 %shr78, ptr %out_frac, align 8
  store i64 0, ptr %out_exp, align 8
  br label %if.end79

if.end79:                                         ; preds = %if.then77, %if.then69
  br label %if.end80

if.end80:                                         ; preds = %if.end79, %lor.lhs.false66
  store i64 0, ptr %val, align 8
  %51 = load i64, ptr %val, align 8
  %52 = load i32, ptr %frac_size.addr, align 4
  %53 = load i64, ptr %out_frac, align 8
  %call81 = call i64 @deposit64(i64 noundef %51, i32 noundef 0, i32 noundef %52, i64 noundef %53)
  store i64 %call81, ptr %val, align 8
  %54 = load i64, ptr %val, align 8
  %55 = load i32, ptr %frac_size.addr, align 4
  %56 = load i32, ptr %exp_size.addr, align 4
  %57 = load i64, ptr %out_exp, align 8
  %call82 = call i64 @deposit64(i64 noundef %54, i32 noundef %55, i32 noundef %56, i64 noundef %57)
  store i64 %call82, ptr %val, align 8
  %58 = load i64, ptr %val, align 8
  %59 = load i32, ptr %frac_size.addr, align 4
  %60 = load i32, ptr %exp_size.addr, align 4
  %add83 = add i32 %59, %60
  %61 = load i64, ptr %sign, align 8
  %call84 = call i64 @deposit64(i64 noundef %58, i32 noundef %add83, i32 noundef 1, i64 noundef %61)
  store i64 %call84, ptr %val, align 8
  %62 = load i64, ptr %val, align 8
  store i64 %62, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end80, %if.else, %if.then29
  %63 = load i64, ptr %retval, align 8
  ret i64 %63
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @frec7_s(i32 noundef %f, ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %f.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %exp_size = alloca i32, align 4
  %frac_size = alloca i32, align 4
  %sign = alloca i8, align 1
  %val = alloca i64, align 8
  store i32 %f, ptr %f.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 8, ptr %exp_size, align 4
  store i32 23, ptr %frac_size, align 4
  %0 = load i32, ptr %f.addr, align 4
  %call = call zeroext i1 @float32_is_neg(i32 noundef %0)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %sign, align 1
  %1 = load i32, ptr %f.addr, align 4
  %call1 = call zeroext i1 @float32_is_infinity(i32 noundef %1)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i8, ptr %sign, align 1
  %tobool = trunc i8 %2 to i1
  %conv = zext i1 %tobool to i32
  %call2 = call i32 @float32_set_sign(i32 noundef 0, i32 noundef %conv)
  store i32 %call2, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %f.addr, align 4
  %call3 = call zeroext i1 @float32_is_zero(i32 noundef %3)
  br i1 %call3, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.end
  %4 = load ptr, ptr %s.addr, align 8
  %float_exception_flags = getelementptr inbounds %struct.float_status, ptr %4, i32 0, i32 0
  %5 = load i16, ptr %float_exception_flags, align 2
  %conv5 = zext i16 %5 to i32
  %or = or i32 %conv5, 2
  %conv6 = trunc i32 %or to i16
  store i16 %conv6, ptr %float_exception_flags, align 2
  %6 = load i8, ptr %sign, align 1
  %tobool7 = trunc i8 %6 to i1
  %conv8 = zext i1 %tobool7 to i32
  %call9 = call i32 @float32_set_sign(i32 noundef 2139095040, i32 noundef %conv8)
  store i32 %call9, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  %7 = load i32, ptr %f.addr, align 4
  %8 = load ptr, ptr %s.addr, align 8
  %call11 = call zeroext i1 @float32_is_signaling_nan(i32 noundef %7, ptr noundef %8)
  br i1 %call11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %if.end10
  %9 = load ptr, ptr %s.addr, align 8
  %float_exception_flags13 = getelementptr inbounds %struct.float_status, ptr %9, i32 0, i32 0
  %10 = load i16, ptr %float_exception_flags13, align 2
  %conv14 = zext i16 %10 to i32
  %or15 = or i32 %conv14, 1
  %conv16 = trunc i32 %or15 to i16
  store i16 %conv16, ptr %float_exception_flags13, align 2
  %11 = load ptr, ptr %s.addr, align 8
  %call17 = call i32 @float32_default_nan(ptr noundef %11)
  store i32 %call17, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end10
  %12 = load i32, ptr %f.addr, align 4
  %13 = load ptr, ptr %s.addr, align 8
  %call19 = call zeroext i1 @float32_is_quiet_nan(i32 noundef %12, ptr noundef %13)
  br i1 %call19, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.end18
  %14 = load ptr, ptr %s.addr, align 8
  %call21 = call i32 @float32_default_nan(ptr noundef %14)
  store i32 %call21, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end18
  %15 = load i32, ptr %f.addr, align 4
  %conv23 = zext i32 %15 to i64
  %16 = load i32, ptr %exp_size, align 4
  %17 = load i32, ptr %frac_size, align 4
  %18 = load ptr, ptr %s.addr, align 8
  %call24 = call i64 @frec7(i64 noundef %conv23, i32 noundef %16, i32 noundef %17, ptr noundef %18)
  store i64 %call24, ptr %val, align 8
  %19 = load i64, ptr %val, align 8
  %conv25 = trunc i64 %19 to i32
  store i32 %conv25, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end22, %if.then20, %if.then12, %if.then4, %if.then
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @frec7_d(i64 noundef %f, ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %f.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %exp_size = alloca i32, align 4
  %frac_size = alloca i32, align 4
  %sign = alloca i8, align 1
  %val = alloca i64, align 8
  store i64 %f, ptr %f.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 11, ptr %exp_size, align 4
  store i32 52, ptr %frac_size, align 4
  %0 = load i64, ptr %f.addr, align 8
  %call = call zeroext i1 @float64_is_neg(i64 noundef %0)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %sign, align 1
  %1 = load i64, ptr %f.addr, align 8
  %call1 = call zeroext i1 @float64_is_infinity(i64 noundef %1)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i8, ptr %sign, align 1
  %tobool = trunc i8 %2 to i1
  %conv = zext i1 %tobool to i32
  %call2 = call i64 @float64_set_sign(i64 noundef 0, i32 noundef %conv)
  store i64 %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i64, ptr %f.addr, align 8
  %call3 = call zeroext i1 @float64_is_zero(i64 noundef %3)
  br i1 %call3, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.end
  %4 = load ptr, ptr %s.addr, align 8
  %float_exception_flags = getelementptr inbounds %struct.float_status, ptr %4, i32 0, i32 0
  %5 = load i16, ptr %float_exception_flags, align 2
  %conv5 = zext i16 %5 to i32
  %or = or i32 %conv5, 2
  %conv6 = trunc i32 %or to i16
  store i16 %conv6, ptr %float_exception_flags, align 2
  %6 = load i8, ptr %sign, align 1
  %tobool7 = trunc i8 %6 to i1
  %conv8 = zext i1 %tobool7 to i32
  %call9 = call i64 @float64_set_sign(i64 noundef 9218868437227405312, i32 noundef %conv8)
  store i64 %call9, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end
  %7 = load i64, ptr %f.addr, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %call11 = call zeroext i1 @float64_is_signaling_nan(i64 noundef %7, ptr noundef %8)
  br i1 %call11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %if.end10
  %9 = load ptr, ptr %s.addr, align 8
  %float_exception_flags13 = getelementptr inbounds %struct.float_status, ptr %9, i32 0, i32 0
  %10 = load i16, ptr %float_exception_flags13, align 2
  %conv14 = zext i16 %10 to i32
  %or15 = or i32 %conv14, 1
  %conv16 = trunc i32 %or15 to i16
  store i16 %conv16, ptr %float_exception_flags13, align 2
  %11 = load ptr, ptr %s.addr, align 8
  %call17 = call i64 @float64_default_nan(ptr noundef %11)
  store i64 %call17, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %if.end10
  %12 = load i64, ptr %f.addr, align 8
  %13 = load ptr, ptr %s.addr, align 8
  %call19 = call zeroext i1 @float64_is_quiet_nan(i64 noundef %12, ptr noundef %13)
  br i1 %call19, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.end18
  %14 = load ptr, ptr %s.addr, align 8
  %call21 = call i64 @float64_default_nan(ptr noundef %14)
  store i64 %call21, ptr %retval, align 8
  br label %return

if.end22:                                         ; preds = %if.end18
  %15 = load i64, ptr %f.addr, align 8
  %16 = load i32, ptr %exp_size, align 4
  %17 = load i32, ptr %frac_size, align 4
  %18 = load ptr, ptr %s.addr, align 8
  %call23 = call i64 @frec7(i64 noundef %15, i32 noundef %16, i32 noundef %17, ptr noundef %18)
  store i64 %call23, ptr %val, align 8
  %19 = load i64, ptr %val, align 8
  store i64 %19, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end22, %if.then20, %if.then12, %if.then4, %if.then
  %20 = load i64, ptr %retval, align 8
  ret i64 %20
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @fsgnj16(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %b.addr, align 2
  %conv = zext i16 %0 to i64
  %1 = load i16, ptr %a.addr, align 2
  %conv1 = zext i16 %1 to i64
  %call = call i64 @deposit64(i64 noundef %conv, i32 noundef 0, i32 noundef 15, i64 noundef %conv1)
  %conv2 = trunc i64 %call to i16
  ret i16 %conv2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fsgnj32(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %b.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = load i32, ptr %a.addr, align 4
  %conv1 = zext i32 %1 to i64
  %call = call i64 @deposit64(i64 noundef %conv, i32 noundef 0, i32 noundef 31, i64 noundef %conv1)
  %conv2 = trunc i64 %call to i32
  ret i32 %conv2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fsgnj64(i64 noundef %a, i64 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %b.addr, align 8
  %1 = load i64, ptr %a.addr, align 8
  %call = call i64 @deposit64(i64 noundef %0, i32 noundef 0, i32 noundef 63, i64 noundef %1)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @fsgnjn16(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %b.addr, align 2
  %conv = zext i16 %0 to i32
  %not = xor i32 %conv, -1
  %conv1 = sext i32 %not to i64
  %1 = load i16, ptr %a.addr, align 2
  %conv2 = zext i16 %1 to i64
  %call = call i64 @deposit64(i64 noundef %conv1, i32 noundef 0, i32 noundef 15, i64 noundef %conv2)
  %conv3 = trunc i64 %call to i16
  ret i16 %conv3
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fsgnjn32(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %b.addr, align 4
  %not = xor i32 %0, -1
  %conv = zext i32 %not to i64
  %1 = load i32, ptr %a.addr, align 4
  %conv1 = zext i32 %1 to i64
  %call = call i64 @deposit64(i64 noundef %conv, i32 noundef 0, i32 noundef 31, i64 noundef %conv1)
  %conv2 = trunc i64 %call to i32
  ret i32 %conv2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fsgnjn64(i64 noundef %a, i64 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %b.addr, align 8
  %not = xor i64 %0, -1
  %1 = load i64, ptr %a.addr, align 8
  %call = call i64 @deposit64(i64 noundef %not, i32 noundef 0, i32 noundef 63, i64 noundef %1)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @fsgnjx16(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store i16 %b, ptr %b.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %b.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, ptr %a.addr, align 2
  %conv1 = zext i16 %1 to i32
  %xor = xor i32 %conv, %conv1
  %conv2 = sext i32 %xor to i64
  %2 = load i16, ptr %a.addr, align 2
  %conv3 = zext i16 %2 to i64
  %call = call i64 @deposit64(i64 noundef %conv2, i32 noundef 0, i32 noundef 15, i64 noundef %conv3)
  %conv4 = trunc i64 %call to i16
  ret i16 %conv4
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @fsgnjx32(i32 noundef %a, i32 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %b.addr, align 4
  %1 = load i32, ptr %a.addr, align 4
  %xor = xor i32 %0, %1
  %conv = zext i32 %xor to i64
  %2 = load i32, ptr %a.addr, align 4
  %conv1 = zext i32 %2 to i64
  %call = call i64 @deposit64(i64 noundef %conv, i32 noundef 0, i32 noundef 31, i64 noundef %conv1)
  %conv2 = trunc i64 %call to i32
  ret i32 %conv2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @fsgnjx64(i64 noundef %a, i64 noundef %b, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i64, ptr %b.addr, align 8
  %1 = load i64, ptr %a.addr, align 8
  %xor = xor i64 %0, %1
  %2 = load i64, ptr %a.addr, align 8
  %call = call i64 @deposit64(i64 noundef %xor, i32 noundef 0, i32 noundef 63, i64 noundef %2)
  ret i64 %call
}

declare i32 @float16_compare_quiet(i16 noundef zeroext, i16 noundef zeroext, ptr noundef) #2

declare i32 @float32_compare_quiet(i32 noundef, i32 noundef, ptr noundef) #2

declare i32 @float64_compare_quiet(i64 noundef, i64 noundef, ptr noundef) #2

declare i32 @float16_compare(i16 noundef zeroext, i16 noundef zeroext, ptr noundef) #2

declare i32 @float32_compare(i32 noundef, i32 noundef, ptr noundef) #2

declare i32 @float64_compare(i64 noundef, i64 noundef, ptr noundef) #2

declare zeroext i16 @float16_to_uint16(i16 noundef zeroext, ptr noundef) #2

declare i32 @float32_to_uint32(i32 noundef, ptr noundef) #2

declare i64 @float64_to_uint64(i64 noundef, ptr noundef) #2

declare signext i16 @float16_to_int16(i16 noundef zeroext, ptr noundef) #2

declare i32 @float32_to_int32(i32 noundef, ptr noundef) #2

declare i64 @float64_to_int64(i64 noundef, ptr noundef) #2

declare zeroext i16 @uint16_to_float16(i16 noundef zeroext, ptr noundef) #2

declare i32 @uint32_to_float32(i32 noundef, ptr noundef) #2

declare i64 @uint64_to_float64(i64 noundef, ptr noundef) #2

declare zeroext i16 @int16_to_float16(i16 noundef signext, ptr noundef) #2

declare i32 @int32_to_float32(i32 noundef, ptr noundef) #2

declare i64 @int64_to_float64(i64 noundef, ptr noundef) #2

declare i32 @float16_to_uint32(i16 noundef zeroext, ptr noundef) #2

declare i64 @float32_to_uint64(i32 noundef, ptr noundef) #2

declare i32 @float16_to_int32(i16 noundef zeroext, ptr noundef) #2

declare i64 @float32_to_int64(i32 noundef, ptr noundef) #2

declare zeroext i16 @uint8_to_float16(i8 noundef zeroext, ptr noundef) #2

declare i32 @uint16_to_float32(i16 noundef zeroext, ptr noundef) #2

declare i64 @uint32_to_float64(i32 noundef, ptr noundef) #2

declare zeroext i16 @int8_to_float16(i8 noundef signext, ptr noundef) #2

declare i32 @int16_to_float32(i16 noundef signext, ptr noundef) #2

declare i64 @int32_to_float64(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @vfwcvtffv16(i16 noundef zeroext %a, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i16, align 2
  %s.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2
  store ptr %s, ptr %s.addr, align 8
  %0 = load i16, ptr %a.addr, align 2
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i32 @float16_to_float32(i16 noundef zeroext %0, i1 noundef zeroext true, ptr noundef %1)
  ret i32 %call
}

declare zeroext i8 @float16_to_uint8(i16 noundef zeroext, ptr noundef) #2

declare zeroext i16 @float32_to_uint16(i32 noundef, ptr noundef) #2

declare i32 @float64_to_uint32(i64 noundef, ptr noundef) #2

declare signext i8 @float16_to_int8(i16 noundef zeroext, ptr noundef) #2

declare signext i16 @float32_to_int16(i32 noundef, ptr noundef) #2

declare i32 @float64_to_int32(i64 noundef, ptr noundef) #2

declare zeroext i16 @uint32_to_float16(i32 noundef, ptr noundef) #2

declare i32 @uint64_to_float32(i64 noundef, ptr noundef) #2

declare zeroext i16 @int32_to_float16(i32 noundef, ptr noundef) #2

declare i32 @int64_to_float32(i64 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @vfncvtffv16(i32 noundef %a, ptr noundef %s) #0 {
entry:
  %a.addr = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  %1 = load ptr, ptr %s.addr, align 8
  %call = call zeroext i16 @float32_to_float16(i32 noundef %0, i1 noundef zeroext true, ptr noundef %1)
  ret i16 %call
}

declare zeroext i16 @float32_to_float16(i32 noundef, i1 noundef zeroext, ptr noundef) #2

declare i32 @float64_to_float32(i64 noundef, ptr noundef) #2

declare zeroext i16 @float32_to_bfloat16(i32 noundef, ptr noundef) #2

attributes #0 = { nounwind sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nocallback nofree nosync nounwind willreturn memory(none) }
attributes #2 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #7 = { noreturn nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
!86 = distinct !{!86, !6}
!87 = distinct !{!87, !6}
!88 = distinct !{!88, !6}
!89 = distinct !{!89, !6}
!90 = distinct !{!90, !6}
!91 = distinct !{!91, !6}
!92 = distinct !{!92, !6}
!93 = distinct !{!93, !6}
!94 = distinct !{!94, !6}
!95 = distinct !{!95, !6}
!96 = distinct !{!96, !6}
!97 = distinct !{!97, !6}
!98 = distinct !{!98, !6}
!99 = distinct !{!99, !6}
!100 = distinct !{!100, !6}
!101 = distinct !{!101, !6}
!102 = distinct !{!102, !6}
!103 = distinct !{!103, !6}
!104 = distinct !{!104, !6}
!105 = distinct !{!105, !6}
!106 = distinct !{!106, !6}
!107 = distinct !{!107, !6}
!108 = distinct !{!108, !6}
!109 = distinct !{!109, !6}
!110 = distinct !{!110, !6}
!111 = distinct !{!111, !6}
!112 = distinct !{!112, !6}
!113 = distinct !{!113, !6}
!114 = distinct !{!114, !6}
!115 = distinct !{!115, !6}
!116 = distinct !{!116, !6}
!117 = distinct !{!117, !6}
!118 = distinct !{!118, !6}
!119 = distinct !{!119, !6}
!120 = distinct !{!120, !6}
!121 = distinct !{!121, !6}
!122 = distinct !{!122, !6}
!123 = distinct !{!123, !6}
!124 = distinct !{!124, !6}
!125 = distinct !{!125, !6}
!126 = distinct !{!126, !6}
!127 = distinct !{!127, !6}
!128 = distinct !{!128, !6}
!129 = distinct !{!129, !6}
!130 = distinct !{!130, !6}
!131 = distinct !{!131, !6}
!132 = distinct !{!132, !6}
!133 = distinct !{!133, !6}
!134 = distinct !{!134, !6}
!135 = distinct !{!135, !6}
!136 = distinct !{!136, !6}
!137 = distinct !{!137, !6}
!138 = distinct !{!138, !6}
!139 = distinct !{!139, !6}
!140 = distinct !{!140, !6}
!141 = distinct !{!141, !6}
!142 = distinct !{!142, !6}
!143 = distinct !{!143, !6}
!144 = distinct !{!144, !6}
!145 = distinct !{!145, !6}
!146 = distinct !{!146, !6}
!147 = distinct !{!147, !6}
!148 = distinct !{!148, !6}
!149 = distinct !{!149, !6}
!150 = distinct !{!150, !6}
!151 = distinct !{!151, !6}
!152 = distinct !{!152, !6}
!153 = distinct !{!153, !6}
!154 = distinct !{!154, !6}
!155 = distinct !{!155, !6}
!156 = distinct !{!156, !6}
!157 = distinct !{!157, !6}
!158 = distinct !{!158, !6}
!159 = distinct !{!159, !6}
!160 = distinct !{!160, !6}
!161 = distinct !{!161, !6}
!162 = distinct !{!162, !6}
!163 = distinct !{!163, !6}
!164 = distinct !{!164, !6}
!165 = distinct !{!165, !6}
!166 = distinct !{!166, !6}
!167 = distinct !{!167, !6}
!168 = distinct !{!168, !6}
!169 = distinct !{!169, !6}
!170 = distinct !{!170, !6}
!171 = distinct !{!171, !6}
!172 = distinct !{!172, !6}
!173 = distinct !{!173, !6}
!174 = distinct !{!174, !6}
!175 = distinct !{!175, !6}
!176 = distinct !{!176, !6}
!177 = distinct !{!177, !6}
!178 = distinct !{!178, !6}
!179 = distinct !{!179, !6}
!180 = distinct !{!180, !6}
!181 = distinct !{!181, !6}
!182 = distinct !{!182, !6}
!183 = distinct !{!183, !6}
!184 = distinct !{!184, !6}
!185 = distinct !{!185, !6}
!186 = distinct !{!186, !6}
!187 = distinct !{!187, !6}
!188 = distinct !{!188, !6}
!189 = distinct !{!189, !6}
!190 = distinct !{!190, !6}
!191 = distinct !{!191, !6}
!192 = distinct !{!192, !6}
!193 = distinct !{!193, !6}
!194 = distinct !{!194, !6}
!195 = distinct !{!195, !6}
!196 = distinct !{!196, !6}
!197 = distinct !{!197, !6}
!198 = distinct !{!198, !6}
!199 = distinct !{!199, !6}
!200 = distinct !{!200, !6}
!201 = distinct !{!201, !6}
!202 = distinct !{!202, !6}
!203 = distinct !{!203, !6}
!204 = distinct !{!204, !6}
!205 = distinct !{!205, !6}
!206 = distinct !{!206, !6}
!207 = distinct !{!207, !6}
!208 = distinct !{!208, !6}
!209 = distinct !{!209, !6}
!210 = distinct !{!210, !6}
!211 = distinct !{!211, !6}
!212 = distinct !{!212, !6}
!213 = distinct !{!213, !6}
!214 = distinct !{!214, !6}
!215 = distinct !{!215, !6}
!216 = distinct !{!216, !6}
!217 = distinct !{!217, !6}
!218 = distinct !{!218, !6}
!219 = distinct !{!219, !6}
!220 = distinct !{!220, !6}
!221 = distinct !{!221, !6}
!222 = distinct !{!222, !6}
!223 = distinct !{!223, !6}
!224 = distinct !{!224, !6}
!225 = distinct !{!225, !6}
!226 = distinct !{!226, !6}
!227 = distinct !{!227, !6}
!228 = distinct !{!228, !6}
!229 = distinct !{!229, !6}
!230 = distinct !{!230, !6}
!231 = distinct !{!231, !6}
!232 = distinct !{!232, !6}
!233 = distinct !{!233, !6}
!234 = distinct !{!234, !6}
!235 = distinct !{!235, !6}
!236 = distinct !{!236, !6}
!237 = distinct !{!237, !6}
!238 = distinct !{!238, !6}
!239 = distinct !{!239, !6}
!240 = distinct !{!240, !6}
!241 = distinct !{!241, !6}
!242 = distinct !{!242, !6}
!243 = distinct !{!243, !6}
!244 = distinct !{!244, !6}
!245 = distinct !{!245, !6}
!246 = distinct !{!246, !6}
!247 = distinct !{!247, !6}
!248 = distinct !{!248, !6}
!249 = distinct !{!249, !6}
!250 = distinct !{!250, !6}
!251 = distinct !{!251, !6}
!252 = distinct !{!252, !6}
!253 = distinct !{!253, !6}
!254 = distinct !{!254, !6}
!255 = distinct !{!255, !6}
!256 = distinct !{!256, !6}
!257 = distinct !{!257, !6}
!258 = distinct !{!258, !6}
!259 = distinct !{!259, !6}
!260 = distinct !{!260, !6}
!261 = distinct !{!261, !6}
!262 = distinct !{!262, !6}
!263 = distinct !{!263, !6}
!264 = distinct !{!264, !6}
!265 = distinct !{!265, !6}
!266 = distinct !{!266, !6}
!267 = distinct !{!267, !6}
!268 = distinct !{!268, !6}
!269 = distinct !{!269, !6}
!270 = distinct !{!270, !6}
!271 = distinct !{!271, !6}
!272 = distinct !{!272, !6}
!273 = distinct !{!273, !6}
!274 = distinct !{!274, !6}
!275 = distinct !{!275, !6}
!276 = distinct !{!276, !6}
!277 = distinct !{!277, !6}
!278 = distinct !{!278, !6}
!279 = distinct !{!279, !6}
!280 = distinct !{!280, !6}
!281 = distinct !{!281, !6}
!282 = distinct !{!282, !6}
!283 = distinct !{!283, !6}
!284 = distinct !{!284, !6}
!285 = distinct !{!285, !6}
!286 = distinct !{!286, !6}
!287 = distinct !{!287, !6}
!288 = distinct !{!288, !6}
!289 = distinct !{!289, !6}
!290 = distinct !{!290, !6}
!291 = distinct !{!291, !6}
!292 = distinct !{!292, !6}
!293 = distinct !{!293, !6}
!294 = distinct !{!294, !6}
!295 = distinct !{!295, !6}
!296 = distinct !{!296, !6}
!297 = distinct !{!297, !6}
!298 = distinct !{!298, !6}
!299 = distinct !{!299, !6}
!300 = distinct !{!300, !6}
!301 = distinct !{!301, !6}
!302 = distinct !{!302, !6}
!303 = distinct !{!303, !6}
!304 = distinct !{!304, !6}
!305 = distinct !{!305, !6}
!306 = distinct !{!306, !6}
!307 = distinct !{!307, !6}
!308 = distinct !{!308, !6}
!309 = distinct !{!309, !6}
!310 = distinct !{!310, !6}
!311 = distinct !{!311, !6}
!312 = distinct !{!312, !6}
!313 = distinct !{!313, !6}
!314 = distinct !{!314, !6}
!315 = distinct !{!315, !6}
!316 = distinct !{!316, !6}
!317 = distinct !{!317, !6}
!318 = distinct !{!318, !6}
!319 = distinct !{!319, !6}
!320 = distinct !{!320, !6}
!321 = distinct !{!321, !6}
!322 = distinct !{!322, !6}
!323 = distinct !{!323, !6}
!324 = distinct !{!324, !6}
!325 = distinct !{!325, !6}
!326 = distinct !{!326, !6}
!327 = distinct !{!327, !6}
!328 = distinct !{!328, !6}
!329 = distinct !{!329, !6}
!330 = distinct !{!330, !6}
!331 = distinct !{!331, !6}
!332 = distinct !{!332, !6}
!333 = distinct !{!333, !6}
!334 = distinct !{!334, !6}
!335 = distinct !{!335, !6}
!336 = distinct !{!336, !6}
!337 = distinct !{!337, !6}
!338 = distinct !{!338, !6}
!339 = distinct !{!339, !6}
!340 = distinct !{!340, !6}
!341 = distinct !{!341, !6}
!342 = distinct !{!342, !6}
!343 = distinct !{!343, !6}
!344 = distinct !{!344, !6}
!345 = distinct !{!345, !6}
!346 = distinct !{!346, !6}
!347 = distinct !{!347, !6}
!348 = distinct !{!348, !6}
!349 = distinct !{!349, !6}
!350 = distinct !{!350, !6}
!351 = distinct !{!351, !6}
!352 = distinct !{!352, !6}
!353 = distinct !{!353, !6}
!354 = distinct !{!354, !6}
!355 = distinct !{!355, !6}
!356 = distinct !{!356, !6}
!357 = distinct !{!357, !6}
!358 = distinct !{!358, !6}
!359 = distinct !{!359, !6}
!360 = distinct !{!360, !6}
!361 = distinct !{!361, !6}
!362 = distinct !{!362, !6}
!363 = distinct !{!363, !6}
!364 = distinct !{!364, !6}
!365 = distinct !{!365, !6}
!366 = distinct !{!366, !6}
!367 = distinct !{!367, !6}
!368 = distinct !{!368, !6}
!369 = distinct !{!369, !6}
!370 = distinct !{!370, !6}
!371 = distinct !{!371, !6}
!372 = distinct !{!372, !6}
!373 = distinct !{!373, !6}
!374 = distinct !{!374, !6}
!375 = distinct !{!375, !6}
!376 = distinct !{!376, !6}
!377 = distinct !{!377, !6}
!378 = distinct !{!378, !6}
!379 = distinct !{!379, !6}
!380 = distinct !{!380, !6}
!381 = distinct !{!381, !6}
!382 = distinct !{!382, !6}
!383 = distinct !{!383, !6}
!384 = distinct !{!384, !6}
!385 = distinct !{!385, !6}
!386 = distinct !{!386, !6}
!387 = distinct !{!387, !6}
!388 = distinct !{!388, !6}
!389 = distinct !{!389, !6}
!390 = distinct !{!390, !6}
!391 = distinct !{!391, !6}
!392 = distinct !{!392, !6}
!393 = distinct !{!393, !6}
!394 = distinct !{!394, !6}
!395 = distinct !{!395, !6}
!396 = distinct !{!396, !6}
!397 = distinct !{!397, !6}
!398 = distinct !{!398, !6}
!399 = distinct !{!399, !6}
!400 = distinct !{!400, !6}
!401 = distinct !{!401, !6}
!402 = distinct !{!402, !6}
!403 = distinct !{!403, !6}
!404 = distinct !{!404, !6}
!405 = distinct !{!405, !6}
!406 = distinct !{!406, !6}
!407 = distinct !{!407, !6}
!408 = distinct !{!408, !6}
!409 = distinct !{!409, !6}
!410 = distinct !{!410, !6}
!411 = distinct !{!411, !6}
!412 = distinct !{!412, !6}
!413 = distinct !{!413, !6}
!414 = distinct !{!414, !6}
!415 = distinct !{!415, !6}
!416 = distinct !{!416, !6}
!417 = distinct !{!417, !6}
!418 = distinct !{!418, !6}
!419 = distinct !{!419, !6}
!420 = distinct !{!420, !6}
!421 = distinct !{!421, !6}
!422 = distinct !{!422, !6}
!423 = distinct !{!423, !6}
!424 = distinct !{!424, !6}
!425 = distinct !{!425, !6}
!426 = distinct !{!426, !6}
!427 = distinct !{!427, !6}
!428 = distinct !{!428, !6}
!429 = distinct !{!429, !6}
!430 = distinct !{!430, !6}
!431 = distinct !{!431, !6}
!432 = distinct !{!432, !6}
!433 = distinct !{!433, !6}
!434 = distinct !{!434, !6}
!435 = distinct !{!435, !6}
!436 = distinct !{!436, !6}
!437 = distinct !{!437, !6}
!438 = distinct !{!438, !6}
!439 = distinct !{!439, !6}
!440 = distinct !{!440, !6}
!441 = distinct !{!441, !6}
!442 = distinct !{!442, !6}
!443 = distinct !{!443, !6}
!444 = distinct !{!444, !6}
!445 = distinct !{!445, !6}
!446 = distinct !{!446, !6}
!447 = distinct !{!447, !6}
!448 = distinct !{!448, !6}
!449 = distinct !{!449, !6}
!450 = distinct !{!450, !6}
!451 = distinct !{!451, !6}
!452 = distinct !{!452, !6}
!453 = distinct !{!453, !6}
!454 = distinct !{!454, !6}
!455 = distinct !{!455, !6}
!456 = distinct !{!456, !6}
!457 = distinct !{!457, !6}
!458 = distinct !{!458, !6}
!459 = distinct !{!459, !6}
!460 = distinct !{!460, !6}
!461 = distinct !{!461, !6}
!462 = distinct !{!462, !6}
!463 = distinct !{!463, !6}
!464 = distinct !{!464, !6}
!465 = distinct !{!465, !6}
!466 = distinct !{!466, !6}
!467 = distinct !{!467, !6}
!468 = distinct !{!468, !6}
!469 = distinct !{!469, !6}
!470 = distinct !{!470, !6}
!471 = distinct !{!471, !6}
!472 = distinct !{!472, !6}
!473 = distinct !{!473, !6}
!474 = distinct !{!474, !6}
!475 = distinct !{!475, !6}
!476 = distinct !{!476, !6}
!477 = distinct !{!477, !6}
!478 = distinct !{!478, !6}
!479 = distinct !{!479, !6}
!480 = distinct !{!480, !6}
!481 = distinct !{!481, !6}
!482 = distinct !{!482, !6}
!483 = distinct !{!483, !6}
!484 = distinct !{!484, !6}
!485 = distinct !{!485, !6}
!486 = distinct !{!486, !6}
!487 = distinct !{!487, !6}
!488 = distinct !{!488, !6}
!489 = distinct !{!489, !6}
!490 = distinct !{!490, !6}
!491 = distinct !{!491, !6}
!492 = distinct !{!492, !6}
!493 = distinct !{!493, !6}
!494 = distinct !{!494, !6}
!495 = distinct !{!495, !6}
!496 = distinct !{!496, !6}
!497 = distinct !{!497, !6}
!498 = distinct !{!498, !6}
!499 = distinct !{!499, !6}
!500 = distinct !{!500, !6}
!501 = distinct !{!501, !6}
!502 = distinct !{!502, !6}
!503 = distinct !{!503, !6}
!504 = distinct !{!504, !6}
!505 = distinct !{!505, !6}
!506 = distinct !{!506, !6}
!507 = distinct !{!507, !6}
!508 = distinct !{!508, !6}
!509 = distinct !{!509, !6}
!510 = distinct !{!510, !6}
!511 = distinct !{!511, !6}
!512 = distinct !{!512, !6}
!513 = distinct !{!513, !6}
!514 = distinct !{!514, !6}
!515 = distinct !{!515, !6}
!516 = distinct !{!516, !6}
!517 = distinct !{!517, !6}
!518 = distinct !{!518, !6}
!519 = distinct !{!519, !6}
!520 = distinct !{!520, !6}
!521 = distinct !{!521, !6}
!522 = distinct !{!522, !6}
!523 = distinct !{!523, !6}
!524 = distinct !{!524, !6}
!525 = distinct !{!525, !6}
!526 = distinct !{!526, !6}
!527 = distinct !{!527, !6}
!528 = distinct !{!528, !6}
!529 = distinct !{!529, !6}
!530 = distinct !{!530, !6}
!531 = distinct !{!531, !6}
!532 = distinct !{!532, !6}
!533 = distinct !{!533, !6}
!534 = distinct !{!534, !6}
!535 = distinct !{!535, !6}
!536 = distinct !{!536, !6}
!537 = distinct !{!537, !6}
!538 = distinct !{!538, !6}
!539 = distinct !{!539, !6}
!540 = distinct !{!540, !6}
!541 = distinct !{!541, !6}
!542 = distinct !{!542, !6}
!543 = distinct !{!543, !6}
!544 = distinct !{!544, !6}
!545 = distinct !{!545, !6}
!546 = distinct !{!546, !6}
!547 = distinct !{!547, !6}
!548 = distinct !{!548, !6}
!549 = distinct !{!549, !6}
!550 = distinct !{!550, !6}
!551 = distinct !{!551, !6}
!552 = distinct !{!552, !6}
!553 = distinct !{!553, !6}
!554 = distinct !{!554, !6}
!555 = distinct !{!555, !6}
!556 = distinct !{!556, !6}
!557 = distinct !{!557, !6}
!558 = distinct !{!558, !6}
!559 = distinct !{!559, !6}
!560 = distinct !{!560, !6}
!561 = distinct !{!561, !6}
!562 = distinct !{!562, !6}
!563 = distinct !{!563, !6}
!564 = distinct !{!564, !6}
!565 = distinct !{!565, !6}
!566 = distinct !{!566, !6}
!567 = distinct !{!567, !6}
!568 = distinct !{!568, !6}
!569 = distinct !{!569, !6}
!570 = distinct !{!570, !6}
!571 = distinct !{!571, !6}
!572 = distinct !{!572, !6}
!573 = distinct !{!573, !6}
!574 = distinct !{!574, !6}
!575 = distinct !{!575, !6}
!576 = distinct !{!576, !6}
!577 = distinct !{!577, !6}
!578 = distinct !{!578, !6}
!579 = distinct !{!579, !6}
!580 = distinct !{!580, !6}
!581 = distinct !{!581, !6}
!582 = distinct !{!582, !6}
!583 = distinct !{!583, !6}
!584 = distinct !{!584, !6}
!585 = distinct !{!585, !6}
!586 = distinct !{!586, !6}
!587 = distinct !{!587, !6}
!588 = distinct !{!588, !6}
!589 = distinct !{!589, !6}
!590 = distinct !{!590, !6}
!591 = distinct !{!591, !6}
!592 = distinct !{!592, !6}
!593 = distinct !{!593, !6}
!594 = distinct !{!594, !6}
!595 = distinct !{!595, !6}
!596 = distinct !{!596, !6}
!597 = distinct !{!597, !6}
!598 = distinct !{!598, !6}
!599 = distinct !{!599, !6}
!600 = distinct !{!600, !6}
!601 = distinct !{!601, !6}
!602 = distinct !{!602, !6}
!603 = distinct !{!603, !6}
!604 = distinct !{!604, !6}
!605 = distinct !{!605, !6}
!606 = distinct !{!606, !6}
!607 = distinct !{!607, !6}
!608 = distinct !{!608, !6}
!609 = distinct !{!609, !6}
!610 = distinct !{!610, !6}
!611 = distinct !{!611, !6}
!612 = distinct !{!612, !6}
!613 = distinct !{!613, !6}
!614 = distinct !{!614, !6}
!615 = distinct !{!615, !6}
!616 = distinct !{!616, !6}
!617 = distinct !{!617, !6}
!618 = distinct !{!618, !6}
!619 = distinct !{!619, !6}
!620 = distinct !{!620, !6}
!621 = distinct !{!621, !6}
!622 = distinct !{!622, !6}
!623 = distinct !{!623, !6}
!624 = distinct !{!624, !6}
!625 = distinct !{!625, !6}
!626 = distinct !{!626, !6}
!627 = distinct !{!627, !6}
!628 = distinct !{!628, !6}
