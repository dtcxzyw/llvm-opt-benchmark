target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.IOCTLEntry = type { i32, i32, ptr, i32, ptr, [5 x i32] }
%struct.StructEntry = type { ptr, i32, [2 x ptr], [2 x ptr], ptr, [2 x i32], [2 x i32], ptr }
%struct.fake_open = type { ptr, ptr, ptr }
%struct.bitmask_transtbl = type { i32, i32, i32, i32 }
%struct.MapInfo = type { %struct.IntervalTreeNode, i8, i8, i8, i8, i64, i64, i64, ptr }
%struct.IntervalTreeNode = type { %struct.RBNode, i64, i64, i64 }
%struct.RBNode = type { i64, ptr, ptr }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { ptr, ptr }
%union.CPUTailQ = type { %struct.QTailQLink }
%struct.QTailQLink = type { ptr, ptr }
%struct.TargetFdTrans = type { ptr, ptr, ptr }
%struct.QemuMutex = type { %union.pthread_mutex_t, i8 }
%struct.CPUState = type { %struct.DeviceState, ptr, i32, i32, ptr, i32, i8, i8, ptr, i8, i8, i8, i8, i8, i8, i8, i8, i32, i32, i32, i32, i64, i64, i64, [1 x %struct.__jmp_buf_tag], %struct.QemuMutex, %struct.anon.5, ptr, i32, ptr, ptr, ptr, ptr, i32, i32, %union.anon.6, %union.anon.7, %union.anon.8, ptr, ptr, i64, i32, ptr, ptr, ptr, i32, i64, i32, %struct.QemuLockCnt, [1 x i64], ptr, i32, i32, i32, i32, i32, ptr, i8, i8, i64, i8, i8, ptr, [8 x i8], [0 x i8], %struct.CPUNegativeOffsetState }
%struct.DeviceState = type { %struct.Object, ptr, ptr, i8, i8, i64, ptr, i32, i8, ptr, %struct.NamedGPIOListHead, %struct.NamedClockListHead, %struct.BusStateHead, i32, i32, i32, %struct.ResettableState, ptr, %struct.MemReentrancyGuard }
%struct.Object = type { ptr, ptr, ptr, i32, ptr }
%struct.NamedGPIOListHead = type { ptr }
%struct.NamedClockListHead = type { ptr }
%struct.BusStateHead = type { ptr }
%struct.ResettableState = type { i32, i8, i8 }
%struct.MemReentrancyGuard = type { i8 }
%struct.__jmp_buf_tag = type { [8 x i64], i32, %struct.__sigset_t }
%struct.__sigset_t = type { [16 x i64] }
%struct.anon.5 = type { ptr, ptr }
%union.anon.6 = type { %struct.QTailQLink }
%union.anon.7 = type { %struct.QTailQLink }
%union.anon.8 = type { %struct.QTailQLink }
%struct.QemuLockCnt = type { i32 }
%struct.CPUNegativeOffsetState = type { %struct.CPUTLB, %union.IcountDecr, i8, [11 x i8] }
%struct.CPUTLB = type { %struct.CPUTLBCommon, [16 x %struct.CPUTLBDesc], [16 x %struct.CPUTLBDescFast] }
%struct.CPUTLBCommon = type { %struct.QemuSpin, i16, i64, i64, i64 }
%struct.QemuSpin = type { i32 }
%struct.CPUTLBDesc = type { i64, i64, i64, i64, i64, i64, [8 x %union.CPUTLBEntry], [8 x %struct.CPUTLBEntryFull], ptr }
%union.CPUTLBEntry = type { %struct.anon.9 }
%struct.anon.9 = type { i64, i64, i64, i64 }
%struct.CPUTLBEntryFull = type { i64, i64, %struct.MemTxAttrs, i8, i8, [3 x i8], %union.anon.10 }
%struct.MemTxAttrs = type { i32 }
%union.anon.10 = type { %struct.anon.11 }
%struct.anon.11 = type { i8, i8, i8 }
%struct.CPUTLBDescFast = type { i64, ptr }
%union.IcountDecr = type { i32 }
%struct.TaskState = type { i32, i32, i64, i64, i64, i64, i32, ptr, ptr, %struct.emulated_sigtable, [64 x %struct.emulated_sigtable], %struct.__sigset_t, %struct.__sigset_t, i32, i32, %struct.target_sigaltstack, i64 }
%struct.emulated_sigtable = type { i32, %struct.target_siginfo }
%struct.target_siginfo = type { i32, i32, i32, %union.anon }
%union.anon = type { %struct.anon.2, [80 x i8] }
%struct.anon.2 = type { i32, i32, i32, i64, i64 }
%struct.target_sigaltstack = type { i64, i32, i64 }
%struct.blkpg_partition = type { i64, i64, i32, [64 x i8], [64 x i8] }
%struct.blkpg_ioctl_arg = type { i32, i32, i32, ptr }
%struct.fiemap = type { i64, i64, i32, i32, i32, i32, [0 x %struct.fiemap_extent] }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.live_urb = type { i64, i64, ptr, %struct.usbdevfs_urb }
%struct.usbdevfs_urb = type { i8, i8, i32, i32, ptr, i32, i32, i32, %union.anon.13, i32, i32, ptr, [0 x %struct.usbdevfs_iso_packet_desc] }
%union.anon.13 = type { i32 }
%struct.usbdevfs_iso_packet_desc = type { i32, i32, i32 }
%struct.ifconf = type { i32, %union.anon.14 }
%union.anon.14 = type { ptr }
%struct.timeval = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.dm_ioctl = type { [3 x i32], i32, i32, i32, i32, i32, i32, i32, i64, [128 x i8], [129 x i8], [7 x i8] }
%struct.dm_target_spec = type { i64, i64, i32, i32, [16 x i8] }
%struct.dm_name_list = type { i64, i32, [0 x i8] }
%struct.dm_target_versions = type { i32, [3 x i32], [0 x i8] }
%struct.tun_filter = type { i16, i16, [0 x [6 x i8]] }
%struct.linux_binprm = type { [1024 x i8], %struct.ImageSource, i64, i32, i32, i32, i32, ptr, ptr, ptr, ptr, [8 x i8] }
%struct.ImageSource = type { ptr, i32, i32 }
%struct.image_info = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i8, i64, i64, i64, i16, ptr, i64, i64, i64, ptr, i32 }
%struct._GString = type { ptr, i64, i64 }
%struct.RISCVCPUConfig = type { i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i32, i64, i64, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i32, ptr, ptr, ptr, ptr, i16, i16, i16, i16, i8, i8, i8, i8, i8 }
%struct.CPUArchState = type { [32 x i64], [32 x i64], [512 x i64], i64, i64, i64, i64, i64, i8, i64, i64, i64, [32 x i64], i64, %struct.float_status, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, i32, i64, i64, i32, i64, i64, ptr, ptr, i8, i64, i64, [8 x i8] }
%struct.float_status = type { i16, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.stat = type { i64, i64, i64, i32, i32, i32, i32, i64, i64, i64, i64, %struct.timespec, %struct.timespec, %struct.timespec, [3 x i64] }
%struct.statfs = type { i64, i64, i64, i64, i64, i64, i64, %struct.__fsid_t, i64, i64, i64, [4 x i64] }
%struct.__fsid_t = type { [2 x i32] }
%struct.siginfo_t = type { i32, i32, i32, i32, %union.anon.15 }
%union.anon.15 = type { %struct.anon.19, [80 x i8] }
%struct.anon.19 = type { i32, i32, i32, i64, i64 }
%struct.tms = type { i64, i64, i64, i64 }
%struct.rlimit = type { i64, i64 }
%struct.rusage = type { %struct.timeval, %struct.timeval, %union.anon.25, %union.anon.26, %union.anon.27, %union.anon.28, %union.anon.29, %union.anon.30, %union.anon.31, %union.anon.32, %union.anon.33, %union.anon.34, %union.anon.35, %union.anon.36, %union.anon.37, %union.anon.38 }
%union.anon.25 = type { i64 }
%union.anon.26 = type { i64 }
%union.anon.27 = type { i64 }
%union.anon.28 = type { i64 }
%union.anon.29 = type { i64 }
%union.anon.30 = type { i64 }
%union.anon.31 = type { i64 }
%union.anon.32 = type { i64 }
%union.anon.33 = type { i64 }
%union.anon.34 = type { i64 }
%union.anon.35 = type { i64 }
%union.anon.36 = type { i64 }
%union.anon.37 = type { i64 }
%union.anon.38 = type { i64 }
%struct.timezone = type { i32, i32 }
%struct.itimerval = type { %struct.timeval, %struct.timeval }
%struct.sysinfo = type { i64, [3 x i64], i64, i64, i64, i64, i64, i64, i16, i16, i64, i64, i32, [0 x i8] }
%struct.timex = type { i32, i64, i64, i64, i64, i32, i64, i64, i64, %struct.timeval, i64, i64, i64, i32, i64, i64, i64, i64, i64, i32, [44 x i8] }
%struct.sched_param = type { i32 }
%struct.sched_attr = type { i32, i32, i64, i32, i32, i64, i64, i64, i32, i32 }
%struct.__user_cap_header_struct = type { i32, i32 }
%struct.__user_cap_data_struct = type { i32, i32, i32 }
%struct.target_statx = type { i32, i32, i64, i32, i32, i32, i16, [1 x i16], i64, i64, i64, i64, %struct.target_statx_timestamp, %struct.target_statx_timestamp, %struct.target_statx_timestamp, %struct.target_statx_timestamp, i32, i32, i32, i32, [14 x i64] }
%struct.target_statx_timestamp = type { i64, i32, i32 }
%struct.mq_attr = type { i64, i64, i64, i64, [4 x i64] }
%struct.epoll_event = type <{ i32, %union.epoll_data }>
%union.epoll_data = type { ptr }
%struct.host_rlimit64 = type { i64, i64 }
%struct.sigevent = type { %union.sigval, i32, i32, %union.anon.39 }
%union.sigval = type { ptr }
%union.anon.39 = type { %struct.anon.40, [32 x i8] }
%struct.anon.40 = type { ptr, ptr }
%struct.itimerspec = type { %struct.timespec, %struct.timespec }
%struct.anon.16 = type { i32, i32 }
%struct.target_tms = type { i64, i64, i64, i64 }
%struct.target_rlimit = type { i64, i64 }
%struct.target_statfs = type { i64, i64, i64, i64, i64, i64, i64, %struct.target_fsid_t, i64, i64, i64, [4 x i64] }
%struct.target_fsid_t = type { [2 x i32] }
%struct.target_stat = type { i64, i64, i32, i32, i32, i32, i64, i64, i64, i32, i32, i64, i64, i64, i64, i64, i64, i64, i32, i32 }
%struct.target_sysinfo = type { i64, [3 x i64], i64, i64, i64, i64, i64, i64, i16, i16, i64, i64, i32, [0 x i8] }
%struct.new_utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.target_sched_param = type { i32 }
%struct.target_sched_attr = type { i32, i32, i64, i32, i32, i64, i64, i64, i32, i32 }
%struct.target_user_cap_header = type { i32, i32 }
%struct.target_user_cap_data = type { i32, i32, i32 }
%struct.target_epoll_event = type { i32, %union.target_epoll_data }
%union.target_epoll_data = type { i64 }
%struct.target_rlimit64 = type { i64, i64 }
%struct.target_timeval = type { i64, i64 }
%struct.target__kernel_sock_timeval = type { i64, i64 }
%struct.target_timespec = type { i64, i64 }
%struct.target__kernel_timespec = type { i64, i64 }
%struct.target_drm_version = type { i32, i32, i32, i64, i64, i64, i64, i64, i64 }
%struct.drm_version = type { i32, i32, i32, i64, ptr, i64, ptr, i64, ptr }
%struct.target_drm_i915_getparam = type { i32, i64 }
%struct.drm_i915_getparam = type { i32, ptr }
%struct.host_termios = type { i32, i32, i32, i32, i8, [19 x i8] }
%struct.target_termios = type { i32, i32, i32, i32, i8, [19 x i8] }
%struct.open_self_maps_data = type { ptr, ptr, i32, i8 }
%struct.ArchCPU = type { %struct.CPUState, %struct.CPUArchState, ptr, ptr, %struct.RISCVCPUConfig, ptr, i32, ptr }
%struct.QemuLockable = type { ptr, ptr, ptr }
%struct.file_handle = type { i32, i32, [0 x i8] }
%struct.flock64 = type { i16, i16, i64, i64, i32 }
%struct.f_owner_ex = type { i32, i32 }
%struct.target_f_owner_ex = type { i32, i32 }
%struct.target_rusage = type { %struct.target_timeval, %struct.target_timeval, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.target_timezone = type { i32, i32 }
%struct.fd_set = type { [16 x i64] }
%struct.anon.41 = type { ptr, i64 }
%union.__CONST_SOCKADDR_ARG = type { ptr }
%union.__SOCKADDR_ARG = type { ptr }
%struct.ucred = type { i32, i32, i32 }
%struct.linger = type { i32, i32 }
%struct.target_ucred = type { i32, i32, i32 }
%struct.target_linger = type { i32, i32 }
%struct.target_mmsghdr = type { %struct.target_msghdr, i32 }
%struct.target_msghdr = type { i64, i32, i64, i64, i64, i64, i32 }
%struct.in6_pktinfo = type { %struct.in6_addr, i32 }
%struct.in6_addr = type { %union.anon.42 }
%union.anon.42 = type { [4 x i32] }
%struct.ipv6_mreq = type { %struct.in6_addr, i32 }
%struct.icmp6_filter = type { [8 x i32] }
%struct.sock_fprog = type { i16, ptr }
%struct.target_sock_fprog = type { i16, i64 }
%struct.target_sock_filter = type { i16, i8, i8, i32 }
%struct.sock_filter = type { i16, i8, i8, i32 }
%union.target_semun = type { i64 }
%union.semun = type { ptr }
%struct.semid_ds = type { %struct.ipc_perm, i64, i64, i64, i64, i64, i64, i64 }
%struct.ipc_perm = type { i32, i32, i32, i32, i32, i32, i16, i16, i64, i64 }
%struct.seminfo = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.msqid_ds = type { %struct.ipc_perm, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.msginfo = type { i32, i32, i32, i32, i32, i32, i32, i16 }
%struct.target_msgbuf = type { i64, [1 x i8] }
%struct.msgbuf = type { i64, [1 x i8] }
%struct.shmid_ds = type { %struct.ipc_perm, i64, i64, i64, i64, i32, i32, i64, i64, i64 }
%struct.shminfo = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.shm_info = type { i32, i64, i64, i64, i64, i64 }
%struct.new_thread_info = type { ptr, %union.pthread_mutex_t, %union.pthread_cond_t, i64, i32, i64, i64, %struct.__sigset_t }
%union.pthread_cond_t = type { %struct.__pthread_cond_s }
%struct.__pthread_cond_s = type { %union.__atomic_wide_counter, %union.__atomic_wide_counter, [2 x i32], [2 x i32], i32, i32, [2 x i32] }
%union.__atomic_wide_counter = type { i64 }
%union.pthread_attr_t = type { i64, [48 x i8] }
%struct.target_timex = type { i32, i64, i64, i64, i64, i32, i64, i64, i64, %struct.target_timeval, i64, i64, i64, i32, i64, i64, i64, i64, i64, i32, [44 x i8] }
%struct.linux_dirent64 = type { i64, i64, i16, i8, [0 x i8] }
%struct.target_dirent64 = type { i64, i64, i16, i8, [0 x i8] }
%struct.target_pollfd = type { i32, i16, i16 }
%struct.pollfd = type { i32, i16, i16 }
%struct.target_iovec = type { i64, i64 }
%struct.iovec = type { ptr, i64 }
%struct.target_mq_attr = type { i64, i64, i64, i64 }
%struct.target_sigevent = type { %union.target_sigval, i32, i32, %union.anon.45 }
%union.target_sigval = type { i64 }
%union.anon.45 = type { %struct.anon.46, [32 x i8] }
%struct.anon.46 = type { i64, i64 }
%struct.target_flock = type { i16, i16, i64, i64, i32 }
%struct.target_flock64 = type { i16, i16, i64, i64, i32 }
%struct.sockaddr = type { i16, [14 x i8] }
%struct.target_sockaddr = type { i16, [14 x i8] }
%struct.target_sockaddr_nl = type { i16, i16, i32, i32 }
%struct.sockaddr_ll = type { i16, i16, i32, i16, i8, i8, [8 x i8] }
%struct.target_sockaddr_in6 = type { i16, i16, i32, %struct.in6_addr, i32 }
%struct.sockaddr_nl = type { i16, i16, i32, i32 }
%struct.target_sockaddr_ll = type { i16, i16, i32, i16, i8, i8, [8 x i8] }
%struct.sockaddr_in6 = type { i16, i16, i32, %struct.in6_addr, i32 }
%struct.msghdr = type { ptr, i32, ptr, i64, ptr, i64, i32 }
%struct.cmsghdr = type { i64, i32, i32, [0 x i8] }
%struct.target_cmsghdr = type { i64, i32, i32 }
%struct.errhdr_t = type { %struct.sock_extended_err, %struct.sockaddr_in }
%struct.sock_extended_err = type { i32, i8, i8, i8, i8, i32, %union.anon.43 }
%union.anon.43 = type { i32 }
%struct.sockaddr_in = type { i16, i16, %struct.in_addr, [8 x i8] }
%struct.in_addr = type { i32 }
%struct.errhdr6_t = type { %struct.sock_extended_err, %struct.sockaddr_in6 }
%struct.target_ip_mreqn = type { %struct.target_in_addr, %struct.target_in_addr, i64 }
%struct.target_in_addr = type { i32 }
%struct.ip_mreqn = type { %struct.in_addr, %struct.in_addr, i32 }
%struct.target_sembuf = type { i16, i16, i16 }
%struct.sembuf = type { i16, i16, i16 }
%struct.target_semid64_ds = type { %struct.target_ipc_perm, i64, i64, i64, i64, i64 }
%struct.target_ipc_perm = type { i32, i32, i32, i32, i32, i16, i16, i16, i16, i64, i64 }
%struct.target_seminfo = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.target_msqid_ds = type { %struct.target_ipc_perm, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.target_msginfo = type { i32, i32, i32, i32, i32, i32, i32, i16 }
%struct.target_shmid_ds = type { %struct.target_ipc_perm, i64, i64, i64, i64, i32, i32, i64, i64, i64 }
%struct.target_shminfo = type { i64, i64, i64, i64, i64 }
%struct.target_shm_info = type { i32, i64, i64, i64, i64, i64 }
%struct.riscv_hwprobe = type { i64, i64 }

@.str = private unnamed_addr constant [16 x i8] c"To be restarted\00", align 1
@.str.1 = private unnamed_addr constant [31 x i8] c"Successful exit from sigreturn\00", align 1
@target_brk = internal global i64 0, align 8
@initial_target_brk = internal global i64 0, align 8
@.str.2 = private unnamed_addr constant [7 x i8] c"TCGETS\00", align 1
@.str.3 = private unnamed_addr constant [7 x i8] c"TCSETS\00", align 1
@.str.4 = private unnamed_addr constant [8 x i8] c"TCSETSF\00", align 1
@.str.5 = private unnamed_addr constant [8 x i8] c"TCSETSW\00", align 1
@.str.6 = private unnamed_addr constant [11 x i8] c"TIOCGWINSZ\00", align 1
@.str.7 = private unnamed_addr constant [11 x i8] c"TIOCSWINSZ\00", align 1
@.str.8 = private unnamed_addr constant [9 x i8] c"FIONREAD\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c"TCGETA\00", align 1
@.str.10 = private unnamed_addr constant [7 x i8] c"TCSETA\00", align 1
@.str.11 = private unnamed_addr constant [8 x i8] c"TCSETAW\00", align 1
@.str.12 = private unnamed_addr constant [8 x i8] c"TCSETAF\00", align 1
@.str.13 = private unnamed_addr constant [7 x i8] c"TCSBRK\00", align 1
@.str.14 = private unnamed_addr constant [8 x i8] c"TCSBRKP\00", align 1
@.str.15 = private unnamed_addr constant [7 x i8] c"TCXONC\00", align 1
@.str.16 = private unnamed_addr constant [7 x i8] c"TCFLSH\00", align 1
@.str.17 = private unnamed_addr constant [9 x i8] c"TIOCEXCL\00", align 1
@.str.18 = private unnamed_addr constant [9 x i8] c"TIOCNXCL\00", align 1
@.str.19 = private unnamed_addr constant [10 x i8] c"TIOCSCTTY\00", align 1
@.str.20 = private unnamed_addr constant [10 x i8] c"TIOCGPGRP\00", align 1
@.str.21 = private unnamed_addr constant [10 x i8] c"TIOCSPGRP\00", align 1
@.str.22 = private unnamed_addr constant [9 x i8] c"TIOCGSID\00", align 1
@.str.23 = private unnamed_addr constant [9 x i8] c"TIOCOUTQ\00", align 1
@.str.24 = private unnamed_addr constant [8 x i8] c"TIOCSTI\00", align 1
@.str.25 = private unnamed_addr constant [9 x i8] c"TIOCMGET\00", align 1
@.str.26 = private unnamed_addr constant [9 x i8] c"TIOCMBIS\00", align 1
@.str.27 = private unnamed_addr constant [9 x i8] c"TIOCMBIC\00", align 1
@.str.28 = private unnamed_addr constant [9 x i8] c"TIOCMSET\00", align 1
@.str.29 = private unnamed_addr constant [13 x i8] c"TIOCGSOFTCAR\00", align 1
@.str.30 = private unnamed_addr constant [13 x i8] c"TIOCSSOFTCAR\00", align 1
@.str.31 = private unnamed_addr constant [10 x i8] c"TIOCLINUX\00", align 1
@.str.32 = private unnamed_addr constant [9 x i8] c"TIOCCONS\00", align 1
@.str.33 = private unnamed_addr constant [12 x i8] c"TIOCGSERIAL\00", align 1
@.str.34 = private unnamed_addr constant [12 x i8] c"TIOCSSERIAL\00", align 1
@.str.35 = private unnamed_addr constant [8 x i8] c"TIOCPKT\00", align 1
@.str.36 = private unnamed_addr constant [8 x i8] c"FIONBIO\00", align 1
@.str.37 = private unnamed_addr constant [10 x i8] c"TIOCNOTTY\00", align 1
@.str.38 = private unnamed_addr constant [9 x i8] c"TIOCGETD\00", align 1
@.str.39 = private unnamed_addr constant [9 x i8] c"TIOCSETD\00", align 1
@.str.40 = private unnamed_addr constant [9 x i8] c"TIOCGPTN\00", align 1
@.str.41 = private unnamed_addr constant [11 x i8] c"TIOCSPTLCK\00", align 1
@.str.42 = private unnamed_addr constant [12 x i8] c"TIOCGPTPEER\00", align 1
@.str.43 = private unnamed_addr constant [8 x i8] c"FIOCLEX\00", align 1
@.str.44 = private unnamed_addr constant [9 x i8] c"FIONCLEX\00", align 1
@.str.45 = private unnamed_addr constant [9 x i8] c"FIOASYNC\00", align 1
@.str.46 = private unnamed_addr constant [15 x i8] c"TIOCGLCKTRMIOS\00", align 1
@.str.47 = private unnamed_addr constant [15 x i8] c"TIOCSLCKTRMIOS\00", align 1
@.str.48 = private unnamed_addr constant [14 x i8] c"TIOCSERCONFIG\00", align 1
@.str.49 = private unnamed_addr constant [14 x i8] c"TIOCSERGETLSR\00", align 1
@.str.50 = private unnamed_addr constant [16 x i8] c"TIOCSERGETMULTI\00", align 1
@.str.51 = private unnamed_addr constant [16 x i8] c"TIOCSERSETMULTI\00", align 1
@.str.52 = private unnamed_addr constant [11 x i8] c"TIOCMIWAIT\00", align 1
@.str.53 = private unnamed_addr constant [12 x i8] c"TIOCGICOUNT\00", align 1
@.str.54 = private unnamed_addr constant [10 x i8] c"KIOCSOUND\00", align 1
@.str.55 = private unnamed_addr constant [9 x i8] c"KDMKTONE\00", align 1
@.str.56 = private unnamed_addr constant [10 x i8] c"KDSETMODE\00", align 1
@.str.57 = private unnamed_addr constant [10 x i8] c"KDGKBTYPE\00", align 1
@.str.58 = private unnamed_addr constant [10 x i8] c"KDGKBMODE\00", align 1
@.str.59 = private unnamed_addr constant [10 x i8] c"KDSKBMODE\00", align 1
@.str.60 = private unnamed_addr constant [9 x i8] c"KDGKBENT\00", align 1
@.str.61 = private unnamed_addr constant [10 x i8] c"KDGKBSENT\00", align 1
@.str.62 = private unnamed_addr constant [9 x i8] c"KDGKBLED\00", align 1
@.str.63 = private unnamed_addr constant [9 x i8] c"KDSKBLED\00", align 1
@.str.64 = private unnamed_addr constant [9 x i8] c"KDGETLED\00", align 1
@.str.65 = private unnamed_addr constant [9 x i8] c"KDSETLED\00", align 1
@.str.66 = private unnamed_addr constant [12 x i8] c"KDSIGACCEPT\00", align 1
@.str.67 = private unnamed_addr constant [11 x i8] c"RTC_AIE_ON\00", align 1
@.str.68 = private unnamed_addr constant [12 x i8] c"RTC_AIE_OFF\00", align 1
@.str.69 = private unnamed_addr constant [11 x i8] c"RTC_UIE_ON\00", align 1
@.str.70 = private unnamed_addr constant [12 x i8] c"RTC_UIE_OFF\00", align 1
@.str.71 = private unnamed_addr constant [11 x i8] c"RTC_PIE_ON\00", align 1
@.str.72 = private unnamed_addr constant [12 x i8] c"RTC_PIE_OFF\00", align 1
@.str.73 = private unnamed_addr constant [11 x i8] c"RTC_WIE_ON\00", align 1
@.str.74 = private unnamed_addr constant [12 x i8] c"RTC_WIE_OFF\00", align 1
@.str.75 = private unnamed_addr constant [13 x i8] c"RTC_ALM_READ\00", align 1
@.str.76 = private unnamed_addr constant [12 x i8] c"RTC_ALM_SET\00", align 1
@.str.77 = private unnamed_addr constant [12 x i8] c"RTC_RD_TIME\00", align 1
@.str.78 = private unnamed_addr constant [13 x i8] c"RTC_SET_TIME\00", align 1
@.str.79 = private unnamed_addr constant [14 x i8] c"RTC_IRQP_READ\00", align 1
@.str.80 = private unnamed_addr constant [13 x i8] c"RTC_IRQP_SET\00", align 1
@.str.81 = private unnamed_addr constant [15 x i8] c"RTC_EPOCH_READ\00", align 1
@.str.82 = private unnamed_addr constant [14 x i8] c"RTC_EPOCH_SET\00", align 1
@.str.83 = private unnamed_addr constant [13 x i8] c"RTC_WKALM_RD\00", align 1
@.str.84 = private unnamed_addr constant [14 x i8] c"RTC_WKALM_SET\00", align 1
@.str.85 = private unnamed_addr constant [12 x i8] c"RTC_PLL_GET\00", align 1
@.str.86 = private unnamed_addr constant [12 x i8] c"RTC_PLL_SET\00", align 1
@.str.87 = private unnamed_addr constant [12 x i8] c"RTC_VL_READ\00", align 1
@.str.88 = private unnamed_addr constant [11 x i8] c"RTC_VL_CLR\00", align 1
@.str.89 = private unnamed_addr constant [9 x i8] c"BLKROSET\00", align 1
@.str.90 = private unnamed_addr constant [9 x i8] c"BLKROGET\00", align 1
@.str.91 = private unnamed_addr constant [10 x i8] c"BLKRRPART\00", align 1
@.str.92 = private unnamed_addr constant [11 x i8] c"BLKGETSIZE\00", align 1
@.str.93 = private unnamed_addr constant [13 x i8] c"BLKGETSIZE64\00", align 1
@.str.94 = private unnamed_addr constant [10 x i8] c"BLKFLSBUF\00", align 1
@.str.95 = private unnamed_addr constant [9 x i8] c"BLKRASET\00", align 1
@.str.96 = private unnamed_addr constant [9 x i8] c"BLKRAGET\00", align 1
@.str.97 = private unnamed_addr constant [10 x i8] c"BLKSSZGET\00", align 1
@.str.98 = private unnamed_addr constant [10 x i8] c"BLKBSZGET\00", align 1
@.str.99 = private unnamed_addr constant [6 x i8] c"BLKPG\00", align 1
@.str.100 = private unnamed_addr constant [11 x i8] c"BLKDISCARD\00", align 1
@.str.101 = private unnamed_addr constant [9 x i8] c"BLKIOMIN\00", align 1
@.str.102 = private unnamed_addr constant [9 x i8] c"BLKIOOPT\00", align 1
@.str.103 = private unnamed_addr constant [12 x i8] c"BLKALIGNOFF\00", align 1
@.str.104 = private unnamed_addr constant [11 x i8] c"BLKPBSZGET\00", align 1
@.str.105 = private unnamed_addr constant [17 x i8] c"BLKDISCARDZEROES\00", align 1
@.str.106 = private unnamed_addr constant [14 x i8] c"BLKSECDISCARD\00", align 1
@.str.107 = private unnamed_addr constant [14 x i8] c"BLKROTATIONAL\00", align 1
@.str.108 = private unnamed_addr constant [11 x i8] c"BLKZEROOUT\00", align 1
@.str.109 = private unnamed_addr constant [8 x i8] c"FDMSGON\00", align 1
@.str.110 = private unnamed_addr constant [9 x i8] c"FDMSGOFF\00", align 1
@.str.111 = private unnamed_addr constant [15 x i8] c"FDSETEMSGTRESH\00", align 1
@.str.112 = private unnamed_addr constant [9 x i8] c"FDFMTBEG\00", align 1
@.str.113 = private unnamed_addr constant [9 x i8] c"FDFMTTRK\00", align 1
@.str.114 = private unnamed_addr constant [9 x i8] c"FDFMTEND\00", align 1
@.str.115 = private unnamed_addr constant [8 x i8] c"FDFLUSH\00", align 1
@.str.116 = private unnamed_addr constant [13 x i8] c"FDSETMAXERRS\00", align 1
@.str.117 = private unnamed_addr constant [13 x i8] c"FDGETMAXERRS\00", align 1
@.str.118 = private unnamed_addr constant [8 x i8] c"FDRESET\00", align 1
@.str.119 = private unnamed_addr constant [9 x i8] c"FDRAWCMD\00", align 1
@.str.120 = private unnamed_addr constant [10 x i8] c"FDTWADDLE\00", align 1
@.str.121 = private unnamed_addr constant [8 x i8] c"FDEJECT\00", align 1
@.str.122 = private unnamed_addr constant [7 x i8] c"FIBMAP\00", align 1
@.str.123 = private unnamed_addr constant [8 x i8] c"FICLONE\00", align 1
@.str.124 = private unnamed_addr constant [13 x i8] c"FICLONERANGE\00", align 1
@.str.125 = private unnamed_addr constant [9 x i8] c"FIGETBSZ\00", align 1
@.str.126 = private unnamed_addr constant [14 x i8] c"FS_IOC_FIEMAP\00", align 1
@.str.127 = private unnamed_addr constant [16 x i8] c"FS_IOC_GETFLAGS\00", align 1
@.str.128 = private unnamed_addr constant [16 x i8] c"FS_IOC_SETFLAGS\00", align 1
@.str.129 = private unnamed_addr constant [18 x i8] c"FS_IOC_GETVERSION\00", align 1
@.str.130 = private unnamed_addr constant [18 x i8] c"FS_IOC_SETVERSION\00", align 1
@.str.131 = private unnamed_addr constant [18 x i8] c"FS_IOC32_GETFLAGS\00", align 1
@.str.132 = private unnamed_addr constant [18 x i8] c"FS_IOC32_SETFLAGS\00", align 1
@.str.133 = private unnamed_addr constant [20 x i8] c"FS_IOC32_GETVERSION\00", align 1
@.str.134 = private unnamed_addr constant [20 x i8] c"FS_IOC32_SETVERSION\00", align 1
@.str.135 = private unnamed_addr constant [22 x i8] c"BTRFS_IOC_SNAP_CREATE\00", align 1
@.str.136 = private unnamed_addr constant [19 x i8] c"BTRFS_IOC_SCAN_DEV\00", align 1
@.str.137 = private unnamed_addr constant [21 x i8] c"BTRFS_IOC_FORGET_DEV\00", align 1
@.str.138 = private unnamed_addr constant [18 x i8] c"BTRFS_IOC_ADD_DEV\00", align 1
@.str.139 = private unnamed_addr constant [17 x i8] c"BTRFS_IOC_RM_DEV\00", align 1
@.str.140 = private unnamed_addr constant [24 x i8] c"BTRFS_IOC_SUBVOL_CREATE\00", align 1
@.str.141 = private unnamed_addr constant [23 x i8] c"BTRFS_IOC_SNAP_DESTROY\00", align 1
@.str.142 = private unnamed_addr constant [21 x i8] c"BTRFS_IOC_INO_LOOKUP\00", align 1
@.str.143 = private unnamed_addr constant [25 x i8] c"BTRFS_IOC_DEFAULT_SUBVOL\00", align 1
@.str.144 = private unnamed_addr constant [26 x i8] c"BTRFS_IOC_SUBVOL_GETFLAGS\00", align 1
@.str.145 = private unnamed_addr constant [26 x i8] c"BTRFS_IOC_SUBVOL_SETFLAGS\00", align 1
@.str.146 = private unnamed_addr constant [16 x i8] c"BTRFS_IOC_SCRUB\00", align 1
@.str.147 = private unnamed_addr constant [23 x i8] c"BTRFS_IOC_SCRUB_CANCEL\00", align 1
@.str.148 = private unnamed_addr constant [25 x i8] c"BTRFS_IOC_SCRUB_PROGRESS\00", align 1
@.str.149 = private unnamed_addr constant [19 x i8] c"BTRFS_IOC_DEV_INFO\00", align 1
@.str.150 = private unnamed_addr constant [20 x i8] c"BTRFS_IOC_INO_PATHS\00", align 1
@.str.151 = private unnamed_addr constant [22 x i8] c"BTRFS_IOC_LOGICAL_INO\00", align 1
@.str.152 = private unnamed_addr constant [20 x i8] c"BTRFS_IOC_QUOTA_CTL\00", align 1
@.str.153 = private unnamed_addr constant [24 x i8] c"BTRFS_IOC_QGROUP_ASSIGN\00", align 1
@.str.154 = private unnamed_addr constant [24 x i8] c"BTRFS_IOC_QGROUP_CREATE\00", align 1
@.str.155 = private unnamed_addr constant [23 x i8] c"BTRFS_IOC_QGROUP_LIMIT\00", align 1
@.str.156 = private unnamed_addr constant [23 x i8] c"BTRFS_IOC_QUOTA_RESCAN\00", align 1
@.str.157 = private unnamed_addr constant [30 x i8] c"BTRFS_IOC_QUOTA_RESCAN_STATUS\00", align 1
@.str.158 = private unnamed_addr constant [28 x i8] c"BTRFS_IOC_QUOTA_RESCAN_WAIT\00", align 1
@.str.159 = private unnamed_addr constant [24 x i8] c"BTRFS_IOC_GET_DEV_STATS\00", align 1
@.str.160 = private unnamed_addr constant [23 x i8] c"BTRFS_IOC_GET_FEATURES\00", align 1
@.str.161 = private unnamed_addr constant [23 x i8] c"BTRFS_IOC_SET_FEATURES\00", align 1
@.str.162 = private unnamed_addr constant [33 x i8] c"BTRFS_IOC_GET_SUPPORTED_FEATURES\00", align 1
@.str.163 = private unnamed_addr constant [25 x i8] c"BTRFS_IOC_LOGICAL_INO_V2\00", align 1
@.str.164 = private unnamed_addr constant [26 x i8] c"BTRFS_IOC_GET_SUBVOL_INFO\00", align 1
@.str.165 = private unnamed_addr constant [29 x i8] c"BTRFS_IOC_GET_SUBVOL_ROOTREF\00", align 1
@.str.166 = private unnamed_addr constant [26 x i8] c"BTRFS_IOC_INO_LOOKUP_USER\00", align 1
@.str.167 = private unnamed_addr constant [17 x i8] c"USBDEVFS_CONTROL\00", align 1
@.str.168 = private unnamed_addr constant [14 x i8] c"USBDEVFS_BULK\00", align 1
@.str.169 = private unnamed_addr constant [17 x i8] c"USBDEVFS_RESETEP\00", align 1
@.str.170 = private unnamed_addr constant [22 x i8] c"USBDEVFS_SETINTERFACE\00", align 1
@.str.171 = private unnamed_addr constant [26 x i8] c"USBDEVFS_SETCONFIGURATION\00", align 1
@.str.172 = private unnamed_addr constant [19 x i8] c"USBDEVFS_GETDRIVER\00", align 1
@.str.173 = private unnamed_addr constant [19 x i8] c"USBDEVFS_SUBMITURB\00", align 1
@.str.174 = private unnamed_addr constant [20 x i8] c"USBDEVFS_DISCARDURB\00", align 1
@.str.175 = private unnamed_addr constant [17 x i8] c"USBDEVFS_REAPURB\00", align 1
@.str.176 = private unnamed_addr constant [23 x i8] c"USBDEVFS_REAPURBNDELAY\00", align 1
@.str.177 = private unnamed_addr constant [20 x i8] c"USBDEVFS_DISCSIGNAL\00", align 1
@.str.178 = private unnamed_addr constant [24 x i8] c"USBDEVFS_CLAIMINTERFACE\00", align 1
@.str.179 = private unnamed_addr constant [26 x i8] c"USBDEVFS_RELEASEINTERFACE\00", align 1
@.str.180 = private unnamed_addr constant [21 x i8] c"USBDEVFS_CONNECTINFO\00", align 1
@.str.181 = private unnamed_addr constant [15 x i8] c"USBDEVFS_IOCTL\00", align 1
@.str.182 = private unnamed_addr constant [22 x i8] c"USBDEVFS_HUB_PORTINFO\00", align 1
@.str.183 = private unnamed_addr constant [15 x i8] c"USBDEVFS_RESET\00", align 1
@.str.184 = private unnamed_addr constant [20 x i8] c"USBDEVFS_CLEAR_HALT\00", align 1
@.str.185 = private unnamed_addr constant [20 x i8] c"USBDEVFS_DISCONNECT\00", align 1
@.str.186 = private unnamed_addr constant [17 x i8] c"USBDEVFS_CONNECT\00", align 1
@.str.187 = private unnamed_addr constant [20 x i8] c"USBDEVFS_CLAIM_PORT\00", align 1
@.str.188 = private unnamed_addr constant [22 x i8] c"USBDEVFS_RELEASE_PORT\00", align 1
@.str.189 = private unnamed_addr constant [26 x i8] c"USBDEVFS_GET_CAPABILITIES\00", align 1
@.str.190 = private unnamed_addr constant [26 x i8] c"USBDEVFS_DISCONNECT_CLAIM\00", align 1
@.str.191 = private unnamed_addr constant [25 x i8] c"USBDEVFS_DROP_PRIVILEGES\00", align 1
@.str.192 = private unnamed_addr constant [19 x i8] c"USBDEVFS_GET_SPEED\00", align 1
@.str.193 = private unnamed_addr constant [10 x i8] c"FIOGETOWN\00", align 1
@.str.194 = private unnamed_addr constant [10 x i8] c"FIOSETOWN\00", align 1
@.str.195 = private unnamed_addr constant [11 x i8] c"SIOCATMARK\00", align 1
@.str.196 = private unnamed_addr constant [12 x i8] c"SIOCGIFNAME\00", align 1
@.str.197 = private unnamed_addr constant [13 x i8] c"SIOCGIFFLAGS\00", align 1
@.str.198 = private unnamed_addr constant [13 x i8] c"SIOCSIFFLAGS\00", align 1
@.str.199 = private unnamed_addr constant [12 x i8] c"SIOCGIFADDR\00", align 1
@.str.200 = private unnamed_addr constant [12 x i8] c"SIOCSIFADDR\00", align 1
@.str.201 = private unnamed_addr constant [15 x i8] c"SIOCGIFBRDADDR\00", align 1
@.str.202 = private unnamed_addr constant [15 x i8] c"SIOCSIFBRDADDR\00", align 1
@.str.203 = private unnamed_addr constant [15 x i8] c"SIOCGIFDSTADDR\00", align 1
@.str.204 = private unnamed_addr constant [15 x i8] c"SIOCSIFDSTADDR\00", align 1
@.str.205 = private unnamed_addr constant [15 x i8] c"SIOCGIFNETMASK\00", align 1
@.str.206 = private unnamed_addr constant [15 x i8] c"SIOCSIFNETMASK\00", align 1
@.str.207 = private unnamed_addr constant [14 x i8] c"SIOCGIFHWADDR\00", align 1
@.str.208 = private unnamed_addr constant [14 x i8] c"SIOCSIFHWADDR\00", align 1
@.str.209 = private unnamed_addr constant [14 x i8] c"SIOCGIFTXQLEN\00", align 1
@.str.210 = private unnamed_addr constant [14 x i8] c"SIOCSIFTXQLEN\00", align 1
@.str.211 = private unnamed_addr constant [14 x i8] c"SIOCGIFMETRIC\00", align 1
@.str.212 = private unnamed_addr constant [14 x i8] c"SIOCSIFMETRIC\00", align 1
@.str.213 = private unnamed_addr constant [11 x i8] c"SIOCGIFMTU\00", align 1
@.str.214 = private unnamed_addr constant [11 x i8] c"SIOCSIFMTU\00", align 1
@.str.215 = private unnamed_addr constant [11 x i8] c"SIOCGIFMAP\00", align 1
@.str.216 = private unnamed_addr constant [11 x i8] c"SIOCSIFMAP\00", align 1
@.str.217 = private unnamed_addr constant [13 x i8] c"SIOCGIFSLAVE\00", align 1
@.str.218 = private unnamed_addr constant [13 x i8] c"SIOCSIFSLAVE\00", align 1
@.str.219 = private unnamed_addr constant [11 x i8] c"SIOCGIFMEM\00", align 1
@.str.220 = private unnamed_addr constant [11 x i8] c"SIOCSIFMEM\00", align 1
@.str.221 = private unnamed_addr constant [13 x i8] c"SIOCADDMULTI\00", align 1
@.str.222 = private unnamed_addr constant [13 x i8] c"SIOCDELMULTI\00", align 1
@.str.223 = private unnamed_addr constant [13 x i8] c"SIOCGIFINDEX\00", align 1
@.str.224 = private unnamed_addr constant [14 x i8] c"SIOCSIFPFLAGS\00", align 1
@.str.225 = private unnamed_addr constant [14 x i8] c"SIOCGIFPFLAGS\00", align 1
@.str.226 = private unnamed_addr constant [12 x i8] c"SIOCSIFLINK\00", align 1
@.str.227 = private unnamed_addr constant [12 x i8] c"SIOCGIFCONF\00", align 1
@.str.228 = private unnamed_addr constant [13 x i8] c"SIOCGIFENCAP\00", align 1
@.str.229 = private unnamed_addr constant [13 x i8] c"SIOCSIFENCAP\00", align 1
@.str.230 = private unnamed_addr constant [9 x i8] c"SIOCDARP\00", align 1
@.str.231 = private unnamed_addr constant [9 x i8] c"SIOCSARP\00", align 1
@.str.232 = private unnamed_addr constant [9 x i8] c"SIOCGARP\00", align 1
@.str.233 = private unnamed_addr constant [10 x i8] c"SIOCDRARP\00", align 1
@.str.234 = private unnamed_addr constant [10 x i8] c"SIOCSRARP\00", align 1
@.str.235 = private unnamed_addr constant [10 x i8] c"SIOCGRARP\00", align 1
@.str.236 = private unnamed_addr constant [12 x i8] c"SIOCGIWNAME\00", align 1
@.str.237 = private unnamed_addr constant [10 x i8] c"SIOCSPGRP\00", align 1
@.str.238 = private unnamed_addr constant [10 x i8] c"SIOCGPGRP\00", align 1
@.str.239 = private unnamed_addr constant [15 x i8] c"SIOCGSTAMP_OLD\00", align 1
@.str.240 = private unnamed_addr constant [17 x i8] c"SIOCGSTAMPNS_OLD\00", align 1
@.str.241 = private unnamed_addr constant [15 x i8] c"SIOCGSTAMP_NEW\00", align 1
@.str.242 = private unnamed_addr constant [17 x i8] c"SIOCGSTAMPNS_NEW\00", align 1
@.str.243 = private unnamed_addr constant [13 x i8] c"RNDGETENTCNT\00", align 1
@.str.244 = private unnamed_addr constant [15 x i8] c"RNDADDTOENTCNT\00", align 1
@.str.245 = private unnamed_addr constant [13 x i8] c"RNDZAPENTCNT\00", align 1
@.str.246 = private unnamed_addr constant [13 x i8] c"RNDCLEARPOOL\00", align 1
@.str.247 = private unnamed_addr constant [14 x i8] c"RNDRESEEDCRNG\00", align 1
@.str.248 = private unnamed_addr constant [11 x i8] c"CDROMPAUSE\00", align 1
@.str.249 = private unnamed_addr constant [11 x i8] c"CDROMSTART\00", align 1
@.str.250 = private unnamed_addr constant [10 x i8] c"CDROMSTOP\00", align 1
@.str.251 = private unnamed_addr constant [12 x i8] c"CDROMRESUME\00", align 1
@.str.252 = private unnamed_addr constant [11 x i8] c"CDROMEJECT\00", align 1
@.str.253 = private unnamed_addr constant [14 x i8] c"CDROMEJECT_SW\00", align 1
@.str.254 = private unnamed_addr constant [15 x i8] c"CDROMCLOSETRAY\00", align 1
@.str.255 = private unnamed_addr constant [11 x i8] c"CDROMRESET\00", align 1
@.str.256 = private unnamed_addr constant [13 x i8] c"CDROMPLAYMSF\00", align 1
@.str.257 = private unnamed_addr constant [16 x i8] c"CDROMPLAYTRKIND\00", align 1
@.str.258 = private unnamed_addr constant [16 x i8] c"CDROMREADTOCHDR\00", align 1
@.str.259 = private unnamed_addr constant [18 x i8] c"CDROMREADTOCENTRY\00", align 1
@.str.260 = private unnamed_addr constant [13 x i8] c"CDROMVOLCTRL\00", align 1
@.str.261 = private unnamed_addr constant [13 x i8] c"CDROMSUBCHNL\00", align 1
@.str.262 = private unnamed_addr constant [15 x i8] c"CDROMREADAUDIO\00", align 1
@.str.263 = private unnamed_addr constant [16 x i8] c"CDROMREADCOOKED\00", align 1
@.str.264 = private unnamed_addr constant [13 x i8] c"CDROMREADRAW\00", align 1
@.str.265 = private unnamed_addr constant [15 x i8] c"CDROMREADMODE1\00", align 1
@.str.266 = private unnamed_addr constant [15 x i8] c"CDROMREADMODE2\00", align 1
@.str.267 = private unnamed_addr constant [13 x i8] c"CDROMREADALL\00", align 1
@.str.268 = private unnamed_addr constant [18 x i8] c"CDROMMULTISESSION\00", align 1
@.str.269 = private unnamed_addr constant [14 x i8] c"CDROM_GET_UPC\00", align 1
@.str.270 = private unnamed_addr constant [13 x i8] c"CDROMVOLREAD\00", align 1
@.str.271 = private unnamed_addr constant [10 x i8] c"CDROMSEEK\00", align 1
@.str.272 = private unnamed_addr constant [13 x i8] c"CDROMPLAYBLK\00", align 1
@.str.273 = private unnamed_addr constant [20 x i8] c"CDROM_MEDIA_CHANGED\00", align 1
@.str.274 = private unnamed_addr constant [18 x i8] c"CDROM_SET_OPTIONS\00", align 1
@.str.275 = private unnamed_addr constant [20 x i8] c"CDROM_CLEAR_OPTIONS\00", align 1
@.str.276 = private unnamed_addr constant [19 x i8] c"CDROM_SELECT_SPEED\00", align 1
@.str.277 = private unnamed_addr constant [18 x i8] c"CDROM_SELECT_DISC\00", align 1
@.str.278 = private unnamed_addr constant [19 x i8] c"CDROM_DRIVE_STATUS\00", align 1
@.str.279 = private unnamed_addr constant [18 x i8] c"CDROM_DISC_STATUS\00", align 1
@.str.280 = private unnamed_addr constant [17 x i8] c"CDROMAUDIOBUFSIZ\00", align 1
@.str.281 = private unnamed_addr constant [20 x i8] c"SNDCTL_DSP_CHANNELS\00", align 1
@.str.282 = private unnamed_addr constant [22 x i8] c"SNDCTL_DSP_GETBLKSIZE\00", align 1
@.str.283 = private unnamed_addr constant [19 x i8] c"SNDCTL_DSP_GETCAPS\00", align 1
@.str.284 = private unnamed_addr constant [19 x i8] c"SNDCTL_DSP_GETFMTS\00", align 1
@.str.285 = private unnamed_addr constant [19 x i8] c"SNDCTL_DSP_GETIPTR\00", align 1
@.str.286 = private unnamed_addr constant [19 x i8] c"SNDCTL_DSP_GETOPTR\00", align 1
@.str.287 = private unnamed_addr constant [21 x i8] c"SNDCTL_DSP_GETISPACE\00", align 1
@.str.288 = private unnamed_addr constant [21 x i8] c"SNDCTL_DSP_GETOSPACE\00", align 1
@.str.289 = private unnamed_addr constant [22 x i8] c"SNDCTL_DSP_GETTRIGGER\00", align 1
@.str.290 = private unnamed_addr constant [20 x i8] c"SNDCTL_DSP_MAPINBUF\00", align 1
@.str.291 = private unnamed_addr constant [21 x i8] c"SNDCTL_DSP_MAPOUTBUF\00", align 1
@.str.292 = private unnamed_addr constant [20 x i8] c"SNDCTL_DSP_NONBLOCK\00", align 1
@.str.293 = private unnamed_addr constant [16 x i8] c"SNDCTL_DSP_POST\00", align 1
@.str.294 = private unnamed_addr constant [17 x i8] c"SNDCTL_DSP_RESET\00", align 1
@.str.295 = private unnamed_addr constant [21 x i8] c"SNDCTL_DSP_SETDUPLEX\00", align 1
@.str.296 = private unnamed_addr constant [18 x i8] c"SNDCTL_DSP_SETFMT\00", align 1
@.str.297 = private unnamed_addr constant [23 x i8] c"SNDCTL_DSP_SETFRAGMENT\00", align 1
@.str.298 = private unnamed_addr constant [21 x i8] c"SNDCTL_DSP_SETSYNCRO\00", align 1
@.str.299 = private unnamed_addr constant [22 x i8] c"SNDCTL_DSP_SETTRIGGER\00", align 1
@.str.300 = private unnamed_addr constant [17 x i8] c"SNDCTL_DSP_SPEED\00", align 1
@.str.301 = private unnamed_addr constant [18 x i8] c"SNDCTL_DSP_STEREO\00", align 1
@.str.302 = private unnamed_addr constant [21 x i8] c"SNDCTL_DSP_SUBDIVIDE\00", align 1
@.str.303 = private unnamed_addr constant [16 x i8] c"SNDCTL_DSP_SYNC\00", align 1
@.str.304 = private unnamed_addr constant [17 x i8] c"SOUND_MIXER_INFO\00", align 1
@.str.305 = private unnamed_addr constant [19 x i8] c"SOUND_MIXER_ACCESS\00", align 1
@.str.306 = private unnamed_addr constant [21 x i8] c"SOUND_MIXER_PRIVATE1\00", align 1
@.str.307 = private unnamed_addr constant [21 x i8] c"SOUND_MIXER_PRIVATE2\00", align 1
@.str.308 = private unnamed_addr constant [21 x i8] c"SOUND_MIXER_PRIVATE3\00", align 1
@.str.309 = private unnamed_addr constant [21 x i8] c"SOUND_MIXER_PRIVATE4\00", align 1
@.str.310 = private unnamed_addr constant [21 x i8] c"SOUND_MIXER_PRIVATE5\00", align 1
@.str.311 = private unnamed_addr constant [24 x i8] c"SOUND_MIXER_READ_VOLUME\00", align 1
@.str.312 = private unnamed_addr constant [22 x i8] c"SOUND_MIXER_READ_BASS\00", align 1
@.str.313 = private unnamed_addr constant [24 x i8] c"SOUND_MIXER_READ_TREBLE\00", align 1
@.str.314 = private unnamed_addr constant [23 x i8] c"SOUND_MIXER_READ_SYNTH\00", align 1
@.str.315 = private unnamed_addr constant [21 x i8] c"SOUND_MIXER_READ_PCM\00", align 1
@.str.316 = private unnamed_addr constant [25 x i8] c"SOUND_MIXER_READ_SPEAKER\00", align 1
@.str.317 = private unnamed_addr constant [22 x i8] c"SOUND_MIXER_READ_LINE\00", align 1
@.str.318 = private unnamed_addr constant [21 x i8] c"SOUND_MIXER_READ_MIC\00", align 1
@.str.319 = private unnamed_addr constant [20 x i8] c"SOUND_MIXER_READ_CD\00", align 1
@.str.320 = private unnamed_addr constant [22 x i8] c"SOUND_MIXER_READ_IMIX\00", align 1
@.str.321 = private unnamed_addr constant [24 x i8] c"SOUND_MIXER_READ_ALTPCM\00", align 1
@.str.322 = private unnamed_addr constant [24 x i8] c"SOUND_MIXER_READ_RECLEV\00", align 1
@.str.323 = private unnamed_addr constant [23 x i8] c"SOUND_MIXER_READ_IGAIN\00", align 1
@.str.324 = private unnamed_addr constant [23 x i8] c"SOUND_MIXER_READ_OGAIN\00", align 1
@.str.325 = private unnamed_addr constant [23 x i8] c"SOUND_MIXER_READ_LINE1\00", align 1
@.str.326 = private unnamed_addr constant [23 x i8] c"SOUND_MIXER_READ_LINE2\00", align 1
@.str.327 = private unnamed_addr constant [23 x i8] c"SOUND_MIXER_READ_LINE3\00", align 1
@.str.328 = private unnamed_addr constant [22 x i8] c"SOUND_MIXER_READ_MUTE\00", align 1
@.str.329 = private unnamed_addr constant [25 x i8] c"SOUND_MIXER_READ_ENHANCE\00", align 1
@.str.330 = private unnamed_addr constant [22 x i8] c"SOUND_MIXER_READ_LOUD\00", align 1
@.str.331 = private unnamed_addr constant [24 x i8] c"SOUND_MIXER_READ_RECSRC\00", align 1
@.str.332 = private unnamed_addr constant [25 x i8] c"SOUND_MIXER_READ_DEVMASK\00", align 1
@.str.333 = private unnamed_addr constant [25 x i8] c"SOUND_MIXER_READ_RECMASK\00", align 1
@.str.334 = private unnamed_addr constant [28 x i8] c"SOUND_MIXER_READ_STEREODEVS\00", align 1
@.str.335 = private unnamed_addr constant [22 x i8] c"SOUND_MIXER_READ_CAPS\00", align 1
@.str.336 = private unnamed_addr constant [25 x i8] c"SOUND_MIXER_WRITE_VOLUME\00", align 1
@.str.337 = private unnamed_addr constant [23 x i8] c"SOUND_MIXER_WRITE_BASS\00", align 1
@.str.338 = private unnamed_addr constant [25 x i8] c"SOUND_MIXER_WRITE_TREBLE\00", align 1
@.str.339 = private unnamed_addr constant [24 x i8] c"SOUND_MIXER_WRITE_SYNTH\00", align 1
@.str.340 = private unnamed_addr constant [22 x i8] c"SOUND_MIXER_WRITE_PCM\00", align 1
@.str.341 = private unnamed_addr constant [26 x i8] c"SOUND_MIXER_WRITE_SPEAKER\00", align 1
@.str.342 = private unnamed_addr constant [23 x i8] c"SOUND_MIXER_WRITE_LINE\00", align 1
@.str.343 = private unnamed_addr constant [22 x i8] c"SOUND_MIXER_WRITE_MIC\00", align 1
@.str.344 = private unnamed_addr constant [21 x i8] c"SOUND_MIXER_WRITE_CD\00", align 1
@.str.345 = private unnamed_addr constant [23 x i8] c"SOUND_MIXER_WRITE_IMIX\00", align 1
@.str.346 = private unnamed_addr constant [25 x i8] c"SOUND_MIXER_WRITE_ALTPCM\00", align 1
@.str.347 = private unnamed_addr constant [25 x i8] c"SOUND_MIXER_WRITE_RECLEV\00", align 1
@.str.348 = private unnamed_addr constant [24 x i8] c"SOUND_MIXER_WRITE_IGAIN\00", align 1
@.str.349 = private unnamed_addr constant [24 x i8] c"SOUND_MIXER_WRITE_OGAIN\00", align 1
@.str.350 = private unnamed_addr constant [24 x i8] c"SOUND_MIXER_WRITE_LINE1\00", align 1
@.str.351 = private unnamed_addr constant [24 x i8] c"SOUND_MIXER_WRITE_LINE2\00", align 1
@.str.352 = private unnamed_addr constant [24 x i8] c"SOUND_MIXER_WRITE_LINE3\00", align 1
@.str.353 = private unnamed_addr constant [23 x i8] c"SOUND_MIXER_WRITE_MUTE\00", align 1
@.str.354 = private unnamed_addr constant [26 x i8] c"SOUND_MIXER_WRITE_ENHANCE\00", align 1
@.str.355 = private unnamed_addr constant [23 x i8] c"SOUND_MIXER_WRITE_LOUD\00", align 1
@.str.356 = private unnamed_addr constant [25 x i8] c"SOUND_MIXER_WRITE_RECSRC\00", align 1
@.str.357 = private unnamed_addr constant [27 x i8] c"SNDRV_TIMER_IOCTL_PVERSION\00", align 1
@.str.358 = private unnamed_addr constant [30 x i8] c"SNDRV_TIMER_IOCTL_NEXT_DEVICE\00", align 1
@.str.359 = private unnamed_addr constant [24 x i8] c"SNDRV_TIMER_IOCTL_GINFO\00", align 1
@.str.360 = private unnamed_addr constant [26 x i8] c"SNDRV_TIMER_IOCTL_GPARAMS\00", align 1
@.str.361 = private unnamed_addr constant [26 x i8] c"SNDRV_TIMER_IOCTL_GSTATUS\00", align 1
@.str.362 = private unnamed_addr constant [25 x i8] c"SNDRV_TIMER_IOCTL_SELECT\00", align 1
@.str.363 = private unnamed_addr constant [23 x i8] c"SNDRV_TIMER_IOCTL_INFO\00", align 1
@.str.364 = private unnamed_addr constant [25 x i8] c"SNDRV_TIMER_IOCTL_PARAMS\00", align 1
@.str.365 = private unnamed_addr constant [25 x i8] c"SNDRV_TIMER_IOCTL_STATUS\00", align 1
@.str.366 = private unnamed_addr constant [24 x i8] c"SNDRV_TIMER_IOCTL_START\00", align 1
@.str.367 = private unnamed_addr constant [23 x i8] c"SNDRV_TIMER_IOCTL_STOP\00", align 1
@.str.368 = private unnamed_addr constant [27 x i8] c"SNDRV_TIMER_IOCTL_CONTINUE\00", align 1
@.str.369 = private unnamed_addr constant [24 x i8] c"SNDRV_TIMER_IOCTL_PAUSE\00", align 1
@.str.370 = private unnamed_addr constant [12 x i8] c"HDIO_GETGEO\00", align 1
@.str.371 = private unnamed_addr constant [20 x i8] c"HDIO_GET_UNMASKINTR\00", align 1
@.str.372 = private unnamed_addr constant [19 x i8] c"HDIO_GET_MULTCOUNT\00", align 1
@.str.373 = private unnamed_addr constant [18 x i8] c"HDIO_GET_IDENTITY\00", align 1
@.str.374 = private unnamed_addr constant [22 x i8] c"HDIO_GET_KEEPSETTINGS\00", align 1
@.str.375 = private unnamed_addr constant [16 x i8] c"HDIO_GET_NOWERR\00", align 1
@.str.376 = private unnamed_addr constant [13 x i8] c"HDIO_GET_DMA\00", align 1
@.str.377 = private unnamed_addr constant [15 x i8] c"HDIO_GET_32BIT\00", align 1
@.str.378 = private unnamed_addr constant [15 x i8] c"HDIO_DRIVE_CMD\00", align 1
@.str.379 = private unnamed_addr constant [20 x i8] c"HDIO_SET_UNMASKINTR\00", align 1
@.str.380 = private unnamed_addr constant [19 x i8] c"HDIO_SET_MULTCOUNT\00", align 1
@.str.381 = private unnamed_addr constant [22 x i8] c"HDIO_SET_KEEPSETTINGS\00", align 1
@.str.382 = private unnamed_addr constant [16 x i8] c"HDIO_SET_NOWERR\00", align 1
@.str.383 = private unnamed_addr constant [13 x i8] c"HDIO_SET_DMA\00", align 1
@.str.384 = private unnamed_addr constant [15 x i8] c"HDIO_SET_32BIT\00", align 1
@.str.385 = private unnamed_addr constant [18 x i8] c"HDIO_SET_PIO_MODE\00", align 1
@.str.386 = private unnamed_addr constant [24 x i8] c"VFAT_IOCTL_READDIR_BOTH\00", align 1
@.str.387 = private unnamed_addr constant [25 x i8] c"VFAT_IOCTL_READDIR_SHORT\00", align 1
@.str.388 = private unnamed_addr constant [12 x i8] c"LOOP_SET_FD\00", align 1
@.str.389 = private unnamed_addr constant [12 x i8] c"LOOP_CLR_FD\00", align 1
@.str.390 = private unnamed_addr constant [16 x i8] c"LOOP_SET_STATUS\00", align 1
@.str.391 = private unnamed_addr constant [16 x i8] c"LOOP_GET_STATUS\00", align 1
@.str.392 = private unnamed_addr constant [18 x i8] c"LOOP_SET_STATUS64\00", align 1
@.str.393 = private unnamed_addr constant [18 x i8] c"LOOP_GET_STATUS64\00", align 1
@.str.394 = private unnamed_addr constant [15 x i8] c"LOOP_CHANGE_FD\00", align 1
@.str.395 = private unnamed_addr constant [18 x i8] c"LOOP_SET_CAPACITY\00", align 1
@.str.396 = private unnamed_addr constant [19 x i8] c"LOOP_SET_DIRECT_IO\00", align 1
@.str.397 = private unnamed_addr constant [20 x i8] c"LOOP_SET_BLOCK_SIZE\00", align 1
@.str.398 = private unnamed_addr constant [15 x i8] c"LOOP_CONFIGURE\00", align 1
@.str.399 = private unnamed_addr constant [13 x i8] c"LOOP_CTL_ADD\00", align 1
@.str.400 = private unnamed_addr constant [16 x i8] c"LOOP_CTL_REMOVE\00", align 1
@.str.401 = private unnamed_addr constant [18 x i8] c"LOOP_CTL_GET_FREE\00", align 1
@.str.402 = private unnamed_addr constant [9 x i8] c"MTIOCTOP\00", align 1
@.str.403 = private unnamed_addr constant [9 x i8] c"MTIOCGET\00", align 1
@.str.404 = private unnamed_addr constant [9 x i8] c"MTIOCPOS\00", align 1
@.str.405 = private unnamed_addr constant [20 x i8] c"FBIOGET_FSCREENINFO\00", align 1
@.str.406 = private unnamed_addr constant [20 x i8] c"FBIOGET_VSCREENINFO\00", align 1
@.str.407 = private unnamed_addr constant [20 x i8] c"FBIOPUT_VSCREENINFO\00", align 1
@.str.408 = private unnamed_addr constant [12 x i8] c"FBIOGETCMAP\00", align 1
@.str.409 = private unnamed_addr constant [12 x i8] c"FBIOPUTCMAP\00", align 1
@.str.410 = private unnamed_addr constant [16 x i8] c"FBIOPAN_DISPLAY\00", align 1
@.str.411 = private unnamed_addr constant [18 x i8] c"FBIOGET_CON2FBMAP\00", align 1
@.str.412 = private unnamed_addr constant [18 x i8] c"FBIOPUT_CON2FBMAP\00", align 1
@.str.413 = private unnamed_addr constant [11 x i8] c"VT_OPENQRY\00", align 1
@.str.414 = private unnamed_addr constant [12 x i8] c"VT_GETSTATE\00", align 1
@.str.415 = private unnamed_addr constant [12 x i8] c"VT_ACTIVATE\00", align 1
@.str.416 = private unnamed_addr constant [14 x i8] c"VT_WAITACTIVE\00", align 1
@.str.417 = private unnamed_addr constant [14 x i8] c"VT_LOCKSWITCH\00", align 1
@.str.418 = private unnamed_addr constant [16 x i8] c"VT_UNLOCKSWITCH\00", align 1
@.str.419 = private unnamed_addr constant [11 x i8] c"VT_GETMODE\00", align 1
@.str.420 = private unnamed_addr constant [11 x i8] c"VT_SETMODE\00", align 1
@.str.421 = private unnamed_addr constant [11 x i8] c"VT_RELDISP\00", align 1
@.str.422 = private unnamed_addr constant [15 x i8] c"VT_DISALLOCATE\00", align 1
@.str.423 = private unnamed_addr constant [11 x i8] c"DM_VERSION\00", align 1
@.str.424 = private unnamed_addr constant [14 x i8] c"DM_REMOVE_ALL\00", align 1
@.str.425 = private unnamed_addr constant [16 x i8] c"DM_LIST_DEVICES\00", align 1
@.str.426 = private unnamed_addr constant [14 x i8] c"DM_DEV_CREATE\00", align 1
@.str.427 = private unnamed_addr constant [14 x i8] c"DM_DEV_REMOVE\00", align 1
@.str.428 = private unnamed_addr constant [14 x i8] c"DM_DEV_RENAME\00", align 1
@.str.429 = private unnamed_addr constant [15 x i8] c"DM_DEV_SUSPEND\00", align 1
@.str.430 = private unnamed_addr constant [14 x i8] c"DM_DEV_STATUS\00", align 1
@.str.431 = private unnamed_addr constant [12 x i8] c"DM_DEV_WAIT\00", align 1
@.str.432 = private unnamed_addr constant [14 x i8] c"DM_TABLE_LOAD\00", align 1
@.str.433 = private unnamed_addr constant [15 x i8] c"DM_TABLE_CLEAR\00", align 1
@.str.434 = private unnamed_addr constant [14 x i8] c"DM_TABLE_DEPS\00", align 1
@.str.435 = private unnamed_addr constant [16 x i8] c"DM_TABLE_STATUS\00", align 1
@.str.436 = private unnamed_addr constant [17 x i8] c"DM_LIST_VERSIONS\00", align 1
@.str.437 = private unnamed_addr constant [14 x i8] c"DM_TARGET_MSG\00", align 1
@.str.438 = private unnamed_addr constant [20 x i8] c"DM_DEV_SET_GEOMETRY\00", align 1
@.str.439 = private unnamed_addr constant [10 x i8] c"SIOCADDRT\00", align 1
@.str.440 = private unnamed_addr constant [10 x i8] c"SIOCDELRT\00", align 1
@.str.441 = private unnamed_addr constant [18 x i8] c"DRM_IOCTL_VERSION\00", align 1
@.str.442 = private unnamed_addr constant [24 x i8] c"DRM_IOCTL_I915_GETPARAM\00", align 1
@.str.443 = private unnamed_addr constant [12 x i8] c"TUNSETDEBUG\00", align 1
@.str.444 = private unnamed_addr constant [10 x i8] c"TUNSETIFF\00", align 1
@.str.445 = private unnamed_addr constant [14 x i8] c"TUNSETPERSIST\00", align 1
@.str.446 = private unnamed_addr constant [12 x i8] c"TUNSETOWNER\00", align 1
@.str.447 = private unnamed_addr constant [11 x i8] c"TUNSETLINK\00", align 1
@.str.448 = private unnamed_addr constant [12 x i8] c"TUNSETGROUP\00", align 1
@.str.449 = private unnamed_addr constant [15 x i8] c"TUNGETFEATURES\00", align 1
@.str.450 = private unnamed_addr constant [14 x i8] c"TUNSETOFFLOAD\00", align 1
@.str.451 = private unnamed_addr constant [15 x i8] c"TUNSETTXFILTER\00", align 1
@.str.452 = private unnamed_addr constant [10 x i8] c"TUNGETIFF\00", align 1
@.str.453 = private unnamed_addr constant [13 x i8] c"TUNGETSNDBUF\00", align 1
@.str.454 = private unnamed_addr constant [13 x i8] c"TUNSETSNDBUF\00", align 1
@.str.455 = private unnamed_addr constant [16 x i8] c"TUNGETVNETHDRSZ\00", align 1
@.str.456 = private unnamed_addr constant [16 x i8] c"TUNSETVNETHDRSZ\00", align 1
@.str.457 = private unnamed_addr constant [12 x i8] c"TUNSETQUEUE\00", align 1
@.str.458 = private unnamed_addr constant [14 x i8] c"TUNSETIFINDEX\00", align 1
@.str.459 = private unnamed_addr constant [13 x i8] c"TUNSETVNETLE\00", align 1
@.str.460 = private unnamed_addr constant [13 x i8] c"TUNGETVNETLE\00", align 1
@.str.461 = private unnamed_addr constant [13 x i8] c"TUNSETVNETBE\00", align 1
@.str.462 = private unnamed_addr constant [13 x i8] c"TUNGETVNETBE\00", align 1
@.str.463 = private unnamed_addr constant [19 x i8] c"TUNSETSTEERINGEBPF\00", align 1
@.str.464 = private unnamed_addr constant [17 x i8] c"TUNSETFILTEREBPF\00", align 1
@.str.465 = private unnamed_addr constant [14 x i8] c"TUNSETCARRIER\00", align 1
@.str.466 = private unnamed_addr constant [15 x i8] c"TUNGETDEVNETNS\00", align 1
@ioctl_entries = dso_local global [466 x %struct.IOCTLEntry] [%struct.IOCTLEntry { i32 21505, i32 21505, ptr @.str.2, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21506, i32 21506, ptr @.str.3, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21508, i32 21508, ptr @.str.4, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21507, i32 21507, ptr @.str.5, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21523, i32 21523, ptr @.str.6, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 1, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21524, i32 21524, ptr @.str.7, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 1, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21531, i32 21531, ptr @.str.8, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21509, i32 21509, ptr @.str.9, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21510, i32 21510, ptr @.str.10, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21511, i32 21511, ptr @.str.11, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21512, i32 21512, ptr @.str.12, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21513, i32 21513, ptr @.str.13, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21541, i32 21541, ptr @.str.14, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21514, i32 21514, ptr @.str.15, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21515, i32 21515, ptr @.str.16, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21516, i32 21516, ptr @.str.17, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21517, i32 21517, ptr @.str.18, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21518, i32 21518, ptr @.str.19, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21519, i32 21519, ptr @.str.20, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21520, i32 21520, ptr @.str.21, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21545, i32 21545, ptr @.str.22, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21521, i32 21521, ptr @.str.23, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21522, i32 21522, ptr @.str.24, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21525, i32 21525, ptr @.str.25, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21526, i32 21526, ptr @.str.26, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21527, i32 21527, ptr @.str.27, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21528, i32 21528, ptr @.str.28, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21529, i32 21529, ptr @.str.29, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21530, i32 21530, ptr @.str.30, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21532, i32 21532, ptr @.str.31, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21533, i32 21533, ptr @.str.32, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21534, i32 21534, ptr @.str.33, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21535, i32 21535, ptr @.str.34, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21536, i32 21536, ptr @.str.35, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21537, i32 21537, ptr @.str.36, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21538, i32 21538, ptr @.str.37, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21540, i32 21540, ptr @.str.38, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21539, i32 21539, ptr @.str.39, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147199952, i32 -2147199952, ptr @.str.40, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025521, i32 1074025521, ptr @.str.41, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21569, i32 21569, ptr @.str.42, i32 0, ptr @do_ioctl_tiocgptpeer, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21585, i32 21585, ptr @.str.43, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21584, i32 21584, ptr @.str.44, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21586, i32 21586, ptr @.str.45, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21590, i32 21590, ptr @.str.46, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21591, i32 21591, ptr @.str.47, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21587, i32 21587, ptr @.str.48, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21593, i32 21593, ptr @.str.49, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21594, i32 21594, ptr @.str.50, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 2, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21595, i32 21595, ptr @.str.51, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 2, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21596, i32 21596, ptr @.str.52, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21597, i32 21597, ptr @.str.53, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 3, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19247, i32 19247, ptr @.str.54, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19248, i32 19248, ptr @.str.55, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19258, i32 19258, ptr @.str.56, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19251, i32 19251, ptr @.str.57, i32 1, ptr null, [5 x i32] [i32 9, i32 1, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19268, i32 19268, ptr @.str.58, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19269, i32 19269, ptr @.str.59, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19270, i32 19270, ptr @.str.60, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 19, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19272, i32 19272, ptr @.str.61, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 20, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19300, i32 19300, ptr @.str.62, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19301, i32 19301, ptr @.str.63, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19249, i32 19249, ptr @.str.64, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19250, i32 19250, ptr @.str.65, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19278, i32 19278, ptr @.str.66, i32 0, ptr @do_ioctl_kdsigaccept, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 28673, i32 28673, ptr @.str.67, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 28674, i32 28674, ptr @.str.68, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 28675, i32 28675, ptr @.str.69, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 28676, i32 28676, ptr @.str.70, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 28677, i32 28677, ptr @.str.71, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 28678, i32 28678, ptr @.str.72, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 28687, i32 28687, ptr @.str.73, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 28688, i32 28688, ptr @.str.74, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 -2145095672, i32 -2145095672, ptr @.str.75, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 81, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1076129799, i32 1076129799, ptr @.str.76, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 81, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2145095671, i32 -2145095671, ptr @.str.77, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 81, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1076129802, i32 1076129802, ptr @.str.78, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 81, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2146930677, i32 -2146930677, ptr @.str.79, i32 1, ptr null, [5 x i32] [i32 9, i32 5, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074294796, i32 1074294796, ptr @.str.80, i32 2, ptr null, [5 x i32] [i32 5, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2146930675, i32 -2146930675, ptr @.str.81, i32 1, ptr null, [5 x i32] [i32 9, i32 5, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074294798, i32 1074294798, ptr @.str.82, i32 2, ptr null, [5 x i32] [i32 5, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2144833520, i32 -2144833520, ptr @.str.83, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 82, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1076391951, i32 1076391951, ptr @.str.84, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 82, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2145357807, i32 -2145357807, ptr @.str.85, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 83, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1075867666, i32 1075867666, ptr @.str.86, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 83, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147192813, i32 -2147192813, ptr @.str.87, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 28692, i32 28692, ptr @.str.88, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 4701, i32 4701, ptr @.str.89, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4702, i32 4702, ptr @.str.90, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4703, i32 4703, ptr @.str.91, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 4704, i32 4704, ptr @.str.92, i32 1, ptr null, [5 x i32] [i32 9, i32 5, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2146954638, i32 -2146954638, ptr @.str.93, i32 1, ptr null, [5 x i32] [i32 9, i32 8, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4705, i32 4705, ptr @.str.94, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 4706, i32 4706, ptr @.str.95, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4707, i32 4707, ptr @.str.96, i32 1, ptr null, [5 x i32] [i32 9, i32 4, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4712, i32 4712, ptr @.str.97, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2146954640, i32 -2146954640, ptr @.str.98, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4713, i32 4713, ptr @.str.99, i32 2, ptr @do_ioctl_blkpg, [5 x i32] [i32 9, i32 11, i32 84, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4727, i32 4727, ptr @.str.100, i32 2, ptr null, [5 x i32] [i32 9, i32 10, i32 2, i32 8, i32 0] }, %struct.IOCTLEntry { i32 4728, i32 4728, ptr @.str.101, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4729, i32 4729, ptr @.str.102, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4730, i32 4730, ptr @.str.103, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4731, i32 4731, ptr @.str.104, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4732, i32 4732, ptr @.str.105, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4733, i32 4733, ptr @.str.106, i32 2, ptr null, [5 x i32] [i32 9, i32 10, i32 2, i32 8, i32 0] }, %struct.IOCTLEntry { i32 4734, i32 4734, ptr @.str.107, i32 1, ptr null, [5 x i32] [i32 9, i32 2, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 4735, i32 4735, ptr @.str.108, i32 2, ptr null, [5 x i32] [i32 9, i32 10, i32 2, i32 8, i32 0] }, %struct.IOCTLEntry { i32 581, i32 581, ptr @.str.109, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 582, i32 582, ptr @.str.110, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 586, i32 586, ptr @.str.111, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 583, i32 583, ptr @.str.112, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 1074528840, i32 1074528840, ptr @.str.113, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 85, i32 0, i32 0] }, %struct.IOCTLEntry { i32 585, i32 585, ptr @.str.114, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 587, i32 587, ptr @.str.115, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 1075053132, i32 1075053132, ptr @.str.116, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 86, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2146172402, i32 -2146172402, ptr @.str.117, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 86, i32 0, i32 0] }, %struct.IOCTLEntry { i32 596, i32 596, ptr @.str.118, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 600, i32 600, ptr @.str.119, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 601, i32 601, ptr @.str.120, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 602, i32 602, ptr @.str.121, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 1, i32 1, ptr @.str.122, i32 3, ptr null, [5 x i32] [i32 9, i32 4, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074041865, i32 1074041865, ptr @.str.123, i32 2, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1075876877, i32 1075876877, ptr @.str.124, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 57, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2, i32 2, ptr @.str.125, i32 1, ptr null, [5 x i32] [i32 9, i32 4, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1071618549, i32 -1071618549, ptr @.str.126, i32 3, ptr @do_ioctl_fs_ioc_fiemap, [5 x i32] [i32 9, i32 11, i32 59, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2146933247, i32 -2146933247, ptr @.str.127, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074292226, i32 1074292226, ptr @.str.128, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2146929151, i32 -2146929151, ptr @.str.129, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074296322, i32 1074296322, ptr @.str.130, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147195391, i32 -2147195391, ptr @.str.131, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074030082, i32 1074030082, ptr @.str.132, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147191295, i32 -2147191295, ptr @.str.133, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074034178, i32 1074034178, ptr @.str.134, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147456001, i32 1342215169, ptr @.str.135, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 61, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147456004, i32 1342215172, ptr @.str.136, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 61, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147456005, i32 1342215173, ptr @.str.137, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 61, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147456010, i32 1342215178, ptr @.str.138, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 61, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147456011, i32 1342215179, ptr @.str.139, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 61, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147456014, i32 1342215182, ptr @.str.140, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 61, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147456015, i32 1342215183, ptr @.str.141, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 61, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -27630, i32 -805268462, ptr @.str.142, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 64, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074304019, i32 1074304019, ptr @.str.143, i32 2, ptr null, [5 x i32] [i32 9, i32 8, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2146921447, i32 -2146921447, ptr @.str.144, i32 1, ptr null, [5 x i32] [i32 9, i32 8, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074304026, i32 1074304026, ptr @.str.145, i32 2, ptr null, [5 x i32] [i32 9, i32 8, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -27621, i32 -1006595045, ptr @.str.146, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 69, i32 0, i32 0] }, %struct.IOCTLEntry { i32 37916, i32 37916, ptr @.str.147, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 -27619, i32 -1006595043, ptr @.str.148, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 69, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -27618, i32 -805268450, ptr @.str.149, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 70, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -27613, i32 -1070033885, ptr @.str.150, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 65, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -27612, i32 -1070033884, ptr @.str.151, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 66, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -27608, i32 -1072655320, ptr @.str.152, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 74, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147456041, i32 1075352617, ptr @.str.153, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 76, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147456042, i32 1074828330, ptr @.str.154, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 77, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073769429, i32 -2144299989, ptr @.str.155, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 79, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147456044, i32 1077974060, ptr @.str.156, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 75, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073769427, i32 -2143251411, ptr @.str.157, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 75, i32 0, i32 0] }, %struct.IOCTLEntry { i32 37934, i32 37934, ptr @.str.158, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 -27596, i32 -1006070732, ptr @.str.159, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 73, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073769415, i32 -2145872839, ptr @.str.160, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 80, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147456057, i32 1076925497, ptr @.str.161, i32 2, ptr null, [5 x i32] [i32 9, i32 10, i32 2, i32 11, i32 80] }, %struct.IOCTLEntry { i32 -1073769415, i32 -2142727111, ptr @.str.162, i32 1, ptr null, [5 x i32] [i32 9, i32 10, i32 3, i32 11, i32 80] }, %struct.IOCTLEntry { i32 -27589, i32 -1070033861, ptr @.str.163, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 66, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073769412, i32 -2114415556, ptr @.str.164, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 63, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -27587, i32 -805268419, ptr @.str.165, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 72, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -27586, i32 -805268418, ptr @.str.166, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 67, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -43776, i32 -1072147200, ptr @.str.167, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 87, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -43774, i32 -1072147198, ptr @.str.168, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 88, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073785597, i32 -2147199741, ptr @.str.169, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073785596, i32 -2146937596, ptr @.str.170, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 89, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073785595, i32 -2147199739, ptr @.str.171, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147439880, i32 1090802952, ptr @.str.172, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 91, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073785590, i32 -2143791862, ptr @.str.173, i32 2, ptr @do_ioctl_usbdevfs_submiturb, [5 x i32] [i32 9, i32 11, i32 94, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21771, i32 21771, ptr @.str.174, i32 3, ptr @do_ioctl_usbdevfs_discardurb, [5 x i32] [i32 9, i32 11, i32 94, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147439884, i32 1074287884, ptr @.str.175, i32 1, ptr @do_ioctl_usbdevfs_reapurb, [5 x i32] [i32 9, i32 6, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147439885, i32 1074287885, ptr @.str.176, i32 1, ptr @do_ioctl_usbdevfs_reapurb, [5 x i32] [i32 9, i32 6, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073785586, i32 -2146413298, ptr @.str.177, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 90, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073785585, i32 -2147199729, ptr @.str.178, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073785584, i32 -2147199728, ptr @.str.179, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147439889, i32 1074287889, ptr @.str.180, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 92, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -43758, i32 -1072671470, ptr @.str.181, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 95, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073785581, i32 -2139073261, ptr @.str.182, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 96, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21780, i32 21780, ptr @.str.183, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 -1073785579, i32 -2147199723, ptr @.str.184, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21782, i32 21782, ptr @.str.185, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21783, i32 21783, ptr @.str.186, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 -1073785576, i32 -2147199720, ptr @.str.187, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073785575, i32 -2147199719, ptr @.str.188, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073785574, i32 -2147199718, ptr @.str.189, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073785573, i32 -2130160357, ptr @.str.190, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 97, i32 0, i32 0] }, %struct.IOCTLEntry { i32 2147439902, i32 1074025758, ptr @.str.191, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21791, i32 21791, ptr @.str.192, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 35075, i32 35075, ptr @.str.193, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35073, i32 35073, ptr @.str.194, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35077, i32 35077, ptr @.str.195, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35088, i32 35088, ptr @.str.196, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 9, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35091, i32 35091, ptr @.str.197, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 8, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35092, i32 35092, ptr @.str.198, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 8, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35093, i32 35093, ptr @.str.199, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35094, i32 35094, ptr @.str.200, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35097, i32 35097, ptr @.str.201, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35098, i32 35098, ptr @.str.202, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35095, i32 35095, ptr @.str.203, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35096, i32 35096, ptr @.str.204, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35099, i32 35099, ptr @.str.205, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35100, i32 35100, ptr @.str.206, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35111, i32 35111, ptr @.str.207, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35108, i32 35108, ptr @.str.208, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35138, i32 35138, ptr @.str.209, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35139, i32 35139, ptr @.str.210, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35101, i32 35101, ptr @.str.211, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 9, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35102, i32 35102, ptr @.str.212, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 9, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35105, i32 35105, ptr @.str.213, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 9, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35106, i32 35106, ptr @.str.214, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 9, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35184, i32 35184, ptr @.str.215, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 10, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35185, i32 35185, ptr @.str.216, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 10, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35113, i32 35113, ptr @.str.217, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 11, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35120, i32 35120, ptr @.str.218, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 11, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35103, i32 35103, ptr @.str.219, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 12, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35104, i32 35104, ptr @.str.220, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 12, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35121, i32 35121, ptr @.str.221, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35122, i32 35122, ptr @.str.222, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 7, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35123, i32 35123, ptr @.str.223, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 9, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35124, i32 35124, ptr @.str.224, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 8, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35125, i32 35125, ptr @.str.225, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 8, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35089, i32 35089, ptr @.str.226, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 35090, i32 35090, ptr @.str.227, i32 3, ptr @do_ioctl_ifconf, [5 x i32] [i32 9, i32 11, i32 13, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35109, i32 35109, ptr @.str.228, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35110, i32 35110, ptr @.str.229, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35155, i32 35155, ptr @.str.230, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 14, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35157, i32 35157, ptr @.str.231, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 14, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35156, i32 35156, ptr @.str.232, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 14, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35168, i32 35168, ptr @.str.233, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 14, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35170, i32 35170, ptr @.str.234, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 14, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35169, i32 35169, ptr @.str.235, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 14, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35585, i32 35585, ptr @.str.236, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 11, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35074, i32 35074, ptr @.str.237, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35076, i32 35076, ptr @.str.238, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35078, i32 35078, ptr @.str.239, i32 1, ptr @do_ioctl_SIOCGSTAMP, [5 x i32] [i32 9, i32 11, i32 32, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35079, i32 35079, ptr @.str.240, i32 1, ptr @do_ioctl_SIOCGSTAMPNS, [5 x i32] [i32 9, i32 11, i32 34, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2146399994, i32 -2146399994, ptr @.str.241, i32 1, ptr @do_ioctl_SIOCGSTAMP, [5 x i32] [i32 9, i32 11, i32 33, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2146399993, i32 -2146399993, ptr @.str.242, i32 1, ptr @do_ioctl_SIOCGSTAMPNS, [5 x i32] [i32 9, i32 11, i32 35, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147200512, i32 -2147200512, ptr @.str.243, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074024961, i32 1074024961, ptr @.str.244, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 20996, i32 20996, ptr @.str.245, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 20998, i32 20998, ptr @.str.246, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 20999, i32 20999, ptr @.str.247, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21249, i32 21249, ptr @.str.248, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21256, i32 21256, ptr @.str.249, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21255, i32 21255, ptr @.str.250, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21250, i32 21250, ptr @.str.251, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21257, i32 21257, ptr @.str.252, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21263, i32 21263, ptr @.str.253, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21273, i32 21273, ptr @.str.254, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21266, i32 21266, ptr @.str.255, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21251, i32 21251, ptr @.str.256, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21252, i32 21252, ptr @.str.257, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21253, i32 21253, ptr @.str.258, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21254, i32 21254, ptr @.str.259, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21258, i32 21258, ptr @.str.260, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21259, i32 21259, ptr @.str.261, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21262, i32 21262, ptr @.str.262, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 16, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21269, i32 21269, ptr @.str.263, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21268, i32 21268, ptr @.str.264, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21261, i32 21261, ptr @.str.265, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21260, i32 21260, ptr @.str.266, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21272, i32 21272, ptr @.str.267, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21264, i32 21264, ptr @.str.268, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21265, i32 21265, ptr @.str.269, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21267, i32 21267, ptr @.str.270, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21270, i32 21270, ptr @.str.271, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21271, i32 21271, ptr @.str.272, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21285, i32 21285, ptr @.str.273, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21280, i32 21280, ptr @.str.274, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21281, i32 21281, ptr @.str.275, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21282, i32 21282, ptr @.str.276, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21283, i32 21283, ptr @.str.277, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21286, i32 21286, ptr @.str.278, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21287, i32 21287, ptr @.str.279, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21378, i32 21378, ptr @.str.280, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459194, i32 -1073459194, ptr @.str.281, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459196, i32 -1073459196, ptr @.str.282, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201009, i32 -2147201009, ptr @.str.283, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201013, i32 -2147201013, ptr @.str.284, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073786863, i32 -2146676719, ptr @.str.285, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 22, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073786862, i32 -2146676718, ptr @.str.286, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 22, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073786867, i32 -2146414579, ptr @.str.287, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 21, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073786868, i32 -2146414580, ptr @.str.288, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 21, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201008, i32 -2147201008, ptr @.str.289, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073786861, i32 -2146414573, ptr @.str.290, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 23, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073786860, i32 -2146414572, ptr @.str.291, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 23, i32 0, i32 0] }, %struct.IOCTLEntry { i32 20494, i32 20494, ptr @.str.292, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 20488, i32 20488, ptr @.str.293, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 20480, i32 20480, ptr @.str.294, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 20502, i32 20502, ptr @.str.295, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 -1073459195, i32 -1073459195, ptr @.str.296, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459190, i32 -1073459190, ptr @.str.297, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 20501, i32 20501, ptr @.str.298, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 1074024464, i32 1074024464, ptr @.str.299, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459198, i32 -1073459198, ptr @.str.300, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459197, i32 -1073459197, ptr @.str.301, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459191, i32 -1073459191, ptr @.str.302, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 20481, i32 20481, ptr @.str.303, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 -2141434523, i32 -2141434523, ptr @.str.304, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1065333402, i32 -1065333402, ptr @.str.305, i32 0, ptr null, [5 x i32] [i32 6, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459857, i32 -1073459857, ptr @.str.306, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459856, i32 -1073459856, ptr @.str.307, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459855, i32 -1073459855, ptr @.str.308, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459854, i32 -1073459854, ptr @.str.309, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459853, i32 -1073459853, ptr @.str.310, i32 3, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201792, i32 -2147201792, ptr @.str.311, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201791, i32 -2147201791, ptr @.str.312, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201790, i32 -2147201790, ptr @.str.313, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201789, i32 -2147201789, ptr @.str.314, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201788, i32 -2147201788, ptr @.str.315, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201787, i32 -2147201787, ptr @.str.316, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201786, i32 -2147201786, ptr @.str.317, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201785, i32 -2147201785, ptr @.str.318, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201784, i32 -2147201784, ptr @.str.319, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201783, i32 -2147201783, ptr @.str.320, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201782, i32 -2147201782, ptr @.str.321, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201781, i32 -2147201781, ptr @.str.322, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201780, i32 -2147201780, ptr @.str.323, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201779, i32 -2147201779, ptr @.str.324, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201778, i32 -2147201778, ptr @.str.325, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201777, i32 -2147201777, ptr @.str.326, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201776, i32 -2147201776, ptr @.str.327, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201761, i32 -2147201761, ptr @.str.328, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201761, i32 -2147201761, ptr @.str.329, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201761, i32 -2147201761, ptr @.str.330, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201537, i32 -2147201537, ptr @.str.331, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201538, i32 -2147201538, ptr @.str.332, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201539, i32 -2147201539, ptr @.str.333, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201541, i32 -2147201541, ptr @.str.334, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147201540, i32 -2147201540, ptr @.str.335, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459968, i32 -1073459968, ptr @.str.336, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459967, i32 -1073459967, ptr @.str.337, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459966, i32 -1073459966, ptr @.str.338, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459965, i32 -1073459965, ptr @.str.339, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459964, i32 -1073459964, ptr @.str.340, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459963, i32 -1073459963, ptr @.str.341, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459962, i32 -1073459962, ptr @.str.342, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459961, i32 -1073459961, ptr @.str.343, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459960, i32 -1073459960, ptr @.str.344, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459959, i32 -1073459959, ptr @.str.345, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459958, i32 -1073459958, ptr @.str.346, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459957, i32 -1073459957, ptr @.str.347, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459956, i32 -1073459956, ptr @.str.348, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459955, i32 -1073459955, ptr @.str.349, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459954, i32 -1073459954, ptr @.str.350, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459953, i32 -1073459953, ptr @.str.351, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459952, i32 -1073459952, ptr @.str.352, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459937, i32 -1073459937, ptr @.str.353, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459937, i32 -1073459937, ptr @.str.354, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459937, i32 -1073459937, ptr @.str.355, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073459713, i32 -1073459713, ptr @.str.356, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147200000, i32 -2147200000, ptr @.str.357, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1072409599, i32 -1072409599, ptr @.str.358, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 25, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1057467389, i32 -1057467389, ptr @.str.359, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 26, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1078481924, i32 1078481924, ptr @.str.360, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 27, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1068477435, i32 -1068477435, ptr @.str.361, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 28, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1077171216, i32 1077171216, ptr @.str.362, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 29, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2132257775, i32 -2132257775, ptr @.str.363, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 30, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1079006226, i32 1079006226, ptr @.str.364, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 31, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2141170668, i32 -2141170668, ptr @.str.365, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 36, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21664, i32 21664, ptr @.str.366, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21665, i32 21665, ptr @.str.367, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21666, i32 21666, ptr @.str.368, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 21667, i32 21667, ptr @.str.369, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 769, i32 769, ptr @.str.370, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 17, i32 0, i32 0] }, %struct.IOCTLEntry { i32 770, i32 770, ptr @.str.371, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 772, i32 772, ptr @.str.372, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 781, i32 781, ptr @.str.373, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 776, i32 776, ptr @.str.374, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 778, i32 778, ptr @.str.375, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 779, i32 779, ptr @.str.376, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 777, i32 777, ptr @.str.377, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 799, i32 799, ptr @.str.378, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 802, i32 802, ptr @.str.379, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 801, i32 801, ptr @.str.380, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 803, i32 803, ptr @.str.381, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 805, i32 805, ptr @.str.382, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 806, i32 806, ptr @.str.383, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 804, i32 804, ptr @.str.384, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 807, i32 807, ptr @.str.385, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -1073778175, i32 -2110754303, ptr @.str.386, i32 1, ptr null, [5 x i32] [i32 9, i32 10, i32 2, i32 11, i32 18] }, %struct.IOCTLEntry { i32 -1073778174, i32 -2110754302, ptr @.str.387, i32 1, ptr null, [5 x i32] [i32 9, i32 10, i32 2, i32 11, i32 18] }, %struct.IOCTLEntry { i32 19456, i32 19456, ptr @.str.388, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19457, i32 19457, ptr @.str.389, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19458, i32 19458, ptr @.str.390, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 37, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19459, i32 19459, ptr @.str.391, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 37, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19460, i32 19460, ptr @.str.392, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 38, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19461, i32 19461, ptr @.str.393, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 38, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19462, i32 19462, ptr @.str.394, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19463, i32 19463, ptr @.str.395, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19464, i32 19464, ptr @.str.396, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19465, i32 19465, ptr @.str.397, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19466, i32 19466, ptr @.str.398, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 39, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19584, i32 19584, ptr @.str.399, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19585, i32 19585, ptr @.str.400, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 19586, i32 19586, ptr @.str.401, i32 0, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry { i32 1074294017, i32 1074294017, ptr @.str.402, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 40, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2144310014, i32 -2144310014, ptr @.str.403, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 41, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2146931453, i32 -2146931453, ptr @.str.404, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 42, i32 0, i32 0] }, %struct.IOCTLEntry { i32 17922, i32 17922, ptr @.str.405, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 43, i32 0, i32 0] }, %struct.IOCTLEntry { i32 17920, i32 17920, ptr @.str.406, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 44, i32 0, i32 0] }, %struct.IOCTLEntry { i32 17921, i32 17921, ptr @.str.407, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 44, i32 0, i32 0] }, %struct.IOCTLEntry { i32 17924, i32 17924, ptr @.str.408, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 45, i32 0, i32 0] }, %struct.IOCTLEntry { i32 17925, i32 17925, ptr @.str.409, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 45, i32 0, i32 0] }, %struct.IOCTLEntry { i32 17926, i32 17926, ptr @.str.410, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 44, i32 0, i32 0] }, %struct.IOCTLEntry { i32 17935, i32 17935, ptr @.str.411, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 46, i32 0, i32 0] }, %struct.IOCTLEntry { i32 17936, i32 17936, ptr @.str.412, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 46, i32 0, i32 0] }, %struct.IOCTLEntry { i32 22016, i32 22016, ptr @.str.413, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 22019, i32 22019, ptr @.str.414, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 47, i32 0, i32 0] }, %struct.IOCTLEntry { i32 22022, i32 22022, ptr @.str.415, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 22023, i32 22023, ptr @.str.416, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 22027, i32 22027, ptr @.str.417, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 22028, i32 22028, ptr @.str.418, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 22017, i32 22017, ptr @.str.419, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 48, i32 0, i32 0] }, %struct.IOCTLEntry { i32 22018, i32 22018, ptr @.str.420, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 48, i32 0, i32 0] }, %struct.IOCTLEntry { i32 22021, i32 22021, ptr @.str.421, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 22024, i32 22024, ptr @.str.422, i32 0, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -768, i32 -1053229824, ptr @.str.423, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -767, i32 -1053229823, ptr @.str.424, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -766, i32 -1053229822, ptr @.str.425, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -765, i32 -1053229821, ptr @.str.426, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -764, i32 -1053229820, ptr @.str.427, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -763, i32 -1053229819, ptr @.str.428, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -762, i32 -1053229818, ptr @.str.429, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -761, i32 -1053229817, ptr @.str.430, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -760, i32 -1053229816, ptr @.str.431, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -759, i32 -1053229815, ptr @.str.432, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -758, i32 -1053229814, ptr @.str.433, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -757, i32 -1053229813, ptr @.str.434, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -756, i32 -1053229812, ptr @.str.435, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -755, i32 -1053229811, ptr @.str.436, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -754, i32 -1053229810, ptr @.str.437, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -753, i32 -1053229809, ptr @.str.438, i32 3, ptr @do_ioctl_dm, [5 x i32] [i32 9, i32 11, i32 49, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35083, i32 35083, ptr @.str.439, i32 2, ptr @do_ioctl_rt, [5 x i32] [i32 9, i32 11, i32 5, i32 0, i32 0] }, %struct.IOCTLEntry { i32 35084, i32 35084, ptr @.str.440, i32 2, ptr @do_ioctl_rt, [5 x i32] [i32 9, i32 11, i32 5, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -39936, i32 -1069521920, ptr @.str.441, i32 3, ptr @do_ioctl_drm, [5 x i32] [i32 9, i32 11, i32 55, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -39866, i32 -1072667578, ptr @.str.442, i32 3, ptr @do_ioctl_drm_i915, [5 x i32] [i32 9, i32 11, i32 56, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025673, i32 1074025673, ptr @.str.443, i32 2, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025674, i32 1074025674, ptr @.str.444, i32 3, ptr null, [5 x i32] [i32 9, i32 11, i32 8, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025675, i32 1074025675, ptr @.str.445, i32 2, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025676, i32 1074025676, ptr @.str.446, i32 2, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025677, i32 1074025677, ptr @.str.447, i32 2, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025678, i32 1074025678, ptr @.str.448, i32 2, ptr null, [5 x i32] [i32 3, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147199793, i32 -2147199793, ptr @.str.449, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025680, i32 1074025680, ptr @.str.450, i32 2, ptr null, [5 x i32] [i32 4, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025681, i32 1074025681, ptr @.str.451, i32 2, ptr @do_ioctl_TUNSETTXFILTER, [5 x i32] [i32 6, i32 0, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147199790, i32 -2147199790, ptr @.str.452, i32 1, ptr null, [5 x i32] [i32 9, i32 11, i32 8, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147199789, i32 -2147199789, ptr @.str.453, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025684, i32 1074025684, ptr @.str.454, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147199785, i32 -2147199785, ptr @.str.455, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025688, i32 1074025688, ptr @.str.456, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025689, i32 1074025689, ptr @.str.457, i32 2, ptr null, [5 x i32] [i32 9, i32 11, i32 8, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025690, i32 1074025690, ptr @.str.458, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025692, i32 1074025692, ptr @.str.459, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147199779, i32 -2147199779, ptr @.str.460, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025694, i32 1074025694, ptr @.str.461, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147199777, i32 -2147199777, ptr @.str.462, i32 1, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147199776, i32 -2147199776, ptr @.str.463, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 -2147199775, i32 -2147199775, ptr @.str.464, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 1074025698, i32 1074025698, ptr @.str.465, i32 2, ptr null, [5 x i32] [i32 9, i32 3, i32 0, i32 0, i32 0] }, %struct.IOCTLEntry { i32 21731, i32 21731, ptr @.str.466, i32 1, ptr null, [5 x i32] zeroinitializer }, %struct.IOCTLEntry zeroinitializer], align 16
@.str.467 = private unnamed_addr constant [8 x i8] c"termios\00", align 1
@struct_termios_def = internal constant %struct.StructEntry { ptr null, i32 0, [2 x ptr] zeroinitializer, [2 x ptr] [ptr @host_to_target_termios, ptr @target_to_host_termios], ptr @print_termios, [2 x i32] [i32 36, i32 36], [2 x i32] [i32 4, i32 4], ptr null }, align 8
@.str.468 = private unnamed_addr constant [8 x i8] c"winsize\00", align 1
@struct_winsize_def = internal constant [5 x i32] [i32 2, i32 2, i32 2, i32 2, i32 0], align 16
@.str.469 = private unnamed_addr constant [24 x i8] c"serial_multiport_struct\00", align 1
@struct_serial_multiport_struct_def = internal constant [18 x i32] [i32 3, i32 3, i32 1, i32 1, i32 3, i32 1, i32 1, i32 3, i32 1, i32 1, i32 3, i32 1, i32 1, i32 3, i32 10, i32 32, i32 3, i32 0], align 16
@.str.470 = private unnamed_addr constant [23 x i8] c"serial_icounter_struct\00", align 1
@struct_serial_icounter_struct_def = internal constant [8 x i32] [i32 3, i32 3, i32 3, i32 3, i32 10, i32 16, i32 3, i32 0], align 16
@.str.471 = private unnamed_addr constant [9 x i8] c"sockaddr\00", align 1
@struct_sockaddr_def = internal constant [5 x i32] [i32 2, i32 10, i32 14, i32 1, i32 0], align 16
@.str.472 = private unnamed_addr constant [8 x i8] c"rtentry\00", align 1
@struct_rtentry_def = internal constant [17 x i32] [i32 5, i32 11, i32 4, i32 11, i32 4, i32 11, i32 4, i32 2, i32 2, i32 5, i32 6, i32 2, i32 6, i32 5, i32 5, i32 2, i32 0], align 16
@.str.473 = private unnamed_addr constant [6 x i8] c"ifmap\00", align 1
@struct_ifmap_def = internal constant [10 x i32] [i32 5, i32 5, i32 2, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 0], align 16
@.str.474 = private unnamed_addr constant [15 x i8] c"sockaddr_ifreq\00", align 1
@struct_sockaddr_ifreq_def = internal constant [6 x i32] [i32 10, i32 16, i32 1, i32 11, i32 4, i32 0], align 16
@.str.475 = private unnamed_addr constant [12 x i8] c"short_ifreq\00", align 1
@struct_short_ifreq_def = internal constant [5 x i32] [i32 10, i32 16, i32 1, i32 2, i32 0], align 16
@.str.476 = private unnamed_addr constant [10 x i8] c"int_ifreq\00", align 1
@struct_int_ifreq_def = internal constant [5 x i32] [i32 10, i32 16, i32 1, i32 3, i32 0], align 16
@.str.477 = private unnamed_addr constant [12 x i8] c"ifmap_ifreq\00", align 1
@struct_ifmap_ifreq_def = internal constant [6 x i32] [i32 10, i32 16, i32 1, i32 11, i32 6, i32 0], align 16
@.str.478 = private unnamed_addr constant [11 x i8] c"char_ifreq\00", align 1
@struct_char_ifreq_def = internal constant [7 x i32] [i32 10, i32 16, i32 1, i32 10, i32 16, i32 1, i32 0], align 16
@.str.479 = private unnamed_addr constant [10 x i8] c"ptr_ifreq\00", align 1
@struct_ptr_ifreq_def = internal constant [5 x i32] [i32 10, i32 16, i32 1, i32 6, i32 0], align 16
@.str.480 = private unnamed_addr constant [7 x i8] c"ifconf\00", align 1
@struct_ifconf_def = internal constant [3 x i32] [i32 3, i32 6, i32 0], align 4
@.str.481 = private unnamed_addr constant [7 x i8] c"arpreq\00", align 1
@struct_arpreq_def = internal constant [11 x i32] [i32 11, i32 4, i32 11, i32 4, i32 3, i32 11, i32 4, i32 10, i32 16, i32 1, i32 0], align 16
@.str.482 = private unnamed_addr constant [11 x i8] c"arpreq_old\00", align 1
@struct_arpreq_old_def = internal constant [8 x i32] [i32 11, i32 4, i32 11, i32 4, i32 3, i32 11, i32 4, i32 0], align 16
@.str.483 = private unnamed_addr constant [17 x i8] c"cdrom_read_audio\00", align 1
@struct_cdrom_read_audio_def = internal constant [9 x i32] [i32 1, i32 1, i32 1, i32 1, i32 1, i32 3, i32 6, i32 0, i32 0], align 16
@.str.484 = private unnamed_addr constant [12 x i8] c"hd_geometry\00", align 1
@struct_hd_geometry_def = internal constant [5 x i32] [i32 1, i32 1, i32 2, i32 5, i32 0], align 16
@.str.485 = private unnamed_addr constant [7 x i8] c"dirent\00", align 1
@struct_dirent_def = internal constant [7 x i32] [i32 4, i32 4, i32 2, i32 10, i32 256, i32 1, i32 0], align 16
@.str.486 = private unnamed_addr constant [8 x i8] c"kbentry\00", align 1
@struct_kbentry_def = internal constant [4 x i32] [i32 1, i32 1, i32 2, i32 0], align 16
@.str.487 = private unnamed_addr constant [9 x i8] c"kbsentry\00", align 1
@struct_kbsentry_def = internal constant [5 x i32] [i32 1, i32 10, i32 512, i32 1, i32 0], align 16
@.str.488 = private unnamed_addr constant [15 x i8] c"audio_buf_info\00", align 1
@struct_audio_buf_info_def = internal constant [5 x i32] [i32 3, i32 3, i32 3, i32 3, i32 0], align 16
@.str.489 = private unnamed_addr constant [11 x i8] c"count_info\00", align 1
@struct_count_info_def = internal constant [4 x i32] [i32 3, i32 3, i32 3, i32 0], align 16
@.str.490 = private unnamed_addr constant [13 x i8] c"buffmem_desc\00", align 1
@struct_buffmem_desc_def = internal constant [3 x i32] [i32 6, i32 3, i32 0], align 4
@.str.491 = private unnamed_addr constant [11 x i8] c"mixer_info\00", align 1
@struct_mixer_info_def = internal constant [11 x i32] [i32 10, i32 16, i32 1, i32 10, i32 32, i32 1, i32 3, i32 10, i32 10, i32 3, i32 0], align 16
@.str.492 = private unnamed_addr constant [13 x i8] c"snd_timer_id\00", align 1
@struct_snd_timer_id_def = internal constant [6 x i32] [i32 3, i32 3, i32 3, i32 3, i32 3, i32 0], align 16
@.str.493 = private unnamed_addr constant [16 x i8] c"snd_timer_ginfo\00", align 1
@struct_snd_timer_ginfo_def = internal constant [19 x i32] [i32 11, i32 25, i32 3, i32 3, i32 10, i32 64, i32 1, i32 10, i32 80, i32 1, i32 5, i32 5, i32 5, i32 5, i32 3, i32 10, i32 32, i32 1, i32 0], align 16
@.str.494 = private unnamed_addr constant [18 x i8] c"snd_timer_gparams\00", align 1
@struct_snd_timer_gparams_def = internal constant [8 x i32] [i32 11, i32 25, i32 5, i32 5, i32 10, i32 32, i32 1, i32 0], align 16
@.str.495 = private unnamed_addr constant [18 x i8] c"snd_timer_gstatus\00", align 1
@struct_snd_timer_gstatus_def = internal constant [9 x i32] [i32 11, i32 25, i32 5, i32 5, i32 5, i32 10, i32 32, i32 1, i32 0], align 16
@.str.496 = private unnamed_addr constant [17 x i8] c"snd_timer_select\00", align 1
@struct_snd_timer_select_def = internal constant [6 x i32] [i32 11, i32 25, i32 10, i32 32, i32 1, i32 0], align 16
@.str.497 = private unnamed_addr constant [15 x i8] c"snd_timer_info\00", align 1
@struct_snd_timer_info_def = internal constant [14 x i32] [i32 3, i32 3, i32 10, i32 64, i32 1, i32 10, i32 80, i32 1, i32 5, i32 5, i32 10, i32 64, i32 1, i32 0], align 16
@.str.498 = private unnamed_addr constant [17 x i8] c"snd_timer_params\00", align 1
@struct_snd_timer_params_def = internal constant [9 x i32] [i32 3, i32 3, i32 3, i32 3, i32 3, i32 10, i32 60, i32 1, i32 0], align 16
@.str.499 = private unnamed_addr constant [8 x i8] c"timeval\00", align 1
@struct_timeval_def = internal constant [3 x i32] [i32 4, i32 4, i32 0], align 4
@.str.500 = private unnamed_addr constant [21 x i8] c"_kernel_sock_timeval\00", align 1
@struct__kernel_sock_timeval_def = internal constant [3 x i32] [i32 7, i32 7, i32 0], align 4
@.str.501 = private unnamed_addr constant [9 x i8] c"timespec\00", align 1
@struct_timespec_def = internal constant [3 x i32] [i32 4, i32 4, i32 0], align 4
@.str.502 = private unnamed_addr constant [17 x i8] c"_kernel_timespec\00", align 1
@struct__kernel_timespec_def = internal constant [3 x i32] [i32 7, i32 7, i32 0], align 4
@.str.503 = private unnamed_addr constant [17 x i8] c"snd_timer_status\00", align 1
@struct_snd_timer_status_def = internal constant [10 x i32] [i32 11, i32 34, i32 3, i32 3, i32 3, i32 3, i32 10, i32 64, i32 1, i32 0], align 16
@.str.504 = private unnamed_addr constant [10 x i8] c"loop_info\00", align 1
@struct_loop_info_def = internal constant [21 x i32] [i32 3, i32 12, i32 5, i32 12, i32 3, i32 3, i32 3, i32 3, i32 10, i32 64, i32 1, i32 10, i32 32, i32 1, i32 10, i32 2, i32 5, i32 10, i32 4, i32 1, i32 0], align 16
@.str.505 = private unnamed_addr constant [12 x i8] c"loop_info64\00", align 1
@struct_loop_info64_def = internal constant [22 x i32] [i32 8, i32 8, i32 8, i32 8, i32 8, i32 3, i32 3, i32 3, i32 3, i32 10, i32 64, i32 1, i32 10, i32 64, i32 1, i32 10, i32 32, i32 1, i32 10, i32 2, i32 8, i32 0], align 16
@.str.506 = private unnamed_addr constant [12 x i8] c"loop_config\00", align 1
@struct_loop_config_def = internal constant [8 x i32] [i32 3, i32 3, i32 11, i32 38, i32 10, i32 8, i32 8, i32 0], align 16
@.str.507 = private unnamed_addr constant [5 x i8] c"mtop\00", align 1
@struct_mtop_def = internal constant [3 x i32] [i32 2, i32 3, i32 0], align 4
@.str.508 = private unnamed_addr constant [6 x i8] c"mtget\00", align 1
@struct_mtget_def = internal constant [8 x i32] [i32 4, i32 4, i32 4, i32 4, i32 4, i32 3, i32 3, i32 0], align 16
@.str.509 = private unnamed_addr constant [6 x i8] c"mtpos\00", align 1
@struct_mtpos_def = internal constant [2 x i32] [i32 4, i32 0], align 4
@.str.510 = private unnamed_addr constant [18 x i8] c"fb_fix_screeninfo\00", align 1
@struct_fb_fix_screeninfo_def = internal constant [19 x i32] [i32 10, i32 16, i32 1, i32 5, i32 3, i32 3, i32 3, i32 3, i32 2, i32 2, i32 2, i32 3, i32 5, i32 3, i32 3, i32 10, i32 3, i32 1, i32 0], align 16
@.str.511 = private unnamed_addr constant [18 x i8] c"fb_var_screeninfo\00", align 1
@struct_fb_var_screeninfo_def = internal constant [39 x i32] [i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 10, i32 3, i32 3, i32 10, i32 3, i32 3, i32 10, i32 3, i32 3, i32 10, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 10, i32 5, i32 3, i32 0], align 16
@.str.512 = private unnamed_addr constant [8 x i8] c"fb_cmap\00", align 1
@struct_fb_cmap_def = internal constant [7 x i32] [i32 3, i32 3, i32 6, i32 6, i32 6, i32 6, i32 0], align 16
@.str.513 = private unnamed_addr constant [13 x i8] c"fb_con2fbmap\00", align 1
@struct_fb_con2fbmap_def = internal constant [3 x i32] [i32 3, i32 3, i32 0], align 4
@.str.514 = private unnamed_addr constant [8 x i8] c"vt_stat\00", align 1
@struct_vt_stat_def = internal constant [4 x i32] [i32 2, i32 2, i32 2, i32 0], align 16
@.str.515 = private unnamed_addr constant [8 x i8] c"vt_mode\00", align 1
@struct_vt_mode_def = internal constant [6 x i32] [i32 1, i32 1, i32 2, i32 2, i32 2, i32 0], align 16
@.str.516 = private unnamed_addr constant [9 x i8] c"dm_ioctl\00", align 1
@struct_dm_ioctl_def = internal constant [21 x i32] [i32 10, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 8, i32 10, i32 128, i32 1, i32 10, i32 129, i32 1, i32 10, i32 7, i32 1, i32 0], align 16
@.str.517 = private unnamed_addr constant [15 x i8] c"dm_target_spec\00", align 1
@struct_dm_target_spec_def = internal constant [8 x i32] [i32 8, i32 8, i32 3, i32 3, i32 10, i32 16, i32 1, i32 0], align 16
@.str.518 = private unnamed_addr constant [15 x i8] c"dm_target_deps\00", align 1
@struct_dm_target_deps_def = internal constant [3 x i32] [i32 3, i32 3, i32 0], align 4
@.str.519 = private unnamed_addr constant [13 x i8] c"dm_name_list\00", align 1
@struct_dm_name_list_def = internal constant [3 x i32] [i32 8, i32 3, i32 0], align 4
@.str.520 = private unnamed_addr constant [19 x i8] c"dm_target_versions\00", align 1
@struct_dm_target_versions_def = internal constant [5 x i32] [i32 3, i32 10, i32 3, i32 3, i32 0], align 16
@.str.521 = private unnamed_addr constant [14 x i8] c"dm_target_msg\00", align 1
@struct_dm_target_msg_def = internal constant [2 x i32] [i32 8, i32 0], align 4
@.str.522 = private unnamed_addr constant [12 x i8] c"drm_version\00", align 1
@struct_drm_version_def = internal constant [10 x i32] [i32 3, i32 3, i32 3, i32 5, i32 6, i32 5, i32 6, i32 5, i32 6, i32 0], align 16
@.str.523 = private unnamed_addr constant [18 x i8] c"drm_i915_getparam\00", align 1
@struct_drm_i915_getparam_def = internal constant [3 x i32] [i32 3, i32 6, i32 0], align 4
@.str.524 = private unnamed_addr constant [17 x i8] c"file_clone_range\00", align 1
@struct_file_clone_range_def = internal constant [5 x i32] [i32 7, i32 8, i32 8, i32 8, i32 0], align 16
@.str.525 = private unnamed_addr constant [14 x i8] c"fiemap_extent\00", align 1
@struct_fiemap_extent_def = internal constant [11 x i32] [i32 8, i32 8, i32 8, i32 10, i32 2, i32 8, i32 3, i32 10, i32 3, i32 3, i32 0], align 16
@.str.526 = private unnamed_addr constant [7 x i8] c"fiemap\00", align 1
@struct_fiemap_def = internal constant [7 x i32] [i32 8, i32 8, i32 3, i32 3, i32 3, i32 3, i32 0], align 16
@.str.527 = private unnamed_addr constant [16 x i8] c"blkpg_partition\00", align 1
@struct_blkpg_partition_def = internal constant [10 x i32] [i32 7, i32 7, i32 3, i32 10, i32 64, i32 1, i32 10, i32 64, i32 1, i32 0], align 16
@.str.528 = private unnamed_addr constant [21 x i8] c"btrfs_ioctl_vol_args\00", align 1
@struct_btrfs_ioctl_vol_args_def = internal constant [5 x i32] [i32 7, i32 10, i32 4088, i32 1, i32 0], align 16
@.str.529 = private unnamed_addr constant [21 x i8] c"btrfs_ioctl_timespec\00", align 1
@struct_btrfs_ioctl_timespec_def = internal constant [3 x i32] [i32 8, i32 3, i32 0], align 4
@.str.530 = private unnamed_addr constant [33 x i8] c"btrfs_ioctl_get_subvol_info_args\00", align 1
@struct_btrfs_ioctl_get_subvol_info_args_def = internal constant [33 x i32] [i32 8, i32 10, i32 256, i32 1, i32 8, i32 8, i32 8, i32 8, i32 10, i32 16, i32 1, i32 10, i32 16, i32 1, i32 10, i32 16, i32 1, i32 8, i32 8, i32 8, i32 8, i32 11, i32 62, i32 11, i32 62, i32 11, i32 62, i32 11, i32 62, i32 10, i32 8, i32 8, i32 0], align 16
@.str.531 = private unnamed_addr constant [28 x i8] c"btrfs_ioctl_ino_lookup_args\00", align 1
@struct_btrfs_ioctl_ino_lookup_args_def = internal constant [6 x i32] [i32 8, i32 8, i32 10, i32 4080, i32 1, i32 0], align 16
@.str.532 = private unnamed_addr constant [26 x i8] c"btrfs_ioctl_ino_path_args\00", align 1
@struct_btrfs_ioctl_ino_path_args_def = internal constant [7 x i32] [i32 8, i32 8, i32 10, i32 4, i32 8, i32 8, i32 0], align 16
@.str.533 = private unnamed_addr constant [29 x i8] c"btrfs_ioctl_logical_ino_args\00", align 1
@struct_btrfs_ioctl_logical_ino_args_def = internal constant [8 x i32] [i32 8, i32 8, i32 10, i32 3, i32 8, i32 8, i32 8, i32 0], align 16
@.str.534 = private unnamed_addr constant [33 x i8] c"btrfs_ioctl_ino_lookup_user_args\00", align 1
@struct_btrfs_ioctl_ino_lookup_user_args_def = internal constant [9 x i32] [i32 8, i32 8, i32 10, i32 256, i32 1, i32 10, i32 3824, i32 1, i32 0], align 16
@.str.535 = private unnamed_addr constant [21 x i8] c"btrfs_scrub_progress\00", align 1
@struct_btrfs_scrub_progress_def = internal constant [16 x i32] [i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 0], align 16
@.str.536 = private unnamed_addr constant [23 x i8] c"btrfs_ioctl_scrub_args\00", align 1
@struct_btrfs_ioctl_scrub_args_def = internal constant [10 x i32] [i32 8, i32 8, i32 8, i32 8, i32 11, i32 68, i32 10, i32 109, i32 8, i32 0], align 16
@.str.537 = private unnamed_addr constant [26 x i8] c"btrfs_ioctl_dev_info_args\00", align 1
@struct_btrfs_ioctl_dev_info_args_def = internal constant [13 x i32] [i32 8, i32 10, i32 16, i32 1, i32 8, i32 8, i32 10, i32 379, i32 8, i32 10, i32 1024, i32 1, i32 0], align 16
@.str.538 = private unnamed_addr constant [8 x i8] c"rootref\00", align 1
@struct_rootref_def = internal constant [3 x i32] [i32 8, i32 8, i32 0], align 4
@.str.539 = private unnamed_addr constant [36 x i8] c"btrfs_ioctl_get_subvol_rootref_args\00", align 1
@struct_btrfs_ioctl_get_subvol_rootref_args_def = internal constant [10 x i32] [i32 8, i32 10, i32 255, i32 11, i32 71, i32 1, i32 10, i32 7, i32 1, i32 0], align 16
@.str.540 = private unnamed_addr constant [26 x i8] c"btrfs_ioctl_get_dev_stats\00", align 1
@struct_btrfs_ioctl_get_dev_stats_def = internal constant [10 x i32] [i32 8, i32 8, i32 8, i32 10, i32 5, i32 8, i32 10, i32 121, i32 8, i32 0], align 16
@.str.541 = private unnamed_addr constant [27 x i8] c"btrfs_ioctl_quota_ctl_args\00", align 1
@struct_btrfs_ioctl_quota_ctl_args_def = internal constant [3 x i32] [i32 8, i32 8, i32 0], align 4
@.str.542 = private unnamed_addr constant [30 x i8] c"btrfs_ioctl_quota_rescan_args\00", align 1
@struct_btrfs_ioctl_quota_rescan_args_def = internal constant [6 x i32] [i32 8, i32 8, i32 10, i32 6, i32 8, i32 0], align 16
@.str.543 = private unnamed_addr constant [31 x i8] c"btrfs_ioctl_qgroup_assign_args\00", align 1
@struct_btrfs_ioctl_qgroup_assign_args_def = internal constant [4 x i32] [i32 8, i32 8, i32 8, i32 0], align 16
@.str.544 = private unnamed_addr constant [31 x i8] c"btrfs_ioctl_qgroup_create_args\00", align 1
@struct_btrfs_ioctl_qgroup_create_args_def = internal constant [3 x i32] [i32 8, i32 8, i32 0], align 4
@.str.545 = private unnamed_addr constant [19 x i8] c"btrfs_qgroup_limit\00", align 1
@struct_btrfs_qgroup_limit_def = internal constant [6 x i32] [i32 8, i32 8, i32 8, i32 8, i32 8, i32 0], align 16
@.str.546 = private unnamed_addr constant [30 x i8] c"btrfs_ioctl_qgroup_limit_args\00", align 1
@struct_btrfs_ioctl_qgroup_limit_args_def = internal constant [4 x i32] [i32 8, i32 11, i32 78, i32 0], align 16
@.str.547 = private unnamed_addr constant [26 x i8] c"btrfs_ioctl_feature_flags\00", align 1
@struct_btrfs_ioctl_feature_flags_def = internal constant [4 x i32] [i32 8, i32 8, i32 8, i32 0], align 16
@.str.548 = private unnamed_addr constant [9 x i8] c"rtc_time\00", align 1
@struct_rtc_time_def = internal constant [10 x i32] [i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 0], align 16
@.str.549 = private unnamed_addr constant [11 x i8] c"rtc_wkalrm\00", align 1
@struct_rtc_wkalrm_def = internal constant [5 x i32] [i32 1, i32 1, i32 11, i32 81, i32 0], align 16
@.str.550 = private unnamed_addr constant [13 x i8] c"rtc_pll_info\00", align 1
@struct_rtc_pll_info_def = internal constant [8 x i32] [i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 4, i32 0], align 16
@.str.551 = private unnamed_addr constant [16 x i8] c"blkpg_ioctl_arg\00", align 1
@struct_blkpg_ioctl_arg_def = internal constant [5 x i32] [i32 3, i32 3, i32 3, i32 6, i32 0], align 16
@.str.552 = private unnamed_addr constant [13 x i8] c"format_descr\00", align 1
@struct_format_descr_def = internal constant [4 x i32] [i32 3, i32 3, i32 3, i32 0], align 16
@.str.553 = private unnamed_addr constant [18 x i8] c"floppy_max_errors\00", align 1
@struct_floppy_max_errors_def = internal constant [6 x i32] [i32 3, i32 3, i32 3, i32 3, i32 3, i32 0], align 16
@.str.554 = private unnamed_addr constant [22 x i8] c"usbdevfs_ctrltransfer\00", align 1
@struct_usbdevfs_ctrltransfer_def = internal constant [8 x i32] [i32 1, i32 1, i32 2, i32 2, i32 2, i32 3, i32 6, i32 0], align 16
@.str.555 = private unnamed_addr constant [22 x i8] c"usbdevfs_bulktransfer\00", align 1
@struct_usbdevfs_bulktransfer_def = internal constant [5 x i32] [i32 3, i32 3, i32 3, i32 6, i32 0], align 16
@.str.556 = private unnamed_addr constant [22 x i8] c"usbdevfs_setinterface\00", align 1
@struct_usbdevfs_setinterface_def = internal constant [3 x i32] [i32 3, i32 3, i32 0], align 4
@.str.557 = private unnamed_addr constant [26 x i8] c"usbdevfs_disconnectsignal\00", align 1
@struct_usbdevfs_disconnectsignal_def = internal constant [3 x i32] [i32 3, i32 6, i32 0], align 4
@.str.558 = private unnamed_addr constant [19 x i8] c"usbdevfs_getdriver\00", align 1
@struct_usbdevfs_getdriver_def = internal constant [5 x i32] [i32 3, i32 10, i32 256, i32 1, i32 0], align 16
@.str.559 = private unnamed_addr constant [21 x i8] c"usbdevfs_connectinfo\00", align 1
@struct_usbdevfs_connectinfo_def = internal constant [3 x i32] [i32 3, i32 1, i32 0], align 4
@.str.560 = private unnamed_addr constant [25 x i8] c"usbdevfs_iso_packet_desc\00", align 1
@struct_usbdevfs_iso_packet_desc_def = internal constant [4 x i32] [i32 3, i32 3, i32 3, i32 0], align 16
@.str.561 = private unnamed_addr constant [13 x i8] c"usbdevfs_urb\00", align 1
@struct_usbdevfs_urb_def = internal constant [17 x i32] [i32 1, i32 1, i32 3, i32 3, i32 6, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 6, i32 10, i32 0, i32 11, i32 93, i32 0], align 16
@.str.562 = private unnamed_addr constant [15 x i8] c"usbdevfs_ioctl\00", align 1
@struct_usbdevfs_ioctl_def = internal constant [4 x i32] [i32 3, i32 3, i32 6, i32 0], align 16
@.str.563 = private unnamed_addr constant [22 x i8] c"usbdevfs_hub_portinfo\00", align 1
@struct_usbdevfs_hub_portinfo_def = internal constant [5 x i32] [i32 1, i32 10, i32 127, i32 1, i32 0], align 16
@.str.564 = private unnamed_addr constant [26 x i8] c"usbdevfs_disconnect_claim\00", align 1
@struct_usbdevfs_disconnect_claim_def = internal constant [6 x i32] [i32 3, i32 3, i32 10, i32 256, i32 1, i32 0], align 16
@stderr = external global ptr, align 8
@.str.565 = private unnamed_addr constant [34 x i8] c"cannot patch size for ioctl 0x%x\0A\00", align 1
@do_guest_openat.fakes = internal constant [7 x %struct.fake_open] [%struct.fake_open { ptr @.str.566, ptr @open_self_maps, ptr @is_proc_myself }, %struct.fake_open { ptr @.str.567, ptr @open_self_smaps, ptr @is_proc_myself }, %struct.fake_open { ptr @.str.568, ptr @open_self_stat, ptr @is_proc_myself }, %struct.fake_open { ptr @.str.569, ptr @open_self_auxv, ptr @is_proc_myself }, %struct.fake_open { ptr @.str.570, ptr @open_self_cmdline, ptr @is_proc_myself }, %struct.fake_open { ptr @.str.571, ptr @open_cpuinfo, ptr @is_proc }, %struct.fake_open zeroinitializer], align 16
@.str.566 = private unnamed_addr constant [5 x i8] c"maps\00", align 1
@.str.567 = private unnamed_addr constant [6 x i8] c"smaps\00", align 1
@.str.568 = private unnamed_addr constant [5 x i8] c"stat\00", align 1
@.str.569 = private unnamed_addr constant [5 x i8] c"auxv\00", align 1
@.str.570 = private unnamed_addr constant [8 x i8] c"cmdline\00", align 1
@.str.571 = private unnamed_addr constant [14 x i8] c"/proc/cpuinfo\00", align 1
@.str.572 = private unnamed_addr constant [7 x i8] c"/proc/\00", align 1
@.str.573 = private unnamed_addr constant [4 x i8] c"exe\00", align 1
@exec_path = external global ptr, align 8
@.str.574 = private unnamed_addr constant [10 x i8] c"qemu-open\00", align 1
@.str.575 = private unnamed_addr constant [7 x i8] c"TMPDIR\00", align 1
@.str.576 = private unnamed_addr constant [5 x i8] c"/tmp\00", align 1
@.str.577 = private unnamed_addr constant [20 x i8] c"%s/qemu-open.XXXXXX\00", align 1
@fcntl_flags_tbl = internal constant [19 x %struct.bitmask_transtbl] [%struct.bitmask_transtbl { i32 3, i32 1, i32 3, i32 1 }, %struct.bitmask_transtbl { i32 3, i32 2, i32 3, i32 2 }, %struct.bitmask_transtbl { i32 64, i32 64, i32 64, i32 64 }, %struct.bitmask_transtbl { i32 128, i32 128, i32 128, i32 128 }, %struct.bitmask_transtbl { i32 256, i32 256, i32 256, i32 256 }, %struct.bitmask_transtbl { i32 512, i32 512, i32 512, i32 512 }, %struct.bitmask_transtbl { i32 1024, i32 1024, i32 1024, i32 1024 }, %struct.bitmask_transtbl { i32 2048, i32 2048, i32 2048, i32 2048 }, %struct.bitmask_transtbl { i32 1052672, i32 4096, i32 1052672, i32 4096 }, %struct.bitmask_transtbl { i32 1052672, i32 1052672, i32 1052672, i32 1052672 }, %struct.bitmask_transtbl { i32 8192, i32 8192, i32 8192, i32 8192 }, %struct.bitmask_transtbl { i32 65536, i32 65536, i32 65536, i32 65536 }, %struct.bitmask_transtbl { i32 131072, i32 131072, i32 131072, i32 131072 }, %struct.bitmask_transtbl { i32 16384, i32 16384, i32 16384, i32 16384 }, %struct.bitmask_transtbl { i32 262144, i32 262144, i32 262144, i32 262144 }, %struct.bitmask_transtbl { i32 524288, i32 524288, i32 524288, i32 524288 }, %struct.bitmask_transtbl { i32 2097152, i32 2097152, i32 2097152, i32 2097152 }, %struct.bitmask_transtbl { i32 4259840, i32 4259840, i32 4259840, i32 4259840 }, %struct.bitmask_transtbl { i32 32768, i32 32768, i32 0, i32 0 }], align 16
@thread_cpu = external thread_local global ptr, align 8
@__const.do_ioctl_blkpg.part_arg_type = private unnamed_addr constant [2 x i32] [i32 11, i32 60], align 4
@__const.do_ioctl_fs_ioc_fiemap.extent_arg_type = private unnamed_addr constant [2 x i32] [i32 11, i32 58], align 4
@.str.578 = private unnamed_addr constant [24 x i8] c"arg_type[0] == TYPE_PTR\00", align 1
@.str.579 = private unnamed_addr constant [29 x i8] c"../qemu/linux-user/syscall.c\00", align 1
@__PRETTY_FUNCTION__.do_ioctl_fs_ioc_fiemap = private unnamed_addr constant [83 x i8] c"abi_long do_ioctl_fs_ioc_fiemap(const IOCTLEntry *, uint8_t *, int, int, abi_long)\00", align 1
@.str.580 = private unnamed_addr constant [21 x i8] c"ie->access == IOC_RW\00", align 1
@usbdevfs_urb_hashtable.urb_hashtable = internal global ptr null, align 8
@__const.do_ioctl_usbdevfs_reapurb.usbfsurb_arg_type = private unnamed_addr constant [2 x i32] [i32 11, i32 94], align 4
@__const.do_ioctl_usbdevfs_reapurb.ptrvoid_arg_type = private unnamed_addr constant [3 x i32] [i32 6, i32 0, i32 0], align 4
@__const.do_ioctl_ifconf.ifreq_arg_type = private unnamed_addr constant [2 x i32] [i32 11, i32 7], align 4
@__const.do_ioctl_ifconf.ifreq_max_type = private unnamed_addr constant [2 x i32] [i32 11, i32 10], align 4
@__PRETTY_FUNCTION__.do_ioctl_ifconf = private unnamed_addr constant [76 x i8] c"abi_long do_ioctl_ifconf(const IOCTLEntry *, uint8_t *, int, int, abi_long)\00", align 1
@__const.do_ioctl_dm.dm_arg_type = private unnamed_addr constant [2 x i32] [i32 11, i32 50], align 4
@__const.do_ioctl_dm.dm_arg_type.581 = private unnamed_addr constant [2 x i32] [i32 11, i32 52], align 4
@__const.do_ioctl_dm.dm_arg_type.582 = private unnamed_addr constant [2 x i32] [i32 11, i32 50], align 4
@__const.do_ioctl_dm.dm_arg_type.583 = private unnamed_addr constant [2 x i32] [i32 11, i32 53], align 4
@.str.584 = private unnamed_addr constant [20 x i8] c"ie->access == IOC_W\00", align 1
@__PRETTY_FUNCTION__.do_ioctl_rt = private unnamed_addr constant [72 x i8] c"abi_long do_ioctl_rt(const IOCTLEntry *, uint8_t *, int, int, abi_long)\00", align 1
@.str.585 = private unnamed_addr constant [22 x i8] c"*arg_type == TYPE_PTR\00", align 1
@.str.586 = private unnamed_addr constant [25 x i8] c"*arg_type == TYPE_STRUCT\00", align 1
@.str.587 = private unnamed_addr constant [33 x i8] c"*arg_type == (int)STRUCT_rtentry\00", align 1
@struct_entries = external global ptr, align 8
@.str.588 = private unnamed_addr constant [23 x i8] c"se->convert[0] == NULL\00", align 1
@.str.589 = private unnamed_addr constant [29 x i8] c"*field_types == TYPE_PTRVOID\00", align 1
@.str.590 = private unnamed_addr constant [24 x i8] c"host_rt_dev_ptr != NULL\00", align 1
@.str.591 = private unnamed_addr constant [26 x i8] c"target_rt_dev_ptr != NULL\00", align 1
@__PRETTY_FUNCTION__.do_ioctl_TUNSETTXFILTER = private unnamed_addr constant [84 x i8] c"abi_long do_ioctl_TUNSETTXFILTER(const IOCTLEntry *, uint8_t *, int, int, abi_long)\00", align 1
@iflag_tbl = internal constant [15 x %struct.bitmask_transtbl] [%struct.bitmask_transtbl { i32 1, i32 1, i32 1, i32 1 }, %struct.bitmask_transtbl { i32 2, i32 2, i32 2, i32 2 }, %struct.bitmask_transtbl { i32 4, i32 4, i32 4, i32 4 }, %struct.bitmask_transtbl { i32 8, i32 8, i32 8, i32 8 }, %struct.bitmask_transtbl { i32 16, i32 16, i32 16, i32 16 }, %struct.bitmask_transtbl { i32 32, i32 32, i32 32, i32 32 }, %struct.bitmask_transtbl { i32 64, i32 64, i32 64, i32 64 }, %struct.bitmask_transtbl { i32 128, i32 128, i32 128, i32 128 }, %struct.bitmask_transtbl { i32 256, i32 256, i32 256, i32 256 }, %struct.bitmask_transtbl { i32 512, i32 512, i32 512, i32 512 }, %struct.bitmask_transtbl { i32 1024, i32 1024, i32 1024, i32 1024 }, %struct.bitmask_transtbl { i32 2048, i32 2048, i32 2048, i32 2048 }, %struct.bitmask_transtbl { i32 4096, i32 4096, i32 4096, i32 4096 }, %struct.bitmask_transtbl { i32 8192, i32 8192, i32 8192, i32 8192 }, %struct.bitmask_transtbl { i32 16384, i32 16384, i32 16384, i32 16384 }], align 16
@oflag_tbl = internal constant [24 x %struct.bitmask_transtbl] [%struct.bitmask_transtbl { i32 1, i32 1, i32 1, i32 1 }, %struct.bitmask_transtbl { i32 2, i32 2, i32 2, i32 2 }, %struct.bitmask_transtbl { i32 4, i32 4, i32 4, i32 4 }, %struct.bitmask_transtbl { i32 8, i32 8, i32 8, i32 8 }, %struct.bitmask_transtbl { i32 16, i32 16, i32 16, i32 16 }, %struct.bitmask_transtbl { i32 32, i32 32, i32 32, i32 32 }, %struct.bitmask_transtbl { i32 64, i32 64, i32 64, i32 64 }, %struct.bitmask_transtbl { i32 128, i32 128, i32 128, i32 128 }, %struct.bitmask_transtbl { i32 256, i32 0, i32 256, i32 0 }, %struct.bitmask_transtbl { i32 256, i32 256, i32 256, i32 256 }, %struct.bitmask_transtbl { i32 1536, i32 0, i32 1536, i32 0 }, %struct.bitmask_transtbl { i32 1536, i32 512, i32 1536, i32 512 }, %struct.bitmask_transtbl { i32 1536, i32 1024, i32 1536, i32 1024 }, %struct.bitmask_transtbl { i32 1536, i32 1536, i32 1536, i32 1536 }, %struct.bitmask_transtbl { i32 6144, i32 0, i32 6144, i32 0 }, %struct.bitmask_transtbl { i32 6144, i32 2048, i32 6144, i32 2048 }, %struct.bitmask_transtbl { i32 6144, i32 4096, i32 6144, i32 4096 }, %struct.bitmask_transtbl { i32 6144, i32 6144, i32 6144, i32 6144 }, %struct.bitmask_transtbl { i32 8192, i32 0, i32 8192, i32 0 }, %struct.bitmask_transtbl { i32 8192, i32 8192, i32 8192, i32 8192 }, %struct.bitmask_transtbl { i32 16384, i32 0, i32 16384, i32 0 }, %struct.bitmask_transtbl { i32 16384, i32 16384, i32 16384, i32 16384 }, %struct.bitmask_transtbl { i32 32768, i32 0, i32 32768, i32 0 }, %struct.bitmask_transtbl { i32 32768, i32 32768, i32 32768, i32 32768 }], align 16
@cflag_tbl = internal constant [31 x %struct.bitmask_transtbl] [%struct.bitmask_transtbl { i32 4111, i32 0, i32 4111, i32 0 }, %struct.bitmask_transtbl { i32 4111, i32 1, i32 4111, i32 1 }, %struct.bitmask_transtbl { i32 4111, i32 2, i32 4111, i32 2 }, %struct.bitmask_transtbl { i32 4111, i32 3, i32 4111, i32 3 }, %struct.bitmask_transtbl { i32 4111, i32 4, i32 4111, i32 4 }, %struct.bitmask_transtbl { i32 4111, i32 5, i32 4111, i32 5 }, %struct.bitmask_transtbl { i32 4111, i32 6, i32 4111, i32 6 }, %struct.bitmask_transtbl { i32 4111, i32 7, i32 4111, i32 7 }, %struct.bitmask_transtbl { i32 4111, i32 8, i32 4111, i32 8 }, %struct.bitmask_transtbl { i32 4111, i32 9, i32 4111, i32 9 }, %struct.bitmask_transtbl { i32 4111, i32 10, i32 4111, i32 10 }, %struct.bitmask_transtbl { i32 4111, i32 11, i32 4111, i32 11 }, %struct.bitmask_transtbl { i32 4111, i32 12, i32 4111, i32 12 }, %struct.bitmask_transtbl { i32 4111, i32 13, i32 4111, i32 13 }, %struct.bitmask_transtbl { i32 4111, i32 14, i32 4111, i32 14 }, %struct.bitmask_transtbl { i32 4111, i32 15, i32 4111, i32 15 }, %struct.bitmask_transtbl { i32 4111, i32 4097, i32 4111, i32 4097 }, %struct.bitmask_transtbl { i32 4111, i32 4098, i32 4111, i32 4098 }, %struct.bitmask_transtbl { i32 4111, i32 4099, i32 4111, i32 4099 }, %struct.bitmask_transtbl { i32 4111, i32 4100, i32 4111, i32 4100 }, %struct.bitmask_transtbl { i32 48, i32 0, i32 48, i32 0 }, %struct.bitmask_transtbl { i32 48, i32 16, i32 48, i32 16 }, %struct.bitmask_transtbl { i32 48, i32 32, i32 48, i32 32 }, %struct.bitmask_transtbl { i32 48, i32 48, i32 48, i32 48 }, %struct.bitmask_transtbl { i32 64, i32 64, i32 64, i32 64 }, %struct.bitmask_transtbl { i32 128, i32 128, i32 128, i32 128 }, %struct.bitmask_transtbl { i32 256, i32 256, i32 256, i32 256 }, %struct.bitmask_transtbl { i32 512, i32 512, i32 512, i32 512 }, %struct.bitmask_transtbl { i32 1024, i32 1024, i32 1024, i32 1024 }, %struct.bitmask_transtbl { i32 2048, i32 2048, i32 2048, i32 2048 }, %struct.bitmask_transtbl { i32 -2147483648, i32 -2147483648, i32 -2147483648, i32 -2147483648 }], align 16
@lflag_tbl = internal constant [16 x %struct.bitmask_transtbl] [%struct.bitmask_transtbl { i32 1, i32 1, i32 1, i32 1 }, %struct.bitmask_transtbl { i32 2, i32 2, i32 2, i32 2 }, %struct.bitmask_transtbl { i32 4, i32 4, i32 4, i32 4 }, %struct.bitmask_transtbl { i32 8, i32 8, i32 8, i32 8 }, %struct.bitmask_transtbl { i32 16, i32 16, i32 16, i32 16 }, %struct.bitmask_transtbl { i32 32, i32 32, i32 32, i32 32 }, %struct.bitmask_transtbl { i32 64, i32 64, i32 64, i32 64 }, %struct.bitmask_transtbl { i32 128, i32 128, i32 128, i32 128 }, %struct.bitmask_transtbl { i32 256, i32 256, i32 256, i32 256 }, %struct.bitmask_transtbl { i32 512, i32 512, i32 512, i32 512 }, %struct.bitmask_transtbl { i32 1024, i32 1024, i32 1024, i32 1024 }, %struct.bitmask_transtbl { i32 2048, i32 2048, i32 2048, i32 2048 }, %struct.bitmask_transtbl { i32 4096, i32 4096, i32 4096, i32 4096 }, %struct.bitmask_transtbl { i32 16384, i32 16384, i32 16384, i32 16384 }, %struct.bitmask_transtbl { i32 32768, i32 32768, i32 32768, i32 32768 }, %struct.bitmask_transtbl { i32 65536, i32 65536, i32 65536, i32 65536 }], align 16
@.str.592 = private unnamed_addr constant [104 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/exec/user/thunk.h\00", align 1
@__func__.thunk_type_size = private unnamed_addr constant [16 x i8] c"thunk_type_size\00", align 1
@.str.593 = private unnamed_addr constant [24 x i8] c"Failing executable: %s\0A\00", align 1
@guest_base = external global i64, align 8
@reserved_va = external global i64, align 8
@.str.594 = private unnamed_addr constant [22 x i8] c"h2g_valid(this_hlast)\00", align 1
@__PRETTY_FUNCTION__.open_self_maps_2 = private unnamed_addr constant [72 x i8] c"int open_self_maps_2(void *, target_ulong, target_ulong, unsigned long)\00", align 1
@.str.595 = private unnamed_addr constant [22 x i8] c"h2g_valid(host_start)\00", align 1
@.str.596 = private unnamed_addr constant [8 x i8] c"[stack]\00", align 1
@.str.597 = private unnamed_addr constant [7 x i8] c"[heap]\00", align 1
@.str.598 = private unnamed_addr constant [7 x i8] c"[vdso]\00", align 1
@.str.599 = private unnamed_addr constant [37 x i8] c"%lx-%lx %c%c%c%c %08lx %02x:%02x %ld\00", align 1
@.str.600 = private unnamed_addr constant [7 x i8] c"%*s%s\0A\00", align 1
@.str.601 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.602 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.603 = private unnamed_addr constant [640 x i8] c"Size:                  %lu kB\0AKernelPageSize:        %lu kB\0AMMUPageSize:           %lu kB\0ARss:                   0 kB\0APss:                   0 kB\0APss_Dirty:             0 kB\0AShared_Clean:          0 kB\0AShared_Dirty:          0 kB\0APrivate_Clean:         0 kB\0APrivate_Dirty:         0 kB\0AReferenced:            0 kB\0AAnonymous:             %lu kB\0ALazyFree:              0 kB\0AAnonHugePages:         0 kB\0AShmemPmdMapped:        0 kB\0AFilePmdMapped:         0 kB\0AShared_Hugetlb:        0 kB\0APrivate_Hugetlb:       0 kB\0ASwap:                  0 kB\0ASwapPss:               0 kB\0ALocked:                0 kB\0ATHPeligible:    0\0AVmFlags:%s%s%s%s%s%s%s%s\0A\00", align 1
@.str.604 = private unnamed_addr constant [4 x i8] c" rd\00", align 1
@.str.605 = private unnamed_addr constant [4 x i8] c" wr\00", align 1
@.str.606 = private unnamed_addr constant [4 x i8] c" ex\00", align 1
@.str.607 = private unnamed_addr constant [4 x i8] c" sh\00", align 1
@.str.608 = private unnamed_addr constant [4 x i8] c" mr\00", align 1
@.str.609 = private unnamed_addr constant [4 x i8] c" mw\00", align 1
@.str.610 = private unnamed_addr constant [4 x i8] c" me\00", align 1
@.str.611 = private unnamed_addr constant [4 x i8] c" ms\00", align 1
@open_self_maps_3.mi = internal constant %struct.MapInfo { %struct.IntervalTreeNode zeroinitializer, i8 0, i8 0, i8 0, i8 1, i64 0, i64 0, i64 0, ptr null }, align 8
@.str.612 = private unnamed_addr constant [6 x i8] c"self/\00", align 1
@.str.613 = private unnamed_addr constant [4 x i8] c"%d/\00", align 1
@.str.614 = private unnamed_addr constant [4 x i8] c"%d \00", align 1
@.str.615 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@.str.616 = private unnamed_addr constant [9 x i8] c"(%.15s) \00", align 1
@.str.617 = private unnamed_addr constant [3 x i8] c"R \00", align 1
@.str.618 = private unnamed_addr constant [5 x i8] c"%lu \00", align 1
@.str.619 = private unnamed_addr constant [5 x i8] c"%ld \00", align 1
@.str.620 = private unnamed_addr constant [4 x i8] c"0%c\00", align 1
@.str.621 = private unnamed_addr constant [5 x i8] c"sv32\00", align 1
@.str.622 = private unnamed_addr constant [5 x i8] c"sv48\00", align 1
@.str.623 = private unnamed_addr constant [5 x i8] c"none\00", align 1
@.str.624 = private unnamed_addr constant [16 x i8] c"processor\09: %d\0A\00", align 1
@.str.625 = private unnamed_addr constant [12 x i8] c"hart\09\09: %d\0A\00", align 1
@.str.626 = private unnamed_addr constant [11 x i8] c"isa\09\09: %s\0A\00", align 1
@.str.627 = private unnamed_addr constant [11 x i8] c"mmu\09\09: %s\0A\00", align 1
@.str.628 = private unnamed_addr constant [16 x i8] c"uarch\09\09: qemu\0A\0A\00", align 1
@qemu_loglevel = external global i32, align 4
@clone_lock = internal global %union.pthread_mutex_t zeroinitializer, align 8
@__func__.do_syscall1 = private unnamed_addr constant [12 x i8] c"do_syscall1\00", align 1
@cpus_queue = external global %union.CPUTailQ, align 8
@target_fd_max = external global i32, align 4
@qemu_uname_release = external global ptr, align 8
@target_inotify_trans = external global %struct.TargetFdTrans, align 8
@target_eventfd_trans = external global %struct.TargetFdTrans, align 8
@g_posix_timers = internal global [32 x ptr] zeroinitializer, align 16
@target_timerfd_trans = external global %struct.TargetFdTrans, align 8
@.str.629 = private unnamed_addr constant [25 x i8] c"Unsupported syscall: %d\0A\00", align 1
@target_fd_trans_lock = external global %struct.QemuMutex, align 8
@target_fd_trans = external global ptr, align 8
@.str.630 = private unnamed_addr constant [100 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qemu/thread.h\00", align 1
@__func__.qemu_mutex_lock = private unnamed_addr constant [16 x i8] c"qemu_mutex_lock\00", align 1
@qemu_mutex_lock_func = external global ptr, align 8
@.str.631 = private unnamed_addr constant [32 x i8] c"Unsupported ioctl: cmd=0x%04lx\0A\00", align 1
@.str.632 = private unnamed_addr constant [45 x i8] c"Unsupported ioctl type: cmd=0x%04lx type=%d\0A\00", align 1
@mmap_flags_tbl = internal constant [13 x %struct.bitmask_transtbl] [%struct.bitmask_transtbl { i32 16, i32 16, i32 16, i32 16 }, %struct.bitmask_transtbl { i32 32, i32 32, i32 32, i32 32 }, %struct.bitmask_transtbl { i32 256, i32 256, i32 256, i32 256 }, %struct.bitmask_transtbl { i32 2048, i32 2048, i32 2048, i32 2048 }, %struct.bitmask_transtbl { i32 4096, i32 4096, i32 4096, i32 4096 }, %struct.bitmask_transtbl { i32 8192, i32 8192, i32 8192, i32 8192 }, %struct.bitmask_transtbl { i32 16384, i32 16384, i32 16384, i32 16384 }, %struct.bitmask_transtbl { i32 262144, i32 262144, i32 262144, i32 262144 }, %struct.bitmask_transtbl { i32 131072, i32 131072, i32 0, i32 0 }, %struct.bitmask_transtbl { i32 65536, i32 65536, i32 65536, i32 65536 }, %struct.bitmask_transtbl { i32 32768, i32 32768, i32 32768, i32 32768 }, %struct.bitmask_transtbl { i32 1048576, i32 1048576, i32 1048576, i32 1048576 }, %struct.bitmask_transtbl { i32 67108864, i32 67108864, i32 0, i32 0 }], align 16
@.str.633 = private unnamed_addr constant [5 x i8] c"addr\00", align 1
@__PRETTY_FUNCTION__.host_to_target_sockaddr = private unnamed_addr constant [74 x i8] c"abi_long host_to_target_sockaddr(abi_ulong, struct sockaddr *, socklen_t)\00", align 1
@.str.634 = private unnamed_addr constant [50 x i8] c"getsockopt level=%d optname=%d not yet supported\0A\00", align 1
@.str.635 = private unnamed_addr constant [54 x i8] c"Unsupported ancillary data %d/%d: unhandled msg size\0A\00", align 1
@.str.636 = private unnamed_addr constant [35 x i8] c"Unsupported ancillary data: %d/%d\0A\00", align 1
@target_packet_trans = external global %struct.TargetFdTrans, align 8
@target_netlink_route_trans = external global %struct.TargetFdTrans, align 8
@target_netlink_audit_trans = external global %struct.TargetFdTrans, align 8
@__func__.do_socket = private unnamed_addr constant [10 x i8] c"do_socket\00", align 1
@.str.637 = private unnamed_addr constant [44 x i8] c"Unsupported setsockopt level=%d optname=%d\0A\00", align 1
@__func__.do_fork = private unnamed_addr constant [8 x i8] c"do_fork\00", align 1
@.str.638 = private unnamed_addr constant [31 x i8] c"!cpu_in_exclusive_context(cpu)\00", align 1
@.str.639 = private unnamed_addr constant [25 x i8] c"host_size >= target_size\00", align 1
@__PRETTY_FUNCTION__.host_to_target_cpu_mask = private unnamed_addr constant [78 x i8] c"int host_to_target_cpu_mask(const unsigned long *, size_t, abi_ulong, size_t)\00", align 1
@__PRETTY_FUNCTION__.target_to_host_cpu_mask = private unnamed_addr constant [72 x i8] c"int target_to_host_cpu_mask(unsigned long *, size_t, abi_ulong, size_t)\00", align 1
@.str.640 = private unnamed_addr constant [24 x i8] c"Unsupported prctl: %ld\0A\00", align 1
@target_signalfd_trans = external global %struct.TargetFdTrans, align 8
@__func__.next_free_host_timer = private unnamed_addr constant [21 x i8] c"next_free_host_timer\00", align 1
@g_posix_timer_allocated = internal global [32 x i32] zeroinitializer, align 16
@__func__.free_host_timer_slot = private unnamed_addr constant [21 x i8] c"free_host_timer_slot\00", align 1

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @get_errno(i64 noundef %ret) #0 {
entry:
  %retval = alloca i64, align 8
  %ret.addr = alloca i64, align 8
  store i64 %ret, ptr %ret.addr, align 8
  %0 = load i64, ptr %ret.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #13
  %1 = load i32, ptr %call, align 4
  %call1 = call i32 @host_to_target_errno(i32 noundef %1)
  %sub = sub i32 0, %call1
  %conv = sext i32 %sub to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %ret.addr, align 8
  store i64 %2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %3 = load i64, ptr %retval, align 8
  ret i64 %3
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @host_to_target_errno(i32 noundef %host_errno) #0 {
entry:
  %retval = alloca i32, align 4
  %host_errno.addr = alloca i32, align 4
  store i32 %host_errno, ptr %host_errno.addr, align 4
  %0 = load i32, ptr %host_errno.addr, align 4
  switch i32 %0, label %sw.default [
    i32 98, label %sw.bb
    i32 99, label %sw.bb1
    i32 68, label %sw.bb2
    i32 97, label %sw.bb3
    i32 11, label %sw.bb4
    i32 114, label %sw.bb5
    i32 52, label %sw.bb6
    i32 77, label %sw.bb7
    i32 74, label %sw.bb8
    i32 53, label %sw.bb9
    i32 56, label %sw.bb10
    i32 57, label %sw.bb11
    i32 59, label %sw.bb12
    i32 125, label %sw.bb13
    i32 44, label %sw.bb14
    i32 70, label %sw.bb15
    i32 103, label %sw.bb16
    i32 111, label %sw.bb17
    i32 104, label %sw.bb18
    i32 35, label %sw.bb19
    i32 89, label %sw.bb20
    i32 73, label %sw.bb21
    i32 122, label %sw.bb22
    i32 112, label %sw.bb23
    i32 113, label %sw.bb24
    i32 133, label %sw.bb25
    i32 43, label %sw.bb26
    i32 84, label %sw.bb27
    i32 115, label %sw.bb28
    i32 106, label %sw.bb29
    i32 120, label %sw.bb30
    i32 127, label %sw.bb31
    i32 129, label %sw.bb32
    i32 128, label %sw.bb33
    i32 51, label %sw.bb34
    i32 45, label %sw.bb35
    i32 46, label %sw.bb36
    i32 47, label %sw.bb37
    i32 79, label %sw.bb38
    i32 80, label %sw.bb39
    i32 83, label %sw.bb40
    i32 82, label %sw.bb41
    i32 81, label %sw.bb42
    i32 48, label %sw.bb43
    i32 40, label %sw.bb44
    i32 124, label %sw.bb45
    i32 90, label %sw.bb46
    i32 72, label %sw.bb47
    i32 36, label %sw.bb48
    i32 119, label %sw.bb49
    i32 100, label %sw.bb50
    i32 102, label %sw.bb51
    i32 101, label %sw.bb52
    i32 55, label %sw.bb53
    i32 105, label %sw.bb54
    i32 50, label %sw.bb55
    i32 61, label %sw.bb56
    i32 126, label %sw.bb57
    i32 37, label %sw.bb58
    i32 67, label %sw.bb59
    i32 123, label %sw.bb60
    i32 42, label %sw.bb61
    i32 64, label %sw.bb62
    i32 65, label %sw.bb63
    i32 92, label %sw.bb64
    i32 63, label %sw.bb65
    i32 60, label %sw.bb66
    i32 38, label %sw.bb67
    i32 107, label %sw.bb68
    i32 39, label %sw.bb69
    i32 118, label %sw.bb70
    i32 131, label %sw.bb71
    i32 88, label %sw.bb72
    i32 76, label %sw.bb73
    i32 95, label %sw.bb74
    i32 75, label %sw.bb75
    i32 130, label %sw.bb76
    i32 96, label %sw.bb77
    i32 71, label %sw.bb78
    i32 93, label %sw.bb79
    i32 91, label %sw.bb80
    i32 78, label %sw.bb81
    i32 66, label %sw.bb82
    i32 121, label %sw.bb83
    i32 85, label %sw.bb84
    i32 132, label %sw.bb85
    i32 108, label %sw.bb86
    i32 94, label %sw.bb87
    i32 69, label %sw.bb88
    i32 116, label %sw.bb89
    i32 86, label %sw.bb90
    i32 62, label %sw.bb91
    i32 110, label %sw.bb92
    i32 109, label %sw.bb93
    i32 117, label %sw.bb94
    i32 49, label %sw.bb95
    i32 87, label %sw.bb96
    i32 54, label %sw.bb97
  ]

sw.bb:                                            ; preds = %entry
  store i32 98, ptr %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %entry
  store i32 99, ptr %retval, align 4
  br label %return

sw.bb2:                                           ; preds = %entry
  store i32 68, ptr %retval, align 4
  br label %return

sw.bb3:                                           ; preds = %entry
  store i32 97, ptr %retval, align 4
  br label %return

sw.bb4:                                           ; preds = %entry
  store i32 11, ptr %retval, align 4
  br label %return

sw.bb5:                                           ; preds = %entry
  store i32 114, ptr %retval, align 4
  br label %return

sw.bb6:                                           ; preds = %entry
  store i32 52, ptr %retval, align 4
  br label %return

sw.bb7:                                           ; preds = %entry
  store i32 77, ptr %retval, align 4
  br label %return

sw.bb8:                                           ; preds = %entry
  store i32 74, ptr %retval, align 4
  br label %return

sw.bb9:                                           ; preds = %entry
  store i32 53, ptr %retval, align 4
  br label %return

sw.bb10:                                          ; preds = %entry
  store i32 56, ptr %retval, align 4
  br label %return

sw.bb11:                                          ; preds = %entry
  store i32 57, ptr %retval, align 4
  br label %return

sw.bb12:                                          ; preds = %entry
  store i32 59, ptr %retval, align 4
  br label %return

sw.bb13:                                          ; preds = %entry
  store i32 125, ptr %retval, align 4
  br label %return

sw.bb14:                                          ; preds = %entry
  store i32 44, ptr %retval, align 4
  br label %return

sw.bb15:                                          ; preds = %entry
  store i32 70, ptr %retval, align 4
  br label %return

sw.bb16:                                          ; preds = %entry
  store i32 103, ptr %retval, align 4
  br label %return

sw.bb17:                                          ; preds = %entry
  store i32 111, ptr %retval, align 4
  br label %return

sw.bb18:                                          ; preds = %entry
  store i32 104, ptr %retval, align 4
  br label %return

sw.bb19:                                          ; preds = %entry
  store i32 35, ptr %retval, align 4
  br label %return

sw.bb20:                                          ; preds = %entry
  store i32 89, ptr %retval, align 4
  br label %return

sw.bb21:                                          ; preds = %entry
  store i32 73, ptr %retval, align 4
  br label %return

sw.bb22:                                          ; preds = %entry
  store i32 122, ptr %retval, align 4
  br label %return

sw.bb23:                                          ; preds = %entry
  store i32 112, ptr %retval, align 4
  br label %return

sw.bb24:                                          ; preds = %entry
  store i32 113, ptr %retval, align 4
  br label %return

sw.bb25:                                          ; preds = %entry
  store i32 133, ptr %retval, align 4
  br label %return

sw.bb26:                                          ; preds = %entry
  store i32 43, ptr %retval, align 4
  br label %return

sw.bb27:                                          ; preds = %entry
  store i32 84, ptr %retval, align 4
  br label %return

sw.bb28:                                          ; preds = %entry
  store i32 115, ptr %retval, align 4
  br label %return

sw.bb29:                                          ; preds = %entry
  store i32 106, ptr %retval, align 4
  br label %return

sw.bb30:                                          ; preds = %entry
  store i32 120, ptr %retval, align 4
  br label %return

sw.bb31:                                          ; preds = %entry
  store i32 127, ptr %retval, align 4
  br label %return

sw.bb32:                                          ; preds = %entry
  store i32 129, ptr %retval, align 4
  br label %return

sw.bb33:                                          ; preds = %entry
  store i32 128, ptr %retval, align 4
  br label %return

sw.bb34:                                          ; preds = %entry
  store i32 51, ptr %retval, align 4
  br label %return

sw.bb35:                                          ; preds = %entry
  store i32 45, ptr %retval, align 4
  br label %return

sw.bb36:                                          ; preds = %entry
  store i32 46, ptr %retval, align 4
  br label %return

sw.bb37:                                          ; preds = %entry
  store i32 47, ptr %retval, align 4
  br label %return

sw.bb38:                                          ; preds = %entry
  store i32 79, ptr %retval, align 4
  br label %return

sw.bb39:                                          ; preds = %entry
  store i32 80, ptr %retval, align 4
  br label %return

sw.bb40:                                          ; preds = %entry
  store i32 83, ptr %retval, align 4
  br label %return

sw.bb41:                                          ; preds = %entry
  store i32 82, ptr %retval, align 4
  br label %return

sw.bb42:                                          ; preds = %entry
  store i32 81, ptr %retval, align 4
  br label %return

sw.bb43:                                          ; preds = %entry
  store i32 48, ptr %retval, align 4
  br label %return

sw.bb44:                                          ; preds = %entry
  store i32 40, ptr %retval, align 4
  br label %return

sw.bb45:                                          ; preds = %entry
  store i32 124, ptr %retval, align 4
  br label %return

sw.bb46:                                          ; preds = %entry
  store i32 90, ptr %retval, align 4
  br label %return

sw.bb47:                                          ; preds = %entry
  store i32 72, ptr %retval, align 4
  br label %return

sw.bb48:                                          ; preds = %entry
  store i32 36, ptr %retval, align 4
  br label %return

sw.bb49:                                          ; preds = %entry
  store i32 119, ptr %retval, align 4
  br label %return

sw.bb50:                                          ; preds = %entry
  store i32 100, ptr %retval, align 4
  br label %return

sw.bb51:                                          ; preds = %entry
  store i32 102, ptr %retval, align 4
  br label %return

sw.bb52:                                          ; preds = %entry
  store i32 101, ptr %retval, align 4
  br label %return

sw.bb53:                                          ; preds = %entry
  store i32 55, ptr %retval, align 4
  br label %return

sw.bb54:                                          ; preds = %entry
  store i32 105, ptr %retval, align 4
  br label %return

sw.bb55:                                          ; preds = %entry
  store i32 50, ptr %retval, align 4
  br label %return

sw.bb56:                                          ; preds = %entry
  store i32 61, ptr %retval, align 4
  br label %return

sw.bb57:                                          ; preds = %entry
  store i32 126, ptr %retval, align 4
  br label %return

sw.bb58:                                          ; preds = %entry
  store i32 37, ptr %retval, align 4
  br label %return

sw.bb59:                                          ; preds = %entry
  store i32 67, ptr %retval, align 4
  br label %return

sw.bb60:                                          ; preds = %entry
  store i32 123, ptr %retval, align 4
  br label %return

sw.bb61:                                          ; preds = %entry
  store i32 42, ptr %retval, align 4
  br label %return

sw.bb62:                                          ; preds = %entry
  store i32 64, ptr %retval, align 4
  br label %return

sw.bb63:                                          ; preds = %entry
  store i32 65, ptr %retval, align 4
  br label %return

sw.bb64:                                          ; preds = %entry
  store i32 92, ptr %retval, align 4
  br label %return

sw.bb65:                                          ; preds = %entry
  store i32 63, ptr %retval, align 4
  br label %return

sw.bb66:                                          ; preds = %entry
  store i32 60, ptr %retval, align 4
  br label %return

sw.bb67:                                          ; preds = %entry
  store i32 38, ptr %retval, align 4
  br label %return

sw.bb68:                                          ; preds = %entry
  store i32 107, ptr %retval, align 4
  br label %return

sw.bb69:                                          ; preds = %entry
  store i32 39, ptr %retval, align 4
  br label %return

sw.bb70:                                          ; preds = %entry
  store i32 118, ptr %retval, align 4
  br label %return

sw.bb71:                                          ; preds = %entry
  store i32 131, ptr %retval, align 4
  br label %return

sw.bb72:                                          ; preds = %entry
  store i32 88, ptr %retval, align 4
  br label %return

sw.bb73:                                          ; preds = %entry
  store i32 76, ptr %retval, align 4
  br label %return

sw.bb74:                                          ; preds = %entry
  store i32 95, ptr %retval, align 4
  br label %return

sw.bb75:                                          ; preds = %entry
  store i32 75, ptr %retval, align 4
  br label %return

sw.bb76:                                          ; preds = %entry
  store i32 130, ptr %retval, align 4
  br label %return

sw.bb77:                                          ; preds = %entry
  store i32 96, ptr %retval, align 4
  br label %return

sw.bb78:                                          ; preds = %entry
  store i32 71, ptr %retval, align 4
  br label %return

sw.bb79:                                          ; preds = %entry
  store i32 93, ptr %retval, align 4
  br label %return

sw.bb80:                                          ; preds = %entry
  store i32 91, ptr %retval, align 4
  br label %return

sw.bb81:                                          ; preds = %entry
  store i32 78, ptr %retval, align 4
  br label %return

sw.bb82:                                          ; preds = %entry
  store i32 66, ptr %retval, align 4
  br label %return

sw.bb83:                                          ; preds = %entry
  store i32 121, ptr %retval, align 4
  br label %return

sw.bb84:                                          ; preds = %entry
  store i32 85, ptr %retval, align 4
  br label %return

sw.bb85:                                          ; preds = %entry
  store i32 132, ptr %retval, align 4
  br label %return

sw.bb86:                                          ; preds = %entry
  store i32 108, ptr %retval, align 4
  br label %return

sw.bb87:                                          ; preds = %entry
  store i32 94, ptr %retval, align 4
  br label %return

sw.bb88:                                          ; preds = %entry
  store i32 69, ptr %retval, align 4
  br label %return

sw.bb89:                                          ; preds = %entry
  store i32 116, ptr %retval, align 4
  br label %return

sw.bb90:                                          ; preds = %entry
  store i32 86, ptr %retval, align 4
  br label %return

sw.bb91:                                          ; preds = %entry
  store i32 62, ptr %retval, align 4
  br label %return

sw.bb92:                                          ; preds = %entry
  store i32 110, ptr %retval, align 4
  br label %return

sw.bb93:                                          ; preds = %entry
  store i32 109, ptr %retval, align 4
  br label %return

sw.bb94:                                          ; preds = %entry
  store i32 117, ptr %retval, align 4
  br label %return

sw.bb95:                                          ; preds = %entry
  store i32 49, ptr %retval, align 4
  br label %return

sw.bb96:                                          ; preds = %entry
  store i32 87, ptr %retval, align 4
  br label %return

sw.bb97:                                          ; preds = %entry
  store i32 54, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  %1 = load i32, ptr %host_errno.addr, align 4
  store i32 %1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %sw.bb97, %sw.bb96, %sw.bb95, %sw.bb94, %sw.bb93, %sw.bb92, %sw.bb91, %sw.bb90, %sw.bb89, %sw.bb88, %sw.bb87, %sw.bb86, %sw.bb85, %sw.bb84, %sw.bb83, %sw.bb82, %sw.bb81, %sw.bb80, %sw.bb79, %sw.bb78, %sw.bb77, %sw.bb76, %sw.bb75, %sw.bb74, %sw.bb73, %sw.bb72, %sw.bb71, %sw.bb70, %sw.bb69, %sw.bb68, %sw.bb67, %sw.bb66, %sw.bb65, %sw.bb64, %sw.bb63, %sw.bb62, %sw.bb61, %sw.bb60, %sw.bb59, %sw.bb58, %sw.bb57, %sw.bb56, %sw.bb55, %sw.bb54, %sw.bb53, %sw.bb52, %sw.bb51, %sw.bb50, %sw.bb49, %sw.bb48, %sw.bb47, %sw.bb46, %sw.bb45, %sw.bb44, %sw.bb43, %sw.bb42, %sw.bb41, %sw.bb40, %sw.bb39, %sw.bb38, %sw.bb37, %sw.bb36, %sw.bb35, %sw.bb34, %sw.bb33, %sw.bb32, %sw.bb31, %sw.bb30, %sw.bb29, %sw.bb28, %sw.bb27, %sw.bb26, %sw.bb25, %sw.bb24, %sw.bb23, %sw.bb22, %sw.bb21, %sw.bb20, %sw.bb19, %sw.bb18, %sw.bb17, %sw.bb16, %sw.bb15, %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind willreturn memory(none)
declare ptr @__errno_location() #1

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @target_strerror(i32 noundef %err) #0 {
entry:
  %retval = alloca ptr, align 8
  %err.addr = alloca i32, align 4
  store i32 %err, ptr %err.addr, align 4
  %0 = load i32, ptr %err.addr, align 4
  %cmp = icmp eq i32 %0, 512
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr @.str, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %err.addr, align 4
  %cmp1 = icmp eq i32 %1, 513
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store ptr @.str.1, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %2 = load i32, ptr %err.addr, align 4
  %call = call i32 @target_to_host_errno(i32 noundef %2)
  %call4 = call ptr @strerror(i32 noundef %call) #14
  store ptr %call4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind
declare ptr @strerror(i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @target_to_host_errno(i32 noundef %target_errno) #0 {
entry:
  %retval = alloca i32, align 4
  %target_errno.addr = alloca i32, align 4
  store i32 %target_errno, ptr %target_errno.addr, align 4
  %0 = load i32, ptr %target_errno.addr, align 4
  switch i32 %0, label %sw.default [
    i32 98, label %sw.bb
    i32 99, label %sw.bb1
    i32 68, label %sw.bb2
    i32 97, label %sw.bb3
    i32 11, label %sw.bb4
    i32 114, label %sw.bb5
    i32 52, label %sw.bb6
    i32 77, label %sw.bb7
    i32 74, label %sw.bb8
    i32 53, label %sw.bb9
    i32 56, label %sw.bb10
    i32 57, label %sw.bb11
    i32 59, label %sw.bb12
    i32 125, label %sw.bb13
    i32 44, label %sw.bb14
    i32 70, label %sw.bb15
    i32 103, label %sw.bb16
    i32 111, label %sw.bb17
    i32 104, label %sw.bb18
    i32 35, label %sw.bb19
    i32 89, label %sw.bb20
    i32 73, label %sw.bb21
    i32 122, label %sw.bb22
    i32 112, label %sw.bb23
    i32 113, label %sw.bb24
    i32 133, label %sw.bb25
    i32 43, label %sw.bb26
    i32 84, label %sw.bb27
    i32 115, label %sw.bb28
    i32 106, label %sw.bb29
    i32 120, label %sw.bb30
    i32 127, label %sw.bb31
    i32 129, label %sw.bb32
    i32 128, label %sw.bb33
    i32 51, label %sw.bb34
    i32 45, label %sw.bb35
    i32 46, label %sw.bb36
    i32 47, label %sw.bb37
    i32 79, label %sw.bb38
    i32 80, label %sw.bb39
    i32 83, label %sw.bb40
    i32 82, label %sw.bb41
    i32 81, label %sw.bb42
    i32 48, label %sw.bb43
    i32 40, label %sw.bb44
    i32 124, label %sw.bb45
    i32 90, label %sw.bb46
    i32 72, label %sw.bb47
    i32 36, label %sw.bb48
    i32 119, label %sw.bb49
    i32 100, label %sw.bb50
    i32 102, label %sw.bb51
    i32 101, label %sw.bb52
    i32 55, label %sw.bb53
    i32 105, label %sw.bb54
    i32 50, label %sw.bb55
    i32 61, label %sw.bb56
    i32 126, label %sw.bb57
    i32 37, label %sw.bb58
    i32 67, label %sw.bb59
    i32 123, label %sw.bb60
    i32 42, label %sw.bb61
    i32 64, label %sw.bb62
    i32 65, label %sw.bb63
    i32 92, label %sw.bb64
    i32 63, label %sw.bb65
    i32 60, label %sw.bb66
    i32 38, label %sw.bb67
    i32 107, label %sw.bb68
    i32 39, label %sw.bb69
    i32 118, label %sw.bb70
    i32 131, label %sw.bb71
    i32 88, label %sw.bb72
    i32 76, label %sw.bb73
    i32 95, label %sw.bb74
    i32 75, label %sw.bb75
    i32 130, label %sw.bb76
    i32 96, label %sw.bb77
    i32 71, label %sw.bb78
    i32 93, label %sw.bb79
    i32 91, label %sw.bb80
    i32 78, label %sw.bb81
    i32 66, label %sw.bb82
    i32 121, label %sw.bb83
    i32 85, label %sw.bb84
    i32 132, label %sw.bb85
    i32 108, label %sw.bb86
    i32 94, label %sw.bb87
    i32 69, label %sw.bb88
    i32 116, label %sw.bb89
    i32 86, label %sw.bb90
    i32 62, label %sw.bb91
    i32 110, label %sw.bb92
    i32 109, label %sw.bb93
    i32 117, label %sw.bb94
    i32 49, label %sw.bb95
    i32 87, label %sw.bb96
    i32 54, label %sw.bb97
  ]

sw.bb:                                            ; preds = %entry
  store i32 98, ptr %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %entry
  store i32 99, ptr %retval, align 4
  br label %return

sw.bb2:                                           ; preds = %entry
  store i32 68, ptr %retval, align 4
  br label %return

sw.bb3:                                           ; preds = %entry
  store i32 97, ptr %retval, align 4
  br label %return

sw.bb4:                                           ; preds = %entry
  store i32 11, ptr %retval, align 4
  br label %return

sw.bb5:                                           ; preds = %entry
  store i32 114, ptr %retval, align 4
  br label %return

sw.bb6:                                           ; preds = %entry
  store i32 52, ptr %retval, align 4
  br label %return

sw.bb7:                                           ; preds = %entry
  store i32 77, ptr %retval, align 4
  br label %return

sw.bb8:                                           ; preds = %entry
  store i32 74, ptr %retval, align 4
  br label %return

sw.bb9:                                           ; preds = %entry
  store i32 53, ptr %retval, align 4
  br label %return

sw.bb10:                                          ; preds = %entry
  store i32 56, ptr %retval, align 4
  br label %return

sw.bb11:                                          ; preds = %entry
  store i32 57, ptr %retval, align 4
  br label %return

sw.bb12:                                          ; preds = %entry
  store i32 59, ptr %retval, align 4
  br label %return

sw.bb13:                                          ; preds = %entry
  store i32 125, ptr %retval, align 4
  br label %return

sw.bb14:                                          ; preds = %entry
  store i32 44, ptr %retval, align 4
  br label %return

sw.bb15:                                          ; preds = %entry
  store i32 70, ptr %retval, align 4
  br label %return

sw.bb16:                                          ; preds = %entry
  store i32 103, ptr %retval, align 4
  br label %return

sw.bb17:                                          ; preds = %entry
  store i32 111, ptr %retval, align 4
  br label %return

sw.bb18:                                          ; preds = %entry
  store i32 104, ptr %retval, align 4
  br label %return

sw.bb19:                                          ; preds = %entry
  store i32 35, ptr %retval, align 4
  br label %return

sw.bb20:                                          ; preds = %entry
  store i32 89, ptr %retval, align 4
  br label %return

sw.bb21:                                          ; preds = %entry
  store i32 73, ptr %retval, align 4
  br label %return

sw.bb22:                                          ; preds = %entry
  store i32 122, ptr %retval, align 4
  br label %return

sw.bb23:                                          ; preds = %entry
  store i32 112, ptr %retval, align 4
  br label %return

sw.bb24:                                          ; preds = %entry
  store i32 113, ptr %retval, align 4
  br label %return

sw.bb25:                                          ; preds = %entry
  store i32 133, ptr %retval, align 4
  br label %return

sw.bb26:                                          ; preds = %entry
  store i32 43, ptr %retval, align 4
  br label %return

sw.bb27:                                          ; preds = %entry
  store i32 84, ptr %retval, align 4
  br label %return

sw.bb28:                                          ; preds = %entry
  store i32 115, ptr %retval, align 4
  br label %return

sw.bb29:                                          ; preds = %entry
  store i32 106, ptr %retval, align 4
  br label %return

sw.bb30:                                          ; preds = %entry
  store i32 120, ptr %retval, align 4
  br label %return

sw.bb31:                                          ; preds = %entry
  store i32 127, ptr %retval, align 4
  br label %return

sw.bb32:                                          ; preds = %entry
  store i32 129, ptr %retval, align 4
  br label %return

sw.bb33:                                          ; preds = %entry
  store i32 128, ptr %retval, align 4
  br label %return

sw.bb34:                                          ; preds = %entry
  store i32 51, ptr %retval, align 4
  br label %return

sw.bb35:                                          ; preds = %entry
  store i32 45, ptr %retval, align 4
  br label %return

sw.bb36:                                          ; preds = %entry
  store i32 46, ptr %retval, align 4
  br label %return

sw.bb37:                                          ; preds = %entry
  store i32 47, ptr %retval, align 4
  br label %return

sw.bb38:                                          ; preds = %entry
  store i32 79, ptr %retval, align 4
  br label %return

sw.bb39:                                          ; preds = %entry
  store i32 80, ptr %retval, align 4
  br label %return

sw.bb40:                                          ; preds = %entry
  store i32 83, ptr %retval, align 4
  br label %return

sw.bb41:                                          ; preds = %entry
  store i32 82, ptr %retval, align 4
  br label %return

sw.bb42:                                          ; preds = %entry
  store i32 81, ptr %retval, align 4
  br label %return

sw.bb43:                                          ; preds = %entry
  store i32 48, ptr %retval, align 4
  br label %return

sw.bb44:                                          ; preds = %entry
  store i32 40, ptr %retval, align 4
  br label %return

sw.bb45:                                          ; preds = %entry
  store i32 124, ptr %retval, align 4
  br label %return

sw.bb46:                                          ; preds = %entry
  store i32 90, ptr %retval, align 4
  br label %return

sw.bb47:                                          ; preds = %entry
  store i32 72, ptr %retval, align 4
  br label %return

sw.bb48:                                          ; preds = %entry
  store i32 36, ptr %retval, align 4
  br label %return

sw.bb49:                                          ; preds = %entry
  store i32 119, ptr %retval, align 4
  br label %return

sw.bb50:                                          ; preds = %entry
  store i32 100, ptr %retval, align 4
  br label %return

sw.bb51:                                          ; preds = %entry
  store i32 102, ptr %retval, align 4
  br label %return

sw.bb52:                                          ; preds = %entry
  store i32 101, ptr %retval, align 4
  br label %return

sw.bb53:                                          ; preds = %entry
  store i32 55, ptr %retval, align 4
  br label %return

sw.bb54:                                          ; preds = %entry
  store i32 105, ptr %retval, align 4
  br label %return

sw.bb55:                                          ; preds = %entry
  store i32 50, ptr %retval, align 4
  br label %return

sw.bb56:                                          ; preds = %entry
  store i32 61, ptr %retval, align 4
  br label %return

sw.bb57:                                          ; preds = %entry
  store i32 126, ptr %retval, align 4
  br label %return

sw.bb58:                                          ; preds = %entry
  store i32 37, ptr %retval, align 4
  br label %return

sw.bb59:                                          ; preds = %entry
  store i32 67, ptr %retval, align 4
  br label %return

sw.bb60:                                          ; preds = %entry
  store i32 123, ptr %retval, align 4
  br label %return

sw.bb61:                                          ; preds = %entry
  store i32 42, ptr %retval, align 4
  br label %return

sw.bb62:                                          ; preds = %entry
  store i32 64, ptr %retval, align 4
  br label %return

sw.bb63:                                          ; preds = %entry
  store i32 65, ptr %retval, align 4
  br label %return

sw.bb64:                                          ; preds = %entry
  store i32 92, ptr %retval, align 4
  br label %return

sw.bb65:                                          ; preds = %entry
  store i32 63, ptr %retval, align 4
  br label %return

sw.bb66:                                          ; preds = %entry
  store i32 60, ptr %retval, align 4
  br label %return

sw.bb67:                                          ; preds = %entry
  store i32 38, ptr %retval, align 4
  br label %return

sw.bb68:                                          ; preds = %entry
  store i32 107, ptr %retval, align 4
  br label %return

sw.bb69:                                          ; preds = %entry
  store i32 39, ptr %retval, align 4
  br label %return

sw.bb70:                                          ; preds = %entry
  store i32 118, ptr %retval, align 4
  br label %return

sw.bb71:                                          ; preds = %entry
  store i32 131, ptr %retval, align 4
  br label %return

sw.bb72:                                          ; preds = %entry
  store i32 88, ptr %retval, align 4
  br label %return

sw.bb73:                                          ; preds = %entry
  store i32 76, ptr %retval, align 4
  br label %return

sw.bb74:                                          ; preds = %entry
  store i32 95, ptr %retval, align 4
  br label %return

sw.bb75:                                          ; preds = %entry
  store i32 75, ptr %retval, align 4
  br label %return

sw.bb76:                                          ; preds = %entry
  store i32 130, ptr %retval, align 4
  br label %return

sw.bb77:                                          ; preds = %entry
  store i32 96, ptr %retval, align 4
  br label %return

sw.bb78:                                          ; preds = %entry
  store i32 71, ptr %retval, align 4
  br label %return

sw.bb79:                                          ; preds = %entry
  store i32 93, ptr %retval, align 4
  br label %return

sw.bb80:                                          ; preds = %entry
  store i32 91, ptr %retval, align 4
  br label %return

sw.bb81:                                          ; preds = %entry
  store i32 78, ptr %retval, align 4
  br label %return

sw.bb82:                                          ; preds = %entry
  store i32 66, ptr %retval, align 4
  br label %return

sw.bb83:                                          ; preds = %entry
  store i32 121, ptr %retval, align 4
  br label %return

sw.bb84:                                          ; preds = %entry
  store i32 85, ptr %retval, align 4
  br label %return

sw.bb85:                                          ; preds = %entry
  store i32 132, ptr %retval, align 4
  br label %return

sw.bb86:                                          ; preds = %entry
  store i32 108, ptr %retval, align 4
  br label %return

sw.bb87:                                          ; preds = %entry
  store i32 94, ptr %retval, align 4
  br label %return

sw.bb88:                                          ; preds = %entry
  store i32 69, ptr %retval, align 4
  br label %return

sw.bb89:                                          ; preds = %entry
  store i32 116, ptr %retval, align 4
  br label %return

sw.bb90:                                          ; preds = %entry
  store i32 86, ptr %retval, align 4
  br label %return

sw.bb91:                                          ; preds = %entry
  store i32 62, ptr %retval, align 4
  br label %return

sw.bb92:                                          ; preds = %entry
  store i32 110, ptr %retval, align 4
  br label %return

sw.bb93:                                          ; preds = %entry
  store i32 109, ptr %retval, align 4
  br label %return

sw.bb94:                                          ; preds = %entry
  store i32 117, ptr %retval, align 4
  br label %return

sw.bb95:                                          ; preds = %entry
  store i32 49, ptr %retval, align 4
  br label %return

sw.bb96:                                          ; preds = %entry
  store i32 87, ptr %retval, align 4
  br label %return

sw.bb97:                                          ; preds = %entry
  store i32 54, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  %1 = load i32, ptr %target_errno.addr, align 4
  store i32 %1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %sw.bb97, %sw.bb96, %sw.bb95, %sw.bb94, %sw.bb93, %sw.bb92, %sw.bb91, %sw.bb90, %sw.bb89, %sw.bb88, %sw.bb87, %sw.bb86, %sw.bb85, %sw.bb84, %sw.bb83, %sw.bb82, %sw.bb81, %sw.bb80, %sw.bb79, %sw.bb78, %sw.bb77, %sw.bb76, %sw.bb75, %sw.bb74, %sw.bb73, %sw.bb72, %sw.bb71, %sw.bb70, %sw.bb69, %sw.bb68, %sw.bb67, %sw.bb66, %sw.bb65, %sw.bb64, %sw.bb63, %sw.bb62, %sw.bb61, %sw.bb60, %sw.bb59, %sw.bb58, %sw.bb57, %sw.bb56, %sw.bb55, %sw.bb54, %sw.bb53, %sw.bb52, %sw.bb51, %sw.bb50, %sw.bb49, %sw.bb48, %sw.bb47, %sw.bb46, %sw.bb45, %sw.bb44, %sw.bb43, %sw.bb42, %sw.bb41, %sw.bb40, %sw.bb39, %sw.bb38, %sw.bb37, %sw.bb36, %sw.bb35, %sw.bb34, %sw.bb33, %sw.bb32, %sw.bb31, %sw.bb30, %sw.bb29, %sw.bb28, %sw.bb27, %sw.bb26, %sw.bb25, %sw.bb24, %sw.bb23, %sw.bb22, %sw.bb21, %sw.bb20, %sw.bb19, %sw.bb18, %sw.bb17, %sw.bb16, %sw.bb15, %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @target_set_brk(i64 noundef %new_brk) #0 {
entry:
  %new_brk.addr = alloca i64, align 8
  store i64 %new_brk, ptr %new_brk.addr, align 8
  %0 = load i64, ptr %new_brk.addr, align 8
  %add = add i64 %0, 4096
  %sub = sub i64 %add, 1
  %and = and i64 %sub, -4096
  store i64 %and, ptr @target_brk, align 8
  %1 = load i64, ptr @target_brk, align 8
  store i64 %1, ptr @initial_target_brk, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @do_brk(i64 noundef %brk_val) #0 {
entry:
  %retval = alloca i64, align 8
  %brk_val.addr = alloca i64, align 8
  %mapped_addr = alloca i64, align 8
  %new_brk = alloca i64, align 8
  %old_brk = alloca i64, align 8
  store i64 %brk_val, ptr %brk_val.addr, align 8
  %0 = load i64, ptr %brk_val.addr, align 8
  %1 = load i64, ptr @initial_target_brk, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr @target_brk, align 8
  store i64 %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i64, ptr %brk_val.addr, align 8
  %add = add i64 %3, 4096
  %sub = sub i64 %add, 1
  %and = and i64 %sub, -4096
  store i64 %and, ptr %new_brk, align 8
  %4 = load i64, ptr @target_brk, align 8
  %add1 = add i64 %4, 4096
  %sub2 = sub i64 %add1, 1
  %and3 = and i64 %sub2, -4096
  store i64 %and3, ptr %old_brk, align 8
  %5 = load i64, ptr %new_brk, align 8
  %6 = load i64, ptr %old_brk, align 8
  %cmp4 = icmp eq i64 %5, %6
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %7 = load i64, ptr %brk_val.addr, align 8
  store i64 %7, ptr @target_brk, align 8
  %8 = load i64, ptr @target_brk, align 8
  store i64 %8, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %9 = load i64, ptr %new_brk, align 8
  %10 = load i64, ptr %old_brk, align 8
  %cmp7 = icmp ult i64 %9, %10
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end6
  %11 = load i64, ptr %new_brk, align 8
  %12 = load i64, ptr %old_brk, align 8
  %13 = load i64, ptr %new_brk, align 8
  %sub9 = sub i64 %12, %13
  %call = call i32 @target_munmap(i64 noundef %11, i64 noundef %sub9)
  %14 = load i64, ptr %brk_val.addr, align 8
  store i64 %14, ptr @target_brk, align 8
  %15 = load i64, ptr @target_brk, align 8
  store i64 %15, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end6
  %16 = load i64, ptr %old_brk, align 8
  %17 = load i64, ptr %new_brk, align 8
  %18 = load i64, ptr %old_brk, align 8
  %sub11 = sub i64 %17, %18
  %call12 = call i64 @target_mmap(i64 noundef %16, i64 noundef %sub11, i32 noundef 3, i32 noundef 1048610, i32 noundef -1, i64 noundef 0)
  store i64 %call12, ptr %mapped_addr, align 8
  %19 = load i64, ptr %mapped_addr, align 8
  %20 = load i64, ptr %old_brk, align 8
  %cmp13 = icmp eq i64 %19, %20
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end10
  %21 = load i64, ptr %brk_val.addr, align 8
  store i64 %21, ptr @target_brk, align 8
  %22 = load i64, ptr @target_brk, align 8
  store i64 %22, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end10
  %23 = load i64, ptr @target_brk, align 8
  store i64 %23, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %if.then14, %if.then8, %if.then5, %if.then
  %24 = load i64, ptr %retval, align 8
  ret i64 %24
}

declare i32 @target_munmap(i64 noundef, i64 noundef) #3

declare i64 @target_mmap(i64 noundef, i64 noundef, i32 noundef, i32 noundef, i32 noundef, i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_tiocgptpeer(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %flags = alloca i32, align 4
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load i64, ptr %arg.addr, align 8
  %conv = trunc i64 %0 to i32
  %call = call i32 @target_to_host_bitmask_len(i32 noundef %conv, ptr noundef @fcntl_flags_tbl, i64 noundef 19)
  store i32 %call, ptr %flags, align 4
  %1 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %2 = load ptr, ptr %1, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %2, i32 0, i32 39
  %3 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %3, i32 0, i32 14
  %4 = load i32, ptr %fd.addr, align 4
  %5 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %host_cmd, align 4
  %7 = load i32, ptr %flags, align 4
  %call1 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %4, i32 noundef %6, i32 noundef %7)
  %call2 = call i64 @get_errno(i64 noundef %call1)
  ret i64 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_kdsigaccept(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %sig = alloca i32, align 4
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load i64, ptr %arg.addr, align 8
  %conv = trunc i64 %0 to i32
  %call = call i32 @target_to_host_signal(i32 noundef %conv)
  store i32 %call, ptr %sig, align 4
  %1 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %2 = load ptr, ptr %1, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %2, i32 0, i32 39
  %3 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %3, i32 0, i32 14
  %4 = load i32, ptr %fd.addr, align 4
  %5 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %host_cmd, align 4
  %7 = load i32, ptr %sig, align 4
  %call1 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %4, i32 noundef %6, i32 noundef %7)
  %call2 = call i64 @get_errno(i64 noundef %call1)
  ret i64 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_blkpg(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %argptr = alloca ptr, align 8
  %target_size = alloca i32, align 4
  %arg_type = alloca ptr, align 8
  %part_arg_type = alloca [2 x i32], align 4
  %ret = alloca i64, align 8
  %host_blkpg = alloca ptr, align 8
  %host_part = alloca %struct.blkpg_partition, align 8
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %ie.addr, align 8
  %arg_type1 = getelementptr inbounds %struct.IOCTLEntry, ptr %0, i32 0, i32 5
  %arraydecay = getelementptr inbounds [5 x i32], ptr %arg_type1, i64 0, i64 0
  store ptr %arraydecay, ptr %arg_type, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %part_arg_type, ptr align 4 @__const.do_ioctl_blkpg.part_arg_type, i64 8, i1 false)
  %1 = load ptr, ptr %buf_temp.addr, align 8
  store ptr %1, ptr %host_blkpg, align 8
  %2 = load ptr, ptr %arg_type, align 8
  %incdec.ptr = getelementptr i32, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %arg_type, align 8
  %3 = load ptr, ptr %arg_type, align 8
  %call = call i32 @thunk_type_size(ptr noundef %3, i32 noundef 0)
  store i32 %call, ptr %target_size, align 4
  %4 = load i64, ptr %arg.addr, align 8
  %5 = load i32, ptr %target_size, align 4
  %conv = sext i32 %5 to i64
  %call2 = call ptr @lock_user(i32 noundef 1, i64 noundef %4, i64 noundef %conv, i1 noundef zeroext true)
  store ptr %call2, ptr %argptr, align 8
  %6 = load ptr, ptr %argptr, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %ret, align 8
  br label %out

if.end:                                           ; preds = %entry
  %7 = load ptr, ptr %buf_temp.addr, align 8
  %8 = load ptr, ptr %argptr, align 8
  %9 = load ptr, ptr %arg_type, align 8
  %call3 = call ptr @thunk_convert(ptr noundef %7, ptr noundef %8, ptr noundef %9, i32 noundef 1)
  %10 = load ptr, ptr %argptr, align 8
  %11 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %10, i64 noundef %11, i64 noundef 0)
  %12 = load ptr, ptr %host_blkpg, align 8
  %op = getelementptr inbounds %struct.blkpg_ioctl_arg, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %op, align 8
  switch i32 %13, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.end, %if.end
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  store i64 -22, ptr %ret, align 8
  br label %out

sw.epilog:                                        ; preds = %sw.bb
  %14 = load ptr, ptr %host_blkpg, align 8
  %data = getelementptr inbounds %struct.blkpg_ioctl_arg, ptr %14, i32 0, i32 3
  %15 = load ptr, ptr %data, align 8
  %16 = ptrtoint ptr %15 to i64
  store i64 %16, ptr %arg.addr, align 8
  %arraydecay4 = getelementptr inbounds [2 x i32], ptr %part_arg_type, i64 0, i64 0
  %call5 = call i32 @thunk_type_size(ptr noundef %arraydecay4, i32 noundef 0)
  store i32 %call5, ptr %target_size, align 4
  %17 = load i64, ptr %arg.addr, align 8
  %18 = load i32, ptr %target_size, align 4
  %conv6 = sext i32 %18 to i64
  %call7 = call ptr @lock_user(i32 noundef 1, i64 noundef %17, i64 noundef %conv6, i1 noundef zeroext true)
  store ptr %call7, ptr %argptr, align 8
  %19 = load ptr, ptr %argptr, align 8
  %tobool8 = icmp ne ptr %19, null
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %sw.epilog
  store i64 -14, ptr %ret, align 8
  br label %out

if.end10:                                         ; preds = %sw.epilog
  %20 = load ptr, ptr %argptr, align 8
  %arraydecay11 = getelementptr inbounds [2 x i32], ptr %part_arg_type, i64 0, i64 0
  %call12 = call ptr @thunk_convert(ptr noundef %host_part, ptr noundef %20, ptr noundef %arraydecay11, i32 noundef 1)
  %21 = load ptr, ptr %argptr, align 8
  %22 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %21, i64 noundef %22, i64 noundef 0)
  %23 = load ptr, ptr %host_blkpg, align 8
  %data13 = getelementptr inbounds %struct.blkpg_ioctl_arg, ptr %23, i32 0, i32 3
  store ptr %host_part, ptr %data13, align 8
  %24 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %25 = load ptr, ptr %24, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %25, i32 0, i32 39
  %26 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %26, i32 0, i32 14
  %27 = load i32, ptr %fd.addr, align 4
  %28 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %28, i32 0, i32 1
  %29 = load i32, ptr %host_cmd, align 4
  %30 = load ptr, ptr %host_blkpg, align 8
  %call14 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %27, i32 noundef %29, ptr noundef %30)
  %call15 = call i64 @get_errno(i64 noundef %call14)
  store i64 %call15, ptr %ret, align 8
  br label %out

out:                                              ; preds = %if.end10, %if.then9, %sw.default, %if.then
  %31 = load i64, ptr %ret, align 8
  ret i64 %31
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_fs_ioc_fiemap(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %target_size_in = alloca i32, align 4
  %target_size_out = alloca i32, align 4
  %fm = alloca ptr, align 8
  %arg_type = alloca ptr, align 8
  %extent_arg_type = alloca [2 x i32], align 4
  %argptr = alloca ptr, align 8
  %p = alloca ptr, align 8
  %ret = alloca i64, align 8
  %i = alloca i32, align 4
  %extent_size = alloca i32, align 4
  %outbufsz = alloca i32, align 4
  %free_fm = alloca i32, align 4
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %ie.addr, align 8
  %arg_type1 = getelementptr inbounds %struct.IOCTLEntry, ptr %0, i32 0, i32 5
  %arraydecay = getelementptr inbounds [5 x i32], ptr %arg_type1, i64 0, i64 0
  store ptr %arraydecay, ptr %arg_type, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %extent_arg_type, ptr align 4 @__const.do_ioctl_fs_ioc_fiemap.extent_arg_type, i64 8, i1 false)
  %arraydecay2 = getelementptr inbounds [2 x i32], ptr %extent_arg_type, i64 0, i64 0
  %call = call i32 @thunk_type_size(ptr noundef %arraydecay2, i32 noundef 0)
  store i32 %call, ptr %extent_size, align 4
  store i32 0, ptr %free_fm, align 4
  %1 = load ptr, ptr %arg_type, align 8
  %arrayidx = getelementptr i32, ptr %1, i64 0
  %2 = load i32, ptr %arrayidx, align 4
  %cmp = icmp eq i32 %2, 9
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.578, ptr noundef @.str.579, i32 noundef 4643, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_fs_ioc_fiemap) #15
  unreachable

if.end:                                           ; preds = %if.then
  %3 = load ptr, ptr %ie.addr, align 8
  %access = getelementptr inbounds %struct.IOCTLEntry, ptr %3, i32 0, i32 3
  %4 = load i32, ptr %access, align 8
  %cmp3 = icmp eq i32 %4, 3
  br i1 %cmp3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.end
  br label %if.end6

if.else5:                                         ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.580, ptr noundef @.str.579, i32 noundef 4644, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_fs_ioc_fiemap) #15
  unreachable

if.end6:                                          ; preds = %if.then4
  %5 = load ptr, ptr %arg_type, align 8
  %incdec.ptr = getelementptr i32, ptr %5, i32 1
  store ptr %incdec.ptr, ptr %arg_type, align 8
  %6 = load ptr, ptr %arg_type, align 8
  %call7 = call i32 @thunk_type_size(ptr noundef %6, i32 noundef 0)
  store i32 %call7, ptr %target_size_in, align 4
  %7 = load i64, ptr %arg.addr, align 8
  %8 = load i32, ptr %target_size_in, align 4
  %conv = sext i32 %8 to i64
  %call8 = call ptr @lock_user(i32 noundef 1, i64 noundef %7, i64 noundef %conv, i1 noundef zeroext true)
  store ptr %call8, ptr %argptr, align 8
  %9 = load ptr, ptr %argptr, align 8
  %tobool = icmp ne ptr %9, null
  br i1 %tobool, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end6
  store i64 -14, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end6
  %10 = load ptr, ptr %buf_temp.addr, align 8
  %11 = load ptr, ptr %argptr, align 8
  %12 = load ptr, ptr %arg_type, align 8
  %call11 = call ptr @thunk_convert(ptr noundef %10, ptr noundef %11, ptr noundef %12, i32 noundef 1)
  %13 = load ptr, ptr %argptr, align 8
  %14 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %13, i64 noundef %14, i64 noundef 0)
  %15 = load ptr, ptr %buf_temp.addr, align 8
  store ptr %15, ptr %fm, align 8
  %16 = load ptr, ptr %fm, align 8
  %fm_extent_count = getelementptr inbounds %struct.fiemap, ptr %16, i32 0, i32 4
  %17 = load i32, ptr %fm_extent_count, align 8
  %conv12 = zext i32 %17 to i64
  %cmp13 = icmp ugt i64 %conv12, 76695843
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end10
  store i64 -22, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end10
  %18 = load ptr, ptr %fm, align 8
  %fm_extent_count17 = getelementptr inbounds %struct.fiemap, ptr %18, i32 0, i32 4
  %19 = load i32, ptr %fm_extent_count17, align 8
  %conv18 = zext i32 %19 to i64
  %mul = mul i64 56, %conv18
  %add = add i64 32, %mul
  %conv19 = trunc i64 %add to i32
  store i32 %conv19, ptr %outbufsz, align 4
  %20 = load i32, ptr %outbufsz, align 4
  %cmp20 = icmp ugt i32 %20, 4096
  br i1 %cmp20, label %if.then22, label %if.end28

if.then22:                                        ; preds = %if.end16
  %21 = load i32, ptr %outbufsz, align 4
  %conv23 = zext i32 %21 to i64
  %call24 = call noalias ptr @g_try_malloc(i64 noundef %conv23) #16
  store ptr %call24, ptr %fm, align 8
  %22 = load ptr, ptr %fm, align 8
  %tobool25 = icmp ne ptr %22, null
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %if.then22
  store i64 -12, ptr %retval, align 8
  br label %return

if.end27:                                         ; preds = %if.then22
  %23 = load ptr, ptr %fm, align 8
  %24 = load ptr, ptr %buf_temp.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %23, ptr align 1 %24, i64 32, i1 false)
  store i32 1, ptr %free_fm, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end16
  %25 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %26 = load ptr, ptr %25, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %26, i32 0, i32 39
  %27 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %27, i32 0, i32 14
  %28 = load i32, ptr %fd.addr, align 4
  %29 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %29, i32 0, i32 1
  %30 = load i32, ptr %host_cmd, align 4
  %31 = load ptr, ptr %fm, align 8
  %call29 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %28, i32 noundef %30, ptr noundef %31)
  %call30 = call i64 @get_errno(i64 noundef %call29)
  store i64 %call30, ptr %ret, align 8
  %32 = load i64, ptr %ret, align 8
  %call31 = call i32 @is_error(i64 noundef %32)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.end62, label %if.then33

if.then33:                                        ; preds = %if.end28
  %33 = load i32, ptr %target_size_in, align 4
  store i32 %33, ptr %target_size_out, align 4
  %34 = load ptr, ptr %fm, align 8
  %fm_extent_count34 = getelementptr inbounds %struct.fiemap, ptr %34, i32 0, i32 4
  %35 = load i32, ptr %fm_extent_count34, align 8
  %cmp35 = icmp ne i32 %35, 0
  br i1 %cmp35, label %if.then37, label %if.end40

if.then37:                                        ; preds = %if.then33
  %36 = load ptr, ptr %fm, align 8
  %fm_mapped_extents = getelementptr inbounds %struct.fiemap, ptr %36, i32 0, i32 3
  %37 = load i32, ptr %fm_mapped_extents, align 4
  %38 = load i32, ptr %extent_size, align 4
  %mul38 = mul i32 %37, %38
  %39 = load i32, ptr %target_size_out, align 4
  %add39 = add i32 %39, %mul38
  store i32 %add39, ptr %target_size_out, align 4
  br label %if.end40

if.end40:                                         ; preds = %if.then37, %if.then33
  %40 = load i64, ptr %arg.addr, align 8
  %41 = load i32, ptr %target_size_out, align 4
  %conv41 = sext i32 %41 to i64
  %call42 = call ptr @lock_user(i32 noundef 3, i64 noundef %40, i64 noundef %conv41, i1 noundef zeroext false)
  store ptr %call42, ptr %argptr, align 8
  %42 = load ptr, ptr %argptr, align 8
  %tobool43 = icmp ne ptr %42, null
  br i1 %tobool43, label %if.else45, label %if.then44

if.then44:                                        ; preds = %if.end40
  store i64 -14, ptr %ret, align 8
  br label %if.end61

if.else45:                                        ; preds = %if.end40
  %43 = load ptr, ptr %argptr, align 8
  %44 = load ptr, ptr %fm, align 8
  %45 = load ptr, ptr %arg_type, align 8
  %call46 = call ptr @thunk_convert(ptr noundef %43, ptr noundef %44, ptr noundef %45, i32 noundef 0)
  %46 = load ptr, ptr %fm, align 8
  %fm_extent_count47 = getelementptr inbounds %struct.fiemap, ptr %46, i32 0, i32 4
  %47 = load i32, ptr %fm_extent_count47, align 8
  %cmp48 = icmp ne i32 %47, 0
  br i1 %cmp48, label %if.then50, label %if.end59

if.then50:                                        ; preds = %if.else45
  %48 = load ptr, ptr %argptr, align 8
  %49 = load i32, ptr %target_size_in, align 4
  %idx.ext = sext i32 %49 to i64
  %add.ptr = getelementptr i8, ptr %48, i64 %idx.ext
  store ptr %add.ptr, ptr %p, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then50
  %50 = load i32, ptr %i, align 4
  %51 = load ptr, ptr %fm, align 8
  %fm_mapped_extents51 = getelementptr inbounds %struct.fiemap, ptr %51, i32 0, i32 3
  %52 = load i32, ptr %fm_mapped_extents51, align 4
  %cmp52 = icmp ult i32 %50, %52
  br i1 %cmp52, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %53 = load ptr, ptr %p, align 8
  %54 = load ptr, ptr %fm, align 8
  %fm_extents = getelementptr inbounds %struct.fiemap, ptr %54, i32 0, i32 6
  %55 = load i32, ptr %i, align 4
  %idxprom = sext i32 %55 to i64
  %arrayidx54 = getelementptr [0 x %struct.fiemap_extent], ptr %fm_extents, i64 0, i64 %idxprom
  %arraydecay55 = getelementptr inbounds [2 x i32], ptr %extent_arg_type, i64 0, i64 0
  %call56 = call ptr @thunk_convert(ptr noundef %53, ptr noundef %arrayidx54, ptr noundef %arraydecay55, i32 noundef 0)
  %56 = load i32, ptr %extent_size, align 4
  %57 = load ptr, ptr %p, align 8
  %idx.ext57 = sext i32 %56 to i64
  %add.ptr58 = getelementptr i8, ptr %57, i64 %idx.ext57
  store ptr %add.ptr58, ptr %p, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %58 = load i32, ptr %i, align 4
  %inc = add i32 %58, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !5

for.end:                                          ; preds = %for.cond
  br label %if.end59

if.end59:                                         ; preds = %for.end, %if.else45
  %59 = load ptr, ptr %argptr, align 8
  %60 = load i64, ptr %arg.addr, align 8
  %61 = load i32, ptr %target_size_out, align 4
  %conv60 = sext i32 %61 to i64
  call void @unlock_user(ptr noundef %59, i64 noundef %60, i64 noundef %conv60)
  br label %if.end61

if.end61:                                         ; preds = %if.end59, %if.then44
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %if.end28
  %62 = load i32, ptr %free_fm, align 4
  %tobool63 = icmp ne i32 %62, 0
  br i1 %tobool63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.end62
  %63 = load ptr, ptr %fm, align 8
  call void @g_free(ptr noundef %63)
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %if.end62
  %64 = load i64, ptr %ret, align 8
  store i64 %64, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end65, %if.then26, %if.then15, %if.then9
  %65 = load i64, ptr %retval, align 8
  ret i64 %65
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_usbdevfs_submiturb(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %arg_type = alloca ptr, align 8
  %target_size = alloca i32, align 4
  %ret = alloca i64, align 8
  %argptr = alloca ptr, align 8
  %rw_dir = alloca i32, align 4
  %lurb = alloca ptr, align 8
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %ie.addr, align 8
  %arg_type1 = getelementptr inbounds %struct.IOCTLEntry, ptr %0, i32 0, i32 5
  %arraydecay = getelementptr inbounds [5 x i32], ptr %arg_type1, i64 0, i64 0
  store ptr %arraydecay, ptr %arg_type, align 8
  %1 = load ptr, ptr %arg_type, align 8
  %incdec.ptr = getelementptr i32, ptr %1, i32 1
  store ptr %incdec.ptr, ptr %arg_type, align 8
  %2 = load ptr, ptr %arg_type, align 8
  %call = call i32 @thunk_type_size(ptr noundef %2, i32 noundef 0)
  store i32 %call, ptr %target_size, align 4
  %call2 = call noalias ptr @g_try_malloc0_n(i64 noundef 1, i64 noundef 80) #17
  store ptr %call2, ptr %lurb, align 8
  %3 = load ptr, ptr %lurb, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -12, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i64, ptr %arg.addr, align 8
  %5 = load i32, ptr %target_size, align 4
  %conv = sext i32 %5 to i64
  %call3 = call ptr @lock_user(i32 noundef 1, i64 noundef %4, i64 noundef %conv, i1 noundef zeroext true)
  store ptr %call3, ptr %argptr, align 8
  %6 = load ptr, ptr %argptr, align 8
  %tobool4 = icmp ne ptr %6, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  %7 = load ptr, ptr %lurb, align 8
  call void @g_free(ptr noundef %7)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %8 = load ptr, ptr %lurb, align 8
  %host_urb = getelementptr inbounds %struct.live_urb, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %argptr, align 8
  %10 = load ptr, ptr %arg_type, align 8
  %call7 = call ptr @thunk_convert(ptr noundef %host_urb, ptr noundef %9, ptr noundef %10, i32 noundef 1)
  %11 = load ptr, ptr %argptr, align 8
  %12 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %11, i64 noundef %12, i64 noundef 0)
  %13 = load i64, ptr %arg.addr, align 8
  %14 = load ptr, ptr %lurb, align 8
  %target_urb_adr = getelementptr inbounds %struct.live_urb, ptr %14, i32 0, i32 0
  store i64 %13, ptr %target_urb_adr, align 8
  %15 = load ptr, ptr %lurb, align 8
  %host_urb8 = getelementptr inbounds %struct.live_urb, ptr %15, i32 0, i32 3
  %buffer = getelementptr inbounds %struct.usbdevfs_urb, ptr %host_urb8, i32 0, i32 4
  %16 = load ptr, ptr %buffer, align 8
  %17 = ptrtoint ptr %16 to i64
  %18 = load ptr, ptr %lurb, align 8
  %target_buf_adr = getelementptr inbounds %struct.live_urb, ptr %18, i32 0, i32 1
  store i64 %17, ptr %target_buf_adr, align 8
  %19 = load ptr, ptr %lurb, align 8
  %host_urb9 = getelementptr inbounds %struct.live_urb, ptr %19, i32 0, i32 3
  %endpoint = getelementptr inbounds %struct.usbdevfs_urb, ptr %host_urb9, i32 0, i32 1
  %20 = load i8, ptr %endpoint, align 1
  %conv10 = zext i8 %20 to i32
  %and = and i32 %conv10, 128
  %tobool11 = icmp ne i32 %and, 0
  %cond = select i1 %tobool11, i32 3, i32 1
  store i32 %cond, ptr %rw_dir, align 4
  %21 = load i32, ptr %rw_dir, align 4
  %22 = load ptr, ptr %lurb, align 8
  %target_buf_adr12 = getelementptr inbounds %struct.live_urb, ptr %22, i32 0, i32 1
  %23 = load i64, ptr %target_buf_adr12, align 8
  %24 = load ptr, ptr %lurb, align 8
  %host_urb13 = getelementptr inbounds %struct.live_urb, ptr %24, i32 0, i32 3
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb, ptr %host_urb13, i32 0, i32 5
  %25 = load i32, ptr %buffer_length, align 8
  %conv14 = sext i32 %25 to i64
  %call15 = call ptr @lock_user(i32 noundef %21, i64 noundef %23, i64 noundef %conv14, i1 noundef zeroext true)
  %26 = load ptr, ptr %lurb, align 8
  %target_buf_ptr = getelementptr inbounds %struct.live_urb, ptr %26, i32 0, i32 2
  store ptr %call15, ptr %target_buf_ptr, align 8
  %27 = load ptr, ptr %lurb, align 8
  %target_buf_ptr16 = getelementptr inbounds %struct.live_urb, ptr %27, i32 0, i32 2
  %28 = load ptr, ptr %target_buf_ptr16, align 8
  %cmp = icmp eq ptr %28, null
  br i1 %cmp, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end6
  %29 = load ptr, ptr %lurb, align 8
  call void @g_free(ptr noundef %29)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %if.end6
  %30 = load ptr, ptr %lurb, align 8
  %target_buf_ptr20 = getelementptr inbounds %struct.live_urb, ptr %30, i32 0, i32 2
  %31 = load ptr, ptr %target_buf_ptr20, align 8
  %32 = load ptr, ptr %lurb, align 8
  %host_urb21 = getelementptr inbounds %struct.live_urb, ptr %32, i32 0, i32 3
  %buffer22 = getelementptr inbounds %struct.usbdevfs_urb, ptr %host_urb21, i32 0, i32 4
  store ptr %31, ptr %buffer22, align 8
  %33 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %34 = load ptr, ptr %33, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %34, i32 0, i32 39
  %35 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %35, i32 0, i32 14
  %36 = load i32, ptr %fd.addr, align 4
  %37 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %37, i32 0, i32 1
  %38 = load i32, ptr %host_cmd, align 4
  %39 = load ptr, ptr %lurb, align 8
  %host_urb23 = getelementptr inbounds %struct.live_urb, ptr %39, i32 0, i32 3
  %call24 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %36, i32 noundef %38, ptr noundef %host_urb23)
  %call25 = call i64 @get_errno(i64 noundef %call24)
  store i64 %call25, ptr %ret, align 8
  %40 = load i64, ptr %ret, align 8
  %call26 = call i32 @is_error(i64 noundef %40)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %if.then28, label %if.else

if.then28:                                        ; preds = %if.end19
  %41 = load ptr, ptr %lurb, align 8
  %target_buf_ptr29 = getelementptr inbounds %struct.live_urb, ptr %41, i32 0, i32 2
  %42 = load ptr, ptr %target_buf_ptr29, align 8
  %43 = load ptr, ptr %lurb, align 8
  %target_buf_adr30 = getelementptr inbounds %struct.live_urb, ptr %43, i32 0, i32 1
  %44 = load i64, ptr %target_buf_adr30, align 8
  call void @unlock_user(ptr noundef %42, i64 noundef %44, i64 noundef 0)
  %45 = load ptr, ptr %lurb, align 8
  call void @g_free(ptr noundef %45)
  br label %if.end31

if.else:                                          ; preds = %if.end19
  %46 = load ptr, ptr %lurb, align 8
  call void @urb_hashtable_insert(ptr noundef %46)
  br label %if.end31

if.end31:                                         ; preds = %if.else, %if.then28
  %47 = load i64, ptr %ret, align 8
  store i64 %47, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end31, %if.then18, %if.then5, %if.then
  %48 = load i64, ptr %retval, align 8
  ret i64 %48
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_usbdevfs_discardurb(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %lurb = alloca ptr, align 8
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load i64, ptr %arg.addr, align 8
  %call = call ptr @urb_hashtable_lookup(i64 noundef %0)
  store ptr %call, ptr %lurb, align 8
  %1 = load ptr, ptr %lurb, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %3 = load ptr, ptr %2, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %3, i32 0, i32 39
  %4 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %4, i32 0, i32 14
  %5 = load i32, ptr %fd.addr, align 4
  %6 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %6, i32 0, i32 1
  %7 = load i32, ptr %host_cmd, align 4
  %8 = load ptr, ptr %lurb, align 8
  %host_urb = getelementptr inbounds %struct.live_urb, ptr %8, i32 0, i32 3
  %call1 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %5, i32 noundef %7, ptr noundef %host_urb)
  %call2 = call i64 @get_errno(i64 noundef %call1)
  store i64 %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i64, ptr %retval, align 8
  ret i64 %9
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_usbdevfs_reapurb(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %usbfsurb_arg_type = alloca [2 x i32], align 4
  %ptrvoid_arg_type = alloca [3 x i32], align 4
  %lurb = alloca ptr, align 8
  %argptr = alloca ptr, align 8
  %hurb = alloca i64, align 8
  %target_size = alloca i32, align 4
  %target_urb_adr = alloca i64, align 8
  %ret = alloca i64, align 8
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %usbfsurb_arg_type, ptr align 4 @__const.do_ioctl_usbdevfs_reapurb.usbfsurb_arg_type, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %ptrvoid_arg_type, ptr align 4 @__const.do_ioctl_usbdevfs_reapurb.ptrvoid_arg_type, i64 12, i1 false)
  %arraydecay = getelementptr inbounds [2 x i32], ptr %usbfsurb_arg_type, i64 0, i64 0
  %call = call i32 @thunk_type_size(ptr noundef %arraydecay, i32 noundef 0)
  store i32 %call, ptr %target_size, align 4
  %0 = load ptr, ptr %buf_temp.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %0, i8 0, i64 8, i1 false)
  %1 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %2 = load ptr, ptr %1, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %2, i32 0, i32 39
  %3 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %3, i32 0, i32 14
  %4 = load i32, ptr %fd.addr, align 4
  %5 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %host_cmd, align 4
  %7 = load ptr, ptr %buf_temp.addr, align 8
  %call1 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %4, i32 noundef %6, ptr noundef %7)
  %call2 = call i64 @get_errno(i64 noundef %call1)
  store i64 %call2, ptr %ret, align 8
  %8 = load i64, ptr %ret, align 8
  %call3 = call i32 @is_error(i64 noundef %8)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load i64, ptr %ret, align 8
  store i64 %9, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load ptr, ptr %buf_temp.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %hurb, ptr align 1 %10, i64 8, i1 false)
  %11 = load i64, ptr %hurb, align 8
  %sub = sub i64 %11, 24
  %12 = inttoptr i64 %sub to ptr
  store ptr %12, ptr %lurb, align 8
  %13 = load ptr, ptr %lurb, align 8
  %target_urb_adr4 = getelementptr inbounds %struct.live_urb, ptr %13, i32 0, i32 0
  %14 = load i64, ptr %target_urb_adr4, align 8
  %tobool5 = icmp ne i64 %14, 0
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end
  %15 = load ptr, ptr %lurb, align 8
  call void @urb_hashtable_remove(ptr noundef %15)
  %16 = load ptr, ptr %lurb, align 8
  %target_buf_ptr = getelementptr inbounds %struct.live_urb, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %target_buf_ptr, align 8
  %18 = load ptr, ptr %lurb, align 8
  %target_buf_adr = getelementptr inbounds %struct.live_urb, ptr %18, i32 0, i32 1
  %19 = load i64, ptr %target_buf_adr, align 8
  %20 = load ptr, ptr %lurb, align 8
  %host_urb = getelementptr inbounds %struct.live_urb, ptr %20, i32 0, i32 3
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb, ptr %host_urb, i32 0, i32 5
  %21 = load i32, ptr %buffer_length, align 8
  %conv = sext i32 %21 to i64
  call void @unlock_user(ptr noundef %17, i64 noundef %19, i64 noundef %conv)
  %22 = load ptr, ptr %lurb, align 8
  %target_buf_ptr8 = getelementptr inbounds %struct.live_urb, ptr %22, i32 0, i32 2
  store ptr null, ptr %target_buf_ptr8, align 8
  %23 = load ptr, ptr %lurb, align 8
  %target_buf_adr9 = getelementptr inbounds %struct.live_urb, ptr %23, i32 0, i32 1
  %24 = load i64, ptr %target_buf_adr9, align 8
  %25 = inttoptr i64 %24 to ptr
  %26 = load ptr, ptr %lurb, align 8
  %host_urb10 = getelementptr inbounds %struct.live_urb, ptr %26, i32 0, i32 3
  %buffer = getelementptr inbounds %struct.usbdevfs_urb, ptr %host_urb10, i32 0, i32 4
  store ptr %25, ptr %buffer, align 8
  %27 = load ptr, ptr %lurb, align 8
  %target_urb_adr11 = getelementptr inbounds %struct.live_urb, ptr %27, i32 0, i32 0
  %28 = load i64, ptr %target_urb_adr11, align 8
  %29 = load i32, ptr %target_size, align 4
  %conv12 = sext i32 %29 to i64
  %call13 = call ptr @lock_user(i32 noundef 3, i64 noundef %28, i64 noundef %conv12, i1 noundef zeroext false)
  store ptr %call13, ptr %argptr, align 8
  %30 = load ptr, ptr %argptr, align 8
  %tobool14 = icmp ne ptr %30, null
  br i1 %tobool14, label %if.end16, label %if.then15

if.then15:                                        ; preds = %if.end7
  %31 = load ptr, ptr %lurb, align 8
  call void @g_free(ptr noundef %31)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end7
  %32 = load ptr, ptr %argptr, align 8
  %33 = load ptr, ptr %lurb, align 8
  %host_urb17 = getelementptr inbounds %struct.live_urb, ptr %33, i32 0, i32 3
  %arraydecay18 = getelementptr inbounds [2 x i32], ptr %usbfsurb_arg_type, i64 0, i64 0
  %call19 = call ptr @thunk_convert(ptr noundef %32, ptr noundef %host_urb17, ptr noundef %arraydecay18, i32 noundef 0)
  %34 = load ptr, ptr %argptr, align 8
  %35 = load ptr, ptr %lurb, align 8
  %target_urb_adr20 = getelementptr inbounds %struct.live_urb, ptr %35, i32 0, i32 0
  %36 = load i64, ptr %target_urb_adr20, align 8
  %37 = load i32, ptr %target_size, align 4
  %conv21 = sext i32 %37 to i64
  call void @unlock_user(ptr noundef %34, i64 noundef %36, i64 noundef %conv21)
  %arraydecay22 = getelementptr inbounds [3 x i32], ptr %ptrvoid_arg_type, i64 0, i64 0
  %call23 = call i32 @thunk_type_size(ptr noundef %arraydecay22, i32 noundef 0)
  store i32 %call23, ptr %target_size, align 4
  %38 = load i64, ptr %arg.addr, align 8
  %39 = load i32, ptr %target_size, align 4
  %conv24 = sext i32 %39 to i64
  %call25 = call ptr @lock_user(i32 noundef 3, i64 noundef %38, i64 noundef %conv24, i1 noundef zeroext false)
  store ptr %call25, ptr %argptr, align 8
  %40 = load ptr, ptr %argptr, align 8
  %tobool26 = icmp ne ptr %40, null
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end16
  %41 = load ptr, ptr %lurb, align 8
  call void @g_free(ptr noundef %41)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end28:                                         ; preds = %if.end16
  %42 = load ptr, ptr %lurb, align 8
  %target_urb_adr29 = getelementptr inbounds %struct.live_urb, ptr %42, i32 0, i32 0
  %43 = load i64, ptr %target_urb_adr29, align 8
  store i64 %43, ptr %target_urb_adr, align 8
  %44 = load ptr, ptr %argptr, align 8
  %arraydecay30 = getelementptr inbounds [3 x i32], ptr %ptrvoid_arg_type, i64 0, i64 0
  %call31 = call ptr @thunk_convert(ptr noundef %44, ptr noundef %target_urb_adr, ptr noundef %arraydecay30, i32 noundef 0)
  %45 = load ptr, ptr %argptr, align 8
  %46 = load i64, ptr %arg.addr, align 8
  %47 = load i32, ptr %target_size, align 4
  %conv32 = sext i32 %47 to i64
  call void @unlock_user(ptr noundef %45, i64 noundef %46, i64 noundef %conv32)
  %48 = load ptr, ptr %lurb, align 8
  call void @g_free(ptr noundef %48)
  %49 = load i64, ptr %ret, align 8
  store i64 %49, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end28, %if.then27, %if.then15, %if.then6, %if.then
  %50 = load i64, ptr %retval, align 8
  ret i64 %50
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_ifconf(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %arg_type = alloca ptr, align 8
  %target_size = alloca i32, align 4
  %argptr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %host_ifconf = alloca ptr, align 8
  %outbufsz = alloca i32, align 4
  %ifreq_arg_type = alloca [2 x i32], align 4
  %ifreq_max_type = alloca [2 x i32], align 4
  %target_ifreq_size = alloca i32, align 4
  %nb_ifreq = alloca i32, align 4
  %free_buf = alloca i32, align 4
  %i = alloca i32, align 4
  %target_ifc_len = alloca i32, align 4
  %target_ifc_buf = alloca i64, align 8
  %host_ifc_len = alloca i32, align 4
  %host_ifc_buf = alloca ptr, align 8
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %ie.addr, align 8
  %arg_type1 = getelementptr inbounds %struct.IOCTLEntry, ptr %0, i32 0, i32 5
  %arraydecay = getelementptr inbounds [5 x i32], ptr %arg_type1, i64 0, i64 0
  store ptr %arraydecay, ptr %arg_type, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %ifreq_arg_type, ptr align 4 @__const.do_ioctl_ifconf.ifreq_arg_type, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %ifreq_max_type, ptr align 4 @__const.do_ioctl_ifconf.ifreq_max_type, i64 8, i1 false)
  store i32 0, ptr %free_buf, align 4
  %1 = load ptr, ptr %arg_type, align 8
  %arrayidx = getelementptr i32, ptr %1, i64 0
  %2 = load i32, ptr %arrayidx, align 4
  %cmp = icmp eq i32 %2, 9
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.578, ptr noundef @.str.579, i32 noundef 4726, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_ifconf) #15
  unreachable

if.end:                                           ; preds = %if.then
  %3 = load ptr, ptr %ie.addr, align 8
  %access = getelementptr inbounds %struct.IOCTLEntry, ptr %3, i32 0, i32 3
  %4 = load i32, ptr %access, align 8
  %cmp2 = icmp eq i32 %4, 3
  br i1 %cmp2, label %if.then3, label %if.else4

if.then3:                                         ; preds = %if.end
  br label %if.end5

if.else4:                                         ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.580, ptr noundef @.str.579, i32 noundef 4727, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_ifconf) #15
  unreachable

if.end5:                                          ; preds = %if.then3
  %5 = load ptr, ptr %arg_type, align 8
  %incdec.ptr = getelementptr i32, ptr %5, i32 1
  store ptr %incdec.ptr, ptr %arg_type, align 8
  %6 = load ptr, ptr %arg_type, align 8
  %call = call i32 @thunk_type_size(ptr noundef %6, i32 noundef 0)
  store i32 %call, ptr %target_size, align 4
  %7 = load i64, ptr %arg.addr, align 8
  %8 = load i32, ptr %target_size, align 4
  %conv = sext i32 %8 to i64
  %call6 = call ptr @lock_user(i32 noundef 1, i64 noundef %7, i64 noundef %conv, i1 noundef zeroext true)
  store ptr %call6, ptr %argptr, align 8
  %9 = load ptr, ptr %argptr, align 8
  %tobool = icmp ne ptr %9, null
  br i1 %tobool, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end5
  store i64 -14, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end5
  %10 = load ptr, ptr %buf_temp.addr, align 8
  %11 = load ptr, ptr %argptr, align 8
  %12 = load ptr, ptr %arg_type, align 8
  %call9 = call ptr @thunk_convert(ptr noundef %10, ptr noundef %11, ptr noundef %12, i32 noundef 1)
  %13 = load ptr, ptr %argptr, align 8
  %14 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %13, i64 noundef %14, i64 noundef 0)
  %15 = load ptr, ptr %buf_temp.addr, align 8
  %16 = ptrtoint ptr %15 to i64
  %17 = inttoptr i64 %16 to ptr
  store ptr %17, ptr %host_ifconf, align 8
  %18 = load ptr, ptr %host_ifconf, align 8
  %ifc_ifcu = getelementptr inbounds %struct.ifconf, ptr %18, i32 0, i32 1
  %19 = load ptr, ptr %ifc_ifcu, align 8
  %20 = ptrtoint ptr %19 to i64
  store i64 %20, ptr %target_ifc_buf, align 8
  %arraydecay10 = getelementptr inbounds [2 x i32], ptr %ifreq_max_type, i64 0, i64 0
  %call11 = call i32 @thunk_type_size(ptr noundef %arraydecay10, i32 noundef 0)
  store i32 %call11, ptr %target_ifreq_size, align 4
  %21 = load i64, ptr %target_ifc_buf, align 8
  %cmp12 = icmp ne i64 %21, 0
  br i1 %cmp12, label %if.then14, label %if.else29

if.then14:                                        ; preds = %if.end8
  %22 = load ptr, ptr %host_ifconf, align 8
  %ifc_len = getelementptr inbounds %struct.ifconf, ptr %22, i32 0, i32 0
  %23 = load i32, ptr %ifc_len, align 8
  store i32 %23, ptr %target_ifc_len, align 4
  %24 = load i32, ptr %target_ifc_len, align 4
  %25 = load i32, ptr %target_ifreq_size, align 4
  %div = sdiv i32 %24, %25
  store i32 %div, ptr %nb_ifreq, align 4
  %26 = load i32, ptr %nb_ifreq, align 4
  %conv15 = sext i32 %26 to i64
  %mul = mul i64 %conv15, 40
  %conv16 = trunc i64 %mul to i32
  store i32 %conv16, ptr %host_ifc_len, align 4
  %27 = load i32, ptr %host_ifc_len, align 4
  %conv17 = sext i32 %27 to i64
  %add = add i64 16, %conv17
  %conv18 = trunc i64 %add to i32
  store i32 %conv18, ptr %outbufsz, align 4
  %28 = load i32, ptr %outbufsz, align 4
  %cmp19 = icmp ugt i32 %28, 4096
  br i1 %cmp19, label %if.then21, label %if.end27

if.then21:                                        ; preds = %if.then14
  %29 = load i32, ptr %outbufsz, align 4
  %conv22 = zext i32 %29 to i64
  %call23 = call noalias ptr @g_try_malloc(i64 noundef %conv22) #16
  store ptr %call23, ptr %host_ifconf, align 8
  %30 = load ptr, ptr %host_ifconf, align 8
  %tobool24 = icmp ne ptr %30, null
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.then21
  store i64 -12, ptr %retval, align 8
  br label %return

if.end26:                                         ; preds = %if.then21
  %31 = load ptr, ptr %host_ifconf, align 8
  %32 = load ptr, ptr %buf_temp.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %31, ptr align 1 %32, i64 16, i1 false)
  store i32 1, ptr %free_buf, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %if.then14
  %33 = load ptr, ptr %host_ifconf, align 8
  %add.ptr = getelementptr i8, ptr %33, i64 16
  store ptr %add.ptr, ptr %host_ifc_buf, align 8
  %34 = load i32, ptr %host_ifc_len, align 4
  %35 = load ptr, ptr %host_ifconf, align 8
  %ifc_len28 = getelementptr inbounds %struct.ifconf, ptr %35, i32 0, i32 0
  store i32 %34, ptr %ifc_len28, align 8
  br label %if.end30

if.else29:                                        ; preds = %if.end8
  store ptr null, ptr %host_ifc_buf, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.else29, %if.end27
  %36 = load ptr, ptr %host_ifc_buf, align 8
  %37 = load ptr, ptr %host_ifconf, align 8
  %ifc_ifcu31 = getelementptr inbounds %struct.ifconf, ptr %37, i32 0, i32 1
  store ptr %36, ptr %ifc_ifcu31, align 8
  %38 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %39 = load ptr, ptr %38, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %39, i32 0, i32 39
  %40 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %40, i32 0, i32 14
  %41 = load i32, ptr %fd.addr, align 4
  %42 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %42, i32 0, i32 1
  %43 = load i32, ptr %host_cmd, align 4
  %44 = load ptr, ptr %host_ifconf, align 8
  %call32 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %41, i32 noundef %43, ptr noundef %44)
  %call33 = call i64 @get_errno(i64 noundef %call32)
  %conv34 = trunc i64 %call33 to i32
  store i32 %conv34, ptr %ret, align 4
  %45 = load i32, ptr %ret, align 4
  %conv35 = sext i32 %45 to i64
  %call36 = call i32 @is_error(i64 noundef %conv35)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %if.end69, label %if.then38

if.then38:                                        ; preds = %if.end30
  %46 = load ptr, ptr %host_ifconf, align 8
  %ifc_len39 = getelementptr inbounds %struct.ifconf, ptr %46, i32 0, i32 0
  %47 = load i32, ptr %ifc_len39, align 8
  %conv40 = sext i32 %47 to i64
  %div41 = udiv i64 %conv40, 40
  %conv42 = trunc i64 %div41 to i32
  store i32 %conv42, ptr %nb_ifreq, align 4
  %48 = load i32, ptr %nb_ifreq, align 4
  %49 = load i32, ptr %target_ifreq_size, align 4
  %mul43 = mul i32 %48, %49
  store i32 %mul43, ptr %target_ifc_len, align 4
  %50 = load i32, ptr %target_ifc_len, align 4
  %51 = load ptr, ptr %host_ifconf, align 8
  %ifc_len44 = getelementptr inbounds %struct.ifconf, ptr %51, i32 0, i32 0
  store i32 %50, ptr %ifc_len44, align 8
  %52 = load i64, ptr %target_ifc_buf, align 8
  %53 = inttoptr i64 %52 to ptr
  %54 = load ptr, ptr %host_ifconf, align 8
  %ifc_ifcu45 = getelementptr inbounds %struct.ifconf, ptr %54, i32 0, i32 1
  store ptr %53, ptr %ifc_ifcu45, align 8
  %55 = load i64, ptr %arg.addr, align 8
  %56 = load i32, ptr %target_size, align 4
  %conv46 = sext i32 %56 to i64
  %call47 = call ptr @lock_user(i32 noundef 3, i64 noundef %55, i64 noundef %conv46, i1 noundef zeroext false)
  store ptr %call47, ptr %argptr, align 8
  %57 = load ptr, ptr %argptr, align 8
  %tobool48 = icmp ne ptr %57, null
  br i1 %tobool48, label %if.end50, label %if.then49

if.then49:                                        ; preds = %if.then38
  store i64 -14, ptr %retval, align 8
  br label %return

if.end50:                                         ; preds = %if.then38
  %58 = load ptr, ptr %argptr, align 8
  %59 = load ptr, ptr %host_ifconf, align 8
  %60 = load ptr, ptr %arg_type, align 8
  %call51 = call ptr @thunk_convert(ptr noundef %58, ptr noundef %59, ptr noundef %60, i32 noundef 0)
  %61 = load ptr, ptr %argptr, align 8
  %62 = load i64, ptr %arg.addr, align 8
  %63 = load i32, ptr %target_size, align 4
  %conv52 = sext i32 %63 to i64
  call void @unlock_user(ptr noundef %61, i64 noundef %62, i64 noundef %conv52)
  %64 = load i64, ptr %target_ifc_buf, align 8
  %cmp53 = icmp ne i64 %64, 0
  br i1 %cmp53, label %if.then55, label %if.end68

if.then55:                                        ; preds = %if.end50
  %65 = load i64, ptr %target_ifc_buf, align 8
  %66 = load i32, ptr %target_ifc_len, align 4
  %conv56 = sext i32 %66 to i64
  %call57 = call ptr @lock_user(i32 noundef 3, i64 noundef %65, i64 noundef %conv56, i1 noundef zeroext false)
  store ptr %call57, ptr %argptr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then55
  %67 = load i32, ptr %i, align 4
  %68 = load i32, ptr %nb_ifreq, align 4
  %cmp58 = icmp slt i32 %67, %68
  br i1 %cmp58, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %69 = load ptr, ptr %argptr, align 8
  %70 = load i32, ptr %i, align 4
  %71 = load i32, ptr %target_ifreq_size, align 4
  %mul60 = mul i32 %70, %71
  %idx.ext = sext i32 %mul60 to i64
  %add.ptr61 = getelementptr i8, ptr %69, i64 %idx.ext
  %72 = load ptr, ptr %host_ifc_buf, align 8
  %73 = load i32, ptr %i, align 4
  %conv62 = sext i32 %73 to i64
  %mul63 = mul i64 %conv62, 40
  %add.ptr64 = getelementptr i8, ptr %72, i64 %mul63
  %arraydecay65 = getelementptr inbounds [2 x i32], ptr %ifreq_arg_type, i64 0, i64 0
  %call66 = call ptr @thunk_convert(ptr noundef %add.ptr61, ptr noundef %add.ptr64, ptr noundef %arraydecay65, i32 noundef 0)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %74 = load i32, ptr %i, align 4
  %inc = add i32 %74, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !7

for.end:                                          ; preds = %for.cond
  %75 = load ptr, ptr %argptr, align 8
  %76 = load i64, ptr %target_ifc_buf, align 8
  %77 = load i32, ptr %target_ifc_len, align 4
  %conv67 = sext i32 %77 to i64
  call void @unlock_user(ptr noundef %75, i64 noundef %76, i64 noundef %conv67)
  br label %if.end68

if.end68:                                         ; preds = %for.end, %if.end50
  br label %if.end69

if.end69:                                         ; preds = %if.end68, %if.end30
  %78 = load i32, ptr %free_buf, align 4
  %tobool70 = icmp ne i32 %78, 0
  br i1 %tobool70, label %if.then71, label %if.end72

if.then71:                                        ; preds = %if.end69
  %79 = load ptr, ptr %host_ifconf, align 8
  call void @g_free(ptr noundef %79)
  br label %if.end72

if.end72:                                         ; preds = %if.then71, %if.end69
  %80 = load i32, ptr %ret, align 4
  %conv73 = sext i32 %80 to i64
  store i64 %conv73, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end72, %if.then49, %if.then25, %if.then7
  %81 = load i64, ptr %retval, align 8
  ret i64 %81
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_SIOCGSTAMP(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %tv = alloca %struct.timeval, align 8
  %ret = alloca i64, align 8
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %3, i32 noundef 35078, ptr noundef %tv)
  %call1 = call i64 @get_errno(i64 noundef %call)
  store i64 %call1, ptr %ret, align 8
  %4 = load i64, ptr %ret, align 8
  %call2 = call i32 @is_error(i64 noundef %4)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i64, ptr %ret, align 8
  store i64 %5, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, ptr %cmd.addr, align 4
  %cmp = icmp eq i32 %6, 35078
  br i1 %cmp, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %7 = load i64, ptr %arg.addr, align 8
  %call4 = call i64 @copy_to_user_timeval(i64 noundef %7, ptr noundef %tv)
  %tobool5 = icmp ne i64 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.then3
  store i64 -14, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.then3
  br label %if.end12

if.else:                                          ; preds = %if.end
  %8 = load i64, ptr %arg.addr, align 8
  %call8 = call i64 @copy_to_user_timeval64(i64 noundef %8, ptr noundef %tv)
  %tobool9 = icmp ne i64 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.else
  store i64 -14, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.else
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end7
  %9 = load i64, ptr %ret, align 8
  store i64 %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then10, %if.then6, %if.then
  %10 = load i64, ptr %retval, align 8
  ret i64 %10
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_SIOCGSTAMPNS(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %ts = alloca %struct.timespec, align 8
  %ret = alloca i64, align 8
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %3, i32 noundef 35079, ptr noundef %ts)
  %call1 = call i64 @get_errno(i64 noundef %call)
  store i64 %call1, ptr %ret, align 8
  %4 = load i64, ptr %ret, align 8
  %call2 = call i32 @is_error(i64 noundef %4)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i64, ptr %ret, align 8
  store i64 %5, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, ptr %cmd.addr, align 4
  %cmp = icmp eq i32 %6, 35079
  br i1 %cmp, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %7 = load i64, ptr %arg.addr, align 8
  %call4 = call i64 @host_to_target_timespec(i64 noundef %7, ptr noundef %ts)
  %tobool5 = icmp ne i64 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.then3
  store i64 -14, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.then3
  br label %if.end12

if.else:                                          ; preds = %if.end
  %8 = load i64, ptr %arg.addr, align 8
  %call8 = call i64 @host_to_target_timespec64(i64 noundef %8, ptr noundef %ts)
  %tobool9 = icmp ne i64 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.else
  store i64 -14, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.else
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end7
  %9 = load i64, ptr %ret, align 8
  store i64 %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then10, %if.then6, %if.then
  %10 = load i64, ptr %retval, align 8
  ret i64 %10
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_dm(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %argptr = alloca ptr, align 8
  %host_dm = alloca ptr, align 8
  %guest_data = alloca i64, align 8
  %guest_data_size = alloca i32, align 4
  %target_size = alloca i32, align 4
  %arg_type = alloca ptr, align 8
  %ret = alloca i64, align 8
  %big_buf = alloca ptr, align 8
  %host_data = alloca ptr, align 8
  %gspec = alloca ptr, align 8
  %cur_data = alloca ptr, align 8
  %dm_arg_type = alloca [2 x i32], align 4
  %spec_size = alloca i32, align 4
  %i = alloca i32, align 4
  %spec = alloca ptr, align 8
  %next = alloca i32, align 4
  %slen = alloca i32, align 4
  %nl = alloca ptr, align 8
  %remaining_data = alloca i32, align 4
  %cur_data70 = alloca ptr, align 8
  %dm_arg_type71 = alloca [2 x i32], align 4
  %nl_size = alloca i32, align 4
  %next72 = alloca i32, align 4
  %spec107 = alloca ptr, align 8
  %cur_data111 = alloca ptr, align 8
  %dm_arg_type112 = alloca [2 x i32], align 4
  %spec_size113 = alloca i32, align 4
  %i116 = alloca i32, align 4
  %next122 = alloca i32, align 4
  %slen124 = alloca i32, align 4
  %hdata = alloca ptr, align 8
  %count = alloca i32, align 4
  %hdev = alloca ptr, align 8
  %gdev = alloca ptr, align 8
  %i165 = alloca i32, align 4
  %vers = alloca ptr, align 8
  %remaining_data181 = alloca i32, align 4
  %cur_data182 = alloca ptr, align 8
  %dm_arg_type183 = alloca [2 x i32], align 4
  %vers_size = alloca i32, align 4
  %next187 = alloca i32, align 4
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %ie.addr, align 8
  %arg_type1 = getelementptr inbounds %struct.IOCTLEntry, ptr %0, i32 0, i32 5
  %arraydecay = getelementptr inbounds [5 x i32], ptr %arg_type1, i64 0, i64 0
  store ptr %arraydecay, ptr %arg_type, align 8
  store ptr null, ptr %big_buf, align 8
  %1 = load ptr, ptr %arg_type, align 8
  %incdec.ptr = getelementptr i32, ptr %1, i32 1
  store ptr %incdec.ptr, ptr %arg_type, align 8
  %2 = load ptr, ptr %arg_type, align 8
  %call = call i32 @thunk_type_size(ptr noundef %2, i32 noundef 0)
  store i32 %call, ptr %target_size, align 4
  %3 = load i64, ptr %arg.addr, align 8
  %4 = load i32, ptr %target_size, align 4
  %conv = sext i32 %4 to i64
  %call2 = call ptr @lock_user(i32 noundef 1, i64 noundef %3, i64 noundef %conv, i1 noundef zeroext true)
  store ptr %call2, ptr %argptr, align 8
  %5 = load ptr, ptr %argptr, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %ret, align 8
  br label %out

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %buf_temp.addr, align 8
  %7 = load ptr, ptr %argptr, align 8
  %8 = load ptr, ptr %arg_type, align 8
  %call3 = call ptr @thunk_convert(ptr noundef %6, ptr noundef %7, ptr noundef %8, i32 noundef 1)
  %9 = load ptr, ptr %argptr, align 8
  %10 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %9, i64 noundef %10, i64 noundef 0)
  %11 = load ptr, ptr %buf_temp.addr, align 8
  %data_size = getelementptr inbounds %struct.dm_ioctl, ptr %11, i32 0, i32 1
  %12 = load i32, ptr %data_size, align 4
  %mul = mul i32 %12, 2
  %conv4 = zext i32 %mul to i64
  %call5 = call noalias ptr @g_malloc0(i64 noundef %conv4) #16
  store ptr %call5, ptr %big_buf, align 8
  %13 = load ptr, ptr %big_buf, align 8
  %14 = load ptr, ptr %buf_temp.addr, align 8
  %15 = load i32, ptr %target_size, align 4
  %conv6 = sext i32 %15 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %13, ptr align 1 %14, i64 %conv6, i1 false)
  %16 = load ptr, ptr %big_buf, align 8
  store ptr %16, ptr %buf_temp.addr, align 8
  %17 = load ptr, ptr %big_buf, align 8
  store ptr %17, ptr %host_dm, align 8
  %18 = load i64, ptr %arg.addr, align 8
  %19 = load ptr, ptr %host_dm, align 8
  %data_start = getelementptr inbounds %struct.dm_ioctl, ptr %19, i32 0, i32 2
  %20 = load i32, ptr %data_start, align 8
  %conv7 = zext i32 %20 to i64
  %add = add i64 %18, %conv7
  store i64 %add, ptr %guest_data, align 8
  %21 = load i64, ptr %guest_data, align 8
  %22 = load i64, ptr %arg.addr, align 8
  %sub = sub i64 %21, %22
  %cmp = icmp slt i64 %sub, 0
  br i1 %cmp, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  store i64 -22, ptr %ret, align 8
  br label %out

if.end10:                                         ; preds = %if.end
  %23 = load ptr, ptr %host_dm, align 8
  %data_size11 = getelementptr inbounds %struct.dm_ioctl, ptr %23, i32 0, i32 1
  %24 = load i32, ptr %data_size11, align 4
  %25 = load ptr, ptr %host_dm, align 8
  %data_start12 = getelementptr inbounds %struct.dm_ioctl, ptr %25, i32 0, i32 2
  %26 = load i32, ptr %data_start12, align 8
  %sub13 = sub i32 %24, %26
  store i32 %sub13, ptr %guest_data_size, align 4
  %27 = load ptr, ptr %host_dm, align 8
  %28 = load ptr, ptr %host_dm, align 8
  %data_start14 = getelementptr inbounds %struct.dm_ioctl, ptr %28, i32 0, i32 2
  %29 = load i32, ptr %data_start14, align 8
  %idx.ext = zext i32 %29 to i64
  %add.ptr = getelementptr i8, ptr %27, i64 %idx.ext
  store ptr %add.ptr, ptr %host_data, align 8
  %30 = load i64, ptr %guest_data, align 8
  %31 = load i32, ptr %guest_data_size, align 4
  %conv15 = zext i32 %31 to i64
  %call16 = call ptr @lock_user(i32 noundef 1, i64 noundef %30, i64 noundef %conv15, i1 noundef zeroext true)
  store ptr %call16, ptr %argptr, align 8
  %32 = load ptr, ptr %argptr, align 8
  %tobool17 = icmp ne ptr %32, null
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end10
  store i64 -14, ptr %ret, align 8
  br label %out

if.end19:                                         ; preds = %if.end10
  %33 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %33, i32 0, i32 1
  %34 = load i32, ptr %host_cmd, align 4
  switch i32 %34, label %sw.default [
    i32 -1053229823, label %sw.bb
    i32 -1053229822, label %sw.bb
    i32 -1053229821, label %sw.bb
    i32 -1053229820, label %sw.bb
    i32 -1053229818, label %sw.bb
    i32 -1053229817, label %sw.bb
    i32 -1053229816, label %sw.bb
    i32 -1053229812, label %sw.bb
    i32 -1053229814, label %sw.bb
    i32 -1053229813, label %sw.bb
    i32 -1053229811, label %sw.bb
    i32 -1053229819, label %sw.bb20
    i32 -1053229809, label %sw.bb20
    i32 -1053229810, label %sw.bb22
    i32 -1053229815, label %sw.bb25
  ]

sw.bb:                                            ; preds = %if.end19, %if.end19, %if.end19, %if.end19, %if.end19, %if.end19, %if.end19, %if.end19, %if.end19, %if.end19, %if.end19
  br label %sw.epilog

sw.bb20:                                          ; preds = %if.end19, %if.end19
  %35 = load ptr, ptr %host_data, align 8
  %36 = load ptr, ptr %argptr, align 8
  %37 = load i32, ptr %guest_data_size, align 4
  %conv21 = zext i32 %37 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %35, ptr align 1 %36, i64 %conv21, i1 false)
  br label %sw.epilog

sw.bb22:                                          ; preds = %if.end19
  %38 = load ptr, ptr %host_data, align 8
  %39 = load ptr, ptr %argptr, align 8
  %40 = load i32, ptr %guest_data_size, align 4
  %conv23 = zext i32 %40 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %38, ptr align 1 %39, i64 %conv23, i1 false)
  %41 = load ptr, ptr %argptr, align 8
  %42 = load i64, ptr %41, align 8
  %call24 = call i64 @tswap64(i64 noundef %42)
  %43 = load ptr, ptr %host_data, align 8
  store i64 %call24, ptr %43, align 8
  br label %sw.epilog

sw.bb25:                                          ; preds = %if.end19
  %44 = load ptr, ptr %argptr, align 8
  store ptr %44, ptr %gspec, align 8
  %45 = load ptr, ptr %host_data, align 8
  store ptr %45, ptr %cur_data, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %dm_arg_type, ptr align 4 @__const.do_ioctl_dm.dm_arg_type, i64 8, i1 false)
  %arraydecay26 = getelementptr inbounds [2 x i32], ptr %dm_arg_type, i64 0, i64 0
  %call27 = call i32 @thunk_type_size(ptr noundef %arraydecay26, i32 noundef 0)
  store i32 %call27, ptr %spec_size, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb25
  %46 = load i32, ptr %i, align 4
  %47 = load ptr, ptr %host_dm, align 8
  %target_count = getelementptr inbounds %struct.dm_ioctl, ptr %47, i32 0, i32 3
  %48 = load i32, ptr %target_count, align 4
  %cmp28 = icmp ult i32 %46, %48
  br i1 %cmp28, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %49 = load ptr, ptr %cur_data, align 8
  store ptr %49, ptr %spec, align 8
  %50 = load ptr, ptr %spec, align 8
  %51 = load ptr, ptr %gspec, align 8
  %arraydecay30 = getelementptr inbounds [2 x i32], ptr %dm_arg_type, i64 0, i64 0
  %call31 = call ptr @thunk_convert(ptr noundef %50, ptr noundef %51, ptr noundef %arraydecay30, i32 noundef 1)
  %52 = load ptr, ptr %gspec, align 8
  %53 = load i32, ptr %spec_size, align 4
  %idx.ext32 = sext i32 %53 to i64
  %add.ptr33 = getelementptr i8, ptr %52, i64 %idx.ext32
  %call34 = call i64 @strlen(ptr noundef %add.ptr33) #18
  %add35 = add i64 %call34, 1
  %conv36 = trunc i64 %add35 to i32
  store i32 %conv36, ptr %slen, align 4
  %54 = load ptr, ptr %spec, align 8
  %next37 = getelementptr inbounds %struct.dm_target_spec, ptr %54, i32 0, i32 3
  %55 = load i32, ptr %next37, align 4
  store i32 %55, ptr %next, align 4
  %56 = load i32, ptr %slen, align 4
  %conv38 = sext i32 %56 to i64
  %add39 = add i64 40, %conv38
  %conv40 = trunc i64 %add39 to i32
  %57 = load ptr, ptr %spec, align 8
  %next41 = getelementptr inbounds %struct.dm_target_spec, ptr %57, i32 0, i32 3
  store i32 %conv40, ptr %next41, align 4
  %58 = load ptr, ptr %spec, align 8
  %arrayidx = getelementptr %struct.dm_target_spec, ptr %58, i64 1
  %59 = load ptr, ptr %gspec, align 8
  %60 = load i32, ptr %spec_size, align 4
  %idx.ext42 = sext i32 %60 to i64
  %add.ptr43 = getelementptr i8, ptr %59, i64 %idx.ext42
  %call44 = call ptr @strcpy(ptr noundef %arrayidx, ptr noundef %add.ptr43) #14
  %61 = load i32, ptr %next, align 4
  %62 = load ptr, ptr %gspec, align 8
  %idx.ext45 = zext i32 %61 to i64
  %add.ptr46 = getelementptr i8, ptr %62, i64 %idx.ext45
  store ptr %add.ptr46, ptr %gspec, align 8
  %63 = load ptr, ptr %spec, align 8
  %next47 = getelementptr inbounds %struct.dm_target_spec, ptr %63, i32 0, i32 3
  %64 = load i32, ptr %next47, align 4
  %65 = load ptr, ptr %cur_data, align 8
  %idx.ext48 = zext i32 %64 to i64
  %add.ptr49 = getelementptr i8, ptr %65, i64 %idx.ext48
  store ptr %add.ptr49, ptr %cur_data, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %66 = load i32, ptr %i, align 4
  %inc = add i32 %66, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !8

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

sw.default:                                       ; preds = %if.end19
  store i64 -22, ptr %ret, align 8
  %67 = load ptr, ptr %argptr, align 8
  %68 = load i64, ptr %guest_data, align 8
  call void @unlock_user(ptr noundef %67, i64 noundef %68, i64 noundef 0)
  br label %out

sw.epilog:                                        ; preds = %for.end, %sw.bb22, %sw.bb20, %sw.bb
  %69 = load ptr, ptr %argptr, align 8
  %70 = load i64, ptr %guest_data, align 8
  call void @unlock_user(ptr noundef %69, i64 noundef %70, i64 noundef 0)
  %71 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %72 = load ptr, ptr %71, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %72, i32 0, i32 39
  %73 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %73, i32 0, i32 14
  %74 = load i32, ptr %fd.addr, align 4
  %75 = load ptr, ptr %ie.addr, align 8
  %host_cmd50 = getelementptr inbounds %struct.IOCTLEntry, ptr %75, i32 0, i32 1
  %76 = load i32, ptr %host_cmd50, align 4
  %77 = load ptr, ptr %buf_temp.addr, align 8
  %call51 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %74, i32 noundef %76, ptr noundef %77)
  %call52 = call i64 @get_errno(i64 noundef %call51)
  store i64 %call52, ptr %ret, align 8
  %78 = load i64, ptr %ret, align 8
  %call53 = call i32 @is_error(i64 noundef %78)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %if.end235, label %if.then55

if.then55:                                        ; preds = %sw.epilog
  %79 = load i64, ptr %arg.addr, align 8
  %80 = load ptr, ptr %host_dm, align 8
  %data_start56 = getelementptr inbounds %struct.dm_ioctl, ptr %80, i32 0, i32 2
  %81 = load i32, ptr %data_start56, align 8
  %conv57 = zext i32 %81 to i64
  %add58 = add i64 %79, %conv57
  store i64 %add58, ptr %guest_data, align 8
  %82 = load ptr, ptr %host_dm, align 8
  %data_size59 = getelementptr inbounds %struct.dm_ioctl, ptr %82, i32 0, i32 1
  %83 = load i32, ptr %data_size59, align 4
  %84 = load ptr, ptr %host_dm, align 8
  %data_start60 = getelementptr inbounds %struct.dm_ioctl, ptr %84, i32 0, i32 2
  %85 = load i32, ptr %data_start60, align 8
  %sub61 = sub i32 %83, %85
  store i32 %sub61, ptr %guest_data_size, align 4
  %86 = load i64, ptr %guest_data, align 8
  %87 = load i32, ptr %guest_data_size, align 4
  %conv62 = zext i32 %87 to i64
  %call63 = call ptr @lock_user(i32 noundef 3, i64 noundef %86, i64 noundef %conv62, i1 noundef zeroext false)
  store ptr %call63, ptr %argptr, align 8
  %88 = load ptr, ptr %ie.addr, align 8
  %host_cmd64 = getelementptr inbounds %struct.IOCTLEntry, ptr %88, i32 0, i32 1
  %89 = load i32, ptr %host_cmd64, align 4
  switch i32 %89, label %sw.default225 [
    i32 -1053229823, label %sw.bb65
    i32 -1053229821, label %sw.bb65
    i32 -1053229820, label %sw.bb65
    i32 -1053229819, label %sw.bb65
    i32 -1053229818, label %sw.bb65
    i32 -1053229817, label %sw.bb65
    i32 -1053229815, label %sw.bb65
    i32 -1053229814, label %sw.bb65
    i32 -1053229810, label %sw.bb65
    i32 -1053229809, label %sw.bb65
    i32 -1053229822, label %sw.bb66
    i32 -1053229816, label %sw.bb106
    i32 -1053229812, label %sw.bb106
    i32 -1053229813, label %sw.bb159
    i32 -1053229811, label %sw.bb177
  ]

sw.bb65:                                          ; preds = %if.then55, %if.then55, %if.then55, %if.then55, %if.then55, %if.then55, %if.then55, %if.then55, %if.then55, %if.then55
  br label %sw.epilog226

sw.bb66:                                          ; preds = %if.then55
  %90 = load ptr, ptr %host_dm, align 8
  %91 = load ptr, ptr %host_dm, align 8
  %data_start67 = getelementptr inbounds %struct.dm_ioctl, ptr %91, i32 0, i32 2
  %92 = load i32, ptr %data_start67, align 8
  %idx.ext68 = zext i32 %92 to i64
  %add.ptr69 = getelementptr i8, ptr %90, i64 %idx.ext68
  store ptr %add.ptr69, ptr %nl, align 8
  %93 = load i32, ptr %guest_data_size, align 4
  store i32 %93, ptr %remaining_data, align 4
  %94 = load ptr, ptr %argptr, align 8
  store ptr %94, ptr %cur_data70, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %dm_arg_type71, ptr align 4 @__const.do_ioctl_dm.dm_arg_type.581, i64 8, i1 false)
  store i32 12, ptr %nl_size, align 4
  br label %while.body

while.body:                                       ; preds = %if.end103, %sw.bb66
  %95 = load ptr, ptr %nl, align 8
  %next73 = getelementptr inbounds %struct.dm_name_list, ptr %95, i32 0, i32 1
  %96 = load i32, ptr %next73, align 8
  store i32 %96, ptr %next72, align 4
  %97 = load i32, ptr %next72, align 4
  %tobool74 = icmp ne i32 %97, 0
  br i1 %tobool74, label %if.then75, label %if.end83

if.then75:                                        ; preds = %while.body
  %98 = load i32, ptr %nl_size, align 4
  %conv76 = sext i32 %98 to i64
  %99 = load ptr, ptr %nl, align 8
  %name = getelementptr inbounds %struct.dm_name_list, ptr %99, i32 0, i32 2
  %arraydecay77 = getelementptr inbounds [0 x i8], ptr %name, i64 0, i64 0
  %call78 = call i64 @strlen(ptr noundef %arraydecay77) #18
  %add79 = add i64 %call78, 1
  %add80 = add i64 %conv76, %add79
  %conv81 = trunc i64 %add80 to i32
  %100 = load ptr, ptr %nl, align 8
  %next82 = getelementptr inbounds %struct.dm_name_list, ptr %100, i32 0, i32 1
  store i32 %conv81, ptr %next82, align 8
  br label %if.end83

if.end83:                                         ; preds = %if.then75, %while.body
  %101 = load i32, ptr %remaining_data, align 4
  %102 = load ptr, ptr %nl, align 8
  %next84 = getelementptr inbounds %struct.dm_name_list, ptr %102, i32 0, i32 1
  %103 = load i32, ptr %next84, align 8
  %cmp85 = icmp ult i32 %101, %103
  br i1 %cmp85, label %if.then87, label %if.end88

if.then87:                                        ; preds = %if.end83
  %104 = load ptr, ptr %host_dm, align 8
  %flags = getelementptr inbounds %struct.dm_ioctl, ptr %104, i32 0, i32 5
  %105 = load i32, ptr %flags, align 4
  %or = or i32 %105, 256
  store i32 %or, ptr %flags, align 4
  br label %while.end

if.end88:                                         ; preds = %if.end83
  %106 = load ptr, ptr %cur_data70, align 8
  %107 = load ptr, ptr %nl, align 8
  %arraydecay89 = getelementptr inbounds [2 x i32], ptr %dm_arg_type71, i64 0, i64 0
  %call90 = call ptr @thunk_convert(ptr noundef %106, ptr noundef %107, ptr noundef %arraydecay89, i32 noundef 0)
  %108 = load ptr, ptr %cur_data70, align 8
  %109 = load i32, ptr %nl_size, align 4
  %idx.ext91 = sext i32 %109 to i64
  %add.ptr92 = getelementptr i8, ptr %108, i64 %idx.ext91
  %110 = load ptr, ptr %nl, align 8
  %name93 = getelementptr inbounds %struct.dm_name_list, ptr %110, i32 0, i32 2
  %arraydecay94 = getelementptr inbounds [0 x i8], ptr %name93, i64 0, i64 0
  %call95 = call ptr @strcpy(ptr noundef %add.ptr92, ptr noundef %arraydecay94) #14
  %111 = load ptr, ptr %nl, align 8
  %next96 = getelementptr inbounds %struct.dm_name_list, ptr %111, i32 0, i32 1
  %112 = load i32, ptr %next96, align 8
  %113 = load ptr, ptr %cur_data70, align 8
  %idx.ext97 = zext i32 %112 to i64
  %add.ptr98 = getelementptr i8, ptr %113, i64 %idx.ext97
  store ptr %add.ptr98, ptr %cur_data70, align 8
  %114 = load ptr, ptr %nl, align 8
  %next99 = getelementptr inbounds %struct.dm_name_list, ptr %114, i32 0, i32 1
  %115 = load i32, ptr %next99, align 8
  %116 = load i32, ptr %remaining_data, align 4
  %sub100 = sub i32 %116, %115
  store i32 %sub100, ptr %remaining_data, align 4
  %117 = load i32, ptr %next72, align 4
  %tobool101 = icmp ne i32 %117, 0
  br i1 %tobool101, label %if.end103, label %if.then102

if.then102:                                       ; preds = %if.end88
  br label %while.end

if.end103:                                        ; preds = %if.end88
  %118 = load ptr, ptr %nl, align 8
  %119 = load i32, ptr %next72, align 4
  %idx.ext104 = zext i32 %119 to i64
  %add.ptr105 = getelementptr i8, ptr %118, i64 %idx.ext104
  store ptr %add.ptr105, ptr %nl, align 8
  br label %while.body

while.end:                                        ; preds = %if.then102, %if.then87
  br label %sw.epilog226

sw.bb106:                                         ; preds = %if.then55, %if.then55
  %120 = load ptr, ptr %host_dm, align 8
  %121 = load ptr, ptr %host_dm, align 8
  %data_start108 = getelementptr inbounds %struct.dm_ioctl, ptr %121, i32 0, i32 2
  %122 = load i32, ptr %data_start108, align 8
  %idx.ext109 = zext i32 %122 to i64
  %add.ptr110 = getelementptr i8, ptr %120, i64 %idx.ext109
  store ptr %add.ptr110, ptr %spec107, align 8
  %123 = load ptr, ptr %argptr, align 8
  store ptr %123, ptr %cur_data111, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %dm_arg_type112, ptr align 4 @__const.do_ioctl_dm.dm_arg_type.582, i64 8, i1 false)
  %arraydecay114 = getelementptr inbounds [2 x i32], ptr %dm_arg_type112, i64 0, i64 0
  %call115 = call i32 @thunk_type_size(ptr noundef %arraydecay114, i32 noundef 0)
  store i32 %call115, ptr %spec_size113, align 4
  store i32 0, ptr %i116, align 4
  br label %for.cond117

for.cond117:                                      ; preds = %for.inc156, %sw.bb106
  %124 = load i32, ptr %i116, align 4
  %125 = load ptr, ptr %host_dm, align 8
  %target_count118 = getelementptr inbounds %struct.dm_ioctl, ptr %125, i32 0, i32 3
  %126 = load i32, ptr %target_count118, align 4
  %cmp119 = icmp ult i32 %124, %126
  br i1 %cmp119, label %for.body121, label %for.end158

for.body121:                                      ; preds = %for.cond117
  %127 = load ptr, ptr %spec107, align 8
  %next123 = getelementptr inbounds %struct.dm_target_spec, ptr %127, i32 0, i32 3
  %128 = load i32, ptr %next123, align 4
  store i32 %128, ptr %next122, align 4
  %129 = load ptr, ptr %spec107, align 8
  %arrayidx125 = getelementptr %struct.dm_target_spec, ptr %129, i64 1
  %call126 = call i64 @strlen(ptr noundef %arrayidx125) #18
  %add127 = add i64 %call126, 1
  %conv128 = trunc i64 %add127 to i32
  store i32 %conv128, ptr %slen124, align 4
  %130 = load ptr, ptr %cur_data111, align 8
  %131 = load ptr, ptr %argptr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %130 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %131 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %132 = load i32, ptr %spec_size113, align 4
  %conv129 = sext i32 %132 to i64
  %add130 = add i64 %sub.ptr.sub, %conv129
  %133 = load i32, ptr %slen124, align 4
  %conv131 = sext i32 %133 to i64
  %add132 = add i64 %add130, %conv131
  %conv133 = trunc i64 %add132 to i32
  %134 = load ptr, ptr %spec107, align 8
  %next134 = getelementptr inbounds %struct.dm_target_spec, ptr %134, i32 0, i32 3
  store i32 %conv133, ptr %next134, align 4
  %135 = load i32, ptr %guest_data_size, align 4
  %136 = load ptr, ptr %spec107, align 8
  %next135 = getelementptr inbounds %struct.dm_target_spec, ptr %136, i32 0, i32 3
  %137 = load i32, ptr %next135, align 4
  %cmp136 = icmp ult i32 %135, %137
  br i1 %cmp136, label %if.then138, label %if.end141

if.then138:                                       ; preds = %for.body121
  %138 = load ptr, ptr %host_dm, align 8
  %flags139 = getelementptr inbounds %struct.dm_ioctl, ptr %138, i32 0, i32 5
  %139 = load i32, ptr %flags139, align 4
  %or140 = or i32 %139, 256
  store i32 %or140, ptr %flags139, align 4
  br label %for.end158

if.end141:                                        ; preds = %for.body121
  %140 = load ptr, ptr %cur_data111, align 8
  %141 = load ptr, ptr %spec107, align 8
  %arraydecay142 = getelementptr inbounds [2 x i32], ptr %dm_arg_type112, i64 0, i64 0
  %call143 = call ptr @thunk_convert(ptr noundef %140, ptr noundef %141, ptr noundef %arraydecay142, i32 noundef 0)
  %142 = load ptr, ptr %cur_data111, align 8
  %143 = load i32, ptr %spec_size113, align 4
  %idx.ext144 = sext i32 %143 to i64
  %add.ptr145 = getelementptr i8, ptr %142, i64 %idx.ext144
  %144 = load ptr, ptr %spec107, align 8
  %arrayidx146 = getelementptr %struct.dm_target_spec, ptr %144, i64 1
  %call147 = call ptr @strcpy(ptr noundef %add.ptr145, ptr noundef %arrayidx146) #14
  %145 = load ptr, ptr %argptr, align 8
  %146 = load ptr, ptr %spec107, align 8
  %next148 = getelementptr inbounds %struct.dm_target_spec, ptr %146, i32 0, i32 3
  %147 = load i32, ptr %next148, align 4
  %idx.ext149 = zext i32 %147 to i64
  %add.ptr150 = getelementptr i8, ptr %145, i64 %idx.ext149
  store ptr %add.ptr150, ptr %cur_data111, align 8
  %148 = load ptr, ptr %host_dm, align 8
  %149 = load ptr, ptr %host_dm, align 8
  %data_start151 = getelementptr inbounds %struct.dm_ioctl, ptr %149, i32 0, i32 2
  %150 = load i32, ptr %data_start151, align 8
  %idx.ext152 = zext i32 %150 to i64
  %add.ptr153 = getelementptr i8, ptr %148, i64 %idx.ext152
  %151 = load i32, ptr %next122, align 4
  %idx.ext154 = zext i32 %151 to i64
  %add.ptr155 = getelementptr i8, ptr %add.ptr153, i64 %idx.ext154
  store ptr %add.ptr155, ptr %spec107, align 8
  br label %for.inc156

for.inc156:                                       ; preds = %if.end141
  %152 = load i32, ptr %i116, align 4
  %inc157 = add i32 %152, 1
  store i32 %inc157, ptr %i116, align 4
  br label %for.cond117, !llvm.loop !9

for.end158:                                       ; preds = %if.then138, %for.cond117
  br label %sw.epilog226

sw.bb159:                                         ; preds = %if.then55
  %153 = load ptr, ptr %host_dm, align 8
  %154 = load ptr, ptr %host_dm, align 8
  %data_start160 = getelementptr inbounds %struct.dm_ioctl, ptr %154, i32 0, i32 2
  %155 = load i32, ptr %data_start160, align 8
  %idx.ext161 = zext i32 %155 to i64
  %add.ptr162 = getelementptr i8, ptr %153, i64 %idx.ext161
  store ptr %add.ptr162, ptr %hdata, align 8
  %156 = load ptr, ptr %hdata, align 8
  %157 = load i32, ptr %156, align 4
  store i32 %157, ptr %count, align 4
  %158 = load ptr, ptr %hdata, align 8
  %add.ptr163 = getelementptr i8, ptr %158, i64 8
  store ptr %add.ptr163, ptr %hdev, align 8
  %159 = load ptr, ptr %argptr, align 8
  %add.ptr164 = getelementptr i8, ptr %159, i64 8
  store ptr %add.ptr164, ptr %gdev, align 8
  %160 = load i32, ptr %count, align 4
  %call166 = call i32 @tswap32(i32 noundef %160)
  %161 = load ptr, ptr %argptr, align 8
  store i32 %call166, ptr %161, align 4
  store i32 0, ptr %i165, align 4
  br label %for.cond167

for.cond167:                                      ; preds = %for.inc174, %sw.bb159
  %162 = load i32, ptr %i165, align 4
  %163 = load i32, ptr %count, align 4
  %cmp168 = icmp slt i32 %162, %163
  br i1 %cmp168, label %for.body170, label %for.end176

for.body170:                                      ; preds = %for.cond167
  %164 = load ptr, ptr %hdev, align 8
  %165 = load i64, ptr %164, align 8
  %call171 = call i64 @tswap64(i64 noundef %165)
  %166 = load ptr, ptr %gdev, align 8
  store i64 %call171, ptr %166, align 8
  %167 = load ptr, ptr %gdev, align 8
  %incdec.ptr172 = getelementptr i64, ptr %167, i32 1
  store ptr %incdec.ptr172, ptr %gdev, align 8
  %168 = load ptr, ptr %hdev, align 8
  %incdec.ptr173 = getelementptr i64, ptr %168, i32 1
  store ptr %incdec.ptr173, ptr %hdev, align 8
  br label %for.inc174

for.inc174:                                       ; preds = %for.body170
  %169 = load i32, ptr %i165, align 4
  %inc175 = add i32 %169, 1
  store i32 %inc175, ptr %i165, align 4
  br label %for.cond167, !llvm.loop !10

for.end176:                                       ; preds = %for.cond167
  br label %sw.epilog226

sw.bb177:                                         ; preds = %if.then55
  %170 = load ptr, ptr %host_dm, align 8
  %171 = load ptr, ptr %host_dm, align 8
  %data_start178 = getelementptr inbounds %struct.dm_ioctl, ptr %171, i32 0, i32 2
  %172 = load i32, ptr %data_start178, align 8
  %idx.ext179 = zext i32 %172 to i64
  %add.ptr180 = getelementptr i8, ptr %170, i64 %idx.ext179
  store ptr %add.ptr180, ptr %vers, align 8
  %173 = load i32, ptr %guest_data_size, align 4
  store i32 %173, ptr %remaining_data181, align 4
  %174 = load ptr, ptr %argptr, align 8
  store ptr %174, ptr %cur_data182, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %dm_arg_type183, ptr align 4 @__const.do_ioctl_dm.dm_arg_type.583, i64 8, i1 false)
  %arraydecay184 = getelementptr inbounds [2 x i32], ptr %dm_arg_type183, i64 0, i64 0
  %call185 = call i32 @thunk_type_size(ptr noundef %arraydecay184, i32 noundef 0)
  store i32 %call185, ptr %vers_size, align 4
  br label %while.body186

while.body186:                                    ; preds = %if.end221, %sw.bb177
  %175 = load ptr, ptr %vers, align 8
  %next188 = getelementptr inbounds %struct.dm_target_versions, ptr %175, i32 0, i32 0
  %176 = load i32, ptr %next188, align 4
  store i32 %176, ptr %next187, align 4
  %177 = load i32, ptr %next187, align 4
  %tobool189 = icmp ne i32 %177, 0
  br i1 %tobool189, label %if.then190, label %if.end199

if.then190:                                       ; preds = %while.body186
  %178 = load i32, ptr %vers_size, align 4
  %conv191 = sext i32 %178 to i64
  %179 = load ptr, ptr %vers, align 8
  %name192 = getelementptr inbounds %struct.dm_target_versions, ptr %179, i32 0, i32 2
  %arraydecay193 = getelementptr inbounds [0 x i8], ptr %name192, i64 0, i64 0
  %call194 = call i64 @strlen(ptr noundef %arraydecay193) #18
  %add195 = add i64 %call194, 1
  %add196 = add i64 %conv191, %add195
  %conv197 = trunc i64 %add196 to i32
  %180 = load ptr, ptr %vers, align 8
  %next198 = getelementptr inbounds %struct.dm_target_versions, ptr %180, i32 0, i32 0
  store i32 %conv197, ptr %next198, align 4
  br label %if.end199

if.end199:                                        ; preds = %if.then190, %while.body186
  %181 = load i32, ptr %remaining_data181, align 4
  %182 = load ptr, ptr %vers, align 8
  %next200 = getelementptr inbounds %struct.dm_target_versions, ptr %182, i32 0, i32 0
  %183 = load i32, ptr %next200, align 4
  %cmp201 = icmp ult i32 %181, %183
  br i1 %cmp201, label %if.then203, label %if.end206

if.then203:                                       ; preds = %if.end199
  %184 = load ptr, ptr %host_dm, align 8
  %flags204 = getelementptr inbounds %struct.dm_ioctl, ptr %184, i32 0, i32 5
  %185 = load i32, ptr %flags204, align 4
  %or205 = or i32 %185, 256
  store i32 %or205, ptr %flags204, align 4
  br label %while.end224

if.end206:                                        ; preds = %if.end199
  %186 = load ptr, ptr %cur_data182, align 8
  %187 = load ptr, ptr %vers, align 8
  %arraydecay207 = getelementptr inbounds [2 x i32], ptr %dm_arg_type183, i64 0, i64 0
  %call208 = call ptr @thunk_convert(ptr noundef %186, ptr noundef %187, ptr noundef %arraydecay207, i32 noundef 0)
  %188 = load ptr, ptr %cur_data182, align 8
  %189 = load i32, ptr %vers_size, align 4
  %idx.ext209 = sext i32 %189 to i64
  %add.ptr210 = getelementptr i8, ptr %188, i64 %idx.ext209
  %190 = load ptr, ptr %vers, align 8
  %name211 = getelementptr inbounds %struct.dm_target_versions, ptr %190, i32 0, i32 2
  %arraydecay212 = getelementptr inbounds [0 x i8], ptr %name211, i64 0, i64 0
  %call213 = call ptr @strcpy(ptr noundef %add.ptr210, ptr noundef %arraydecay212) #14
  %191 = load ptr, ptr %vers, align 8
  %next214 = getelementptr inbounds %struct.dm_target_versions, ptr %191, i32 0, i32 0
  %192 = load i32, ptr %next214, align 4
  %193 = load ptr, ptr %cur_data182, align 8
  %idx.ext215 = zext i32 %192 to i64
  %add.ptr216 = getelementptr i8, ptr %193, i64 %idx.ext215
  store ptr %add.ptr216, ptr %cur_data182, align 8
  %194 = load ptr, ptr %vers, align 8
  %next217 = getelementptr inbounds %struct.dm_target_versions, ptr %194, i32 0, i32 0
  %195 = load i32, ptr %next217, align 4
  %196 = load i32, ptr %remaining_data181, align 4
  %sub218 = sub i32 %196, %195
  store i32 %sub218, ptr %remaining_data181, align 4
  %197 = load i32, ptr %next187, align 4
  %tobool219 = icmp ne i32 %197, 0
  br i1 %tobool219, label %if.end221, label %if.then220

if.then220:                                       ; preds = %if.end206
  br label %while.end224

if.end221:                                        ; preds = %if.end206
  %198 = load ptr, ptr %vers, align 8
  %199 = load i32, ptr %next187, align 4
  %idx.ext222 = zext i32 %199 to i64
  %add.ptr223 = getelementptr i8, ptr %198, i64 %idx.ext222
  store ptr %add.ptr223, ptr %vers, align 8
  br label %while.body186

while.end224:                                     ; preds = %if.then220, %if.then203
  br label %sw.epilog226

sw.default225:                                    ; preds = %if.then55
  %200 = load ptr, ptr %argptr, align 8
  %201 = load i64, ptr %guest_data, align 8
  call void @unlock_user(ptr noundef %200, i64 noundef %201, i64 noundef 0)
  store i64 -22, ptr %ret, align 8
  br label %out

sw.epilog226:                                     ; preds = %while.end224, %for.end176, %for.end158, %while.end, %sw.bb65
  %202 = load ptr, ptr %argptr, align 8
  %203 = load i64, ptr %guest_data, align 8
  %204 = load i32, ptr %guest_data_size, align 4
  %conv227 = zext i32 %204 to i64
  call void @unlock_user(ptr noundef %202, i64 noundef %203, i64 noundef %conv227)
  %205 = load i64, ptr %arg.addr, align 8
  %206 = load i32, ptr %target_size, align 4
  %conv228 = sext i32 %206 to i64
  %call229 = call ptr @lock_user(i32 noundef 3, i64 noundef %205, i64 noundef %conv228, i1 noundef zeroext false)
  store ptr %call229, ptr %argptr, align 8
  %207 = load ptr, ptr %argptr, align 8
  %tobool230 = icmp ne ptr %207, null
  br i1 %tobool230, label %if.end232, label %if.then231

if.then231:                                       ; preds = %sw.epilog226
  store i64 -14, ptr %ret, align 8
  br label %out

if.end232:                                        ; preds = %sw.epilog226
  %208 = load ptr, ptr %argptr, align 8
  %209 = load ptr, ptr %buf_temp.addr, align 8
  %210 = load ptr, ptr %arg_type, align 8
  %call233 = call ptr @thunk_convert(ptr noundef %208, ptr noundef %209, ptr noundef %210, i32 noundef 0)
  %211 = load ptr, ptr %argptr, align 8
  %212 = load i64, ptr %arg.addr, align 8
  %213 = load i32, ptr %target_size, align 4
  %conv234 = sext i32 %213 to i64
  call void @unlock_user(ptr noundef %211, i64 noundef %212, i64 noundef %conv234)
  br label %if.end235

if.end235:                                        ; preds = %if.end232, %sw.epilog
  br label %out

out:                                              ; preds = %if.end235, %if.then231, %sw.default225, %sw.default, %if.then18, %if.then9, %if.then
  %214 = load ptr, ptr %big_buf, align 8
  call void @g_free(ptr noundef %214)
  %215 = load i64, ptr %ret, align 8
  ret i64 %215
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_rt(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %arg_type = alloca ptr, align 8
  %se = alloca ptr, align 8
  %field_types = alloca ptr, align 8
  %dst_offsets = alloca ptr, align 8
  %src_offsets = alloca ptr, align 8
  %target_size = alloca i32, align 4
  %argptr = alloca ptr, align 8
  %target_rt_dev_ptr = alloca ptr, align 8
  %host_rt_dev_ptr = alloca ptr, align 8
  %ret = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %ie.addr, align 8
  %arg_type1 = getelementptr inbounds %struct.IOCTLEntry, ptr %0, i32 0, i32 5
  %arraydecay = getelementptr inbounds [5 x i32], ptr %arg_type1, i64 0, i64 0
  store ptr %arraydecay, ptr %arg_type, align 8
  store ptr null, ptr %target_rt_dev_ptr, align 8
  store ptr null, ptr %host_rt_dev_ptr, align 8
  %1 = load ptr, ptr %ie.addr, align 8
  %access = getelementptr inbounds %struct.IOCTLEntry, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %access, align 8
  %cmp = icmp eq i32 %2, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.584, ptr noundef @.str.579, i32 noundef 5280, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_rt) #15
  unreachable

if.end:                                           ; preds = %if.then
  %3 = load ptr, ptr %arg_type, align 8
  %4 = load i32, ptr %3, align 4
  %cmp2 = icmp eq i32 %4, 9
  br i1 %cmp2, label %if.then3, label %if.else4

if.then3:                                         ; preds = %if.end
  br label %if.end5

if.else4:                                         ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.585, ptr noundef @.str.579, i32 noundef 5281, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_rt) #15
  unreachable

if.end5:                                          ; preds = %if.then3
  %5 = load ptr, ptr %arg_type, align 8
  %incdec.ptr = getelementptr i32, ptr %5, i32 1
  store ptr %incdec.ptr, ptr %arg_type, align 8
  %6 = load ptr, ptr %arg_type, align 8
  %7 = load i32, ptr %6, align 4
  %cmp6 = icmp eq i32 %7, 11
  br i1 %cmp6, label %if.then7, label %if.else8

if.then7:                                         ; preds = %if.end5
  br label %if.end9

if.else8:                                         ; preds = %if.end5
  call void @__assert_fail(ptr noundef @.str.586, ptr noundef @.str.579, i32 noundef 5283, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_rt) #15
  unreachable

if.end9:                                          ; preds = %if.then7
  %8 = load ptr, ptr %arg_type, align 8
  %call = call i32 @thunk_type_size(ptr noundef %8, i32 noundef 0)
  store i32 %call, ptr %target_size, align 4
  %9 = load i64, ptr %arg.addr, align 8
  %10 = load i32, ptr %target_size, align 4
  %conv = sext i32 %10 to i64
  %call10 = call ptr @lock_user(i32 noundef 1, i64 noundef %9, i64 noundef %conv, i1 noundef zeroext true)
  store ptr %call10, ptr %argptr, align 8
  %11 = load ptr, ptr %argptr, align 8
  %tobool = icmp ne ptr %11, null
  br i1 %tobool, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end9
  store i64 -14, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end9
  %12 = load ptr, ptr %arg_type, align 8
  %incdec.ptr13 = getelementptr i32, ptr %12, i32 1
  store ptr %incdec.ptr13, ptr %arg_type, align 8
  %13 = load ptr, ptr %arg_type, align 8
  %14 = load i32, ptr %13, align 4
  %cmp14 = icmp eq i32 %14, 5
  br i1 %cmp14, label %if.then16, label %if.else17

if.then16:                                        ; preds = %if.end12
  br label %if.end18

if.else17:                                        ; preds = %if.end12
  call void @__assert_fail(ptr noundef @.str.587, ptr noundef @.str.579, i32 noundef 5290, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_rt) #15
  unreachable

if.end18:                                         ; preds = %if.then16
  %15 = load ptr, ptr @struct_entries, align 8
  %16 = load ptr, ptr %arg_type, align 8
  %incdec.ptr19 = getelementptr i32, ptr %16, i32 1
  store ptr %incdec.ptr19, ptr %arg_type, align 8
  %17 = load i32, ptr %16, align 4
  %idx.ext = zext i32 %17 to i64
  %add.ptr = getelementptr %struct.StructEntry, ptr %15, i64 %idx.ext
  store ptr %add.ptr, ptr %se, align 8
  %18 = load ptr, ptr %se, align 8
  %convert = getelementptr inbounds %struct.StructEntry, ptr %18, i32 0, i32 3
  %arrayidx = getelementptr [2 x ptr], ptr %convert, i64 0, i64 0
  %19 = load ptr, ptr %arrayidx, align 8
  %cmp20 = icmp eq ptr %19, null
  br i1 %cmp20, label %if.then22, label %if.else23

if.then22:                                        ; preds = %if.end18
  br label %if.end24

if.else23:                                        ; preds = %if.end18
  call void @__assert_fail(ptr noundef @.str.588, ptr noundef @.str.579, i32 noundef 5292, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_rt) #15
  unreachable

if.end24:                                         ; preds = %if.then22
  %20 = load ptr, ptr %se, align 8
  %field_types25 = getelementptr inbounds %struct.StructEntry, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %field_types25, align 8
  store ptr %21, ptr %field_types, align 8
  %22 = load ptr, ptr %se, align 8
  %field_offsets = getelementptr inbounds %struct.StructEntry, ptr %22, i32 0, i32 2
  %arrayidx26 = getelementptr [2 x ptr], ptr %field_offsets, i64 0, i64 1
  %23 = load ptr, ptr %arrayidx26, align 8
  store ptr %23, ptr %dst_offsets, align 8
  %24 = load ptr, ptr %se, align 8
  %field_offsets27 = getelementptr inbounds %struct.StructEntry, ptr %24, i32 0, i32 2
  %arrayidx28 = getelementptr [2 x ptr], ptr %field_offsets27, i64 0, i64 0
  %25 = load ptr, ptr %arrayidx28, align 8
  store ptr %25, ptr %src_offsets, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end24
  %26 = load i32, ptr %i, align 4
  %27 = load ptr, ptr %se, align 8
  %nb_fields = getelementptr inbounds %struct.StructEntry, ptr %27, i32 0, i32 1
  %28 = load i32, ptr %nb_fields, align 8
  %cmp29 = icmp slt i32 %26, %28
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %29 = load ptr, ptr %dst_offsets, align 8
  %30 = load i32, ptr %i, align 4
  %idxprom = sext i32 %30 to i64
  %arrayidx31 = getelementptr i32, ptr %29, i64 %idxprom
  %31 = load i32, ptr %arrayidx31, align 4
  %conv32 = sext i32 %31 to i64
  %cmp33 = icmp eq i64 %conv32, 88
  br i1 %cmp33, label %if.then35, label %if.end60

if.then35:                                        ; preds = %for.body
  %32 = load ptr, ptr %field_types, align 8
  %33 = load i32, ptr %32, align 4
  %cmp36 = icmp eq i32 %33, 6
  br i1 %cmp36, label %if.then38, label %if.else39

if.then38:                                        ; preds = %if.then35
  br label %if.end40

if.else39:                                        ; preds = %if.then35
  call void @__assert_fail(ptr noundef @.str.589, ptr noundef @.str.579, i32 noundef 5299, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_rt) #15
  unreachable

if.end40:                                         ; preds = %if.then38
  %34 = load ptr, ptr %argptr, align 8
  %35 = load ptr, ptr %src_offsets, align 8
  %36 = load i32, ptr %i, align 4
  %idxprom41 = sext i32 %36 to i64
  %arrayidx42 = getelementptr i32, ptr %35, i64 %idxprom41
  %37 = load i32, ptr %arrayidx42, align 4
  %idx.ext43 = sext i32 %37 to i64
  %add.ptr44 = getelementptr i8, ptr %34, i64 %idx.ext43
  store ptr %add.ptr44, ptr %target_rt_dev_ptr, align 8
  %38 = load ptr, ptr %buf_temp.addr, align 8
  %39 = load ptr, ptr %dst_offsets, align 8
  %40 = load i32, ptr %i, align 4
  %idxprom45 = sext i32 %40 to i64
  %arrayidx46 = getelementptr i32, ptr %39, i64 %idxprom45
  %41 = load i32, ptr %arrayidx46, align 4
  %idx.ext47 = sext i32 %41 to i64
  %add.ptr48 = getelementptr i8, ptr %38, i64 %idx.ext47
  store ptr %add.ptr48, ptr %host_rt_dev_ptr, align 8
  %42 = load ptr, ptr %target_rt_dev_ptr, align 8
  %43 = load i64, ptr %42, align 8
  %cmp49 = icmp ne i64 %43, 0
  br i1 %cmp49, label %if.then51, label %if.else57

if.then51:                                        ; preds = %if.end40
  %44 = load ptr, ptr %target_rt_dev_ptr, align 8
  %45 = load i64, ptr %44, align 8
  %call52 = call i64 @tswapal(i64 noundef %45)
  %call53 = call ptr @lock_user_string(i64 noundef %call52)
  %46 = ptrtoint ptr %call53 to i64
  %47 = load ptr, ptr %host_rt_dev_ptr, align 8
  store i64 %46, ptr %47, align 8
  %48 = load ptr, ptr %host_rt_dev_ptr, align 8
  %49 = load i64, ptr %48, align 8
  %tobool54 = icmp ne i64 %49, 0
  br i1 %tobool54, label %if.end56, label %if.then55

if.then55:                                        ; preds = %if.then51
  %50 = load ptr, ptr %argptr, align 8
  %51 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %50, i64 noundef %51, i64 noundef 0)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end56:                                         ; preds = %if.then51
  br label %if.end58

if.else57:                                        ; preds = %if.end40
  %52 = load ptr, ptr %host_rt_dev_ptr, align 8
  store i64 0, ptr %52, align 8
  br label %if.end58

if.end58:                                         ; preds = %if.else57, %if.end56
  %53 = load ptr, ptr %field_types, align 8
  %incdec.ptr59 = getelementptr i32, ptr %53, i32 1
  store ptr %incdec.ptr59, ptr %field_types, align 8
  br label %for.inc

if.end60:                                         ; preds = %for.body
  %54 = load ptr, ptr %buf_temp.addr, align 8
  %55 = load ptr, ptr %dst_offsets, align 8
  %56 = load i32, ptr %i, align 4
  %idxprom61 = sext i32 %56 to i64
  %arrayidx62 = getelementptr i32, ptr %55, i64 %idxprom61
  %57 = load i32, ptr %arrayidx62, align 4
  %idx.ext63 = sext i32 %57 to i64
  %add.ptr64 = getelementptr i8, ptr %54, i64 %idx.ext63
  %58 = load ptr, ptr %argptr, align 8
  %59 = load ptr, ptr %src_offsets, align 8
  %60 = load i32, ptr %i, align 4
  %idxprom65 = sext i32 %60 to i64
  %arrayidx66 = getelementptr i32, ptr %59, i64 %idxprom65
  %61 = load i32, ptr %arrayidx66, align 4
  %idx.ext67 = sext i32 %61 to i64
  %add.ptr68 = getelementptr i8, ptr %58, i64 %idx.ext67
  %62 = load ptr, ptr %field_types, align 8
  %call69 = call ptr @thunk_convert(ptr noundef %add.ptr64, ptr noundef %add.ptr68, ptr noundef %62, i32 noundef 1)
  store ptr %call69, ptr %field_types, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end60, %if.end58
  %63 = load i32, ptr %i, align 4
  %inc = add i32 %63, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !11

for.end:                                          ; preds = %for.cond
  %64 = load ptr, ptr %argptr, align 8
  %65 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %64, i64 noundef %65, i64 noundef 0)
  %66 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %67 = load ptr, ptr %66, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %67, i32 0, i32 39
  %68 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %68, i32 0, i32 14
  %69 = load i32, ptr %fd.addr, align 4
  %70 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %70, i32 0, i32 1
  %71 = load i32, ptr %host_cmd, align 4
  %72 = load ptr, ptr %buf_temp.addr, align 8
  %call70 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %69, i32 noundef %71, ptr noundef %72)
  %call71 = call i64 @get_errno(i64 noundef %call70)
  store i64 %call71, ptr %ret, align 8
  %73 = load ptr, ptr %host_rt_dev_ptr, align 8
  %cmp72 = icmp ne ptr %73, null
  br i1 %cmp72, label %if.then74, label %if.else75

if.then74:                                        ; preds = %for.end
  br label %if.end76

if.else75:                                        ; preds = %for.end
  call void @__assert_fail(ptr noundef @.str.590, ptr noundef @.str.579, i32 noundef 5323, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_rt) #15
  unreachable

if.end76:                                         ; preds = %if.then74
  %74 = load ptr, ptr %target_rt_dev_ptr, align 8
  %cmp77 = icmp ne ptr %74, null
  br i1 %cmp77, label %if.then79, label %if.else80

if.then79:                                        ; preds = %if.end76
  br label %if.end81

if.else80:                                        ; preds = %if.end76
  call void @__assert_fail(ptr noundef @.str.591, ptr noundef @.str.579, i32 noundef 5324, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_rt) #15
  unreachable

if.end81:                                         ; preds = %if.then79
  %75 = load ptr, ptr %host_rt_dev_ptr, align 8
  %76 = load i64, ptr %75, align 8
  %cmp82 = icmp ne i64 %76, 0
  br i1 %cmp82, label %if.then84, label %if.end85

if.then84:                                        ; preds = %if.end81
  %77 = load ptr, ptr %host_rt_dev_ptr, align 8
  %78 = load i64, ptr %77, align 8
  %79 = inttoptr i64 %78 to ptr
  %80 = load ptr, ptr %target_rt_dev_ptr, align 8
  %81 = load i64, ptr %80, align 8
  call void @unlock_user(ptr noundef %79, i64 noundef %81, i64 noundef 0)
  br label %if.end85

if.end85:                                         ; preds = %if.then84, %if.end81
  %82 = load i64, ptr %ret, align 8
  store i64 %82, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end85, %if.then55, %if.then11
  %83 = load i64, ptr %retval, align 8
  ret i64 %83
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_drm(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %ver = alloca ptr, align 8
  %target_ver = alloca ptr, align 8
  %ret = alloca i64, align 8
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %host_cmd, align 4
  switch i32 %1, label %sw.epilog [
    i32 -1069521920, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry
  %2 = load i64, ptr %arg.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %2, i64 noundef 64, i1 noundef zeroext false)
  store ptr %call, ptr %target_ver, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %sw.bb
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %sw.bb
  %3 = load ptr, ptr %buf_temp.addr, align 8
  store ptr %3, ptr %ver, align 8
  %4 = load ptr, ptr %ver, align 8
  %5 = load ptr, ptr %target_ver, align 8
  %call1 = call i64 @target_to_host_drmversion(ptr noundef %4, ptr noundef %5)
  store i64 %call1, ptr %ret, align 8
  %6 = load i64, ptr %ret, align 8
  %call2 = call i32 @is_error(i64 noundef %6)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end12, label %if.then4

if.then4:                                         ; preds = %if.end
  %7 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %8 = load ptr, ptr %7, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %8, i32 0, i32 39
  %9 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %9, i32 0, i32 14
  %10 = load i32, ptr %fd.addr, align 4
  %11 = load ptr, ptr %ie.addr, align 8
  %host_cmd5 = getelementptr inbounds %struct.IOCTLEntry, ptr %11, i32 0, i32 1
  %12 = load i32, ptr %host_cmd5, align 4
  %13 = load ptr, ptr %ver, align 8
  %call6 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %10, i32 noundef %12, ptr noundef %13)
  %call7 = call i64 @get_errno(i64 noundef %call6)
  store i64 %call7, ptr %ret, align 8
  %14 = load i64, ptr %ret, align 8
  %call8 = call i32 @is_error(i64 noundef %14)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then4
  %15 = load ptr, ptr %ver, align 8
  %16 = load ptr, ptr %target_ver, align 8
  call void @unlock_drm_version(ptr noundef %15, ptr noundef %16, i1 noundef zeroext false)
  br label %if.end11

if.else:                                          ; preds = %if.then4
  %17 = load ptr, ptr %target_ver, align 8
  %18 = load ptr, ptr %ver, align 8
  call void @host_to_target_drmversion(ptr noundef %17, ptr noundef %18)
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then10
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end
  %19 = load ptr, ptr %target_ver, align 8
  %20 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %19, i64 noundef %20, i64 noundef 0)
  %21 = load i64, ptr %ret, align 8
  store i64 %21, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store i64 -38, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %if.end12, %if.then
  %22 = load i64, ptr %retval, align 8
  ret i64 %22
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_drm_i915(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %host_cmd, align 4
  switch i32 %1, label %sw.default [
    i32 -1072667578, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry
  %2 = load ptr, ptr %ie.addr, align 8
  %3 = load ptr, ptr %buf_temp.addr, align 8
  %4 = load i32, ptr %fd.addr, align 4
  %5 = load i64, ptr %arg.addr, align 8
  %call = call i64 @do_ioctl_drm_i915_getparam(ptr noundef %2, ptr noundef %3, i32 noundef %4, i64 noundef %5)
  store i64 %call, ptr %retval, align 8
  br label %return

sw.default:                                       ; preds = %entry
  store i64 -38, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %6 = load i64, ptr %retval, align 8
  ret i64 %6
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_TUNSETTXFILTER(ptr noundef %ie, ptr noundef %buf_temp, i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %ie.addr = alloca ptr, align 8
  %buf_temp.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %filter = alloca ptr, align 8
  %target_filter = alloca ptr, align 8
  %target_addr = alloca ptr, align 8
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %buf_temp, ptr %buf_temp.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %buf_temp.addr, align 8
  store ptr %0, ptr %filter, align 8
  %1 = load ptr, ptr %ie.addr, align 8
  %access = getelementptr inbounds %struct.IOCTLEntry, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %access, align 8
  %cmp = icmp eq i32 %2, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.584, ptr noundef @.str.579, i32 noundef 5532, ptr noundef @__PRETTY_FUNCTION__.do_ioctl_TUNSETTXFILTER) #15
  unreachable

if.end:                                           ; preds = %if.then
  %3 = load i64, ptr %arg.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %3, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call, ptr %target_filter, align 8
  %4 = load ptr, ptr %target_filter, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  %5 = load ptr, ptr %target_filter, align 8
  %flags = getelementptr inbounds %struct.tun_filter, ptr %5, i32 0, i32 0
  %6 = load i16, ptr %flags, align 2
  %call3 = call zeroext i16 @tswap16(i16 noundef zeroext %6)
  %7 = load ptr, ptr %filter, align 8
  %flags4 = getelementptr inbounds %struct.tun_filter, ptr %7, i32 0, i32 0
  store i16 %call3, ptr %flags4, align 2
  %8 = load ptr, ptr %target_filter, align 8
  %count = getelementptr inbounds %struct.tun_filter, ptr %8, i32 0, i32 1
  %9 = load i16, ptr %count, align 2
  %call5 = call zeroext i16 @tswap16(i16 noundef zeroext %9)
  %10 = load ptr, ptr %filter, align 8
  %count6 = getelementptr inbounds %struct.tun_filter, ptr %10, i32 0, i32 1
  store i16 %call5, ptr %count6, align 2
  %11 = load ptr, ptr %target_filter, align 8
  %12 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %11, i64 noundef %12, i64 noundef 0)
  %13 = load ptr, ptr %filter, align 8
  %count7 = getelementptr inbounds %struct.tun_filter, ptr %13, i32 0, i32 1
  %14 = load i16, ptr %count7, align 2
  %tobool8 = icmp ne i16 %14, 0
  br i1 %tobool8, label %if.then9, label %if.end30

if.then9:                                         ; preds = %if.end2
  %15 = load ptr, ptr %filter, align 8
  %count10 = getelementptr inbounds %struct.tun_filter, ptr %15, i32 0, i32 1
  %16 = load i16, ptr %count10, align 2
  %conv = zext i16 %16 to i32
  %mul = mul i32 %conv, 6
  %conv11 = sext i32 %mul to i64
  %add = add i64 4, %conv11
  %cmp12 = icmp ugt i64 %add, 4096
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.then9
  store i64 -14, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.then9
  %17 = load i64, ptr %arg.addr, align 8
  %add16 = add i64 %17, 4
  %18 = load ptr, ptr %filter, align 8
  %count17 = getelementptr inbounds %struct.tun_filter, ptr %18, i32 0, i32 1
  %19 = load i16, ptr %count17, align 2
  %conv18 = zext i16 %19 to i32
  %mul19 = mul i32 %conv18, 6
  %conv20 = sext i32 %mul19 to i64
  %call21 = call ptr @lock_user(i32 noundef 1, i64 noundef %add16, i64 noundef %conv20, i1 noundef zeroext true)
  store ptr %call21, ptr %target_addr, align 8
  %20 = load ptr, ptr %target_addr, align 8
  %tobool22 = icmp ne ptr %20, null
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end15
  store i64 -14, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %if.end15
  %21 = load ptr, ptr %filter, align 8
  %addr = getelementptr inbounds %struct.tun_filter, ptr %21, i32 0, i32 2
  %arraydecay = getelementptr inbounds [0 x [6 x i8]], ptr %addr, i64 0, i64 0
  %22 = load ptr, ptr %target_addr, align 8
  %23 = load ptr, ptr %filter, align 8
  %count25 = getelementptr inbounds %struct.tun_filter, ptr %23, i32 0, i32 1
  %24 = load i16, ptr %count25, align 2
  %conv26 = zext i16 %24 to i32
  %mul27 = mul i32 %conv26, 6
  %conv28 = sext i32 %mul27 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %arraydecay, ptr align 1 %22, i64 %conv28, i1 false)
  %25 = load ptr, ptr %target_addr, align 8
  %26 = load i64, ptr %arg.addr, align 8
  %add29 = add i64 %26, 4
  call void @unlock_user(ptr noundef %25, i64 noundef %add29, i64 noundef 0)
  br label %if.end30

if.end30:                                         ; preds = %if.end24, %if.end2
  %27 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %28 = load ptr, ptr %27, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %28, i32 0, i32 39
  %29 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %29, i32 0, i32 14
  %30 = load i32, ptr %fd.addr, align 4
  %31 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %31, i32 0, i32 1
  %32 = load i32, ptr %host_cmd, align 4
  %33 = load ptr, ptr %filter, align 8
  %call31 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %30, i32 noundef %32, ptr noundef %33)
  %call32 = call i64 @get_errno(i64 noundef %call31)
  store i64 %call32, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end30, %if.then23, %if.then14, %if.then1
  %34 = load i64, ptr %retval, align 8
  ret i64 %34
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @syscall_init() #0 {
entry:
  %ie = alloca ptr, align 8
  %arg_type = alloca ptr, align 8
  %size = alloca i32, align 4
  call void @thunk_init(i32 noundef 98)
  call void @thunk_register_struct_direct(i32 noundef 0, ptr noundef @.str.467, ptr noundef @struct_termios_def)
  call void @thunk_register_struct(i32 noundef 1, ptr noundef @.str.468, ptr noundef @struct_winsize_def)
  call void @thunk_register_struct(i32 noundef 2, ptr noundef @.str.469, ptr noundef @struct_serial_multiport_struct_def)
  call void @thunk_register_struct(i32 noundef 3, ptr noundef @.str.470, ptr noundef @struct_serial_icounter_struct_def)
  call void @thunk_register_struct(i32 noundef 4, ptr noundef @.str.471, ptr noundef @struct_sockaddr_def)
  call void @thunk_register_struct(i32 noundef 5, ptr noundef @.str.472, ptr noundef @struct_rtentry_def)
  call void @thunk_register_struct(i32 noundef 6, ptr noundef @.str.473, ptr noundef @struct_ifmap_def)
  call void @thunk_register_struct(i32 noundef 7, ptr noundef @.str.474, ptr noundef @struct_sockaddr_ifreq_def)
  call void @thunk_register_struct(i32 noundef 8, ptr noundef @.str.475, ptr noundef @struct_short_ifreq_def)
  call void @thunk_register_struct(i32 noundef 9, ptr noundef @.str.476, ptr noundef @struct_int_ifreq_def)
  call void @thunk_register_struct(i32 noundef 10, ptr noundef @.str.477, ptr noundef @struct_ifmap_ifreq_def)
  call void @thunk_register_struct(i32 noundef 11, ptr noundef @.str.478, ptr noundef @struct_char_ifreq_def)
  call void @thunk_register_struct(i32 noundef 12, ptr noundef @.str.479, ptr noundef @struct_ptr_ifreq_def)
  call void @thunk_register_struct(i32 noundef 13, ptr noundef @.str.480, ptr noundef @struct_ifconf_def)
  call void @thunk_register_struct(i32 noundef 14, ptr noundef @.str.481, ptr noundef @struct_arpreq_def)
  call void @thunk_register_struct(i32 noundef 15, ptr noundef @.str.482, ptr noundef @struct_arpreq_old_def)
  call void @thunk_register_struct(i32 noundef 16, ptr noundef @.str.483, ptr noundef @struct_cdrom_read_audio_def)
  call void @thunk_register_struct(i32 noundef 17, ptr noundef @.str.484, ptr noundef @struct_hd_geometry_def)
  call void @thunk_register_struct(i32 noundef 18, ptr noundef @.str.485, ptr noundef @struct_dirent_def)
  call void @thunk_register_struct(i32 noundef 19, ptr noundef @.str.486, ptr noundef @struct_kbentry_def)
  call void @thunk_register_struct(i32 noundef 20, ptr noundef @.str.487, ptr noundef @struct_kbsentry_def)
  call void @thunk_register_struct(i32 noundef 21, ptr noundef @.str.488, ptr noundef @struct_audio_buf_info_def)
  call void @thunk_register_struct(i32 noundef 22, ptr noundef @.str.489, ptr noundef @struct_count_info_def)
  call void @thunk_register_struct(i32 noundef 23, ptr noundef @.str.490, ptr noundef @struct_buffmem_desc_def)
  call void @thunk_register_struct(i32 noundef 24, ptr noundef @.str.491, ptr noundef @struct_mixer_info_def)
  call void @thunk_register_struct(i32 noundef 25, ptr noundef @.str.492, ptr noundef @struct_snd_timer_id_def)
  call void @thunk_register_struct(i32 noundef 26, ptr noundef @.str.493, ptr noundef @struct_snd_timer_ginfo_def)
  call void @thunk_register_struct(i32 noundef 27, ptr noundef @.str.494, ptr noundef @struct_snd_timer_gparams_def)
  call void @thunk_register_struct(i32 noundef 28, ptr noundef @.str.495, ptr noundef @struct_snd_timer_gstatus_def)
  call void @thunk_register_struct(i32 noundef 29, ptr noundef @.str.496, ptr noundef @struct_snd_timer_select_def)
  call void @thunk_register_struct(i32 noundef 30, ptr noundef @.str.497, ptr noundef @struct_snd_timer_info_def)
  call void @thunk_register_struct(i32 noundef 31, ptr noundef @.str.498, ptr noundef @struct_snd_timer_params_def)
  call void @thunk_register_struct(i32 noundef 32, ptr noundef @.str.499, ptr noundef @struct_timeval_def)
  call void @thunk_register_struct(i32 noundef 33, ptr noundef @.str.500, ptr noundef @struct__kernel_sock_timeval_def)
  call void @thunk_register_struct(i32 noundef 34, ptr noundef @.str.501, ptr noundef @struct_timespec_def)
  call void @thunk_register_struct(i32 noundef 35, ptr noundef @.str.502, ptr noundef @struct__kernel_timespec_def)
  call void @thunk_register_struct(i32 noundef 36, ptr noundef @.str.503, ptr noundef @struct_snd_timer_status_def)
  call void @thunk_register_struct(i32 noundef 37, ptr noundef @.str.504, ptr noundef @struct_loop_info_def)
  call void @thunk_register_struct(i32 noundef 38, ptr noundef @.str.505, ptr noundef @struct_loop_info64_def)
  call void @thunk_register_struct(i32 noundef 39, ptr noundef @.str.506, ptr noundef @struct_loop_config_def)
  call void @thunk_register_struct(i32 noundef 40, ptr noundef @.str.507, ptr noundef @struct_mtop_def)
  call void @thunk_register_struct(i32 noundef 41, ptr noundef @.str.508, ptr noundef @struct_mtget_def)
  call void @thunk_register_struct(i32 noundef 42, ptr noundef @.str.509, ptr noundef @struct_mtpos_def)
  call void @thunk_register_struct(i32 noundef 43, ptr noundef @.str.510, ptr noundef @struct_fb_fix_screeninfo_def)
  call void @thunk_register_struct(i32 noundef 44, ptr noundef @.str.511, ptr noundef @struct_fb_var_screeninfo_def)
  call void @thunk_register_struct(i32 noundef 45, ptr noundef @.str.512, ptr noundef @struct_fb_cmap_def)
  call void @thunk_register_struct(i32 noundef 46, ptr noundef @.str.513, ptr noundef @struct_fb_con2fbmap_def)
  call void @thunk_register_struct(i32 noundef 47, ptr noundef @.str.514, ptr noundef @struct_vt_stat_def)
  call void @thunk_register_struct(i32 noundef 48, ptr noundef @.str.515, ptr noundef @struct_vt_mode_def)
  call void @thunk_register_struct(i32 noundef 49, ptr noundef @.str.516, ptr noundef @struct_dm_ioctl_def)
  call void @thunk_register_struct(i32 noundef 50, ptr noundef @.str.517, ptr noundef @struct_dm_target_spec_def)
  call void @thunk_register_struct(i32 noundef 51, ptr noundef @.str.518, ptr noundef @struct_dm_target_deps_def)
  call void @thunk_register_struct(i32 noundef 52, ptr noundef @.str.519, ptr noundef @struct_dm_name_list_def)
  call void @thunk_register_struct(i32 noundef 53, ptr noundef @.str.520, ptr noundef @struct_dm_target_versions_def)
  call void @thunk_register_struct(i32 noundef 54, ptr noundef @.str.521, ptr noundef @struct_dm_target_msg_def)
  call void @thunk_register_struct(i32 noundef 55, ptr noundef @.str.522, ptr noundef @struct_drm_version_def)
  call void @thunk_register_struct(i32 noundef 56, ptr noundef @.str.523, ptr noundef @struct_drm_i915_getparam_def)
  call void @thunk_register_struct(i32 noundef 57, ptr noundef @.str.524, ptr noundef @struct_file_clone_range_def)
  call void @thunk_register_struct(i32 noundef 58, ptr noundef @.str.525, ptr noundef @struct_fiemap_extent_def)
  call void @thunk_register_struct(i32 noundef 59, ptr noundef @.str.526, ptr noundef @struct_fiemap_def)
  call void @thunk_register_struct(i32 noundef 60, ptr noundef @.str.527, ptr noundef @struct_blkpg_partition_def)
  call void @thunk_register_struct(i32 noundef 61, ptr noundef @.str.528, ptr noundef @struct_btrfs_ioctl_vol_args_def)
  call void @thunk_register_struct(i32 noundef 62, ptr noundef @.str.529, ptr noundef @struct_btrfs_ioctl_timespec_def)
  call void @thunk_register_struct(i32 noundef 63, ptr noundef @.str.530, ptr noundef @struct_btrfs_ioctl_get_subvol_info_args_def)
  call void @thunk_register_struct(i32 noundef 64, ptr noundef @.str.531, ptr noundef @struct_btrfs_ioctl_ino_lookup_args_def)
  call void @thunk_register_struct(i32 noundef 65, ptr noundef @.str.532, ptr noundef @struct_btrfs_ioctl_ino_path_args_def)
  call void @thunk_register_struct(i32 noundef 66, ptr noundef @.str.533, ptr noundef @struct_btrfs_ioctl_logical_ino_args_def)
  call void @thunk_register_struct(i32 noundef 67, ptr noundef @.str.534, ptr noundef @struct_btrfs_ioctl_ino_lookup_user_args_def)
  call void @thunk_register_struct(i32 noundef 68, ptr noundef @.str.535, ptr noundef @struct_btrfs_scrub_progress_def)
  call void @thunk_register_struct(i32 noundef 69, ptr noundef @.str.536, ptr noundef @struct_btrfs_ioctl_scrub_args_def)
  call void @thunk_register_struct(i32 noundef 70, ptr noundef @.str.537, ptr noundef @struct_btrfs_ioctl_dev_info_args_def)
  call void @thunk_register_struct(i32 noundef 71, ptr noundef @.str.538, ptr noundef @struct_rootref_def)
  call void @thunk_register_struct(i32 noundef 72, ptr noundef @.str.539, ptr noundef @struct_btrfs_ioctl_get_subvol_rootref_args_def)
  call void @thunk_register_struct(i32 noundef 73, ptr noundef @.str.540, ptr noundef @struct_btrfs_ioctl_get_dev_stats_def)
  call void @thunk_register_struct(i32 noundef 74, ptr noundef @.str.541, ptr noundef @struct_btrfs_ioctl_quota_ctl_args_def)
  call void @thunk_register_struct(i32 noundef 75, ptr noundef @.str.542, ptr noundef @struct_btrfs_ioctl_quota_rescan_args_def)
  call void @thunk_register_struct(i32 noundef 76, ptr noundef @.str.543, ptr noundef @struct_btrfs_ioctl_qgroup_assign_args_def)
  call void @thunk_register_struct(i32 noundef 77, ptr noundef @.str.544, ptr noundef @struct_btrfs_ioctl_qgroup_create_args_def)
  call void @thunk_register_struct(i32 noundef 78, ptr noundef @.str.545, ptr noundef @struct_btrfs_qgroup_limit_def)
  call void @thunk_register_struct(i32 noundef 79, ptr noundef @.str.546, ptr noundef @struct_btrfs_ioctl_qgroup_limit_args_def)
  call void @thunk_register_struct(i32 noundef 80, ptr noundef @.str.547, ptr noundef @struct_btrfs_ioctl_feature_flags_def)
  call void @thunk_register_struct(i32 noundef 81, ptr noundef @.str.548, ptr noundef @struct_rtc_time_def)
  call void @thunk_register_struct(i32 noundef 82, ptr noundef @.str.549, ptr noundef @struct_rtc_wkalrm_def)
  call void @thunk_register_struct(i32 noundef 83, ptr noundef @.str.550, ptr noundef @struct_rtc_pll_info_def)
  call void @thunk_register_struct(i32 noundef 84, ptr noundef @.str.551, ptr noundef @struct_blkpg_ioctl_arg_def)
  call void @thunk_register_struct(i32 noundef 85, ptr noundef @.str.552, ptr noundef @struct_format_descr_def)
  call void @thunk_register_struct(i32 noundef 86, ptr noundef @.str.553, ptr noundef @struct_floppy_max_errors_def)
  call void @thunk_register_struct(i32 noundef 87, ptr noundef @.str.554, ptr noundef @struct_usbdevfs_ctrltransfer_def)
  call void @thunk_register_struct(i32 noundef 88, ptr noundef @.str.555, ptr noundef @struct_usbdevfs_bulktransfer_def)
  call void @thunk_register_struct(i32 noundef 89, ptr noundef @.str.556, ptr noundef @struct_usbdevfs_setinterface_def)
  call void @thunk_register_struct(i32 noundef 90, ptr noundef @.str.557, ptr noundef @struct_usbdevfs_disconnectsignal_def)
  call void @thunk_register_struct(i32 noundef 91, ptr noundef @.str.558, ptr noundef @struct_usbdevfs_getdriver_def)
  call void @thunk_register_struct(i32 noundef 92, ptr noundef @.str.559, ptr noundef @struct_usbdevfs_connectinfo_def)
  call void @thunk_register_struct(i32 noundef 93, ptr noundef @.str.560, ptr noundef @struct_usbdevfs_iso_packet_desc_def)
  call void @thunk_register_struct(i32 noundef 94, ptr noundef @.str.561, ptr noundef @struct_usbdevfs_urb_def)
  call void @thunk_register_struct(i32 noundef 95, ptr noundef @.str.562, ptr noundef @struct_usbdevfs_ioctl_def)
  call void @thunk_register_struct(i32 noundef 96, ptr noundef @.str.563, ptr noundef @struct_usbdevfs_hub_portinfo_def)
  call void @thunk_register_struct(i32 noundef 97, ptr noundef @.str.564, ptr noundef @struct_usbdevfs_disconnect_claim_def)
  store ptr @ioctl_entries, ptr %ie, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %entry
  %0 = load ptr, ptr %ie, align 8
  %target_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %target_cmd, align 8
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %ie, align 8
  %target_cmd1 = getelementptr inbounds %struct.IOCTLEntry, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %target_cmd1, align 8
  %shr = ashr i32 %3, 16
  %and = and i32 %shr, 16383
  %cmp2 = icmp eq i32 %and, 16383
  br i1 %cmp2, label %if.then, label %if.end11

if.then:                                          ; preds = %while.body
  %4 = load ptr, ptr %ie, align 8
  %arg_type3 = getelementptr inbounds %struct.IOCTLEntry, ptr %4, i32 0, i32 5
  %arraydecay = getelementptr inbounds [5 x i32], ptr %arg_type3, i64 0, i64 0
  store ptr %arraydecay, ptr %arg_type, align 8
  %5 = load ptr, ptr %arg_type, align 8
  %arrayidx = getelementptr i32, ptr %5, i64 0
  %6 = load i32, ptr %arrayidx, align 4
  %cmp4 = icmp ne i32 %6, 9
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  %7 = load ptr, ptr @stderr, align 8
  %8 = load ptr, ptr %ie, align 8
  %target_cmd6 = getelementptr inbounds %struct.IOCTLEntry, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %target_cmd6, align 8
  %call = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %7, ptr noundef @.str.565, i32 noundef %9)
  call void @exit(i32 noundef 1) #15
  unreachable

if.end:                                           ; preds = %if.then
  %10 = load ptr, ptr %arg_type, align 8
  %incdec.ptr = getelementptr i32, ptr %10, i32 1
  store ptr %incdec.ptr, ptr %arg_type, align 8
  %11 = load ptr, ptr %arg_type, align 8
  %call7 = call i32 @thunk_type_size(ptr noundef %11, i32 noundef 0)
  store i32 %call7, ptr %size, align 4
  %12 = load ptr, ptr %ie, align 8
  %target_cmd8 = getelementptr inbounds %struct.IOCTLEntry, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %target_cmd8, align 8
  %and9 = and i32 %13, -1073676289
  %14 = load i32, ptr %size, align 4
  %shl = shl i32 %14, 16
  %or = or i32 %and9, %shl
  %15 = load ptr, ptr %ie, align 8
  %target_cmd10 = getelementptr inbounds %struct.IOCTLEntry, ptr %15, i32 0, i32 0
  store i32 %or, ptr %target_cmd10, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %while.body
  %16 = load ptr, ptr %ie, align 8
  %incdec.ptr12 = getelementptr %struct.IOCTLEntry, ptr %16, i32 1
  store ptr %incdec.ptr12, ptr %ie, align 8
  br label %while.cond, !llvm.loop !12

while.end:                                        ; preds = %while.cond
  ret void
}

declare void @thunk_init(i32 noundef) #3

declare void @thunk_register_struct_direct(i32 noundef, ptr noundef, ptr noundef) #3

declare void @thunk_register_struct(i32 noundef, ptr noundef, ptr noundef) #3

declare i32 @fprintf(ptr noundef, ptr noundef, ...) #3

; Function Attrs: noreturn nounwind
declare void @exit(i32 noundef) #4

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @thunk_type_size(ptr noundef %type_ptr, i32 noundef %is_host) #0 {
entry:
  %retval = alloca i32, align 4
  %type_ptr.addr = alloca ptr, align 8
  %is_host.addr = alloca i32, align 4
  %type = alloca i32, align 4
  %size = alloca i32, align 4
  %se = alloca ptr, align 8
  store ptr %type_ptr, ptr %type_ptr.addr, align 8
  store i32 %is_host, ptr %is_host.addr, align 4
  %0 = load ptr, ptr %type_ptr.addr, align 8
  %1 = load i32, ptr %0, align 4
  store i32 %1, ptr %type, align 4
  %2 = load i32, ptr %type, align 4
  switch i32 %2, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb1
    i32 3, label %sw.bb2
    i32 7, label %sw.bb3
    i32 8, label %sw.bb3
    i32 4, label %sw.bb4
    i32 5, label %sw.bb4
    i32 6, label %sw.bb4
    i32 9, label %sw.bb4
    i32 12, label %sw.bb5
    i32 10, label %sw.bb9
    i32 11, label %sw.bb10
  ]

sw.bb:                                            ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  store i32 2, ptr %retval, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  store i32 4, ptr %retval, align 4
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry, %entry
  store i32 8, ptr %retval, align 4
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry, %entry, %entry, %entry
  %3 = load i32, ptr %is_host.addr, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb4
  store i32 8, ptr %retval, align 4
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb4
  store i32 8, ptr %retval, align 4
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %4 = load i32, ptr %is_host.addr, align 4
  %tobool6 = icmp ne i32 %4, 0
  br i1 %tobool6, label %if.then7, label %if.else8

if.then7:                                         ; preds = %sw.bb5
  store i32 8, ptr %retval, align 4
  br label %sw.epilog

if.else8:                                         ; preds = %sw.bb5
  store i32 2, ptr %retval, align 4
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %5 = load ptr, ptr %type_ptr.addr, align 8
  %arrayidx = getelementptr i32, ptr %5, i64 1
  %6 = load i32, ptr %arrayidx, align 4
  store i32 %6, ptr %size, align 4
  %7 = load i32, ptr %size, align 4
  %8 = load ptr, ptr %type_ptr.addr, align 8
  %add.ptr = getelementptr i32, ptr %8, i64 2
  %9 = load i32, ptr %is_host.addr, align 4
  %call = call i32 @thunk_type_size_array(ptr noundef %add.ptr, i32 noundef %9)
  %mul = mul i32 %7, %call
  store i32 %mul, ptr %retval, align 4
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry
  %10 = load ptr, ptr @struct_entries, align 8
  %11 = load ptr, ptr %type_ptr.addr, align 8
  %arrayidx11 = getelementptr i32, ptr %11, i64 1
  %12 = load i32, ptr %arrayidx11, align 4
  %idx.ext = zext i32 %12 to i64
  %add.ptr12 = getelementptr %struct.StructEntry, ptr %10, i64 %idx.ext
  store ptr %add.ptr12, ptr %se, align 8
  %13 = load ptr, ptr %se, align 8
  %size13 = getelementptr inbounds %struct.StructEntry, ptr %13, i32 0, i32 5
  %14 = load i32, ptr %is_host.addr, align 4
  %idxprom = sext i32 %14 to i64
  %arrayidx14 = getelementptr [2 x i32], ptr %size13, i64 0, i64 %idxprom
  %15 = load i32, ptr %arrayidx14, align 4
  store i32 %15, ptr %retval, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.592, i32 noundef 141, ptr noundef @__func__.thunk_type_size, ptr noundef null) #19
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb10, %sw.bb9, %if.else8, %if.then7, %if.else, %if.then, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @host_to_target_waitstatus(i32 noundef %status) #0 {
entry:
  %retval = alloca i32, align 4
  %status.addr = alloca i32, align 4
  store i32 %status, ptr %status.addr, align 4
  %0 = load i32, ptr %status.addr, align 4
  %and = and i32 %0, 127
  %add = add i32 %and, 1
  %conv = trunc i32 %add to i8
  %conv1 = sext i8 %conv to i32
  %shr = ashr i32 %conv1, 1
  %cmp = icmp sgt i32 %shr, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %status.addr, align 4
  %and3 = and i32 %1, 127
  %call = call i32 @host_to_target_signal(i32 noundef %and3)
  %2 = load i32, ptr %status.addr, align 4
  %and4 = and i32 %2, -128
  %or = or i32 %call, %and4
  store i32 %or, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %status.addr, align 4
  %and5 = and i32 %3, 255
  %cmp6 = icmp eq i32 %and5, 127
  br i1 %cmp6, label %if.then8, label %if.end14

if.then8:                                         ; preds = %if.end
  %4 = load i32, ptr %status.addr, align 4
  %and9 = and i32 %4, 65280
  %shr10 = ashr i32 %and9, 8
  %call11 = call i32 @host_to_target_signal(i32 noundef %shr10)
  %shl = shl i32 %call11, 8
  %5 = load i32, ptr %status.addr, align 4
  %and12 = and i32 %5, 255
  %or13 = or i32 %shl, %and12
  store i32 %or13, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end
  %6 = load i32, ptr %status.addr, align 4
  store i32 %6, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %if.then8, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare i32 @host_to_target_signal(i32 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @target_exception_dump(ptr noundef %env, ptr noundef %fmt, i32 noundef %code) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %code.addr = alloca i32, align 4
  %logfile = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  store i32 %code, ptr %code.addr, align 4
  %0 = load ptr, ptr @stderr, align 8
  %1 = load ptr, ptr %env.addr, align 8
  %2 = load ptr, ptr %fmt.addr, align 8
  %3 = load i32, ptr %code.addr, align 4
  call void @excp_dump_file(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef %3)
  %call = call zeroext i1 @qemu_log_separate()
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @qemu_log_trylock()
  store ptr %call1, ptr %logfile, align 8
  %4 = load ptr, ptr %logfile, align 8
  %5 = load ptr, ptr %env.addr, align 8
  %6 = load ptr, ptr %fmt.addr, align 8
  %7 = load i32, ptr %code.addr, align 4
  call void @excp_dump_file(ptr noundef %4, ptr noundef %5, ptr noundef %6, i32 noundef %7)
  %8 = load ptr, ptr %logfile, align 8
  call void @qemu_log_unlock(ptr noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @excp_dump_file(ptr noundef %logfile, ptr noundef %env, ptr noundef %fmt, i32 noundef %code) #0 {
entry:
  %logfile.addr = alloca ptr, align 8
  %env.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %code.addr = alloca i32, align 4
  %cs = alloca ptr, align 8
  store ptr %logfile, ptr %logfile.addr, align 8
  store ptr %env, ptr %env.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  store i32 %code, ptr %code.addr, align 4
  %0 = load ptr, ptr %logfile.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %env.addr, align 8
  %call = call ptr @env_cpu(ptr noundef %1)
  store ptr %call, ptr %cs, align 8
  %2 = load ptr, ptr %logfile.addr, align 8
  %3 = load ptr, ptr %fmt.addr, align 8
  %4 = load i32, ptr %code.addr, align 4
  %call1 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %2, ptr noundef %3, i32 noundef %4)
  %5 = load ptr, ptr %logfile.addr, align 8
  %6 = load ptr, ptr @exec_path, align 8
  %call2 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.593, ptr noundef %6)
  %7 = load ptr, ptr %cs, align 8
  %8 = load ptr, ptr %logfile.addr, align 8
  call void @cpu_dump_state(ptr noundef %7, ptr noundef %8, i32 noundef 0)
  %9 = load ptr, ptr %env.addr, align 8
  %10 = load ptr, ptr %logfile.addr, align 8
  %call3 = call i32 @fileno(ptr noundef %10) #14
  %call4 = call i32 @open_self_maps(ptr noundef %9, i32 noundef %call3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare zeroext i1 @qemu_log_separate() #3

declare ptr @qemu_log_trylock() #3

declare void @qemu_log_unlock(ptr noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @do_guest_openat(ptr noundef %cpu_env, i32 noundef %dirfd, ptr noundef %fname, i32 noundef %flags, i32 noundef %mode, i1 noundef zeroext %safe) #0 {
entry:
  %retval = alloca i32, align 4
  %cpu_env.addr = alloca ptr, align 8
  %dirfd.addr = alloca i32, align 4
  %fname.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %mode.addr = alloca i32, align 4
  %safe.addr = alloca i8, align 1
  %proc_name = alloca ptr, align 8
  %pathname = alloca ptr, align 8
  %fake_open = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tmpdir = alloca ptr, align 8
  %filename21 = alloca [4096 x i8], align 16
  %fd = alloca i32, align 4
  %r = alloca i32, align 4
  %e = alloca i32, align 4
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i32 %dirfd, ptr %dirfd.addr, align 4
  store ptr %fname, ptr %fname.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %mode, ptr %mode.addr, align 4
  %frombool = zext i1 %safe to i8
  store i8 %frombool, ptr %safe.addr, align 1
  store ptr null, ptr %proc_name, align 8
  %0 = load ptr, ptr %fname.addr, align 8
  %call = call ptr @realpath(ptr noundef %0, ptr noundef null) #14
  store ptr %call, ptr %proc_name, align 8
  %1 = load ptr, ptr %proc_name, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %proc_name, align 8
  %call1 = call i32 @strncmp(ptr noundef %2, ptr noundef @.str.572, i64 noundef 6) #18
  %cmp = icmp eq i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %3 = load ptr, ptr %proc_name, align 8
  store ptr %3, ptr %pathname, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %4 = load ptr, ptr %fname.addr, align 8
  store ptr %4, ptr %pathname, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %5 = load ptr, ptr %pathname, align 8
  %call2 = call i32 @is_proc_myself(ptr noundef %5, ptr noundef @.str.573)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.end
  %6 = load i8, ptr %safe.addr, align 1
  %tobool5 = trunc i8 %6 to i1
  br i1 %tobool5, label %if.then6, label %if.else8

if.then6:                                         ; preds = %if.then4
  %7 = load i32, ptr %dirfd.addr, align 4
  %8 = load ptr, ptr @exec_path, align 8
  %9 = load i32, ptr %flags.addr, align 4
  %10 = load i32, ptr %mode.addr, align 4
  %call7 = call i32 @safe_openat(i32 noundef %7, ptr noundef %8, i32 noundef %9, i32 noundef %10)
  store i32 %call7, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.else8:                                         ; preds = %if.then4
  %11 = load i32, ptr %dirfd.addr, align 4
  %12 = load ptr, ptr @exec_path, align 8
  %13 = load i32, ptr %flags.addr, align 4
  %14 = load i32, ptr %mode.addr, align 4
  %call9 = call i32 (i32, ptr, i32, ...) @openat64(i32 noundef %11, ptr noundef %12, i32 noundef %13, i32 noundef %14)
  store i32 %call9, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end10:                                         ; preds = %if.end
  store ptr @do_guest_openat.fakes, ptr %fake_open, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %15 = load ptr, ptr %fake_open, align 8
  %filename = getelementptr inbounds %struct.fake_open, ptr %15, i32 0, i32 0
  %16 = load ptr, ptr %filename, align 8
  %tobool11 = icmp ne ptr %16, null
  br i1 %tobool11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load ptr, ptr %fake_open, align 8
  %cmp12 = getelementptr inbounds %struct.fake_open, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %cmp12, align 8
  %19 = load ptr, ptr %pathname, align 8
  %20 = load ptr, ptr %fake_open, align 8
  %filename13 = getelementptr inbounds %struct.fake_open, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %filename13, align 8
  %call14 = call i32 %18(ptr noundef %19, ptr noundef %21)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %for.body
  br label %for.end

if.end17:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %22 = load ptr, ptr %fake_open, align 8
  %incdec.ptr = getelementptr %struct.fake_open, ptr %22, i32 1
  store ptr %incdec.ptr, ptr %fake_open, align 8
  br label %for.cond, !llvm.loop !13

for.end:                                          ; preds = %if.then16, %for.cond
  %23 = load ptr, ptr %fake_open, align 8
  %filename18 = getelementptr inbounds %struct.fake_open, ptr %23, i32 0, i32 0
  %24 = load ptr, ptr %filename18, align 8
  %tobool19 = icmp ne ptr %24, null
  br i1 %tobool19, label %if.then20, label %if.end50

if.then20:                                        ; preds = %for.end
  %call22 = call i32 @memfd_create(ptr noundef @.str.574, i32 noundef 0) #14
  store i32 %call22, ptr %fd, align 4
  %25 = load i32, ptr %fd, align 4
  %cmp23 = icmp slt i32 %25, 0
  br i1 %cmp23, label %if.then24, label %if.end41

if.then24:                                        ; preds = %if.then20
  %call25 = call ptr @__errno_location() #13
  %26 = load i32, ptr %call25, align 4
  %cmp26 = icmp ne i32 %26, 38
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.then24
  %27 = load i32, ptr %fd, align 4
  store i32 %27, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end28:                                         ; preds = %if.then24
  %call29 = call ptr @getenv(ptr noundef @.str.575) #14
  store ptr %call29, ptr %tmpdir, align 8
  %28 = load ptr, ptr %tmpdir, align 8
  %tobool30 = icmp ne ptr %28, null
  br i1 %tobool30, label %if.end32, label %if.then31

if.then31:                                        ; preds = %if.end28
  store ptr @.str.576, ptr %tmpdir, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then31, %if.end28
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %filename21, i64 0, i64 0
  %29 = load ptr, ptr %tmpdir, align 8
  %call33 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay, i64 noundef 4096, ptr noundef @.str.577, ptr noundef %29) #14
  %arraydecay34 = getelementptr inbounds [4096 x i8], ptr %filename21, i64 0, i64 0
  %call35 = call i32 @mkstemp64(ptr noundef %arraydecay34)
  store i32 %call35, ptr %fd, align 4
  %30 = load i32, ptr %fd, align 4
  %cmp36 = icmp slt i32 %30, 0
  br i1 %cmp36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end32
  %31 = load i32, ptr %fd, align 4
  store i32 %31, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end38:                                         ; preds = %if.end32
  %arraydecay39 = getelementptr inbounds [4096 x i8], ptr %filename21, i64 0, i64 0
  %call40 = call i32 @unlink(ptr noundef %arraydecay39) #14
  br label %if.end41

if.end41:                                         ; preds = %if.end38, %if.then20
  %32 = load ptr, ptr %fake_open, align 8
  %fill = getelementptr inbounds %struct.fake_open, ptr %32, i32 0, i32 1
  %33 = load ptr, ptr %fill, align 8
  %34 = load ptr, ptr %cpu_env.addr, align 8
  %35 = load i32, ptr %fd, align 4
  %call42 = call i32 %33(ptr noundef %34, i32 noundef %35)
  store i32 %call42, ptr %r, align 4
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.then44, label %if.end48

if.then44:                                        ; preds = %if.end41
  %call45 = call ptr @__errno_location() #13
  %36 = load i32, ptr %call45, align 4
  store i32 %36, ptr %e, align 4
  %37 = load i32, ptr %fd, align 4
  %call46 = call i32 @close(i32 noundef %37)
  %38 = load i32, ptr %e, align 4
  %call47 = call ptr @__errno_location() #13
  store i32 %38, ptr %call47, align 4
  %39 = load i32, ptr %r, align 4
  store i32 %39, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end48:                                         ; preds = %if.end41
  %40 = load i32, ptr %fd, align 4
  %call49 = call i64 @lseek64(i32 noundef %40, i64 noundef 0, i32 noundef 0) #14
  %41 = load i32, ptr %fd, align 4
  store i32 %41, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end50:                                         ; preds = %for.end
  %42 = load i8, ptr %safe.addr, align 1
  %tobool51 = trunc i8 %42 to i1
  br i1 %tobool51, label %if.then52, label %if.else55

if.then52:                                        ; preds = %if.end50
  %43 = load i32, ptr %dirfd.addr, align 4
  %44 = load ptr, ptr %pathname, align 8
  %call53 = call ptr @path(ptr noundef %44)
  %45 = load i32, ptr %flags.addr, align 4
  %46 = load i32, ptr %mode.addr, align 4
  %call54 = call i32 @safe_openat(i32 noundef %43, ptr noundef %call53, i32 noundef %45, i32 noundef %46)
  store i32 %call54, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.else55:                                        ; preds = %if.end50
  %47 = load i32, ptr %dirfd.addr, align 4
  %48 = load ptr, ptr %pathname, align 8
  %call56 = call ptr @path(ptr noundef %48)
  %49 = load i32, ptr %flags.addr, align 4
  %50 = load i32, ptr %mode.addr, align 4
  %call57 = call i32 (i32, ptr, i32, ...) @openat64(i32 noundef %47, ptr noundef %call56, i32 noundef %49, i32 noundef %50)
  store i32 %call57, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.else55, %if.then52, %if.end48, %if.then44, %if.then37, %if.then27, %if.else8, %if.then6
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %proc_name)
  %51 = load i32, ptr %retval, align 4
  ret i32 %51
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @g_autoptr_cleanup_generic_gfree(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %pp = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %pp, align 8
  %1 = load ptr, ptr %pp, align 8
  %2 = load ptr, ptr %1, align 8
  call void @g_free(ptr noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @open_self_maps(ptr noundef %cpu_env, i32 noundef %fd) #0 {
entry:
  %cpu_env.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load ptr, ptr %cpu_env.addr, align 8
  %1 = load i32, ptr %fd.addr, align 4
  %call = call i32 @open_self_maps_1(ptr noundef %0, i32 noundef %1, i1 noundef zeroext false)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @is_proc_myself(ptr noundef %filename, ptr noundef %entry1) #0 {
entry:
  %retval = alloca i32, align 4
  %filename.addr = alloca ptr, align 8
  %entry.addr = alloca ptr, align 8
  %myself = alloca [80 x i8], align 16
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %entry1, ptr %entry.addr, align 8
  %0 = load ptr, ptr %filename.addr, align 8
  %call = call i32 @strncmp(ptr noundef %0, ptr noundef @.str.572, i64 noundef 6) #18
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end30, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %filename.addr, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 6
  store ptr %add.ptr, ptr %filename.addr, align 8
  %2 = load ptr, ptr %filename.addr, align 8
  %call2 = call i32 @strncmp(ptr noundef %2, ptr noundef @.str.612, i64 noundef 5) #18
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.else, label %if.then4

if.then4:                                         ; preds = %if.then
  %3 = load ptr, ptr %filename.addr, align 8
  %add.ptr5 = getelementptr i8, ptr %3, i64 5
  store ptr %add.ptr5, ptr %filename.addr, align 8
  br label %if.end25

if.else:                                          ; preds = %if.then
  %4 = load ptr, ptr %filename.addr, align 8
  %5 = load i8, ptr %4, align 1
  %conv = sext i8 %5 to i32
  %cmp = icmp sge i32 %conv, 49
  br i1 %cmp, label %land.lhs.true, label %if.else23

land.lhs.true:                                    ; preds = %if.else
  %6 = load ptr, ptr %filename.addr, align 8
  %7 = load i8, ptr %6, align 1
  %conv7 = sext i8 %7 to i32
  %cmp8 = icmp sle i32 %conv7, 57
  br i1 %cmp8, label %if.then10, label %if.else23

if.then10:                                        ; preds = %land.lhs.true
  %arraydecay = getelementptr inbounds [80 x i8], ptr %myself, i64 0, i64 0
  %call11 = call i32 @getpid() #14
  %call12 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay, i64 noundef 80, ptr noundef @.str.613, i32 noundef %call11) #14
  %8 = load ptr, ptr %filename.addr, align 8
  %arraydecay13 = getelementptr inbounds [80 x i8], ptr %myself, i64 0, i64 0
  %arraydecay14 = getelementptr inbounds [80 x i8], ptr %myself, i64 0, i64 0
  %call15 = call i64 @strlen(ptr noundef %arraydecay14) #18
  %call16 = call i32 @strncmp(ptr noundef %8, ptr noundef %arraydecay13, i64 noundef %call15) #18
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.else22, label %if.then18

if.then18:                                        ; preds = %if.then10
  %arraydecay19 = getelementptr inbounds [80 x i8], ptr %myself, i64 0, i64 0
  %call20 = call i64 @strlen(ptr noundef %arraydecay19) #18
  %9 = load ptr, ptr %filename.addr, align 8
  %add.ptr21 = getelementptr i8, ptr %9, i64 %call20
  store ptr %add.ptr21, ptr %filename.addr, align 8
  br label %if.end

if.else22:                                        ; preds = %if.then10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then18
  br label %if.end24

if.else23:                                        ; preds = %land.lhs.true, %if.else
  store i32 0, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.then4
  %10 = load ptr, ptr %filename.addr, align 8
  %11 = load ptr, ptr %entry.addr, align 8
  %call26 = call i32 @strcmp(ptr noundef %10, ptr noundef %11) #18
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %if.end25
  store i32 1, ptr %retval, align 4
  br label %return

if.end29:                                         ; preds = %if.end25
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end30, %if.then28, %if.else23, %if.else22
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @open_self_smaps(ptr noundef %cpu_env, i32 noundef %fd) #0 {
entry:
  %cpu_env.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load ptr, ptr %cpu_env.addr, align 8
  %1 = load i32, ptr %fd.addr, align 4
  %call = call i32 @open_self_maps_1(ptr noundef %0, i32 noundef %1, i1 noundef zeroext true)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @open_self_stat(ptr noundef %cpu_env, i32 noundef %fd) #0 {
entry:
  %retval = alloca i32, align 4
  %cpu_env.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cpu = alloca ptr, align 8
  %ts = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %i = alloca i32, align 4
  %bin = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load ptr, ptr %cpu_env.addr, align 8
  %call = call ptr @env_cpu(ptr noundef %0)
  store ptr %call, ptr %cpu, align 8
  %1 = load ptr, ptr %cpu, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  store ptr %2, ptr %ts, align 8
  %call1 = call ptr @g_string_new(ptr noundef null)
  store ptr %call1, ptr %buf, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %3, 44
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, ptr %i, align 4
  %cmp2 = icmp eq i32 %4, 0
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %5 = load ptr, ptr %buf, align 8
  %call3 = call i32 @getpid() #14
  call void (ptr, ptr, ...) @g_string_printf(ptr noundef %5, ptr noundef @.str.614, i32 noundef %call3)
  br label %if.end31

if.else:                                          ; preds = %for.body
  %6 = load i32, ptr %i, align 4
  %cmp4 = icmp eq i32 %6, 1
  br i1 %cmp4, label %if.then5, label %if.else10

if.then5:                                         ; preds = %if.else
  %7 = load ptr, ptr %ts, align 8
  %bprm = getelementptr inbounds %struct.TaskState, ptr %7, i32 0, i32 8
  %8 = load ptr, ptr %bprm, align 8
  %argv = getelementptr inbounds %struct.linux_binprm, ptr %8, i32 0, i32 7
  %9 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %call6 = call ptr @g_strrstr(ptr noundef %10, ptr noundef @.str.615)
  store ptr %call6, ptr %bin, align 8
  %11 = load ptr, ptr %bin, align 8
  %tobool = icmp ne ptr %11, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then5
  %12 = load ptr, ptr %bin, align 8
  %add.ptr = getelementptr i8, ptr %12, i64 1
  br label %cond.end

cond.false:                                       ; preds = %if.then5
  %13 = load ptr, ptr %ts, align 8
  %bprm7 = getelementptr inbounds %struct.TaskState, ptr %13, i32 0, i32 8
  %14 = load ptr, ptr %bprm7, align 8
  %argv8 = getelementptr inbounds %struct.linux_binprm, ptr %14, i32 0, i32 7
  %15 = load ptr, ptr %argv8, align 8
  %arrayidx9 = getelementptr ptr, ptr %15, i64 0
  %16 = load ptr, ptr %arrayidx9, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %add.ptr, %cond.true ], [ %16, %cond.false ]
  store ptr %cond, ptr %bin, align 8
  %17 = load ptr, ptr %buf, align 8
  %18 = load ptr, ptr %bin, align 8
  call void (ptr, ptr, ...) @g_string_printf(ptr noundef %17, ptr noundef @.str.616, ptr noundef %18)
  br label %if.end30

if.else10:                                        ; preds = %if.else
  %19 = load i32, ptr %i, align 4
  %cmp11 = icmp eq i32 %19, 2
  br i1 %cmp11, label %if.then12, label %if.else14

if.then12:                                        ; preds = %if.else10
  %20 = load ptr, ptr %buf, align 8
  %call13 = call ptr @g_string_assign(ptr noundef %20, ptr noundef @.str.617)
  br label %if.end29

if.else14:                                        ; preds = %if.else10
  %21 = load i32, ptr %i, align 4
  %cmp15 = icmp eq i32 %21, 3
  br i1 %cmp15, label %if.then16, label %if.else18

if.then16:                                        ; preds = %if.else14
  %22 = load ptr, ptr %buf, align 8
  %call17 = call i32 @getppid() #14
  call void (ptr, ptr, ...) @g_string_printf(ptr noundef %22, ptr noundef @.str.614, i32 noundef %call17)
  br label %if.end28

if.else18:                                        ; preds = %if.else14
  %23 = load i32, ptr %i, align 4
  %cmp19 = icmp eq i32 %23, 21
  br i1 %cmp19, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.else18
  %24 = load ptr, ptr %buf, align 8
  %25 = load ptr, ptr %ts, align 8
  %start_boottime = getelementptr inbounds %struct.TaskState, ptr %25, i32 0, i32 16
  %26 = load i64, ptr %start_boottime, align 8
  call void (ptr, ptr, ...) @g_string_printf(ptr noundef %24, ptr noundef @.str.618, i64 noundef %26)
  br label %if.end27

if.else21:                                        ; preds = %if.else18
  %27 = load i32, ptr %i, align 4
  %cmp22 = icmp eq i32 %27, 27
  br i1 %cmp22, label %if.then23, label %if.else24

if.then23:                                        ; preds = %if.else21
  %28 = load ptr, ptr %buf, align 8
  %29 = load ptr, ptr %ts, align 8
  %info = getelementptr inbounds %struct.TaskState, ptr %29, i32 0, i32 7
  %30 = load ptr, ptr %info, align 8
  %start_stack = getelementptr inbounds %struct.image_info, ptr %30, i32 0, i32 7
  %31 = load i64, ptr %start_stack, align 8
  call void (ptr, ptr, ...) @g_string_printf(ptr noundef %28, ptr noundef @.str.619, i64 noundef %31)
  br label %if.end

if.else24:                                        ; preds = %if.else21
  %32 = load ptr, ptr %buf, align 8
  %33 = load i32, ptr %i, align 4
  %cmp25 = icmp eq i32 %33, 43
  %cond26 = select i1 %cmp25, i32 10, i32 32
  call void (ptr, ptr, ...) @g_string_printf(ptr noundef %32, ptr noundef @.str.620, i32 noundef %cond26)
  br label %if.end

if.end:                                           ; preds = %if.else24, %if.then23
  br label %if.end27

if.end27:                                         ; preds = %if.end, %if.then20
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.then16
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.then12
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %cond.end
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.then
  %34 = load i32, ptr %fd.addr, align 4
  %35 = load ptr, ptr %buf, align 8
  %str = getelementptr inbounds %struct._GString, ptr %35, i32 0, i32 0
  %36 = load ptr, ptr %str, align 8
  %37 = load ptr, ptr %buf, align 8
  %len = getelementptr inbounds %struct._GString, ptr %37, i32 0, i32 1
  %38 = load i64, ptr %len, align 8
  %call32 = call i64 @write(i32 noundef %34, ptr noundef %36, i64 noundef %38)
  %39 = load ptr, ptr %buf, align 8
  %len33 = getelementptr inbounds %struct._GString, ptr %39, i32 0, i32 1
  %40 = load i64, ptr %len33, align 8
  %cmp34 = icmp ne i64 %call32, %40
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end31
  store i32 -1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end36:                                         ; preds = %if.end31
  br label %for.inc

for.inc:                                          ; preds = %if.end36
  %41 = load i32, ptr %i, align 4
  %inc = add i32 %41, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !14

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then35
  call void @glib_autoptr_cleanup_GString(ptr noundef %buf)
  %42 = load i32, ptr %retval, align 4
  ret i32 %42
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @open_self_auxv(ptr noundef %cpu_env, i32 noundef %fd) #0 {
entry:
  %cpu_env.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cpu = alloca ptr, align 8
  %ts = alloca ptr, align 8
  %auxv = alloca i64, align 8
  %len = alloca i64, align 8
  %ptr = alloca ptr, align 8
  %r = alloca i64, align 8
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load ptr, ptr %cpu_env.addr, align 8
  %call = call ptr @env_cpu(ptr noundef %0)
  store ptr %call, ptr %cpu, align 8
  %1 = load ptr, ptr %cpu, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  store ptr %2, ptr %ts, align 8
  %3 = load ptr, ptr %ts, align 8
  %info = getelementptr inbounds %struct.TaskState, ptr %3, i32 0, i32 7
  %4 = load ptr, ptr %info, align 8
  %saved_auxv = getelementptr inbounds %struct.image_info, ptr %4, i32 0, i32 13
  %5 = load i64, ptr %saved_auxv, align 8
  store i64 %5, ptr %auxv, align 8
  %6 = load ptr, ptr %ts, align 8
  %info1 = getelementptr inbounds %struct.TaskState, ptr %6, i32 0, i32 7
  %7 = load ptr, ptr %info1, align 8
  %auxv_len = getelementptr inbounds %struct.image_info, ptr %7, i32 0, i32 14
  %8 = load i64, ptr %auxv_len, align 8
  store i64 %8, ptr %len, align 8
  %9 = load i64, ptr %auxv, align 8
  %10 = load i64, ptr %len, align 8
  %call2 = call ptr @lock_user(i32 noundef 1, i64 noundef %9, i64 noundef %10, i1 noundef zeroext false)
  store ptr %call2, ptr %ptr, align 8
  %11 = load ptr, ptr %ptr, align 8
  %cmp = icmp ne ptr %11, null
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then
  %12 = load i64, ptr %len, align 8
  %cmp3 = icmp ugt i64 %12, 0
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %13 = load i32, ptr %fd.addr, align 4
  %14 = load ptr, ptr %ptr, align 8
  %15 = load i64, ptr %len, align 8
  %call4 = call i64 @write(i32 noundef %13, ptr noundef %14, i64 noundef %15)
  store i64 %call4, ptr %r, align 8
  %16 = load i64, ptr %r, align 8
  %cmp5 = icmp sle i64 %16, 0
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  %17 = load i64, ptr %r, align 8
  %18 = load i64, ptr %len, align 8
  %sub = sub i64 %18, %17
  store i64 %sub, ptr %len, align 8
  %19 = load i64, ptr %r, align 8
  %20 = load ptr, ptr %ptr, align 8
  %add.ptr = getelementptr i8, ptr %20, i64 %19
  store ptr %add.ptr, ptr %ptr, align 8
  br label %while.cond, !llvm.loop !15

while.end:                                        ; preds = %if.then6, %while.cond
  %21 = load i32, ptr %fd.addr, align 4
  %call7 = call i64 @lseek64(i32 noundef %21, i64 noundef 0, i32 noundef 0) #14
  %22 = load ptr, ptr %ptr, align 8
  %23 = load i64, ptr %auxv, align 8
  %24 = load i64, ptr %len, align 8
  call void @unlock_user(ptr noundef %22, i64 noundef %23, i64 noundef %24)
  br label %if.end8

if.end8:                                          ; preds = %while.end, %entry
  ret i32 0
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @open_self_cmdline(ptr noundef %cpu_env, i32 noundef %fd) #0 {
entry:
  %retval = alloca i32, align 4
  %cpu_env.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %cpu = alloca ptr, align 8
  %bprm = alloca ptr, align 8
  %i = alloca i32, align 4
  %len = alloca i64, align 8
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load ptr, ptr %cpu_env.addr, align 8
  %call = call ptr @env_cpu(ptr noundef %0)
  store ptr %call, ptr %cpu, align 8
  %1 = load ptr, ptr %cpu, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %bprm1 = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 8
  %3 = load ptr, ptr %bprm1, align 8
  store ptr %3, ptr %bprm, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32, ptr %i, align 4
  %5 = load ptr, ptr %bprm, align 8
  %argc = getelementptr inbounds %struct.linux_binprm, ptr %5, i32 0, i32 5
  %6 = load i32, ptr %argc, align 16
  %cmp = icmp slt i32 %4, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load ptr, ptr %bprm, align 8
  %argv = getelementptr inbounds %struct.linux_binprm, ptr %7, i32 0, i32 7
  %8 = load ptr, ptr %argv, align 8
  %9 = load i32, ptr %i, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr ptr, ptr %8, i64 %idxprom
  %10 = load ptr, ptr %arrayidx, align 8
  %call2 = call i64 @strlen(ptr noundef %10) #18
  %add = add i64 %call2, 1
  store i64 %add, ptr %len, align 8
  %11 = load i32, ptr %fd.addr, align 4
  %12 = load ptr, ptr %bprm, align 8
  %argv3 = getelementptr inbounds %struct.linux_binprm, ptr %12, i32 0, i32 7
  %13 = load ptr, ptr %argv3, align 8
  %14 = load i32, ptr %i, align 4
  %idxprom4 = sext i32 %14 to i64
  %arrayidx5 = getelementptr ptr, ptr %13, i64 %idxprom4
  %15 = load ptr, ptr %arrayidx5, align 8
  %16 = load i64, ptr %len, align 8
  %call6 = call i64 @write(i32 noundef %11, ptr noundef %15, i64 noundef %16)
  %17 = load i64, ptr %len, align 8
  %cmp7 = icmp ne i64 %call6, %17
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %18 = load i32, ptr %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !16

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @open_cpuinfo(ptr noundef %cpu_env, i32 noundef %fd) #0 {
entry:
  %cpu_env.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %num_cpus = alloca i32, align 4
  %cpu = alloca ptr, align 8
  %cfg = alloca ptr, align 8
  %isa_string = alloca ptr, align 8
  %mmu = alloca ptr, align 8
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %call = call i64 @sysconf(i32 noundef 84) #14
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %num_cpus, align 4
  %0 = load ptr, ptr %cpu_env.addr, align 8
  %call1 = call ptr @env_archcpu(ptr noundef %0)
  store ptr %call1, ptr %cpu, align 8
  %1 = load ptr, ptr %cpu_env.addr, align 8
  %call2 = call ptr @riscv_cpu_cfg(ptr noundef %1)
  store ptr %call2, ptr %cfg, align 8
  %2 = load ptr, ptr %cpu, align 8
  %call3 = call ptr @riscv_isa_string(ptr noundef %2)
  store ptr %call3, ptr %isa_string, align 8
  %3 = load ptr, ptr %cfg, align 8
  %mmu4 = getelementptr inbounds %struct.RISCVCPUConfig, ptr %3, i32 0, i32 102
  %4 = load i8, ptr %mmu4, align 8
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %cpu_env.addr, align 8
  %xl = getelementptr inbounds %struct.CPUArchState, ptr %5, i32 0, i32 25
  %6 = load i32, ptr %xl, align 16
  %cmp = icmp eq i32 %6, 1
  %cond = select i1 %cmp, ptr @.str.621, ptr @.str.622
  store ptr %cond, ptr %mmu, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  store ptr @.str.623, ptr %mmu, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %num_cpus, align 4
  %cmp6 = icmp slt i32 %7, %8
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, ptr %fd.addr, align 4
  %10 = load i32, ptr %i, align 4
  %call8 = call i32 (i32, ptr, ...) @dprintf(i32 noundef %9, ptr noundef @.str.624, i32 noundef %10)
  %11 = load i32, ptr %fd.addr, align 4
  %12 = load i32, ptr %i, align 4
  %call9 = call i32 (i32, ptr, ...) @dprintf(i32 noundef %11, ptr noundef @.str.625, i32 noundef %12)
  %13 = load i32, ptr %fd.addr, align 4
  %14 = load ptr, ptr %isa_string, align 8
  %call10 = call i32 (i32, ptr, ...) @dprintf(i32 noundef %13, ptr noundef @.str.626, ptr noundef %14)
  %15 = load i32, ptr %fd.addr, align 4
  %16 = load ptr, ptr %mmu, align 8
  %call11 = call i32 (i32, ptr, ...) @dprintf(i32 noundef %15, ptr noundef @.str.627, ptr noundef %16)
  %17 = load i32, ptr %fd.addr, align 4
  %call12 = call i32 (i32, ptr, ...) @dprintf(i32 noundef %17, ptr noundef @.str.628)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load i32, ptr %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !17

for.end:                                          ; preds = %for.cond
  %19 = load ptr, ptr %isa_string, align 8
  call void @g_free(ptr noundef %19)
  ret i32 0
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @is_proc(ptr noundef %filename, ptr noundef %entry1) #0 {
entry:
  %filename.addr = alloca ptr, align 8
  %entry.addr = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %entry1, ptr %entry.addr, align 8
  %0 = load ptr, ptr %filename.addr, align 8
  %1 = load ptr, ptr %entry.addr, align 8
  %call = call i32 @strcmp(ptr noundef %0, ptr noundef %1) #18
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare ptr @realpath(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strncmp(ptr noundef, ptr noundef, i64 noundef) #5

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_openat(i32 noundef %dirfd, ptr noundef %pathname, i32 noundef %flags, i32 noundef %mode) #0 {
entry:
  %dirfd.addr = alloca i32, align 4
  %pathname.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %mode.addr = alloca i32, align 4
  store i32 %dirfd, ptr %dirfd.addr, align 4
  store ptr %pathname, ptr %pathname.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %mode, ptr %mode.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %dirfd.addr, align 4
  %4 = load ptr, ptr %pathname.addr, align 8
  %5 = load i32, ptr %flags.addr, align 4
  %6 = load i32, ptr %mode.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 257, i32 noundef %3, ptr noundef %4, i32 noundef %5, i32 noundef %6)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

declare i32 @openat64(i32 noundef, ptr noundef, i32 noundef, ...) #3

; Function Attrs: nounwind
declare i32 @memfd_create(ptr noundef, i32 noundef) #2

; Function Attrs: nounwind
declare ptr @getenv(ptr noundef) #2

; Function Attrs: nounwind
declare i32 @snprintf(ptr noundef, i64 noundef, ptr noundef, ...) #2

declare i32 @mkstemp64(ptr noundef) #3

; Function Attrs: nounwind
declare i32 @unlink(ptr noundef) #2

declare i32 @close(i32 noundef) #3

; Function Attrs: nounwind
declare i64 @lseek64(i32 noundef, i64 noundef, i32 noundef) #2

declare ptr @path(ptr noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @do_guest_readlink(ptr noundef %pathname, ptr noundef %buf, i64 noundef %bufsiz) #0 {
entry:
  %retval = alloca i64, align 8
  %pathname.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %bufsiz.addr = alloca i64, align 8
  %ret = alloca i64, align 8
  %_a22 = alloca i64, align 8
  %_b23 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %pathname, ptr %pathname.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %bufsiz, ptr %bufsiz.addr, align 8
  %0 = load ptr, ptr %pathname.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %buf.addr, align 8
  %tobool1 = icmp ne ptr %1, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call ptr @__errno_location() #13
  store i32 14, ptr %call, align 4
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i64, ptr %bufsiz.addr, align 8
  %tobool2 = icmp ne i64 %2, 0
  br i1 %tobool2, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %call4 = call ptr @__errno_location() #13
  store i32 22, ptr %call4, align 4
  store i64 -1, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %3 = load ptr, ptr %pathname.addr, align 8
  %call6 = call i32 @is_proc_myself(ptr noundef %3, ptr noundef @.str.573)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end5
  %4 = load ptr, ptr @exec_path, align 8
  %call9 = call i64 @strlen(ptr noundef %4) #18
  store i64 %call9, ptr %_a22, align 8
  %5 = load i64, ptr %bufsiz.addr, align 8
  store i64 %5, ptr %_b23, align 8
  %6 = load i64, ptr %_a22, align 8
  %7 = load i64, ptr %_b23, align 8
  %cmp = icmp ult i64 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then8
  %8 = load i64, ptr %_a22, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then8
  %9 = load i64, ptr %_b23, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %8, %cond.true ], [ %9, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %10 = load i64, ptr %tmp, align 8
  store i64 %10, ptr %ret, align 8
  %11 = load ptr, ptr %buf.addr, align 8
  %12 = load ptr, ptr @exec_path, align 8
  %13 = load i64, ptr %ret, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %11, ptr align 1 %12, i64 %13, i1 false)
  br label %if.end12

if.else:                                          ; preds = %if.end5
  %14 = load ptr, ptr %pathname.addr, align 8
  %call10 = call ptr @path(ptr noundef %14)
  %15 = load ptr, ptr %buf.addr, align 8
  %16 = load i64, ptr %bufsiz.addr, align 8
  %call11 = call i64 @readlink(ptr noundef %call10, ptr noundef %15, i64 noundef %16) #14
  store i64 %call11, ptr %ret, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else, %cond.end
  %17 = load i64, ptr %ret, align 8
  store i64 %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then3, %if.then
  %18 = load i64, ptr %retval, align 8
  ret i64 %18
}

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #5

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #6

; Function Attrs: nounwind
declare i64 @readlink(ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @do_syscall(ptr noundef %cpu_env, i32 noundef %num, i64 noundef %arg1, i64 noundef %arg2, i64 noundef %arg3, i64 noundef %arg4, i64 noundef %arg5, i64 noundef %arg6, i64 noundef %arg7, i64 noundef %arg8) #0 {
entry:
  %cpu_env.addr = alloca ptr, align 8
  %num.addr = alloca i32, align 4
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  %arg4.addr = alloca i64, align 8
  %arg5.addr = alloca i64, align 8
  %arg6.addr = alloca i64, align 8
  %arg7.addr = alloca i64, align 8
  %arg8.addr = alloca i64, align 8
  %cpu = alloca ptr, align 8
  %ret = alloca i64, align 8
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i32 %num, ptr %num.addr, align 4
  store i64 %arg1, ptr %arg1.addr, align 8
  store i64 %arg2, ptr %arg2.addr, align 8
  store i64 %arg3, ptr %arg3.addr, align 8
  store i64 %arg4, ptr %arg4.addr, align 8
  store i64 %arg5, ptr %arg5.addr, align 8
  store i64 %arg6, ptr %arg6.addr, align 8
  store i64 %arg7, ptr %arg7.addr, align 8
  store i64 %arg8, ptr %arg8.addr, align 8
  %0 = load ptr, ptr %cpu_env.addr, align 8
  %call = call ptr @env_cpu(ptr noundef %0)
  store ptr %call, ptr %cpu, align 8
  %1 = load ptr, ptr %cpu, align 8
  %2 = load i32, ptr %num.addr, align 4
  %3 = load i64, ptr %arg1.addr, align 8
  %4 = load i64, ptr %arg2.addr, align 8
  %5 = load i64, ptr %arg3.addr, align 8
  %6 = load i64, ptr %arg4.addr, align 8
  %7 = load i64, ptr %arg5.addr, align 8
  %8 = load i64, ptr %arg6.addr, align 8
  %9 = load i64, ptr %arg7.addr, align 8
  %10 = load i64, ptr %arg8.addr, align 8
  call void @record_syscall_start(ptr noundef %1, i32 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6, i64 noundef %7, i64 noundef %8, i64 noundef %9, i64 noundef %10)
  %call1 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 524288)
  %lnot = xor i1 %call1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load ptr, ptr %cpu_env.addr, align 8
  %12 = load i32, ptr %num.addr, align 4
  %13 = load i64, ptr %arg1.addr, align 8
  %14 = load i64, ptr %arg2.addr, align 8
  %15 = load i64, ptr %arg3.addr, align 8
  %16 = load i64, ptr %arg4.addr, align 8
  %17 = load i64, ptr %arg5.addr, align 8
  %18 = load i64, ptr %arg6.addr, align 8
  call void @print_syscall(ptr noundef %11, i32 noundef %12, i64 noundef %13, i64 noundef %14, i64 noundef %15, i64 noundef %16, i64 noundef %17, i64 noundef %18)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %19 = load ptr, ptr %cpu_env.addr, align 8
  %20 = load i32, ptr %num.addr, align 4
  %21 = load i64, ptr %arg1.addr, align 8
  %22 = load i64, ptr %arg2.addr, align 8
  %23 = load i64, ptr %arg3.addr, align 8
  %24 = load i64, ptr %arg4.addr, align 8
  %25 = load i64, ptr %arg5.addr, align 8
  %26 = load i64, ptr %arg6.addr, align 8
  %27 = load i64, ptr %arg7.addr, align 8
  %28 = load i64, ptr %arg8.addr, align 8
  %call3 = call i64 @do_syscall1(ptr noundef %19, i32 noundef %20, i64 noundef %21, i64 noundef %22, i64 noundef %23, i64 noundef %24, i64 noundef %25, i64 noundef %26, i64 noundef %27, i64 noundef %28)
  store i64 %call3, ptr %ret, align 8
  %call4 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 524288)
  %lnot5 = xor i1 %call4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %tobool10 = icmp ne i64 %conv9, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end
  %29 = load ptr, ptr %cpu_env.addr, align 8
  %30 = load i32, ptr %num.addr, align 4
  %31 = load i64, ptr %ret, align 8
  %32 = load i64, ptr %arg1.addr, align 8
  %33 = load i64, ptr %arg2.addr, align 8
  %34 = load i64, ptr %arg3.addr, align 8
  %35 = load i64, ptr %arg4.addr, align 8
  %36 = load i64, ptr %arg5.addr, align 8
  %37 = load i64, ptr %arg6.addr, align 8
  call void @print_syscall_ret(ptr noundef %29, i32 noundef %30, i64 noundef %31, i64 noundef %32, i64 noundef %33, i64 noundef %34, i64 noundef %35, i64 noundef %36, i64 noundef %37)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end
  %38 = load ptr, ptr %cpu, align 8
  %39 = load i32, ptr %num.addr, align 4
  %40 = load i64, ptr %ret, align 8
  call void @record_syscall_return(ptr noundef %38, i32 noundef %39, i64 noundef %40)
  %41 = load i64, ptr %ret, align 8
  ret i64 %41
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @env_cpu(ptr noundef %env) #0 {
entry:
  %env.addr = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %env.addr, align 8
  %add.ptr = getelementptr i8, ptr %0, i64 -10176
  ret ptr %add.ptr
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @record_syscall_start(ptr noundef %cpu, i32 noundef %num, i64 noundef %arg1, i64 noundef %arg2, i64 noundef %arg3, i64 noundef %arg4, i64 noundef %arg5, i64 noundef %arg6, i64 noundef %arg7, i64 noundef %arg8) #0 {
entry:
  %cpu.addr = alloca ptr, align 8
  %num.addr = alloca i32, align 4
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  %arg4.addr = alloca i64, align 8
  %arg5.addr = alloca i64, align 8
  %arg6.addr = alloca i64, align 8
  %arg7.addr = alloca i64, align 8
  %arg8.addr = alloca i64, align 8
  store ptr %cpu, ptr %cpu.addr, align 8
  store i32 %num, ptr %num.addr, align 4
  store i64 %arg1, ptr %arg1.addr, align 8
  store i64 %arg2, ptr %arg2.addr, align 8
  store i64 %arg3, ptr %arg3.addr, align 8
  store i64 %arg4, ptr %arg4.addr, align 8
  store i64 %arg5, ptr %arg5.addr, align 8
  store i64 %arg6, ptr %arg6.addr, align 8
  store i64 %arg7, ptr %arg7.addr, align 8
  store i64 %arg8, ptr %arg8.addr, align 8
  %0 = load ptr, ptr %cpu.addr, align 8
  %1 = load i32, ptr %num.addr, align 4
  %conv = sext i32 %1 to i64
  %2 = load i64, ptr %arg1.addr, align 8
  %3 = load i64, ptr %arg2.addr, align 8
  %4 = load i64, ptr %arg3.addr, align 8
  %5 = load i64, ptr %arg4.addr, align 8
  %6 = load i64, ptr %arg5.addr, align 8
  %7 = load i64, ptr %arg6.addr, align 8
  %8 = load i64, ptr %arg7.addr, align 8
  %9 = load i64, ptr %arg8.addr, align 8
  call void @qemu_plugin_vcpu_syscall(ptr noundef %0, i64 noundef %conv, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6, i64 noundef %7, i64 noundef %8, i64 noundef %9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @qemu_loglevel_mask(i32 noundef %mask) #0 {
entry:
  %mask.addr = alloca i32, align 4
  store i32 %mask, ptr %mask.addr, align 4
  %0 = load i32, ptr @qemu_loglevel, align 4
  %1 = load i32, ptr %mask.addr, align 4
  %and = and i32 %0, %1
  %cmp = icmp ne i32 %and, 0
  ret i1 %cmp
}

declare void @print_syscall(ptr noundef, i32 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_syscall1(ptr noundef %cpu_env, i32 noundef %num, i64 noundef %arg1, i64 noundef %arg2, i64 noundef %arg3, i64 noundef %arg4, i64 noundef %arg5, i64 noundef %arg6, i64 noundef %arg7, i64 noundef %arg8) #0 {
entry:
  %retval = alloca i64, align 8
  %cpu_env.addr = alloca ptr, align 8
  %num.addr = alloca i32, align 4
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  %arg4.addr = alloca i64, align 8
  %arg5.addr = alloca i64, align 8
  %arg6.addr = alloca i64, align 8
  %arg7.addr = alloca i64, align 8
  %arg8.addr = alloca i64, align 8
  %cpu = alloca ptr, align 8
  %ret = alloca i64, align 8
  %st = alloca %struct.stat, align 8
  %stfs = alloca %struct.statfs, align 8
  %p = alloca ptr, align 8
  %_val25 = alloca ptr, align 8
  %_val24 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %tmp8 = alloca ptr, align 8
  %ts = alloca ptr, align 8
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp20 = alloca i64, align 8
  %copy = alloca ptr, align 8
  %uinfo = alloca %struct.siginfo_t, align 8
  %puinfo = alloca ptr, align 8
  %fd = alloca i64, align 8
  %maxfd = alloca i64, align 8
  %_a26 = alloca i64, align 8
  %_b27 = alloca i64, align 8
  %tmp158 = alloca i64, align 8
  %info = alloca %struct.siginfo_t, align 8
  %p2 = alloca ptr, align 8
  %p2254 = alloca ptr, align 8
  %p3 = alloca ptr, align 8
  %p2298 = alloca ptr, align 8
  %p4 = alloca ptr, align 8
  %p2319 = alloca ptr, align 8
  %host_flags = alloca i32, align 4
  %p2372 = alloca ptr, align 8
  %tmsp = alloca ptr, align 8
  %tms = alloca %struct.tms, align 8
  %host_flags493 = alloca i32, align 4
  %sigsetsize = alloca i64, align 8
  %restorer = alloca i64, align 8
  %act = alloca ptr, align 8
  %oact = alloca ptr, align 8
  %how = alloca i32, align 4
  %set = alloca %struct.__sigset_t, align 8
  %oldset = alloca %struct.__sigset_t, align 8
  %set_ptr = alloca ptr, align 8
  %set578 = alloca %struct.__sigset_t, align 8
  %set595 = alloca ptr, align 8
  %set607 = alloca %struct.__sigset_t, align 8
  %uts = alloca %struct.timespec, align 8
  %puts = alloca ptr, align 8
  %uinfo608 = alloca %struct.siginfo_t, align 8
  %uinfo643 = alloca %struct.siginfo_t, align 8
  %uinfo655 = alloca %struct.siginfo_t, align 8
  %resource = alloca i32, align 4
  %target_rlim = alloca ptr, align 8
  %rlim = alloca %struct.rlimit, align 8
  %resource706 = alloca i32, align 4
  %target_rlim709 = alloca ptr, align 8
  %rlim710 = alloca %struct.rlimit, align 8
  %rusage = alloca %struct.rusage, align 8
  %tv = alloca %struct.timeval, align 8
  %tz = alloca %struct.timezone, align 4
  %tv759 = alloca %struct.timeval, align 8
  %ptv = alloca ptr, align 8
  %tz760 = alloca %struct.timezone, align 4
  %ptz = alloca ptr, align 8
  %p2781 = alloca ptr, align 8
  %p2795 = alloca ptr, align 8
  %_a28 = alloca i64, align 8
  %_b29 = alloca i64, align 8
  %tmp810 = alloca i64, align 8
  %ts868 = alloca ptr, align 8
  %target_stfs = alloca ptr, align 8
  %len = alloca i32, align 4
  %value = alloca %struct.itimerval, align 8
  %ovalue = alloca %struct.itimerval, align 8
  %pvalue = alloca ptr, align 8
  %value1191 = alloca %struct.itimerval, align 8
  %target_st = alloca ptr, align 8
  %status = alloca i32, align 4
  %status_ptr = alloca i64, align 8
  %rusage1281 = alloca %struct.rusage, align 8
  %rusage_ptr = alloca ptr, align 8
  %target_rusage = alloca i64, align 8
  %rusage_err = alloca i64, align 8
  %__gaddr1299 = alloca i64, align 8
  %__hptr1300 = alloca ptr, align 8
  %__ret1301 = alloca i64, align 8
  %tmp1309 = alloca i64, align 8
  %target_value = alloca ptr, align 8
  %value1331 = alloca %struct.sysinfo, align 8
  %buf = alloca ptr, align 8
  %host_buf = alloca %struct.timex, align 8
  %htx = alloca %struct.timex, align 8
  %vec = alloca ptr, align 8
  %vec1572 = alloca ptr, align 8
  %vec1588 = alloca ptr, align 8
  %low = alloca i64, align 8
  %high = alloca i64, align 8
  %vec1604 = alloca ptr, align 8
  %low1609 = alloca i64, align 8
  %high1610 = alloca i64, align 8
  %mask_size = alloca i32, align 4
  %mask = alloca ptr, align 8
  %numcpus = alloca i32, align 4
  %mask_size1666 = alloca i32, align 4
  %mask1667 = alloca ptr, align 8
  %cpuid = alloca i32, align 4
  %node1687 = alloca i32, align 4
  %__gaddr1707 = alloca i64, align 8
  %__hptr1708 = alloca ptr, align 8
  %__ret1709 = alloca i64, align 8
  %tmp1717 = alloca i64, align 8
  %__gaddr1723 = alloca i64, align 8
  %__hptr1724 = alloca ptr, align 8
  %__ret1725 = alloca i64, align 8
  %tmp1733 = alloca i64, align 8
  %target_schp = alloca ptr, align 8
  %schp = alloca %struct.sched_param, align 4
  %target_schp1753 = alloca ptr, align 8
  %schp1754 = alloca %struct.sched_param, align 4
  %target_schp1775 = alloca ptr, align 8
  %schp1776 = alloca %struct.sched_param, align 4
  %target_scha = alloca ptr, align 8
  %scha = alloca %struct.sched_attr, align 8
  %target_scha1849 = alloca ptr, align 8
  %scha1850 = alloca %struct.sched_attr, align 8
  %size1851 = alloca i32, align 4
  %zeroed = alloca i32, align 4
  %__gaddr1856 = alloca i64, align 8
  %__hptr1857 = alloca ptr, align 8
  %__ret1858 = alloca i64, align 8
  %tmp1867 = alloca i64, align 8
  %__gaddr1878 = alloca i64, align 8
  %__hptr1879 = alloca ptr, align 8
  %__ret1880 = alloca i64, align 8
  %tmp1888 = alloca i64, align 8
  %__gaddr1903 = alloca i64, align 8
  %__hptr1904 = alloca ptr, align 8
  %__ret1905 = alloca i64, align 8
  %tmp1913 = alloca i64, align 8
  %ts1982 = alloca %struct.timespec, align 8
  %req = alloca %struct.timespec, align 8
  %rem = alloca %struct.timespec, align 8
  %target_header = alloca ptr, align 8
  %target_data = alloca ptr, align 8
  %header = alloca %struct.__user_cap_header_struct, align 4
  %data = alloca [2 x %struct.__user_cap_data_struct], align 16
  %dataptr = alloca ptr, align 8
  %i = alloca i32, align 4
  %target_datalen = alloca i32, align 4
  %data_items = alloca i32, align 4
  %offp = alloca ptr, align 8
  %off = alloca i64, align 8
  %__gaddr2173 = alloca i64, align 8
  %__hptr2174 = alloca ptr, align 8
  %__ret2175 = alloca i64, align 8
  %tmp2184 = alloca i64, align 8
  %ret2 = alloca i64, align 8
  %__gaddr2199 = alloca i64, align 8
  %__hptr2200 = alloca ptr, align 8
  %__ret2201 = alloca i64, align 8
  %tmp2209 = alloca i64, align 8
  %target_stx = alloca ptr, align 8
  %dirfd = alloca i32, align 4
  %flags = alloca i32, align 4
  %host_stx = alloca %struct.target_statx, align 8
  %mask2239 = alloca i32, align 4
  %gidsetsize = alloca i32, align 4
  %target_grouplist = alloca ptr, align 8
  %grouplist = alloca ptr, align 8
  %i2365 = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %gidsetsize2415 = alloca i32, align 4
  %target_grouplist2417 = alloca ptr, align 8
  %grouplist2418 = alloca ptr, align 8
  %i2419 = alloca i32, align 4
  %ruid = alloca i32, align 4
  %euid = alloca i32, align 4
  %suid = alloca i32, align 4
  %__gaddr2502 = alloca i64, align 8
  %__hptr2503 = alloca ptr, align 8
  %__ret2504 = alloca i64, align 8
  %tmp2513 = alloca i64, align 8
  %__gaddr2516 = alloca i64, align 8
  %__hptr2517 = alloca ptr, align 8
  %__ret2518 = alloca i64, align 8
  %tmp2527 = alloca i64, align 8
  %__gaddr2530 = alloca i64, align 8
  %__hptr2531 = alloca ptr, align 8
  %__ret2532 = alloca i64, align 8
  %tmp2541 = alloca i64, align 8
  %rgid = alloca i32, align 4
  %egid = alloca i32, align 4
  %sgid = alloca i32, align 4
  %__gaddr2563 = alloca i64, align 8
  %__hptr2564 = alloca ptr, align 8
  %__ret2565 = alloca i64, align 8
  %tmp2574 = alloca i64, align 8
  %__gaddr2577 = alloca i64, align 8
  %__hptr2578 = alloca ptr, align 8
  %__ret2579 = alloca i64, align 8
  %tmp2588 = alloca i64, align 8
  %__gaddr2591 = alloca i64, align 8
  %__hptr2592 = alloca ptr, align 8
  %__ret2593 = alloca i64, align 8
  %tmp2602 = alloca i64, align 8
  %a = alloca ptr, align 8
  %b = alloca ptr, align 8
  %b2683 = alloca ptr, align 8
  %n = alloca ptr, align 8
  %v = alloca ptr, align 8
  %n2724 = alloca ptr, align 8
  %v2725 = alloca ptr, align 8
  %n2744 = alloca ptr, align 8
  %v2745 = alloca ptr, align 8
  %n2771 = alloca ptr, align 8
  %v2772 = alloca ptr, align 8
  %n2789 = alloca ptr, align 8
  %n2810 = alloca ptr, align 8
  %ts2821 = alloca %struct.timespec, align 8
  %ts2832 = alloca %struct.timespec, align 8
  %ts2843 = alloca %struct.timespec, align 8
  %ts2854 = alloca %struct.timespec, align 8
  %ts2882 = alloca ptr, align 8
  %tsp = alloca ptr, align 8
  %ts2905 = alloca [2 x %struct.timespec], align 16
  %posix_mq_attr = alloca %struct.mq_attr, align 8
  %pposix_mq_attr = alloca ptr, align 8
  %host_flags2973 = alloca i32, align 4
  %ts3002 = alloca %struct.timespec, align 8
  %ts3031 = alloca %struct.timespec, align 8
  %prio = alloca i32, align 4
  %__gaddr3060 = alloca i64, align 8
  %__hptr3061 = alloca ptr, align 8
  %__ret3062 = alloca i64, align 8
  %tmp3070 = alloca i64, align 8
  %posix_mq_attr_in = alloca %struct.mq_attr, align 8
  %posix_mq_attr_out = alloca %struct.mq_attr, align 8
  %loff_in = alloca i64, align 8
  %loff_out = alloca i64, align 8
  %ploff_in = alloca ptr, align 8
  %ploff_out = alloca ptr, align 8
  %__gaddr3108 = alloca i64, align 8
  %__hptr3109 = alloca ptr, align 8
  %__ret3110 = alloca i64, align 8
  %tmp3119 = alloca i64, align 8
  %__gaddr3126 = alloca i64, align 8
  %__hptr3127 = alloca ptr, align 8
  %__ret3128 = alloca i64, align 8
  %tmp3137 = alloca i64, align 8
  %__gaddr3149 = alloca i64, align 8
  %__hptr3150 = alloca ptr, align 8
  %__ret3151 = alloca i64, align 8
  %tmp3159 = alloca i64, align 8
  %__gaddr3166 = alloca i64, align 8
  %__hptr3167 = alloca ptr, align 8
  %__ret3168 = alloca i64, align 8
  %tmp3176 = alloca i64, align 8
  %vec3182 = alloca ptr, align 8
  %host_flags3198 = alloca i32, align 4
  %ep = alloca %struct.epoll_event, align 1
  %epp = alloca ptr, align 8
  %target_ep = alloca ptr, align 8
  %target_ep3266 = alloca ptr, align 8
  %ep3267 = alloca ptr, align 8
  %epfd = alloca i32, align 4
  %maxevents = alloca i32, align 4
  %timeout = alloca i32, align 4
  %set3291 = alloca ptr, align 8
  %i3313 = alloca i32, align 4
  %target_rnew = alloca ptr, align 8
  %target_rold = alloca ptr, align 8
  %rnew = alloca %struct.host_rlimit64, align 8
  %rold = alloca %struct.host_rlimit64, align 8
  %rnewp = alloca ptr, align 8
  %resource3340 = alloca i32, align 4
  %host_sevp = alloca %struct.sigevent, align 8
  %phost_sevp = alloca ptr, align 8
  %clkid = alloca i32, align 4
  %timer_index = alloca i32, align 4
  %phtimer = alloca ptr, align 8
  %__gaddr3418 = alloca i64, align 8
  %__hptr3419 = alloca ptr, align 8
  %__ret3420 = alloca i64, align 8
  %tmp3429 = alloca i64, align 8
  %timerid = alloca i32, align 4
  %htimer = alloca ptr, align 8
  %hspec_new = alloca %struct.itimerspec, align 8
  %hspec_old = alloca %struct.itimerspec, align 8
  %timerid3466 = alloca i32, align 4
  %htimer3476 = alloca ptr, align 8
  %hspec = alloca %struct.itimerspec, align 8
  %timerid3489 = alloca i32, align 4
  %htimer3496 = alloca ptr, align 8
  %timerid3504 = alloca i32, align 4
  %htimer3511 = alloca ptr, align 8
  %its_curr = alloca %struct.itimerspec, align 8
  %its_new = alloca %struct.itimerspec, align 8
  %its_old = alloca %struct.itimerspec, align 8
  %p_new = alloca ptr, align 8
  %inoff = alloca i64, align 8
  %outoff = alloca i64, align 8
  %pinoff = alloca ptr, align 8
  %poutoff = alloca ptr, align 8
  %__gaddr3611 = alloca i64, align 8
  %__hptr3612 = alloca ptr, align 8
  %__ret3613 = alloca i64, align 8
  %tmp3622 = alloca i64, align 8
  %__gaddr3629 = alloca i64, align 8
  %__hptr3630 = alloca ptr, align 8
  %__ret3631 = alloca i64, align 8
  %tmp3640 = alloca i64, align 8
  %__gaddr3658 = alloca i64, align 8
  %__hptr3659 = alloca ptr, align 8
  %__ret3660 = alloca i64, align 8
  %tmp3668 = alloca i64, align 8
  %__gaddr3675 = alloca i64, align 8
  %__hptr3676 = alloca ptr, align 8
  %__ret3677 = alloca i64, align 8
  %tmp3685 = alloca i64, align 8
  %p23692 = alloca ptr, align 8
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i32 %num, ptr %num.addr, align 4
  store i64 %arg1, ptr %arg1.addr, align 8
  store i64 %arg2, ptr %arg2.addr, align 8
  store i64 %arg3, ptr %arg3.addr, align 8
  store i64 %arg4, ptr %arg4.addr, align 8
  store i64 %arg5, ptr %arg5.addr, align 8
  store i64 %arg6, ptr %arg6.addr, align 8
  store i64 %arg7, ptr %arg7.addr, align 8
  store i64 %arg8, ptr %arg8.addr, align 8
  %0 = load ptr, ptr %cpu_env.addr, align 8
  %call = call ptr @env_cpu(ptr noundef %0)
  store ptr %call, ptr %cpu, align 8
  %1 = load i32, ptr %num.addr, align 4
  switch i32 %1, label %sw.default3706 [
    i32 93, label %sw.bb
    i32 63, label %sw.bb29
    i32 64, label %sw.bb57
    i32 56, label %sw.bb92
    i32 264, label %sw.bb105
    i32 265, label %sw.bb107
    i32 434, label %sw.bb110
    i32 424, label %sw.bb116
    i32 438, label %sw.bb132
    i32 57, label %sw.bb139
    i32 436, label %sw.bb145
    i32 214, label %sw.bb165
    i32 95, label %sw.bb167
    i32 37, label %sw.bb189
    i32 35, label %sw.bb208
    i32 281, label %sw.bb218
    i32 221, label %sw.bb223
    i32 49, label %sw.bb226
    i32 33, label %sw.bb234
    i32 62, label %sw.bb244
    i32 172, label %sw.bb249
    i32 40, label %sw.bb253
    i32 429, label %sw.bb297
    i32 428, label %sw.bb318
    i32 48, label %sw.bb337
    i32 439, label %sw.bb347
    i32 81, label %sw.bb358
    i32 267, label %sw.bb359
    i32 129, label %sw.bb364
    i32 276, label %sw.bb371
    i32 34, label %sw.bb387
    i32 23, label %sw.bb397
    i32 59, label %sw.bb408
    i32 153, label %sw.bb412
    i32 89, label %sw.bb439
    i32 39, label %sw.bb456
    i32 29, label %sw.bb465
    i32 25, label %sw.bb469
    i32 154, label %sw.bb473
    i32 166, label %sw.bb479
    i32 51, label %sw.bb484
    i32 24, label %sw.bb492
    i32 173, label %sw.bb512
    i32 157, label %sw.bb516
    i32 134, label %sw.bb520
    i32 135, label %sw.bb548
    i32 136, label %sw.bb577
    i32 133, label %sw.bb594
    i32 137, label %sw.bb606
    i32 138, label %sw.bb642
    i32 240, label %sw.bb654
    i32 139, label %sw.bb667
    i32 161, label %sw.bb673
    i32 164, label %sw.bb681
    i32 163, label %sw.bb705
    i32 165, label %sw.bb728
    i32 169, label %sw.bb738
    i32 170, label %sw.bb758
    i32 72, label %sw.bb778
    i32 36, label %sw.bb780
    i32 78, label %sw.bb794
    i32 224, label %sw.bb825
    i32 142, label %sw.bb834
    i32 222, label %sw.bb856
    i32 215, label %sw.bb861
    i32 226, label %sw.bb866
    i32 216, label %sw.bb891
    i32 227, label %sw.bb895
    i32 228, label %sw.bb901
    i32 229, label %sw.bb906
    i32 230, label %sw.bb911
    i32 231, label %sw.bb917
    i32 45, label %sw.bb921
    i32 46, label %sw.bb929
    i32 52, label %sw.bb934
    i32 53, label %sw.bb940
    i32 141, label %sw.bb950
    i32 140, label %sw.bb969
    i32 43, label %sw.bb976
    i32 44, label %sw.bb1035
    i32 202, label %sw.bb1040
    i32 242, label %sw.bb1043
    i32 200, label %sw.bb1047
    i32 203, label %sw.bb1051
    i32 205, label %sw.bb1055
    i32 204, label %sw.bb1058
    i32 209, label %sw.bb1061
    i32 201, label %sw.bb1066
    i32 207, label %sw.bb1072
    i32 212, label %sw.bb1076
    i32 211, label %sw.bb1080
    i32 269, label %sw.bb1084
    i32 243, label %sw.bb1089
    i32 206, label %sw.bb1094
    i32 210, label %sw.bb1099
    i32 278, label %sw.bb1105
    i32 198, label %sw.bb1114
    i32 199, label %sw.bb1119
    i32 208, label %sw.bb1124
    i32 116, label %sw.bb1130
    i32 103, label %sw.bb1157
    i32 102, label %sw.bb1190
    i32 80, label %sw.bb1212
    i32 58, label %sw.bb1276
    i32 260, label %sw.bb1280
    i32 225, label %sw.bb1322
    i32 179, label %sw.bb1330
    i32 190, label %sw.bb1395
    i32 193, label %sw.bb1402
    i32 192, label %sw.bb1406
    i32 191, label %sw.bb1410
    i32 187, label %sw.bb1415
    i32 186, label %sw.bb1419
    i32 188, label %sw.bb1425
    i32 189, label %sw.bb1429
    i32 194, label %sw.bb1433
    i32 195, label %sw.bb1439
    i32 196, label %sw.bb1443
    i32 197, label %sw.bb1447
    i32 82, label %sw.bb1449
    i32 220, label %sw.bb1454
    i32 94, label %sw.bb1459
    i32 162, label %sw.bb1465
    i32 160, label %sw.bb1473
    i32 171, label %sw.bb1496
    i32 266, label %sw.bb1514
    i32 155, label %sw.bb1531
    i32 50, label %sw.bb1536
    i32 92, label %sw.bb1541
    i32 61, label %sw.bb1545
    i32 73, label %sw.bb1548
    i32 32, label %sw.bb1550
    i32 65, label %sw.bb1556
    i32 66, label %sw.bb1571
    i32 69, label %sw.bb1587
    i32 70, label %sw.bb1603
    i32 156, label %sw.bb1621
    i32 83, label %sw.bb1626
    i32 123, label %sw.bb1631
    i32 122, label %sw.bb1665
    i32 168, label %sw.bb1686
    i32 118, label %sw.bb1737
    i32 121, label %sw.bb1752
    i32 119, label %sw.bb1774
    i32 120, label %sw.bb1793
    i32 275, label %sw.bb1798
    i32 274, label %sw.bb1848
    i32 124, label %sw.bb1967
    i32 125, label %sw.bb1971
    i32 126, label %sw.bb1976
    i32 127, label %sw.bb1981
    i32 101, label %sw.bb1992
    i32 167, label %sw.bb2004
    i32 67, label %sw.bb2006
    i32 68, label %sw.bb2027
    i32 17, label %sw.bb2048
    i32 90, label %sw.bb2056
    i32 91, label %sw.bb2056
    i32 132, label %sw.bb2168
    i32 71, label %sw.bb2170
    i32 79, label %sw.bb2215
    i32 291, label %sw.bb2231
    i32 174, label %sw.bb2327
    i32 176, label %sw.bb2332
    i32 175, label %sw.bb2337
    i32 177, label %sw.bb2342
    i32 145, label %sw.bb2347
    i32 143, label %sw.bb2355
    i32 158, label %sw.bb2363
    i32 159, label %sw.bb2414
    i32 55, label %sw.bb2462
    i32 54, label %sw.bb2471
    i32 147, label %sw.bb2485
    i32 148, label %sw.bb2495
    i32 149, label %sw.bb2546
    i32 150, label %sw.bb2556
    i32 146, label %sw.bb2607
    i32 144, label %sw.bb2613
    i32 151, label %sw.bb2619
    i32 152, label %sw.bb2624
    i32 232, label %sw.bb2629
    i32 223, label %sw.bb2642
    i32 233, label %sw.bb2649
    i32 178, label %sw.bb2652
    i32 213, label %sw.bb2656
    i32 11, label %sw.bb2660
    i32 12, label %sw.bb2660
    i32 13, label %sw.bb2682
    i32 5, label %sw.bb2694
    i32 6, label %sw.bb2694
    i32 7, label %sw.bb2723
    i32 8, label %sw.bb2743
    i32 9, label %sw.bb2743
    i32 10, label %sw.bb2770
    i32 14, label %sw.bb2788
    i32 15, label %sw.bb2788
    i32 16, label %sw.bb2809
    i32 112, label %sw.bb2820
    i32 113, label %sw.bb2831
    i32 114, label %sw.bb2842
    i32 115, label %sw.bb2853
    i32 96, label %sw.bb2881
    i32 130, label %sw.bb2888
    i32 131, label %sw.bb2895
    i32 99, label %sw.bb2903
    i32 100, label %sw.bb2903
    i32 88, label %sw.bb2904
    i32 98, label %sw.bb2941
    i32 26, label %sw.bb2947
    i32 27, label %sw.bb2958
    i32 28, label %sw.bb2966
    i32 180, label %sw.bb2972
    i32 181, label %sw.bb2992
    i32 182, label %sw.bb3001
    i32 183, label %sw.bb3030
    i32 185, label %sw.bb3072
    i32 77, label %sw.bb3099
    i32 76, label %sw.bb3105
    i32 75, label %sw.bb3181
    i32 19, label %sw.bb3197
    i32 47, label %sw.bb3220
    i32 84, label %sw.bb3226
    i32 74, label %sw.bb3232
    i32 20, label %sw.bb3236
    i32 21, label %sw.bb3242
    i32 22, label %sw.bb3265
    i32 261, label %sw.bb3339
    i32 107, label %sw.bb3396
    i32 110, label %sw.bb3436
    i32 108, label %sw.bb3465
    i32 109, label %sw.bb3488
    i32 111, label %sw.bb3503
    i32 85, label %sw.bb3518
    i32 87, label %sw.bb3530
    i32 86, label %sw.bb3541
    i32 31, label %sw.bb3561
    i32 30, label %sw.bb3567
    i32 268, label %sw.bb3574
    i32 97, label %sw.bb3580
    i32 272, label %sw.bb3585
    i32 279, label %sw.bb3592
    i32 283, label %sw.bb3602
    i32 285, label %sw.bb3608
    i32 41, label %sw.bb3691
    i32 258, label %sw.bb3704
  ]

sw.bb:                                            ; preds = %entry
  %call1 = call i32 @block_signals()
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i64 -512, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %sw.bb
  %call2 = call i32 @pthread_mutex_lock(ptr noundef @clone_lock) #14
  br label %while.cond

while.cond:                                       ; preds = %do.end, %if.end
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.579, i32 noundef 8998, ptr noundef @__func__.do_syscall1, ptr noundef null) #19
  unreachable

do.end:                                           ; No predecessors!
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond3

while.cond3:                                      ; preds = %do.end6, %while.end
  br i1 false, label %while.body4, label %while.end7

while.body4:                                      ; preds = %while.cond3
  br label %do.body5

do.body5:                                         ; preds = %while.body4
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.579, i32 noundef 8998, ptr noundef @__func__.do_syscall1, ptr noundef null) #19
  unreachable

do.end6:                                          ; No predecessors!
  br label %while.cond3

while.end7:                                       ; preds = %while.cond3
  %2 = load atomic i64, ptr @cpus_queue monotonic, align 8
  store i64 %2, ptr %_val24, align 8
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #14, !srcloc !18
  %3 = load ptr, ptr %_val24, align 8
  store ptr %3, ptr %tmp, align 8
  %4 = load ptr, ptr %tmp, align 8
  %node = getelementptr inbounds %struct.CPUState, ptr %4, i32 0, i32 35
  %5 = load atomic i64, ptr %node monotonic, align 8
  store i64 %5, ptr %_val25, align 8
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #14, !srcloc !19
  %6 = load ptr, ptr %_val25, align 8
  store ptr %6, ptr %tmp8, align 8
  %7 = load ptr, ptr %tmp8, align 8
  %tobool9 = icmp ne ptr %7, null
  br i1 %tobool9, label %if.then10, label %if.end26

if.then10:                                        ; preds = %while.end7
  %8 = load ptr, ptr %cpu, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %8, i32 0, i32 39
  %9 = load ptr, ptr %opaque, align 16
  store ptr %9, ptr %ts, align 8
  %10 = load ptr, ptr %ts, align 8
  %child_tidptr = getelementptr inbounds %struct.TaskState, ptr %10, i32 0, i32 2
  %11 = load i64, ptr %child_tidptr, align 8
  %tobool11 = icmp ne i64 %11, 0
  br i1 %tobool11, label %if.then12, label %if.end24

if.then12:                                        ; preds = %if.then10
  %12 = load ptr, ptr %ts, align 8
  %child_tidptr13 = getelementptr inbounds %struct.TaskState, ptr %12, i32 0, i32 2
  %13 = load i64, ptr %child_tidptr13, align 8
  store i64 %13, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %14 = load i64, ptr %__gaddr, align 8
  %call14 = call ptr @lock_user(i32 noundef 3, i64 noundef %14, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call14, ptr %__hptr, align 8
  %tobool15 = icmp ne ptr %call14, null
  br i1 %tobool15, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.then12
  br label %do.body17

do.body17:                                        ; preds = %if.then16
  %15 = load ptr, ptr %__hptr, align 8
  call void @stl_le_p(ptr noundef %15, i32 noundef 0)
  br label %do.end18

do.end18:                                         ; preds = %do.body17
  %16 = load ptr, ptr %__hptr, align 8
  %17 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %16, i64 noundef %17, i64 noundef 4)
  br label %if.end19

if.else:                                          ; preds = %if.then12
  store i64 -14, ptr %__ret, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.else, %do.end18
  %18 = load i64, ptr %__ret, align 8
  store i64 %18, ptr %tmp20, align 8
  %19 = load ptr, ptr %cpu, align 8
  %20 = load ptr, ptr %ts, align 8
  %child_tidptr21 = getelementptr inbounds %struct.TaskState, ptr %20, i32 0, i32 2
  %21 = load i64, ptr %child_tidptr21, align 8
  %call22 = call ptr @g2h(ptr noundef %19, i64 noundef %21)
  %call23 = call i32 @do_sys_futex(ptr noundef %call22, i32 noundef 1, i32 noundef 2147483647, ptr noundef null, ptr noundef null, i32 noundef 0)
  br label %if.end24

if.end24:                                         ; preds = %if.end19, %if.then10
  %22 = load ptr, ptr %cpu, align 8
  call void @object_unparent(ptr noundef %22)
  %23 = load ptr, ptr %cpu, align 8
  call void @object_unref(ptr noundef %23)
  %call25 = call i32 @pthread_mutex_unlock(ptr noundef @clone_lock) #14
  %24 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  store ptr null, ptr %24, align 8
  %25 = load ptr, ptr %ts, align 8
  call void @g_free(ptr noundef %25)
  call void @rcu_unregister_thread()
  call void @pthread_exit(ptr noundef null) #19
  unreachable

if.end26:                                         ; preds = %while.end7
  %call27 = call i32 @pthread_mutex_unlock(ptr noundef @clone_lock) #14
  %26 = load ptr, ptr %cpu_env.addr, align 8
  %27 = load i64, ptr %arg1.addr, align 8
  %conv = trunc i64 %27 to i32
  call void @preexit_cleanup(ptr noundef %26, i32 noundef %conv)
  %28 = load i64, ptr %arg1.addr, align 8
  %conv28 = trunc i64 %28 to i32
  call void @_exit(i32 noundef %conv28) #19
  unreachable

sw.bb29:                                          ; preds = %entry
  %29 = load i64, ptr %arg2.addr, align 8
  %cmp = icmp eq i64 %29, 0
  br i1 %cmp, label %land.lhs.true, label %if.else37

land.lhs.true:                                    ; preds = %sw.bb29
  %30 = load i64, ptr %arg3.addr, align 8
  %cmp31 = icmp eq i64 %30, 0
  br i1 %cmp31, label %if.then33, label %if.else37

if.then33:                                        ; preds = %land.lhs.true
  %31 = load i64, ptr %arg1.addr, align 8
  %conv34 = trunc i64 %31 to i32
  %call35 = call i64 @safe_read(i32 noundef %conv34, ptr noundef null, i64 noundef 0)
  %call36 = call i64 @get_errno(i64 noundef %call35)
  store i64 %call36, ptr %retval, align 8
  br label %return

if.else37:                                        ; preds = %land.lhs.true, %sw.bb29
  %32 = load i64, ptr %arg2.addr, align 8
  %33 = load i64, ptr %arg3.addr, align 8
  %call38 = call ptr @lock_user(i32 noundef 3, i64 noundef %32, i64 noundef %33, i1 noundef zeroext false)
  store ptr %call38, ptr %p, align 8
  %tobool39 = icmp ne ptr %call38, null
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.else37
  store i64 -14, ptr %retval, align 8
  br label %return

if.end41:                                         ; preds = %if.else37
  %34 = load i64, ptr %arg1.addr, align 8
  %conv42 = trunc i64 %34 to i32
  %35 = load ptr, ptr %p, align 8
  %36 = load i64, ptr %arg3.addr, align 8
  %call43 = call i64 @safe_read(i32 noundef %conv42, ptr noundef %35, i64 noundef %36)
  %call44 = call i64 @get_errno(i64 noundef %call43)
  store i64 %call44, ptr %ret, align 8
  %37 = load i64, ptr %ret, align 8
  %cmp45 = icmp sge i64 %37, 0
  br i1 %cmp45, label %land.lhs.true47, label %if.end55

land.lhs.true47:                                  ; preds = %if.end41
  %38 = load i64, ptr %arg1.addr, align 8
  %conv48 = trunc i64 %38 to i32
  %call49 = call ptr @fd_trans_host_to_target_data(i32 noundef %conv48)
  %tobool50 = icmp ne ptr %call49, null
  br i1 %tobool50, label %if.then51, label %if.end55

if.then51:                                        ; preds = %land.lhs.true47
  %39 = load i64, ptr %arg1.addr, align 8
  %conv52 = trunc i64 %39 to i32
  %call53 = call ptr @fd_trans_host_to_target_data(i32 noundef %conv52)
  %40 = load ptr, ptr %p, align 8
  %41 = load i64, ptr %ret, align 8
  %call54 = call i64 %call53(ptr noundef %40, i64 noundef %41)
  store i64 %call54, ptr %ret, align 8
  br label %if.end55

if.end55:                                         ; preds = %if.then51, %land.lhs.true47, %if.end41
  %42 = load ptr, ptr %p, align 8
  %43 = load i64, ptr %arg2.addr, align 8
  %44 = load i64, ptr %ret, align 8
  call void @unlock_user(ptr noundef %42, i64 noundef %43, i64 noundef %44)
  br label %if.end56

if.end56:                                         ; preds = %if.end55
  %45 = load i64, ptr %ret, align 8
  store i64 %45, ptr %retval, align 8
  br label %return

sw.bb57:                                          ; preds = %entry
  %46 = load i64, ptr %arg2.addr, align 8
  %cmp58 = icmp eq i64 %46, 0
  br i1 %cmp58, label %land.lhs.true60, label %if.end67

land.lhs.true60:                                  ; preds = %sw.bb57
  %47 = load i64, ptr %arg3.addr, align 8
  %cmp61 = icmp eq i64 %47, 0
  br i1 %cmp61, label %if.then63, label %if.end67

if.then63:                                        ; preds = %land.lhs.true60
  %48 = load i64, ptr %arg1.addr, align 8
  %conv64 = trunc i64 %48 to i32
  %call65 = call i64 @safe_write(i32 noundef %conv64, ptr noundef null, i64 noundef 0)
  %call66 = call i64 @get_errno(i64 noundef %call65)
  store i64 %call66, ptr %retval, align 8
  br label %return

if.end67:                                         ; preds = %land.lhs.true60, %sw.bb57
  %49 = load i64, ptr %arg2.addr, align 8
  %50 = load i64, ptr %arg3.addr, align 8
  %call68 = call ptr @lock_user(i32 noundef 1, i64 noundef %49, i64 noundef %50, i1 noundef zeroext true)
  store ptr %call68, ptr %p, align 8
  %tobool69 = icmp ne ptr %call68, null
  br i1 %tobool69, label %if.end71, label %if.then70

if.then70:                                        ; preds = %if.end67
  store i64 -14, ptr %retval, align 8
  br label %return

if.end71:                                         ; preds = %if.end67
  %51 = load i64, ptr %arg1.addr, align 8
  %conv72 = trunc i64 %51 to i32
  %call73 = call ptr @fd_trans_target_to_host_data(i32 noundef %conv72)
  %tobool74 = icmp ne ptr %call73, null
  br i1 %tobool74, label %if.then75, label %if.else87

if.then75:                                        ; preds = %if.end71
  %52 = load i64, ptr %arg3.addr, align 8
  %call76 = call noalias ptr @g_malloc(i64 noundef %52) #16
  store ptr %call76, ptr %copy, align 8
  %53 = load ptr, ptr %copy, align 8
  %54 = load ptr, ptr %p, align 8
  %55 = load i64, ptr %arg3.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %53, ptr align 1 %54, i64 %55, i1 false)
  %56 = load i64, ptr %arg1.addr, align 8
  %conv77 = trunc i64 %56 to i32
  %call78 = call ptr @fd_trans_target_to_host_data(i32 noundef %conv77)
  %57 = load ptr, ptr %copy, align 8
  %58 = load i64, ptr %arg3.addr, align 8
  %call79 = call i64 %call78(ptr noundef %57, i64 noundef %58)
  store i64 %call79, ptr %ret, align 8
  %59 = load i64, ptr %ret, align 8
  %cmp80 = icmp sge i64 %59, 0
  br i1 %cmp80, label %if.then82, label %if.end86

if.then82:                                        ; preds = %if.then75
  %60 = load i64, ptr %arg1.addr, align 8
  %conv83 = trunc i64 %60 to i32
  %61 = load ptr, ptr %copy, align 8
  %62 = load i64, ptr %ret, align 8
  %call84 = call i64 @safe_write(i32 noundef %conv83, ptr noundef %61, i64 noundef %62)
  %call85 = call i64 @get_errno(i64 noundef %call84)
  store i64 %call85, ptr %ret, align 8
  br label %if.end86

if.end86:                                         ; preds = %if.then82, %if.then75
  %63 = load ptr, ptr %copy, align 8
  call void @g_free(ptr noundef %63)
  br label %if.end91

if.else87:                                        ; preds = %if.end71
  %64 = load i64, ptr %arg1.addr, align 8
  %conv88 = trunc i64 %64 to i32
  %65 = load ptr, ptr %p, align 8
  %66 = load i64, ptr %arg3.addr, align 8
  %call89 = call i64 @safe_write(i32 noundef %conv88, ptr noundef %65, i64 noundef %66)
  %call90 = call i64 @get_errno(i64 noundef %call89)
  store i64 %call90, ptr %ret, align 8
  br label %if.end91

if.end91:                                         ; preds = %if.else87, %if.end86
  %67 = load ptr, ptr %p, align 8
  %68 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %67, i64 noundef %68, i64 noundef 0)
  %69 = load i64, ptr %ret, align 8
  store i64 %69, ptr %retval, align 8
  br label %return

sw.bb92:                                          ; preds = %entry
  %70 = load i64, ptr %arg2.addr, align 8
  %call93 = call ptr @lock_user_string(i64 noundef %70)
  store ptr %call93, ptr %p, align 8
  %tobool94 = icmp ne ptr %call93, null
  br i1 %tobool94, label %if.end96, label %if.then95

if.then95:                                        ; preds = %sw.bb92
  store i64 -14, ptr %retval, align 8
  br label %return

if.end96:                                         ; preds = %sw.bb92
  %71 = load ptr, ptr %cpu_env.addr, align 8
  %72 = load i64, ptr %arg1.addr, align 8
  %conv97 = trunc i64 %72 to i32
  %73 = load ptr, ptr %p, align 8
  %74 = load i64, ptr %arg3.addr, align 8
  %conv98 = trunc i64 %74 to i32
  %call99 = call i32 @target_to_host_bitmask_len(i32 noundef %conv98, ptr noundef @fcntl_flags_tbl, i64 noundef 19)
  %75 = load i64, ptr %arg4.addr, align 8
  %conv100 = trunc i64 %75 to i32
  %call101 = call i32 @do_guest_openat(ptr noundef %71, i32 noundef %conv97, ptr noundef %73, i32 noundef %call99, i32 noundef %conv100, i1 noundef zeroext true)
  %conv102 = sext i32 %call101 to i64
  %call103 = call i64 @get_errno(i64 noundef %conv102)
  store i64 %call103, ptr %ret, align 8
  %76 = load i64, ptr %ret, align 8
  %conv104 = trunc i64 %76 to i32
  call void @fd_trans_unregister(i32 noundef %conv104)
  %77 = load ptr, ptr %p, align 8
  %78 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %77, i64 noundef %78, i64 noundef 0)
  %79 = load i64, ptr %ret, align 8
  store i64 %79, ptr %retval, align 8
  br label %return

sw.bb105:                                         ; preds = %entry
  %80 = load i64, ptr %arg1.addr, align 8
  %81 = load i64, ptr %arg2.addr, align 8
  %82 = load i64, ptr %arg3.addr, align 8
  %83 = load i64, ptr %arg4.addr, align 8
  %84 = load i64, ptr %arg5.addr, align 8
  %call106 = call i64 @do_name_to_handle_at(i64 noundef %80, i64 noundef %81, i64 noundef %82, i64 noundef %83, i64 noundef %84)
  store i64 %call106, ptr %ret, align 8
  %85 = load i64, ptr %ret, align 8
  store i64 %85, ptr %retval, align 8
  br label %return

sw.bb107:                                         ; preds = %entry
  %86 = load i64, ptr %arg1.addr, align 8
  %87 = load i64, ptr %arg2.addr, align 8
  %88 = load i64, ptr %arg3.addr, align 8
  %call108 = call i64 @do_open_by_handle_at(i64 noundef %86, i64 noundef %87, i64 noundef %88)
  store i64 %call108, ptr %ret, align 8
  %89 = load i64, ptr %ret, align 8
  %conv109 = trunc i64 %89 to i32
  call void @fd_trans_unregister(i32 noundef %conv109)
  %90 = load i64, ptr %ret, align 8
  store i64 %90, ptr %retval, align 8
  br label %return

sw.bb110:                                         ; preds = %entry
  %91 = load i64, ptr %arg1.addr, align 8
  %conv111 = trunc i64 %91 to i32
  %92 = load i64, ptr %arg2.addr, align 8
  %conv112 = trunc i64 %92 to i32
  %call113 = call i32 @pidfd_open(i32 noundef %conv111, i32 noundef %conv112)
  %conv114 = sext i32 %call113 to i64
  %call115 = call i64 @get_errno(i64 noundef %conv114)
  store i64 %call115, ptr %retval, align 8
  br label %return

sw.bb116:                                         ; preds = %entry
  %93 = load i64, ptr %arg3.addr, align 8
  %tobool117 = icmp ne i64 %93, 0
  br i1 %tobool117, label %if.then118, label %if.else123

if.then118:                                       ; preds = %sw.bb116
  %94 = load i64, ptr %arg3.addr, align 8
  %call119 = call ptr @lock_user(i32 noundef 1, i64 noundef %94, i64 noundef 128, i1 noundef zeroext true)
  store ptr %call119, ptr %p, align 8
  %95 = load ptr, ptr %p, align 8
  %tobool120 = icmp ne ptr %95, null
  br i1 %tobool120, label %if.end122, label %if.then121

if.then121:                                       ; preds = %if.then118
  store i64 -14, ptr %retval, align 8
  br label %return

if.end122:                                        ; preds = %if.then118
  %96 = load ptr, ptr %p, align 8
  call void @target_to_host_siginfo(ptr noundef %uinfo, ptr noundef %96)
  %97 = load ptr, ptr %p, align 8
  %98 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %97, i64 noundef %98, i64 noundef 0)
  store ptr %uinfo, ptr %puinfo, align 8
  br label %if.end124

if.else123:                                       ; preds = %sw.bb116
  store ptr null, ptr %puinfo, align 8
  br label %if.end124

if.end124:                                        ; preds = %if.else123, %if.end122
  %99 = load i64, ptr %arg1.addr, align 8
  %conv125 = trunc i64 %99 to i32
  %100 = load i64, ptr %arg2.addr, align 8
  %conv126 = trunc i64 %100 to i32
  %call127 = call i32 @target_to_host_signal(i32 noundef %conv126)
  %101 = load ptr, ptr %puinfo, align 8
  %102 = load i64, ptr %arg4.addr, align 8
  %conv128 = trunc i64 %102 to i32
  %call129 = call i32 @pidfd_send_signal(i32 noundef %conv125, i32 noundef %call127, ptr noundef %101, i32 noundef %conv128)
  %conv130 = sext i32 %call129 to i64
  %call131 = call i64 @get_errno(i64 noundef %conv130)
  store i64 %call131, ptr %ret, align 8
  %103 = load i64, ptr %ret, align 8
  store i64 %103, ptr %retval, align 8
  br label %return

sw.bb132:                                         ; preds = %entry
  %104 = load i64, ptr %arg1.addr, align 8
  %conv133 = trunc i64 %104 to i32
  %105 = load i64, ptr %arg2.addr, align 8
  %conv134 = trunc i64 %105 to i32
  %106 = load i64, ptr %arg3.addr, align 8
  %conv135 = trunc i64 %106 to i32
  %call136 = call i32 @pidfd_getfd(i32 noundef %conv133, i32 noundef %conv134, i32 noundef %conv135)
  %conv137 = sext i32 %call136 to i64
  %call138 = call i64 @get_errno(i64 noundef %conv137)
  store i64 %call138, ptr %retval, align 8
  br label %return

sw.bb139:                                         ; preds = %entry
  %107 = load i64, ptr %arg1.addr, align 8
  %conv140 = trunc i64 %107 to i32
  call void @fd_trans_unregister(i32 noundef %conv140)
  %108 = load i64, ptr %arg1.addr, align 8
  %conv141 = trunc i64 %108 to i32
  %call142 = call i32 @close(i32 noundef %conv141)
  %conv143 = sext i32 %call142 to i64
  %call144 = call i64 @get_errno(i64 noundef %conv143)
  store i64 %call144, ptr %retval, align 8
  br label %return

sw.bb145:                                         ; preds = %entry
  %109 = load i64, ptr %arg1.addr, align 8
  %conv146 = trunc i64 %109 to i32
  %110 = load i64, ptr %arg2.addr, align 8
  %conv147 = trunc i64 %110 to i32
  %111 = load i64, ptr %arg3.addr, align 8
  %conv148 = trunc i64 %111 to i32
  %call149 = call i32 @sys_close_range(i32 noundef %conv146, i32 noundef %conv147, i32 noundef %conv148)
  %conv150 = sext i32 %call149 to i64
  %call151 = call i64 @get_errno(i64 noundef %conv150)
  store i64 %call151, ptr %ret, align 8
  %112 = load i64, ptr %ret, align 8
  %cmp152 = icmp eq i64 %112, 0
  br i1 %cmp152, label %land.lhs.true154, label %if.end164

land.lhs.true154:                                 ; preds = %sw.bb145
  %113 = load i64, ptr %arg3.addr, align 8
  %and = and i64 %113, 4
  %tobool155 = icmp ne i64 %and, 0
  br i1 %tobool155, label %if.end164, label %if.then156

if.then156:                                       ; preds = %land.lhs.true154
  %114 = load i64, ptr %arg2.addr, align 8
  store i64 %114, ptr %_a26, align 8
  %115 = load i32, ptr @target_fd_max, align 4
  %conv157 = zext i32 %115 to i64
  store i64 %conv157, ptr %_b27, align 8
  %116 = load i64, ptr %_a26, align 8
  %117 = load i64, ptr %_b27, align 8
  %cmp159 = icmp slt i64 %116, %117
  br i1 %cmp159, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then156
  %118 = load i64, ptr %_a26, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then156
  %119 = load i64, ptr %_b27, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %118, %cond.true ], [ %119, %cond.false ]
  store i64 %cond, ptr %tmp158, align 8
  %120 = load i64, ptr %tmp158, align 8
  store i64 %120, ptr %maxfd, align 8
  %121 = load i64, ptr %arg1.addr, align 8
  store i64 %121, ptr %fd, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %122 = load i64, ptr %fd, align 8
  %123 = load i64, ptr %maxfd, align 8
  %cmp161 = icmp slt i64 %122, %123
  br i1 %cmp161, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %124 = load i64, ptr %fd, align 8
  %conv163 = trunc i64 %124 to i32
  call void @fd_trans_unregister(i32 noundef %conv163)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %125 = load i64, ptr %fd, align 8
  %inc = add i64 %125, 1
  store i64 %inc, ptr %fd, align 8
  br label %for.cond, !llvm.loop !20

for.end:                                          ; preds = %for.cond
  br label %if.end164

if.end164:                                        ; preds = %for.end, %land.lhs.true154, %sw.bb145
  %126 = load i64, ptr %ret, align 8
  store i64 %126, ptr %retval, align 8
  br label %return

sw.bb165:                                         ; preds = %entry
  %127 = load i64, ptr %arg1.addr, align 8
  %call166 = call i64 @do_brk(i64 noundef %127)
  store i64 %call166, ptr %retval, align 8
  br label %return

sw.bb167:                                         ; preds = %entry
  %_sifields = getelementptr inbounds %struct.siginfo_t, ptr %info, i32 0, i32 4
  %si_pid = getelementptr inbounds %struct.anon.16, ptr %_sifields, i32 0, i32 0
  store i32 0, ptr %si_pid, align 8
  %128 = load i64, ptr %arg1.addr, align 8
  %conv168 = trunc i64 %128 to i32
  %129 = load i64, ptr %arg2.addr, align 8
  %conv169 = trunc i64 %129 to i32
  %130 = load i64, ptr %arg4.addr, align 8
  %conv170 = trunc i64 %130 to i32
  %call171 = call i32 @safe_waitid(i32 noundef %conv168, i32 noundef %conv169, ptr noundef %info, i32 noundef %conv170, ptr noundef null)
  %conv172 = sext i32 %call171 to i64
  %call173 = call i64 @get_errno(i64 noundef %conv172)
  store i64 %call173, ptr %ret, align 8
  %131 = load i64, ptr %ret, align 8
  %call174 = call i32 @is_error(i64 noundef %131)
  %tobool175 = icmp ne i32 %call174, 0
  br i1 %tobool175, label %if.end188, label %land.lhs.true176

land.lhs.true176:                                 ; preds = %sw.bb167
  %132 = load i64, ptr %arg3.addr, align 8
  %tobool177 = icmp ne i64 %132, 0
  br i1 %tobool177, label %land.lhs.true178, label %if.end188

land.lhs.true178:                                 ; preds = %land.lhs.true176
  %_sifields179 = getelementptr inbounds %struct.siginfo_t, ptr %info, i32 0, i32 4
  %si_pid180 = getelementptr inbounds %struct.anon.16, ptr %_sifields179, i32 0, i32 0
  %133 = load i32, ptr %si_pid180, align 8
  %cmp181 = icmp ne i32 %133, 0
  br i1 %cmp181, label %if.then183, label %if.end188

if.then183:                                       ; preds = %land.lhs.true178
  %134 = load i64, ptr %arg3.addr, align 8
  %call184 = call ptr @lock_user(i32 noundef 3, i64 noundef %134, i64 noundef 128, i1 noundef zeroext false)
  store ptr %call184, ptr %p, align 8
  %tobool185 = icmp ne ptr %call184, null
  br i1 %tobool185, label %if.end187, label %if.then186

if.then186:                                       ; preds = %if.then183
  store i64 -14, ptr %retval, align 8
  br label %return

if.end187:                                        ; preds = %if.then183
  %135 = load ptr, ptr %p, align 8
  call void @host_to_target_siginfo(ptr noundef %135, ptr noundef %info)
  %136 = load ptr, ptr %p, align 8
  %137 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %136, i64 noundef %137, i64 noundef 128)
  br label %if.end188

if.end188:                                        ; preds = %if.end187, %land.lhs.true178, %land.lhs.true176, %sw.bb167
  %138 = load i64, ptr %ret, align 8
  store i64 %138, ptr %retval, align 8
  br label %return

sw.bb189:                                         ; preds = %entry
  store ptr null, ptr %p2, align 8
  %139 = load i64, ptr %arg2.addr, align 8
  %tobool190 = icmp ne i64 %139, 0
  br i1 %tobool190, label %lor.lhs.false, label %if.then192

lor.lhs.false:                                    ; preds = %sw.bb189
  %140 = load i64, ptr %arg4.addr, align 8
  %tobool191 = icmp ne i64 %140, 0
  br i1 %tobool191, label %if.end193, label %if.then192

if.then192:                                       ; preds = %lor.lhs.false, %sw.bb189
  store i64 -14, ptr %retval, align 8
  br label %return

if.end193:                                        ; preds = %lor.lhs.false
  %141 = load i64, ptr %arg2.addr, align 8
  %call194 = call ptr @lock_user_string(i64 noundef %141)
  store ptr %call194, ptr %p, align 8
  %142 = load i64, ptr %arg4.addr, align 8
  %call195 = call ptr @lock_user_string(i64 noundef %142)
  store ptr %call195, ptr %p2, align 8
  %143 = load ptr, ptr %p, align 8
  %tobool196 = icmp ne ptr %143, null
  br i1 %tobool196, label %lor.lhs.false197, label %if.then199

lor.lhs.false197:                                 ; preds = %if.end193
  %144 = load ptr, ptr %p2, align 8
  %tobool198 = icmp ne ptr %144, null
  br i1 %tobool198, label %if.else200, label %if.then199

if.then199:                                       ; preds = %lor.lhs.false197, %if.end193
  store i64 -14, ptr %ret, align 8
  br label %if.end207

if.else200:                                       ; preds = %lor.lhs.false197
  %145 = load i64, ptr %arg1.addr, align 8
  %conv201 = trunc i64 %145 to i32
  %146 = load ptr, ptr %p, align 8
  %147 = load i64, ptr %arg3.addr, align 8
  %conv202 = trunc i64 %147 to i32
  %148 = load ptr, ptr %p2, align 8
  %149 = load i64, ptr %arg5.addr, align 8
  %conv203 = trunc i64 %149 to i32
  %call204 = call i32 @linkat(i32 noundef %conv201, ptr noundef %146, i32 noundef %conv202, ptr noundef %148, i32 noundef %conv203) #14
  %conv205 = sext i32 %call204 to i64
  %call206 = call i64 @get_errno(i64 noundef %conv205)
  store i64 %call206, ptr %ret, align 8
  br label %if.end207

if.end207:                                        ; preds = %if.else200, %if.then199
  %150 = load ptr, ptr %p, align 8
  %151 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %150, i64 noundef %151, i64 noundef 0)
  %152 = load ptr, ptr %p2, align 8
  %153 = load i64, ptr %arg4.addr, align 8
  call void @unlock_user(ptr noundef %152, i64 noundef %153, i64 noundef 0)
  %154 = load i64, ptr %ret, align 8
  store i64 %154, ptr %retval, align 8
  br label %return

sw.bb208:                                         ; preds = %entry
  %155 = load i64, ptr %arg2.addr, align 8
  %call209 = call ptr @lock_user_string(i64 noundef %155)
  store ptr %call209, ptr %p, align 8
  %tobool210 = icmp ne ptr %call209, null
  br i1 %tobool210, label %if.end212, label %if.then211

if.then211:                                       ; preds = %sw.bb208
  store i64 -14, ptr %retval, align 8
  br label %return

if.end212:                                        ; preds = %sw.bb208
  %156 = load i64, ptr %arg1.addr, align 8
  %conv213 = trunc i64 %156 to i32
  %157 = load ptr, ptr %p, align 8
  %158 = load i64, ptr %arg3.addr, align 8
  %conv214 = trunc i64 %158 to i32
  %call215 = call i32 @unlinkat(i32 noundef %conv213, ptr noundef %157, i32 noundef %conv214) #14
  %conv216 = sext i32 %call215 to i64
  %call217 = call i64 @get_errno(i64 noundef %conv216)
  store i64 %call217, ptr %ret, align 8
  %159 = load ptr, ptr %p, align 8
  %160 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %159, i64 noundef %160, i64 noundef 0)
  %161 = load i64, ptr %ret, align 8
  store i64 %161, ptr %retval, align 8
  br label %return

sw.bb218:                                         ; preds = %entry
  %162 = load ptr, ptr %cpu_env.addr, align 8
  %163 = load i64, ptr %arg1.addr, align 8
  %conv219 = trunc i64 %163 to i32
  %164 = load i64, ptr %arg2.addr, align 8
  %165 = load i64, ptr %arg3.addr, align 8
  %166 = load i64, ptr %arg4.addr, align 8
  %167 = load i64, ptr %arg5.addr, align 8
  %conv220 = trunc i64 %167 to i32
  %call221 = call i32 @do_execv(ptr noundef %162, i32 noundef %conv219, i64 noundef %164, i64 noundef %165, i64 noundef %166, i32 noundef %conv220, i1 noundef zeroext true)
  %conv222 = sext i32 %call221 to i64
  store i64 %conv222, ptr %retval, align 8
  br label %return

sw.bb223:                                         ; preds = %entry
  %168 = load ptr, ptr %cpu_env.addr, align 8
  %169 = load i64, ptr %arg1.addr, align 8
  %170 = load i64, ptr %arg2.addr, align 8
  %171 = load i64, ptr %arg3.addr, align 8
  %call224 = call i32 @do_execv(ptr noundef %168, i32 noundef -100, i64 noundef %169, i64 noundef %170, i64 noundef %171, i32 noundef 0, i1 noundef zeroext false)
  %conv225 = sext i32 %call224 to i64
  store i64 %conv225, ptr %retval, align 8
  br label %return

sw.bb226:                                         ; preds = %entry
  %172 = load i64, ptr %arg1.addr, align 8
  %call227 = call ptr @lock_user_string(i64 noundef %172)
  store ptr %call227, ptr %p, align 8
  %tobool228 = icmp ne ptr %call227, null
  br i1 %tobool228, label %if.end230, label %if.then229

if.then229:                                       ; preds = %sw.bb226
  store i64 -14, ptr %retval, align 8
  br label %return

if.end230:                                        ; preds = %sw.bb226
  %173 = load ptr, ptr %p, align 8
  %call231 = call i32 @chdir(ptr noundef %173) #14
  %conv232 = sext i32 %call231 to i64
  %call233 = call i64 @get_errno(i64 noundef %conv232)
  store i64 %call233, ptr %ret, align 8
  %174 = load ptr, ptr %p, align 8
  %175 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %174, i64 noundef %175, i64 noundef 0)
  %176 = load i64, ptr %ret, align 8
  store i64 %176, ptr %retval, align 8
  br label %return

sw.bb234:                                         ; preds = %entry
  %177 = load i64, ptr %arg2.addr, align 8
  %call235 = call ptr @lock_user_string(i64 noundef %177)
  store ptr %call235, ptr %p, align 8
  %tobool236 = icmp ne ptr %call235, null
  br i1 %tobool236, label %if.end238, label %if.then237

if.then237:                                       ; preds = %sw.bb234
  store i64 -14, ptr %retval, align 8
  br label %return

if.end238:                                        ; preds = %sw.bb234
  %178 = load i64, ptr %arg1.addr, align 8
  %conv239 = trunc i64 %178 to i32
  %179 = load ptr, ptr %p, align 8
  %180 = load i64, ptr %arg3.addr, align 8
  %conv240 = trunc i64 %180 to i32
  %181 = load i64, ptr %arg4.addr, align 8
  %call241 = call i32 @mknodat(i32 noundef %conv239, ptr noundef %179, i32 noundef %conv240, i64 noundef %181) #14
  %conv242 = sext i32 %call241 to i64
  %call243 = call i64 @get_errno(i64 noundef %conv242)
  store i64 %call243, ptr %ret, align 8
  %182 = load ptr, ptr %p, align 8
  %183 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %182, i64 noundef %183, i64 noundef 0)
  %184 = load i64, ptr %ret, align 8
  store i64 %184, ptr %retval, align 8
  br label %return

sw.bb244:                                         ; preds = %entry
  %185 = load i64, ptr %arg1.addr, align 8
  %conv245 = trunc i64 %185 to i32
  %186 = load i64, ptr %arg2.addr, align 8
  %187 = load i64, ptr %arg3.addr, align 8
  %conv246 = trunc i64 %187 to i32
  %call247 = call i64 @lseek64(i32 noundef %conv245, i64 noundef %186, i32 noundef %conv246) #14
  %call248 = call i64 @get_errno(i64 noundef %call247)
  store i64 %call248, ptr %retval, align 8
  br label %return

sw.bb249:                                         ; preds = %entry
  %call250 = call i32 @getpid() #14
  %conv251 = sext i32 %call250 to i64
  %call252 = call i64 @get_errno(i64 noundef %conv251)
  store i64 %call252, ptr %retval, align 8
  br label %return

sw.bb253:                                         ; preds = %entry
  %188 = load i64, ptr %arg1.addr, align 8
  %tobool255 = icmp ne i64 %188, 0
  br i1 %tobool255, label %if.then256, label %if.else261

if.then256:                                       ; preds = %sw.bb253
  %189 = load i64, ptr %arg1.addr, align 8
  %call257 = call ptr @lock_user_string(i64 noundef %189)
  store ptr %call257, ptr %p, align 8
  %190 = load ptr, ptr %p, align 8
  %tobool258 = icmp ne ptr %190, null
  br i1 %tobool258, label %if.end260, label %if.then259

if.then259:                                       ; preds = %if.then256
  store i64 -14, ptr %retval, align 8
  br label %return

if.end260:                                        ; preds = %if.then256
  br label %if.end262

if.else261:                                       ; preds = %sw.bb253
  store ptr null, ptr %p, align 8
  br label %if.end262

if.end262:                                        ; preds = %if.else261, %if.end260
  %191 = load i64, ptr %arg2.addr, align 8
  %call263 = call ptr @lock_user_string(i64 noundef %191)
  store ptr %call263, ptr %p2254, align 8
  %192 = load ptr, ptr %p2254, align 8
  %tobool264 = icmp ne ptr %192, null
  br i1 %tobool264, label %if.end269, label %if.then265

if.then265:                                       ; preds = %if.end262
  %193 = load i64, ptr %arg1.addr, align 8
  %tobool266 = icmp ne i64 %193, 0
  br i1 %tobool266, label %if.then267, label %if.end268

if.then267:                                       ; preds = %if.then265
  %194 = load ptr, ptr %p, align 8
  %195 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %194, i64 noundef %195, i64 noundef 0)
  br label %if.end268

if.end268:                                        ; preds = %if.then267, %if.then265
  store i64 -14, ptr %retval, align 8
  br label %return

if.end269:                                        ; preds = %if.end262
  %196 = load i64, ptr %arg3.addr, align 8
  %tobool270 = icmp ne i64 %196, 0
  br i1 %tobool270, label %if.then271, label %if.else279

if.then271:                                       ; preds = %if.end269
  %197 = load i64, ptr %arg3.addr, align 8
  %call272 = call ptr @lock_user_string(i64 noundef %197)
  store ptr %call272, ptr %p3, align 8
  %198 = load ptr, ptr %p3, align 8
  %tobool273 = icmp ne ptr %198, null
  br i1 %tobool273, label %if.end278, label %if.then274

if.then274:                                       ; preds = %if.then271
  %199 = load i64, ptr %arg1.addr, align 8
  %tobool275 = icmp ne i64 %199, 0
  br i1 %tobool275, label %if.then276, label %if.end277

if.then276:                                       ; preds = %if.then274
  %200 = load ptr, ptr %p, align 8
  %201 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %200, i64 noundef %201, i64 noundef 0)
  br label %if.end277

if.end277:                                        ; preds = %if.then276, %if.then274
  %202 = load ptr, ptr %p2254, align 8
  %203 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %202, i64 noundef %203, i64 noundef 0)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end278:                                        ; preds = %if.then271
  br label %if.end280

if.else279:                                       ; preds = %if.end269
  store ptr null, ptr %p3, align 8
  br label %if.end280

if.end280:                                        ; preds = %if.else279, %if.end278
  %204 = load i64, ptr %arg5.addr, align 8
  %tobool281 = icmp ne i64 %204, 0
  br i1 %tobool281, label %if.else285, label %if.then282

if.then282:                                       ; preds = %if.end280
  %205 = load ptr, ptr %p, align 8
  %206 = load ptr, ptr %p2254, align 8
  %207 = load ptr, ptr %p3, align 8
  %208 = load i64, ptr %arg4.addr, align 8
  %call283 = call i32 @mount(ptr noundef %205, ptr noundef %206, ptr noundef %207, i64 noundef %208, ptr noundef null) #14
  %conv284 = sext i32 %call283 to i64
  store i64 %conv284, ptr %ret, align 8
  br label %if.end289

if.else285:                                       ; preds = %if.end280
  %209 = load ptr, ptr %p, align 8
  %210 = load ptr, ptr %p2254, align 8
  %211 = load ptr, ptr %p3, align 8
  %212 = load i64, ptr %arg4.addr, align 8
  %213 = load ptr, ptr %cpu, align 8
  %214 = load i64, ptr %arg5.addr, align 8
  %call286 = call ptr @g2h(ptr noundef %213, i64 noundef %214)
  %call287 = call i32 @mount(ptr noundef %209, ptr noundef %210, ptr noundef %211, i64 noundef %212, ptr noundef %call286) #14
  %conv288 = sext i32 %call287 to i64
  store i64 %conv288, ptr %ret, align 8
  br label %if.end289

if.end289:                                        ; preds = %if.else285, %if.then282
  %215 = load i64, ptr %ret, align 8
  %call290 = call i64 @get_errno(i64 noundef %215)
  store i64 %call290, ptr %ret, align 8
  %216 = load i64, ptr %arg1.addr, align 8
  %tobool291 = icmp ne i64 %216, 0
  br i1 %tobool291, label %if.then292, label %if.end293

if.then292:                                       ; preds = %if.end289
  %217 = load ptr, ptr %p, align 8
  %218 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %217, i64 noundef %218, i64 noundef 0)
  br label %if.end293

if.end293:                                        ; preds = %if.then292, %if.end289
  %219 = load ptr, ptr %p2254, align 8
  %220 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %219, i64 noundef %220, i64 noundef 0)
  %221 = load i64, ptr %arg3.addr, align 8
  %tobool294 = icmp ne i64 %221, 0
  br i1 %tobool294, label %if.then295, label %if.end296

if.then295:                                       ; preds = %if.end293
  %222 = load ptr, ptr %p3, align 8
  %223 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %222, i64 noundef %223, i64 noundef 0)
  br label %if.end296

if.end296:                                        ; preds = %if.then295, %if.end293
  %224 = load i64, ptr %ret, align 8
  store i64 %224, ptr %retval, align 8
  br label %return

sw.bb297:                                         ; preds = %entry
  %225 = load i64, ptr %arg2.addr, align 8
  %tobool299 = icmp ne i64 %225, 0
  br i1 %tobool299, label %lor.lhs.false300, label %if.then302

lor.lhs.false300:                                 ; preds = %sw.bb297
  %226 = load i64, ptr %arg4.addr, align 8
  %tobool301 = icmp ne i64 %226, 0
  br i1 %tobool301, label %if.end303, label %if.then302

if.then302:                                       ; preds = %lor.lhs.false300, %sw.bb297
  store i64 -14, ptr %retval, align 8
  br label %return

if.end303:                                        ; preds = %lor.lhs.false300
  %227 = load i64, ptr %arg2.addr, align 8
  %call304 = call ptr @lock_user_string(i64 noundef %227)
  store ptr %call304, ptr %p2298, align 8
  %228 = load ptr, ptr %p2298, align 8
  %tobool305 = icmp ne ptr %228, null
  br i1 %tobool305, label %if.end307, label %if.then306

if.then306:                                       ; preds = %if.end303
  store i64 -14, ptr %retval, align 8
  br label %return

if.end307:                                        ; preds = %if.end303
  %229 = load i64, ptr %arg4.addr, align 8
  %call308 = call ptr @lock_user_string(i64 noundef %229)
  store ptr %call308, ptr %p4, align 8
  %230 = load ptr, ptr %p4, align 8
  %tobool309 = icmp ne ptr %230, null
  br i1 %tobool309, label %if.end311, label %if.then310

if.then310:                                       ; preds = %if.end307
  %231 = load ptr, ptr %p2298, align 8
  %232 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %231, i64 noundef %232, i64 noundef 0)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end311:                                        ; preds = %if.end307
  %233 = load i64, ptr %arg1.addr, align 8
  %conv312 = trunc i64 %233 to i32
  %234 = load ptr, ptr %p2298, align 8
  %235 = load i64, ptr %arg3.addr, align 8
  %conv313 = trunc i64 %235 to i32
  %236 = load ptr, ptr %p4, align 8
  %237 = load i64, ptr %arg5.addr, align 8
  %conv314 = trunc i64 %237 to i32
  %call315 = call i32 @sys_move_mount(i32 noundef %conv312, ptr noundef %234, i32 noundef %conv313, ptr noundef %236, i32 noundef %conv314)
  %conv316 = sext i32 %call315 to i64
  %call317 = call i64 @get_errno(i64 noundef %conv316)
  store i64 %call317, ptr %ret, align 8
  %238 = load ptr, ptr %p2298, align 8
  %239 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %238, i64 noundef %239, i64 noundef 0)
  %240 = load ptr, ptr %p4, align 8
  %241 = load i64, ptr %arg4.addr, align 8
  call void @unlock_user(ptr noundef %240, i64 noundef %241, i64 noundef 0)
  %242 = load i64, ptr %ret, align 8
  store i64 %242, ptr %retval, align 8
  br label %return

sw.bb318:                                         ; preds = %entry
  %243 = load i64, ptr %arg2.addr, align 8
  %tobool320 = icmp ne i64 %243, 0
  br i1 %tobool320, label %if.end322, label %if.then321

if.then321:                                       ; preds = %sw.bb318
  store i64 -14, ptr %retval, align 8
  br label %return

if.end322:                                        ; preds = %sw.bb318
  %244 = load i64, ptr %arg2.addr, align 8
  %call323 = call ptr @lock_user_string(i64 noundef %244)
  store ptr %call323, ptr %p2319, align 8
  %245 = load ptr, ptr %p2319, align 8
  %tobool324 = icmp ne ptr %245, null
  br i1 %tobool324, label %if.end326, label %if.then325

if.then325:                                       ; preds = %if.end322
  store i64 -14, ptr %retval, align 8
  br label %return

if.end326:                                        ; preds = %if.end322
  %246 = load i64, ptr %arg3.addr, align 8
  %and327 = and i64 %246, -524289
  %conv328 = trunc i64 %and327 to i32
  store i32 %conv328, ptr %host_flags, align 4
  %247 = load i64, ptr %arg3.addr, align 8
  %and329 = and i64 %247, 524288
  %tobool330 = icmp ne i64 %and329, 0
  br i1 %tobool330, label %if.then331, label %if.end332

if.then331:                                       ; preds = %if.end326
  %248 = load i32, ptr %host_flags, align 4
  %or = or i32 %248, 524288
  store i32 %or, ptr %host_flags, align 4
  br label %if.end332

if.end332:                                        ; preds = %if.then331, %if.end326
  %249 = load i64, ptr %arg1.addr, align 8
  %conv333 = trunc i64 %249 to i32
  %250 = load ptr, ptr %p2319, align 8
  %251 = load i32, ptr %host_flags, align 4
  %call334 = call i32 @sys_open_tree(i32 noundef %conv333, ptr noundef %250, i32 noundef %251)
  %conv335 = sext i32 %call334 to i64
  %call336 = call i64 @get_errno(i64 noundef %conv335)
  store i64 %call336, ptr %ret, align 8
  %252 = load ptr, ptr %p2319, align 8
  %253 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %252, i64 noundef %253, i64 noundef 0)
  %254 = load i64, ptr %ret, align 8
  store i64 %254, ptr %retval, align 8
  br label %return

sw.bb337:                                         ; preds = %entry
  %255 = load i64, ptr %arg2.addr, align 8
  %call338 = call ptr @lock_user_string(i64 noundef %255)
  store ptr %call338, ptr %p, align 8
  %tobool339 = icmp ne ptr %call338, null
  br i1 %tobool339, label %if.end341, label %if.then340

if.then340:                                       ; preds = %sw.bb337
  store i64 -14, ptr %retval, align 8
  br label %return

if.end341:                                        ; preds = %sw.bb337
  %256 = load i64, ptr %arg1.addr, align 8
  %conv342 = trunc i64 %256 to i32
  %257 = load ptr, ptr %p, align 8
  %258 = load i64, ptr %arg3.addr, align 8
  %conv343 = trunc i64 %258 to i32
  %call344 = call i32 @faccessat(i32 noundef %conv342, ptr noundef %257, i32 noundef %conv343, i32 noundef 0) #14
  %conv345 = sext i32 %call344 to i64
  %call346 = call i64 @get_errno(i64 noundef %conv345)
  store i64 %call346, ptr %ret, align 8
  %259 = load ptr, ptr %p, align 8
  %260 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %259, i64 noundef %260, i64 noundef 0)
  %261 = load i64, ptr %ret, align 8
  store i64 %261, ptr %retval, align 8
  br label %return

sw.bb347:                                         ; preds = %entry
  %262 = load i64, ptr %arg2.addr, align 8
  %call348 = call ptr @lock_user_string(i64 noundef %262)
  store ptr %call348, ptr %p, align 8
  %tobool349 = icmp ne ptr %call348, null
  br i1 %tobool349, label %if.end351, label %if.then350

if.then350:                                       ; preds = %sw.bb347
  store i64 -14, ptr %retval, align 8
  br label %return

if.end351:                                        ; preds = %sw.bb347
  %263 = load i64, ptr %arg1.addr, align 8
  %conv352 = trunc i64 %263 to i32
  %264 = load ptr, ptr %p, align 8
  %265 = load i64, ptr %arg3.addr, align 8
  %conv353 = trunc i64 %265 to i32
  %266 = load i64, ptr %arg4.addr, align 8
  %conv354 = trunc i64 %266 to i32
  %call355 = call i32 @faccessat(i32 noundef %conv352, ptr noundef %264, i32 noundef %conv353, i32 noundef %conv354) #14
  %conv356 = sext i32 %call355 to i64
  %call357 = call i64 @get_errno(i64 noundef %conv356)
  store i64 %call357, ptr %ret, align 8
  %267 = load ptr, ptr %p, align 8
  %268 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %267, i64 noundef %268, i64 noundef 0)
  %269 = load i64, ptr %ret, align 8
  store i64 %269, ptr %retval, align 8
  br label %return

sw.bb358:                                         ; preds = %entry
  call void @sync() #14
  store i64 0, ptr %retval, align 8
  br label %return

sw.bb359:                                         ; preds = %entry
  %270 = load i64, ptr %arg1.addr, align 8
  %conv360 = trunc i64 %270 to i32
  %call361 = call i32 @syncfs(i32 noundef %conv360) #14
  %conv362 = sext i32 %call361 to i64
  %call363 = call i64 @get_errno(i64 noundef %conv362)
  store i64 %call363, ptr %retval, align 8
  br label %return

sw.bb364:                                         ; preds = %entry
  %271 = load i64, ptr %arg1.addr, align 8
  %conv365 = trunc i64 %271 to i32
  %272 = load i64, ptr %arg2.addr, align 8
  %conv366 = trunc i64 %272 to i32
  %call367 = call i32 @target_to_host_signal(i32 noundef %conv366)
  %call368 = call i32 @safe_kill(i32 noundef %conv365, i32 noundef %call367)
  %conv369 = sext i32 %call368 to i64
  %call370 = call i64 @get_errno(i64 noundef %conv369)
  store i64 %call370, ptr %retval, align 8
  br label %return

sw.bb371:                                         ; preds = %entry
  %273 = load i64, ptr %arg2.addr, align 8
  %call373 = call ptr @lock_user_string(i64 noundef %273)
  store ptr %call373, ptr %p, align 8
  %274 = load i64, ptr %arg4.addr, align 8
  %call374 = call ptr @lock_user_string(i64 noundef %274)
  store ptr %call374, ptr %p2372, align 8
  %275 = load ptr, ptr %p, align 8
  %tobool375 = icmp ne ptr %275, null
  br i1 %tobool375, label %lor.lhs.false376, label %if.then378

lor.lhs.false376:                                 ; preds = %sw.bb371
  %276 = load ptr, ptr %p2372, align 8
  %tobool377 = icmp ne ptr %276, null
  br i1 %tobool377, label %if.else379, label %if.then378

if.then378:                                       ; preds = %lor.lhs.false376, %sw.bb371
  store i64 -14, ptr %ret, align 8
  br label %if.end386

if.else379:                                       ; preds = %lor.lhs.false376
  %277 = load i64, ptr %arg1.addr, align 8
  %conv380 = trunc i64 %277 to i32
  %278 = load ptr, ptr %p, align 8
  %279 = load i64, ptr %arg3.addr, align 8
  %conv381 = trunc i64 %279 to i32
  %280 = load ptr, ptr %p2372, align 8
  %281 = load i64, ptr %arg5.addr, align 8
  %conv382 = trunc i64 %281 to i32
  %call383 = call i32 @sys_renameat2(i32 noundef %conv380, ptr noundef %278, i32 noundef %conv381, ptr noundef %280, i32 noundef %conv382)
  %conv384 = sext i32 %call383 to i64
  %call385 = call i64 @get_errno(i64 noundef %conv384)
  store i64 %call385, ptr %ret, align 8
  br label %if.end386

if.end386:                                        ; preds = %if.else379, %if.then378
  %282 = load ptr, ptr %p2372, align 8
  %283 = load i64, ptr %arg4.addr, align 8
  call void @unlock_user(ptr noundef %282, i64 noundef %283, i64 noundef 0)
  %284 = load ptr, ptr %p, align 8
  %285 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %284, i64 noundef %285, i64 noundef 0)
  %286 = load i64, ptr %ret, align 8
  store i64 %286, ptr %retval, align 8
  br label %return

sw.bb387:                                         ; preds = %entry
  %287 = load i64, ptr %arg2.addr, align 8
  %call388 = call ptr @lock_user_string(i64 noundef %287)
  store ptr %call388, ptr %p, align 8
  %tobool389 = icmp ne ptr %call388, null
  br i1 %tobool389, label %if.end391, label %if.then390

if.then390:                                       ; preds = %sw.bb387
  store i64 -14, ptr %retval, align 8
  br label %return

if.end391:                                        ; preds = %sw.bb387
  %288 = load i64, ptr %arg1.addr, align 8
  %conv392 = trunc i64 %288 to i32
  %289 = load ptr, ptr %p, align 8
  %290 = load i64, ptr %arg3.addr, align 8
  %conv393 = trunc i64 %290 to i32
  %call394 = call i32 @mkdirat(i32 noundef %conv392, ptr noundef %289, i32 noundef %conv393) #14
  %conv395 = sext i32 %call394 to i64
  %call396 = call i64 @get_errno(i64 noundef %conv395)
  store i64 %call396, ptr %ret, align 8
  %291 = load ptr, ptr %p, align 8
  %292 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %291, i64 noundef %292, i64 noundef 0)
  %293 = load i64, ptr %ret, align 8
  store i64 %293, ptr %retval, align 8
  br label %return

sw.bb397:                                         ; preds = %entry
  %294 = load i64, ptr %arg1.addr, align 8
  %conv398 = trunc i64 %294 to i32
  %call399 = call i32 @dup(i32 noundef %conv398) #14
  %conv400 = sext i32 %call399 to i64
  %call401 = call i64 @get_errno(i64 noundef %conv400)
  store i64 %call401, ptr %ret, align 8
  %295 = load i64, ptr %ret, align 8
  %cmp402 = icmp sge i64 %295, 0
  br i1 %cmp402, label %if.then404, label %if.end407

if.then404:                                       ; preds = %sw.bb397
  %296 = load i64, ptr %arg1.addr, align 8
  %conv405 = trunc i64 %296 to i32
  %297 = load i64, ptr %ret, align 8
  %conv406 = trunc i64 %297 to i32
  call void @fd_trans_dup(i32 noundef %conv405, i32 noundef %conv406)
  br label %if.end407

if.end407:                                        ; preds = %if.then404, %sw.bb397
  %298 = load i64, ptr %ret, align 8
  store i64 %298, ptr %retval, align 8
  br label %return

sw.bb408:                                         ; preds = %entry
  %299 = load ptr, ptr %cpu_env.addr, align 8
  %300 = load i64, ptr %arg1.addr, align 8
  %301 = load i64, ptr %arg2.addr, align 8
  %conv409 = trunc i64 %301 to i32
  %call410 = call i32 @target_to_host_bitmask_len(i32 noundef %conv409, ptr noundef @fcntl_flags_tbl, i64 noundef 19)
  %call411 = call i64 @do_pipe(ptr noundef %299, i64 noundef %300, i32 noundef %call410, i32 noundef 1)
  store i64 %call411, ptr %retval, align 8
  br label %return

sw.bb412:                                         ; preds = %entry
  %call413 = call i64 @times(ptr noundef %tms) #14
  %call414 = call i64 @get_errno(i64 noundef %call413)
  store i64 %call414, ptr %ret, align 8
  %302 = load i64, ptr %arg1.addr, align 8
  %tobool415 = icmp ne i64 %302, 0
  br i1 %tobool415, label %if.then416, label %if.end433

if.then416:                                       ; preds = %sw.bb412
  %303 = load i64, ptr %arg1.addr, align 8
  %call417 = call ptr @lock_user(i32 noundef 3, i64 noundef %303, i64 noundef 32, i1 noundef zeroext false)
  store ptr %call417, ptr %tmsp, align 8
  %304 = load ptr, ptr %tmsp, align 8
  %tobool418 = icmp ne ptr %304, null
  br i1 %tobool418, label %if.end420, label %if.then419

if.then419:                                       ; preds = %if.then416
  store i64 -14, ptr %retval, align 8
  br label %return

if.end420:                                        ; preds = %if.then416
  %tms_utime = getelementptr inbounds %struct.tms, ptr %tms, i32 0, i32 0
  %305 = load i64, ptr %tms_utime, align 8
  %call421 = call i64 @host_to_target_clock_t(i64 noundef %305)
  %call422 = call i64 @tswapal(i64 noundef %call421)
  %306 = load ptr, ptr %tmsp, align 8
  %tms_utime423 = getelementptr inbounds %struct.target_tms, ptr %306, i32 0, i32 0
  store i64 %call422, ptr %tms_utime423, align 8
  %tms_stime = getelementptr inbounds %struct.tms, ptr %tms, i32 0, i32 1
  %307 = load i64, ptr %tms_stime, align 8
  %call424 = call i64 @host_to_target_clock_t(i64 noundef %307)
  %call425 = call i64 @tswapal(i64 noundef %call424)
  %308 = load ptr, ptr %tmsp, align 8
  %tms_stime426 = getelementptr inbounds %struct.target_tms, ptr %308, i32 0, i32 1
  store i64 %call425, ptr %tms_stime426, align 8
  %tms_cutime = getelementptr inbounds %struct.tms, ptr %tms, i32 0, i32 2
  %309 = load i64, ptr %tms_cutime, align 8
  %call427 = call i64 @host_to_target_clock_t(i64 noundef %309)
  %call428 = call i64 @tswapal(i64 noundef %call427)
  %310 = load ptr, ptr %tmsp, align 8
  %tms_cutime429 = getelementptr inbounds %struct.target_tms, ptr %310, i32 0, i32 2
  store i64 %call428, ptr %tms_cutime429, align 8
  %tms_cstime = getelementptr inbounds %struct.tms, ptr %tms, i32 0, i32 3
  %311 = load i64, ptr %tms_cstime, align 8
  %call430 = call i64 @host_to_target_clock_t(i64 noundef %311)
  %call431 = call i64 @tswapal(i64 noundef %call430)
  %312 = load ptr, ptr %tmsp, align 8
  %tms_cstime432 = getelementptr inbounds %struct.target_tms, ptr %312, i32 0, i32 3
  store i64 %call431, ptr %tms_cstime432, align 8
  br label %if.end433

if.end433:                                        ; preds = %if.end420, %sw.bb412
  %313 = load i64, ptr %ret, align 8
  %call434 = call i32 @is_error(i64 noundef %313)
  %tobool435 = icmp ne i32 %call434, 0
  br i1 %tobool435, label %if.end438, label %if.then436

if.then436:                                       ; preds = %if.end433
  %314 = load i64, ptr %ret, align 8
  %call437 = call i64 @host_to_target_clock_t(i64 noundef %314)
  store i64 %call437, ptr %ret, align 8
  br label %if.end438

if.end438:                                        ; preds = %if.then436, %if.end433
  %315 = load i64, ptr %ret, align 8
  store i64 %315, ptr %retval, align 8
  br label %return

sw.bb439:                                         ; preds = %entry
  %316 = load i64, ptr %arg1.addr, align 8
  %cmp440 = icmp eq i64 %316, 0
  br i1 %cmp440, label %if.then442, label %if.else446

if.then442:                                       ; preds = %sw.bb439
  %call443 = call i32 @acct(ptr noundef null) #14
  %conv444 = sext i32 %call443 to i64
  %call445 = call i64 @get_errno(i64 noundef %conv444)
  store i64 %call445, ptr %ret, align 8
  br label %if.end455

if.else446:                                       ; preds = %sw.bb439
  %317 = load i64, ptr %arg1.addr, align 8
  %call447 = call ptr @lock_user_string(i64 noundef %317)
  store ptr %call447, ptr %p, align 8
  %tobool448 = icmp ne ptr %call447, null
  br i1 %tobool448, label %if.end450, label %if.then449

if.then449:                                       ; preds = %if.else446
  store i64 -14, ptr %retval, align 8
  br label %return

if.end450:                                        ; preds = %if.else446
  %318 = load ptr, ptr %p, align 8
  %call451 = call ptr @path(ptr noundef %318)
  %call452 = call i32 @acct(ptr noundef %call451) #14
  %conv453 = sext i32 %call452 to i64
  %call454 = call i64 @get_errno(i64 noundef %conv453)
  store i64 %call454, ptr %ret, align 8
  %319 = load ptr, ptr %p, align 8
  %320 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %319, i64 noundef %320, i64 noundef 0)
  br label %if.end455

if.end455:                                        ; preds = %if.end450, %if.then442
  %321 = load i64, ptr %ret, align 8
  store i64 %321, ptr %retval, align 8
  br label %return

sw.bb456:                                         ; preds = %entry
  %322 = load i64, ptr %arg1.addr, align 8
  %call457 = call ptr @lock_user_string(i64 noundef %322)
  store ptr %call457, ptr %p, align 8
  %tobool458 = icmp ne ptr %call457, null
  br i1 %tobool458, label %if.end460, label %if.then459

if.then459:                                       ; preds = %sw.bb456
  store i64 -14, ptr %retval, align 8
  br label %return

if.end460:                                        ; preds = %sw.bb456
  %323 = load ptr, ptr %p, align 8
  %324 = load i64, ptr %arg2.addr, align 8
  %conv461 = trunc i64 %324 to i32
  %call462 = call i32 @umount2(ptr noundef %323, i32 noundef %conv461) #14
  %conv463 = sext i32 %call462 to i64
  %call464 = call i64 @get_errno(i64 noundef %conv463)
  store i64 %call464, ptr %ret, align 8
  %325 = load ptr, ptr %p, align 8
  %326 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %325, i64 noundef %326, i64 noundef 0)
  %327 = load i64, ptr %ret, align 8
  store i64 %327, ptr %retval, align 8
  br label %return

sw.bb465:                                         ; preds = %entry
  %328 = load i64, ptr %arg1.addr, align 8
  %conv466 = trunc i64 %328 to i32
  %329 = load i64, ptr %arg2.addr, align 8
  %conv467 = trunc i64 %329 to i32
  %330 = load i64, ptr %arg3.addr, align 8
  %call468 = call i64 @do_ioctl(i32 noundef %conv466, i32 noundef %conv467, i64 noundef %330)
  store i64 %call468, ptr %retval, align 8
  br label %return

sw.bb469:                                         ; preds = %entry
  %331 = load i64, ptr %arg1.addr, align 8
  %conv470 = trunc i64 %331 to i32
  %332 = load i64, ptr %arg2.addr, align 8
  %conv471 = trunc i64 %332 to i32
  %333 = load i64, ptr %arg3.addr, align 8
  %call472 = call i64 @do_fcntl(i32 noundef %conv470, i32 noundef %conv471, i64 noundef %333)
  store i64 %call472, ptr %retval, align 8
  br label %return

sw.bb473:                                         ; preds = %entry
  %334 = load i64, ptr %arg1.addr, align 8
  %conv474 = trunc i64 %334 to i32
  %335 = load i64, ptr %arg2.addr, align 8
  %conv475 = trunc i64 %335 to i32
  %call476 = call i32 @setpgid(i32 noundef %conv474, i32 noundef %conv475) #14
  %conv477 = sext i32 %call476 to i64
  %call478 = call i64 @get_errno(i64 noundef %conv477)
  store i64 %call478, ptr %retval, align 8
  br label %return

sw.bb479:                                         ; preds = %entry
  %336 = load i64, ptr %arg1.addr, align 8
  %conv480 = trunc i64 %336 to i32
  %call481 = call i32 @umask(i32 noundef %conv480) #14
  %conv482 = zext i32 %call481 to i64
  %call483 = call i64 @get_errno(i64 noundef %conv482)
  store i64 %call483, ptr %retval, align 8
  br label %return

sw.bb484:                                         ; preds = %entry
  %337 = load i64, ptr %arg1.addr, align 8
  %call485 = call ptr @lock_user_string(i64 noundef %337)
  store ptr %call485, ptr %p, align 8
  %tobool486 = icmp ne ptr %call485, null
  br i1 %tobool486, label %if.end488, label %if.then487

if.then487:                                       ; preds = %sw.bb484
  store i64 -14, ptr %retval, align 8
  br label %return

if.end488:                                        ; preds = %sw.bb484
  %338 = load ptr, ptr %p, align 8
  %call489 = call i32 @chroot(ptr noundef %338) #14
  %conv490 = sext i32 %call489 to i64
  %call491 = call i64 @get_errno(i64 noundef %conv490)
  store i64 %call491, ptr %ret, align 8
  %339 = load ptr, ptr %p, align 8
  %340 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %339, i64 noundef %340, i64 noundef 0)
  %341 = load i64, ptr %ret, align 8
  store i64 %341, ptr %retval, align 8
  br label %return

sw.bb492:                                         ; preds = %entry
  %342 = load i64, ptr %arg3.addr, align 8
  %and494 = and i64 %342, -524289
  %cmp495 = icmp ne i64 %and494, 0
  br i1 %cmp495, label %if.then497, label %if.end498

if.then497:                                       ; preds = %sw.bb492
  store i64 -22, ptr %retval, align 8
  br label %return

if.end498:                                        ; preds = %sw.bb492
  %343 = load i64, ptr %arg3.addr, align 8
  %conv499 = trunc i64 %343 to i32
  %call500 = call i32 @target_to_host_bitmask_len(i32 noundef %conv499, ptr noundef @fcntl_flags_tbl, i64 noundef 19)
  store i32 %call500, ptr %host_flags493, align 4
  %344 = load i64, ptr %arg1.addr, align 8
  %conv501 = trunc i64 %344 to i32
  %345 = load i64, ptr %arg2.addr, align 8
  %conv502 = trunc i64 %345 to i32
  %346 = load i32, ptr %host_flags493, align 4
  %call503 = call i32 @dup3(i32 noundef %conv501, i32 noundef %conv502, i32 noundef %346) #14
  %conv504 = sext i32 %call503 to i64
  %call505 = call i64 @get_errno(i64 noundef %conv504)
  store i64 %call505, ptr %ret, align 8
  %347 = load i64, ptr %ret, align 8
  %cmp506 = icmp sge i64 %347, 0
  br i1 %cmp506, label %if.then508, label %if.end511

if.then508:                                       ; preds = %if.end498
  %348 = load i64, ptr %arg1.addr, align 8
  %conv509 = trunc i64 %348 to i32
  %349 = load i64, ptr %arg2.addr, align 8
  %conv510 = trunc i64 %349 to i32
  call void @fd_trans_dup(i32 noundef %conv509, i32 noundef %conv510)
  br label %if.end511

if.end511:                                        ; preds = %if.then508, %if.end498
  %350 = load i64, ptr %ret, align 8
  store i64 %350, ptr %retval, align 8
  br label %return

sw.bb512:                                         ; preds = %entry
  %call513 = call i32 @getppid() #14
  %conv514 = sext i32 %call513 to i64
  %call515 = call i64 @get_errno(i64 noundef %conv514)
  store i64 %call515, ptr %retval, align 8
  br label %return

sw.bb516:                                         ; preds = %entry
  %call517 = call i32 @setsid() #14
  %conv518 = sext i32 %call517 to i64
  %call519 = call i64 @get_errno(i64 noundef %conv518)
  store i64 %call519, ptr %retval, align 8
  br label %return

sw.bb520:                                         ; preds = %entry
  %351 = load i64, ptr %arg4.addr, align 8
  store i64 %351, ptr %sigsetsize, align 8
  store i64 0, ptr %restorer, align 8
  store ptr null, ptr %act, align 8
  store ptr null, ptr %oact, align 8
  %352 = load i64, ptr %sigsetsize, align 8
  %cmp521 = icmp ne i64 %352, 8
  br i1 %cmp521, label %if.then523, label %if.end524

if.then523:                                       ; preds = %sw.bb520
  store i64 -22, ptr %retval, align 8
  br label %return

if.end524:                                        ; preds = %sw.bb520
  %353 = load i64, ptr %arg2.addr, align 8
  %tobool525 = icmp ne i64 %353, 0
  br i1 %tobool525, label %land.lhs.true526, label %if.end530

land.lhs.true526:                                 ; preds = %if.end524
  %354 = load i64, ptr %arg2.addr, align 8
  %call527 = call ptr @lock_user(i32 noundef 1, i64 noundef %354, i64 noundef 32, i1 noundef zeroext true)
  store ptr %call527, ptr %act, align 8
  %tobool528 = icmp ne ptr %call527, null
  br i1 %tobool528, label %if.end530, label %if.then529

if.then529:                                       ; preds = %land.lhs.true526
  store i64 -14, ptr %retval, align 8
  br label %return

if.end530:                                        ; preds = %land.lhs.true526, %if.end524
  %355 = load i64, ptr %arg3.addr, align 8
  %tobool531 = icmp ne i64 %355, 0
  br i1 %tobool531, label %land.lhs.true532, label %if.else536

land.lhs.true532:                                 ; preds = %if.end530
  %356 = load i64, ptr %arg3.addr, align 8
  %call533 = call ptr @lock_user(i32 noundef 3, i64 noundef %356, i64 noundef 32, i1 noundef zeroext false)
  store ptr %call533, ptr %oact, align 8
  %tobool534 = icmp ne ptr %call533, null
  br i1 %tobool534, label %if.else536, label %if.then535

if.then535:                                       ; preds = %land.lhs.true532
  store i64 -14, ptr %ret, align 8
  br label %if.end544

if.else536:                                       ; preds = %land.lhs.true532, %if.end530
  %357 = load i64, ptr %arg1.addr, align 8
  %conv537 = trunc i64 %357 to i32
  %358 = load ptr, ptr %act, align 8
  %359 = load ptr, ptr %oact, align 8
  %360 = load i64, ptr %restorer, align 8
  %call538 = call i32 @do_sigaction(i32 noundef %conv537, ptr noundef %358, ptr noundef %359, i64 noundef %360)
  %conv539 = sext i32 %call538 to i64
  %call540 = call i64 @get_errno(i64 noundef %conv539)
  store i64 %call540, ptr %ret, align 8
  %361 = load ptr, ptr %oact, align 8
  %tobool541 = icmp ne ptr %361, null
  br i1 %tobool541, label %if.then542, label %if.end543

if.then542:                                       ; preds = %if.else536
  %362 = load ptr, ptr %oact, align 8
  %363 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %362, i64 noundef %363, i64 noundef 32)
  br label %if.end543

if.end543:                                        ; preds = %if.then542, %if.else536
  br label %if.end544

if.end544:                                        ; preds = %if.end543, %if.then535
  %364 = load ptr, ptr %act, align 8
  %tobool545 = icmp ne ptr %364, null
  br i1 %tobool545, label %if.then546, label %if.end547

if.then546:                                       ; preds = %if.end544
  %365 = load ptr, ptr %act, align 8
  %366 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %365, i64 noundef %366, i64 noundef 0)
  br label %if.end547

if.end547:                                        ; preds = %if.then546, %if.end544
  %367 = load i64, ptr %ret, align 8
  store i64 %367, ptr %retval, align 8
  br label %return

sw.bb548:                                         ; preds = %entry
  %368 = load i64, ptr %arg1.addr, align 8
  %conv549 = trunc i64 %368 to i32
  store i32 %conv549, ptr %how, align 4
  %369 = load i64, ptr %arg4.addr, align 8
  %cmp550 = icmp ne i64 %369, 8
  br i1 %cmp550, label %if.then552, label %if.end553

if.then552:                                       ; preds = %sw.bb548
  store i64 -22, ptr %retval, align 8
  br label %return

if.end553:                                        ; preds = %sw.bb548
  %370 = load i64, ptr %arg2.addr, align 8
  %tobool554 = icmp ne i64 %370, 0
  br i1 %tobool554, label %if.then555, label %if.else563

if.then555:                                       ; preds = %if.end553
  %371 = load i64, ptr %arg2.addr, align 8
  %call556 = call ptr @lock_user(i32 noundef 1, i64 noundef %371, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call556, ptr %p, align 8
  %372 = load ptr, ptr %p, align 8
  %tobool557 = icmp ne ptr %372, null
  br i1 %tobool557, label %if.end559, label %if.then558

if.then558:                                       ; preds = %if.then555
  store i64 -14, ptr %retval, align 8
  br label %return

if.end559:                                        ; preds = %if.then555
  %373 = load ptr, ptr %p, align 8
  call void @target_to_host_sigset(ptr noundef %set, ptr noundef %373)
  %374 = load ptr, ptr %p, align 8
  %375 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %374, i64 noundef %375, i64 noundef 0)
  store ptr %set, ptr %set_ptr, align 8
  %376 = load i32, ptr %how, align 4
  switch i32 %376, label %sw.default [
    i32 0, label %sw.bb560
    i32 1, label %sw.bb561
    i32 2, label %sw.bb562
  ]

sw.bb560:                                         ; preds = %if.end559
  store i32 0, ptr %how, align 4
  br label %sw.epilog

sw.bb561:                                         ; preds = %if.end559
  store i32 1, ptr %how, align 4
  br label %sw.epilog

sw.bb562:                                         ; preds = %if.end559
  store i32 2, ptr %how, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %if.end559
  store i64 -22, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %sw.bb562, %sw.bb561, %sw.bb560
  br label %if.end564

if.else563:                                       ; preds = %if.end553
  store i32 0, ptr %how, align 4
  store ptr null, ptr %set_ptr, align 8
  br label %if.end564

if.end564:                                        ; preds = %if.else563, %sw.epilog
  %377 = load i32, ptr %how, align 4
  %378 = load ptr, ptr %set_ptr, align 8
  %call565 = call i32 @do_sigprocmask(i32 noundef %377, ptr noundef %378, ptr noundef %oldset)
  %conv566 = sext i32 %call565 to i64
  store i64 %conv566, ptr %ret, align 8
  %379 = load i64, ptr %ret, align 8
  %call567 = call i32 @is_error(i64 noundef %379)
  %tobool568 = icmp ne i32 %call567, 0
  br i1 %tobool568, label %if.end576, label %land.lhs.true569

land.lhs.true569:                                 ; preds = %if.end564
  %380 = load i64, ptr %arg3.addr, align 8
  %tobool570 = icmp ne i64 %380, 0
  br i1 %tobool570, label %if.then571, label %if.end576

if.then571:                                       ; preds = %land.lhs.true569
  %381 = load i64, ptr %arg3.addr, align 8
  %call572 = call ptr @lock_user(i32 noundef 3, i64 noundef %381, i64 noundef 8, i1 noundef zeroext false)
  store ptr %call572, ptr %p, align 8
  %tobool573 = icmp ne ptr %call572, null
  br i1 %tobool573, label %if.end575, label %if.then574

if.then574:                                       ; preds = %if.then571
  store i64 -14, ptr %retval, align 8
  br label %return

if.end575:                                        ; preds = %if.then571
  %382 = load ptr, ptr %p, align 8
  call void @host_to_target_sigset(ptr noundef %382, ptr noundef %oldset)
  %383 = load ptr, ptr %p, align 8
  %384 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %383, i64 noundef %384, i64 noundef 8)
  br label %if.end576

if.end576:                                        ; preds = %if.end575, %land.lhs.true569, %if.end564
  %385 = load i64, ptr %ret, align 8
  store i64 %385, ptr %retval, align 8
  br label %return

sw.bb577:                                         ; preds = %entry
  %386 = load i64, ptr %arg2.addr, align 8
  %cmp579 = icmp ugt i64 %386, 8
  br i1 %cmp579, label %if.then581, label %if.end582

if.then581:                                       ; preds = %sw.bb577
  store i64 -22, ptr %retval, align 8
  br label %return

if.end582:                                        ; preds = %sw.bb577
  %call583 = call i32 @sigpending(ptr noundef %set578) #14
  %conv584 = sext i32 %call583 to i64
  %call585 = call i64 @get_errno(i64 noundef %conv584)
  store i64 %call585, ptr %ret, align 8
  %387 = load i64, ptr %ret, align 8
  %call586 = call i32 @is_error(i64 noundef %387)
  %tobool587 = icmp ne i32 %call586, 0
  br i1 %tobool587, label %if.end593, label %if.then588

if.then588:                                       ; preds = %if.end582
  %388 = load i64, ptr %arg1.addr, align 8
  %call589 = call ptr @lock_user(i32 noundef 3, i64 noundef %388, i64 noundef 8, i1 noundef zeroext false)
  store ptr %call589, ptr %p, align 8
  %tobool590 = icmp ne ptr %call589, null
  br i1 %tobool590, label %if.end592, label %if.then591

if.then591:                                       ; preds = %if.then588
  store i64 -14, ptr %retval, align 8
  br label %return

if.end592:                                        ; preds = %if.then588
  %389 = load ptr, ptr %p, align 8
  call void @host_to_target_sigset(ptr noundef %389, ptr noundef %set578)
  %390 = load ptr, ptr %p, align 8
  %391 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %390, i64 noundef %391, i64 noundef 8)
  br label %if.end593

if.end593:                                        ; preds = %if.end592, %if.end582
  %392 = load i64, ptr %ret, align 8
  store i64 %392, ptr %retval, align 8
  br label %return

sw.bb594:                                         ; preds = %entry
  %393 = load i64, ptr %arg1.addr, align 8
  %394 = load i64, ptr %arg2.addr, align 8
  %call596 = call i32 @process_sigsuspend_mask(ptr noundef %set595, i64 noundef %393, i64 noundef %394)
  %conv597 = sext i32 %call596 to i64
  store i64 %conv597, ptr %ret, align 8
  %395 = load i64, ptr %ret, align 8
  %cmp598 = icmp ne i64 %395, 0
  br i1 %cmp598, label %if.then600, label %if.end601

if.then600:                                       ; preds = %sw.bb594
  %396 = load i64, ptr %ret, align 8
  store i64 %396, ptr %retval, align 8
  br label %return

if.end601:                                        ; preds = %sw.bb594
  %397 = load ptr, ptr %set595, align 8
  %call602 = call i32 @safe_rt_sigsuspend(ptr noundef %397, i64 noundef 8)
  %conv603 = sext i32 %call602 to i64
  %call604 = call i64 @get_errno(i64 noundef %conv603)
  store i64 %call604, ptr %ret, align 8
  %398 = load i64, ptr %ret, align 8
  %conv605 = trunc i64 %398 to i32
  call void @finish_sigsuspend_mask(i32 noundef %conv605)
  %399 = load i64, ptr %ret, align 8
  store i64 %399, ptr %retval, align 8
  br label %return

sw.bb606:                                         ; preds = %entry
  %400 = load i64, ptr %arg4.addr, align 8
  %cmp609 = icmp ne i64 %400, 8
  br i1 %cmp609, label %if.then611, label %if.end612

if.then611:                                       ; preds = %sw.bb606
  store i64 -22, ptr %retval, align 8
  br label %return

if.end612:                                        ; preds = %sw.bb606
  %401 = load i64, ptr %arg1.addr, align 8
  %call613 = call ptr @lock_user(i32 noundef 1, i64 noundef %401, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call613, ptr %p, align 8
  %tobool614 = icmp ne ptr %call613, null
  br i1 %tobool614, label %if.end616, label %if.then615

if.then615:                                       ; preds = %if.end612
  store i64 -14, ptr %retval, align 8
  br label %return

if.end616:                                        ; preds = %if.end612
  %402 = load ptr, ptr %p, align 8
  call void @target_to_host_sigset(ptr noundef %set607, ptr noundef %402)
  %403 = load ptr, ptr %p, align 8
  %404 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %403, i64 noundef %404, i64 noundef 0)
  %405 = load i64, ptr %arg3.addr, align 8
  %tobool617 = icmp ne i64 %405, 0
  br i1 %tobool617, label %if.then618, label %if.else623

if.then618:                                       ; preds = %if.end616
  store ptr %uts, ptr %puts, align 8
  %406 = load ptr, ptr %puts, align 8
  %407 = load i64, ptr %arg3.addr, align 8
  %call619 = call i64 @target_to_host_timespec(ptr noundef %406, i64 noundef %407)
  %tobool620 = icmp ne i64 %call619, 0
  br i1 %tobool620, label %if.then621, label %if.end622

if.then621:                                       ; preds = %if.then618
  store i64 -14, ptr %retval, align 8
  br label %return

if.end622:                                        ; preds = %if.then618
  br label %if.end624

if.else623:                                       ; preds = %if.end616
  store ptr null, ptr %puts, align 8
  br label %if.end624

if.end624:                                        ; preds = %if.else623, %if.end622
  %408 = load ptr, ptr %puts, align 8
  %call625 = call i32 @safe_rt_sigtimedwait(ptr noundef %set607, ptr noundef %uinfo608, ptr noundef %408, i64 noundef 8)
  %conv626 = sext i32 %call625 to i64
  %call627 = call i64 @get_errno(i64 noundef %conv626)
  store i64 %call627, ptr %ret, align 8
  %409 = load i64, ptr %ret, align 8
  %call628 = call i32 @is_error(i64 noundef %409)
  %tobool629 = icmp ne i32 %call628, 0
  br i1 %tobool629, label %if.end641, label %if.then630

if.then630:                                       ; preds = %if.end624
  %410 = load i64, ptr %arg2.addr, align 8
  %tobool631 = icmp ne i64 %410, 0
  br i1 %tobool631, label %if.then632, label %if.end637

if.then632:                                       ; preds = %if.then630
  %411 = load i64, ptr %arg2.addr, align 8
  %call633 = call ptr @lock_user(i32 noundef 3, i64 noundef %411, i64 noundef 128, i1 noundef zeroext false)
  store ptr %call633, ptr %p, align 8
  %412 = load ptr, ptr %p, align 8
  %tobool634 = icmp ne ptr %412, null
  br i1 %tobool634, label %if.end636, label %if.then635

if.then635:                                       ; preds = %if.then632
  store i64 -14, ptr %retval, align 8
  br label %return

if.end636:                                        ; preds = %if.then632
  %413 = load ptr, ptr %p, align 8
  call void @host_to_target_siginfo(ptr noundef %413, ptr noundef %uinfo608)
  %414 = load ptr, ptr %p, align 8
  %415 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %414, i64 noundef %415, i64 noundef 128)
  br label %if.end637

if.end637:                                        ; preds = %if.end636, %if.then630
  %416 = load i64, ptr %ret, align 8
  %conv638 = trunc i64 %416 to i32
  %call639 = call i32 @host_to_target_signal(i32 noundef %conv638)
  %conv640 = sext i32 %call639 to i64
  store i64 %conv640, ptr %ret, align 8
  br label %if.end641

if.end641:                                        ; preds = %if.end637, %if.end624
  %417 = load i64, ptr %ret, align 8
  store i64 %417, ptr %retval, align 8
  br label %return

sw.bb642:                                         ; preds = %entry
  %418 = load i64, ptr %arg3.addr, align 8
  %call644 = call ptr @lock_user(i32 noundef 1, i64 noundef %418, i64 noundef 128, i1 noundef zeroext true)
  store ptr %call644, ptr %p, align 8
  %419 = load ptr, ptr %p, align 8
  %tobool645 = icmp ne ptr %419, null
  br i1 %tobool645, label %if.end647, label %if.then646

if.then646:                                       ; preds = %sw.bb642
  store i64 -14, ptr %retval, align 8
  br label %return

if.end647:                                        ; preds = %sw.bb642
  %420 = load ptr, ptr %p, align 8
  call void @target_to_host_siginfo(ptr noundef %uinfo643, ptr noundef %420)
  %421 = load ptr, ptr %p, align 8
  %422 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %421, i64 noundef %422, i64 noundef 0)
  %423 = load i64, ptr %arg1.addr, align 8
  %conv648 = trunc i64 %423 to i32
  %424 = load i64, ptr %arg2.addr, align 8
  %conv649 = trunc i64 %424 to i32
  %call650 = call i32 @target_to_host_signal(i32 noundef %conv649)
  %call651 = call i32 @sys_rt_sigqueueinfo(i32 noundef %conv648, i32 noundef %call650, ptr noundef %uinfo643)
  %conv652 = sext i32 %call651 to i64
  %call653 = call i64 @get_errno(i64 noundef %conv652)
  store i64 %call653, ptr %ret, align 8
  %425 = load i64, ptr %ret, align 8
  store i64 %425, ptr %retval, align 8
  br label %return

sw.bb654:                                         ; preds = %entry
  %426 = load i64, ptr %arg4.addr, align 8
  %call656 = call ptr @lock_user(i32 noundef 1, i64 noundef %426, i64 noundef 128, i1 noundef zeroext true)
  store ptr %call656, ptr %p, align 8
  %427 = load ptr, ptr %p, align 8
  %tobool657 = icmp ne ptr %427, null
  br i1 %tobool657, label %if.end659, label %if.then658

if.then658:                                       ; preds = %sw.bb654
  store i64 -14, ptr %retval, align 8
  br label %return

if.end659:                                        ; preds = %sw.bb654
  %428 = load ptr, ptr %p, align 8
  call void @target_to_host_siginfo(ptr noundef %uinfo655, ptr noundef %428)
  %429 = load ptr, ptr %p, align 8
  %430 = load i64, ptr %arg4.addr, align 8
  call void @unlock_user(ptr noundef %429, i64 noundef %430, i64 noundef 0)
  %431 = load i64, ptr %arg1.addr, align 8
  %conv660 = trunc i64 %431 to i32
  %432 = load i64, ptr %arg2.addr, align 8
  %conv661 = trunc i64 %432 to i32
  %433 = load i64, ptr %arg3.addr, align 8
  %conv662 = trunc i64 %433 to i32
  %call663 = call i32 @target_to_host_signal(i32 noundef %conv662)
  %call664 = call i32 @sys_rt_tgsigqueueinfo(i32 noundef %conv660, i32 noundef %conv661, i32 noundef %call663, ptr noundef %uinfo655)
  %conv665 = sext i32 %call664 to i64
  %call666 = call i64 @get_errno(i64 noundef %conv665)
  store i64 %call666, ptr %ret, align 8
  %434 = load i64, ptr %ret, align 8
  store i64 %434, ptr %retval, align 8
  br label %return

sw.bb667:                                         ; preds = %entry
  %call668 = call i32 @block_signals()
  %tobool669 = icmp ne i32 %call668, 0
  br i1 %tobool669, label %if.then670, label %if.end671

if.then670:                                       ; preds = %sw.bb667
  store i64 -512, ptr %retval, align 8
  br label %return

if.end671:                                        ; preds = %sw.bb667
  %435 = load ptr, ptr %cpu_env.addr, align 8
  %call672 = call i64 @do_rt_sigreturn(ptr noundef %435)
  store i64 %call672, ptr %retval, align 8
  br label %return

sw.bb673:                                         ; preds = %entry
  %436 = load i64, ptr %arg1.addr, align 8
  %call674 = call ptr @lock_user_string(i64 noundef %436)
  store ptr %call674, ptr %p, align 8
  %tobool675 = icmp ne ptr %call674, null
  br i1 %tobool675, label %if.end677, label %if.then676

if.then676:                                       ; preds = %sw.bb673
  store i64 -14, ptr %retval, align 8
  br label %return

if.end677:                                        ; preds = %sw.bb673
  %437 = load ptr, ptr %p, align 8
  %438 = load i64, ptr %arg2.addr, align 8
  %call678 = call i32 @sethostname(ptr noundef %437, i64 noundef %438) #14
  %conv679 = sext i32 %call678 to i64
  %call680 = call i64 @get_errno(i64 noundef %conv679)
  store i64 %call680, ptr %ret, align 8
  %439 = load ptr, ptr %p, align 8
  %440 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %439, i64 noundef %440, i64 noundef 0)
  %441 = load i64, ptr %ret, align 8
  store i64 %441, ptr %retval, align 8
  br label %return

sw.bb681:                                         ; preds = %entry
  %442 = load i64, ptr %arg1.addr, align 8
  %conv682 = trunc i64 %442 to i32
  %call683 = call i32 @target_to_host_resource(i32 noundef %conv682)
  store i32 %call683, ptr %resource, align 4
  %443 = load i64, ptr %arg2.addr, align 8
  %call684 = call ptr @lock_user(i32 noundef 1, i64 noundef %443, i64 noundef 16, i1 noundef zeroext true)
  store ptr %call684, ptr %target_rlim, align 8
  %tobool685 = icmp ne ptr %call684, null
  br i1 %tobool685, label %if.end687, label %if.then686

if.then686:                                       ; preds = %sw.bb681
  store i64 -14, ptr %retval, align 8
  br label %return

if.end687:                                        ; preds = %sw.bb681
  %444 = load ptr, ptr %target_rlim, align 8
  %rlim_cur = getelementptr inbounds %struct.target_rlimit, ptr %444, i32 0, i32 0
  %445 = load i64, ptr %rlim_cur, align 8
  %call688 = call i64 @target_to_host_rlim(i64 noundef %445)
  %rlim_cur689 = getelementptr inbounds %struct.rlimit, ptr %rlim, i32 0, i32 0
  store i64 %call688, ptr %rlim_cur689, align 8
  %446 = load ptr, ptr %target_rlim, align 8
  %rlim_max = getelementptr inbounds %struct.target_rlimit, ptr %446, i32 0, i32 1
  %447 = load i64, ptr %rlim_max, align 8
  %call690 = call i64 @target_to_host_rlim(i64 noundef %447)
  %rlim_max691 = getelementptr inbounds %struct.rlimit, ptr %rlim, i32 0, i32 1
  store i64 %call690, ptr %rlim_max691, align 8
  %448 = load ptr, ptr %target_rlim, align 8
  %449 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %448, i64 noundef %449, i64 noundef 0)
  %450 = load i32, ptr %resource, align 4
  %cmp692 = icmp ne i32 %450, 9
  br i1 %cmp692, label %land.lhs.true694, label %if.else704

land.lhs.true694:                                 ; preds = %if.end687
  %451 = load i32, ptr %resource, align 4
  %cmp695 = icmp ne i32 %451, 2
  br i1 %cmp695, label %land.lhs.true697, label %if.else704

land.lhs.true697:                                 ; preds = %land.lhs.true694
  %452 = load i32, ptr %resource, align 4
  %cmp698 = icmp ne i32 %452, 3
  br i1 %cmp698, label %if.then700, label %if.else704

if.then700:                                       ; preds = %land.lhs.true697
  %453 = load i32, ptr %resource, align 4
  %call701 = call i32 @setrlimit64(i32 noundef %453, ptr noundef %rlim) #14
  %conv702 = sext i32 %call701 to i64
  %call703 = call i64 @get_errno(i64 noundef %conv702)
  store i64 %call703, ptr %retval, align 8
  br label %return

if.else704:                                       ; preds = %land.lhs.true697, %land.lhs.true694, %if.end687
  store i64 0, ptr %retval, align 8
  br label %return

sw.bb705:                                         ; preds = %entry
  %454 = load i64, ptr %arg1.addr, align 8
  %conv707 = trunc i64 %454 to i32
  %call708 = call i32 @target_to_host_resource(i32 noundef %conv707)
  store i32 %call708, ptr %resource706, align 4
  %455 = load i32, ptr %resource706, align 4
  %call711 = call i32 @getrlimit64(i32 noundef %455, ptr noundef %rlim710) #14
  %conv712 = sext i32 %call711 to i64
  %call713 = call i64 @get_errno(i64 noundef %conv712)
  store i64 %call713, ptr %ret, align 8
  %456 = load i64, ptr %ret, align 8
  %call714 = call i32 @is_error(i64 noundef %456)
  %tobool715 = icmp ne i32 %call714, 0
  br i1 %tobool715, label %if.end727, label %if.then716

if.then716:                                       ; preds = %sw.bb705
  %457 = load i64, ptr %arg2.addr, align 8
  %call717 = call ptr @lock_user(i32 noundef 3, i64 noundef %457, i64 noundef 16, i1 noundef zeroext false)
  store ptr %call717, ptr %target_rlim709, align 8
  %tobool718 = icmp ne ptr %call717, null
  br i1 %tobool718, label %if.end720, label %if.then719

if.then719:                                       ; preds = %if.then716
  store i64 -14, ptr %retval, align 8
  br label %return

if.end720:                                        ; preds = %if.then716
  %rlim_cur721 = getelementptr inbounds %struct.rlimit, ptr %rlim710, i32 0, i32 0
  %458 = load i64, ptr %rlim_cur721, align 8
  %call722 = call i64 @host_to_target_rlim(i64 noundef %458)
  %459 = load ptr, ptr %target_rlim709, align 8
  %rlim_cur723 = getelementptr inbounds %struct.target_rlimit, ptr %459, i32 0, i32 0
  store i64 %call722, ptr %rlim_cur723, align 8
  %rlim_max724 = getelementptr inbounds %struct.rlimit, ptr %rlim710, i32 0, i32 1
  %460 = load i64, ptr %rlim_max724, align 8
  %call725 = call i64 @host_to_target_rlim(i64 noundef %460)
  %461 = load ptr, ptr %target_rlim709, align 8
  %rlim_max726 = getelementptr inbounds %struct.target_rlimit, ptr %461, i32 0, i32 1
  store i64 %call725, ptr %rlim_max726, align 8
  %462 = load ptr, ptr %target_rlim709, align 8
  %463 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %462, i64 noundef %463, i64 noundef 16)
  br label %if.end727

if.end727:                                        ; preds = %if.end720, %sw.bb705
  %464 = load i64, ptr %ret, align 8
  store i64 %464, ptr %retval, align 8
  br label %return

sw.bb728:                                         ; preds = %entry
  %465 = load i64, ptr %arg1.addr, align 8
  %conv729 = trunc i64 %465 to i32
  %call730 = call i32 @getrusage(i32 noundef %conv729, ptr noundef %rusage) #14
  %conv731 = sext i32 %call730 to i64
  %call732 = call i64 @get_errno(i64 noundef %conv731)
  store i64 %call732, ptr %ret, align 8
  %466 = load i64, ptr %ret, align 8
  %call733 = call i32 @is_error(i64 noundef %466)
  %tobool734 = icmp ne i32 %call733, 0
  br i1 %tobool734, label %if.end737, label %if.then735

if.then735:                                       ; preds = %sw.bb728
  %467 = load i64, ptr %arg2.addr, align 8
  %call736 = call i64 @host_to_target_rusage(i64 noundef %467, ptr noundef %rusage)
  store i64 %call736, ptr %ret, align 8
  br label %if.end737

if.end737:                                        ; preds = %if.then735, %sw.bb728
  %468 = load i64, ptr %ret, align 8
  store i64 %468, ptr %retval, align 8
  br label %return

sw.bb738:                                         ; preds = %entry
  %call739 = call i32 @gettimeofday(ptr noundef %tv, ptr noundef %tz) #14
  %conv740 = sext i32 %call739 to i64
  %call741 = call i64 @get_errno(i64 noundef %conv740)
  store i64 %call741, ptr %ret, align 8
  %469 = load i64, ptr %ret, align 8
  %call742 = call i32 @is_error(i64 noundef %469)
  %tobool743 = icmp ne i32 %call742, 0
  br i1 %tobool743, label %if.end757, label %if.then744

if.then744:                                       ; preds = %sw.bb738
  %470 = load i64, ptr %arg1.addr, align 8
  %tobool745 = icmp ne i64 %470, 0
  br i1 %tobool745, label %land.lhs.true746, label %if.end750

land.lhs.true746:                                 ; preds = %if.then744
  %471 = load i64, ptr %arg1.addr, align 8
  %call747 = call i64 @copy_to_user_timeval(i64 noundef %471, ptr noundef %tv)
  %tobool748 = icmp ne i64 %call747, 0
  br i1 %tobool748, label %if.then749, label %if.end750

if.then749:                                       ; preds = %land.lhs.true746
  store i64 -14, ptr %retval, align 8
  br label %return

if.end750:                                        ; preds = %land.lhs.true746, %if.then744
  %472 = load i64, ptr %arg2.addr, align 8
  %tobool751 = icmp ne i64 %472, 0
  br i1 %tobool751, label %land.lhs.true752, label %if.end756

land.lhs.true752:                                 ; preds = %if.end750
  %473 = load i64, ptr %arg2.addr, align 8
  %call753 = call i64 @copy_to_user_timezone(i64 noundef %473, ptr noundef %tz)
  %tobool754 = icmp ne i64 %call753, 0
  br i1 %tobool754, label %if.then755, label %if.end756

if.then755:                                       ; preds = %land.lhs.true752
  store i64 -14, ptr %retval, align 8
  br label %return

if.end756:                                        ; preds = %land.lhs.true752, %if.end750
  br label %if.end757

if.end757:                                        ; preds = %if.end756, %sw.bb738
  %474 = load i64, ptr %ret, align 8
  store i64 %474, ptr %retval, align 8
  br label %return

sw.bb758:                                         ; preds = %entry
  store ptr null, ptr %ptv, align 8
  store ptr null, ptr %ptz, align 8
  %475 = load i64, ptr %arg1.addr, align 8
  %tobool761 = icmp ne i64 %475, 0
  br i1 %tobool761, label %if.then762, label %if.end767

if.then762:                                       ; preds = %sw.bb758
  %476 = load i64, ptr %arg1.addr, align 8
  %call763 = call i64 @copy_from_user_timeval(ptr noundef %tv759, i64 noundef %476)
  %tobool764 = icmp ne i64 %call763, 0
  br i1 %tobool764, label %if.then765, label %if.end766

if.then765:                                       ; preds = %if.then762
  store i64 -14, ptr %retval, align 8
  br label %return

if.end766:                                        ; preds = %if.then762
  store ptr %tv759, ptr %ptv, align 8
  br label %if.end767

if.end767:                                        ; preds = %if.end766, %sw.bb758
  %477 = load i64, ptr %arg2.addr, align 8
  %tobool768 = icmp ne i64 %477, 0
  br i1 %tobool768, label %if.then769, label %if.end774

if.then769:                                       ; preds = %if.end767
  %478 = load i64, ptr %arg2.addr, align 8
  %call770 = call i64 @copy_from_user_timezone(ptr noundef %tz760, i64 noundef %478)
  %tobool771 = icmp ne i64 %call770, 0
  br i1 %tobool771, label %if.then772, label %if.end773

if.then772:                                       ; preds = %if.then769
  store i64 -14, ptr %retval, align 8
  br label %return

if.end773:                                        ; preds = %if.then769
  store ptr %tz760, ptr %ptz, align 8
  br label %if.end774

if.end774:                                        ; preds = %if.end773, %if.end767
  %479 = load ptr, ptr %ptv, align 8
  %480 = load ptr, ptr %ptz, align 8
  %call775 = call i32 @settimeofday(ptr noundef %479, ptr noundef %480) #14
  %conv776 = sext i32 %call775 to i64
  %call777 = call i64 @get_errno(i64 noundef %conv776)
  store i64 %call777, ptr %retval, align 8
  br label %return

sw.bb778:                                         ; preds = %entry
  %481 = load i64, ptr %arg1.addr, align 8
  %482 = load i64, ptr %arg2.addr, align 8
  %483 = load i64, ptr %arg3.addr, align 8
  %484 = load i64, ptr %arg4.addr, align 8
  %485 = load i64, ptr %arg5.addr, align 8
  %486 = load i64, ptr %arg6.addr, align 8
  %call779 = call i64 @do_pselect6(i64 noundef %481, i64 noundef %482, i64 noundef %483, i64 noundef %484, i64 noundef %485, i64 noundef %486, i1 noundef zeroext false)
  store i64 %call779, ptr %retval, align 8
  br label %return

sw.bb780:                                         ; preds = %entry
  %487 = load i64, ptr %arg1.addr, align 8
  %call782 = call ptr @lock_user_string(i64 noundef %487)
  store ptr %call782, ptr %p, align 8
  %488 = load i64, ptr %arg3.addr, align 8
  %call783 = call ptr @lock_user_string(i64 noundef %488)
  store ptr %call783, ptr %p2781, align 8
  %489 = load ptr, ptr %p, align 8
  %tobool784 = icmp ne ptr %489, null
  br i1 %tobool784, label %lor.lhs.false785, label %if.then787

lor.lhs.false785:                                 ; preds = %sw.bb780
  %490 = load ptr, ptr %p2781, align 8
  %tobool786 = icmp ne ptr %490, null
  br i1 %tobool786, label %if.else788, label %if.then787

if.then787:                                       ; preds = %lor.lhs.false785, %sw.bb780
  store i64 -14, ptr %ret, align 8
  br label %if.end793

if.else788:                                       ; preds = %lor.lhs.false785
  %491 = load ptr, ptr %p, align 8
  %492 = load i64, ptr %arg2.addr, align 8
  %conv789 = trunc i64 %492 to i32
  %493 = load ptr, ptr %p2781, align 8
  %call790 = call i32 @symlinkat(ptr noundef %491, i32 noundef %conv789, ptr noundef %493) #14
  %conv791 = sext i32 %call790 to i64
  %call792 = call i64 @get_errno(i64 noundef %conv791)
  store i64 %call792, ptr %ret, align 8
  br label %if.end793

if.end793:                                        ; preds = %if.else788, %if.then787
  %494 = load ptr, ptr %p2781, align 8
  %495 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %494, i64 noundef %495, i64 noundef 0)
  %496 = load ptr, ptr %p, align 8
  %497 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %496, i64 noundef %497, i64 noundef 0)
  %498 = load i64, ptr %ret, align 8
  store i64 %498, ptr %retval, align 8
  br label %return

sw.bb794:                                         ; preds = %entry
  %499 = load i64, ptr %arg2.addr, align 8
  %call796 = call ptr @lock_user_string(i64 noundef %499)
  store ptr %call796, ptr %p, align 8
  %500 = load i64, ptr %arg3.addr, align 8
  %501 = load i64, ptr %arg4.addr, align 8
  %call797 = call ptr @lock_user(i32 noundef 3, i64 noundef %500, i64 noundef %501, i1 noundef zeroext false)
  store ptr %call797, ptr %p2795, align 8
  %502 = load ptr, ptr %p, align 8
  %tobool798 = icmp ne ptr %502, null
  br i1 %tobool798, label %lor.lhs.false799, label %if.then801

lor.lhs.false799:                                 ; preds = %sw.bb794
  %503 = load ptr, ptr %p2795, align 8
  %tobool800 = icmp ne ptr %503, null
  br i1 %tobool800, label %if.else802, label %if.then801

if.then801:                                       ; preds = %lor.lhs.false799, %sw.bb794
  store i64 -14, ptr %ret, align 8
  br label %if.end824

if.else802:                                       ; preds = %lor.lhs.false799
  %504 = load i64, ptr %arg4.addr, align 8
  %tobool803 = icmp ne i64 %504, 0
  br i1 %tobool803, label %if.else805, label %if.then804

if.then804:                                       ; preds = %if.else802
  store i64 -22, ptr %ret, align 8
  br label %if.end823

if.else805:                                       ; preds = %if.else802
  %505 = load ptr, ptr %p, align 8
  %call806 = call i32 @is_proc_myself(ptr noundef %505, ptr noundef @.str.573)
  %tobool807 = icmp ne i32 %call806, 0
  br i1 %tobool807, label %if.then808, label %if.else817

if.then808:                                       ; preds = %if.else805
  %506 = load ptr, ptr @exec_path, align 8
  %call809 = call i64 @strlen(ptr noundef %506) #18
  store i64 %call809, ptr %_a28, align 8
  %507 = load i64, ptr %arg4.addr, align 8
  store i64 %507, ptr %_b29, align 8
  %508 = load i64, ptr %_a28, align 8
  %509 = load i64, ptr %_b29, align 8
  %cmp811 = icmp ult i64 %508, %509
  br i1 %cmp811, label %cond.true813, label %cond.false814

cond.true813:                                     ; preds = %if.then808
  %510 = load i64, ptr %_a28, align 8
  br label %cond.end815

cond.false814:                                    ; preds = %if.then808
  %511 = load i64, ptr %_b29, align 8
  br label %cond.end815

cond.end815:                                      ; preds = %cond.false814, %cond.true813
  %cond816 = phi i64 [ %510, %cond.true813 ], [ %511, %cond.false814 ]
  store i64 %cond816, ptr %tmp810, align 8
  %512 = load i64, ptr %tmp810, align 8
  store i64 %512, ptr %ret, align 8
  %513 = load ptr, ptr %p2795, align 8
  %514 = load ptr, ptr @exec_path, align 8
  %515 = load i64, ptr %ret, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %513, ptr align 1 %514, i64 %515, i1 false)
  br label %if.end822

if.else817:                                       ; preds = %if.else805
  %516 = load i64, ptr %arg1.addr, align 8
  %conv818 = trunc i64 %516 to i32
  %517 = load ptr, ptr %p, align 8
  %call819 = call ptr @path(ptr noundef %517)
  %518 = load ptr, ptr %p2795, align 8
  %519 = load i64, ptr %arg4.addr, align 8
  %call820 = call i64 @readlinkat(i32 noundef %conv818, ptr noundef %call819, ptr noundef %518, i64 noundef %519) #14
  %call821 = call i64 @get_errno(i64 noundef %call820)
  store i64 %call821, ptr %ret, align 8
  br label %if.end822

if.end822:                                        ; preds = %if.else817, %cond.end815
  br label %if.end823

if.end823:                                        ; preds = %if.end822, %if.then804
  br label %if.end824

if.end824:                                        ; preds = %if.end823, %if.then801
  %520 = load ptr, ptr %p2795, align 8
  %521 = load i64, ptr %arg3.addr, align 8
  %522 = load i64, ptr %ret, align 8
  call void @unlock_user(ptr noundef %520, i64 noundef %521, i64 noundef %522)
  %523 = load ptr, ptr %p, align 8
  %524 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %523, i64 noundef %524, i64 noundef 0)
  %525 = load i64, ptr %ret, align 8
  store i64 %525, ptr %retval, align 8
  br label %return

sw.bb825:                                         ; preds = %entry
  %526 = load i64, ptr %arg1.addr, align 8
  %call826 = call ptr @lock_user_string(i64 noundef %526)
  store ptr %call826, ptr %p, align 8
  %tobool827 = icmp ne ptr %call826, null
  br i1 %tobool827, label %if.end829, label %if.then828

if.then828:                                       ; preds = %sw.bb825
  store i64 -14, ptr %retval, align 8
  br label %return

if.end829:                                        ; preds = %sw.bb825
  %527 = load ptr, ptr %p, align 8
  %528 = load i64, ptr %arg2.addr, align 8
  %conv830 = trunc i64 %528 to i32
  %call831 = call i32 @swapon(ptr noundef %527, i32 noundef %conv830) #14
  %conv832 = sext i32 %call831 to i64
  %call833 = call i64 @get_errno(i64 noundef %conv832)
  store i64 %call833, ptr %ret, align 8
  %529 = load ptr, ptr %p, align 8
  %530 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %529, i64 noundef %530, i64 noundef 0)
  %531 = load i64, ptr %ret, align 8
  store i64 %531, ptr %retval, align 8
  br label %return

sw.bb834:                                         ; preds = %entry
  %532 = load i64, ptr %arg3.addr, align 8
  %cmp835 = icmp eq i64 %532, 2712847316
  br i1 %cmp835, label %if.then837, label %if.else848

if.then837:                                       ; preds = %sw.bb834
  %533 = load i64, ptr %arg4.addr, align 8
  %call838 = call ptr @lock_user_string(i64 noundef %533)
  store ptr %call838, ptr %p, align 8
  %534 = load ptr, ptr %p, align 8
  %tobool839 = icmp ne ptr %534, null
  br i1 %tobool839, label %if.end841, label %if.then840

if.then840:                                       ; preds = %if.then837
  store i64 -14, ptr %retval, align 8
  br label %return

if.end841:                                        ; preds = %if.then837
  %535 = load i64, ptr %arg1.addr, align 8
  %conv842 = trunc i64 %535 to i32
  %536 = load i64, ptr %arg2.addr, align 8
  %conv843 = trunc i64 %536 to i32
  %537 = load i64, ptr %arg3.addr, align 8
  %conv844 = trunc i64 %537 to i32
  %538 = load ptr, ptr %p, align 8
  %call845 = call i32 @reboot(i32 noundef %conv842, i32 noundef %conv843, i32 noundef %conv844, ptr noundef %538)
  %conv846 = sext i32 %call845 to i64
  %call847 = call i64 @get_errno(i64 noundef %conv846)
  store i64 %call847, ptr %ret, align 8
  %539 = load ptr, ptr %p, align 8
  %540 = load i64, ptr %arg4.addr, align 8
  call void @unlock_user(ptr noundef %539, i64 noundef %540, i64 noundef 0)
  br label %if.end855

if.else848:                                       ; preds = %sw.bb834
  %541 = load i64, ptr %arg1.addr, align 8
  %conv849 = trunc i64 %541 to i32
  %542 = load i64, ptr %arg2.addr, align 8
  %conv850 = trunc i64 %542 to i32
  %543 = load i64, ptr %arg3.addr, align 8
  %conv851 = trunc i64 %543 to i32
  %call852 = call i32 @reboot(i32 noundef %conv849, i32 noundef %conv850, i32 noundef %conv851, ptr noundef null)
  %conv853 = sext i32 %call852 to i64
  %call854 = call i64 @get_errno(i64 noundef %conv853)
  store i64 %call854, ptr %ret, align 8
  br label %if.end855

if.end855:                                        ; preds = %if.else848, %if.end841
  %544 = load i64, ptr %ret, align 8
  store i64 %544, ptr %retval, align 8
  br label %return

sw.bb856:                                         ; preds = %entry
  %545 = load i64, ptr %arg1.addr, align 8
  %546 = load i64, ptr %arg2.addr, align 8
  %547 = load i64, ptr %arg3.addr, align 8
  %conv857 = trunc i64 %547 to i32
  %548 = load i64, ptr %arg4.addr, align 8
  %conv858 = trunc i64 %548 to i32
  %549 = load i64, ptr %arg5.addr, align 8
  %conv859 = trunc i64 %549 to i32
  %550 = load i64, ptr %arg6.addr, align 8
  %call860 = call i64 @do_mmap(i64 noundef %545, i64 noundef %546, i32 noundef %conv857, i32 noundef %conv858, i32 noundef %conv859, i64 noundef %550)
  store i64 %call860, ptr %retval, align 8
  br label %return

sw.bb861:                                         ; preds = %entry
  %551 = load ptr, ptr %cpu, align 8
  %552 = load i64, ptr %arg1.addr, align 8
  %call862 = call i64 @cpu_untagged_addr(ptr noundef %551, i64 noundef %552)
  store i64 %call862, ptr %arg1.addr, align 8
  %553 = load i64, ptr %arg1.addr, align 8
  %554 = load i64, ptr %arg2.addr, align 8
  %call863 = call i32 @target_munmap(i64 noundef %553, i64 noundef %554)
  %conv864 = sext i32 %call863 to i64
  %call865 = call i64 @get_errno(i64 noundef %conv864)
  store i64 %call865, ptr %retval, align 8
  br label %return

sw.bb866:                                         ; preds = %entry
  %555 = load ptr, ptr %cpu, align 8
  %556 = load i64, ptr %arg1.addr, align 8
  %call867 = call i64 @cpu_untagged_addr(ptr noundef %555, i64 noundef %556)
  store i64 %call867, ptr %arg1.addr, align 8
  %557 = load ptr, ptr %cpu, align 8
  %opaque869 = getelementptr inbounds %struct.CPUState, ptr %557, i32 0, i32 39
  %558 = load ptr, ptr %opaque869, align 16
  store ptr %558, ptr %ts868, align 8
  %559 = load i64, ptr %arg3.addr, align 8
  %and870 = and i64 %559, 16777216
  %tobool871 = icmp ne i64 %and870, 0
  br i1 %tobool871, label %land.lhs.true872, label %if.end886

land.lhs.true872:                                 ; preds = %sw.bb866
  %560 = load i64, ptr %arg1.addr, align 8
  %561 = load ptr, ptr %ts868, align 8
  %info873 = getelementptr inbounds %struct.TaskState, ptr %561, i32 0, i32 7
  %562 = load ptr, ptr %info873, align 8
  %stack_limit = getelementptr inbounds %struct.image_info, ptr %562, i32 0, i32 8
  %563 = load i64, ptr %stack_limit, align 8
  %cmp874 = icmp uge i64 %560, %563
  br i1 %cmp874, label %land.lhs.true876, label %if.end886

land.lhs.true876:                                 ; preds = %land.lhs.true872
  %564 = load i64, ptr %arg1.addr, align 8
  %565 = load ptr, ptr %ts868, align 8
  %info877 = getelementptr inbounds %struct.TaskState, ptr %565, i32 0, i32 7
  %566 = load ptr, ptr %info877, align 8
  %start_stack = getelementptr inbounds %struct.image_info, ptr %566, i32 0, i32 7
  %567 = load i64, ptr %start_stack, align 8
  %cmp878 = icmp ule i64 %564, %567
  br i1 %cmp878, label %if.then880, label %if.end886

if.then880:                                       ; preds = %land.lhs.true876
  %568 = load i64, ptr %arg3.addr, align 8
  %and881 = and i64 %568, -16777217
  store i64 %and881, ptr %arg3.addr, align 8
  %569 = load i64, ptr %arg2.addr, align 8
  %570 = load i64, ptr %arg1.addr, align 8
  %add = add i64 %569, %570
  %571 = load ptr, ptr %ts868, align 8
  %info882 = getelementptr inbounds %struct.TaskState, ptr %571, i32 0, i32 7
  %572 = load ptr, ptr %info882, align 8
  %stack_limit883 = getelementptr inbounds %struct.image_info, ptr %572, i32 0, i32 8
  %573 = load i64, ptr %stack_limit883, align 8
  %sub = sub i64 %add, %573
  store i64 %sub, ptr %arg2.addr, align 8
  %574 = load ptr, ptr %ts868, align 8
  %info884 = getelementptr inbounds %struct.TaskState, ptr %574, i32 0, i32 7
  %575 = load ptr, ptr %info884, align 8
  %stack_limit885 = getelementptr inbounds %struct.image_info, ptr %575, i32 0, i32 8
  %576 = load i64, ptr %stack_limit885, align 8
  store i64 %576, ptr %arg1.addr, align 8
  br label %if.end886

if.end886:                                        ; preds = %if.then880, %land.lhs.true876, %land.lhs.true872, %sw.bb866
  %577 = load i64, ptr %arg1.addr, align 8
  %578 = load i64, ptr %arg2.addr, align 8
  %579 = load i64, ptr %arg3.addr, align 8
  %conv887 = trunc i64 %579 to i32
  %call888 = call i32 @target_mprotect(i64 noundef %577, i64 noundef %578, i32 noundef %conv887)
  %conv889 = sext i32 %call888 to i64
  %call890 = call i64 @get_errno(i64 noundef %conv889)
  store i64 %call890, ptr %retval, align 8
  br label %return

sw.bb891:                                         ; preds = %entry
  %580 = load ptr, ptr %cpu, align 8
  %581 = load i64, ptr %arg1.addr, align 8
  %call892 = call i64 @cpu_untagged_addr(ptr noundef %580, i64 noundef %581)
  store i64 %call892, ptr %arg1.addr, align 8
  %582 = load i64, ptr %arg1.addr, align 8
  %583 = load i64, ptr %arg2.addr, align 8
  %584 = load i64, ptr %arg3.addr, align 8
  %585 = load i64, ptr %arg4.addr, align 8
  %586 = load i64, ptr %arg5.addr, align 8
  %call893 = call i64 @target_mremap(i64 noundef %582, i64 noundef %583, i64 noundef %584, i64 noundef %585, i64 noundef %586)
  %call894 = call i64 @get_errno(i64 noundef %call893)
  store i64 %call894, ptr %retval, align 8
  br label %return

sw.bb895:                                         ; preds = %entry
  %587 = load ptr, ptr %cpu, align 8
  %588 = load i64, ptr %arg1.addr, align 8
  %call896 = call ptr @g2h(ptr noundef %587, i64 noundef %588)
  %589 = load i64, ptr %arg2.addr, align 8
  %590 = load i64, ptr %arg3.addr, align 8
  %call897 = call i32 @target_to_host_msync_arg(i64 noundef %590)
  %call898 = call i32 @msync(ptr noundef %call896, i64 noundef %589, i32 noundef %call897)
  %conv899 = sext i32 %call898 to i64
  %call900 = call i64 @get_errno(i64 noundef %conv899)
  store i64 %call900, ptr %retval, align 8
  br label %return

sw.bb901:                                         ; preds = %entry
  %591 = load ptr, ptr %cpu, align 8
  %592 = load i64, ptr %arg1.addr, align 8
  %call902 = call ptr @g2h(ptr noundef %591, i64 noundef %592)
  %593 = load i64, ptr %arg2.addr, align 8
  %call903 = call i32 @mlock(ptr noundef %call902, i64 noundef %593) #14
  %conv904 = sext i32 %call903 to i64
  %call905 = call i64 @get_errno(i64 noundef %conv904)
  store i64 %call905, ptr %retval, align 8
  br label %return

sw.bb906:                                         ; preds = %entry
  %594 = load ptr, ptr %cpu, align 8
  %595 = load i64, ptr %arg1.addr, align 8
  %call907 = call ptr @g2h(ptr noundef %594, i64 noundef %595)
  %596 = load i64, ptr %arg2.addr, align 8
  %call908 = call i32 @munlock(ptr noundef %call907, i64 noundef %596) #14
  %conv909 = sext i32 %call908 to i64
  %call910 = call i64 @get_errno(i64 noundef %conv909)
  store i64 %call910, ptr %retval, align 8
  br label %return

sw.bb911:                                         ; preds = %entry
  %597 = load i64, ptr %arg1.addr, align 8
  %conv912 = trunc i64 %597 to i32
  %call913 = call i32 @target_to_host_mlockall_arg(i32 noundef %conv912)
  %call914 = call i32 @mlockall(i32 noundef %call913) #14
  %conv915 = sext i32 %call914 to i64
  %call916 = call i64 @get_errno(i64 noundef %conv915)
  store i64 %call916, ptr %retval, align 8
  br label %return

sw.bb917:                                         ; preds = %entry
  %call918 = call i32 @munlockall() #14
  %conv919 = sext i32 %call918 to i64
  %call920 = call i64 @get_errno(i64 noundef %conv919)
  store i64 %call920, ptr %retval, align 8
  br label %return

sw.bb921:                                         ; preds = %entry
  %598 = load i64, ptr %arg1.addr, align 8
  %call922 = call ptr @lock_user_string(i64 noundef %598)
  store ptr %call922, ptr %p, align 8
  %tobool923 = icmp ne ptr %call922, null
  br i1 %tobool923, label %if.end925, label %if.then924

if.then924:                                       ; preds = %sw.bb921
  store i64 -14, ptr %retval, align 8
  br label %return

if.end925:                                        ; preds = %sw.bb921
  %599 = load ptr, ptr %p, align 8
  %600 = load i64, ptr %arg2.addr, align 8
  %call926 = call i32 @truncate64(ptr noundef %599, i64 noundef %600) #14
  %conv927 = sext i32 %call926 to i64
  %call928 = call i64 @get_errno(i64 noundef %conv927)
  store i64 %call928, ptr %ret, align 8
  %601 = load ptr, ptr %p, align 8
  %602 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %601, i64 noundef %602, i64 noundef 0)
  %603 = load i64, ptr %ret, align 8
  store i64 %603, ptr %retval, align 8
  br label %return

sw.bb929:                                         ; preds = %entry
  %604 = load i64, ptr %arg1.addr, align 8
  %conv930 = trunc i64 %604 to i32
  %605 = load i64, ptr %arg2.addr, align 8
  %call931 = call i32 @ftruncate64(i32 noundef %conv930, i64 noundef %605) #14
  %conv932 = sext i32 %call931 to i64
  %call933 = call i64 @get_errno(i64 noundef %conv932)
  store i64 %call933, ptr %retval, align 8
  br label %return

sw.bb934:                                         ; preds = %entry
  %606 = load i64, ptr %arg1.addr, align 8
  %conv935 = trunc i64 %606 to i32
  %607 = load i64, ptr %arg2.addr, align 8
  %conv936 = trunc i64 %607 to i32
  %call937 = call i32 @fchmod(i32 noundef %conv935, i32 noundef %conv936) #14
  %conv938 = sext i32 %call937 to i64
  %call939 = call i64 @get_errno(i64 noundef %conv938)
  store i64 %call939, ptr %retval, align 8
  br label %return

sw.bb940:                                         ; preds = %entry
  %608 = load i64, ptr %arg2.addr, align 8
  %call941 = call ptr @lock_user_string(i64 noundef %608)
  store ptr %call941, ptr %p, align 8
  %tobool942 = icmp ne ptr %call941, null
  br i1 %tobool942, label %if.end944, label %if.then943

if.then943:                                       ; preds = %sw.bb940
  store i64 -14, ptr %retval, align 8
  br label %return

if.end944:                                        ; preds = %sw.bb940
  %609 = load i64, ptr %arg1.addr, align 8
  %conv945 = trunc i64 %609 to i32
  %610 = load ptr, ptr %p, align 8
  %611 = load i64, ptr %arg3.addr, align 8
  %conv946 = trunc i64 %611 to i32
  %call947 = call i32 @fchmodat(i32 noundef %conv945, ptr noundef %610, i32 noundef %conv946, i32 noundef 0) #14
  %conv948 = sext i32 %call947 to i64
  %call949 = call i64 @get_errno(i64 noundef %conv948)
  store i64 %call949, ptr %ret, align 8
  %612 = load ptr, ptr %p, align 8
  %613 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %612, i64 noundef %613, i64 noundef 0)
  %614 = load i64, ptr %ret, align 8
  store i64 %614, ptr %retval, align 8
  br label %return

sw.bb950:                                         ; preds = %entry
  %call951 = call ptr @__errno_location() #13
  store i32 0, ptr %call951, align 4
  %615 = load i64, ptr %arg1.addr, align 8
  %conv952 = trunc i64 %615 to i32
  %616 = load i64, ptr %arg2.addr, align 8
  %conv953 = trunc i64 %616 to i32
  %call954 = call i32 @getpriority(i32 noundef %conv952, i32 noundef %conv953) #14
  %conv955 = sext i32 %call954 to i64
  store i64 %conv955, ptr %ret, align 8
  %617 = load i64, ptr %ret, align 8
  %cmp956 = icmp eq i64 %617, -1
  br i1 %cmp956, label %land.lhs.true958, label %if.end967

land.lhs.true958:                                 ; preds = %sw.bb950
  %call959 = call ptr @__errno_location() #13
  %618 = load i32, ptr %call959, align 4
  %cmp960 = icmp ne i32 %618, 0
  br i1 %cmp960, label %if.then962, label %if.end967

if.then962:                                       ; preds = %land.lhs.true958
  %call963 = call ptr @__errno_location() #13
  %619 = load i32, ptr %call963, align 4
  %call964 = call i32 @host_to_target_errno(i32 noundef %619)
  %sub965 = sub i32 0, %call964
  %conv966 = sext i32 %sub965 to i64
  store i64 %conv966, ptr %retval, align 8
  br label %return

if.end967:                                        ; preds = %land.lhs.true958, %sw.bb950
  %620 = load i64, ptr %ret, align 8
  %sub968 = sub i64 20, %620
  store i64 %sub968, ptr %ret, align 8
  %621 = load i64, ptr %ret, align 8
  store i64 %621, ptr %retval, align 8
  br label %return

sw.bb969:                                         ; preds = %entry
  %622 = load i64, ptr %arg1.addr, align 8
  %conv970 = trunc i64 %622 to i32
  %623 = load i64, ptr %arg2.addr, align 8
  %conv971 = trunc i64 %623 to i32
  %624 = load i64, ptr %arg3.addr, align 8
  %conv972 = trunc i64 %624 to i32
  %call973 = call i32 @setpriority(i32 noundef %conv970, i32 noundef %conv971, i32 noundef %conv972) #14
  %conv974 = sext i32 %call973 to i64
  %call975 = call i64 @get_errno(i64 noundef %conv974)
  store i64 %call975, ptr %retval, align 8
  br label %return

sw.bb976:                                         ; preds = %entry
  %625 = load i64, ptr %arg1.addr, align 8
  %call977 = call ptr @lock_user_string(i64 noundef %625)
  store ptr %call977, ptr %p, align 8
  %tobool978 = icmp ne ptr %call977, null
  br i1 %tobool978, label %if.end980, label %if.then979

if.then979:                                       ; preds = %sw.bb976
  store i64 -14, ptr %retval, align 8
  br label %return

if.end980:                                        ; preds = %sw.bb976
  %626 = load ptr, ptr %p, align 8
  %call981 = call ptr @path(ptr noundef %626)
  %call982 = call i32 @statfs64(ptr noundef %call981, ptr noundef %stfs) #14
  %conv983 = sext i32 %call982 to i64
  %call984 = call i64 @get_errno(i64 noundef %conv983)
  store i64 %call984, ptr %ret, align 8
  %627 = load ptr, ptr %p, align 8
  %628 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %627, i64 noundef %628, i64 noundef 0)
  br label %convert_statfs

convert_statfs:                                   ; preds = %sw.bb1035, %if.end980
  %629 = load i64, ptr %ret, align 8
  %call985 = call i32 @is_error(i64 noundef %629)
  %tobool986 = icmp ne i32 %call985, 0
  br i1 %tobool986, label %if.end1034, label %if.then987

if.then987:                                       ; preds = %convert_statfs
  %630 = load i64, ptr %arg2.addr, align 8
  %call988 = call ptr @lock_user(i32 noundef 3, i64 noundef %630, i64 noundef 120, i1 noundef zeroext false)
  store ptr %call988, ptr %target_stfs, align 8
  %tobool989 = icmp ne ptr %call988, null
  br i1 %tobool989, label %if.end991, label %if.then990

if.then990:                                       ; preds = %if.then987
  store i64 -14, ptr %retval, align 8
  br label %return

if.end991:                                        ; preds = %if.then987
  br label %do.body992

do.body992:                                       ; preds = %if.end991
  %631 = load ptr, ptr %target_stfs, align 8
  %f_type = getelementptr inbounds %struct.target_statfs, ptr %631, i32 0, i32 0
  %f_type993 = getelementptr inbounds %struct.statfs, ptr %stfs, i32 0, i32 0
  %632 = load i64, ptr %f_type993, align 8
  call void @stq_le_p(ptr noundef %f_type, i64 noundef %632)
  br label %do.end994

do.end994:                                        ; preds = %do.body992
  br label %do.body995

do.body995:                                       ; preds = %do.end994
  %633 = load ptr, ptr %target_stfs, align 8
  %f_bsize = getelementptr inbounds %struct.target_statfs, ptr %633, i32 0, i32 1
  %f_bsize996 = getelementptr inbounds %struct.statfs, ptr %stfs, i32 0, i32 1
  %634 = load i64, ptr %f_bsize996, align 8
  call void @stq_le_p(ptr noundef %f_bsize, i64 noundef %634)
  br label %do.end997

do.end997:                                        ; preds = %do.body995
  br label %do.body998

do.body998:                                       ; preds = %do.end997
  %635 = load ptr, ptr %target_stfs, align 8
  %f_blocks = getelementptr inbounds %struct.target_statfs, ptr %635, i32 0, i32 2
  %f_blocks999 = getelementptr inbounds %struct.statfs, ptr %stfs, i32 0, i32 2
  %636 = load i64, ptr %f_blocks999, align 8
  call void @stq_le_p(ptr noundef %f_blocks, i64 noundef %636)
  br label %do.end1000

do.end1000:                                       ; preds = %do.body998
  br label %do.body1001

do.body1001:                                      ; preds = %do.end1000
  %637 = load ptr, ptr %target_stfs, align 8
  %f_bfree = getelementptr inbounds %struct.target_statfs, ptr %637, i32 0, i32 3
  %f_bfree1002 = getelementptr inbounds %struct.statfs, ptr %stfs, i32 0, i32 3
  %638 = load i64, ptr %f_bfree1002, align 8
  call void @stq_le_p(ptr noundef %f_bfree, i64 noundef %638)
  br label %do.end1003

do.end1003:                                       ; preds = %do.body1001
  br label %do.body1004

do.body1004:                                      ; preds = %do.end1003
  %639 = load ptr, ptr %target_stfs, align 8
  %f_bavail = getelementptr inbounds %struct.target_statfs, ptr %639, i32 0, i32 4
  %f_bavail1005 = getelementptr inbounds %struct.statfs, ptr %stfs, i32 0, i32 4
  %640 = load i64, ptr %f_bavail1005, align 8
  call void @stq_le_p(ptr noundef %f_bavail, i64 noundef %640)
  br label %do.end1006

do.end1006:                                       ; preds = %do.body1004
  br label %do.body1007

do.body1007:                                      ; preds = %do.end1006
  %641 = load ptr, ptr %target_stfs, align 8
  %f_files = getelementptr inbounds %struct.target_statfs, ptr %641, i32 0, i32 5
  %f_files1008 = getelementptr inbounds %struct.statfs, ptr %stfs, i32 0, i32 5
  %642 = load i64, ptr %f_files1008, align 8
  call void @stq_le_p(ptr noundef %f_files, i64 noundef %642)
  br label %do.end1009

do.end1009:                                       ; preds = %do.body1007
  br label %do.body1010

do.body1010:                                      ; preds = %do.end1009
  %643 = load ptr, ptr %target_stfs, align 8
  %f_ffree = getelementptr inbounds %struct.target_statfs, ptr %643, i32 0, i32 6
  %f_ffree1011 = getelementptr inbounds %struct.statfs, ptr %stfs, i32 0, i32 6
  %644 = load i64, ptr %f_ffree1011, align 8
  call void @stq_le_p(ptr noundef %f_ffree, i64 noundef %644)
  br label %do.end1012

do.end1012:                                       ; preds = %do.body1010
  br label %do.body1013

do.body1013:                                      ; preds = %do.end1012
  %645 = load ptr, ptr %target_stfs, align 8
  %f_fsid = getelementptr inbounds %struct.target_statfs, ptr %645, i32 0, i32 7
  %val = getelementptr inbounds %struct.target_fsid_t, ptr %f_fsid, i32 0, i32 0
  %arrayidx = getelementptr [2 x i32], ptr %val, i64 0, i64 0
  %f_fsid1014 = getelementptr inbounds %struct.statfs, ptr %stfs, i32 0, i32 7
  %__val = getelementptr inbounds %struct.__fsid_t, ptr %f_fsid1014, i32 0, i32 0
  %arrayidx1015 = getelementptr [2 x i32], ptr %__val, i64 0, i64 0
  %646 = load i32, ptr %arrayidx1015, align 8
  call void @stl_le_p(ptr noundef %arrayidx, i32 noundef %646)
  br label %do.end1016

do.end1016:                                       ; preds = %do.body1013
  br label %do.body1017

do.body1017:                                      ; preds = %do.end1016
  %647 = load ptr, ptr %target_stfs, align 8
  %f_fsid1018 = getelementptr inbounds %struct.target_statfs, ptr %647, i32 0, i32 7
  %val1019 = getelementptr inbounds %struct.target_fsid_t, ptr %f_fsid1018, i32 0, i32 0
  %arrayidx1020 = getelementptr [2 x i32], ptr %val1019, i64 0, i64 1
  %f_fsid1021 = getelementptr inbounds %struct.statfs, ptr %stfs, i32 0, i32 7
  %__val1022 = getelementptr inbounds %struct.__fsid_t, ptr %f_fsid1021, i32 0, i32 0
  %arrayidx1023 = getelementptr [2 x i32], ptr %__val1022, i64 0, i64 1
  %648 = load i32, ptr %arrayidx1023, align 4
  call void @stl_le_p(ptr noundef %arrayidx1020, i32 noundef %648)
  br label %do.end1024

do.end1024:                                       ; preds = %do.body1017
  br label %do.body1025

do.body1025:                                      ; preds = %do.end1024
  %649 = load ptr, ptr %target_stfs, align 8
  %f_namelen = getelementptr inbounds %struct.target_statfs, ptr %649, i32 0, i32 8
  %f_namelen1026 = getelementptr inbounds %struct.statfs, ptr %stfs, i32 0, i32 8
  %650 = load i64, ptr %f_namelen1026, align 8
  call void @stq_le_p(ptr noundef %f_namelen, i64 noundef %650)
  br label %do.end1027

do.end1027:                                       ; preds = %do.body1025
  br label %do.body1028

do.body1028:                                      ; preds = %do.end1027
  %651 = load ptr, ptr %target_stfs, align 8
  %f_frsize = getelementptr inbounds %struct.target_statfs, ptr %651, i32 0, i32 9
  %f_frsize1029 = getelementptr inbounds %struct.statfs, ptr %stfs, i32 0, i32 9
  %652 = load i64, ptr %f_frsize1029, align 8
  call void @stq_le_p(ptr noundef %f_frsize, i64 noundef %652)
  br label %do.end1030

do.end1030:                                       ; preds = %do.body1028
  br label %do.body1031

do.body1031:                                      ; preds = %do.end1030
  %653 = load ptr, ptr %target_stfs, align 8
  %f_flags = getelementptr inbounds %struct.target_statfs, ptr %653, i32 0, i32 10
  %f_flags1032 = getelementptr inbounds %struct.statfs, ptr %stfs, i32 0, i32 10
  %654 = load i64, ptr %f_flags1032, align 8
  call void @stq_le_p(ptr noundef %f_flags, i64 noundef %654)
  br label %do.end1033

do.end1033:                                       ; preds = %do.body1031
  %655 = load ptr, ptr %target_stfs, align 8
  %f_spare = getelementptr inbounds %struct.target_statfs, ptr %655, i32 0, i32 11
  %arraydecay = getelementptr inbounds [4 x i64], ptr %f_spare, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay, i8 0, i64 32, i1 false)
  %656 = load ptr, ptr %target_stfs, align 8
  %657 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %656, i64 noundef %657, i64 noundef 120)
  br label %if.end1034

if.end1034:                                       ; preds = %do.end1033, %convert_statfs
  %658 = load i64, ptr %ret, align 8
  store i64 %658, ptr %retval, align 8
  br label %return

sw.bb1035:                                        ; preds = %entry
  %659 = load i64, ptr %arg1.addr, align 8
  %conv1036 = trunc i64 %659 to i32
  %call1037 = call i32 @fstatfs64(i32 noundef %conv1036, ptr noundef %stfs) #14
  %conv1038 = sext i32 %call1037 to i64
  %call1039 = call i64 @get_errno(i64 noundef %conv1038)
  store i64 %call1039, ptr %ret, align 8
  br label %convert_statfs

sw.bb1040:                                        ; preds = %entry
  %660 = load i64, ptr %arg1.addr, align 8
  %conv1041 = trunc i64 %660 to i32
  %661 = load i64, ptr %arg2.addr, align 8
  %662 = load i64, ptr %arg3.addr, align 8
  %call1042 = call i64 @do_accept4(i32 noundef %conv1041, i64 noundef %661, i64 noundef %662, i32 noundef 0)
  store i64 %call1042, ptr %retval, align 8
  br label %return

sw.bb1043:                                        ; preds = %entry
  %663 = load i64, ptr %arg1.addr, align 8
  %conv1044 = trunc i64 %663 to i32
  %664 = load i64, ptr %arg2.addr, align 8
  %665 = load i64, ptr %arg3.addr, align 8
  %666 = load i64, ptr %arg4.addr, align 8
  %conv1045 = trunc i64 %666 to i32
  %call1046 = call i64 @do_accept4(i32 noundef %conv1044, i64 noundef %664, i64 noundef %665, i32 noundef %conv1045)
  store i64 %call1046, ptr %retval, align 8
  br label %return

sw.bb1047:                                        ; preds = %entry
  %667 = load i64, ptr %arg1.addr, align 8
  %conv1048 = trunc i64 %667 to i32
  %668 = load i64, ptr %arg2.addr, align 8
  %669 = load i64, ptr %arg3.addr, align 8
  %conv1049 = trunc i64 %669 to i32
  %call1050 = call i64 @do_bind(i32 noundef %conv1048, i64 noundef %668, i32 noundef %conv1049)
  store i64 %call1050, ptr %retval, align 8
  br label %return

sw.bb1051:                                        ; preds = %entry
  %670 = load i64, ptr %arg1.addr, align 8
  %conv1052 = trunc i64 %670 to i32
  %671 = load i64, ptr %arg2.addr, align 8
  %672 = load i64, ptr %arg3.addr, align 8
  %conv1053 = trunc i64 %672 to i32
  %call1054 = call i64 @do_connect(i32 noundef %conv1052, i64 noundef %671, i32 noundef %conv1053)
  store i64 %call1054, ptr %retval, align 8
  br label %return

sw.bb1055:                                        ; preds = %entry
  %673 = load i64, ptr %arg1.addr, align 8
  %conv1056 = trunc i64 %673 to i32
  %674 = load i64, ptr %arg2.addr, align 8
  %675 = load i64, ptr %arg3.addr, align 8
  %call1057 = call i64 @do_getpeername(i32 noundef %conv1056, i64 noundef %674, i64 noundef %675)
  store i64 %call1057, ptr %retval, align 8
  br label %return

sw.bb1058:                                        ; preds = %entry
  %676 = load i64, ptr %arg1.addr, align 8
  %conv1059 = trunc i64 %676 to i32
  %677 = load i64, ptr %arg2.addr, align 8
  %678 = load i64, ptr %arg3.addr, align 8
  %call1060 = call i64 @do_getsockname(i32 noundef %conv1059, i64 noundef %677, i64 noundef %678)
  store i64 %call1060, ptr %retval, align 8
  br label %return

sw.bb1061:                                        ; preds = %entry
  %679 = load i64, ptr %arg1.addr, align 8
  %conv1062 = trunc i64 %679 to i32
  %680 = load i64, ptr %arg2.addr, align 8
  %conv1063 = trunc i64 %680 to i32
  %681 = load i64, ptr %arg3.addr, align 8
  %conv1064 = trunc i64 %681 to i32
  %682 = load i64, ptr %arg4.addr, align 8
  %683 = load i64, ptr %arg5.addr, align 8
  %call1065 = call i64 @do_getsockopt(i32 noundef %conv1062, i32 noundef %conv1063, i32 noundef %conv1064, i64 noundef %682, i64 noundef %683)
  store i64 %call1065, ptr %retval, align 8
  br label %return

sw.bb1066:                                        ; preds = %entry
  %684 = load i64, ptr %arg1.addr, align 8
  %conv1067 = trunc i64 %684 to i32
  %685 = load i64, ptr %arg2.addr, align 8
  %conv1068 = trunc i64 %685 to i32
  %call1069 = call i32 @listen(i32 noundef %conv1067, i32 noundef %conv1068) #14
  %conv1070 = sext i32 %call1069 to i64
  %call1071 = call i64 @get_errno(i64 noundef %conv1070)
  store i64 %call1071, ptr %retval, align 8
  br label %return

sw.bb1072:                                        ; preds = %entry
  %686 = load i64, ptr %arg1.addr, align 8
  %conv1073 = trunc i64 %686 to i32
  %687 = load i64, ptr %arg2.addr, align 8
  %688 = load i64, ptr %arg3.addr, align 8
  %689 = load i64, ptr %arg4.addr, align 8
  %conv1074 = trunc i64 %689 to i32
  %690 = load i64, ptr %arg5.addr, align 8
  %691 = load i64, ptr %arg6.addr, align 8
  %call1075 = call i64 @do_recvfrom(i32 noundef %conv1073, i64 noundef %687, i64 noundef %688, i32 noundef %conv1074, i64 noundef %690, i64 noundef %691)
  store i64 %call1075, ptr %retval, align 8
  br label %return

sw.bb1076:                                        ; preds = %entry
  %692 = load i64, ptr %arg1.addr, align 8
  %conv1077 = trunc i64 %692 to i32
  %693 = load i64, ptr %arg2.addr, align 8
  %694 = load i64, ptr %arg3.addr, align 8
  %conv1078 = trunc i64 %694 to i32
  %call1079 = call i64 @do_sendrecvmsg(i32 noundef %conv1077, i64 noundef %693, i32 noundef %conv1078, i32 noundef 0)
  store i64 %call1079, ptr %retval, align 8
  br label %return

sw.bb1080:                                        ; preds = %entry
  %695 = load i64, ptr %arg1.addr, align 8
  %conv1081 = trunc i64 %695 to i32
  %696 = load i64, ptr %arg2.addr, align 8
  %697 = load i64, ptr %arg3.addr, align 8
  %conv1082 = trunc i64 %697 to i32
  %call1083 = call i64 @do_sendrecvmsg(i32 noundef %conv1081, i64 noundef %696, i32 noundef %conv1082, i32 noundef 1)
  store i64 %call1083, ptr %retval, align 8
  br label %return

sw.bb1084:                                        ; preds = %entry
  %698 = load i64, ptr %arg1.addr, align 8
  %conv1085 = trunc i64 %698 to i32
  %699 = load i64, ptr %arg2.addr, align 8
  %700 = load i64, ptr %arg3.addr, align 8
  %conv1086 = trunc i64 %700 to i32
  %701 = load i64, ptr %arg4.addr, align 8
  %conv1087 = trunc i64 %701 to i32
  %call1088 = call i64 @do_sendrecvmmsg(i32 noundef %conv1085, i64 noundef %699, i32 noundef %conv1086, i32 noundef %conv1087, i32 noundef 1)
  store i64 %call1088, ptr %retval, align 8
  br label %return

sw.bb1089:                                        ; preds = %entry
  %702 = load i64, ptr %arg1.addr, align 8
  %conv1090 = trunc i64 %702 to i32
  %703 = load i64, ptr %arg2.addr, align 8
  %704 = load i64, ptr %arg3.addr, align 8
  %conv1091 = trunc i64 %704 to i32
  %705 = load i64, ptr %arg4.addr, align 8
  %conv1092 = trunc i64 %705 to i32
  %call1093 = call i64 @do_sendrecvmmsg(i32 noundef %conv1090, i64 noundef %703, i32 noundef %conv1091, i32 noundef %conv1092, i32 noundef 0)
  store i64 %call1093, ptr %retval, align 8
  br label %return

sw.bb1094:                                        ; preds = %entry
  %706 = load i64, ptr %arg1.addr, align 8
  %conv1095 = trunc i64 %706 to i32
  %707 = load i64, ptr %arg2.addr, align 8
  %708 = load i64, ptr %arg3.addr, align 8
  %709 = load i64, ptr %arg4.addr, align 8
  %conv1096 = trunc i64 %709 to i32
  %710 = load i64, ptr %arg5.addr, align 8
  %711 = load i64, ptr %arg6.addr, align 8
  %conv1097 = trunc i64 %711 to i32
  %call1098 = call i64 @do_sendto(i32 noundef %conv1095, i64 noundef %707, i64 noundef %708, i32 noundef %conv1096, i64 noundef %710, i32 noundef %conv1097)
  store i64 %call1098, ptr %retval, align 8
  br label %return

sw.bb1099:                                        ; preds = %entry
  %712 = load i64, ptr %arg1.addr, align 8
  %conv1100 = trunc i64 %712 to i32
  %713 = load i64, ptr %arg2.addr, align 8
  %conv1101 = trunc i64 %713 to i32
  %call1102 = call i32 @shutdown(i32 noundef %conv1100, i32 noundef %conv1101) #14
  %conv1103 = sext i32 %call1102 to i64
  %call1104 = call i64 @get_errno(i64 noundef %conv1103)
  store i64 %call1104, ptr %retval, align 8
  br label %return

sw.bb1105:                                        ; preds = %entry
  %714 = load i64, ptr %arg1.addr, align 8
  %715 = load i64, ptr %arg2.addr, align 8
  %call1106 = call ptr @lock_user(i32 noundef 3, i64 noundef %714, i64 noundef %715, i1 noundef zeroext false)
  store ptr %call1106, ptr %p, align 8
  %716 = load ptr, ptr %p, align 8
  %tobool1107 = icmp ne ptr %716, null
  br i1 %tobool1107, label %if.end1109, label %if.then1108

if.then1108:                                      ; preds = %sw.bb1105
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1109:                                       ; preds = %sw.bb1105
  %717 = load ptr, ptr %p, align 8
  %718 = load i64, ptr %arg2.addr, align 8
  %719 = load i64, ptr %arg3.addr, align 8
  %conv1110 = trunc i64 %719 to i32
  %call1111 = call i32 @getrandom(ptr noundef %717, i64 noundef %718, i32 noundef %conv1110)
  %conv1112 = sext i32 %call1111 to i64
  %call1113 = call i64 @get_errno(i64 noundef %conv1112)
  store i64 %call1113, ptr %ret, align 8
  %720 = load ptr, ptr %p, align 8
  %721 = load i64, ptr %arg1.addr, align 8
  %722 = load i64, ptr %ret, align 8
  call void @unlock_user(ptr noundef %720, i64 noundef %721, i64 noundef %722)
  %723 = load i64, ptr %ret, align 8
  store i64 %723, ptr %retval, align 8
  br label %return

sw.bb1114:                                        ; preds = %entry
  %724 = load i64, ptr %arg1.addr, align 8
  %conv1115 = trunc i64 %724 to i32
  %725 = load i64, ptr %arg2.addr, align 8
  %conv1116 = trunc i64 %725 to i32
  %726 = load i64, ptr %arg3.addr, align 8
  %conv1117 = trunc i64 %726 to i32
  %call1118 = call i64 @do_socket(i32 noundef %conv1115, i32 noundef %conv1116, i32 noundef %conv1117)
  store i64 %call1118, ptr %retval, align 8
  br label %return

sw.bb1119:                                        ; preds = %entry
  %727 = load i64, ptr %arg1.addr, align 8
  %conv1120 = trunc i64 %727 to i32
  %728 = load i64, ptr %arg2.addr, align 8
  %conv1121 = trunc i64 %728 to i32
  %729 = load i64, ptr %arg3.addr, align 8
  %conv1122 = trunc i64 %729 to i32
  %730 = load i64, ptr %arg4.addr, align 8
  %call1123 = call i64 @do_socketpair(i32 noundef %conv1120, i32 noundef %conv1121, i32 noundef %conv1122, i64 noundef %730)
  store i64 %call1123, ptr %retval, align 8
  br label %return

sw.bb1124:                                        ; preds = %entry
  %731 = load i64, ptr %arg1.addr, align 8
  %conv1125 = trunc i64 %731 to i32
  %732 = load i64, ptr %arg2.addr, align 8
  %conv1126 = trunc i64 %732 to i32
  %733 = load i64, ptr %arg3.addr, align 8
  %conv1127 = trunc i64 %733 to i32
  %734 = load i64, ptr %arg4.addr, align 8
  %735 = load i64, ptr %arg5.addr, align 8
  %conv1128 = trunc i64 %735 to i32
  %call1129 = call i64 @do_setsockopt(i32 noundef %conv1125, i32 noundef %conv1126, i32 noundef %conv1127, i64 noundef %734, i32 noundef %conv1128)
  store i64 %call1129, ptr %retval, align 8
  br label %return

sw.bb1130:                                        ; preds = %entry
  %736 = load i64, ptr %arg2.addr, align 8
  %conv1131 = trunc i64 %736 to i32
  store i32 %conv1131, ptr %len, align 4
  %737 = load i64, ptr %arg1.addr, align 8
  switch i64 %737, label %sw.default1156 [
    i64 0, label %sw.bb1132
    i64 1, label %sw.bb1132
    i64 5, label %sw.bb1132
    i64 6, label %sw.bb1132
    i64 7, label %sw.bb1132
    i64 8, label %sw.bb1132
    i64 9, label %sw.bb1132
    i64 10, label %sw.bb1132
    i64 2, label %sw.bb1138
    i64 4, label %sw.bb1138
    i64 3, label %sw.bb1138
  ]

sw.bb1132:                                        ; preds = %sw.bb1130, %sw.bb1130, %sw.bb1130, %sw.bb1130, %sw.bb1130, %sw.bb1130, %sw.bb1130, %sw.bb1130
  %738 = load i64, ptr %arg1.addr, align 8
  %conv1133 = trunc i64 %738 to i32
  %739 = load i64, ptr %arg3.addr, align 8
  %conv1134 = trunc i64 %739 to i32
  %call1135 = call i32 @sys_syslog(i32 noundef %conv1133, ptr noundef null, i32 noundef %conv1134)
  %conv1136 = sext i32 %call1135 to i64
  %call1137 = call i64 @get_errno(i64 noundef %conv1136)
  store i64 %call1137, ptr %retval, align 8
  br label %return

sw.bb1138:                                        ; preds = %sw.bb1130, %sw.bb1130, %sw.bb1130
  %740 = load i32, ptr %len, align 4
  %cmp1139 = icmp slt i32 %740, 0
  br i1 %cmp1139, label %if.then1141, label %if.end1142

if.then1141:                                      ; preds = %sw.bb1138
  store i64 -22, ptr %retval, align 8
  br label %return

if.end1142:                                       ; preds = %sw.bb1138
  %741 = load i32, ptr %len, align 4
  %cmp1143 = icmp eq i32 %741, 0
  br i1 %cmp1143, label %if.then1145, label %if.end1146

if.then1145:                                      ; preds = %if.end1142
  store i64 0, ptr %retval, align 8
  br label %return

if.end1146:                                       ; preds = %if.end1142
  %742 = load i64, ptr %arg2.addr, align 8
  %743 = load i64, ptr %arg3.addr, align 8
  %call1147 = call ptr @lock_user(i32 noundef 3, i64 noundef %742, i64 noundef %743, i1 noundef zeroext false)
  store ptr %call1147, ptr %p, align 8
  %744 = load ptr, ptr %p, align 8
  %tobool1148 = icmp ne ptr %744, null
  br i1 %tobool1148, label %if.end1150, label %if.then1149

if.then1149:                                      ; preds = %if.end1146
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1150:                                       ; preds = %if.end1146
  %745 = load i64, ptr %arg1.addr, align 8
  %conv1151 = trunc i64 %745 to i32
  %746 = load ptr, ptr %p, align 8
  %747 = load i64, ptr %arg3.addr, align 8
  %conv1152 = trunc i64 %747 to i32
  %call1153 = call i32 @sys_syslog(i32 noundef %conv1151, ptr noundef %746, i32 noundef %conv1152)
  %conv1154 = sext i32 %call1153 to i64
  %call1155 = call i64 @get_errno(i64 noundef %conv1154)
  store i64 %call1155, ptr %ret, align 8
  %748 = load ptr, ptr %p, align 8
  %749 = load i64, ptr %arg2.addr, align 8
  %750 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %748, i64 noundef %749, i64 noundef %750)
  %751 = load i64, ptr %ret, align 8
  store i64 %751, ptr %retval, align 8
  br label %return

sw.default1156:                                   ; preds = %sw.bb1130
  store i64 -22, ptr %retval, align 8
  br label %return

sw.bb1157:                                        ; preds = %entry
  %752 = load i64, ptr %arg2.addr, align 8
  %tobool1158 = icmp ne i64 %752, 0
  br i1 %tobool1158, label %if.then1159, label %if.else1168

if.then1159:                                      ; preds = %sw.bb1157
  store ptr %value, ptr %pvalue, align 8
  %753 = load ptr, ptr %pvalue, align 8
  %it_interval = getelementptr inbounds %struct.itimerval, ptr %753, i32 0, i32 0
  %754 = load i64, ptr %arg2.addr, align 8
  %call1160 = call i64 @copy_from_user_timeval(ptr noundef %it_interval, i64 noundef %754)
  %tobool1161 = icmp ne i64 %call1160, 0
  br i1 %tobool1161, label %if.then1166, label %lor.lhs.false1162

lor.lhs.false1162:                                ; preds = %if.then1159
  %755 = load ptr, ptr %pvalue, align 8
  %it_value = getelementptr inbounds %struct.itimerval, ptr %755, i32 0, i32 1
  %756 = load i64, ptr %arg2.addr, align 8
  %add1163 = add i64 %756, 16
  %call1164 = call i64 @copy_from_user_timeval(ptr noundef %it_value, i64 noundef %add1163)
  %tobool1165 = icmp ne i64 %call1164, 0
  br i1 %tobool1165, label %if.then1166, label %if.end1167

if.then1166:                                      ; preds = %lor.lhs.false1162, %if.then1159
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1167:                                       ; preds = %lor.lhs.false1162
  br label %if.end1169

if.else1168:                                      ; preds = %sw.bb1157
  store ptr null, ptr %pvalue, align 8
  br label %if.end1169

if.end1169:                                       ; preds = %if.else1168, %if.end1167
  %757 = load i64, ptr %arg1.addr, align 8
  %conv1170 = trunc i64 %757 to i32
  %758 = load ptr, ptr %pvalue, align 8
  %call1171 = call i32 @setitimer(i32 noundef %conv1170, ptr noundef %758, ptr noundef %ovalue) #14
  %conv1172 = sext i32 %call1171 to i64
  %call1173 = call i64 @get_errno(i64 noundef %conv1172)
  store i64 %call1173, ptr %ret, align 8
  %759 = load i64, ptr %ret, align 8
  %call1174 = call i32 @is_error(i64 noundef %759)
  %tobool1175 = icmp ne i32 %call1174, 0
  br i1 %tobool1175, label %if.end1189, label %land.lhs.true1176

land.lhs.true1176:                                ; preds = %if.end1169
  %760 = load i64, ptr %arg3.addr, align 8
  %tobool1177 = icmp ne i64 %760, 0
  br i1 %tobool1177, label %if.then1178, label %if.end1189

if.then1178:                                      ; preds = %land.lhs.true1176
  %761 = load i64, ptr %arg3.addr, align 8
  %it_interval1179 = getelementptr inbounds %struct.itimerval, ptr %ovalue, i32 0, i32 0
  %call1180 = call i64 @copy_to_user_timeval(i64 noundef %761, ptr noundef %it_interval1179)
  %tobool1181 = icmp ne i64 %call1180, 0
  br i1 %tobool1181, label %if.then1187, label %lor.lhs.false1182

lor.lhs.false1182:                                ; preds = %if.then1178
  %762 = load i64, ptr %arg3.addr, align 8
  %add1183 = add i64 %762, 16
  %it_value1184 = getelementptr inbounds %struct.itimerval, ptr %ovalue, i32 0, i32 1
  %call1185 = call i64 @copy_to_user_timeval(i64 noundef %add1183, ptr noundef %it_value1184)
  %tobool1186 = icmp ne i64 %call1185, 0
  br i1 %tobool1186, label %if.then1187, label %if.end1188

if.then1187:                                      ; preds = %lor.lhs.false1182, %if.then1178
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1188:                                       ; preds = %lor.lhs.false1182
  br label %if.end1189

if.end1189:                                       ; preds = %if.end1188, %land.lhs.true1176, %if.end1169
  %763 = load i64, ptr %ret, align 8
  store i64 %763, ptr %retval, align 8
  br label %return

sw.bb1190:                                        ; preds = %entry
  %764 = load i64, ptr %arg1.addr, align 8
  %conv1192 = trunc i64 %764 to i32
  %call1193 = call i32 @getitimer(i32 noundef %conv1192, ptr noundef %value1191) #14
  %conv1194 = sext i32 %call1193 to i64
  %call1195 = call i64 @get_errno(i64 noundef %conv1194)
  store i64 %call1195, ptr %ret, align 8
  %765 = load i64, ptr %ret, align 8
  %call1196 = call i32 @is_error(i64 noundef %765)
  %tobool1197 = icmp ne i32 %call1196, 0
  br i1 %tobool1197, label %if.end1211, label %land.lhs.true1198

land.lhs.true1198:                                ; preds = %sw.bb1190
  %766 = load i64, ptr %arg2.addr, align 8
  %tobool1199 = icmp ne i64 %766, 0
  br i1 %tobool1199, label %if.then1200, label %if.end1211

if.then1200:                                      ; preds = %land.lhs.true1198
  %767 = load i64, ptr %arg2.addr, align 8
  %it_interval1201 = getelementptr inbounds %struct.itimerval, ptr %value1191, i32 0, i32 0
  %call1202 = call i64 @copy_to_user_timeval(i64 noundef %767, ptr noundef %it_interval1201)
  %tobool1203 = icmp ne i64 %call1202, 0
  br i1 %tobool1203, label %if.then1209, label %lor.lhs.false1204

lor.lhs.false1204:                                ; preds = %if.then1200
  %768 = load i64, ptr %arg2.addr, align 8
  %add1205 = add i64 %768, 16
  %it_value1206 = getelementptr inbounds %struct.itimerval, ptr %value1191, i32 0, i32 1
  %call1207 = call i64 @copy_to_user_timeval(i64 noundef %add1205, ptr noundef %it_value1206)
  %tobool1208 = icmp ne i64 %call1207, 0
  br i1 %tobool1208, label %if.then1209, label %if.end1210

if.then1209:                                      ; preds = %lor.lhs.false1204, %if.then1200
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1210:                                       ; preds = %lor.lhs.false1204
  br label %if.end1211

if.end1211:                                       ; preds = %if.end1210, %land.lhs.true1198, %sw.bb1190
  %769 = load i64, ptr %ret, align 8
  store i64 %769, ptr %retval, align 8
  br label %return

sw.bb1212:                                        ; preds = %entry
  %770 = load i64, ptr %arg1.addr, align 8
  %conv1213 = trunc i64 %770 to i32
  %call1214 = call i32 @fstat64(i32 noundef %conv1213, ptr noundef %st) #14
  %conv1215 = sext i32 %call1214 to i64
  %call1216 = call i64 @get_errno(i64 noundef %conv1215)
  store i64 %call1216, ptr %ret, align 8
  %771 = load i64, ptr %ret, align 8
  %call1217 = call i32 @is_error(i64 noundef %771)
  %tobool1218 = icmp ne i32 %call1217, 0
  br i1 %tobool1218, label %if.end1275, label %if.then1219

if.then1219:                                      ; preds = %sw.bb1212
  %772 = load i64, ptr %arg2.addr, align 8
  %call1220 = call ptr @lock_user(i32 noundef 3, i64 noundef %772, i64 noundef 128, i1 noundef zeroext false)
  store ptr %call1220, ptr %target_st, align 8
  %tobool1221 = icmp ne ptr %call1220, null
  br i1 %tobool1221, label %if.end1223, label %if.then1222

if.then1222:                                      ; preds = %if.then1219
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1223:                                       ; preds = %if.then1219
  %773 = load ptr, ptr %target_st, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %773, i8 0, i64 128, i1 false)
  br label %do.body1224

do.body1224:                                      ; preds = %if.end1223
  %774 = load ptr, ptr %target_st, align 8
  %st_dev = getelementptr inbounds %struct.target_stat, ptr %774, i32 0, i32 0
  %st_dev1225 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 0
  %775 = load i64, ptr %st_dev1225, align 8
  call void @stq_le_p(ptr noundef %st_dev, i64 noundef %775)
  br label %do.end1226

do.end1226:                                       ; preds = %do.body1224
  br label %do.body1227

do.body1227:                                      ; preds = %do.end1226
  %776 = load ptr, ptr %target_st, align 8
  %st_ino = getelementptr inbounds %struct.target_stat, ptr %776, i32 0, i32 1
  %st_ino1228 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 1
  %777 = load i64, ptr %st_ino1228, align 8
  call void @stq_le_p(ptr noundef %st_ino, i64 noundef %777)
  br label %do.end1229

do.end1229:                                       ; preds = %do.body1227
  br label %do.body1230

do.body1230:                                      ; preds = %do.end1229
  %778 = load ptr, ptr %target_st, align 8
  %st_mode = getelementptr inbounds %struct.target_stat, ptr %778, i32 0, i32 2
  %st_mode1231 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 3
  %779 = load i32, ptr %st_mode1231, align 8
  call void @stl_le_p(ptr noundef %st_mode, i32 noundef %779)
  br label %do.end1232

do.end1232:                                       ; preds = %do.body1230
  br label %do.body1233

do.body1233:                                      ; preds = %do.end1232
  %780 = load ptr, ptr %target_st, align 8
  %st_uid = getelementptr inbounds %struct.target_stat, ptr %780, i32 0, i32 4
  %st_uid1234 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 4
  %781 = load i32, ptr %st_uid1234, align 4
  call void @stl_le_p(ptr noundef %st_uid, i32 noundef %781)
  br label %do.end1235

do.end1235:                                       ; preds = %do.body1233
  br label %do.body1236

do.body1236:                                      ; preds = %do.end1235
  %782 = load ptr, ptr %target_st, align 8
  %st_gid = getelementptr inbounds %struct.target_stat, ptr %782, i32 0, i32 5
  %st_gid1237 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 5
  %783 = load i32, ptr %st_gid1237, align 8
  call void @stl_le_p(ptr noundef %st_gid, i32 noundef %783)
  br label %do.end1238

do.end1238:                                       ; preds = %do.body1236
  br label %do.body1239

do.body1239:                                      ; preds = %do.end1238
  %784 = load ptr, ptr %target_st, align 8
  %st_nlink = getelementptr inbounds %struct.target_stat, ptr %784, i32 0, i32 3
  %st_nlink1240 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 2
  %785 = load i64, ptr %st_nlink1240, align 8
  %conv1241 = trunc i64 %785 to i32
  call void @stl_le_p(ptr noundef %st_nlink, i32 noundef %conv1241)
  br label %do.end1242

do.end1242:                                       ; preds = %do.body1239
  br label %do.body1243

do.body1243:                                      ; preds = %do.end1242
  %786 = load ptr, ptr %target_st, align 8
  %st_rdev = getelementptr inbounds %struct.target_stat, ptr %786, i32 0, i32 6
  %st_rdev1244 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 7
  %787 = load i64, ptr %st_rdev1244, align 8
  call void @stq_le_p(ptr noundef %st_rdev, i64 noundef %787)
  br label %do.end1245

do.end1245:                                       ; preds = %do.body1243
  br label %do.body1246

do.body1246:                                      ; preds = %do.end1245
  %788 = load ptr, ptr %target_st, align 8
  %st_size = getelementptr inbounds %struct.target_stat, ptr %788, i32 0, i32 8
  %st_size1247 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 8
  %789 = load i64, ptr %st_size1247, align 8
  call void @stq_le_p(ptr noundef %st_size, i64 noundef %789)
  br label %do.end1248

do.end1248:                                       ; preds = %do.body1246
  br label %do.body1249

do.body1249:                                      ; preds = %do.end1248
  %790 = load ptr, ptr %target_st, align 8
  %st_blksize = getelementptr inbounds %struct.target_stat, ptr %790, i32 0, i32 9
  %st_blksize1250 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 9
  %791 = load i64, ptr %st_blksize1250, align 8
  %conv1251 = trunc i64 %791 to i32
  call void @stl_le_p(ptr noundef %st_blksize, i32 noundef %conv1251)
  br label %do.end1252

do.end1252:                                       ; preds = %do.body1249
  br label %do.body1253

do.body1253:                                      ; preds = %do.end1252
  %792 = load ptr, ptr %target_st, align 8
  %st_blocks = getelementptr inbounds %struct.target_stat, ptr %792, i32 0, i32 11
  %st_blocks1254 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 10
  %793 = load i64, ptr %st_blocks1254, align 8
  call void @stq_le_p(ptr noundef %st_blocks, i64 noundef %793)
  br label %do.end1255

do.end1255:                                       ; preds = %do.body1253
  br label %do.body1256

do.body1256:                                      ; preds = %do.end1255
  %794 = load ptr, ptr %target_st, align 8
  %target_st_atime = getelementptr inbounds %struct.target_stat, ptr %794, i32 0, i32 12
  %st_atim = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 11
  %tv_sec = getelementptr inbounds %struct.timespec, ptr %st_atim, i32 0, i32 0
  %795 = load i64, ptr %tv_sec, align 8
  call void @stq_le_p(ptr noundef %target_st_atime, i64 noundef %795)
  br label %do.end1257

do.end1257:                                       ; preds = %do.body1256
  br label %do.body1258

do.body1258:                                      ; preds = %do.end1257
  %796 = load ptr, ptr %target_st, align 8
  %target_st_mtime = getelementptr inbounds %struct.target_stat, ptr %796, i32 0, i32 14
  %st_mtim = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 12
  %tv_sec1259 = getelementptr inbounds %struct.timespec, ptr %st_mtim, i32 0, i32 0
  %797 = load i64, ptr %tv_sec1259, align 8
  call void @stq_le_p(ptr noundef %target_st_mtime, i64 noundef %797)
  br label %do.end1260

do.end1260:                                       ; preds = %do.body1258
  br label %do.body1261

do.body1261:                                      ; preds = %do.end1260
  %798 = load ptr, ptr %target_st, align 8
  %target_st_ctime = getelementptr inbounds %struct.target_stat, ptr %798, i32 0, i32 16
  %st_ctim = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 13
  %tv_sec1262 = getelementptr inbounds %struct.timespec, ptr %st_ctim, i32 0, i32 0
  %799 = load i64, ptr %tv_sec1262, align 8
  call void @stq_le_p(ptr noundef %target_st_ctime, i64 noundef %799)
  br label %do.end1263

do.end1263:                                       ; preds = %do.body1261
  br label %do.body1264

do.body1264:                                      ; preds = %do.end1263
  %800 = load ptr, ptr %target_st, align 8
  %target_st_atime_nsec = getelementptr inbounds %struct.target_stat, ptr %800, i32 0, i32 13
  %st_atim1265 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 11
  %tv_nsec = getelementptr inbounds %struct.timespec, ptr %st_atim1265, i32 0, i32 1
  %801 = load i64, ptr %tv_nsec, align 8
  call void @stq_le_p(ptr noundef %target_st_atime_nsec, i64 noundef %801)
  br label %do.end1266

do.end1266:                                       ; preds = %do.body1264
  br label %do.body1267

do.body1267:                                      ; preds = %do.end1266
  %802 = load ptr, ptr %target_st, align 8
  %target_st_mtime_nsec = getelementptr inbounds %struct.target_stat, ptr %802, i32 0, i32 15
  %st_mtim1268 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 12
  %tv_nsec1269 = getelementptr inbounds %struct.timespec, ptr %st_mtim1268, i32 0, i32 1
  %803 = load i64, ptr %tv_nsec1269, align 8
  call void @stq_le_p(ptr noundef %target_st_mtime_nsec, i64 noundef %803)
  br label %do.end1270

do.end1270:                                       ; preds = %do.body1267
  br label %do.body1271

do.body1271:                                      ; preds = %do.end1270
  %804 = load ptr, ptr %target_st, align 8
  %target_st_ctime_nsec = getelementptr inbounds %struct.target_stat, ptr %804, i32 0, i32 17
  %st_ctim1272 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 13
  %tv_nsec1273 = getelementptr inbounds %struct.timespec, ptr %st_ctim1272, i32 0, i32 1
  %805 = load i64, ptr %tv_nsec1273, align 8
  call void @stq_le_p(ptr noundef %target_st_ctime_nsec, i64 noundef %805)
  br label %do.end1274

do.end1274:                                       ; preds = %do.body1271
  %806 = load ptr, ptr %target_st, align 8
  %807 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %806, i64 noundef %807, i64 noundef 128)
  br label %if.end1275

if.end1275:                                       ; preds = %do.end1274, %sw.bb1212
  %808 = load i64, ptr %ret, align 8
  store i64 %808, ptr %retval, align 8
  br label %return

sw.bb1276:                                        ; preds = %entry
  %call1277 = call i32 @vhangup() #14
  %conv1278 = sext i32 %call1277 to i64
  %call1279 = call i64 @get_errno(i64 noundef %conv1278)
  store i64 %call1279, ptr %retval, align 8
  br label %return

sw.bb1280:                                        ; preds = %entry
  %809 = load i64, ptr %arg2.addr, align 8
  store i64 %809, ptr %status_ptr, align 8
  %810 = load i64, ptr %arg4.addr, align 8
  store i64 %810, ptr %target_rusage, align 8
  %811 = load i64, ptr %target_rusage, align 8
  %tobool1282 = icmp ne i64 %811, 0
  br i1 %tobool1282, label %if.then1283, label %if.else1284

if.then1283:                                      ; preds = %sw.bb1280
  store ptr %rusage1281, ptr %rusage_ptr, align 8
  br label %if.end1285

if.else1284:                                      ; preds = %sw.bb1280
  store ptr null, ptr %rusage_ptr, align 8
  br label %if.end1285

if.end1285:                                       ; preds = %if.else1284, %if.then1283
  %812 = load i64, ptr %arg1.addr, align 8
  %conv1286 = trunc i64 %812 to i32
  %813 = load i64, ptr %arg3.addr, align 8
  %conv1287 = trunc i64 %813 to i32
  %814 = load ptr, ptr %rusage_ptr, align 8
  %call1288 = call i32 @safe_wait4(i32 noundef %conv1286, ptr noundef %status, i32 noundef %conv1287, ptr noundef %814)
  %conv1289 = sext i32 %call1288 to i64
  %call1290 = call i64 @get_errno(i64 noundef %conv1289)
  store i64 %call1290, ptr %ret, align 8
  %815 = load i64, ptr %ret, align 8
  %call1291 = call i32 @is_error(i64 noundef %815)
  %tobool1292 = icmp ne i32 %call1291, 0
  br i1 %tobool1292, label %if.end1321, label %if.then1293

if.then1293:                                      ; preds = %if.end1285
  %816 = load i64, ptr %status_ptr, align 8
  %tobool1294 = icmp ne i64 %816, 0
  br i1 %tobool1294, label %land.lhs.true1295, label %if.end1313

land.lhs.true1295:                                ; preds = %if.then1293
  %817 = load i64, ptr %ret, align 8
  %tobool1296 = icmp ne i64 %817, 0
  br i1 %tobool1296, label %if.then1297, label %if.end1313

if.then1297:                                      ; preds = %land.lhs.true1295
  %818 = load i32, ptr %status, align 4
  %call1298 = call i32 @host_to_target_waitstatus(i32 noundef %818)
  store i32 %call1298, ptr %status, align 4
  %819 = load i64, ptr %status_ptr, align 8
  store i64 %819, ptr %__gaddr1299, align 8
  store i64 0, ptr %__ret1301, align 8
  %820 = load i64, ptr %__gaddr1299, align 8
  %call1302 = call ptr @lock_user(i32 noundef 3, i64 noundef %820, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call1302, ptr %__hptr1300, align 8
  %tobool1303 = icmp ne ptr %call1302, null
  br i1 %tobool1303, label %if.then1304, label %if.else1307

if.then1304:                                      ; preds = %if.then1297
  br label %do.body1305

do.body1305:                                      ; preds = %if.then1304
  %821 = load ptr, ptr %__hptr1300, align 8
  %822 = load i32, ptr %status, align 4
  call void @stl_le_p(ptr noundef %821, i32 noundef %822)
  br label %do.end1306

do.end1306:                                       ; preds = %do.body1305
  %823 = load ptr, ptr %__hptr1300, align 8
  %824 = load i64, ptr %__gaddr1299, align 8
  call void @unlock_user(ptr noundef %823, i64 noundef %824, i64 noundef 4)
  br label %if.end1308

if.else1307:                                      ; preds = %if.then1297
  store i64 -14, ptr %__ret1301, align 8
  br label %if.end1308

if.end1308:                                       ; preds = %if.else1307, %do.end1306
  %825 = load i64, ptr %__ret1301, align 8
  store i64 %825, ptr %tmp1309, align 8
  %826 = load i64, ptr %tmp1309, align 8
  %tobool1310 = icmp ne i64 %826, 0
  br i1 %tobool1310, label %if.then1311, label %if.end1312

if.then1311:                                      ; preds = %if.end1308
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1312:                                       ; preds = %if.end1308
  br label %if.end1313

if.end1313:                                       ; preds = %if.end1312, %land.lhs.true1295, %if.then1293
  %827 = load i64, ptr %target_rusage, align 8
  %tobool1314 = icmp ne i64 %827, 0
  br i1 %tobool1314, label %if.then1315, label %if.end1320

if.then1315:                                      ; preds = %if.end1313
  %828 = load i64, ptr %target_rusage, align 8
  %call1316 = call i64 @host_to_target_rusage(i64 noundef %828, ptr noundef %rusage1281)
  store i64 %call1316, ptr %rusage_err, align 8
  %829 = load i64, ptr %rusage_err, align 8
  %tobool1317 = icmp ne i64 %829, 0
  br i1 %tobool1317, label %if.then1318, label %if.end1319

if.then1318:                                      ; preds = %if.then1315
  %830 = load i64, ptr %rusage_err, align 8
  store i64 %830, ptr %ret, align 8
  br label %if.end1319

if.end1319:                                       ; preds = %if.then1318, %if.then1315
  br label %if.end1320

if.end1320:                                       ; preds = %if.end1319, %if.end1313
  br label %if.end1321

if.end1321:                                       ; preds = %if.end1320, %if.end1285
  %831 = load i64, ptr %ret, align 8
  store i64 %831, ptr %retval, align 8
  br label %return

sw.bb1322:                                        ; preds = %entry
  %832 = load i64, ptr %arg1.addr, align 8
  %call1323 = call ptr @lock_user_string(i64 noundef %832)
  store ptr %call1323, ptr %p, align 8
  %tobool1324 = icmp ne ptr %call1323, null
  br i1 %tobool1324, label %if.end1326, label %if.then1325

if.then1325:                                      ; preds = %sw.bb1322
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1326:                                       ; preds = %sw.bb1322
  %833 = load ptr, ptr %p, align 8
  %call1327 = call i32 @swapoff(ptr noundef %833) #14
  %conv1328 = sext i32 %call1327 to i64
  %call1329 = call i64 @get_errno(i64 noundef %conv1328)
  store i64 %call1329, ptr %ret, align 8
  %834 = load ptr, ptr %p, align 8
  %835 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %834, i64 noundef %835, i64 noundef 0)
  %836 = load i64, ptr %ret, align 8
  store i64 %836, ptr %retval, align 8
  br label %return

sw.bb1330:                                        ; preds = %entry
  %call1332 = call i32 @sysinfo(ptr noundef %value1331) #14
  %conv1333 = sext i32 %call1332 to i64
  %call1334 = call i64 @get_errno(i64 noundef %conv1333)
  store i64 %call1334, ptr %ret, align 8
  %837 = load i64, ptr %ret, align 8
  %call1335 = call i32 @is_error(i64 noundef %837)
  %tobool1336 = icmp ne i32 %call1335, 0
  br i1 %tobool1336, label %if.end1394, label %land.lhs.true1337

land.lhs.true1337:                                ; preds = %sw.bb1330
  %838 = load i64, ptr %arg1.addr, align 8
  %tobool1338 = icmp ne i64 %838, 0
  br i1 %tobool1338, label %if.then1339, label %if.end1394

if.then1339:                                      ; preds = %land.lhs.true1337
  %839 = load i64, ptr %arg1.addr, align 8
  %call1340 = call ptr @lock_user(i32 noundef 3, i64 noundef %839, i64 noundef 112, i1 noundef zeroext false)
  store ptr %call1340, ptr %target_value, align 8
  %tobool1341 = icmp ne ptr %call1340, null
  br i1 %tobool1341, label %if.end1343, label %if.then1342

if.then1342:                                      ; preds = %if.then1339
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1343:                                       ; preds = %if.then1339
  br label %do.body1344

do.body1344:                                      ; preds = %if.end1343
  %840 = load ptr, ptr %target_value, align 8
  %uptime = getelementptr inbounds %struct.target_sysinfo, ptr %840, i32 0, i32 0
  %uptime1345 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 0
  %841 = load i64, ptr %uptime1345, align 8
  call void @stq_le_p(ptr noundef %uptime, i64 noundef %841)
  br label %do.end1346

do.end1346:                                       ; preds = %do.body1344
  br label %do.body1347

do.body1347:                                      ; preds = %do.end1346
  %842 = load ptr, ptr %target_value, align 8
  %loads = getelementptr inbounds %struct.target_sysinfo, ptr %842, i32 0, i32 1
  %arrayidx1348 = getelementptr [3 x i64], ptr %loads, i64 0, i64 0
  %loads1349 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 1
  %arrayidx1350 = getelementptr [3 x i64], ptr %loads1349, i64 0, i64 0
  %843 = load i64, ptr %arrayidx1350, align 8
  call void @stq_le_p(ptr noundef %arrayidx1348, i64 noundef %843)
  br label %do.end1351

do.end1351:                                       ; preds = %do.body1347
  br label %do.body1352

do.body1352:                                      ; preds = %do.end1351
  %844 = load ptr, ptr %target_value, align 8
  %loads1353 = getelementptr inbounds %struct.target_sysinfo, ptr %844, i32 0, i32 1
  %arrayidx1354 = getelementptr [3 x i64], ptr %loads1353, i64 0, i64 1
  %loads1355 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 1
  %arrayidx1356 = getelementptr [3 x i64], ptr %loads1355, i64 0, i64 1
  %845 = load i64, ptr %arrayidx1356, align 8
  call void @stq_le_p(ptr noundef %arrayidx1354, i64 noundef %845)
  br label %do.end1357

do.end1357:                                       ; preds = %do.body1352
  br label %do.body1358

do.body1358:                                      ; preds = %do.end1357
  %846 = load ptr, ptr %target_value, align 8
  %loads1359 = getelementptr inbounds %struct.target_sysinfo, ptr %846, i32 0, i32 1
  %arrayidx1360 = getelementptr [3 x i64], ptr %loads1359, i64 0, i64 2
  %loads1361 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 1
  %arrayidx1362 = getelementptr [3 x i64], ptr %loads1361, i64 0, i64 2
  %847 = load i64, ptr %arrayidx1362, align 8
  call void @stq_le_p(ptr noundef %arrayidx1360, i64 noundef %847)
  br label %do.end1363

do.end1363:                                       ; preds = %do.body1358
  br label %do.body1364

do.body1364:                                      ; preds = %do.end1363
  %848 = load ptr, ptr %target_value, align 8
  %totalram = getelementptr inbounds %struct.target_sysinfo, ptr %848, i32 0, i32 2
  %totalram1365 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 2
  %849 = load i64, ptr %totalram1365, align 8
  call void @stq_le_p(ptr noundef %totalram, i64 noundef %849)
  br label %do.end1366

do.end1366:                                       ; preds = %do.body1364
  br label %do.body1367

do.body1367:                                      ; preds = %do.end1366
  %850 = load ptr, ptr %target_value, align 8
  %freeram = getelementptr inbounds %struct.target_sysinfo, ptr %850, i32 0, i32 3
  %freeram1368 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 3
  %851 = load i64, ptr %freeram1368, align 8
  call void @stq_le_p(ptr noundef %freeram, i64 noundef %851)
  br label %do.end1369

do.end1369:                                       ; preds = %do.body1367
  br label %do.body1370

do.body1370:                                      ; preds = %do.end1369
  %852 = load ptr, ptr %target_value, align 8
  %sharedram = getelementptr inbounds %struct.target_sysinfo, ptr %852, i32 0, i32 4
  %sharedram1371 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 4
  %853 = load i64, ptr %sharedram1371, align 8
  call void @stq_le_p(ptr noundef %sharedram, i64 noundef %853)
  br label %do.end1372

do.end1372:                                       ; preds = %do.body1370
  br label %do.body1373

do.body1373:                                      ; preds = %do.end1372
  %854 = load ptr, ptr %target_value, align 8
  %bufferram = getelementptr inbounds %struct.target_sysinfo, ptr %854, i32 0, i32 5
  %bufferram1374 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 5
  %855 = load i64, ptr %bufferram1374, align 8
  call void @stq_le_p(ptr noundef %bufferram, i64 noundef %855)
  br label %do.end1375

do.end1375:                                       ; preds = %do.body1373
  br label %do.body1376

do.body1376:                                      ; preds = %do.end1375
  %856 = load ptr, ptr %target_value, align 8
  %totalswap = getelementptr inbounds %struct.target_sysinfo, ptr %856, i32 0, i32 6
  %totalswap1377 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 6
  %857 = load i64, ptr %totalswap1377, align 8
  call void @stq_le_p(ptr noundef %totalswap, i64 noundef %857)
  br label %do.end1378

do.end1378:                                       ; preds = %do.body1376
  br label %do.body1379

do.body1379:                                      ; preds = %do.end1378
  %858 = load ptr, ptr %target_value, align 8
  %freeswap = getelementptr inbounds %struct.target_sysinfo, ptr %858, i32 0, i32 7
  %freeswap1380 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 7
  %859 = load i64, ptr %freeswap1380, align 8
  call void @stq_le_p(ptr noundef %freeswap, i64 noundef %859)
  br label %do.end1381

do.end1381:                                       ; preds = %do.body1379
  br label %do.body1382

do.body1382:                                      ; preds = %do.end1381
  %860 = load ptr, ptr %target_value, align 8
  %procs = getelementptr inbounds %struct.target_sysinfo, ptr %860, i32 0, i32 8
  %procs1383 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 8
  %861 = load i16, ptr %procs1383, align 8
  call void @stw_le_p(ptr noundef %procs, i16 noundef zeroext %861)
  br label %do.end1384

do.end1384:                                       ; preds = %do.body1382
  br label %do.body1385

do.body1385:                                      ; preds = %do.end1384
  %862 = load ptr, ptr %target_value, align 8
  %totalhigh = getelementptr inbounds %struct.target_sysinfo, ptr %862, i32 0, i32 10
  %totalhigh1386 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 10
  %863 = load i64, ptr %totalhigh1386, align 8
  call void @stq_le_p(ptr noundef %totalhigh, i64 noundef %863)
  br label %do.end1387

do.end1387:                                       ; preds = %do.body1385
  br label %do.body1388

do.body1388:                                      ; preds = %do.end1387
  %864 = load ptr, ptr %target_value, align 8
  %freehigh = getelementptr inbounds %struct.target_sysinfo, ptr %864, i32 0, i32 11
  %freehigh1389 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 11
  %865 = load i64, ptr %freehigh1389, align 8
  call void @stq_le_p(ptr noundef %freehigh, i64 noundef %865)
  br label %do.end1390

do.end1390:                                       ; preds = %do.body1388
  br label %do.body1391

do.body1391:                                      ; preds = %do.end1390
  %866 = load ptr, ptr %target_value, align 8
  %mem_unit = getelementptr inbounds %struct.target_sysinfo, ptr %866, i32 0, i32 12
  %mem_unit1392 = getelementptr inbounds %struct.sysinfo, ptr %value1331, i32 0, i32 12
  %867 = load i32, ptr %mem_unit1392, align 8
  call void @stl_le_p(ptr noundef %mem_unit, i32 noundef %867)
  br label %do.end1393

do.end1393:                                       ; preds = %do.body1391
  %868 = load ptr, ptr %target_value, align 8
  %869 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %868, i64 noundef %869, i64 noundef 112)
  br label %if.end1394

if.end1394:                                       ; preds = %do.end1393, %land.lhs.true1337, %sw.bb1330
  %870 = load i64, ptr %ret, align 8
  store i64 %870, ptr %retval, align 8
  br label %return

sw.bb1395:                                        ; preds = %entry
  %871 = load i64, ptr %arg1.addr, align 8
  %conv1396 = trunc i64 %871 to i32
  %872 = load i64, ptr %arg2.addr, align 8
  %conv1397 = trunc i64 %872 to i32
  %873 = load i64, ptr %arg3.addr, align 8
  %conv1398 = trunc i64 %873 to i32
  %call1399 = call i32 @semget(i32 noundef %conv1396, i32 noundef %conv1397, i32 noundef %conv1398) #14
  %conv1400 = sext i32 %call1399 to i64
  %call1401 = call i64 @get_errno(i64 noundef %conv1400)
  store i64 %call1401, ptr %retval, align 8
  br label %return

sw.bb1402:                                        ; preds = %entry
  %874 = load i64, ptr %arg1.addr, align 8
  %conv1403 = trunc i64 %874 to i32
  %875 = load i64, ptr %arg2.addr, align 8
  %876 = load i64, ptr %arg3.addr, align 8
  %conv1404 = trunc i64 %876 to i32
  %call1405 = call i64 @do_semtimedop(i32 noundef %conv1403, i64 noundef %875, i32 noundef %conv1404, i64 noundef 0, i1 noundef zeroext false)
  store i64 %call1405, ptr %retval, align 8
  br label %return

sw.bb1406:                                        ; preds = %entry
  %877 = load i64, ptr %arg1.addr, align 8
  %conv1407 = trunc i64 %877 to i32
  %878 = load i64, ptr %arg2.addr, align 8
  %879 = load i64, ptr %arg3.addr, align 8
  %conv1408 = trunc i64 %879 to i32
  %880 = load i64, ptr %arg4.addr, align 8
  %call1409 = call i64 @do_semtimedop(i32 noundef %conv1407, i64 noundef %878, i32 noundef %conv1408, i64 noundef %880, i1 noundef zeroext false)
  store i64 %call1409, ptr %retval, align 8
  br label %return

sw.bb1410:                                        ; preds = %entry
  %881 = load i64, ptr %arg1.addr, align 8
  %conv1411 = trunc i64 %881 to i32
  %882 = load i64, ptr %arg2.addr, align 8
  %conv1412 = trunc i64 %882 to i32
  %883 = load i64, ptr %arg3.addr, align 8
  %conv1413 = trunc i64 %883 to i32
  %884 = load i64, ptr %arg4.addr, align 8
  %call1414 = call i64 @do_semctl(i32 noundef %conv1411, i32 noundef %conv1412, i32 noundef %conv1413, i64 noundef %884)
  store i64 %call1414, ptr %retval, align 8
  br label %return

sw.bb1415:                                        ; preds = %entry
  %885 = load i64, ptr %arg1.addr, align 8
  %conv1416 = trunc i64 %885 to i32
  %886 = load i64, ptr %arg2.addr, align 8
  %conv1417 = trunc i64 %886 to i32
  %887 = load i64, ptr %arg3.addr, align 8
  %call1418 = call i64 @do_msgctl(i32 noundef %conv1416, i32 noundef %conv1417, i64 noundef %887)
  store i64 %call1418, ptr %retval, align 8
  br label %return

sw.bb1419:                                        ; preds = %entry
  %888 = load i64, ptr %arg1.addr, align 8
  %conv1420 = trunc i64 %888 to i32
  %889 = load i64, ptr %arg2.addr, align 8
  %conv1421 = trunc i64 %889 to i32
  %call1422 = call i32 @msgget(i32 noundef %conv1420, i32 noundef %conv1421) #14
  %conv1423 = sext i32 %call1422 to i64
  %call1424 = call i64 @get_errno(i64 noundef %conv1423)
  store i64 %call1424, ptr %retval, align 8
  br label %return

sw.bb1425:                                        ; preds = %entry
  %890 = load i64, ptr %arg1.addr, align 8
  %conv1426 = trunc i64 %890 to i32
  %891 = load i64, ptr %arg2.addr, align 8
  %892 = load i64, ptr %arg3.addr, align 8
  %893 = load i64, ptr %arg4.addr, align 8
  %894 = load i64, ptr %arg5.addr, align 8
  %conv1427 = trunc i64 %894 to i32
  %call1428 = call i64 @do_msgrcv(i32 noundef %conv1426, i64 noundef %891, i64 noundef %892, i64 noundef %893, i32 noundef %conv1427)
  store i64 %call1428, ptr %retval, align 8
  br label %return

sw.bb1429:                                        ; preds = %entry
  %895 = load i64, ptr %arg1.addr, align 8
  %conv1430 = trunc i64 %895 to i32
  %896 = load i64, ptr %arg2.addr, align 8
  %897 = load i64, ptr %arg3.addr, align 8
  %898 = load i64, ptr %arg4.addr, align 8
  %conv1431 = trunc i64 %898 to i32
  %call1432 = call i64 @do_msgsnd(i32 noundef %conv1430, i64 noundef %896, i64 noundef %897, i32 noundef %conv1431)
  store i64 %call1432, ptr %retval, align 8
  br label %return

sw.bb1433:                                        ; preds = %entry
  %899 = load i64, ptr %arg1.addr, align 8
  %conv1434 = trunc i64 %899 to i32
  %900 = load i64, ptr %arg2.addr, align 8
  %901 = load i64, ptr %arg3.addr, align 8
  %conv1435 = trunc i64 %901 to i32
  %call1436 = call i32 @shmget(i32 noundef %conv1434, i64 noundef %900, i32 noundef %conv1435) #14
  %conv1437 = sext i32 %call1436 to i64
  %call1438 = call i64 @get_errno(i64 noundef %conv1437)
  store i64 %call1438, ptr %retval, align 8
  br label %return

sw.bb1439:                                        ; preds = %entry
  %902 = load i64, ptr %arg1.addr, align 8
  %conv1440 = trunc i64 %902 to i32
  %903 = load i64, ptr %arg2.addr, align 8
  %conv1441 = trunc i64 %903 to i32
  %904 = load i64, ptr %arg3.addr, align 8
  %call1442 = call i64 @do_shmctl(i32 noundef %conv1440, i32 noundef %conv1441, i64 noundef %904)
  store i64 %call1442, ptr %retval, align 8
  br label %return

sw.bb1443:                                        ; preds = %entry
  %905 = load ptr, ptr %cpu_env.addr, align 8
  %906 = load i64, ptr %arg1.addr, align 8
  %conv1444 = trunc i64 %906 to i32
  %907 = load i64, ptr %arg2.addr, align 8
  %908 = load i64, ptr %arg3.addr, align 8
  %conv1445 = trunc i64 %908 to i32
  %call1446 = call i64 @target_shmat(ptr noundef %905, i32 noundef %conv1444, i64 noundef %907, i32 noundef %conv1445)
  store i64 %call1446, ptr %retval, align 8
  br label %return

sw.bb1447:                                        ; preds = %entry
  %909 = load i64, ptr %arg1.addr, align 8
  %call1448 = call i64 @target_shmdt(i64 noundef %909)
  store i64 %call1448, ptr %retval, align 8
  br label %return

sw.bb1449:                                        ; preds = %entry
  %910 = load i64, ptr %arg1.addr, align 8
  %conv1450 = trunc i64 %910 to i32
  %call1451 = call i32 @fsync(i32 noundef %conv1450)
  %conv1452 = sext i32 %call1451 to i64
  %call1453 = call i64 @get_errno(i64 noundef %conv1452)
  store i64 %call1453, ptr %retval, align 8
  br label %return

sw.bb1454:                                        ; preds = %entry
  %911 = load ptr, ptr %cpu_env.addr, align 8
  %912 = load i64, ptr %arg1.addr, align 8
  %conv1455 = trunc i64 %912 to i32
  %913 = load i64, ptr %arg2.addr, align 8
  %914 = load i64, ptr %arg3.addr, align 8
  %915 = load i64, ptr %arg4.addr, align 8
  %916 = load i64, ptr %arg5.addr, align 8
  %call1456 = call i32 @do_fork(ptr noundef %911, i32 noundef %conv1455, i64 noundef %913, i64 noundef %914, i64 noundef %915, i64 noundef %916)
  %conv1457 = sext i32 %call1456 to i64
  %call1458 = call i64 @get_errno(i64 noundef %conv1457)
  store i64 %call1458, ptr %ret, align 8
  %917 = load i64, ptr %ret, align 8
  store i64 %917, ptr %retval, align 8
  br label %return

sw.bb1459:                                        ; preds = %entry
  %918 = load ptr, ptr %cpu_env.addr, align 8
  %919 = load i64, ptr %arg1.addr, align 8
  %conv1460 = trunc i64 %919 to i32
  call void @preexit_cleanup(ptr noundef %918, i32 noundef %conv1460)
  %920 = load i64, ptr %arg1.addr, align 8
  %conv1461 = trunc i64 %920 to i32
  %call1462 = call i32 @exit_group(i32 noundef %conv1461)
  %conv1463 = sext i32 %call1462 to i64
  %call1464 = call i64 @get_errno(i64 noundef %conv1463)
  store i64 %call1464, ptr %retval, align 8
  br label %return

sw.bb1465:                                        ; preds = %entry
  %921 = load i64, ptr %arg1.addr, align 8
  %call1466 = call ptr @lock_user_string(i64 noundef %921)
  store ptr %call1466, ptr %p, align 8
  %tobool1467 = icmp ne ptr %call1466, null
  br i1 %tobool1467, label %if.end1469, label %if.then1468

if.then1468:                                      ; preds = %sw.bb1465
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1469:                                       ; preds = %sw.bb1465
  %922 = load ptr, ptr %p, align 8
  %923 = load i64, ptr %arg2.addr, align 8
  %call1470 = call i32 @setdomainname(ptr noundef %922, i64 noundef %923) #14
  %conv1471 = sext i32 %call1470 to i64
  %call1472 = call i64 @get_errno(i64 noundef %conv1471)
  store i64 %call1472, ptr %ret, align 8
  %924 = load ptr, ptr %p, align 8
  %925 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %924, i64 noundef %925, i64 noundef 0)
  %926 = load i64, ptr %ret, align 8
  store i64 %926, ptr %retval, align 8
  br label %return

sw.bb1473:                                        ; preds = %entry
  %927 = load i64, ptr %arg1.addr, align 8
  %call1474 = call ptr @lock_user(i32 noundef 3, i64 noundef %927, i64 noundef 390, i1 noundef zeroext false)
  store ptr %call1474, ptr %buf, align 8
  %tobool1475 = icmp ne ptr %call1474, null
  br i1 %tobool1475, label %if.end1477, label %if.then1476

if.then1476:                                      ; preds = %sw.bb1473
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1477:                                       ; preds = %sw.bb1473
  %928 = load ptr, ptr %buf, align 8
  %call1478 = call i32 @sys_uname(ptr noundef %928)
  %conv1479 = sext i32 %call1478 to i64
  %call1480 = call i64 @get_errno(i64 noundef %conv1479)
  store i64 %call1480, ptr %ret, align 8
  %929 = load i64, ptr %ret, align 8
  %call1481 = call i32 @is_error(i64 noundef %929)
  %tobool1482 = icmp ne i32 %call1481, 0
  br i1 %tobool1482, label %if.end1495, label %if.then1483

if.then1483:                                      ; preds = %if.end1477
  %930 = load ptr, ptr %buf, align 8
  %machine = getelementptr inbounds %struct.new_utsname, ptr %930, i32 0, i32 4
  %arraydecay1484 = getelementptr inbounds [65 x i8], ptr %machine, i64 0, i64 0
  %931 = load ptr, ptr %cpu_env.addr, align 8
  %call1485 = call ptr @cpu_to_uname_machine(ptr noundef %931)
  %call1486 = call i64 @g_strlcpy(ptr noundef %arraydecay1484, ptr noundef %call1485, i64 noundef 65)
  %932 = load ptr, ptr @qemu_uname_release, align 8
  %tobool1487 = icmp ne ptr %932, null
  br i1 %tobool1487, label %land.lhs.true1488, label %if.end1494

land.lhs.true1488:                                ; preds = %if.then1483
  %933 = load ptr, ptr @qemu_uname_release, align 8
  %934 = load i8, ptr %933, align 1
  %conv1489 = sext i8 %934 to i32
  %tobool1490 = icmp ne i32 %conv1489, 0
  br i1 %tobool1490, label %if.then1491, label %if.end1494

if.then1491:                                      ; preds = %land.lhs.true1488
  %935 = load ptr, ptr %buf, align 8
  %release = getelementptr inbounds %struct.new_utsname, ptr %935, i32 0, i32 2
  %arraydecay1492 = getelementptr inbounds [65 x i8], ptr %release, i64 0, i64 0
  %936 = load ptr, ptr @qemu_uname_release, align 8
  %call1493 = call i64 @g_strlcpy(ptr noundef %arraydecay1492, ptr noundef %936, i64 noundef 65)
  br label %if.end1494

if.end1494:                                       ; preds = %if.then1491, %land.lhs.true1488, %if.then1483
  br label %if.end1495

if.end1495:                                       ; preds = %if.end1494, %if.end1477
  %937 = load ptr, ptr %buf, align 8
  %938 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %937, i64 noundef %938, i64 noundef 390)
  %939 = load i64, ptr %ret, align 8
  store i64 %939, ptr %retval, align 8
  br label %return

sw.bb1496:                                        ; preds = %entry
  %940 = load i64, ptr %arg1.addr, align 8
  %call1497 = call i64 @target_to_host_timex(ptr noundef %host_buf, i64 noundef %940)
  %cmp1498 = icmp ne i64 %call1497, 0
  br i1 %cmp1498, label %if.then1500, label %if.end1501

if.then1500:                                      ; preds = %sw.bb1496
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1501:                                       ; preds = %sw.bb1496
  %call1502 = call i32 @adjtimex(ptr noundef %host_buf) #14
  %conv1503 = sext i32 %call1502 to i64
  %call1504 = call i64 @get_errno(i64 noundef %conv1503)
  store i64 %call1504, ptr %ret, align 8
  %941 = load i64, ptr %ret, align 8
  %call1505 = call i32 @is_error(i64 noundef %941)
  %tobool1506 = icmp ne i32 %call1505, 0
  br i1 %tobool1506, label %if.end1513, label %if.then1507

if.then1507:                                      ; preds = %if.end1501
  %942 = load i64, ptr %arg1.addr, align 8
  %call1508 = call i64 @host_to_target_timex(i64 noundef %942, ptr noundef %host_buf)
  %cmp1509 = icmp ne i64 %call1508, 0
  br i1 %cmp1509, label %if.then1511, label %if.end1512

if.then1511:                                      ; preds = %if.then1507
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1512:                                       ; preds = %if.then1507
  br label %if.end1513

if.end1513:                                       ; preds = %if.end1512, %if.end1501
  %943 = load i64, ptr %ret, align 8
  store i64 %943, ptr %retval, align 8
  br label %return

sw.bb1514:                                        ; preds = %entry
  %944 = load i64, ptr %arg2.addr, align 8
  %call1515 = call i64 @target_to_host_timex(ptr noundef %htx, i64 noundef %944)
  %cmp1516 = icmp ne i64 %call1515, 0
  br i1 %cmp1516, label %if.then1518, label %if.end1519

if.then1518:                                      ; preds = %sw.bb1514
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1519:                                       ; preds = %sw.bb1514
  %945 = load i64, ptr %arg1.addr, align 8
  %conv1520 = trunc i64 %945 to i32
  %call1521 = call i32 @clock_adjtime(i32 noundef %conv1520, ptr noundef %htx) #14
  %conv1522 = sext i32 %call1521 to i64
  %call1523 = call i64 @get_errno(i64 noundef %conv1522)
  store i64 %call1523, ptr %ret, align 8
  %946 = load i64, ptr %ret, align 8
  %call1524 = call i32 @is_error(i64 noundef %946)
  %tobool1525 = icmp ne i32 %call1524, 0
  br i1 %tobool1525, label %if.end1530, label %land.lhs.true1526

land.lhs.true1526:                                ; preds = %if.end1519
  %947 = load i64, ptr %arg2.addr, align 8
  %call1527 = call i64 @host_to_target_timex(i64 noundef %947, ptr noundef %htx)
  %tobool1528 = icmp ne i64 %call1527, 0
  br i1 %tobool1528, label %if.then1529, label %if.end1530

if.then1529:                                      ; preds = %land.lhs.true1526
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1530:                                       ; preds = %land.lhs.true1526, %if.end1519
  %948 = load i64, ptr %ret, align 8
  store i64 %948, ptr %retval, align 8
  br label %return

sw.bb1531:                                        ; preds = %entry
  %949 = load i64, ptr %arg1.addr, align 8
  %conv1532 = trunc i64 %949 to i32
  %call1533 = call i32 @getpgid(i32 noundef %conv1532) #14
  %conv1534 = sext i32 %call1533 to i64
  %call1535 = call i64 @get_errno(i64 noundef %conv1534)
  store i64 %call1535, ptr %retval, align 8
  br label %return

sw.bb1536:                                        ; preds = %entry
  %950 = load i64, ptr %arg1.addr, align 8
  %conv1537 = trunc i64 %950 to i32
  %call1538 = call i32 @fchdir(i32 noundef %conv1537) #14
  %conv1539 = sext i32 %call1538 to i64
  %call1540 = call i64 @get_errno(i64 noundef %conv1539)
  store i64 %call1540, ptr %retval, align 8
  br label %return

sw.bb1541:                                        ; preds = %entry
  %951 = load i64, ptr %arg1.addr, align 8
  %call1542 = call i32 @personality(i64 noundef %951) #14
  %conv1543 = sext i32 %call1542 to i64
  %call1544 = call i64 @get_errno(i64 noundef %conv1543)
  store i64 %call1544, ptr %retval, align 8
  br label %return

sw.bb1545:                                        ; preds = %entry
  %952 = load i64, ptr %arg1.addr, align 8
  %953 = load i64, ptr %arg2.addr, align 8
  %954 = load i64, ptr %arg3.addr, align 8
  %call1546 = call i32 @do_getdents64(i64 noundef %952, i64 noundef %953, i64 noundef %954)
  %conv1547 = sext i32 %call1546 to i64
  store i64 %conv1547, ptr %retval, align 8
  br label %return

sw.bb1548:                                        ; preds = %entry
  %955 = load i64, ptr %arg1.addr, align 8
  %956 = load i64, ptr %arg2.addr, align 8
  %957 = load i64, ptr %arg3.addr, align 8
  %958 = load i64, ptr %arg4.addr, align 8
  %959 = load i64, ptr %arg5.addr, align 8
  %call1549 = call i64 @do_ppoll(i64 noundef %955, i64 noundef %956, i64 noundef %957, i64 noundef %958, i64 noundef %959, i1 noundef zeroext true, i1 noundef zeroext false)
  store i64 %call1549, ptr %retval, align 8
  br label %return

sw.bb1550:                                        ; preds = %entry
  %960 = load i64, ptr %arg1.addr, align 8
  %conv1551 = trunc i64 %960 to i32
  %961 = load i64, ptr %arg2.addr, align 8
  %conv1552 = trunc i64 %961 to i32
  %call1553 = call i32 @safe_flock(i32 noundef %conv1551, i32 noundef %conv1552)
  %conv1554 = sext i32 %call1553 to i64
  %call1555 = call i64 @get_errno(i64 noundef %conv1554)
  store i64 %call1555, ptr %retval, align 8
  br label %return

sw.bb1556:                                        ; preds = %entry
  %962 = load i64, ptr %arg2.addr, align 8
  %963 = load i64, ptr %arg3.addr, align 8
  %call1557 = call ptr @lock_iovec(i32 noundef 3, i64 noundef %962, i64 noundef %963, i32 noundef 0)
  store ptr %call1557, ptr %vec, align 8
  %964 = load ptr, ptr %vec, align 8
  %cmp1558 = icmp ne ptr %964, null
  br i1 %cmp1558, label %if.then1560, label %if.else1565

if.then1560:                                      ; preds = %sw.bb1556
  %965 = load i64, ptr %arg1.addr, align 8
  %conv1561 = trunc i64 %965 to i32
  %966 = load ptr, ptr %vec, align 8
  %967 = load i64, ptr %arg3.addr, align 8
  %conv1562 = trunc i64 %967 to i32
  %call1563 = call i64 @safe_readv(i32 noundef %conv1561, ptr noundef %966, i32 noundef %conv1562)
  %call1564 = call i64 @get_errno(i64 noundef %call1563)
  store i64 %call1564, ptr %ret, align 8
  %968 = load ptr, ptr %vec, align 8
  %969 = load i64, ptr %arg2.addr, align 8
  %970 = load i64, ptr %arg3.addr, align 8
  call void @unlock_iovec(ptr noundef %968, i64 noundef %969, i64 noundef %970, i32 noundef 1)
  br label %if.end1570

if.else1565:                                      ; preds = %sw.bb1556
  %call1566 = call ptr @__errno_location() #13
  %971 = load i32, ptr %call1566, align 4
  %call1567 = call i32 @host_to_target_errno(i32 noundef %971)
  %sub1568 = sub i32 0, %call1567
  %conv1569 = sext i32 %sub1568 to i64
  store i64 %conv1569, ptr %ret, align 8
  br label %if.end1570

if.end1570:                                       ; preds = %if.else1565, %if.then1560
  %972 = load i64, ptr %ret, align 8
  store i64 %972, ptr %retval, align 8
  br label %return

sw.bb1571:                                        ; preds = %entry
  %973 = load i64, ptr %arg2.addr, align 8
  %974 = load i64, ptr %arg3.addr, align 8
  %call1573 = call ptr @lock_iovec(i32 noundef 1, i64 noundef %973, i64 noundef %974, i32 noundef 1)
  store ptr %call1573, ptr %vec1572, align 8
  %975 = load ptr, ptr %vec1572, align 8
  %cmp1574 = icmp ne ptr %975, null
  br i1 %cmp1574, label %if.then1576, label %if.else1581

if.then1576:                                      ; preds = %sw.bb1571
  %976 = load i64, ptr %arg1.addr, align 8
  %conv1577 = trunc i64 %976 to i32
  %977 = load ptr, ptr %vec1572, align 8
  %978 = load i64, ptr %arg3.addr, align 8
  %conv1578 = trunc i64 %978 to i32
  %call1579 = call i64 @safe_writev(i32 noundef %conv1577, ptr noundef %977, i32 noundef %conv1578)
  %call1580 = call i64 @get_errno(i64 noundef %call1579)
  store i64 %call1580, ptr %ret, align 8
  %979 = load ptr, ptr %vec1572, align 8
  %980 = load i64, ptr %arg2.addr, align 8
  %981 = load i64, ptr %arg3.addr, align 8
  call void @unlock_iovec(ptr noundef %979, i64 noundef %980, i64 noundef %981, i32 noundef 0)
  br label %if.end1586

if.else1581:                                      ; preds = %sw.bb1571
  %call1582 = call ptr @__errno_location() #13
  %982 = load i32, ptr %call1582, align 4
  %call1583 = call i32 @host_to_target_errno(i32 noundef %982)
  %sub1584 = sub i32 0, %call1583
  %conv1585 = sext i32 %sub1584 to i64
  store i64 %conv1585, ptr %ret, align 8
  br label %if.end1586

if.end1586:                                       ; preds = %if.else1581, %if.then1576
  %983 = load i64, ptr %ret, align 8
  store i64 %983, ptr %retval, align 8
  br label %return

sw.bb1587:                                        ; preds = %entry
  %984 = load i64, ptr %arg2.addr, align 8
  %985 = load i64, ptr %arg3.addr, align 8
  %call1589 = call ptr @lock_iovec(i32 noundef 3, i64 noundef %984, i64 noundef %985, i32 noundef 0)
  store ptr %call1589, ptr %vec1588, align 8
  %986 = load ptr, ptr %vec1588, align 8
  %cmp1590 = icmp ne ptr %986, null
  br i1 %cmp1590, label %if.then1592, label %if.else1597

if.then1592:                                      ; preds = %sw.bb1587
  %987 = load i64, ptr %arg4.addr, align 8
  %988 = load i64, ptr %arg5.addr, align 8
  call void @target_to_host_low_high(i64 noundef %987, i64 noundef %988, ptr noundef %low, ptr noundef %high)
  %989 = load i64, ptr %arg1.addr, align 8
  %conv1593 = trunc i64 %989 to i32
  %990 = load ptr, ptr %vec1588, align 8
  %991 = load i64, ptr %arg3.addr, align 8
  %conv1594 = trunc i64 %991 to i32
  %992 = load i64, ptr %low, align 8
  %993 = load i64, ptr %high, align 8
  %call1595 = call i64 @safe_preadv(i32 noundef %conv1593, ptr noundef %990, i32 noundef %conv1594, i64 noundef %992, i64 noundef %993)
  %call1596 = call i64 @get_errno(i64 noundef %call1595)
  store i64 %call1596, ptr %ret, align 8
  %994 = load ptr, ptr %vec1588, align 8
  %995 = load i64, ptr %arg2.addr, align 8
  %996 = load i64, ptr %arg3.addr, align 8
  call void @unlock_iovec(ptr noundef %994, i64 noundef %995, i64 noundef %996, i32 noundef 1)
  br label %if.end1602

if.else1597:                                      ; preds = %sw.bb1587
  %call1598 = call ptr @__errno_location() #13
  %997 = load i32, ptr %call1598, align 4
  %call1599 = call i32 @host_to_target_errno(i32 noundef %997)
  %sub1600 = sub i32 0, %call1599
  %conv1601 = sext i32 %sub1600 to i64
  store i64 %conv1601, ptr %ret, align 8
  br label %if.end1602

if.end1602:                                       ; preds = %if.else1597, %if.then1592
  %998 = load i64, ptr %ret, align 8
  store i64 %998, ptr %retval, align 8
  br label %return

sw.bb1603:                                        ; preds = %entry
  %999 = load i64, ptr %arg2.addr, align 8
  %1000 = load i64, ptr %arg3.addr, align 8
  %call1605 = call ptr @lock_iovec(i32 noundef 1, i64 noundef %999, i64 noundef %1000, i32 noundef 1)
  store ptr %call1605, ptr %vec1604, align 8
  %1001 = load ptr, ptr %vec1604, align 8
  %cmp1606 = icmp ne ptr %1001, null
  br i1 %cmp1606, label %if.then1608, label %if.else1615

if.then1608:                                      ; preds = %sw.bb1603
  %1002 = load i64, ptr %arg4.addr, align 8
  %1003 = load i64, ptr %arg5.addr, align 8
  call void @target_to_host_low_high(i64 noundef %1002, i64 noundef %1003, ptr noundef %low1609, ptr noundef %high1610)
  %1004 = load i64, ptr %arg1.addr, align 8
  %conv1611 = trunc i64 %1004 to i32
  %1005 = load ptr, ptr %vec1604, align 8
  %1006 = load i64, ptr %arg3.addr, align 8
  %conv1612 = trunc i64 %1006 to i32
  %1007 = load i64, ptr %low1609, align 8
  %1008 = load i64, ptr %high1610, align 8
  %call1613 = call i64 @safe_pwritev(i32 noundef %conv1611, ptr noundef %1005, i32 noundef %conv1612, i64 noundef %1007, i64 noundef %1008)
  %call1614 = call i64 @get_errno(i64 noundef %call1613)
  store i64 %call1614, ptr %ret, align 8
  %1009 = load ptr, ptr %vec1604, align 8
  %1010 = load i64, ptr %arg2.addr, align 8
  %1011 = load i64, ptr %arg3.addr, align 8
  call void @unlock_iovec(ptr noundef %1009, i64 noundef %1010, i64 noundef %1011, i32 noundef 0)
  br label %if.end1620

if.else1615:                                      ; preds = %sw.bb1603
  %call1616 = call ptr @__errno_location() #13
  %1012 = load i32, ptr %call1616, align 4
  %call1617 = call i32 @host_to_target_errno(i32 noundef %1012)
  %sub1618 = sub i32 0, %call1617
  %conv1619 = sext i32 %sub1618 to i64
  store i64 %conv1619, ptr %ret, align 8
  br label %if.end1620

if.end1620:                                       ; preds = %if.else1615, %if.then1608
  %1013 = load i64, ptr %ret, align 8
  store i64 %1013, ptr %retval, align 8
  br label %return

sw.bb1621:                                        ; preds = %entry
  %1014 = load i64, ptr %arg1.addr, align 8
  %conv1622 = trunc i64 %1014 to i32
  %call1623 = call i32 @getsid(i32 noundef %conv1622) #14
  %conv1624 = sext i32 %call1623 to i64
  %call1625 = call i64 @get_errno(i64 noundef %conv1624)
  store i64 %call1625, ptr %retval, align 8
  br label %return

sw.bb1626:                                        ; preds = %entry
  %1015 = load i64, ptr %arg1.addr, align 8
  %conv1627 = trunc i64 %1015 to i32
  %call1628 = call i32 @fdatasync(i32 noundef %conv1627)
  %conv1629 = sext i32 %call1628 to i64
  %call1630 = call i64 @get_errno(i64 noundef %conv1629)
  store i64 %call1630, ptr %retval, align 8
  br label %return

sw.bb1631:                                        ; preds = %entry
  %1016 = load i64, ptr %arg2.addr, align 8
  %and1632 = and i64 %1016, 7
  %tobool1633 = icmp ne i64 %and1632, 0
  br i1 %tobool1633, label %if.then1634, label %if.end1635

if.then1634:                                      ; preds = %sw.bb1631
  store i64 -22, ptr %retval, align 8
  br label %return

if.end1635:                                       ; preds = %sw.bb1631
  %1017 = load i64, ptr %arg2.addr, align 8
  %add1636 = add i64 %1017, 7
  %and1637 = and i64 %add1636, -8
  %conv1638 = trunc i64 %and1637 to i32
  store i32 %conv1638, ptr %mask_size, align 4
  %1018 = load i32, ptr %mask_size, align 4
  %conv1639 = zext i32 %1018 to i64
  %1019 = alloca i8, i64 %conv1639, align 16
  store ptr %1019, ptr %mask, align 8
  %1020 = load ptr, ptr %mask, align 8
  %1021 = load i32, ptr %mask_size, align 4
  %conv1640 = zext i32 %1021 to i64
  call void @llvm.memset.p0.i64(ptr align 8 %1020, i8 0, i64 %conv1640, i1 false)
  %1022 = load i64, ptr %arg1.addr, align 8
  %conv1641 = trunc i64 %1022 to i32
  %1023 = load i32, ptr %mask_size, align 4
  %1024 = load ptr, ptr %mask, align 8
  %call1642 = call i32 @sys_sched_getaffinity(i32 noundef %conv1641, i32 noundef %1023, ptr noundef %1024)
  %conv1643 = sext i32 %call1642 to i64
  %call1644 = call i64 @get_errno(i64 noundef %conv1643)
  store i64 %call1644, ptr %ret, align 8
  %1025 = load i64, ptr %ret, align 8
  %call1645 = call i32 @is_error(i64 noundef %1025)
  %tobool1646 = icmp ne i32 %call1645, 0
  br i1 %tobool1646, label %if.end1664, label %if.then1647

if.then1647:                                      ; preds = %if.end1635
  %1026 = load i64, ptr %ret, align 8
  %1027 = load i64, ptr %arg2.addr, align 8
  %cmp1648 = icmp sgt i64 %1026, %1027
  br i1 %cmp1648, label %if.then1650, label %if.end1658

if.then1650:                                      ; preds = %if.then1647
  %call1651 = call i64 @sysconf(i32 noundef 83) #14
  %conv1652 = trunc i64 %call1651 to i32
  store i32 %conv1652, ptr %numcpus, align 4
  %1028 = load i32, ptr %numcpus, align 4
  %conv1653 = sext i32 %1028 to i64
  %1029 = load i64, ptr %arg2.addr, align 8
  %mul = mul i64 %1029, 8
  %cmp1654 = icmp sgt i64 %conv1653, %mul
  br i1 %cmp1654, label %if.then1656, label %if.end1657

if.then1656:                                      ; preds = %if.then1650
  store i64 -22, ptr %retval, align 8
  br label %return

if.end1657:                                       ; preds = %if.then1650
  %1030 = load i64, ptr %arg2.addr, align 8
  store i64 %1030, ptr %ret, align 8
  br label %if.end1658

if.end1658:                                       ; preds = %if.end1657, %if.then1647
  %1031 = load ptr, ptr %mask, align 8
  %1032 = load i32, ptr %mask_size, align 4
  %conv1659 = zext i32 %1032 to i64
  %1033 = load i64, ptr %arg3.addr, align 8
  %1034 = load i64, ptr %ret, align 8
  %call1660 = call i32 @host_to_target_cpu_mask(ptr noundef %1031, i64 noundef %conv1659, i64 noundef %1033, i64 noundef %1034)
  %tobool1661 = icmp ne i32 %call1660, 0
  br i1 %tobool1661, label %if.then1662, label %if.end1663

if.then1662:                                      ; preds = %if.end1658
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1663:                                       ; preds = %if.end1658
  br label %if.end1664

if.end1664:                                       ; preds = %if.end1663, %if.end1635
  %1035 = load i64, ptr %ret, align 8
  store i64 %1035, ptr %retval, align 8
  br label %return

sw.bb1665:                                        ; preds = %entry
  %1036 = load i64, ptr %arg2.addr, align 8
  %and1668 = and i64 %1036, 7
  %tobool1669 = icmp ne i64 %and1668, 0
  br i1 %tobool1669, label %if.then1670, label %if.end1671

if.then1670:                                      ; preds = %sw.bb1665
  store i64 -22, ptr %retval, align 8
  br label %return

if.end1671:                                       ; preds = %sw.bb1665
  %1037 = load i64, ptr %arg2.addr, align 8
  %add1672 = add i64 %1037, 7
  %and1673 = and i64 %add1672, -8
  %conv1674 = trunc i64 %and1673 to i32
  store i32 %conv1674, ptr %mask_size1666, align 4
  %1038 = load i32, ptr %mask_size1666, align 4
  %conv1675 = zext i32 %1038 to i64
  %1039 = alloca i8, i64 %conv1675, align 16
  store ptr %1039, ptr %mask1667, align 8
  %1040 = load ptr, ptr %mask1667, align 8
  %1041 = load i32, ptr %mask_size1666, align 4
  %conv1676 = zext i32 %1041 to i64
  %1042 = load i64, ptr %arg3.addr, align 8
  %1043 = load i64, ptr %arg2.addr, align 8
  %call1677 = call i32 @target_to_host_cpu_mask(ptr noundef %1040, i64 noundef %conv1676, i64 noundef %1042, i64 noundef %1043)
  %conv1678 = sext i32 %call1677 to i64
  store i64 %conv1678, ptr %ret, align 8
  %1044 = load i64, ptr %ret, align 8
  %tobool1679 = icmp ne i64 %1044, 0
  br i1 %tobool1679, label %if.then1680, label %if.end1681

if.then1680:                                      ; preds = %if.end1671
  %1045 = load i64, ptr %ret, align 8
  store i64 %1045, ptr %retval, align 8
  br label %return

if.end1681:                                       ; preds = %if.end1671
  %1046 = load i64, ptr %arg1.addr, align 8
  %conv1682 = trunc i64 %1046 to i32
  %1047 = load i32, ptr %mask_size1666, align 4
  %1048 = load ptr, ptr %mask1667, align 8
  %call1683 = call i32 @sys_sched_setaffinity(i32 noundef %conv1682, i32 noundef %1047, ptr noundef %1048)
  %conv1684 = sext i32 %call1683 to i64
  %call1685 = call i64 @get_errno(i64 noundef %conv1684)
  store i64 %call1685, ptr %retval, align 8
  br label %return

sw.bb1686:                                        ; preds = %entry
  %1049 = load i64, ptr %arg1.addr, align 8
  %tobool1688 = icmp ne i64 %1049, 0
  br i1 %tobool1688, label %cond.true1689, label %cond.false1690

cond.true1689:                                    ; preds = %sw.bb1686
  br label %cond.end1691

cond.false1690:                                   ; preds = %sw.bb1686
  br label %cond.end1691

cond.end1691:                                     ; preds = %cond.false1690, %cond.true1689
  %cond1692 = phi ptr [ %cpuid, %cond.true1689 ], [ null, %cond.false1690 ]
  %1050 = load i64, ptr %arg2.addr, align 8
  %tobool1693 = icmp ne i64 %1050, 0
  br i1 %tobool1693, label %cond.true1694, label %cond.false1695

cond.true1694:                                    ; preds = %cond.end1691
  br label %cond.end1696

cond.false1695:                                   ; preds = %cond.end1691
  br label %cond.end1696

cond.end1696:                                     ; preds = %cond.false1695, %cond.true1694
  %cond1697 = phi ptr [ %node1687, %cond.true1694 ], [ null, %cond.false1695 ]
  %call1698 = call i32 @sys_getcpu(ptr noundef %cond1692, ptr noundef %cond1697, ptr noundef null)
  %conv1699 = sext i32 %call1698 to i64
  %call1700 = call i64 @get_errno(i64 noundef %conv1699)
  store i64 %call1700, ptr %ret, align 8
  %1051 = load i64, ptr %ret, align 8
  %call1701 = call i32 @is_error(i64 noundef %1051)
  %tobool1702 = icmp ne i32 %call1701, 0
  br i1 %tobool1702, label %if.then1703, label %if.end1704

if.then1703:                                      ; preds = %cond.end1696
  %1052 = load i64, ptr %ret, align 8
  store i64 %1052, ptr %retval, align 8
  br label %return

if.end1704:                                       ; preds = %cond.end1696
  %1053 = load i64, ptr %arg1.addr, align 8
  %tobool1705 = icmp ne i64 %1053, 0
  br i1 %tobool1705, label %land.lhs.true1706, label %if.end1720

land.lhs.true1706:                                ; preds = %if.end1704
  %1054 = load i64, ptr %arg1.addr, align 8
  store i64 %1054, ptr %__gaddr1707, align 8
  store i64 0, ptr %__ret1709, align 8
  %1055 = load i64, ptr %__gaddr1707, align 8
  %call1710 = call ptr @lock_user(i32 noundef 3, i64 noundef %1055, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call1710, ptr %__hptr1708, align 8
  %tobool1711 = icmp ne ptr %call1710, null
  br i1 %tobool1711, label %if.then1712, label %if.else1715

if.then1712:                                      ; preds = %land.lhs.true1706
  br label %do.body1713

do.body1713:                                      ; preds = %if.then1712
  %1056 = load ptr, ptr %__hptr1708, align 8
  %1057 = load i32, ptr %cpuid, align 4
  call void @stl_le_p(ptr noundef %1056, i32 noundef %1057)
  br label %do.end1714

do.end1714:                                       ; preds = %do.body1713
  %1058 = load ptr, ptr %__hptr1708, align 8
  %1059 = load i64, ptr %__gaddr1707, align 8
  call void @unlock_user(ptr noundef %1058, i64 noundef %1059, i64 noundef 4)
  br label %if.end1716

if.else1715:                                      ; preds = %land.lhs.true1706
  store i64 -14, ptr %__ret1709, align 8
  br label %if.end1716

if.end1716:                                       ; preds = %if.else1715, %do.end1714
  %1060 = load i64, ptr %__ret1709, align 8
  store i64 %1060, ptr %tmp1717, align 8
  %1061 = load i64, ptr %tmp1717, align 8
  %tobool1718 = icmp ne i64 %1061, 0
  br i1 %tobool1718, label %if.then1719, label %if.end1720

if.then1719:                                      ; preds = %if.end1716
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1720:                                       ; preds = %if.end1716, %if.end1704
  %1062 = load i64, ptr %arg2.addr, align 8
  %tobool1721 = icmp ne i64 %1062, 0
  br i1 %tobool1721, label %land.lhs.true1722, label %if.end1736

land.lhs.true1722:                                ; preds = %if.end1720
  %1063 = load i64, ptr %arg2.addr, align 8
  store i64 %1063, ptr %__gaddr1723, align 8
  store i64 0, ptr %__ret1725, align 8
  %1064 = load i64, ptr %__gaddr1723, align 8
  %call1726 = call ptr @lock_user(i32 noundef 3, i64 noundef %1064, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call1726, ptr %__hptr1724, align 8
  %tobool1727 = icmp ne ptr %call1726, null
  br i1 %tobool1727, label %if.then1728, label %if.else1731

if.then1728:                                      ; preds = %land.lhs.true1722
  br label %do.body1729

do.body1729:                                      ; preds = %if.then1728
  %1065 = load ptr, ptr %__hptr1724, align 8
  %1066 = load i32, ptr %node1687, align 4
  call void @stl_le_p(ptr noundef %1065, i32 noundef %1066)
  br label %do.end1730

do.end1730:                                       ; preds = %do.body1729
  %1067 = load ptr, ptr %__hptr1724, align 8
  %1068 = load i64, ptr %__gaddr1723, align 8
  call void @unlock_user(ptr noundef %1067, i64 noundef %1068, i64 noundef 4)
  br label %if.end1732

if.else1731:                                      ; preds = %land.lhs.true1722
  store i64 -14, ptr %__ret1725, align 8
  br label %if.end1732

if.end1732:                                       ; preds = %if.else1731, %do.end1730
  %1069 = load i64, ptr %__ret1725, align 8
  store i64 %1069, ptr %tmp1733, align 8
  %1070 = load i64, ptr %tmp1733, align 8
  %tobool1734 = icmp ne i64 %1070, 0
  br i1 %tobool1734, label %if.then1735, label %if.end1736

if.then1735:                                      ; preds = %if.end1732
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1736:                                       ; preds = %if.end1732, %if.end1720
  %1071 = load i64, ptr %ret, align 8
  store i64 %1071, ptr %retval, align 8
  br label %return

sw.bb1737:                                        ; preds = %entry
  %1072 = load i64, ptr %arg2.addr, align 8
  %cmp1738 = icmp eq i64 %1072, 0
  br i1 %cmp1738, label %if.then1740, label %if.end1741

if.then1740:                                      ; preds = %sw.bb1737
  store i64 -22, ptr %retval, align 8
  br label %return

if.end1741:                                       ; preds = %sw.bb1737
  %1073 = load i64, ptr %arg2.addr, align 8
  %call1742 = call ptr @lock_user(i32 noundef 1, i64 noundef %1073, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call1742, ptr %target_schp, align 8
  %tobool1743 = icmp ne ptr %call1742, null
  br i1 %tobool1743, label %if.end1745, label %if.then1744

if.then1744:                                      ; preds = %if.end1741
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1745:                                       ; preds = %if.end1741
  %1074 = load ptr, ptr %target_schp, align 8
  %sched_priority = getelementptr inbounds %struct.target_sched_param, ptr %1074, i32 0, i32 0
  %1075 = load i32, ptr %sched_priority, align 4
  %call1746 = call i32 @tswap32(i32 noundef %1075)
  %sched_priority1747 = getelementptr inbounds %struct.sched_param, ptr %schp, i32 0, i32 0
  store i32 %call1746, ptr %sched_priority1747, align 4
  %1076 = load ptr, ptr %target_schp, align 8
  %1077 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1076, i64 noundef %1077, i64 noundef 0)
  %1078 = load i64, ptr %arg1.addr, align 8
  %conv1748 = trunc i64 %1078 to i32
  %call1749 = call i32 @sys_sched_setparam(i32 noundef %conv1748, ptr noundef %schp)
  %conv1750 = sext i32 %call1749 to i64
  %call1751 = call i64 @get_errno(i64 noundef %conv1750)
  store i64 %call1751, ptr %retval, align 8
  br label %return

sw.bb1752:                                        ; preds = %entry
  %1079 = load i64, ptr %arg2.addr, align 8
  %cmp1755 = icmp eq i64 %1079, 0
  br i1 %cmp1755, label %if.then1757, label %if.end1758

if.then1757:                                      ; preds = %sw.bb1752
  store i64 -22, ptr %retval, align 8
  br label %return

if.end1758:                                       ; preds = %sw.bb1752
  %1080 = load i64, ptr %arg1.addr, align 8
  %conv1759 = trunc i64 %1080 to i32
  %call1760 = call i32 @sys_sched_getparam(i32 noundef %conv1759, ptr noundef %schp1754)
  %conv1761 = sext i32 %call1760 to i64
  %call1762 = call i64 @get_errno(i64 noundef %conv1761)
  store i64 %call1762, ptr %ret, align 8
  %1081 = load i64, ptr %ret, align 8
  %call1763 = call i32 @is_error(i64 noundef %1081)
  %tobool1764 = icmp ne i32 %call1763, 0
  br i1 %tobool1764, label %if.end1773, label %if.then1765

if.then1765:                                      ; preds = %if.end1758
  %1082 = load i64, ptr %arg2.addr, align 8
  %call1766 = call ptr @lock_user(i32 noundef 3, i64 noundef %1082, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call1766, ptr %target_schp1753, align 8
  %tobool1767 = icmp ne ptr %call1766, null
  br i1 %tobool1767, label %if.end1769, label %if.then1768

if.then1768:                                      ; preds = %if.then1765
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1769:                                       ; preds = %if.then1765
  %sched_priority1770 = getelementptr inbounds %struct.sched_param, ptr %schp1754, i32 0, i32 0
  %1083 = load i32, ptr %sched_priority1770, align 4
  %call1771 = call i32 @tswap32(i32 noundef %1083)
  %1084 = load ptr, ptr %target_schp1753, align 8
  %sched_priority1772 = getelementptr inbounds %struct.target_sched_param, ptr %1084, i32 0, i32 0
  store i32 %call1771, ptr %sched_priority1772, align 4
  %1085 = load ptr, ptr %target_schp1753, align 8
  %1086 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1085, i64 noundef %1086, i64 noundef 4)
  br label %if.end1773

if.end1773:                                       ; preds = %if.end1769, %if.end1758
  %1087 = load i64, ptr %ret, align 8
  store i64 %1087, ptr %retval, align 8
  br label %return

sw.bb1774:                                        ; preds = %entry
  %1088 = load i64, ptr %arg3.addr, align 8
  %cmp1777 = icmp eq i64 %1088, 0
  br i1 %cmp1777, label %if.then1779, label %if.end1780

if.then1779:                                      ; preds = %sw.bb1774
  store i64 -22, ptr %retval, align 8
  br label %return

if.end1780:                                       ; preds = %sw.bb1774
  %1089 = load i64, ptr %arg3.addr, align 8
  %call1781 = call ptr @lock_user(i32 noundef 1, i64 noundef %1089, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call1781, ptr %target_schp1775, align 8
  %tobool1782 = icmp ne ptr %call1781, null
  br i1 %tobool1782, label %if.end1784, label %if.then1783

if.then1783:                                      ; preds = %if.end1780
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1784:                                       ; preds = %if.end1780
  %1090 = load ptr, ptr %target_schp1775, align 8
  %sched_priority1785 = getelementptr inbounds %struct.target_sched_param, ptr %1090, i32 0, i32 0
  %1091 = load i32, ptr %sched_priority1785, align 4
  %call1786 = call i32 @tswap32(i32 noundef %1091)
  %sched_priority1787 = getelementptr inbounds %struct.sched_param, ptr %schp1776, i32 0, i32 0
  store i32 %call1786, ptr %sched_priority1787, align 4
  %1092 = load ptr, ptr %target_schp1775, align 8
  %1093 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %1092, i64 noundef %1093, i64 noundef 0)
  %1094 = load i64, ptr %arg1.addr, align 8
  %conv1788 = trunc i64 %1094 to i32
  %1095 = load i64, ptr %arg2.addr, align 8
  %conv1789 = trunc i64 %1095 to i32
  %call1790 = call i32 @sys_sched_setscheduler(i32 noundef %conv1788, i32 noundef %conv1789, ptr noundef %schp1776)
  %conv1791 = sext i32 %call1790 to i64
  %call1792 = call i64 @get_errno(i64 noundef %conv1791)
  store i64 %call1792, ptr %retval, align 8
  br label %return

sw.bb1793:                                        ; preds = %entry
  %1096 = load i64, ptr %arg1.addr, align 8
  %conv1794 = trunc i64 %1096 to i32
  %call1795 = call i32 @sys_sched_getscheduler(i32 noundef %conv1794)
  %conv1796 = sext i32 %call1795 to i64
  %call1797 = call i64 @get_errno(i64 noundef %conv1796)
  store i64 %call1797, ptr %retval, align 8
  br label %return

sw.bb1798:                                        ; preds = %entry
  %1097 = load i64, ptr %arg2.addr, align 8
  %cmp1799 = icmp eq i64 %1097, 0
  br i1 %cmp1799, label %if.then1801, label %if.end1802

if.then1801:                                      ; preds = %sw.bb1798
  store i64 -22, ptr %retval, align 8
  br label %return

if.end1802:                                       ; preds = %sw.bb1798
  %1098 = load i64, ptr %arg3.addr, align 8
  %cmp1803 = icmp ugt i64 %1098, 56
  br i1 %cmp1803, label %if.then1805, label %if.end1806

if.then1805:                                      ; preds = %if.end1802
  store i64 56, ptr %arg3.addr, align 8
  br label %if.end1806

if.end1806:                                       ; preds = %if.then1805, %if.end1802
  %1099 = load i64, ptr %arg1.addr, align 8
  %conv1807 = trunc i64 %1099 to i32
  %1100 = load i64, ptr %arg3.addr, align 8
  %conv1808 = trunc i64 %1100 to i32
  %1101 = load i64, ptr %arg4.addr, align 8
  %conv1809 = trunc i64 %1101 to i32
  %call1810 = call i32 @sys_sched_getattr(i32 noundef %conv1807, ptr noundef %scha, i32 noundef %conv1808, i32 noundef %conv1809)
  %conv1811 = sext i32 %call1810 to i64
  %call1812 = call i64 @get_errno(i64 noundef %conv1811)
  store i64 %call1812, ptr %ret, align 8
  %1102 = load i64, ptr %ret, align 8
  %call1813 = call i32 @is_error(i64 noundef %1102)
  %tobool1814 = icmp ne i32 %call1813, 0
  br i1 %tobool1814, label %if.end1847, label %if.then1815

if.then1815:                                      ; preds = %if.end1806
  %1103 = load i64, ptr %arg2.addr, align 8
  %1104 = load i64, ptr %arg3.addr, align 8
  %call1816 = call ptr @lock_user(i32 noundef 3, i64 noundef %1103, i64 noundef %1104, i1 noundef zeroext false)
  store ptr %call1816, ptr %target_scha, align 8
  %1105 = load ptr, ptr %target_scha, align 8
  %tobool1817 = icmp ne ptr %1105, null
  br i1 %tobool1817, label %if.end1819, label %if.then1818

if.then1818:                                      ; preds = %if.then1815
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1819:                                       ; preds = %if.then1815
  %size = getelementptr inbounds %struct.sched_attr, ptr %scha, i32 0, i32 0
  %1106 = load i32, ptr %size, align 8
  %call1820 = call i32 @tswap32(i32 noundef %1106)
  %1107 = load ptr, ptr %target_scha, align 8
  %size1821 = getelementptr inbounds %struct.target_sched_attr, ptr %1107, i32 0, i32 0
  store i32 %call1820, ptr %size1821, align 8
  %sched_policy = getelementptr inbounds %struct.sched_attr, ptr %scha, i32 0, i32 1
  %1108 = load i32, ptr %sched_policy, align 4
  %call1822 = call i32 @tswap32(i32 noundef %1108)
  %1109 = load ptr, ptr %target_scha, align 8
  %sched_policy1823 = getelementptr inbounds %struct.target_sched_attr, ptr %1109, i32 0, i32 1
  store i32 %call1822, ptr %sched_policy1823, align 4
  %sched_flags = getelementptr inbounds %struct.sched_attr, ptr %scha, i32 0, i32 2
  %1110 = load i64, ptr %sched_flags, align 8
  %call1824 = call i64 @tswap64(i64 noundef %1110)
  %1111 = load ptr, ptr %target_scha, align 8
  %sched_flags1825 = getelementptr inbounds %struct.target_sched_attr, ptr %1111, i32 0, i32 2
  store i64 %call1824, ptr %sched_flags1825, align 8
  %sched_nice = getelementptr inbounds %struct.sched_attr, ptr %scha, i32 0, i32 3
  %1112 = load i32, ptr %sched_nice, align 8
  %call1826 = call i32 @tswap32(i32 noundef %1112)
  %1113 = load ptr, ptr %target_scha, align 8
  %sched_nice1827 = getelementptr inbounds %struct.target_sched_attr, ptr %1113, i32 0, i32 3
  store i32 %call1826, ptr %sched_nice1827, align 8
  %sched_priority1828 = getelementptr inbounds %struct.sched_attr, ptr %scha, i32 0, i32 4
  %1114 = load i32, ptr %sched_priority1828, align 4
  %call1829 = call i32 @tswap32(i32 noundef %1114)
  %1115 = load ptr, ptr %target_scha, align 8
  %sched_priority1830 = getelementptr inbounds %struct.target_sched_attr, ptr %1115, i32 0, i32 4
  store i32 %call1829, ptr %sched_priority1830, align 4
  %sched_runtime = getelementptr inbounds %struct.sched_attr, ptr %scha, i32 0, i32 5
  %1116 = load i64, ptr %sched_runtime, align 8
  %call1831 = call i64 @tswap64(i64 noundef %1116)
  %1117 = load ptr, ptr %target_scha, align 8
  %sched_runtime1832 = getelementptr inbounds %struct.target_sched_attr, ptr %1117, i32 0, i32 5
  store i64 %call1831, ptr %sched_runtime1832, align 8
  %sched_deadline = getelementptr inbounds %struct.sched_attr, ptr %scha, i32 0, i32 6
  %1118 = load i64, ptr %sched_deadline, align 8
  %call1833 = call i64 @tswap64(i64 noundef %1118)
  %1119 = load ptr, ptr %target_scha, align 8
  %sched_deadline1834 = getelementptr inbounds %struct.target_sched_attr, ptr %1119, i32 0, i32 6
  store i64 %call1833, ptr %sched_deadline1834, align 8
  %sched_period = getelementptr inbounds %struct.sched_attr, ptr %scha, i32 0, i32 7
  %1120 = load i64, ptr %sched_period, align 8
  %call1835 = call i64 @tswap64(i64 noundef %1120)
  %1121 = load ptr, ptr %target_scha, align 8
  %sched_period1836 = getelementptr inbounds %struct.target_sched_attr, ptr %1121, i32 0, i32 7
  store i64 %call1835, ptr %sched_period1836, align 8
  %size1837 = getelementptr inbounds %struct.sched_attr, ptr %scha, i32 0, i32 0
  %1122 = load i32, ptr %size1837, align 8
  %conv1838 = zext i32 %1122 to i64
  %cmp1839 = icmp ugt i64 %conv1838, 48
  br i1 %cmp1839, label %if.then1841, label %if.end1846

if.then1841:                                      ; preds = %if.end1819
  %sched_util_min = getelementptr inbounds %struct.sched_attr, ptr %scha, i32 0, i32 8
  %1123 = load i32, ptr %sched_util_min, align 8
  %call1842 = call i32 @tswap32(i32 noundef %1123)
  %1124 = load ptr, ptr %target_scha, align 8
  %sched_util_min1843 = getelementptr inbounds %struct.target_sched_attr, ptr %1124, i32 0, i32 8
  store i32 %call1842, ptr %sched_util_min1843, align 8
  %sched_util_max = getelementptr inbounds %struct.sched_attr, ptr %scha, i32 0, i32 9
  %1125 = load i32, ptr %sched_util_max, align 4
  %call1844 = call i32 @tswap32(i32 noundef %1125)
  %1126 = load ptr, ptr %target_scha, align 8
  %sched_util_max1845 = getelementptr inbounds %struct.target_sched_attr, ptr %1126, i32 0, i32 9
  store i32 %call1844, ptr %sched_util_max1845, align 4
  br label %if.end1846

if.end1846:                                       ; preds = %if.then1841, %if.end1819
  %1127 = load ptr, ptr %target_scha, align 8
  %1128 = load i64, ptr %arg2.addr, align 8
  %1129 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %1127, i64 noundef %1128, i64 noundef %1129)
  br label %if.end1847

if.end1847:                                       ; preds = %if.end1846, %if.end1806
  %1130 = load i64, ptr %ret, align 8
  store i64 %1130, ptr %retval, align 8
  br label %return

sw.bb1848:                                        ; preds = %entry
  %1131 = load i64, ptr %arg2.addr, align 8
  %cmp1852 = icmp eq i64 %1131, 0
  br i1 %cmp1852, label %if.then1854, label %if.end1855

if.then1854:                                      ; preds = %sw.bb1848
  store i64 -22, ptr %retval, align 8
  br label %return

if.end1855:                                       ; preds = %sw.bb1848
  %1132 = load i64, ptr %arg2.addr, align 8
  store i64 %1132, ptr %__gaddr1856, align 8
  store i64 0, ptr %__ret1858, align 8
  %1133 = load i64, ptr %__gaddr1856, align 8
  %call1859 = call ptr @lock_user(i32 noundef 1, i64 noundef %1133, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call1859, ptr %__hptr1857, align 8
  %tobool1860 = icmp ne ptr %call1859, null
  br i1 %tobool1860, label %if.then1861, label %if.else1865

if.then1861:                                      ; preds = %if.end1855
  br label %do.body1862

do.body1862:                                      ; preds = %if.then1861
  %1134 = load ptr, ptr %__hptr1857, align 8
  %call1863 = call i32 @ldl_le_p(ptr noundef %1134)
  store i32 %call1863, ptr %size1851, align 4
  br label %do.end1864

do.end1864:                                       ; preds = %do.body1862
  %1135 = load ptr, ptr %__hptr1857, align 8
  %1136 = load i64, ptr %__gaddr1856, align 8
  call void @unlock_user(ptr noundef %1135, i64 noundef %1136, i64 noundef 0)
  br label %if.end1866

if.else1865:                                      ; preds = %if.end1855
  store i32 0, ptr %size1851, align 4
  store i64 -14, ptr %__ret1858, align 8
  br label %if.end1866

if.end1866:                                       ; preds = %if.else1865, %do.end1864
  %1137 = load i64, ptr %__ret1858, align 8
  store i64 %1137, ptr %tmp1867, align 8
  %1138 = load i64, ptr %tmp1867, align 8
  %tobool1868 = icmp ne i64 %1138, 0
  br i1 %tobool1868, label %if.then1869, label %if.end1870

if.then1869:                                      ; preds = %if.end1866
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1870:                                       ; preds = %if.end1866
  %1139 = load i32, ptr %size1851, align 4
  %tobool1871 = icmp ne i32 %1139, 0
  br i1 %tobool1871, label %if.end1873, label %if.then1872

if.then1872:                                      ; preds = %if.end1870
  store i32 48, ptr %size1851, align 4
  br label %if.end1873

if.end1873:                                       ; preds = %if.then1872, %if.end1870
  %1140 = load i32, ptr %size1851, align 4
  %conv1874 = zext i32 %1140 to i64
  %cmp1875 = icmp ult i64 %conv1874, 48
  br i1 %cmp1875, label %if.then1877, label %if.end1892

if.then1877:                                      ; preds = %if.end1873
  %1141 = load i64, ptr %arg2.addr, align 8
  store i64 %1141, ptr %__gaddr1878, align 8
  store i64 0, ptr %__ret1880, align 8
  %1142 = load i64, ptr %__gaddr1878, align 8
  %call1881 = call ptr @lock_user(i32 noundef 3, i64 noundef %1142, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call1881, ptr %__hptr1879, align 8
  %tobool1882 = icmp ne ptr %call1881, null
  br i1 %tobool1882, label %if.then1883, label %if.else1886

if.then1883:                                      ; preds = %if.then1877
  br label %do.body1884

do.body1884:                                      ; preds = %if.then1883
  %1143 = load ptr, ptr %__hptr1879, align 8
  call void @stl_le_p(ptr noundef %1143, i32 noundef 56)
  br label %do.end1885

do.end1885:                                       ; preds = %do.body1884
  %1144 = load ptr, ptr %__hptr1879, align 8
  %1145 = load i64, ptr %__gaddr1878, align 8
  call void @unlock_user(ptr noundef %1144, i64 noundef %1145, i64 noundef 4)
  br label %if.end1887

if.else1886:                                      ; preds = %if.then1877
  store i64 -14, ptr %__ret1880, align 8
  br label %if.end1887

if.end1887:                                       ; preds = %if.else1886, %do.end1885
  %1146 = load i64, ptr %__ret1880, align 8
  store i64 %1146, ptr %tmp1888, align 8
  %1147 = load i64, ptr %tmp1888, align 8
  %tobool1889 = icmp ne i64 %1147, 0
  br i1 %tobool1889, label %if.then1890, label %if.end1891

if.then1890:                                      ; preds = %if.end1887
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1891:                                       ; preds = %if.end1887
  store i64 -7, ptr %retval, align 8
  br label %return

if.end1892:                                       ; preds = %if.end1873
  %1148 = load i64, ptr %arg2.addr, align 8
  %1149 = load i32, ptr %size1851, align 4
  %conv1893 = zext i32 %1149 to i64
  %call1894 = call i32 @check_zeroed_user(i64 noundef %1148, i64 noundef 56, i64 noundef %conv1893)
  store i32 %call1894, ptr %zeroed, align 4
  %1150 = load i32, ptr %zeroed, align 4
  %cmp1895 = icmp slt i32 %1150, 0
  br i1 %cmp1895, label %if.then1897, label %if.else1899

if.then1897:                                      ; preds = %if.end1892
  %1151 = load i32, ptr %zeroed, align 4
  %conv1898 = sext i32 %1151 to i64
  store i64 %conv1898, ptr %retval, align 8
  br label %return

if.else1899:                                      ; preds = %if.end1892
  %1152 = load i32, ptr %zeroed, align 4
  %cmp1900 = icmp eq i32 %1152, 0
  br i1 %cmp1900, label %if.then1902, label %if.end1917

if.then1902:                                      ; preds = %if.else1899
  %1153 = load i64, ptr %arg2.addr, align 8
  store i64 %1153, ptr %__gaddr1903, align 8
  store i64 0, ptr %__ret1905, align 8
  %1154 = load i64, ptr %__gaddr1903, align 8
  %call1906 = call ptr @lock_user(i32 noundef 3, i64 noundef %1154, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call1906, ptr %__hptr1904, align 8
  %tobool1907 = icmp ne ptr %call1906, null
  br i1 %tobool1907, label %if.then1908, label %if.else1911

if.then1908:                                      ; preds = %if.then1902
  br label %do.body1909

do.body1909:                                      ; preds = %if.then1908
  %1155 = load ptr, ptr %__hptr1904, align 8
  call void @stl_le_p(ptr noundef %1155, i32 noundef 56)
  br label %do.end1910

do.end1910:                                       ; preds = %do.body1909
  %1156 = load ptr, ptr %__hptr1904, align 8
  %1157 = load i64, ptr %__gaddr1903, align 8
  call void @unlock_user(ptr noundef %1156, i64 noundef %1157, i64 noundef 4)
  br label %if.end1912

if.else1911:                                      ; preds = %if.then1902
  store i64 -14, ptr %__ret1905, align 8
  br label %if.end1912

if.end1912:                                       ; preds = %if.else1911, %do.end1910
  %1158 = load i64, ptr %__ret1905, align 8
  store i64 %1158, ptr %tmp1913, align 8
  %1159 = load i64, ptr %tmp1913, align 8
  %tobool1914 = icmp ne i64 %1159, 0
  br i1 %tobool1914, label %if.then1915, label %if.end1916

if.then1915:                                      ; preds = %if.end1912
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1916:                                       ; preds = %if.end1912
  store i64 -7, ptr %retval, align 8
  br label %return

if.end1917:                                       ; preds = %if.else1899
  br label %if.end1918

if.end1918:                                       ; preds = %if.end1917
  %1160 = load i32, ptr %size1851, align 4
  %conv1919 = zext i32 %1160 to i64
  %cmp1920 = icmp ugt i64 %conv1919, 56
  br i1 %cmp1920, label %if.then1922, label %if.end1923

if.then1922:                                      ; preds = %if.end1918
  store i32 56, ptr %size1851, align 4
  br label %if.end1923

if.end1923:                                       ; preds = %if.then1922, %if.end1918
  %1161 = load i64, ptr %arg2.addr, align 8
  %1162 = load i32, ptr %size1851, align 4
  %conv1924 = zext i32 %1162 to i64
  %call1925 = call ptr @lock_user(i32 noundef 1, i64 noundef %1161, i64 noundef %conv1924, i1 noundef zeroext true)
  store ptr %call1925, ptr %target_scha1849, align 8
  %1163 = load ptr, ptr %target_scha1849, align 8
  %tobool1926 = icmp ne ptr %1163, null
  br i1 %tobool1926, label %if.end1928, label %if.then1927

if.then1927:                                      ; preds = %if.end1923
  store i64 -14, ptr %retval, align 8
  br label %return

if.end1928:                                       ; preds = %if.end1923
  %1164 = load i32, ptr %size1851, align 4
  %size1929 = getelementptr inbounds %struct.sched_attr, ptr %scha1850, i32 0, i32 0
  store i32 %1164, ptr %size1929, align 8
  %1165 = load ptr, ptr %target_scha1849, align 8
  %sched_policy1930 = getelementptr inbounds %struct.target_sched_attr, ptr %1165, i32 0, i32 1
  %1166 = load i32, ptr %sched_policy1930, align 4
  %call1931 = call i32 @tswap32(i32 noundef %1166)
  %sched_policy1932 = getelementptr inbounds %struct.sched_attr, ptr %scha1850, i32 0, i32 1
  store i32 %call1931, ptr %sched_policy1932, align 4
  %1167 = load ptr, ptr %target_scha1849, align 8
  %sched_flags1933 = getelementptr inbounds %struct.target_sched_attr, ptr %1167, i32 0, i32 2
  %1168 = load i64, ptr %sched_flags1933, align 8
  %call1934 = call i64 @tswap64(i64 noundef %1168)
  %sched_flags1935 = getelementptr inbounds %struct.sched_attr, ptr %scha1850, i32 0, i32 2
  store i64 %call1934, ptr %sched_flags1935, align 8
  %1169 = load ptr, ptr %target_scha1849, align 8
  %sched_nice1936 = getelementptr inbounds %struct.target_sched_attr, ptr %1169, i32 0, i32 3
  %1170 = load i32, ptr %sched_nice1936, align 8
  %call1937 = call i32 @tswap32(i32 noundef %1170)
  %sched_nice1938 = getelementptr inbounds %struct.sched_attr, ptr %scha1850, i32 0, i32 3
  store i32 %call1937, ptr %sched_nice1938, align 8
  %1171 = load ptr, ptr %target_scha1849, align 8
  %sched_priority1939 = getelementptr inbounds %struct.target_sched_attr, ptr %1171, i32 0, i32 4
  %1172 = load i32, ptr %sched_priority1939, align 4
  %call1940 = call i32 @tswap32(i32 noundef %1172)
  %sched_priority1941 = getelementptr inbounds %struct.sched_attr, ptr %scha1850, i32 0, i32 4
  store i32 %call1940, ptr %sched_priority1941, align 4
  %1173 = load ptr, ptr %target_scha1849, align 8
  %sched_runtime1942 = getelementptr inbounds %struct.target_sched_attr, ptr %1173, i32 0, i32 5
  %1174 = load i64, ptr %sched_runtime1942, align 8
  %call1943 = call i64 @tswap64(i64 noundef %1174)
  %sched_runtime1944 = getelementptr inbounds %struct.sched_attr, ptr %scha1850, i32 0, i32 5
  store i64 %call1943, ptr %sched_runtime1944, align 8
  %1175 = load ptr, ptr %target_scha1849, align 8
  %sched_deadline1945 = getelementptr inbounds %struct.target_sched_attr, ptr %1175, i32 0, i32 6
  %1176 = load i64, ptr %sched_deadline1945, align 8
  %call1946 = call i64 @tswap64(i64 noundef %1176)
  %sched_deadline1947 = getelementptr inbounds %struct.sched_attr, ptr %scha1850, i32 0, i32 6
  store i64 %call1946, ptr %sched_deadline1947, align 8
  %1177 = load ptr, ptr %target_scha1849, align 8
  %sched_period1948 = getelementptr inbounds %struct.target_sched_attr, ptr %1177, i32 0, i32 7
  %1178 = load i64, ptr %sched_period1948, align 8
  %call1949 = call i64 @tswap64(i64 noundef %1178)
  %sched_period1950 = getelementptr inbounds %struct.sched_attr, ptr %scha1850, i32 0, i32 7
  store i64 %call1949, ptr %sched_period1950, align 8
  %1179 = load i32, ptr %size1851, align 4
  %conv1951 = zext i32 %1179 to i64
  %cmp1952 = icmp ugt i64 %conv1951, 48
  br i1 %cmp1952, label %if.then1954, label %if.end1961

if.then1954:                                      ; preds = %if.end1928
  %1180 = load ptr, ptr %target_scha1849, align 8
  %sched_util_min1955 = getelementptr inbounds %struct.target_sched_attr, ptr %1180, i32 0, i32 8
  %1181 = load i32, ptr %sched_util_min1955, align 8
  %call1956 = call i32 @tswap32(i32 noundef %1181)
  %sched_util_min1957 = getelementptr inbounds %struct.sched_attr, ptr %scha1850, i32 0, i32 8
  store i32 %call1956, ptr %sched_util_min1957, align 8
  %1182 = load ptr, ptr %target_scha1849, align 8
  %sched_util_max1958 = getelementptr inbounds %struct.target_sched_attr, ptr %1182, i32 0, i32 9
  %1183 = load i32, ptr %sched_util_max1958, align 4
  %call1959 = call i32 @tswap32(i32 noundef %1183)
  %sched_util_max1960 = getelementptr inbounds %struct.sched_attr, ptr %scha1850, i32 0, i32 9
  store i32 %call1959, ptr %sched_util_max1960, align 4
  br label %if.end1961

if.end1961:                                       ; preds = %if.then1954, %if.end1928
  %1184 = load ptr, ptr %target_scha1849, align 8
  %1185 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1184, i64 noundef %1185, i64 noundef 0)
  %1186 = load i64, ptr %arg1.addr, align 8
  %conv1962 = trunc i64 %1186 to i32
  %1187 = load i64, ptr %arg3.addr, align 8
  %conv1963 = trunc i64 %1187 to i32
  %call1964 = call i32 @sys_sched_setattr(i32 noundef %conv1962, ptr noundef %scha1850, i32 noundef %conv1963)
  %conv1965 = sext i32 %call1964 to i64
  %call1966 = call i64 @get_errno(i64 noundef %conv1965)
  store i64 %call1966, ptr %retval, align 8
  br label %return

sw.bb1967:                                        ; preds = %entry
  %call1968 = call i32 @sched_yield() #14
  %conv1969 = sext i32 %call1968 to i64
  %call1970 = call i64 @get_errno(i64 noundef %conv1969)
  store i64 %call1970, ptr %retval, align 8
  br label %return

sw.bb1971:                                        ; preds = %entry
  %1188 = load i64, ptr %arg1.addr, align 8
  %conv1972 = trunc i64 %1188 to i32
  %call1973 = call i32 @sched_get_priority_max(i32 noundef %conv1972) #14
  %conv1974 = sext i32 %call1973 to i64
  %call1975 = call i64 @get_errno(i64 noundef %conv1974)
  store i64 %call1975, ptr %retval, align 8
  br label %return

sw.bb1976:                                        ; preds = %entry
  %1189 = load i64, ptr %arg1.addr, align 8
  %conv1977 = trunc i64 %1189 to i32
  %call1978 = call i32 @sched_get_priority_min(i32 noundef %conv1977) #14
  %conv1979 = sext i32 %call1978 to i64
  %call1980 = call i64 @get_errno(i64 noundef %conv1979)
  store i64 %call1980, ptr %retval, align 8
  br label %return

sw.bb1981:                                        ; preds = %entry
  %1190 = load i64, ptr %arg1.addr, align 8
  %conv1983 = trunc i64 %1190 to i32
  %call1984 = call i32 @sched_rr_get_interval(i32 noundef %conv1983, ptr noundef %ts1982) #14
  %conv1985 = sext i32 %call1984 to i64
  %call1986 = call i64 @get_errno(i64 noundef %conv1985)
  store i64 %call1986, ptr %ret, align 8
  %1191 = load i64, ptr %ret, align 8
  %call1987 = call i32 @is_error(i64 noundef %1191)
  %tobool1988 = icmp ne i32 %call1987, 0
  br i1 %tobool1988, label %if.end1991, label %if.then1989

if.then1989:                                      ; preds = %sw.bb1981
  %1192 = load i64, ptr %arg2.addr, align 8
  %call1990 = call i64 @host_to_target_timespec(i64 noundef %1192, ptr noundef %ts1982)
  store i64 %call1990, ptr %ret, align 8
  br label %if.end1991

if.end1991:                                       ; preds = %if.then1989, %sw.bb1981
  %1193 = load i64, ptr %ret, align 8
  store i64 %1193, ptr %retval, align 8
  br label %return

sw.bb1992:                                        ; preds = %entry
  %1194 = load i64, ptr %arg1.addr, align 8
  %call1993 = call i64 @target_to_host_timespec(ptr noundef %req, i64 noundef %1194)
  %call1994 = call i32 @safe_nanosleep(ptr noundef %req, ptr noundef %rem)
  %conv1995 = sext i32 %call1994 to i64
  %call1996 = call i64 @get_errno(i64 noundef %conv1995)
  store i64 %call1996, ptr %ret, align 8
  %1195 = load i64, ptr %ret, align 8
  %call1997 = call i32 @is_error(i64 noundef %1195)
  %tobool1998 = icmp ne i32 %call1997, 0
  br i1 %tobool1998, label %land.lhs.true1999, label %if.end2003

land.lhs.true1999:                                ; preds = %sw.bb1992
  %1196 = load i64, ptr %arg2.addr, align 8
  %tobool2000 = icmp ne i64 %1196, 0
  br i1 %tobool2000, label %if.then2001, label %if.end2003

if.then2001:                                      ; preds = %land.lhs.true1999
  %1197 = load i64, ptr %arg2.addr, align 8
  %call2002 = call i64 @host_to_target_timespec(i64 noundef %1197, ptr noundef %rem)
  br label %if.end2003

if.end2003:                                       ; preds = %if.then2001, %land.lhs.true1999, %sw.bb1992
  %1198 = load i64, ptr %ret, align 8
  store i64 %1198, ptr %retval, align 8
  br label %return

sw.bb2004:                                        ; preds = %entry
  %1199 = load ptr, ptr %cpu_env.addr, align 8
  %1200 = load i64, ptr %arg1.addr, align 8
  %1201 = load i64, ptr %arg2.addr, align 8
  %1202 = load i64, ptr %arg3.addr, align 8
  %1203 = load i64, ptr %arg4.addr, align 8
  %1204 = load i64, ptr %arg5.addr, align 8
  %call2005 = call i64 @do_prctl(ptr noundef %1199, i64 noundef %1200, i64 noundef %1201, i64 noundef %1202, i64 noundef %1203, i64 noundef %1204)
  store i64 %call2005, ptr %retval, align 8
  br label %return

sw.bb2006:                                        ; preds = %entry
  %1205 = load ptr, ptr %cpu_env.addr, align 8
  %1206 = load i32, ptr %num.addr, align 4
  %call2007 = call i32 @regpairs_aligned(ptr noundef %1205, i32 noundef %1206)
  %tobool2008 = icmp ne i32 %call2007, 0
  br i1 %tobool2008, label %if.then2009, label %if.end2010

if.then2009:                                      ; preds = %sw.bb2006
  %1207 = load i64, ptr %arg5.addr, align 8
  store i64 %1207, ptr %arg4.addr, align 8
  %1208 = load i64, ptr %arg6.addr, align 8
  store i64 %1208, ptr %arg5.addr, align 8
  br label %if.end2010

if.end2010:                                       ; preds = %if.then2009, %sw.bb2006
  %1209 = load i64, ptr %arg2.addr, align 8
  %cmp2011 = icmp eq i64 %1209, 0
  br i1 %cmp2011, label %land.lhs.true2013, label %if.else2017

land.lhs.true2013:                                ; preds = %if.end2010
  %1210 = load i64, ptr %arg3.addr, align 8
  %cmp2014 = icmp eq i64 %1210, 0
  br i1 %cmp2014, label %if.then2016, label %if.else2017

if.then2016:                                      ; preds = %land.lhs.true2013
  store ptr null, ptr %p, align 8
  br label %if.end2022

if.else2017:                                      ; preds = %land.lhs.true2013, %if.end2010
  %1211 = load i64, ptr %arg2.addr, align 8
  %1212 = load i64, ptr %arg3.addr, align 8
  %call2018 = call ptr @lock_user(i32 noundef 3, i64 noundef %1211, i64 noundef %1212, i1 noundef zeroext false)
  store ptr %call2018, ptr %p, align 8
  %1213 = load ptr, ptr %p, align 8
  %tobool2019 = icmp ne ptr %1213, null
  br i1 %tobool2019, label %if.end2021, label %if.then2020

if.then2020:                                      ; preds = %if.else2017
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2021:                                       ; preds = %if.else2017
  br label %if.end2022

if.end2022:                                       ; preds = %if.end2021, %if.then2016
  %1214 = load i64, ptr %arg1.addr, align 8
  %conv2023 = trunc i64 %1214 to i32
  %1215 = load ptr, ptr %p, align 8
  %1216 = load i64, ptr %arg3.addr, align 8
  %1217 = load i64, ptr %arg4.addr, align 8
  %1218 = load i64, ptr %arg5.addr, align 8
  %call2024 = call i64 @target_offset64(i64 noundef %1217, i64 noundef %1218)
  %call2025 = call i64 @pread64(i32 noundef %conv2023, ptr noundef %1215, i64 noundef %1216, i64 noundef %call2024)
  %call2026 = call i64 @get_errno(i64 noundef %call2025)
  store i64 %call2026, ptr %ret, align 8
  %1219 = load ptr, ptr %p, align 8
  %1220 = load i64, ptr %arg2.addr, align 8
  %1221 = load i64, ptr %ret, align 8
  call void @unlock_user(ptr noundef %1219, i64 noundef %1220, i64 noundef %1221)
  %1222 = load i64, ptr %ret, align 8
  store i64 %1222, ptr %retval, align 8
  br label %return

sw.bb2027:                                        ; preds = %entry
  %1223 = load ptr, ptr %cpu_env.addr, align 8
  %1224 = load i32, ptr %num.addr, align 4
  %call2028 = call i32 @regpairs_aligned(ptr noundef %1223, i32 noundef %1224)
  %tobool2029 = icmp ne i32 %call2028, 0
  br i1 %tobool2029, label %if.then2030, label %if.end2031

if.then2030:                                      ; preds = %sw.bb2027
  %1225 = load i64, ptr %arg5.addr, align 8
  store i64 %1225, ptr %arg4.addr, align 8
  %1226 = load i64, ptr %arg6.addr, align 8
  store i64 %1226, ptr %arg5.addr, align 8
  br label %if.end2031

if.end2031:                                       ; preds = %if.then2030, %sw.bb2027
  %1227 = load i64, ptr %arg2.addr, align 8
  %cmp2032 = icmp eq i64 %1227, 0
  br i1 %cmp2032, label %land.lhs.true2034, label %if.else2038

land.lhs.true2034:                                ; preds = %if.end2031
  %1228 = load i64, ptr %arg3.addr, align 8
  %cmp2035 = icmp eq i64 %1228, 0
  br i1 %cmp2035, label %if.then2037, label %if.else2038

if.then2037:                                      ; preds = %land.lhs.true2034
  store ptr null, ptr %p, align 8
  br label %if.end2043

if.else2038:                                      ; preds = %land.lhs.true2034, %if.end2031
  %1229 = load i64, ptr %arg2.addr, align 8
  %1230 = load i64, ptr %arg3.addr, align 8
  %call2039 = call ptr @lock_user(i32 noundef 1, i64 noundef %1229, i64 noundef %1230, i1 noundef zeroext true)
  store ptr %call2039, ptr %p, align 8
  %1231 = load ptr, ptr %p, align 8
  %tobool2040 = icmp ne ptr %1231, null
  br i1 %tobool2040, label %if.end2042, label %if.then2041

if.then2041:                                      ; preds = %if.else2038
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2042:                                       ; preds = %if.else2038
  br label %if.end2043

if.end2043:                                       ; preds = %if.end2042, %if.then2037
  %1232 = load i64, ptr %arg1.addr, align 8
  %conv2044 = trunc i64 %1232 to i32
  %1233 = load ptr, ptr %p, align 8
  %1234 = load i64, ptr %arg3.addr, align 8
  %1235 = load i64, ptr %arg4.addr, align 8
  %1236 = load i64, ptr %arg5.addr, align 8
  %call2045 = call i64 @target_offset64(i64 noundef %1235, i64 noundef %1236)
  %call2046 = call i64 @pwrite64(i32 noundef %conv2044, ptr noundef %1233, i64 noundef %1234, i64 noundef %call2045)
  %call2047 = call i64 @get_errno(i64 noundef %call2046)
  store i64 %call2047, ptr %ret, align 8
  %1237 = load ptr, ptr %p, align 8
  %1238 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1237, i64 noundef %1238, i64 noundef 0)
  %1239 = load i64, ptr %ret, align 8
  store i64 %1239, ptr %retval, align 8
  br label %return

sw.bb2048:                                        ; preds = %entry
  %1240 = load i64, ptr %arg1.addr, align 8
  %1241 = load i64, ptr %arg2.addr, align 8
  %call2049 = call ptr @lock_user(i32 noundef 3, i64 noundef %1240, i64 noundef %1241, i1 noundef zeroext false)
  store ptr %call2049, ptr %p, align 8
  %tobool2050 = icmp ne ptr %call2049, null
  br i1 %tobool2050, label %if.end2052, label %if.then2051

if.then2051:                                      ; preds = %sw.bb2048
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2052:                                       ; preds = %sw.bb2048
  %1242 = load ptr, ptr %p, align 8
  %1243 = load i64, ptr %arg2.addr, align 8
  %call2053 = call i32 @sys_getcwd1(ptr noundef %1242, i64 noundef %1243)
  %conv2054 = sext i32 %call2053 to i64
  %call2055 = call i64 @get_errno(i64 noundef %conv2054)
  store i64 %call2055, ptr %ret, align 8
  %1244 = load ptr, ptr %p, align 8
  %1245 = load i64, ptr %arg1.addr, align 8
  %1246 = load i64, ptr %ret, align 8
  call void @unlock_user(ptr noundef %1244, i64 noundef %1245, i64 noundef %1246)
  %1247 = load i64, ptr %ret, align 8
  store i64 %1247, ptr %retval, align 8
  br label %return

sw.bb2056:                                        ; preds = %entry, %entry
  store ptr null, ptr %target_data, align 8
  store ptr null, ptr %dataptr, align 8
  store i32 1, ptr %data_items, align 4
  %1248 = load i64, ptr %arg1.addr, align 8
  %call2057 = call ptr @lock_user(i32 noundef 3, i64 noundef %1248, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call2057, ptr %target_header, align 8
  %tobool2058 = icmp ne ptr %call2057, null
  br i1 %tobool2058, label %if.end2060, label %if.then2059

if.then2059:                                      ; preds = %sw.bb2056
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2060:                                       ; preds = %sw.bb2056
  %1249 = load ptr, ptr %target_header, align 8
  %version = getelementptr inbounds %struct.target_user_cap_header, ptr %1249, i32 0, i32 0
  %1250 = load i32, ptr %version, align 4
  %call2061 = call i32 @tswap32(i32 noundef %1250)
  %version2062 = getelementptr inbounds %struct.__user_cap_header_struct, ptr %header, i32 0, i32 0
  store i32 %call2061, ptr %version2062, align 4
  %1251 = load ptr, ptr %target_header, align 8
  %pid = getelementptr inbounds %struct.target_user_cap_header, ptr %1251, i32 0, i32 1
  %1252 = load i32, ptr %pid, align 4
  %call2063 = call i32 @tswap32(i32 noundef %1252)
  %pid2064 = getelementptr inbounds %struct.__user_cap_header_struct, ptr %header, i32 0, i32 1
  store i32 %call2063, ptr %pid2064, align 4
  %version2065 = getelementptr inbounds %struct.__user_cap_header_struct, ptr %header, i32 0, i32 0
  %1253 = load i32, ptr %version2065, align 4
  %cmp2066 = icmp ne i32 %1253, 429392688
  br i1 %cmp2066, label %if.then2068, label %if.end2069

if.then2068:                                      ; preds = %if.end2060
  store i32 2, ptr %data_items, align 4
  br label %if.end2069

if.end2069:                                       ; preds = %if.then2068, %if.end2060
  %1254 = load i32, ptr %data_items, align 4
  %conv2070 = sext i32 %1254 to i64
  %mul2071 = mul i64 12, %conv2070
  %conv2072 = trunc i64 %mul2071 to i32
  store i32 %conv2072, ptr %target_datalen, align 4
  %1255 = load i64, ptr %arg2.addr, align 8
  %tobool2073 = icmp ne i64 %1255, 0
  br i1 %tobool2073, label %if.then2074, label %if.end2116

if.then2074:                                      ; preds = %if.end2069
  %1256 = load i32, ptr %num.addr, align 4
  %cmp2075 = icmp eq i32 %1256, 90
  br i1 %cmp2075, label %if.then2077, label %if.else2080

if.then2077:                                      ; preds = %if.then2074
  %1257 = load i64, ptr %arg2.addr, align 8
  %1258 = load i32, ptr %target_datalen, align 4
  %conv2078 = sext i32 %1258 to i64
  %call2079 = call ptr @lock_user(i32 noundef 3, i64 noundef %1257, i64 noundef %conv2078, i1 noundef zeroext false)
  store ptr %call2079, ptr %target_data, align 8
  br label %if.end2083

if.else2080:                                      ; preds = %if.then2074
  %1259 = load i64, ptr %arg2.addr, align 8
  %1260 = load i32, ptr %target_datalen, align 4
  %conv2081 = sext i32 %1260 to i64
  %call2082 = call ptr @lock_user(i32 noundef 1, i64 noundef %1259, i64 noundef %conv2081, i1 noundef zeroext true)
  store ptr %call2082, ptr %target_data, align 8
  br label %if.end2083

if.end2083:                                       ; preds = %if.else2080, %if.then2077
  %1261 = load ptr, ptr %target_data, align 8
  %tobool2084 = icmp ne ptr %1261, null
  br i1 %tobool2084, label %if.end2086, label %if.then2085

if.then2085:                                      ; preds = %if.end2083
  %1262 = load ptr, ptr %target_header, align 8
  %1263 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %1262, i64 noundef %1263, i64 noundef 0)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2086:                                       ; preds = %if.end2083
  %1264 = load i32, ptr %num.addr, align 4
  %cmp2087 = icmp eq i32 %1264, 91
  br i1 %cmp2087, label %if.then2089, label %if.end2114

if.then2089:                                      ; preds = %if.end2086
  store i32 0, ptr %i, align 4
  br label %for.cond2090

for.cond2090:                                     ; preds = %for.inc2111, %if.then2089
  %1265 = load i32, ptr %i, align 4
  %1266 = load i32, ptr %data_items, align 4
  %cmp2091 = icmp slt i32 %1265, %1266
  br i1 %cmp2091, label %for.body2093, label %for.end2113

for.body2093:                                     ; preds = %for.cond2090
  %1267 = load ptr, ptr %target_data, align 8
  %1268 = load i32, ptr %i, align 4
  %idxprom = sext i32 %1268 to i64
  %arrayidx2094 = getelementptr %struct.target_user_cap_data, ptr %1267, i64 %idxprom
  %effective = getelementptr inbounds %struct.target_user_cap_data, ptr %arrayidx2094, i32 0, i32 0
  %1269 = load i32, ptr %effective, align 4
  %call2095 = call i32 @tswap32(i32 noundef %1269)
  %1270 = load i32, ptr %i, align 4
  %idxprom2096 = sext i32 %1270 to i64
  %arrayidx2097 = getelementptr [2 x %struct.__user_cap_data_struct], ptr %data, i64 0, i64 %idxprom2096
  %effective2098 = getelementptr inbounds %struct.__user_cap_data_struct, ptr %arrayidx2097, i32 0, i32 0
  store i32 %call2095, ptr %effective2098, align 4
  %1271 = load ptr, ptr %target_data, align 8
  %1272 = load i32, ptr %i, align 4
  %idxprom2099 = sext i32 %1272 to i64
  %arrayidx2100 = getelementptr %struct.target_user_cap_data, ptr %1271, i64 %idxprom2099
  %permitted = getelementptr inbounds %struct.target_user_cap_data, ptr %arrayidx2100, i32 0, i32 1
  %1273 = load i32, ptr %permitted, align 4
  %call2101 = call i32 @tswap32(i32 noundef %1273)
  %1274 = load i32, ptr %i, align 4
  %idxprom2102 = sext i32 %1274 to i64
  %arrayidx2103 = getelementptr [2 x %struct.__user_cap_data_struct], ptr %data, i64 0, i64 %idxprom2102
  %permitted2104 = getelementptr inbounds %struct.__user_cap_data_struct, ptr %arrayidx2103, i32 0, i32 1
  store i32 %call2101, ptr %permitted2104, align 4
  %1275 = load ptr, ptr %target_data, align 8
  %1276 = load i32, ptr %i, align 4
  %idxprom2105 = sext i32 %1276 to i64
  %arrayidx2106 = getelementptr %struct.target_user_cap_data, ptr %1275, i64 %idxprom2105
  %inheritable = getelementptr inbounds %struct.target_user_cap_data, ptr %arrayidx2106, i32 0, i32 2
  %1277 = load i32, ptr %inheritable, align 4
  %call2107 = call i32 @tswap32(i32 noundef %1277)
  %1278 = load i32, ptr %i, align 4
  %idxprom2108 = sext i32 %1278 to i64
  %arrayidx2109 = getelementptr [2 x %struct.__user_cap_data_struct], ptr %data, i64 0, i64 %idxprom2108
  %inheritable2110 = getelementptr inbounds %struct.__user_cap_data_struct, ptr %arrayidx2109, i32 0, i32 2
  store i32 %call2107, ptr %inheritable2110, align 4
  br label %for.inc2111

for.inc2111:                                      ; preds = %for.body2093
  %1279 = load i32, ptr %i, align 4
  %inc2112 = add i32 %1279, 1
  store i32 %inc2112, ptr %i, align 4
  br label %for.cond2090, !llvm.loop !21

for.end2113:                                      ; preds = %for.cond2090
  br label %if.end2114

if.end2114:                                       ; preds = %for.end2113, %if.end2086
  %arraydecay2115 = getelementptr inbounds [2 x %struct.__user_cap_data_struct], ptr %data, i64 0, i64 0
  store ptr %arraydecay2115, ptr %dataptr, align 8
  br label %if.end2116

if.end2116:                                       ; preds = %if.end2114, %if.end2069
  %1280 = load i32, ptr %num.addr, align 4
  %cmp2117 = icmp eq i32 %1280, 90
  br i1 %cmp2117, label %if.then2119, label %if.else2123

if.then2119:                                      ; preds = %if.end2116
  %1281 = load ptr, ptr %dataptr, align 8
  %call2120 = call i32 @capget(ptr noundef %header, ptr noundef %1281)
  %conv2121 = sext i32 %call2120 to i64
  %call2122 = call i64 @get_errno(i64 noundef %conv2121)
  store i64 %call2122, ptr %ret, align 8
  br label %if.end2127

if.else2123:                                      ; preds = %if.end2116
  %1282 = load ptr, ptr %dataptr, align 8
  %call2124 = call i32 @capset(ptr noundef %header, ptr noundef %1282)
  %conv2125 = sext i32 %call2124 to i64
  %call2126 = call i64 @get_errno(i64 noundef %conv2125)
  store i64 %call2126, ptr %ret, align 8
  br label %if.end2127

if.end2127:                                       ; preds = %if.else2123, %if.then2119
  %version2128 = getelementptr inbounds %struct.__user_cap_header_struct, ptr %header, i32 0, i32 0
  %1283 = load i32, ptr %version2128, align 4
  %call2129 = call i32 @tswap32(i32 noundef %1283)
  %1284 = load ptr, ptr %target_header, align 8
  %version2130 = getelementptr inbounds %struct.target_user_cap_header, ptr %1284, i32 0, i32 0
  store i32 %call2129, ptr %version2130, align 4
  %1285 = load ptr, ptr %target_header, align 8
  %1286 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %1285, i64 noundef %1286, i64 noundef 8)
  %1287 = load i64, ptr %arg2.addr, align 8
  %tobool2131 = icmp ne i64 %1287, 0
  br i1 %tobool2131, label %if.then2132, label %if.end2167

if.then2132:                                      ; preds = %if.end2127
  %1288 = load i32, ptr %num.addr, align 4
  %cmp2133 = icmp eq i32 %1288, 90
  br i1 %cmp2133, label %if.then2135, label %if.else2165

if.then2135:                                      ; preds = %if.then2132
  store i32 0, ptr %i, align 4
  br label %for.cond2136

for.cond2136:                                     ; preds = %for.inc2161, %if.then2135
  %1289 = load i32, ptr %i, align 4
  %1290 = load i32, ptr %data_items, align 4
  %cmp2137 = icmp slt i32 %1289, %1290
  br i1 %cmp2137, label %for.body2139, label %for.end2163

for.body2139:                                     ; preds = %for.cond2136
  %1291 = load i32, ptr %i, align 4
  %idxprom2140 = sext i32 %1291 to i64
  %arrayidx2141 = getelementptr [2 x %struct.__user_cap_data_struct], ptr %data, i64 0, i64 %idxprom2140
  %effective2142 = getelementptr inbounds %struct.__user_cap_data_struct, ptr %arrayidx2141, i32 0, i32 0
  %1292 = load i32, ptr %effective2142, align 4
  %call2143 = call i32 @tswap32(i32 noundef %1292)
  %1293 = load ptr, ptr %target_data, align 8
  %1294 = load i32, ptr %i, align 4
  %idxprom2144 = sext i32 %1294 to i64
  %arrayidx2145 = getelementptr %struct.target_user_cap_data, ptr %1293, i64 %idxprom2144
  %effective2146 = getelementptr inbounds %struct.target_user_cap_data, ptr %arrayidx2145, i32 0, i32 0
  store i32 %call2143, ptr %effective2146, align 4
  %1295 = load i32, ptr %i, align 4
  %idxprom2147 = sext i32 %1295 to i64
  %arrayidx2148 = getelementptr [2 x %struct.__user_cap_data_struct], ptr %data, i64 0, i64 %idxprom2147
  %permitted2149 = getelementptr inbounds %struct.__user_cap_data_struct, ptr %arrayidx2148, i32 0, i32 1
  %1296 = load i32, ptr %permitted2149, align 4
  %call2150 = call i32 @tswap32(i32 noundef %1296)
  %1297 = load ptr, ptr %target_data, align 8
  %1298 = load i32, ptr %i, align 4
  %idxprom2151 = sext i32 %1298 to i64
  %arrayidx2152 = getelementptr %struct.target_user_cap_data, ptr %1297, i64 %idxprom2151
  %permitted2153 = getelementptr inbounds %struct.target_user_cap_data, ptr %arrayidx2152, i32 0, i32 1
  store i32 %call2150, ptr %permitted2153, align 4
  %1299 = load i32, ptr %i, align 4
  %idxprom2154 = sext i32 %1299 to i64
  %arrayidx2155 = getelementptr [2 x %struct.__user_cap_data_struct], ptr %data, i64 0, i64 %idxprom2154
  %inheritable2156 = getelementptr inbounds %struct.__user_cap_data_struct, ptr %arrayidx2155, i32 0, i32 2
  %1300 = load i32, ptr %inheritable2156, align 4
  %call2157 = call i32 @tswap32(i32 noundef %1300)
  %1301 = load ptr, ptr %target_data, align 8
  %1302 = load i32, ptr %i, align 4
  %idxprom2158 = sext i32 %1302 to i64
  %arrayidx2159 = getelementptr %struct.target_user_cap_data, ptr %1301, i64 %idxprom2158
  %inheritable2160 = getelementptr inbounds %struct.target_user_cap_data, ptr %arrayidx2159, i32 0, i32 2
  store i32 %call2157, ptr %inheritable2160, align 4
  br label %for.inc2161

for.inc2161:                                      ; preds = %for.body2139
  %1303 = load i32, ptr %i, align 4
  %inc2162 = add i32 %1303, 1
  store i32 %inc2162, ptr %i, align 4
  br label %for.cond2136, !llvm.loop !22

for.end2163:                                      ; preds = %for.cond2136
  %1304 = load ptr, ptr %target_data, align 8
  %1305 = load i64, ptr %arg2.addr, align 8
  %1306 = load i32, ptr %target_datalen, align 4
  %conv2164 = sext i32 %1306 to i64
  call void @unlock_user(ptr noundef %1304, i64 noundef %1305, i64 noundef %conv2164)
  br label %if.end2166

if.else2165:                                      ; preds = %if.then2132
  %1307 = load ptr, ptr %target_data, align 8
  %1308 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1307, i64 noundef %1308, i64 noundef 0)
  br label %if.end2166

if.end2166:                                       ; preds = %if.else2165, %for.end2163
  br label %if.end2167

if.end2167:                                       ; preds = %if.end2166, %if.end2127
  %1309 = load i64, ptr %ret, align 8
  store i64 %1309, ptr %retval, align 8
  br label %return

sw.bb2168:                                        ; preds = %entry
  %1310 = load i64, ptr %arg1.addr, align 8
  %1311 = load i64, ptr %arg2.addr, align 8
  %1312 = load ptr, ptr %cpu_env.addr, align 8
  %call2169 = call i64 @do_sigaltstack(i64 noundef %1310, i64 noundef %1311, ptr noundef %1312)
  store i64 %call2169, ptr %retval, align 8
  br label %return

sw.bb2170:                                        ; preds = %entry
  store ptr null, ptr %offp, align 8
  %1313 = load i64, ptr %arg3.addr, align 8
  %tobool2171 = icmp ne i64 %1313, 0
  br i1 %tobool2171, label %if.then2172, label %if.end2189

if.then2172:                                      ; preds = %sw.bb2170
  %1314 = load i64, ptr %arg3.addr, align 8
  store i64 %1314, ptr %__gaddr2173, align 8
  store i64 0, ptr %__ret2175, align 8
  %1315 = load i64, ptr %__gaddr2173, align 8
  %call2176 = call ptr @lock_user(i32 noundef 1, i64 noundef %1315, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call2176, ptr %__hptr2174, align 8
  %tobool2177 = icmp ne ptr %call2176, null
  br i1 %tobool2177, label %if.then2178, label %if.else2182

if.then2178:                                      ; preds = %if.then2172
  br label %do.body2179

do.body2179:                                      ; preds = %if.then2178
  %1316 = load ptr, ptr %__hptr2174, align 8
  %call2180 = call i64 @ldq_le_p(ptr noundef %1316)
  store i64 %call2180, ptr %off, align 8
  br label %do.end2181

do.end2181:                                       ; preds = %do.body2179
  %1317 = load ptr, ptr %__hptr2174, align 8
  %1318 = load i64, ptr %__gaddr2173, align 8
  call void @unlock_user(ptr noundef %1317, i64 noundef %1318, i64 noundef 0)
  br label %if.end2183

if.else2182:                                      ; preds = %if.then2172
  store i64 0, ptr %off, align 8
  store i64 -14, ptr %__ret2175, align 8
  br label %if.end2183

if.end2183:                                       ; preds = %if.else2182, %do.end2181
  %1319 = load i64, ptr %__ret2175, align 8
  store i64 %1319, ptr %tmp2184, align 8
  %1320 = load i64, ptr %tmp2184, align 8
  store i64 %1320, ptr %ret, align 8
  %1321 = load i64, ptr %ret, align 8
  %call2185 = call i32 @is_error(i64 noundef %1321)
  %tobool2186 = icmp ne i32 %call2185, 0
  br i1 %tobool2186, label %if.then2187, label %if.end2188

if.then2187:                                      ; preds = %if.end2183
  %1322 = load i64, ptr %ret, align 8
  store i64 %1322, ptr %retval, align 8
  br label %return

if.end2188:                                       ; preds = %if.end2183
  store ptr %off, ptr %offp, align 8
  br label %if.end2189

if.end2189:                                       ; preds = %if.end2188, %sw.bb2170
  %1323 = load i64, ptr %arg1.addr, align 8
  %conv2190 = trunc i64 %1323 to i32
  %1324 = load i64, ptr %arg2.addr, align 8
  %conv2191 = trunc i64 %1324 to i32
  %1325 = load ptr, ptr %offp, align 8
  %1326 = load i64, ptr %arg4.addr, align 8
  %call2192 = call i64 @sendfile64(i32 noundef %conv2190, i32 noundef %conv2191, ptr noundef %1325, i64 noundef %1326) #14
  %call2193 = call i64 @get_errno(i64 noundef %call2192)
  store i64 %call2193, ptr %ret, align 8
  %1327 = load i64, ptr %ret, align 8
  %call2194 = call i32 @is_error(i64 noundef %1327)
  %tobool2195 = icmp ne i32 %call2194, 0
  br i1 %tobool2195, label %if.end2214, label %land.lhs.true2196

land.lhs.true2196:                                ; preds = %if.end2189
  %1328 = load i64, ptr %arg3.addr, align 8
  %tobool2197 = icmp ne i64 %1328, 0
  br i1 %tobool2197, label %if.then2198, label %if.end2214

if.then2198:                                      ; preds = %land.lhs.true2196
  %1329 = load i64, ptr %arg3.addr, align 8
  store i64 %1329, ptr %__gaddr2199, align 8
  store i64 0, ptr %__ret2201, align 8
  %1330 = load i64, ptr %__gaddr2199, align 8
  %call2202 = call ptr @lock_user(i32 noundef 3, i64 noundef %1330, i64 noundef 8, i1 noundef zeroext false)
  store ptr %call2202, ptr %__hptr2200, align 8
  %tobool2203 = icmp ne ptr %call2202, null
  br i1 %tobool2203, label %if.then2204, label %if.else2207

if.then2204:                                      ; preds = %if.then2198
  br label %do.body2205

do.body2205:                                      ; preds = %if.then2204
  %1331 = load ptr, ptr %__hptr2200, align 8
  %1332 = load i64, ptr %off, align 8
  call void @stq_le_p(ptr noundef %1331, i64 noundef %1332)
  br label %do.end2206

do.end2206:                                       ; preds = %do.body2205
  %1333 = load ptr, ptr %__hptr2200, align 8
  %1334 = load i64, ptr %__gaddr2199, align 8
  call void @unlock_user(ptr noundef %1333, i64 noundef %1334, i64 noundef 8)
  br label %if.end2208

if.else2207:                                      ; preds = %if.then2198
  store i64 -14, ptr %__ret2201, align 8
  br label %if.end2208

if.end2208:                                       ; preds = %if.else2207, %do.end2206
  %1335 = load i64, ptr %__ret2201, align 8
  store i64 %1335, ptr %tmp2209, align 8
  %1336 = load i64, ptr %tmp2209, align 8
  store i64 %1336, ptr %ret2, align 8
  %1337 = load i64, ptr %ret2, align 8
  %call2210 = call i32 @is_error(i64 noundef %1337)
  %tobool2211 = icmp ne i32 %call2210, 0
  br i1 %tobool2211, label %if.then2212, label %if.end2213

if.then2212:                                      ; preds = %if.end2208
  %1338 = load i64, ptr %ret2, align 8
  store i64 %1338, ptr %ret, align 8
  br label %if.end2213

if.end2213:                                       ; preds = %if.then2212, %if.end2208
  br label %if.end2214

if.end2214:                                       ; preds = %if.end2213, %land.lhs.true2196, %if.end2189
  %1339 = load i64, ptr %ret, align 8
  store i64 %1339, ptr %retval, align 8
  br label %return

sw.bb2215:                                        ; preds = %entry
  %1340 = load i64, ptr %arg2.addr, align 8
  %call2216 = call ptr @lock_user_string(i64 noundef %1340)
  store ptr %call2216, ptr %p, align 8
  %tobool2217 = icmp ne ptr %call2216, null
  br i1 %tobool2217, label %if.end2219, label %if.then2218

if.then2218:                                      ; preds = %sw.bb2215
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2219:                                       ; preds = %sw.bb2215
  %1341 = load i64, ptr %arg1.addr, align 8
  %conv2220 = trunc i64 %1341 to i32
  %1342 = load ptr, ptr %p, align 8
  %call2221 = call ptr @path(ptr noundef %1342)
  %1343 = load i64, ptr %arg4.addr, align 8
  %conv2222 = trunc i64 %1343 to i32
  %call2223 = call i32 @fstatat64(i32 noundef %conv2220, ptr noundef %call2221, ptr noundef %st, i32 noundef %conv2222) #14
  %conv2224 = sext i32 %call2223 to i64
  %call2225 = call i64 @get_errno(i64 noundef %conv2224)
  store i64 %call2225, ptr %ret, align 8
  %1344 = load ptr, ptr %p, align 8
  %1345 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1344, i64 noundef %1345, i64 noundef 0)
  %1346 = load i64, ptr %ret, align 8
  %call2226 = call i32 @is_error(i64 noundef %1346)
  %tobool2227 = icmp ne i32 %call2226, 0
  br i1 %tobool2227, label %if.end2230, label %if.then2228

if.then2228:                                      ; preds = %if.end2219
  %1347 = load ptr, ptr %cpu_env.addr, align 8
  %1348 = load i64, ptr %arg3.addr, align 8
  %call2229 = call i64 @host_to_target_stat64(ptr noundef %1347, i64 noundef %1348, ptr noundef %st)
  store i64 %call2229, ptr %ret, align 8
  br label %if.end2230

if.end2230:                                       ; preds = %if.then2228, %if.end2219
  %1349 = load i64, ptr %ret, align 8
  store i64 %1349, ptr %retval, align 8
  br label %return

sw.bb2231:                                        ; preds = %entry
  %1350 = load i64, ptr %arg1.addr, align 8
  %conv2232 = trunc i64 %1350 to i32
  store i32 %conv2232, ptr %dirfd, align 4
  %1351 = load i64, ptr %arg3.addr, align 8
  %conv2233 = trunc i64 %1351 to i32
  store i32 %conv2233, ptr %flags, align 4
  %1352 = load i64, ptr %arg2.addr, align 8
  %call2234 = call ptr @lock_user_string(i64 noundef %1352)
  store ptr %call2234, ptr %p, align 8
  %1353 = load ptr, ptr %p, align 8
  %cmp2235 = icmp eq ptr %1353, null
  br i1 %cmp2235, label %if.then2237, label %if.end2238

if.then2237:                                      ; preds = %sw.bb2231
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2238:                                       ; preds = %sw.bb2231
  %1354 = load i64, ptr %arg4.addr, align 8
  %conv2240 = trunc i64 %1354 to i32
  store i32 %conv2240, ptr %mask2239, align 4
  %1355 = load i32, ptr %dirfd, align 4
  %1356 = load ptr, ptr %p, align 8
  %1357 = load i32, ptr %flags, align 4
  %1358 = load i32, ptr %mask2239, align 4
  %call2241 = call i32 @sys_statx(i32 noundef %1355, ptr noundef %1356, i32 noundef %1357, i32 noundef %1358, ptr noundef %host_stx)
  %conv2242 = sext i32 %call2241 to i64
  %call2243 = call i64 @get_errno(i64 noundef %conv2242)
  store i64 %call2243, ptr %ret, align 8
  %1359 = load i64, ptr %ret, align 8
  %call2244 = call i32 @is_error(i64 noundef %1359)
  %tobool2245 = icmp ne i32 %call2244, 0
  br i1 %tobool2245, label %if.end2252, label %if.then2246

if.then2246:                                      ; preds = %if.end2238
  %1360 = load i64, ptr %arg5.addr, align 8
  %call2247 = call i64 @host_to_target_statx(ptr noundef %host_stx, i64 noundef %1360)
  %cmp2248 = icmp ne i64 %call2247, 0
  br i1 %cmp2248, label %if.then2250, label %if.end2251

if.then2250:                                      ; preds = %if.then2246
  %1361 = load ptr, ptr %p, align 8
  %1362 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1361, i64 noundef %1362, i64 noundef 0)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2251:                                       ; preds = %if.then2246
  br label %if.end2252

if.end2252:                                       ; preds = %if.end2251, %if.end2238
  %1363 = load i64, ptr %ret, align 8
  %cmp2253 = icmp ne i64 %1363, -38
  br i1 %cmp2253, label %if.then2255, label %if.end2256

if.then2255:                                      ; preds = %if.end2252
  %1364 = load ptr, ptr %p, align 8
  %1365 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1364, i64 noundef %1365, i64 noundef 0)
  %1366 = load i64, ptr %ret, align 8
  store i64 %1366, ptr %retval, align 8
  br label %return

if.end2256:                                       ; preds = %if.end2252
  %1367 = load i32, ptr %dirfd, align 4
  %1368 = load ptr, ptr %p, align 8
  %call2257 = call ptr @path(ptr noundef %1368)
  %1369 = load i32, ptr %flags, align 4
  %call2258 = call i32 @fstatat64(i32 noundef %1367, ptr noundef %call2257, ptr noundef %st, i32 noundef %1369) #14
  %conv2259 = sext i32 %call2258 to i64
  %call2260 = call i64 @get_errno(i64 noundef %conv2259)
  store i64 %call2260, ptr %ret, align 8
  %1370 = load ptr, ptr %p, align 8
  %1371 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1370, i64 noundef %1371, i64 noundef 0)
  %1372 = load i64, ptr %ret, align 8
  %call2261 = call i32 @is_error(i64 noundef %1372)
  %tobool2262 = icmp ne i32 %call2261, 0
  br i1 %tobool2262, label %if.end2326, label %if.then2263

if.then2263:                                      ; preds = %if.end2256
  %1373 = load i64, ptr %arg5.addr, align 8
  %call2264 = call ptr @lock_user(i32 noundef 3, i64 noundef %1373, i64 noundef 256, i1 noundef zeroext false)
  store ptr %call2264, ptr %target_stx, align 8
  %tobool2265 = icmp ne ptr %call2264, null
  br i1 %tobool2265, label %if.end2267, label %if.then2266

if.then2266:                                      ; preds = %if.then2263
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2267:                                       ; preds = %if.then2263
  %1374 = load ptr, ptr %target_stx, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %1374, i8 0, i64 256, i1 false)
  br label %do.body2268

do.body2268:                                      ; preds = %if.end2267
  %1375 = load ptr, ptr %target_stx, align 8
  %stx_dev_major = getelementptr inbounds %struct.target_statx, ptr %1375, i32 0, i32 18
  %st_dev2269 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 0
  %1376 = load i64, ptr %st_dev2269, align 8
  %call2270 = call i32 @gnu_dev_major(i64 noundef %1376) #13
  call void @stl_le_p(ptr noundef %stx_dev_major, i32 noundef %call2270)
  br label %do.end2271

do.end2271:                                       ; preds = %do.body2268
  br label %do.body2272

do.body2272:                                      ; preds = %do.end2271
  %1377 = load ptr, ptr %target_stx, align 8
  %stx_dev_minor = getelementptr inbounds %struct.target_statx, ptr %1377, i32 0, i32 19
  %st_dev2273 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 0
  %1378 = load i64, ptr %st_dev2273, align 8
  %call2274 = call i32 @gnu_dev_minor(i64 noundef %1378) #13
  call void @stl_le_p(ptr noundef %stx_dev_minor, i32 noundef %call2274)
  br label %do.end2275

do.end2275:                                       ; preds = %do.body2272
  br label %do.body2276

do.body2276:                                      ; preds = %do.end2275
  %1379 = load ptr, ptr %target_stx, align 8
  %stx_ino = getelementptr inbounds %struct.target_statx, ptr %1379, i32 0, i32 8
  %st_ino2277 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 1
  %1380 = load i64, ptr %st_ino2277, align 8
  call void @stq_le_p(ptr noundef %stx_ino, i64 noundef %1380)
  br label %do.end2278

do.end2278:                                       ; preds = %do.body2276
  br label %do.body2279

do.body2279:                                      ; preds = %do.end2278
  %1381 = load ptr, ptr %target_stx, align 8
  %stx_mode = getelementptr inbounds %struct.target_statx, ptr %1381, i32 0, i32 6
  %st_mode2280 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 3
  %1382 = load i32, ptr %st_mode2280, align 8
  %conv2281 = trunc i32 %1382 to i16
  call void @stw_le_p(ptr noundef %stx_mode, i16 noundef zeroext %conv2281)
  br label %do.end2282

do.end2282:                                       ; preds = %do.body2279
  br label %do.body2283

do.body2283:                                      ; preds = %do.end2282
  %1383 = load ptr, ptr %target_stx, align 8
  %stx_uid = getelementptr inbounds %struct.target_statx, ptr %1383, i32 0, i32 4
  %st_uid2284 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 4
  %1384 = load i32, ptr %st_uid2284, align 4
  call void @stl_le_p(ptr noundef %stx_uid, i32 noundef %1384)
  br label %do.end2285

do.end2285:                                       ; preds = %do.body2283
  br label %do.body2286

do.body2286:                                      ; preds = %do.end2285
  %1385 = load ptr, ptr %target_stx, align 8
  %stx_gid = getelementptr inbounds %struct.target_statx, ptr %1385, i32 0, i32 5
  %st_gid2287 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 5
  %1386 = load i32, ptr %st_gid2287, align 8
  call void @stl_le_p(ptr noundef %stx_gid, i32 noundef %1386)
  br label %do.end2288

do.end2288:                                       ; preds = %do.body2286
  br label %do.body2289

do.body2289:                                      ; preds = %do.end2288
  %1387 = load ptr, ptr %target_stx, align 8
  %stx_nlink = getelementptr inbounds %struct.target_statx, ptr %1387, i32 0, i32 3
  %st_nlink2290 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 2
  %1388 = load i64, ptr %st_nlink2290, align 8
  %conv2291 = trunc i64 %1388 to i32
  call void @stl_le_p(ptr noundef %stx_nlink, i32 noundef %conv2291)
  br label %do.end2292

do.end2292:                                       ; preds = %do.body2289
  br label %do.body2293

do.body2293:                                      ; preds = %do.end2292
  %1389 = load ptr, ptr %target_stx, align 8
  %stx_rdev_major = getelementptr inbounds %struct.target_statx, ptr %1389, i32 0, i32 16
  %st_rdev2294 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 7
  %1390 = load i64, ptr %st_rdev2294, align 8
  %call2295 = call i32 @gnu_dev_major(i64 noundef %1390) #13
  call void @stl_le_p(ptr noundef %stx_rdev_major, i32 noundef %call2295)
  br label %do.end2296

do.end2296:                                       ; preds = %do.body2293
  br label %do.body2297

do.body2297:                                      ; preds = %do.end2296
  %1391 = load ptr, ptr %target_stx, align 8
  %stx_rdev_minor = getelementptr inbounds %struct.target_statx, ptr %1391, i32 0, i32 17
  %st_rdev2298 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 7
  %1392 = load i64, ptr %st_rdev2298, align 8
  %call2299 = call i32 @gnu_dev_minor(i64 noundef %1392) #13
  call void @stl_le_p(ptr noundef %stx_rdev_minor, i32 noundef %call2299)
  br label %do.end2300

do.end2300:                                       ; preds = %do.body2297
  br label %do.body2301

do.body2301:                                      ; preds = %do.end2300
  %1393 = load ptr, ptr %target_stx, align 8
  %stx_size = getelementptr inbounds %struct.target_statx, ptr %1393, i32 0, i32 9
  %st_size2302 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 8
  %1394 = load i64, ptr %st_size2302, align 8
  call void @stq_le_p(ptr noundef %stx_size, i64 noundef %1394)
  br label %do.end2303

do.end2303:                                       ; preds = %do.body2301
  br label %do.body2304

do.body2304:                                      ; preds = %do.end2303
  %1395 = load ptr, ptr %target_stx, align 8
  %stx_blksize = getelementptr inbounds %struct.target_statx, ptr %1395, i32 0, i32 1
  %st_blksize2305 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 9
  %1396 = load i64, ptr %st_blksize2305, align 8
  %conv2306 = trunc i64 %1396 to i32
  call void @stl_le_p(ptr noundef %stx_blksize, i32 noundef %conv2306)
  br label %do.end2307

do.end2307:                                       ; preds = %do.body2304
  br label %do.body2308

do.body2308:                                      ; preds = %do.end2307
  %1397 = load ptr, ptr %target_stx, align 8
  %stx_blocks = getelementptr inbounds %struct.target_statx, ptr %1397, i32 0, i32 10
  %st_blocks2309 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 10
  %1398 = load i64, ptr %st_blocks2309, align 8
  call void @stq_le_p(ptr noundef %stx_blocks, i64 noundef %1398)
  br label %do.end2310

do.end2310:                                       ; preds = %do.body2308
  br label %do.body2311

do.body2311:                                      ; preds = %do.end2310
  %1399 = load ptr, ptr %target_stx, align 8
  %stx_atime = getelementptr inbounds %struct.target_statx, ptr %1399, i32 0, i32 12
  %tv_sec2312 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_atime, i32 0, i32 0
  %st_atim2313 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 11
  %tv_sec2314 = getelementptr inbounds %struct.timespec, ptr %st_atim2313, i32 0, i32 0
  %1400 = load i64, ptr %tv_sec2314, align 8
  call void @stq_le_p(ptr noundef %tv_sec2312, i64 noundef %1400)
  br label %do.end2315

do.end2315:                                       ; preds = %do.body2311
  br label %do.body2316

do.body2316:                                      ; preds = %do.end2315
  %1401 = load ptr, ptr %target_stx, align 8
  %stx_mtime = getelementptr inbounds %struct.target_statx, ptr %1401, i32 0, i32 15
  %tv_sec2317 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_mtime, i32 0, i32 0
  %st_mtim2318 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 12
  %tv_sec2319 = getelementptr inbounds %struct.timespec, ptr %st_mtim2318, i32 0, i32 0
  %1402 = load i64, ptr %tv_sec2319, align 8
  call void @stq_le_p(ptr noundef %tv_sec2317, i64 noundef %1402)
  br label %do.end2320

do.end2320:                                       ; preds = %do.body2316
  br label %do.body2321

do.body2321:                                      ; preds = %do.end2320
  %1403 = load ptr, ptr %target_stx, align 8
  %stx_ctime = getelementptr inbounds %struct.target_statx, ptr %1403, i32 0, i32 14
  %tv_sec2322 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_ctime, i32 0, i32 0
  %st_ctim2323 = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 13
  %tv_sec2324 = getelementptr inbounds %struct.timespec, ptr %st_ctim2323, i32 0, i32 0
  %1404 = load i64, ptr %tv_sec2324, align 8
  call void @stq_le_p(ptr noundef %tv_sec2322, i64 noundef %1404)
  br label %do.end2325

do.end2325:                                       ; preds = %do.body2321
  %1405 = load ptr, ptr %target_stx, align 8
  %1406 = load i64, ptr %arg5.addr, align 8
  call void @unlock_user(ptr noundef %1405, i64 noundef %1406, i64 noundef 256)
  br label %if.end2326

if.end2326:                                       ; preds = %do.end2325, %if.end2256
  %1407 = load i64, ptr %ret, align 8
  store i64 %1407, ptr %retval, align 8
  br label %return

sw.bb2327:                                        ; preds = %entry
  %call2328 = call i32 @getuid() #14
  %call2329 = call i32 @high2lowuid(i32 noundef %call2328)
  %conv2330 = sext i32 %call2329 to i64
  %call2331 = call i64 @get_errno(i64 noundef %conv2330)
  store i64 %call2331, ptr %retval, align 8
  br label %return

sw.bb2332:                                        ; preds = %entry
  %call2333 = call i32 @getgid() #14
  %call2334 = call i32 @high2lowgid(i32 noundef %call2333)
  %conv2335 = sext i32 %call2334 to i64
  %call2336 = call i64 @get_errno(i64 noundef %conv2335)
  store i64 %call2336, ptr %retval, align 8
  br label %return

sw.bb2337:                                        ; preds = %entry
  %call2338 = call i32 @geteuid() #14
  %call2339 = call i32 @high2lowuid(i32 noundef %call2338)
  %conv2340 = sext i32 %call2339 to i64
  %call2341 = call i64 @get_errno(i64 noundef %conv2340)
  store i64 %call2341, ptr %retval, align 8
  br label %return

sw.bb2342:                                        ; preds = %entry
  %call2343 = call i32 @getegid() #14
  %call2344 = call i32 @high2lowgid(i32 noundef %call2343)
  %conv2345 = sext i32 %call2344 to i64
  %call2346 = call i64 @get_errno(i64 noundef %conv2345)
  store i64 %call2346, ptr %retval, align 8
  br label %return

sw.bb2347:                                        ; preds = %entry
  %1408 = load i64, ptr %arg1.addr, align 8
  %conv2348 = trunc i64 %1408 to i32
  %call2349 = call i32 @low2highuid(i32 noundef %conv2348)
  %1409 = load i64, ptr %arg2.addr, align 8
  %conv2350 = trunc i64 %1409 to i32
  %call2351 = call i32 @low2highuid(i32 noundef %conv2350)
  %call2352 = call i32 @setreuid(i32 noundef %call2349, i32 noundef %call2351) #14
  %conv2353 = sext i32 %call2352 to i64
  %call2354 = call i64 @get_errno(i64 noundef %conv2353)
  store i64 %call2354, ptr %retval, align 8
  br label %return

sw.bb2355:                                        ; preds = %entry
  %1410 = load i64, ptr %arg1.addr, align 8
  %conv2356 = trunc i64 %1410 to i32
  %call2357 = call i32 @low2highgid(i32 noundef %conv2356)
  %1411 = load i64, ptr %arg2.addr, align 8
  %conv2358 = trunc i64 %1411 to i32
  %call2359 = call i32 @low2highgid(i32 noundef %conv2358)
  %call2360 = call i32 @setregid(i32 noundef %call2357, i32 noundef %call2359) #14
  %conv2361 = sext i32 %call2360 to i64
  %call2362 = call i64 @get_errno(i64 noundef %conv2361)
  store i64 %call2362, ptr %retval, align 8
  br label %return

sw.bb2363:                                        ; preds = %entry
  %1412 = load i64, ptr %arg1.addr, align 8
  %conv2364 = trunc i64 %1412 to i32
  store i32 %conv2364, ptr %gidsetsize, align 4
  store ptr null, ptr %grouplist, align 8
  %1413 = load i32, ptr %gidsetsize, align 4
  %cmp2366 = icmp sgt i32 %1413, 65536
  br i1 %cmp2366, label %if.then2371, label %lor.lhs.false2368

lor.lhs.false2368:                                ; preds = %sw.bb2363
  %1414 = load i32, ptr %gidsetsize, align 4
  %cmp2369 = icmp slt i32 %1414, 0
  br i1 %cmp2369, label %if.then2371, label %if.end2372

if.then2371:                                      ; preds = %lor.lhs.false2368, %sw.bb2363
  store i64 -22, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end2372:                                       ; preds = %lor.lhs.false2368
  %1415 = load i32, ptr %gidsetsize, align 4
  %cmp2373 = icmp sgt i32 %1415, 0
  br i1 %cmp2373, label %if.then2375, label %if.end2381

if.then2375:                                      ; preds = %if.end2372
  %1416 = load i32, ptr %gidsetsize, align 4
  %conv2376 = sext i32 %1416 to i64
  %call2377 = call noalias ptr @g_try_malloc_n(i64 noundef %conv2376, i64 noundef 4) #17
  store ptr %call2377, ptr %grouplist, align 8
  %1417 = load ptr, ptr %grouplist, align 8
  %tobool2378 = icmp ne ptr %1417, null
  br i1 %tobool2378, label %if.end2380, label %if.then2379

if.then2379:                                      ; preds = %if.then2375
  store i64 -12, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end2380:                                       ; preds = %if.then2375
  br label %if.end2381

if.end2381:                                       ; preds = %if.end2380, %if.end2372
  %1418 = load i32, ptr %gidsetsize, align 4
  %1419 = load ptr, ptr %grouplist, align 8
  %call2382 = call i32 @getgroups(i32 noundef %1418, ptr noundef %1419) #14
  %conv2383 = sext i32 %call2382 to i64
  %call2384 = call i64 @get_errno(i64 noundef %conv2383)
  store i64 %call2384, ptr %ret, align 8
  %1420 = load i64, ptr %ret, align 8
  %call2385 = call i32 @is_error(i64 noundef %1420)
  %tobool2386 = icmp ne i32 %call2385, 0
  br i1 %tobool2386, label %if.end2413, label %land.lhs.true2387

land.lhs.true2387:                                ; preds = %if.end2381
  %1421 = load i32, ptr %gidsetsize, align 4
  %cmp2388 = icmp sgt i32 %1421, 0
  br i1 %cmp2388, label %if.then2390, label %if.end2413

if.then2390:                                      ; preds = %land.lhs.true2387
  %1422 = load i64, ptr %arg2.addr, align 8
  %1423 = load i32, ptr %gidsetsize, align 4
  %conv2391 = sext i32 %1423 to i64
  %mul2392 = mul i64 %conv2391, 4
  %call2393 = call ptr @lock_user(i32 noundef 3, i64 noundef %1422, i64 noundef %mul2392, i1 noundef zeroext false)
  store ptr %call2393, ptr %target_grouplist, align 8
  %1424 = load ptr, ptr %target_grouplist, align 8
  %tobool2394 = icmp ne ptr %1424, null
  br i1 %tobool2394, label %if.end2396, label %if.then2395

if.then2395:                                      ; preds = %if.then2390
  store i64 -14, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end2396:                                       ; preds = %if.then2390
  store i32 0, ptr %i2365, align 4
  br label %for.cond2397

for.cond2397:                                     ; preds = %for.inc2408, %if.end2396
  %1425 = load i32, ptr %i2365, align 4
  %conv2398 = sext i32 %1425 to i64
  %1426 = load i64, ptr %ret, align 8
  %cmp2399 = icmp slt i64 %conv2398, %1426
  br i1 %cmp2399, label %for.body2401, label %for.end2410

for.body2401:                                     ; preds = %for.cond2397
  %1427 = load ptr, ptr %grouplist, align 8
  %1428 = load i32, ptr %i2365, align 4
  %idxprom2402 = sext i32 %1428 to i64
  %arrayidx2403 = getelementptr i32, ptr %1427, i64 %idxprom2402
  %1429 = load i32, ptr %arrayidx2403, align 4
  %call2404 = call i32 @high2lowgid(i32 noundef %1429)
  %call2405 = call i32 @tswapid(i32 noundef %call2404)
  %1430 = load ptr, ptr %target_grouplist, align 8
  %1431 = load i32, ptr %i2365, align 4
  %idxprom2406 = sext i32 %1431 to i64
  %arrayidx2407 = getelementptr i32, ptr %1430, i64 %idxprom2406
  store i32 %call2405, ptr %arrayidx2407, align 4
  br label %for.inc2408

for.inc2408:                                      ; preds = %for.body2401
  %1432 = load i32, ptr %i2365, align 4
  %inc2409 = add i32 %1432, 1
  store i32 %inc2409, ptr %i2365, align 4
  br label %for.cond2397, !llvm.loop !23

for.end2410:                                      ; preds = %for.cond2397
  %1433 = load ptr, ptr %target_grouplist, align 8
  %1434 = load i64, ptr %arg2.addr, align 8
  %1435 = load i32, ptr %gidsetsize, align 4
  %conv2411 = sext i32 %1435 to i64
  %mul2412 = mul i64 %conv2411, 4
  call void @unlock_user(ptr noundef %1433, i64 noundef %1434, i64 noundef %mul2412)
  br label %if.end2413

if.end2413:                                       ; preds = %for.end2410, %land.lhs.true2387, %if.end2381
  %1436 = load i64, ptr %ret, align 8
  store i64 %1436, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end2413, %if.then2395, %if.then2379, %if.then2371
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %grouplist)
  br label %return

sw.bb2414:                                        ; preds = %entry
  %1437 = load i64, ptr %arg1.addr, align 8
  %conv2416 = trunc i64 %1437 to i32
  store i32 %conv2416, ptr %gidsetsize2415, align 4
  store ptr null, ptr %grouplist2418, align 8
  %1438 = load i32, ptr %gidsetsize2415, align 4
  %cmp2420 = icmp sgt i32 %1438, 65536
  br i1 %cmp2420, label %if.then2425, label %lor.lhs.false2422

lor.lhs.false2422:                                ; preds = %sw.bb2414
  %1439 = load i32, ptr %gidsetsize2415, align 4
  %cmp2423 = icmp slt i32 %1439, 0
  br i1 %cmp2423, label %if.then2425, label %if.end2426

if.then2425:                                      ; preds = %lor.lhs.false2422, %sw.bb2414
  store i64 -22, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup2461

if.end2426:                                       ; preds = %lor.lhs.false2422
  %1440 = load i32, ptr %gidsetsize2415, align 4
  %cmp2427 = icmp sgt i32 %1440, 0
  br i1 %cmp2427, label %if.then2429, label %if.end2456

if.then2429:                                      ; preds = %if.end2426
  %1441 = load i32, ptr %gidsetsize2415, align 4
  %conv2430 = sext i32 %1441 to i64
  %call2431 = call noalias ptr @g_try_malloc_n(i64 noundef %conv2430, i64 noundef 4) #17
  store ptr %call2431, ptr %grouplist2418, align 8
  %1442 = load ptr, ptr %grouplist2418, align 8
  %tobool2432 = icmp ne ptr %1442, null
  br i1 %tobool2432, label %if.end2434, label %if.then2433

if.then2433:                                      ; preds = %if.then2429
  store i64 -12, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup2461

if.end2434:                                       ; preds = %if.then2429
  %1443 = load i64, ptr %arg2.addr, align 8
  %1444 = load i32, ptr %gidsetsize2415, align 4
  %conv2435 = sext i32 %1444 to i64
  %mul2436 = mul i64 %conv2435, 4
  %call2437 = call ptr @lock_user(i32 noundef 1, i64 noundef %1443, i64 noundef %mul2436, i1 noundef zeroext true)
  store ptr %call2437, ptr %target_grouplist2417, align 8
  %1445 = load ptr, ptr %target_grouplist2417, align 8
  %tobool2438 = icmp ne ptr %1445, null
  br i1 %tobool2438, label %if.end2440, label %if.then2439

if.then2439:                                      ; preds = %if.end2434
  store i64 -14, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup2461

if.end2440:                                       ; preds = %if.end2434
  store i32 0, ptr %i2419, align 4
  br label %for.cond2441

for.cond2441:                                     ; preds = %for.inc2451, %if.end2440
  %1446 = load i32, ptr %i2419, align 4
  %1447 = load i32, ptr %gidsetsize2415, align 4
  %cmp2442 = icmp slt i32 %1446, %1447
  br i1 %cmp2442, label %for.body2444, label %for.end2453

for.body2444:                                     ; preds = %for.cond2441
  %1448 = load ptr, ptr %target_grouplist2417, align 8
  %1449 = load i32, ptr %i2419, align 4
  %idxprom2445 = sext i32 %1449 to i64
  %arrayidx2446 = getelementptr i32, ptr %1448, i64 %idxprom2445
  %1450 = load i32, ptr %arrayidx2446, align 4
  %call2447 = call i32 @tswapid(i32 noundef %1450)
  %call2448 = call i32 @low2highgid(i32 noundef %call2447)
  %1451 = load ptr, ptr %grouplist2418, align 8
  %1452 = load i32, ptr %i2419, align 4
  %idxprom2449 = sext i32 %1452 to i64
  %arrayidx2450 = getelementptr i32, ptr %1451, i64 %idxprom2449
  store i32 %call2448, ptr %arrayidx2450, align 4
  br label %for.inc2451

for.inc2451:                                      ; preds = %for.body2444
  %1453 = load i32, ptr %i2419, align 4
  %inc2452 = add i32 %1453, 1
  store i32 %inc2452, ptr %i2419, align 4
  br label %for.cond2441, !llvm.loop !24

for.end2453:                                      ; preds = %for.cond2441
  %1454 = load ptr, ptr %target_grouplist2417, align 8
  %1455 = load i64, ptr %arg2.addr, align 8
  %1456 = load i32, ptr %gidsetsize2415, align 4
  %conv2454 = sext i32 %1456 to i64
  %mul2455 = mul i64 %conv2454, 4
  call void @unlock_user(ptr noundef %1454, i64 noundef %1455, i64 noundef %mul2455)
  br label %if.end2456

if.end2456:                                       ; preds = %for.end2453, %if.end2426
  %1457 = load i32, ptr %gidsetsize2415, align 4
  %conv2457 = sext i32 %1457 to i64
  %1458 = load ptr, ptr %grouplist2418, align 8
  %call2458 = call i32 @setgroups(i64 noundef %conv2457, ptr noundef %1458) #14
  %conv2459 = sext i32 %call2458 to i64
  %call2460 = call i64 @get_errno(i64 noundef %conv2459)
  store i64 %call2460, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup2461

cleanup2461:                                      ; preds = %if.end2456, %if.then2439, %if.then2433, %if.then2425
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %grouplist2418)
  br label %return

sw.bb2462:                                        ; preds = %entry
  %1459 = load i64, ptr %arg1.addr, align 8
  %conv2463 = trunc i64 %1459 to i32
  %1460 = load i64, ptr %arg2.addr, align 8
  %conv2464 = trunc i64 %1460 to i32
  %call2465 = call i32 @low2highuid(i32 noundef %conv2464)
  %1461 = load i64, ptr %arg3.addr, align 8
  %conv2466 = trunc i64 %1461 to i32
  %call2467 = call i32 @low2highgid(i32 noundef %conv2466)
  %call2468 = call i32 @fchown(i32 noundef %conv2463, i32 noundef %call2465, i32 noundef %call2467) #14
  %conv2469 = sext i32 %call2468 to i64
  %call2470 = call i64 @get_errno(i64 noundef %conv2469)
  store i64 %call2470, ptr %retval, align 8
  br label %return

sw.bb2471:                                        ; preds = %entry
  %1462 = load i64, ptr %arg2.addr, align 8
  %call2472 = call ptr @lock_user_string(i64 noundef %1462)
  store ptr %call2472, ptr %p, align 8
  %tobool2473 = icmp ne ptr %call2472, null
  br i1 %tobool2473, label %if.end2475, label %if.then2474

if.then2474:                                      ; preds = %sw.bb2471
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2475:                                       ; preds = %sw.bb2471
  %1463 = load i64, ptr %arg1.addr, align 8
  %conv2476 = trunc i64 %1463 to i32
  %1464 = load ptr, ptr %p, align 8
  %1465 = load i64, ptr %arg3.addr, align 8
  %conv2477 = trunc i64 %1465 to i32
  %call2478 = call i32 @low2highuid(i32 noundef %conv2477)
  %1466 = load i64, ptr %arg4.addr, align 8
  %conv2479 = trunc i64 %1466 to i32
  %call2480 = call i32 @low2highgid(i32 noundef %conv2479)
  %1467 = load i64, ptr %arg5.addr, align 8
  %conv2481 = trunc i64 %1467 to i32
  %call2482 = call i32 @fchownat(i32 noundef %conv2476, ptr noundef %1464, i32 noundef %call2478, i32 noundef %call2480, i32 noundef %conv2481) #14
  %conv2483 = sext i32 %call2482 to i64
  %call2484 = call i64 @get_errno(i64 noundef %conv2483)
  store i64 %call2484, ptr %ret, align 8
  %1468 = load ptr, ptr %p, align 8
  %1469 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1468, i64 noundef %1469, i64 noundef 0)
  %1470 = load i64, ptr %ret, align 8
  store i64 %1470, ptr %retval, align 8
  br label %return

sw.bb2485:                                        ; preds = %entry
  %1471 = load i64, ptr %arg1.addr, align 8
  %conv2486 = trunc i64 %1471 to i32
  %call2487 = call i32 @low2highuid(i32 noundef %conv2486)
  %1472 = load i64, ptr %arg2.addr, align 8
  %conv2488 = trunc i64 %1472 to i32
  %call2489 = call i32 @low2highuid(i32 noundef %conv2488)
  %1473 = load i64, ptr %arg3.addr, align 8
  %conv2490 = trunc i64 %1473 to i32
  %call2491 = call i32 @low2highuid(i32 noundef %conv2490)
  %call2492 = call i32 @sys_setresuid(i32 noundef %call2487, i32 noundef %call2489, i32 noundef %call2491)
  %conv2493 = sext i32 %call2492 to i64
  %call2494 = call i64 @get_errno(i64 noundef %conv2493)
  store i64 %call2494, ptr %retval, align 8
  br label %return

sw.bb2495:                                        ; preds = %entry
  %call2496 = call i32 @getresuid(ptr noundef %ruid, ptr noundef %euid, ptr noundef %suid) #14
  %conv2497 = sext i32 %call2496 to i64
  %call2498 = call i64 @get_errno(i64 noundef %conv2497)
  store i64 %call2498, ptr %ret, align 8
  %1474 = load i64, ptr %ret, align 8
  %call2499 = call i32 @is_error(i64 noundef %1474)
  %tobool2500 = icmp ne i32 %call2499, 0
  br i1 %tobool2500, label %if.end2545, label %if.then2501

if.then2501:                                      ; preds = %sw.bb2495
  %1475 = load i64, ptr %arg1.addr, align 8
  store i64 %1475, ptr %__gaddr2502, align 8
  store i64 0, ptr %__ret2504, align 8
  %1476 = load i64, ptr %__gaddr2502, align 8
  %call2505 = call ptr @lock_user(i32 noundef 3, i64 noundef %1476, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call2505, ptr %__hptr2503, align 8
  %tobool2506 = icmp ne ptr %call2505, null
  br i1 %tobool2506, label %if.then2507, label %if.else2511

if.then2507:                                      ; preds = %if.then2501
  br label %do.body2508

do.body2508:                                      ; preds = %if.then2507
  %1477 = load ptr, ptr %__hptr2503, align 8
  %1478 = load i32, ptr %ruid, align 4
  %call2509 = call i32 @high2lowuid(i32 noundef %1478)
  call void @stl_le_p(ptr noundef %1477, i32 noundef %call2509)
  br label %do.end2510

do.end2510:                                       ; preds = %do.body2508
  %1479 = load ptr, ptr %__hptr2503, align 8
  %1480 = load i64, ptr %__gaddr2502, align 8
  call void @unlock_user(ptr noundef %1479, i64 noundef %1480, i64 noundef 4)
  br label %if.end2512

if.else2511:                                      ; preds = %if.then2501
  store i64 -14, ptr %__ret2504, align 8
  br label %if.end2512

if.end2512:                                       ; preds = %if.else2511, %do.end2510
  %1481 = load i64, ptr %__ret2504, align 8
  store i64 %1481, ptr %tmp2513, align 8
  %1482 = load i64, ptr %tmp2513, align 8
  %tobool2514 = icmp ne i64 %1482, 0
  br i1 %tobool2514, label %if.then2543, label %lor.lhs.false2515

lor.lhs.false2515:                                ; preds = %if.end2512
  %1483 = load i64, ptr %arg2.addr, align 8
  store i64 %1483, ptr %__gaddr2516, align 8
  store i64 0, ptr %__ret2518, align 8
  %1484 = load i64, ptr %__gaddr2516, align 8
  %call2519 = call ptr @lock_user(i32 noundef 3, i64 noundef %1484, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call2519, ptr %__hptr2517, align 8
  %tobool2520 = icmp ne ptr %call2519, null
  br i1 %tobool2520, label %if.then2521, label %if.else2525

if.then2521:                                      ; preds = %lor.lhs.false2515
  br label %do.body2522

do.body2522:                                      ; preds = %if.then2521
  %1485 = load ptr, ptr %__hptr2517, align 8
  %1486 = load i32, ptr %euid, align 4
  %call2523 = call i32 @high2lowuid(i32 noundef %1486)
  call void @stl_le_p(ptr noundef %1485, i32 noundef %call2523)
  br label %do.end2524

do.end2524:                                       ; preds = %do.body2522
  %1487 = load ptr, ptr %__hptr2517, align 8
  %1488 = load i64, ptr %__gaddr2516, align 8
  call void @unlock_user(ptr noundef %1487, i64 noundef %1488, i64 noundef 4)
  br label %if.end2526

if.else2525:                                      ; preds = %lor.lhs.false2515
  store i64 -14, ptr %__ret2518, align 8
  br label %if.end2526

if.end2526:                                       ; preds = %if.else2525, %do.end2524
  %1489 = load i64, ptr %__ret2518, align 8
  store i64 %1489, ptr %tmp2527, align 8
  %1490 = load i64, ptr %tmp2527, align 8
  %tobool2528 = icmp ne i64 %1490, 0
  br i1 %tobool2528, label %if.then2543, label %lor.lhs.false2529

lor.lhs.false2529:                                ; preds = %if.end2526
  %1491 = load i64, ptr %arg3.addr, align 8
  store i64 %1491, ptr %__gaddr2530, align 8
  store i64 0, ptr %__ret2532, align 8
  %1492 = load i64, ptr %__gaddr2530, align 8
  %call2533 = call ptr @lock_user(i32 noundef 3, i64 noundef %1492, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call2533, ptr %__hptr2531, align 8
  %tobool2534 = icmp ne ptr %call2533, null
  br i1 %tobool2534, label %if.then2535, label %if.else2539

if.then2535:                                      ; preds = %lor.lhs.false2529
  br label %do.body2536

do.body2536:                                      ; preds = %if.then2535
  %1493 = load ptr, ptr %__hptr2531, align 8
  %1494 = load i32, ptr %suid, align 4
  %call2537 = call i32 @high2lowuid(i32 noundef %1494)
  call void @stl_le_p(ptr noundef %1493, i32 noundef %call2537)
  br label %do.end2538

do.end2538:                                       ; preds = %do.body2536
  %1495 = load ptr, ptr %__hptr2531, align 8
  %1496 = load i64, ptr %__gaddr2530, align 8
  call void @unlock_user(ptr noundef %1495, i64 noundef %1496, i64 noundef 4)
  br label %if.end2540

if.else2539:                                      ; preds = %lor.lhs.false2529
  store i64 -14, ptr %__ret2532, align 8
  br label %if.end2540

if.end2540:                                       ; preds = %if.else2539, %do.end2538
  %1497 = load i64, ptr %__ret2532, align 8
  store i64 %1497, ptr %tmp2541, align 8
  %1498 = load i64, ptr %tmp2541, align 8
  %tobool2542 = icmp ne i64 %1498, 0
  br i1 %tobool2542, label %if.then2543, label %if.end2544

if.then2543:                                      ; preds = %if.end2540, %if.end2526, %if.end2512
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2544:                                       ; preds = %if.end2540
  br label %if.end2545

if.end2545:                                       ; preds = %if.end2544, %sw.bb2495
  %1499 = load i64, ptr %ret, align 8
  store i64 %1499, ptr %retval, align 8
  br label %return

sw.bb2546:                                        ; preds = %entry
  %1500 = load i64, ptr %arg1.addr, align 8
  %conv2547 = trunc i64 %1500 to i32
  %call2548 = call i32 @low2highgid(i32 noundef %conv2547)
  %1501 = load i64, ptr %arg2.addr, align 8
  %conv2549 = trunc i64 %1501 to i32
  %call2550 = call i32 @low2highgid(i32 noundef %conv2549)
  %1502 = load i64, ptr %arg3.addr, align 8
  %conv2551 = trunc i64 %1502 to i32
  %call2552 = call i32 @low2highgid(i32 noundef %conv2551)
  %call2553 = call i32 @sys_setresgid(i32 noundef %call2548, i32 noundef %call2550, i32 noundef %call2552)
  %conv2554 = sext i32 %call2553 to i64
  %call2555 = call i64 @get_errno(i64 noundef %conv2554)
  store i64 %call2555, ptr %retval, align 8
  br label %return

sw.bb2556:                                        ; preds = %entry
  %call2557 = call i32 @getresgid(ptr noundef %rgid, ptr noundef %egid, ptr noundef %sgid) #14
  %conv2558 = sext i32 %call2557 to i64
  %call2559 = call i64 @get_errno(i64 noundef %conv2558)
  store i64 %call2559, ptr %ret, align 8
  %1503 = load i64, ptr %ret, align 8
  %call2560 = call i32 @is_error(i64 noundef %1503)
  %tobool2561 = icmp ne i32 %call2560, 0
  br i1 %tobool2561, label %if.end2606, label %if.then2562

if.then2562:                                      ; preds = %sw.bb2556
  %1504 = load i64, ptr %arg1.addr, align 8
  store i64 %1504, ptr %__gaddr2563, align 8
  store i64 0, ptr %__ret2565, align 8
  %1505 = load i64, ptr %__gaddr2563, align 8
  %call2566 = call ptr @lock_user(i32 noundef 3, i64 noundef %1505, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call2566, ptr %__hptr2564, align 8
  %tobool2567 = icmp ne ptr %call2566, null
  br i1 %tobool2567, label %if.then2568, label %if.else2572

if.then2568:                                      ; preds = %if.then2562
  br label %do.body2569

do.body2569:                                      ; preds = %if.then2568
  %1506 = load ptr, ptr %__hptr2564, align 8
  %1507 = load i32, ptr %rgid, align 4
  %call2570 = call i32 @high2lowgid(i32 noundef %1507)
  call void @stl_le_p(ptr noundef %1506, i32 noundef %call2570)
  br label %do.end2571

do.end2571:                                       ; preds = %do.body2569
  %1508 = load ptr, ptr %__hptr2564, align 8
  %1509 = load i64, ptr %__gaddr2563, align 8
  call void @unlock_user(ptr noundef %1508, i64 noundef %1509, i64 noundef 4)
  br label %if.end2573

if.else2572:                                      ; preds = %if.then2562
  store i64 -14, ptr %__ret2565, align 8
  br label %if.end2573

if.end2573:                                       ; preds = %if.else2572, %do.end2571
  %1510 = load i64, ptr %__ret2565, align 8
  store i64 %1510, ptr %tmp2574, align 8
  %1511 = load i64, ptr %tmp2574, align 8
  %tobool2575 = icmp ne i64 %1511, 0
  br i1 %tobool2575, label %if.then2604, label %lor.lhs.false2576

lor.lhs.false2576:                                ; preds = %if.end2573
  %1512 = load i64, ptr %arg2.addr, align 8
  store i64 %1512, ptr %__gaddr2577, align 8
  store i64 0, ptr %__ret2579, align 8
  %1513 = load i64, ptr %__gaddr2577, align 8
  %call2580 = call ptr @lock_user(i32 noundef 3, i64 noundef %1513, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call2580, ptr %__hptr2578, align 8
  %tobool2581 = icmp ne ptr %call2580, null
  br i1 %tobool2581, label %if.then2582, label %if.else2586

if.then2582:                                      ; preds = %lor.lhs.false2576
  br label %do.body2583

do.body2583:                                      ; preds = %if.then2582
  %1514 = load ptr, ptr %__hptr2578, align 8
  %1515 = load i32, ptr %egid, align 4
  %call2584 = call i32 @high2lowgid(i32 noundef %1515)
  call void @stl_le_p(ptr noundef %1514, i32 noundef %call2584)
  br label %do.end2585

do.end2585:                                       ; preds = %do.body2583
  %1516 = load ptr, ptr %__hptr2578, align 8
  %1517 = load i64, ptr %__gaddr2577, align 8
  call void @unlock_user(ptr noundef %1516, i64 noundef %1517, i64 noundef 4)
  br label %if.end2587

if.else2586:                                      ; preds = %lor.lhs.false2576
  store i64 -14, ptr %__ret2579, align 8
  br label %if.end2587

if.end2587:                                       ; preds = %if.else2586, %do.end2585
  %1518 = load i64, ptr %__ret2579, align 8
  store i64 %1518, ptr %tmp2588, align 8
  %1519 = load i64, ptr %tmp2588, align 8
  %tobool2589 = icmp ne i64 %1519, 0
  br i1 %tobool2589, label %if.then2604, label %lor.lhs.false2590

lor.lhs.false2590:                                ; preds = %if.end2587
  %1520 = load i64, ptr %arg3.addr, align 8
  store i64 %1520, ptr %__gaddr2591, align 8
  store i64 0, ptr %__ret2593, align 8
  %1521 = load i64, ptr %__gaddr2591, align 8
  %call2594 = call ptr @lock_user(i32 noundef 3, i64 noundef %1521, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call2594, ptr %__hptr2592, align 8
  %tobool2595 = icmp ne ptr %call2594, null
  br i1 %tobool2595, label %if.then2596, label %if.else2600

if.then2596:                                      ; preds = %lor.lhs.false2590
  br label %do.body2597

do.body2597:                                      ; preds = %if.then2596
  %1522 = load ptr, ptr %__hptr2592, align 8
  %1523 = load i32, ptr %sgid, align 4
  %call2598 = call i32 @high2lowgid(i32 noundef %1523)
  call void @stl_le_p(ptr noundef %1522, i32 noundef %call2598)
  br label %do.end2599

do.end2599:                                       ; preds = %do.body2597
  %1524 = load ptr, ptr %__hptr2592, align 8
  %1525 = load i64, ptr %__gaddr2591, align 8
  call void @unlock_user(ptr noundef %1524, i64 noundef %1525, i64 noundef 4)
  br label %if.end2601

if.else2600:                                      ; preds = %lor.lhs.false2590
  store i64 -14, ptr %__ret2593, align 8
  br label %if.end2601

if.end2601:                                       ; preds = %if.else2600, %do.end2599
  %1526 = load i64, ptr %__ret2593, align 8
  store i64 %1526, ptr %tmp2602, align 8
  %1527 = load i64, ptr %tmp2602, align 8
  %tobool2603 = icmp ne i64 %1527, 0
  br i1 %tobool2603, label %if.then2604, label %if.end2605

if.then2604:                                      ; preds = %if.end2601, %if.end2587, %if.end2573
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2605:                                       ; preds = %if.end2601
  br label %if.end2606

if.end2606:                                       ; preds = %if.end2605, %sw.bb2556
  %1528 = load i64, ptr %ret, align 8
  store i64 %1528, ptr %retval, align 8
  br label %return

sw.bb2607:                                        ; preds = %entry
  %1529 = load i64, ptr %arg1.addr, align 8
  %conv2608 = trunc i64 %1529 to i32
  %call2609 = call i32 @low2highuid(i32 noundef %conv2608)
  %call2610 = call i32 @sys_setuid(i32 noundef %call2609)
  %conv2611 = sext i32 %call2610 to i64
  %call2612 = call i64 @get_errno(i64 noundef %conv2611)
  store i64 %call2612, ptr %retval, align 8
  br label %return

sw.bb2613:                                        ; preds = %entry
  %1530 = load i64, ptr %arg1.addr, align 8
  %conv2614 = trunc i64 %1530 to i32
  %call2615 = call i32 @low2highgid(i32 noundef %conv2614)
  %call2616 = call i32 @sys_setgid(i32 noundef %call2615)
  %conv2617 = sext i32 %call2616 to i64
  %call2618 = call i64 @get_errno(i64 noundef %conv2617)
  store i64 %call2618, ptr %retval, align 8
  br label %return

sw.bb2619:                                        ; preds = %entry
  %1531 = load i64, ptr %arg1.addr, align 8
  %conv2620 = trunc i64 %1531 to i32
  %call2621 = call i32 @setfsuid(i32 noundef %conv2620) #14
  %conv2622 = sext i32 %call2621 to i64
  %call2623 = call i64 @get_errno(i64 noundef %conv2622)
  store i64 %call2623, ptr %retval, align 8
  br label %return

sw.bb2624:                                        ; preds = %entry
  %1532 = load i64, ptr %arg1.addr, align 8
  %conv2625 = trunc i64 %1532 to i32
  %call2626 = call i32 @setfsgid(i32 noundef %conv2625) #14
  %conv2627 = sext i32 %call2626 to i64
  %call2628 = call i64 @get_errno(i64 noundef %conv2627)
  store i64 %call2628, ptr %retval, align 8
  br label %return

sw.bb2629:                                        ; preds = %entry
  %1533 = load i64, ptr %arg1.addr, align 8
  %1534 = load i64, ptr %arg2.addr, align 8
  %call2630 = call ptr @lock_user(i32 noundef 0, i64 noundef %1533, i64 noundef %1534, i1 noundef zeroext false)
  store ptr %call2630, ptr %a, align 8
  %1535 = load ptr, ptr %a, align 8
  %tobool2631 = icmp ne ptr %1535, null
  br i1 %tobool2631, label %if.end2633, label %if.then2632

if.then2632:                                      ; preds = %sw.bb2629
  store i64 -12, ptr %retval, align 8
  br label %return

if.end2633:                                       ; preds = %sw.bb2629
  %1536 = load i64, ptr %arg3.addr, align 8
  %call2634 = call ptr @lock_user_string(i64 noundef %1536)
  store ptr %call2634, ptr %p, align 8
  %1537 = load ptr, ptr %p, align 8
  %tobool2635 = icmp ne ptr %1537, null
  br i1 %tobool2635, label %if.else2637, label %if.then2636

if.then2636:                                      ; preds = %if.end2633
  store i64 -14, ptr %ret, align 8
  br label %if.end2641

if.else2637:                                      ; preds = %if.end2633
  %1538 = load ptr, ptr %a, align 8
  %1539 = load i64, ptr %arg2.addr, align 8
  %1540 = load ptr, ptr %p, align 8
  %call2638 = call i32 @mincore(ptr noundef %1538, i64 noundef %1539, ptr noundef %1540) #14
  %conv2639 = sext i32 %call2638 to i64
  %call2640 = call i64 @get_errno(i64 noundef %conv2639)
  store i64 %call2640, ptr %ret, align 8
  %1541 = load ptr, ptr %p, align 8
  %1542 = load i64, ptr %arg3.addr, align 8
  %1543 = load i64, ptr %ret, align 8
  call void @unlock_user(ptr noundef %1541, i64 noundef %1542, i64 noundef %1543)
  br label %if.end2641

if.end2641:                                       ; preds = %if.else2637, %if.then2636
  %1544 = load ptr, ptr %a, align 8
  %1545 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %1544, i64 noundef %1545, i64 noundef 0)
  %1546 = load i64, ptr %ret, align 8
  store i64 %1546, ptr %retval, align 8
  br label %return

sw.bb2642:                                        ; preds = %entry
  %1547 = load i64, ptr %arg1.addr, align 8
  %conv2643 = trunc i64 %1547 to i32
  %1548 = load i64, ptr %arg2.addr, align 8
  %1549 = load i64, ptr %arg3.addr, align 8
  %1550 = load i64, ptr %arg4.addr, align 8
  %conv2644 = trunc i64 %1550 to i32
  %call2645 = call i32 @posix_fadvise64(i32 noundef %conv2643, i64 noundef %1548, i64 noundef %1549, i32 noundef %conv2644) #14
  %call2646 = call i32 @host_to_target_errno(i32 noundef %call2645)
  %sub2647 = sub i32 0, %call2646
  %conv2648 = sext i32 %sub2647 to i64
  store i64 %conv2648, ptr %retval, align 8
  br label %return

sw.bb2649:                                        ; preds = %entry
  %1551 = load i64, ptr %arg1.addr, align 8
  %1552 = load i64, ptr %arg2.addr, align 8
  %1553 = load i64, ptr %arg3.addr, align 8
  %conv2650 = trunc i64 %1553 to i32
  %call2651 = call i64 @target_madvise(i64 noundef %1551, i64 noundef %1552, i32 noundef %conv2650)
  store i64 %call2651, ptr %retval, align 8
  br label %return

sw.bb2652:                                        ; preds = %entry
  %call2653 = call i32 @sys_gettid()
  %conv2654 = sext i32 %call2653 to i64
  %call2655 = call i64 @get_errno(i64 noundef %conv2654)
  store i64 %call2655, ptr %retval, align 8
  br label %return

sw.bb2656:                                        ; preds = %entry
  %1554 = load i64, ptr %arg1.addr, align 8
  %conv2657 = trunc i64 %1554 to i32
  %1555 = load i64, ptr %arg2.addr, align 8
  %1556 = load i64, ptr %arg3.addr, align 8
  %call2658 = call i64 @readahead(i32 noundef %conv2657, i64 noundef %1555, i64 noundef %1556) #14
  %call2659 = call i64 @get_errno(i64 noundef %call2658)
  store i64 %call2659, ptr %ret, align 8
  %1557 = load i64, ptr %ret, align 8
  store i64 %1557, ptr %retval, align 8
  br label %return

sw.bb2660:                                        ; preds = %entry, %entry
  store ptr null, ptr %b, align 8
  %1558 = load i64, ptr %arg2.addr, align 8
  %tobool2661 = icmp ne i64 %1558, 0
  br i1 %tobool2661, label %if.then2662, label %if.end2667

if.then2662:                                      ; preds = %sw.bb2660
  %1559 = load i64, ptr %arg2.addr, align 8
  %1560 = load i64, ptr %arg3.addr, align 8
  %call2663 = call ptr @lock_user(i32 noundef 3, i64 noundef %1559, i64 noundef %1560, i1 noundef zeroext false)
  store ptr %call2663, ptr %b, align 8
  %1561 = load ptr, ptr %b, align 8
  %tobool2664 = icmp ne ptr %1561, null
  br i1 %tobool2664, label %if.end2666, label %if.then2665

if.then2665:                                      ; preds = %if.then2662
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2666:                                       ; preds = %if.then2662
  br label %if.end2667

if.end2667:                                       ; preds = %if.end2666, %sw.bb2660
  %1562 = load i64, ptr %arg1.addr, align 8
  %call2668 = call ptr @lock_user_string(i64 noundef %1562)
  store ptr %call2668, ptr %p, align 8
  %1563 = load ptr, ptr %p, align 8
  %tobool2669 = icmp ne ptr %1563, null
  br i1 %tobool2669, label %if.then2670, label %if.else2680

if.then2670:                                      ; preds = %if.end2667
  %1564 = load i32, ptr %num.addr, align 4
  %cmp2671 = icmp eq i32 %1564, 11
  br i1 %cmp2671, label %if.then2673, label %if.else2676

if.then2673:                                      ; preds = %if.then2670
  %1565 = load ptr, ptr %p, align 8
  %1566 = load ptr, ptr %b, align 8
  %1567 = load i64, ptr %arg3.addr, align 8
  %call2674 = call i64 @listxattr(ptr noundef %1565, ptr noundef %1566, i64 noundef %1567) #14
  %call2675 = call i64 @get_errno(i64 noundef %call2674)
  store i64 %call2675, ptr %ret, align 8
  br label %if.end2679

if.else2676:                                      ; preds = %if.then2670
  %1568 = load ptr, ptr %p, align 8
  %1569 = load ptr, ptr %b, align 8
  %1570 = load i64, ptr %arg3.addr, align 8
  %call2677 = call i64 @llistxattr(ptr noundef %1568, ptr noundef %1569, i64 noundef %1570) #14
  %call2678 = call i64 @get_errno(i64 noundef %call2677)
  store i64 %call2678, ptr %ret, align 8
  br label %if.end2679

if.end2679:                                       ; preds = %if.else2676, %if.then2673
  br label %if.end2681

if.else2680:                                      ; preds = %if.end2667
  store i64 -14, ptr %ret, align 8
  br label %if.end2681

if.end2681:                                       ; preds = %if.else2680, %if.end2679
  %1571 = load ptr, ptr %p, align 8
  %1572 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %1571, i64 noundef %1572, i64 noundef 0)
  %1573 = load ptr, ptr %b, align 8
  %1574 = load i64, ptr %arg2.addr, align 8
  %1575 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %1573, i64 noundef %1574, i64 noundef %1575)
  %1576 = load i64, ptr %ret, align 8
  store i64 %1576, ptr %retval, align 8
  br label %return

sw.bb2682:                                        ; preds = %entry
  store ptr null, ptr %b2683, align 8
  %1577 = load i64, ptr %arg2.addr, align 8
  %tobool2684 = icmp ne i64 %1577, 0
  br i1 %tobool2684, label %if.then2685, label %if.end2690

if.then2685:                                      ; preds = %sw.bb2682
  %1578 = load i64, ptr %arg2.addr, align 8
  %1579 = load i64, ptr %arg3.addr, align 8
  %call2686 = call ptr @lock_user(i32 noundef 3, i64 noundef %1578, i64 noundef %1579, i1 noundef zeroext false)
  store ptr %call2686, ptr %b2683, align 8
  %1580 = load ptr, ptr %b2683, align 8
  %tobool2687 = icmp ne ptr %1580, null
  br i1 %tobool2687, label %if.end2689, label %if.then2688

if.then2688:                                      ; preds = %if.then2685
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2689:                                       ; preds = %if.then2685
  br label %if.end2690

if.end2690:                                       ; preds = %if.end2689, %sw.bb2682
  %1581 = load i64, ptr %arg1.addr, align 8
  %conv2691 = trunc i64 %1581 to i32
  %1582 = load ptr, ptr %b2683, align 8
  %1583 = load i64, ptr %arg3.addr, align 8
  %call2692 = call i64 @flistxattr(i32 noundef %conv2691, ptr noundef %1582, i64 noundef %1583) #14
  %call2693 = call i64 @get_errno(i64 noundef %call2692)
  store i64 %call2693, ptr %ret, align 8
  %1584 = load ptr, ptr %b2683, align 8
  %1585 = load i64, ptr %arg2.addr, align 8
  %1586 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %1584, i64 noundef %1585, i64 noundef %1586)
  %1587 = load i64, ptr %ret, align 8
  store i64 %1587, ptr %retval, align 8
  br label %return

sw.bb2694:                                        ; preds = %entry, %entry
  store ptr null, ptr %v, align 8
  %1588 = load i64, ptr %arg3.addr, align 8
  %tobool2695 = icmp ne i64 %1588, 0
  br i1 %tobool2695, label %if.then2696, label %if.end2701

if.then2696:                                      ; preds = %sw.bb2694
  %1589 = load i64, ptr %arg3.addr, align 8
  %1590 = load i64, ptr %arg4.addr, align 8
  %call2697 = call ptr @lock_user(i32 noundef 1, i64 noundef %1589, i64 noundef %1590, i1 noundef zeroext true)
  store ptr %call2697, ptr %v, align 8
  %1591 = load ptr, ptr %v, align 8
  %tobool2698 = icmp ne ptr %1591, null
  br i1 %tobool2698, label %if.end2700, label %if.then2699

if.then2699:                                      ; preds = %if.then2696
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2700:                                       ; preds = %if.then2696
  br label %if.end2701

if.end2701:                                       ; preds = %if.end2700, %sw.bb2694
  %1592 = load i64, ptr %arg1.addr, align 8
  %call2702 = call ptr @lock_user_string(i64 noundef %1592)
  store ptr %call2702, ptr %p, align 8
  %1593 = load i64, ptr %arg2.addr, align 8
  %call2703 = call ptr @lock_user_string(i64 noundef %1593)
  store ptr %call2703, ptr %n, align 8
  %1594 = load ptr, ptr %p, align 8
  %tobool2704 = icmp ne ptr %1594, null
  br i1 %tobool2704, label %land.lhs.true2705, label %if.else2721

land.lhs.true2705:                                ; preds = %if.end2701
  %1595 = load ptr, ptr %n, align 8
  %tobool2706 = icmp ne ptr %1595, null
  br i1 %tobool2706, label %if.then2707, label %if.else2721

if.then2707:                                      ; preds = %land.lhs.true2705
  %1596 = load i32, ptr %num.addr, align 4
  %cmp2708 = icmp eq i32 %1596, 5
  br i1 %cmp2708, label %if.then2710, label %if.else2715

if.then2710:                                      ; preds = %if.then2707
  %1597 = load ptr, ptr %p, align 8
  %1598 = load ptr, ptr %n, align 8
  %1599 = load ptr, ptr %v, align 8
  %1600 = load i64, ptr %arg4.addr, align 8
  %1601 = load i64, ptr %arg5.addr, align 8
  %conv2711 = trunc i64 %1601 to i32
  %call2712 = call i32 @setxattr(ptr noundef %1597, ptr noundef %1598, ptr noundef %1599, i64 noundef %1600, i32 noundef %conv2711) #14
  %conv2713 = sext i32 %call2712 to i64
  %call2714 = call i64 @get_errno(i64 noundef %conv2713)
  store i64 %call2714, ptr %ret, align 8
  br label %if.end2720

if.else2715:                                      ; preds = %if.then2707
  %1602 = load ptr, ptr %p, align 8
  %1603 = load ptr, ptr %n, align 8
  %1604 = load ptr, ptr %v, align 8
  %1605 = load i64, ptr %arg4.addr, align 8
  %1606 = load i64, ptr %arg5.addr, align 8
  %conv2716 = trunc i64 %1606 to i32
  %call2717 = call i32 @lsetxattr(ptr noundef %1602, ptr noundef %1603, ptr noundef %1604, i64 noundef %1605, i32 noundef %conv2716) #14
  %conv2718 = sext i32 %call2717 to i64
  %call2719 = call i64 @get_errno(i64 noundef %conv2718)
  store i64 %call2719, ptr %ret, align 8
  br label %if.end2720

if.end2720:                                       ; preds = %if.else2715, %if.then2710
  br label %if.end2722

if.else2721:                                      ; preds = %land.lhs.true2705, %if.end2701
  store i64 -14, ptr %ret, align 8
  br label %if.end2722

if.end2722:                                       ; preds = %if.else2721, %if.end2720
  %1607 = load ptr, ptr %p, align 8
  %1608 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %1607, i64 noundef %1608, i64 noundef 0)
  %1609 = load ptr, ptr %n, align 8
  %1610 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1609, i64 noundef %1610, i64 noundef 0)
  %1611 = load ptr, ptr %v, align 8
  %1612 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %1611, i64 noundef %1612, i64 noundef 0)
  %1613 = load i64, ptr %ret, align 8
  store i64 %1613, ptr %retval, align 8
  br label %return

sw.bb2723:                                        ; preds = %entry
  store ptr null, ptr %v2725, align 8
  %1614 = load i64, ptr %arg3.addr, align 8
  %tobool2726 = icmp ne i64 %1614, 0
  br i1 %tobool2726, label %if.then2727, label %if.end2732

if.then2727:                                      ; preds = %sw.bb2723
  %1615 = load i64, ptr %arg3.addr, align 8
  %1616 = load i64, ptr %arg4.addr, align 8
  %call2728 = call ptr @lock_user(i32 noundef 1, i64 noundef %1615, i64 noundef %1616, i1 noundef zeroext true)
  store ptr %call2728, ptr %v2725, align 8
  %1617 = load ptr, ptr %v2725, align 8
  %tobool2729 = icmp ne ptr %1617, null
  br i1 %tobool2729, label %if.end2731, label %if.then2730

if.then2730:                                      ; preds = %if.then2727
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2731:                                       ; preds = %if.then2727
  br label %if.end2732

if.end2732:                                       ; preds = %if.end2731, %sw.bb2723
  %1618 = load i64, ptr %arg2.addr, align 8
  %call2733 = call ptr @lock_user_string(i64 noundef %1618)
  store ptr %call2733, ptr %n2724, align 8
  %1619 = load ptr, ptr %n2724, align 8
  %tobool2734 = icmp ne ptr %1619, null
  br i1 %tobool2734, label %if.then2735, label %if.else2741

if.then2735:                                      ; preds = %if.end2732
  %1620 = load i64, ptr %arg1.addr, align 8
  %conv2736 = trunc i64 %1620 to i32
  %1621 = load ptr, ptr %n2724, align 8
  %1622 = load ptr, ptr %v2725, align 8
  %1623 = load i64, ptr %arg4.addr, align 8
  %1624 = load i64, ptr %arg5.addr, align 8
  %conv2737 = trunc i64 %1624 to i32
  %call2738 = call i32 @fsetxattr(i32 noundef %conv2736, ptr noundef %1621, ptr noundef %1622, i64 noundef %1623, i32 noundef %conv2737) #14
  %conv2739 = sext i32 %call2738 to i64
  %call2740 = call i64 @get_errno(i64 noundef %conv2739)
  store i64 %call2740, ptr %ret, align 8
  br label %if.end2742

if.else2741:                                      ; preds = %if.end2732
  store i64 -14, ptr %ret, align 8
  br label %if.end2742

if.end2742:                                       ; preds = %if.else2741, %if.then2735
  %1625 = load ptr, ptr %n2724, align 8
  %1626 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1625, i64 noundef %1626, i64 noundef 0)
  %1627 = load ptr, ptr %v2725, align 8
  %1628 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %1627, i64 noundef %1628, i64 noundef 0)
  %1629 = load i64, ptr %ret, align 8
  store i64 %1629, ptr %retval, align 8
  br label %return

sw.bb2743:                                        ; preds = %entry, %entry
  store ptr null, ptr %v2745, align 8
  %1630 = load i64, ptr %arg3.addr, align 8
  %tobool2746 = icmp ne i64 %1630, 0
  br i1 %tobool2746, label %if.then2747, label %if.end2752

if.then2747:                                      ; preds = %sw.bb2743
  %1631 = load i64, ptr %arg3.addr, align 8
  %1632 = load i64, ptr %arg4.addr, align 8
  %call2748 = call ptr @lock_user(i32 noundef 3, i64 noundef %1631, i64 noundef %1632, i1 noundef zeroext false)
  store ptr %call2748, ptr %v2745, align 8
  %1633 = load ptr, ptr %v2745, align 8
  %tobool2749 = icmp ne ptr %1633, null
  br i1 %tobool2749, label %if.end2751, label %if.then2750

if.then2750:                                      ; preds = %if.then2747
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2751:                                       ; preds = %if.then2747
  br label %if.end2752

if.end2752:                                       ; preds = %if.end2751, %sw.bb2743
  %1634 = load i64, ptr %arg1.addr, align 8
  %call2753 = call ptr @lock_user_string(i64 noundef %1634)
  store ptr %call2753, ptr %p, align 8
  %1635 = load i64, ptr %arg2.addr, align 8
  %call2754 = call ptr @lock_user_string(i64 noundef %1635)
  store ptr %call2754, ptr %n2744, align 8
  %1636 = load ptr, ptr %p, align 8
  %tobool2755 = icmp ne ptr %1636, null
  br i1 %tobool2755, label %land.lhs.true2756, label %if.else2768

land.lhs.true2756:                                ; preds = %if.end2752
  %1637 = load ptr, ptr %n2744, align 8
  %tobool2757 = icmp ne ptr %1637, null
  br i1 %tobool2757, label %if.then2758, label %if.else2768

if.then2758:                                      ; preds = %land.lhs.true2756
  %1638 = load i32, ptr %num.addr, align 4
  %cmp2759 = icmp eq i32 %1638, 8
  br i1 %cmp2759, label %if.then2761, label %if.else2764

if.then2761:                                      ; preds = %if.then2758
  %1639 = load ptr, ptr %p, align 8
  %1640 = load ptr, ptr %n2744, align 8
  %1641 = load ptr, ptr %v2745, align 8
  %1642 = load i64, ptr %arg4.addr, align 8
  %call2762 = call i64 @getxattr(ptr noundef %1639, ptr noundef %1640, ptr noundef %1641, i64 noundef %1642) #14
  %call2763 = call i64 @get_errno(i64 noundef %call2762)
  store i64 %call2763, ptr %ret, align 8
  br label %if.end2767

if.else2764:                                      ; preds = %if.then2758
  %1643 = load ptr, ptr %p, align 8
  %1644 = load ptr, ptr %n2744, align 8
  %1645 = load ptr, ptr %v2745, align 8
  %1646 = load i64, ptr %arg4.addr, align 8
  %call2765 = call i64 @lgetxattr(ptr noundef %1643, ptr noundef %1644, ptr noundef %1645, i64 noundef %1646) #14
  %call2766 = call i64 @get_errno(i64 noundef %call2765)
  store i64 %call2766, ptr %ret, align 8
  br label %if.end2767

if.end2767:                                       ; preds = %if.else2764, %if.then2761
  br label %if.end2769

if.else2768:                                      ; preds = %land.lhs.true2756, %if.end2752
  store i64 -14, ptr %ret, align 8
  br label %if.end2769

if.end2769:                                       ; preds = %if.else2768, %if.end2767
  %1647 = load ptr, ptr %p, align 8
  %1648 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %1647, i64 noundef %1648, i64 noundef 0)
  %1649 = load ptr, ptr %n2744, align 8
  %1650 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1649, i64 noundef %1650, i64 noundef 0)
  %1651 = load ptr, ptr %v2745, align 8
  %1652 = load i64, ptr %arg3.addr, align 8
  %1653 = load i64, ptr %arg4.addr, align 8
  call void @unlock_user(ptr noundef %1651, i64 noundef %1652, i64 noundef %1653)
  %1654 = load i64, ptr %ret, align 8
  store i64 %1654, ptr %retval, align 8
  br label %return

sw.bb2770:                                        ; preds = %entry
  store ptr null, ptr %v2772, align 8
  %1655 = load i64, ptr %arg3.addr, align 8
  %tobool2773 = icmp ne i64 %1655, 0
  br i1 %tobool2773, label %if.then2774, label %if.end2779

if.then2774:                                      ; preds = %sw.bb2770
  %1656 = load i64, ptr %arg3.addr, align 8
  %1657 = load i64, ptr %arg4.addr, align 8
  %call2775 = call ptr @lock_user(i32 noundef 3, i64 noundef %1656, i64 noundef %1657, i1 noundef zeroext false)
  store ptr %call2775, ptr %v2772, align 8
  %1658 = load ptr, ptr %v2772, align 8
  %tobool2776 = icmp ne ptr %1658, null
  br i1 %tobool2776, label %if.end2778, label %if.then2777

if.then2777:                                      ; preds = %if.then2774
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2778:                                       ; preds = %if.then2774
  br label %if.end2779

if.end2779:                                       ; preds = %if.end2778, %sw.bb2770
  %1659 = load i64, ptr %arg2.addr, align 8
  %call2780 = call ptr @lock_user_string(i64 noundef %1659)
  store ptr %call2780, ptr %n2771, align 8
  %1660 = load ptr, ptr %n2771, align 8
  %tobool2781 = icmp ne ptr %1660, null
  br i1 %tobool2781, label %if.then2782, label %if.else2786

if.then2782:                                      ; preds = %if.end2779
  %1661 = load i64, ptr %arg1.addr, align 8
  %conv2783 = trunc i64 %1661 to i32
  %1662 = load ptr, ptr %n2771, align 8
  %1663 = load ptr, ptr %v2772, align 8
  %1664 = load i64, ptr %arg4.addr, align 8
  %call2784 = call i64 @fgetxattr(i32 noundef %conv2783, ptr noundef %1662, ptr noundef %1663, i64 noundef %1664) #14
  %call2785 = call i64 @get_errno(i64 noundef %call2784)
  store i64 %call2785, ptr %ret, align 8
  br label %if.end2787

if.else2786:                                      ; preds = %if.end2779
  store i64 -14, ptr %ret, align 8
  br label %if.end2787

if.end2787:                                       ; preds = %if.else2786, %if.then2782
  %1665 = load ptr, ptr %n2771, align 8
  %1666 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1665, i64 noundef %1666, i64 noundef 0)
  %1667 = load ptr, ptr %v2772, align 8
  %1668 = load i64, ptr %arg3.addr, align 8
  %1669 = load i64, ptr %arg4.addr, align 8
  call void @unlock_user(ptr noundef %1667, i64 noundef %1668, i64 noundef %1669)
  %1670 = load i64, ptr %ret, align 8
  store i64 %1670, ptr %retval, align 8
  br label %return

sw.bb2788:                                        ; preds = %entry, %entry
  %1671 = load i64, ptr %arg1.addr, align 8
  %call2790 = call ptr @lock_user_string(i64 noundef %1671)
  store ptr %call2790, ptr %p, align 8
  %1672 = load i64, ptr %arg2.addr, align 8
  %call2791 = call ptr @lock_user_string(i64 noundef %1672)
  store ptr %call2791, ptr %n2789, align 8
  %1673 = load ptr, ptr %p, align 8
  %tobool2792 = icmp ne ptr %1673, null
  br i1 %tobool2792, label %land.lhs.true2793, label %if.else2807

land.lhs.true2793:                                ; preds = %sw.bb2788
  %1674 = load ptr, ptr %n2789, align 8
  %tobool2794 = icmp ne ptr %1674, null
  br i1 %tobool2794, label %if.then2795, label %if.else2807

if.then2795:                                      ; preds = %land.lhs.true2793
  %1675 = load i32, ptr %num.addr, align 4
  %cmp2796 = icmp eq i32 %1675, 14
  br i1 %cmp2796, label %if.then2798, label %if.else2802

if.then2798:                                      ; preds = %if.then2795
  %1676 = load ptr, ptr %p, align 8
  %1677 = load ptr, ptr %n2789, align 8
  %call2799 = call i32 @removexattr(ptr noundef %1676, ptr noundef %1677) #14
  %conv2800 = sext i32 %call2799 to i64
  %call2801 = call i64 @get_errno(i64 noundef %conv2800)
  store i64 %call2801, ptr %ret, align 8
  br label %if.end2806

if.else2802:                                      ; preds = %if.then2795
  %1678 = load ptr, ptr %p, align 8
  %1679 = load ptr, ptr %n2789, align 8
  %call2803 = call i32 @lremovexattr(ptr noundef %1678, ptr noundef %1679) #14
  %conv2804 = sext i32 %call2803 to i64
  %call2805 = call i64 @get_errno(i64 noundef %conv2804)
  store i64 %call2805, ptr %ret, align 8
  br label %if.end2806

if.end2806:                                       ; preds = %if.else2802, %if.then2798
  br label %if.end2808

if.else2807:                                      ; preds = %land.lhs.true2793, %sw.bb2788
  store i64 -14, ptr %ret, align 8
  br label %if.end2808

if.end2808:                                       ; preds = %if.else2807, %if.end2806
  %1680 = load ptr, ptr %p, align 8
  %1681 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %1680, i64 noundef %1681, i64 noundef 0)
  %1682 = load ptr, ptr %n2789, align 8
  %1683 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1682, i64 noundef %1683, i64 noundef 0)
  %1684 = load i64, ptr %ret, align 8
  store i64 %1684, ptr %retval, align 8
  br label %return

sw.bb2809:                                        ; preds = %entry
  %1685 = load i64, ptr %arg2.addr, align 8
  %call2811 = call ptr @lock_user_string(i64 noundef %1685)
  store ptr %call2811, ptr %n2810, align 8
  %1686 = load ptr, ptr %n2810, align 8
  %tobool2812 = icmp ne ptr %1686, null
  br i1 %tobool2812, label %if.then2813, label %if.else2818

if.then2813:                                      ; preds = %sw.bb2809
  %1687 = load i64, ptr %arg1.addr, align 8
  %conv2814 = trunc i64 %1687 to i32
  %1688 = load ptr, ptr %n2810, align 8
  %call2815 = call i32 @fremovexattr(i32 noundef %conv2814, ptr noundef %1688) #14
  %conv2816 = sext i32 %call2815 to i64
  %call2817 = call i64 @get_errno(i64 noundef %conv2816)
  store i64 %call2817, ptr %ret, align 8
  br label %if.end2819

if.else2818:                                      ; preds = %sw.bb2809
  store i64 -14, ptr %ret, align 8
  br label %if.end2819

if.end2819:                                       ; preds = %if.else2818, %if.then2813
  %1689 = load ptr, ptr %n2810, align 8
  %1690 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1689, i64 noundef %1690, i64 noundef 0)
  %1691 = load i64, ptr %ret, align 8
  store i64 %1691, ptr %retval, align 8
  br label %return

sw.bb2820:                                        ; preds = %entry
  %1692 = load i64, ptr %arg2.addr, align 8
  %call2822 = call i64 @target_to_host_timespec(ptr noundef %ts2821, i64 noundef %1692)
  store i64 %call2822, ptr %ret, align 8
  %1693 = load i64, ptr %ret, align 8
  %call2823 = call i32 @is_error(i64 noundef %1693)
  %tobool2824 = icmp ne i32 %call2823, 0
  br i1 %tobool2824, label %if.end2830, label %if.then2825

if.then2825:                                      ; preds = %sw.bb2820
  %1694 = load i64, ptr %arg1.addr, align 8
  %conv2826 = trunc i64 %1694 to i32
  %call2827 = call i32 @clock_settime(i32 noundef %conv2826, ptr noundef %ts2821) #14
  %conv2828 = sext i32 %call2827 to i64
  %call2829 = call i64 @get_errno(i64 noundef %conv2828)
  store i64 %call2829, ptr %ret, align 8
  br label %if.end2830

if.end2830:                                       ; preds = %if.then2825, %sw.bb2820
  %1695 = load i64, ptr %ret, align 8
  store i64 %1695, ptr %retval, align 8
  br label %return

sw.bb2831:                                        ; preds = %entry
  %1696 = load i64, ptr %arg1.addr, align 8
  %conv2833 = trunc i64 %1696 to i32
  %call2834 = call i32 @clock_gettime(i32 noundef %conv2833, ptr noundef %ts2832) #14
  %conv2835 = sext i32 %call2834 to i64
  %call2836 = call i64 @get_errno(i64 noundef %conv2835)
  store i64 %call2836, ptr %ret, align 8
  %1697 = load i64, ptr %ret, align 8
  %call2837 = call i32 @is_error(i64 noundef %1697)
  %tobool2838 = icmp ne i32 %call2837, 0
  br i1 %tobool2838, label %if.end2841, label %if.then2839

if.then2839:                                      ; preds = %sw.bb2831
  %1698 = load i64, ptr %arg2.addr, align 8
  %call2840 = call i64 @host_to_target_timespec(i64 noundef %1698, ptr noundef %ts2832)
  store i64 %call2840, ptr %ret, align 8
  br label %if.end2841

if.end2841:                                       ; preds = %if.then2839, %sw.bb2831
  %1699 = load i64, ptr %ret, align 8
  store i64 %1699, ptr %retval, align 8
  br label %return

sw.bb2842:                                        ; preds = %entry
  %1700 = load i64, ptr %arg1.addr, align 8
  %conv2844 = trunc i64 %1700 to i32
  %call2845 = call i32 @clock_getres(i32 noundef %conv2844, ptr noundef %ts2843) #14
  %conv2846 = sext i32 %call2845 to i64
  %call2847 = call i64 @get_errno(i64 noundef %conv2846)
  store i64 %call2847, ptr %ret, align 8
  %1701 = load i64, ptr %ret, align 8
  %call2848 = call i32 @is_error(i64 noundef %1701)
  %tobool2849 = icmp ne i32 %call2848, 0
  br i1 %tobool2849, label %if.end2852, label %if.then2850

if.then2850:                                      ; preds = %sw.bb2842
  %1702 = load i64, ptr %arg2.addr, align 8
  %call2851 = call i64 @host_to_target_timespec(i64 noundef %1702, ptr noundef %ts2843)
  br label %if.end2852

if.end2852:                                       ; preds = %if.then2850, %sw.bb2842
  %1703 = load i64, ptr %ret, align 8
  store i64 %1703, ptr %retval, align 8
  br label %return

sw.bb2853:                                        ; preds = %entry
  %1704 = load i64, ptr %arg3.addr, align 8
  %call2855 = call i64 @target_to_host_timespec(ptr noundef %ts2854, i64 noundef %1704)
  %tobool2856 = icmp ne i64 %call2855, 0
  br i1 %tobool2856, label %if.then2857, label %if.end2858

if.then2857:                                      ; preds = %sw.bb2853
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2858:                                       ; preds = %sw.bb2853
  %1705 = load i64, ptr %arg1.addr, align 8
  %conv2859 = trunc i64 %1705 to i32
  %1706 = load i64, ptr %arg2.addr, align 8
  %conv2860 = trunc i64 %1706 to i32
  %1707 = load i64, ptr %arg4.addr, align 8
  %tobool2861 = icmp ne i64 %1707, 0
  br i1 %tobool2861, label %cond.true2862, label %cond.false2863

cond.true2862:                                    ; preds = %if.end2858
  br label %cond.end2864

cond.false2863:                                   ; preds = %if.end2858
  br label %cond.end2864

cond.end2864:                                     ; preds = %cond.false2863, %cond.true2862
  %cond2865 = phi ptr [ %ts2854, %cond.true2862 ], [ null, %cond.false2863 ]
  %call2866 = call i32 @safe_clock_nanosleep(i32 noundef %conv2859, i32 noundef %conv2860, ptr noundef %ts2854, ptr noundef %cond2865)
  %conv2867 = sext i32 %call2866 to i64
  %call2868 = call i64 @get_errno(i64 noundef %conv2867)
  store i64 %call2868, ptr %ret, align 8
  %1708 = load i64, ptr %ret, align 8
  %cmp2869 = icmp eq i64 %1708, -4
  br i1 %cmp2869, label %land.lhs.true2871, label %if.end2880

land.lhs.true2871:                                ; preds = %cond.end2864
  %1709 = load i64, ptr %arg4.addr, align 8
  %tobool2872 = icmp ne i64 %1709, 0
  br i1 %tobool2872, label %land.lhs.true2873, label %if.end2880

land.lhs.true2873:                                ; preds = %land.lhs.true2871
  %1710 = load i64, ptr %arg2.addr, align 8
  %cmp2874 = icmp ne i64 %1710, 1
  br i1 %cmp2874, label %land.lhs.true2876, label %if.end2880

land.lhs.true2876:                                ; preds = %land.lhs.true2873
  %1711 = load i64, ptr %arg4.addr, align 8
  %call2877 = call i64 @host_to_target_timespec(i64 noundef %1711, ptr noundef %ts2854)
  %tobool2878 = icmp ne i64 %call2877, 0
  br i1 %tobool2878, label %if.then2879, label %if.end2880

if.then2879:                                      ; preds = %land.lhs.true2876
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2880:                                       ; preds = %land.lhs.true2876, %land.lhs.true2873, %land.lhs.true2871, %cond.end2864
  %1712 = load i64, ptr %ret, align 8
  store i64 %1712, ptr %retval, align 8
  br label %return

sw.bb2881:                                        ; preds = %entry
  %1713 = load ptr, ptr %cpu, align 8
  %opaque2883 = getelementptr inbounds %struct.CPUState, ptr %1713, i32 0, i32 39
  %1714 = load ptr, ptr %opaque2883, align 16
  store ptr %1714, ptr %ts2882, align 8
  %1715 = load i64, ptr %arg1.addr, align 8
  %1716 = load ptr, ptr %ts2882, align 8
  %child_tidptr2884 = getelementptr inbounds %struct.TaskState, ptr %1716, i32 0, i32 2
  store i64 %1715, ptr %child_tidptr2884, align 8
  %call2885 = call i32 @sys_gettid()
  %conv2886 = sext i32 %call2885 to i64
  %call2887 = call i64 @get_errno(i64 noundef %conv2886)
  store i64 %call2887, ptr %retval, align 8
  br label %return

sw.bb2888:                                        ; preds = %entry
  %1717 = load i64, ptr %arg1.addr, align 8
  %conv2889 = trunc i64 %1717 to i32
  %1718 = load i64, ptr %arg2.addr, align 8
  %conv2890 = trunc i64 %1718 to i32
  %call2891 = call i32 @target_to_host_signal(i32 noundef %conv2890)
  %call2892 = call i32 @safe_tkill(i32 noundef %conv2889, i32 noundef %call2891)
  %conv2893 = sext i32 %call2892 to i64
  %call2894 = call i64 @get_errno(i64 noundef %conv2893)
  store i64 %call2894, ptr %retval, align 8
  br label %return

sw.bb2895:                                        ; preds = %entry
  %1719 = load i64, ptr %arg1.addr, align 8
  %conv2896 = trunc i64 %1719 to i32
  %1720 = load i64, ptr %arg2.addr, align 8
  %conv2897 = trunc i64 %1720 to i32
  %1721 = load i64, ptr %arg3.addr, align 8
  %conv2898 = trunc i64 %1721 to i32
  %call2899 = call i32 @target_to_host_signal(i32 noundef %conv2898)
  %call2900 = call i32 @safe_tgkill(i32 noundef %conv2896, i32 noundef %conv2897, i32 noundef %call2899)
  %conv2901 = sext i32 %call2900 to i64
  %call2902 = call i64 @get_errno(i64 noundef %conv2901)
  store i64 %call2902, ptr %retval, align 8
  br label %return

sw.bb2903:                                        ; preds = %entry, %entry
  store i64 -38, ptr %retval, align 8
  br label %return

sw.bb2904:                                        ; preds = %entry
  %1722 = load i64, ptr %arg3.addr, align 8
  %tobool2906 = icmp ne i64 %1722, 0
  br i1 %tobool2906, label %if.else2908, label %if.then2907

if.then2907:                                      ; preds = %sw.bb2904
  store ptr null, ptr %tsp, align 8
  br label %if.end2921

if.else2908:                                      ; preds = %sw.bb2904
  %arraydecay2909 = getelementptr inbounds [2 x %struct.timespec], ptr %ts2905, i64 0, i64 0
  %1723 = load i64, ptr %arg3.addr, align 8
  %call2910 = call i64 @target_to_host_timespec(ptr noundef %arraydecay2909, i64 noundef %1723)
  %tobool2911 = icmp ne i64 %call2910, 0
  br i1 %tobool2911, label %if.then2912, label %if.end2913

if.then2912:                                      ; preds = %if.else2908
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2913:                                       ; preds = %if.else2908
  %arraydecay2914 = getelementptr inbounds [2 x %struct.timespec], ptr %ts2905, i64 0, i64 0
  %add.ptr = getelementptr %struct.timespec, ptr %arraydecay2914, i64 1
  %1724 = load i64, ptr %arg3.addr, align 8
  %add2915 = add i64 %1724, 16
  %call2916 = call i64 @target_to_host_timespec(ptr noundef %add.ptr, i64 noundef %add2915)
  %tobool2917 = icmp ne i64 %call2916, 0
  br i1 %tobool2917, label %if.then2918, label %if.end2919

if.then2918:                                      ; preds = %if.end2913
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2919:                                       ; preds = %if.end2913
  %arraydecay2920 = getelementptr inbounds [2 x %struct.timespec], ptr %ts2905, i64 0, i64 0
  store ptr %arraydecay2920, ptr %tsp, align 8
  br label %if.end2921

if.end2921:                                       ; preds = %if.end2919, %if.then2907
  %1725 = load i64, ptr %arg2.addr, align 8
  %tobool2922 = icmp ne i64 %1725, 0
  br i1 %tobool2922, label %if.else2929, label %if.then2923

if.then2923:                                      ; preds = %if.end2921
  %1726 = load i64, ptr %arg1.addr, align 8
  %conv2924 = trunc i64 %1726 to i32
  %1727 = load ptr, ptr %tsp, align 8
  %1728 = load i64, ptr %arg4.addr, align 8
  %conv2925 = trunc i64 %1728 to i32
  %call2926 = call i32 @sys_utimensat(i32 noundef %conv2924, ptr noundef null, ptr noundef %1727, i32 noundef %conv2925)
  %conv2927 = sext i32 %call2926 to i64
  %call2928 = call i64 @get_errno(i64 noundef %conv2927)
  store i64 %call2928, ptr %ret, align 8
  br label %if.end2940

if.else2929:                                      ; preds = %if.end2921
  %1729 = load i64, ptr %arg2.addr, align 8
  %call2930 = call ptr @lock_user_string(i64 noundef %1729)
  store ptr %call2930, ptr %p, align 8
  %tobool2931 = icmp ne ptr %call2930, null
  br i1 %tobool2931, label %if.end2933, label %if.then2932

if.then2932:                                      ; preds = %if.else2929
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2933:                                       ; preds = %if.else2929
  %1730 = load i64, ptr %arg1.addr, align 8
  %conv2934 = trunc i64 %1730 to i32
  %1731 = load ptr, ptr %p, align 8
  %call2935 = call ptr @path(ptr noundef %1731)
  %1732 = load ptr, ptr %tsp, align 8
  %1733 = load i64, ptr %arg4.addr, align 8
  %conv2936 = trunc i64 %1733 to i32
  %call2937 = call i32 @sys_utimensat(i32 noundef %conv2934, ptr noundef %call2935, ptr noundef %1732, i32 noundef %conv2936)
  %conv2938 = sext i32 %call2937 to i64
  %call2939 = call i64 @get_errno(i64 noundef %conv2938)
  store i64 %call2939, ptr %ret, align 8
  %1734 = load ptr, ptr %p, align 8
  %1735 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1734, i64 noundef %1735, i64 noundef 0)
  br label %if.end2940

if.end2940:                                       ; preds = %if.end2933, %if.then2923
  %1736 = load i64, ptr %ret, align 8
  store i64 %1736, ptr %retval, align 8
  br label %return

sw.bb2941:                                        ; preds = %entry
  %1737 = load ptr, ptr %cpu, align 8
  %1738 = load i64, ptr %arg1.addr, align 8
  %1739 = load i64, ptr %arg2.addr, align 8
  %conv2942 = trunc i64 %1739 to i32
  %1740 = load i64, ptr %arg3.addr, align 8
  %conv2943 = trunc i64 %1740 to i32
  %1741 = load i64, ptr %arg4.addr, align 8
  %1742 = load i64, ptr %arg5.addr, align 8
  %1743 = load i64, ptr %arg6.addr, align 8
  %conv2944 = trunc i64 %1743 to i32
  %call2945 = call i32 @do_futex(ptr noundef %1737, i1 noundef zeroext false, i64 noundef %1738, i32 noundef %conv2942, i32 noundef %conv2943, i64 noundef %1741, i64 noundef %1742, i32 noundef %conv2944)
  %conv2946 = sext i32 %call2945 to i64
  store i64 %conv2946, ptr %retval, align 8
  br label %return

sw.bb2947:                                        ; preds = %entry
  %1744 = load i64, ptr %arg1.addr, align 8
  %conv2948 = trunc i64 %1744 to i32
  %call2949 = call i32 @target_to_host_bitmask_len(i32 noundef %conv2948, ptr noundef @fcntl_flags_tbl, i64 noundef 19)
  %call2950 = call i32 @inotify_init1(i32 noundef %call2949) #14
  %conv2951 = sext i32 %call2950 to i64
  %call2952 = call i64 @get_errno(i64 noundef %conv2951)
  store i64 %call2952, ptr %ret, align 8
  %1745 = load i64, ptr %ret, align 8
  %cmp2953 = icmp sge i64 %1745, 0
  br i1 %cmp2953, label %if.then2955, label %if.end2957

if.then2955:                                      ; preds = %sw.bb2947
  %1746 = load i64, ptr %ret, align 8
  %conv2956 = trunc i64 %1746 to i32
  call void @fd_trans_register(i32 noundef %conv2956, ptr noundef @target_inotify_trans)
  br label %if.end2957

if.end2957:                                       ; preds = %if.then2955, %sw.bb2947
  %1747 = load i64, ptr %ret, align 8
  store i64 %1747, ptr %retval, align 8
  br label %return

sw.bb2958:                                        ; preds = %entry
  %1748 = load i64, ptr %arg2.addr, align 8
  %call2959 = call ptr @lock_user_string(i64 noundef %1748)
  store ptr %call2959, ptr %p, align 8
  %1749 = load i64, ptr %arg1.addr, align 8
  %conv2960 = trunc i64 %1749 to i32
  %1750 = load ptr, ptr %p, align 8
  %call2961 = call ptr @path(ptr noundef %1750)
  %1751 = load i64, ptr %arg3.addr, align 8
  %conv2962 = trunc i64 %1751 to i32
  %call2963 = call i32 @inotify_add_watch(i32 noundef %conv2960, ptr noundef %call2961, i32 noundef %conv2962) #14
  %conv2964 = sext i32 %call2963 to i64
  %call2965 = call i64 @get_errno(i64 noundef %conv2964)
  store i64 %call2965, ptr %ret, align 8
  %1752 = load ptr, ptr %p, align 8
  %1753 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1752, i64 noundef %1753, i64 noundef 0)
  %1754 = load i64, ptr %ret, align 8
  store i64 %1754, ptr %retval, align 8
  br label %return

sw.bb2966:                                        ; preds = %entry
  %1755 = load i64, ptr %arg1.addr, align 8
  %conv2967 = trunc i64 %1755 to i32
  %1756 = load i64, ptr %arg2.addr, align 8
  %conv2968 = trunc i64 %1756 to i32
  %call2969 = call i32 @inotify_rm_watch(i32 noundef %conv2967, i32 noundef %conv2968) #14
  %conv2970 = sext i32 %call2969 to i64
  %call2971 = call i64 @get_errno(i64 noundef %conv2970)
  store i64 %call2971, ptr %retval, align 8
  br label %return

sw.bb2972:                                        ; preds = %entry
  %1757 = load i64, ptr %arg2.addr, align 8
  %conv2974 = trunc i64 %1757 to i32
  %call2975 = call i32 @target_to_host_bitmask_len(i32 noundef %conv2974, ptr noundef @fcntl_flags_tbl, i64 noundef 19)
  store i32 %call2975, ptr %host_flags2973, align 4
  store ptr null, ptr %pposix_mq_attr, align 8
  %1758 = load i64, ptr %arg4.addr, align 8
  %tobool2976 = icmp ne i64 %1758, 0
  br i1 %tobool2976, label %if.then2977, label %if.end2983

if.then2977:                                      ; preds = %sw.bb2972
  %1759 = load i64, ptr %arg4.addr, align 8
  %call2978 = call i64 @copy_from_user_mq_attr(ptr noundef %posix_mq_attr, i64 noundef %1759)
  %cmp2979 = icmp ne i64 %call2978, 0
  br i1 %cmp2979, label %if.then2981, label %if.end2982

if.then2981:                                      ; preds = %if.then2977
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2982:                                       ; preds = %if.then2977
  store ptr %posix_mq_attr, ptr %pposix_mq_attr, align 8
  br label %if.end2983

if.end2983:                                       ; preds = %if.end2982, %sw.bb2972
  %1760 = load i64, ptr %arg1.addr, align 8
  %sub2984 = sub i64 %1760, 1
  %call2985 = call ptr @lock_user_string(i64 noundef %sub2984)
  store ptr %call2985, ptr %p, align 8
  %1761 = load ptr, ptr %p, align 8
  %tobool2986 = icmp ne ptr %1761, null
  br i1 %tobool2986, label %if.end2988, label %if.then2987

if.then2987:                                      ; preds = %if.end2983
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2988:                                       ; preds = %if.end2983
  %1762 = load ptr, ptr %p, align 8
  %1763 = load i32, ptr %host_flags2973, align 4
  %1764 = load i64, ptr %arg3.addr, align 8
  %1765 = load ptr, ptr %pposix_mq_attr, align 8
  %call2989 = call i32 (ptr, i32, ...) @mq_open(ptr noundef %1762, i32 noundef %1763, i64 noundef %1764, ptr noundef %1765) #14
  %conv2990 = sext i32 %call2989 to i64
  %call2991 = call i64 @get_errno(i64 noundef %conv2990)
  store i64 %call2991, ptr %ret, align 8
  %1766 = load ptr, ptr %p, align 8
  %1767 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %1766, i64 noundef %1767, i64 noundef 0)
  %1768 = load i64, ptr %ret, align 8
  store i64 %1768, ptr %retval, align 8
  br label %return

sw.bb2992:                                        ; preds = %entry
  %1769 = load i64, ptr %arg1.addr, align 8
  %sub2993 = sub i64 %1769, 1
  %call2994 = call ptr @lock_user_string(i64 noundef %sub2993)
  store ptr %call2994, ptr %p, align 8
  %1770 = load ptr, ptr %p, align 8
  %tobool2995 = icmp ne ptr %1770, null
  br i1 %tobool2995, label %if.end2997, label %if.then2996

if.then2996:                                      ; preds = %sw.bb2992
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2997:                                       ; preds = %sw.bb2992
  %1771 = load ptr, ptr %p, align 8
  %call2998 = call i32 @mq_unlink(ptr noundef %1771) #14
  %conv2999 = sext i32 %call2998 to i64
  %call3000 = call i64 @get_errno(i64 noundef %conv2999)
  store i64 %call3000, ptr %ret, align 8
  %1772 = load ptr, ptr %p, align 8
  %1773 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %1772, i64 noundef %1773, i64 noundef 0)
  %1774 = load i64, ptr %ret, align 8
  store i64 %1774, ptr %retval, align 8
  br label %return

sw.bb3001:                                        ; preds = %entry
  %1775 = load i64, ptr %arg2.addr, align 8
  %1776 = load i64, ptr %arg3.addr, align 8
  %call3003 = call ptr @lock_user(i32 noundef 1, i64 noundef %1775, i64 noundef %1776, i1 noundef zeroext true)
  store ptr %call3003, ptr %p, align 8
  %1777 = load i64, ptr %arg5.addr, align 8
  %cmp3004 = icmp ne i64 %1777, 0
  br i1 %cmp3004, label %if.then3006, label %if.else3023

if.then3006:                                      ; preds = %sw.bb3001
  %1778 = load i64, ptr %arg5.addr, align 8
  %call3007 = call i64 @target_to_host_timespec(ptr noundef %ts3002, i64 noundef %1778)
  %tobool3008 = icmp ne i64 %call3007, 0
  br i1 %tobool3008, label %if.then3009, label %if.end3010

if.then3009:                                      ; preds = %if.then3006
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3010:                                       ; preds = %if.then3006
  %1779 = load i64, ptr %arg1.addr, align 8
  %conv3011 = trunc i64 %1779 to i32
  %1780 = load ptr, ptr %p, align 8
  %1781 = load i64, ptr %arg3.addr, align 8
  %1782 = load i64, ptr %arg4.addr, align 8
  %conv3012 = trunc i64 %1782 to i32
  %call3013 = call i32 @safe_mq_timedsend(i32 noundef %conv3011, ptr noundef %1780, i64 noundef %1781, i32 noundef %conv3012, ptr noundef %ts3002)
  %conv3014 = sext i32 %call3013 to i64
  %call3015 = call i64 @get_errno(i64 noundef %conv3014)
  store i64 %call3015, ptr %ret, align 8
  %1783 = load i64, ptr %ret, align 8
  %call3016 = call i32 @is_error(i64 noundef %1783)
  %tobool3017 = icmp ne i32 %call3016, 0
  br i1 %tobool3017, label %if.end3022, label %land.lhs.true3018

land.lhs.true3018:                                ; preds = %if.end3010
  %1784 = load i64, ptr %arg5.addr, align 8
  %call3019 = call i64 @host_to_target_timespec(i64 noundef %1784, ptr noundef %ts3002)
  %tobool3020 = icmp ne i64 %call3019, 0
  br i1 %tobool3020, label %if.then3021, label %if.end3022

if.then3021:                                      ; preds = %land.lhs.true3018
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3022:                                       ; preds = %land.lhs.true3018, %if.end3010
  br label %if.end3029

if.else3023:                                      ; preds = %sw.bb3001
  %1785 = load i64, ptr %arg1.addr, align 8
  %conv3024 = trunc i64 %1785 to i32
  %1786 = load ptr, ptr %p, align 8
  %1787 = load i64, ptr %arg3.addr, align 8
  %1788 = load i64, ptr %arg4.addr, align 8
  %conv3025 = trunc i64 %1788 to i32
  %call3026 = call i32 @safe_mq_timedsend(i32 noundef %conv3024, ptr noundef %1786, i64 noundef %1787, i32 noundef %conv3025, ptr noundef null)
  %conv3027 = sext i32 %call3026 to i64
  %call3028 = call i64 @get_errno(i64 noundef %conv3027)
  store i64 %call3028, ptr %ret, align 8
  br label %if.end3029

if.end3029:                                       ; preds = %if.else3023, %if.end3022
  %1789 = load ptr, ptr %p, align 8
  %1790 = load i64, ptr %arg2.addr, align 8
  %1791 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %1789, i64 noundef %1790, i64 noundef %1791)
  %1792 = load i64, ptr %ret, align 8
  store i64 %1792, ptr %retval, align 8
  br label %return

sw.bb3030:                                        ; preds = %entry
  %1793 = load i64, ptr %arg2.addr, align 8
  %1794 = load i64, ptr %arg3.addr, align 8
  %call3032 = call ptr @lock_user(i32 noundef 1, i64 noundef %1793, i64 noundef %1794, i1 noundef zeroext true)
  store ptr %call3032, ptr %p, align 8
  %1795 = load i64, ptr %arg5.addr, align 8
  %cmp3033 = icmp ne i64 %1795, 0
  br i1 %cmp3033, label %if.then3035, label %if.else3051

if.then3035:                                      ; preds = %sw.bb3030
  %1796 = load i64, ptr %arg5.addr, align 8
  %call3036 = call i64 @target_to_host_timespec(ptr noundef %ts3031, i64 noundef %1796)
  %tobool3037 = icmp ne i64 %call3036, 0
  br i1 %tobool3037, label %if.then3038, label %if.end3039

if.then3038:                                      ; preds = %if.then3035
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3039:                                       ; preds = %if.then3035
  %1797 = load i64, ptr %arg1.addr, align 8
  %conv3040 = trunc i64 %1797 to i32
  %1798 = load ptr, ptr %p, align 8
  %1799 = load i64, ptr %arg3.addr, align 8
  %call3041 = call i32 @safe_mq_timedreceive(i32 noundef %conv3040, ptr noundef %1798, i64 noundef %1799, ptr noundef %prio, ptr noundef %ts3031)
  %conv3042 = sext i32 %call3041 to i64
  %call3043 = call i64 @get_errno(i64 noundef %conv3042)
  store i64 %call3043, ptr %ret, align 8
  %1800 = load i64, ptr %ret, align 8
  %call3044 = call i32 @is_error(i64 noundef %1800)
  %tobool3045 = icmp ne i32 %call3044, 0
  br i1 %tobool3045, label %if.end3050, label %land.lhs.true3046

land.lhs.true3046:                                ; preds = %if.end3039
  %1801 = load i64, ptr %arg5.addr, align 8
  %call3047 = call i64 @host_to_target_timespec(i64 noundef %1801, ptr noundef %ts3031)
  %tobool3048 = icmp ne i64 %call3047, 0
  br i1 %tobool3048, label %if.then3049, label %if.end3050

if.then3049:                                      ; preds = %land.lhs.true3046
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3050:                                       ; preds = %land.lhs.true3046, %if.end3039
  br label %if.end3056

if.else3051:                                      ; preds = %sw.bb3030
  %1802 = load i64, ptr %arg1.addr, align 8
  %conv3052 = trunc i64 %1802 to i32
  %1803 = load ptr, ptr %p, align 8
  %1804 = load i64, ptr %arg3.addr, align 8
  %call3053 = call i32 @safe_mq_timedreceive(i32 noundef %conv3052, ptr noundef %1803, i64 noundef %1804, ptr noundef %prio, ptr noundef null)
  %conv3054 = sext i32 %call3053 to i64
  %call3055 = call i64 @get_errno(i64 noundef %conv3054)
  store i64 %call3055, ptr %ret, align 8
  br label %if.end3056

if.end3056:                                       ; preds = %if.else3051, %if.end3050
  %1805 = load ptr, ptr %p, align 8
  %1806 = load i64, ptr %arg2.addr, align 8
  %1807 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %1805, i64 noundef %1806, i64 noundef %1807)
  %1808 = load i64, ptr %arg4.addr, align 8
  %cmp3057 = icmp ne i64 %1808, 0
  br i1 %cmp3057, label %if.then3059, label %if.end3071

if.then3059:                                      ; preds = %if.end3056
  %1809 = load i64, ptr %arg4.addr, align 8
  store i64 %1809, ptr %__gaddr3060, align 8
  store i64 0, ptr %__ret3062, align 8
  %1810 = load i64, ptr %__gaddr3060, align 8
  %call3063 = call ptr @lock_user(i32 noundef 3, i64 noundef %1810, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call3063, ptr %__hptr3061, align 8
  %tobool3064 = icmp ne ptr %call3063, null
  br i1 %tobool3064, label %if.then3065, label %if.else3068

if.then3065:                                      ; preds = %if.then3059
  br label %do.body3066

do.body3066:                                      ; preds = %if.then3065
  %1811 = load ptr, ptr %__hptr3061, align 8
  %1812 = load i32, ptr %prio, align 4
  call void @stl_le_p(ptr noundef %1811, i32 noundef %1812)
  br label %do.end3067

do.end3067:                                       ; preds = %do.body3066
  %1813 = load ptr, ptr %__hptr3061, align 8
  %1814 = load i64, ptr %__gaddr3060, align 8
  call void @unlock_user(ptr noundef %1813, i64 noundef %1814, i64 noundef 4)
  br label %if.end3069

if.else3068:                                      ; preds = %if.then3059
  store i64 -14, ptr %__ret3062, align 8
  br label %if.end3069

if.end3069:                                       ; preds = %if.else3068, %do.end3067
  %1815 = load i64, ptr %__ret3062, align 8
  store i64 %1815, ptr %tmp3070, align 8
  br label %if.end3071

if.end3071:                                       ; preds = %if.end3069, %if.end3056
  %1816 = load i64, ptr %ret, align 8
  store i64 %1816, ptr %retval, align 8
  br label %return

sw.bb3072:                                        ; preds = %entry
  store i64 0, ptr %ret, align 8
  %1817 = load i64, ptr %arg2.addr, align 8
  %cmp3073 = icmp ne i64 %1817, 0
  br i1 %cmp3073, label %if.then3075, label %if.else3081

if.then3075:                                      ; preds = %sw.bb3072
  %1818 = load i64, ptr %arg2.addr, align 8
  %call3076 = call i64 @copy_from_user_mq_attr(ptr noundef %posix_mq_attr_in, i64 noundef %1818)
  %1819 = load i64, ptr %arg1.addr, align 8
  %conv3077 = trunc i64 %1819 to i32
  %call3078 = call i32 @mq_setattr(i32 noundef %conv3077, ptr noundef %posix_mq_attr_in, ptr noundef %posix_mq_attr_out) #14
  %conv3079 = sext i32 %call3078 to i64
  %call3080 = call i64 @get_errno(i64 noundef %conv3079)
  store i64 %call3080, ptr %ret, align 8
  br label %if.end3090

if.else3081:                                      ; preds = %sw.bb3072
  %1820 = load i64, ptr %arg3.addr, align 8
  %cmp3082 = icmp ne i64 %1820, 0
  br i1 %cmp3082, label %if.then3084, label %if.end3089

if.then3084:                                      ; preds = %if.else3081
  %1821 = load i64, ptr %arg1.addr, align 8
  %conv3085 = trunc i64 %1821 to i32
  %call3086 = call i32 @mq_getattr(i32 noundef %conv3085, ptr noundef %posix_mq_attr_out) #14
  %conv3087 = sext i32 %call3086 to i64
  %call3088 = call i64 @get_errno(i64 noundef %conv3087)
  store i64 %call3088, ptr %ret, align 8
  br label %if.end3089

if.end3089:                                       ; preds = %if.then3084, %if.else3081
  br label %if.end3090

if.end3090:                                       ; preds = %if.end3089, %if.then3075
  %1822 = load i64, ptr %ret, align 8
  %cmp3091 = icmp eq i64 %1822, 0
  br i1 %cmp3091, label %land.lhs.true3093, label %if.end3098

land.lhs.true3093:                                ; preds = %if.end3090
  %1823 = load i64, ptr %arg3.addr, align 8
  %cmp3094 = icmp ne i64 %1823, 0
  br i1 %cmp3094, label %if.then3096, label %if.end3098

if.then3096:                                      ; preds = %land.lhs.true3093
  %1824 = load i64, ptr %arg3.addr, align 8
  %call3097 = call i64 @copy_to_user_mq_attr(i64 noundef %1824, ptr noundef %posix_mq_attr_out)
  br label %if.end3098

if.end3098:                                       ; preds = %if.then3096, %land.lhs.true3093, %if.end3090
  %1825 = load i64, ptr %ret, align 8
  store i64 %1825, ptr %retval, align 8
  br label %return

sw.bb3099:                                        ; preds = %entry
  %1826 = load i64, ptr %arg1.addr, align 8
  %conv3100 = trunc i64 %1826 to i32
  %1827 = load i64, ptr %arg2.addr, align 8
  %conv3101 = trunc i64 %1827 to i32
  %1828 = load i64, ptr %arg3.addr, align 8
  %1829 = load i64, ptr %arg4.addr, align 8
  %conv3102 = trunc i64 %1829 to i32
  %call3103 = call i64 @tee(i32 noundef %conv3100, i32 noundef %conv3101, i64 noundef %1828, i32 noundef %conv3102)
  %call3104 = call i64 @get_errno(i64 noundef %call3103)
  store i64 %call3104, ptr %ret, align 8
  %1830 = load i64, ptr %ret, align 8
  store i64 %1830, ptr %retval, align 8
  br label %return

sw.bb3105:                                        ; preds = %entry
  store ptr null, ptr %ploff_in, align 8
  store ptr null, ptr %ploff_out, align 8
  %1831 = load i64, ptr %arg2.addr, align 8
  %tobool3106 = icmp ne i64 %1831, 0
  br i1 %tobool3106, label %if.then3107, label %if.end3123

if.then3107:                                      ; preds = %sw.bb3105
  %1832 = load i64, ptr %arg2.addr, align 8
  store i64 %1832, ptr %__gaddr3108, align 8
  store i64 0, ptr %__ret3110, align 8
  %1833 = load i64, ptr %__gaddr3108, align 8
  %call3111 = call ptr @lock_user(i32 noundef 1, i64 noundef %1833, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call3111, ptr %__hptr3109, align 8
  %tobool3112 = icmp ne ptr %call3111, null
  br i1 %tobool3112, label %if.then3113, label %if.else3117

if.then3113:                                      ; preds = %if.then3107
  br label %do.body3114

do.body3114:                                      ; preds = %if.then3113
  %1834 = load ptr, ptr %__hptr3109, align 8
  %call3115 = call i64 @ldq_le_p(ptr noundef %1834)
  store i64 %call3115, ptr %loff_in, align 8
  br label %do.end3116

do.end3116:                                       ; preds = %do.body3114
  %1835 = load ptr, ptr %__hptr3109, align 8
  %1836 = load i64, ptr %__gaddr3108, align 8
  call void @unlock_user(ptr noundef %1835, i64 noundef %1836, i64 noundef 0)
  br label %if.end3118

if.else3117:                                      ; preds = %if.then3107
  store i64 0, ptr %loff_in, align 8
  store i64 -14, ptr %__ret3110, align 8
  br label %if.end3118

if.end3118:                                       ; preds = %if.else3117, %do.end3116
  %1837 = load i64, ptr %__ret3110, align 8
  store i64 %1837, ptr %tmp3119, align 8
  %1838 = load i64, ptr %tmp3119, align 8
  %tobool3120 = icmp ne i64 %1838, 0
  br i1 %tobool3120, label %if.then3121, label %if.end3122

if.then3121:                                      ; preds = %if.end3118
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3122:                                       ; preds = %if.end3118
  store ptr %loff_in, ptr %ploff_in, align 8
  br label %if.end3123

if.end3123:                                       ; preds = %if.end3122, %sw.bb3105
  %1839 = load i64, ptr %arg4.addr, align 8
  %tobool3124 = icmp ne i64 %1839, 0
  br i1 %tobool3124, label %if.then3125, label %if.end3141

if.then3125:                                      ; preds = %if.end3123
  %1840 = load i64, ptr %arg4.addr, align 8
  store i64 %1840, ptr %__gaddr3126, align 8
  store i64 0, ptr %__ret3128, align 8
  %1841 = load i64, ptr %__gaddr3126, align 8
  %call3129 = call ptr @lock_user(i32 noundef 1, i64 noundef %1841, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call3129, ptr %__hptr3127, align 8
  %tobool3130 = icmp ne ptr %call3129, null
  br i1 %tobool3130, label %if.then3131, label %if.else3135

if.then3131:                                      ; preds = %if.then3125
  br label %do.body3132

do.body3132:                                      ; preds = %if.then3131
  %1842 = load ptr, ptr %__hptr3127, align 8
  %call3133 = call i64 @ldq_le_p(ptr noundef %1842)
  store i64 %call3133, ptr %loff_out, align 8
  br label %do.end3134

do.end3134:                                       ; preds = %do.body3132
  %1843 = load ptr, ptr %__hptr3127, align 8
  %1844 = load i64, ptr %__gaddr3126, align 8
  call void @unlock_user(ptr noundef %1843, i64 noundef %1844, i64 noundef 0)
  br label %if.end3136

if.else3135:                                      ; preds = %if.then3125
  store i64 0, ptr %loff_out, align 8
  store i64 -14, ptr %__ret3128, align 8
  br label %if.end3136

if.end3136:                                       ; preds = %if.else3135, %do.end3134
  %1845 = load i64, ptr %__ret3128, align 8
  store i64 %1845, ptr %tmp3137, align 8
  %1846 = load i64, ptr %tmp3137, align 8
  %tobool3138 = icmp ne i64 %1846, 0
  br i1 %tobool3138, label %if.then3139, label %if.end3140

if.then3139:                                      ; preds = %if.end3136
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3140:                                       ; preds = %if.end3136
  store ptr %loff_out, ptr %ploff_out, align 8
  br label %if.end3141

if.end3141:                                       ; preds = %if.end3140, %if.end3123
  %1847 = load i64, ptr %arg1.addr, align 8
  %conv3142 = trunc i64 %1847 to i32
  %1848 = load ptr, ptr %ploff_in, align 8
  %1849 = load i64, ptr %arg3.addr, align 8
  %conv3143 = trunc i64 %1849 to i32
  %1850 = load ptr, ptr %ploff_out, align 8
  %1851 = load i64, ptr %arg5.addr, align 8
  %1852 = load i64, ptr %arg6.addr, align 8
  %conv3144 = trunc i64 %1852 to i32
  %call3145 = call i64 @splice(i32 noundef %conv3142, ptr noundef %1848, i32 noundef %conv3143, ptr noundef %1850, i64 noundef %1851, i32 noundef %conv3144)
  %call3146 = call i64 @get_errno(i64 noundef %call3145)
  store i64 %call3146, ptr %ret, align 8
  %1853 = load i64, ptr %arg2.addr, align 8
  %tobool3147 = icmp ne i64 %1853, 0
  br i1 %tobool3147, label %if.then3148, label %if.end3163

if.then3148:                                      ; preds = %if.end3141
  %1854 = load i64, ptr %arg2.addr, align 8
  store i64 %1854, ptr %__gaddr3149, align 8
  store i64 0, ptr %__ret3151, align 8
  %1855 = load i64, ptr %__gaddr3149, align 8
  %call3152 = call ptr @lock_user(i32 noundef 3, i64 noundef %1855, i64 noundef 8, i1 noundef zeroext false)
  store ptr %call3152, ptr %__hptr3150, align 8
  %tobool3153 = icmp ne ptr %call3152, null
  br i1 %tobool3153, label %if.then3154, label %if.else3157

if.then3154:                                      ; preds = %if.then3148
  br label %do.body3155

do.body3155:                                      ; preds = %if.then3154
  %1856 = load ptr, ptr %__hptr3150, align 8
  %1857 = load i64, ptr %loff_in, align 8
  call void @stq_le_p(ptr noundef %1856, i64 noundef %1857)
  br label %do.end3156

do.end3156:                                       ; preds = %do.body3155
  %1858 = load ptr, ptr %__hptr3150, align 8
  %1859 = load i64, ptr %__gaddr3149, align 8
  call void @unlock_user(ptr noundef %1858, i64 noundef %1859, i64 noundef 8)
  br label %if.end3158

if.else3157:                                      ; preds = %if.then3148
  store i64 -14, ptr %__ret3151, align 8
  br label %if.end3158

if.end3158:                                       ; preds = %if.else3157, %do.end3156
  %1860 = load i64, ptr %__ret3151, align 8
  store i64 %1860, ptr %tmp3159, align 8
  %1861 = load i64, ptr %tmp3159, align 8
  %tobool3160 = icmp ne i64 %1861, 0
  br i1 %tobool3160, label %if.then3161, label %if.end3162

if.then3161:                                      ; preds = %if.end3158
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3162:                                       ; preds = %if.end3158
  br label %if.end3163

if.end3163:                                       ; preds = %if.end3162, %if.end3141
  %1862 = load i64, ptr %arg4.addr, align 8
  %tobool3164 = icmp ne i64 %1862, 0
  br i1 %tobool3164, label %if.then3165, label %if.end3180

if.then3165:                                      ; preds = %if.end3163
  %1863 = load i64, ptr %arg4.addr, align 8
  store i64 %1863, ptr %__gaddr3166, align 8
  store i64 0, ptr %__ret3168, align 8
  %1864 = load i64, ptr %__gaddr3166, align 8
  %call3169 = call ptr @lock_user(i32 noundef 3, i64 noundef %1864, i64 noundef 8, i1 noundef zeroext false)
  store ptr %call3169, ptr %__hptr3167, align 8
  %tobool3170 = icmp ne ptr %call3169, null
  br i1 %tobool3170, label %if.then3171, label %if.else3174

if.then3171:                                      ; preds = %if.then3165
  br label %do.body3172

do.body3172:                                      ; preds = %if.then3171
  %1865 = load ptr, ptr %__hptr3167, align 8
  %1866 = load i64, ptr %loff_out, align 8
  call void @stq_le_p(ptr noundef %1865, i64 noundef %1866)
  br label %do.end3173

do.end3173:                                       ; preds = %do.body3172
  %1867 = load ptr, ptr %__hptr3167, align 8
  %1868 = load i64, ptr %__gaddr3166, align 8
  call void @unlock_user(ptr noundef %1867, i64 noundef %1868, i64 noundef 8)
  br label %if.end3175

if.else3174:                                      ; preds = %if.then3165
  store i64 -14, ptr %__ret3168, align 8
  br label %if.end3175

if.end3175:                                       ; preds = %if.else3174, %do.end3173
  %1869 = load i64, ptr %__ret3168, align 8
  store i64 %1869, ptr %tmp3176, align 8
  %1870 = load i64, ptr %tmp3176, align 8
  %tobool3177 = icmp ne i64 %1870, 0
  br i1 %tobool3177, label %if.then3178, label %if.end3179

if.then3178:                                      ; preds = %if.end3175
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3179:                                       ; preds = %if.end3175
  br label %if.end3180

if.end3180:                                       ; preds = %if.end3179, %if.end3163
  %1871 = load i64, ptr %ret, align 8
  store i64 %1871, ptr %retval, align 8
  br label %return

sw.bb3181:                                        ; preds = %entry
  %1872 = load i64, ptr %arg2.addr, align 8
  %1873 = load i64, ptr %arg3.addr, align 8
  %call3183 = call ptr @lock_iovec(i32 noundef 1, i64 noundef %1872, i64 noundef %1873, i32 noundef 1)
  store ptr %call3183, ptr %vec3182, align 8
  %1874 = load ptr, ptr %vec3182, align 8
  %cmp3184 = icmp ne ptr %1874, null
  br i1 %cmp3184, label %if.then3186, label %if.else3191

if.then3186:                                      ; preds = %sw.bb3181
  %1875 = load i64, ptr %arg1.addr, align 8
  %conv3187 = trunc i64 %1875 to i32
  %1876 = load ptr, ptr %vec3182, align 8
  %1877 = load i64, ptr %arg3.addr, align 8
  %1878 = load i64, ptr %arg4.addr, align 8
  %conv3188 = trunc i64 %1878 to i32
  %call3189 = call i64 @vmsplice(i32 noundef %conv3187, ptr noundef %1876, i64 noundef %1877, i32 noundef %conv3188)
  %call3190 = call i64 @get_errno(i64 noundef %call3189)
  store i64 %call3190, ptr %ret, align 8
  %1879 = load ptr, ptr %vec3182, align 8
  %1880 = load i64, ptr %arg2.addr, align 8
  %1881 = load i64, ptr %arg3.addr, align 8
  call void @unlock_iovec(ptr noundef %1879, i64 noundef %1880, i64 noundef %1881, i32 noundef 0)
  br label %if.end3196

if.else3191:                                      ; preds = %sw.bb3181
  %call3192 = call ptr @__errno_location() #13
  %1882 = load i32, ptr %call3192, align 4
  %call3193 = call i32 @host_to_target_errno(i32 noundef %1882)
  %sub3194 = sub i32 0, %call3193
  %conv3195 = sext i32 %sub3194 to i64
  store i64 %conv3195, ptr %ret, align 8
  br label %if.end3196

if.end3196:                                       ; preds = %if.else3191, %if.then3186
  %1883 = load i64, ptr %ret, align 8
  store i64 %1883, ptr %retval, align 8
  br label %return

sw.bb3197:                                        ; preds = %entry
  %1884 = load i64, ptr %arg2.addr, align 8
  %and3199 = and i64 %1884, -526337
  %conv3200 = trunc i64 %and3199 to i32
  store i32 %conv3200, ptr %host_flags3198, align 4
  %1885 = load i64, ptr %arg2.addr, align 8
  %and3201 = and i64 %1885, 2048
  %tobool3202 = icmp ne i64 %and3201, 0
  br i1 %tobool3202, label %if.then3203, label %if.end3205

if.then3203:                                      ; preds = %sw.bb3197
  %1886 = load i32, ptr %host_flags3198, align 4
  %or3204 = or i32 %1886, 2048
  store i32 %or3204, ptr %host_flags3198, align 4
  br label %if.end3205

if.end3205:                                       ; preds = %if.then3203, %sw.bb3197
  %1887 = load i64, ptr %arg2.addr, align 8
  %and3206 = and i64 %1887, 524288
  %tobool3207 = icmp ne i64 %and3206, 0
  br i1 %tobool3207, label %if.then3208, label %if.end3210

if.then3208:                                      ; preds = %if.end3205
  %1888 = load i32, ptr %host_flags3198, align 4
  %or3209 = or i32 %1888, 524288
  store i32 %or3209, ptr %host_flags3198, align 4
  br label %if.end3210

if.end3210:                                       ; preds = %if.then3208, %if.end3205
  %1889 = load i64, ptr %arg1.addr, align 8
  %conv3211 = trunc i64 %1889 to i32
  %1890 = load i32, ptr %host_flags3198, align 4
  %call3212 = call i32 @eventfd(i32 noundef %conv3211, i32 noundef %1890) #14
  %conv3213 = sext i32 %call3212 to i64
  %call3214 = call i64 @get_errno(i64 noundef %conv3213)
  store i64 %call3214, ptr %ret, align 8
  %1891 = load i64, ptr %ret, align 8
  %cmp3215 = icmp sge i64 %1891, 0
  br i1 %cmp3215, label %if.then3217, label %if.end3219

if.then3217:                                      ; preds = %if.end3210
  %1892 = load i64, ptr %ret, align 8
  %conv3218 = trunc i64 %1892 to i32
  call void @fd_trans_register(i32 noundef %conv3218, ptr noundef @target_eventfd_trans)
  br label %if.end3219

if.end3219:                                       ; preds = %if.then3217, %if.end3210
  %1893 = load i64, ptr %ret, align 8
  store i64 %1893, ptr %retval, align 8
  br label %return

sw.bb3220:                                        ; preds = %entry
  %1894 = load i64, ptr %arg1.addr, align 8
  %conv3221 = trunc i64 %1894 to i32
  %1895 = load i64, ptr %arg2.addr, align 8
  %conv3222 = trunc i64 %1895 to i32
  %1896 = load i64, ptr %arg3.addr, align 8
  %1897 = load i64, ptr %arg4.addr, align 8
  %call3223 = call i32 @fallocate64(i32 noundef %conv3221, i32 noundef %conv3222, i64 noundef %1896, i64 noundef %1897)
  %conv3224 = sext i32 %call3223 to i64
  %call3225 = call i64 @get_errno(i64 noundef %conv3224)
  store i64 %call3225, ptr %ret, align 8
  %1898 = load i64, ptr %ret, align 8
  store i64 %1898, ptr %retval, align 8
  br label %return

sw.bb3226:                                        ; preds = %entry
  %1899 = load i64, ptr %arg1.addr, align 8
  %conv3227 = trunc i64 %1899 to i32
  %1900 = load i64, ptr %arg2.addr, align 8
  %1901 = load i64, ptr %arg3.addr, align 8
  %1902 = load i64, ptr %arg4.addr, align 8
  %conv3228 = trunc i64 %1902 to i32
  %call3229 = call i32 @sync_file_range(i32 noundef %conv3227, i64 noundef %1900, i64 noundef %1901, i32 noundef %conv3228)
  %conv3230 = sext i32 %call3229 to i64
  %call3231 = call i64 @get_errno(i64 noundef %conv3230)
  store i64 %call3231, ptr %ret, align 8
  %1903 = load i64, ptr %ret, align 8
  store i64 %1903, ptr %retval, align 8
  br label %return

sw.bb3232:                                        ; preds = %entry
  %1904 = load i64, ptr %arg1.addr, align 8
  %conv3233 = trunc i64 %1904 to i32
  %1905 = load i64, ptr %arg2.addr, align 8
  %1906 = load i64, ptr %arg4.addr, align 8
  %conv3234 = trunc i64 %1906 to i32
  %call3235 = call i64 @do_signalfd4(i32 noundef %conv3233, i64 noundef %1905, i32 noundef %conv3234)
  store i64 %call3235, ptr %retval, align 8
  br label %return

sw.bb3236:                                        ; preds = %entry
  %1907 = load i64, ptr %arg1.addr, align 8
  %conv3237 = trunc i64 %1907 to i32
  %call3238 = call i32 @target_to_host_bitmask_len(i32 noundef %conv3237, ptr noundef @fcntl_flags_tbl, i64 noundef 19)
  %call3239 = call i32 @epoll_create1(i32 noundef %call3238) #14
  %conv3240 = sext i32 %call3239 to i64
  %call3241 = call i64 @get_errno(i64 noundef %conv3240)
  store i64 %call3241, ptr %retval, align 8
  br label %return

sw.bb3242:                                        ; preds = %entry
  store ptr null, ptr %epp, align 8
  %1908 = load i64, ptr %arg4.addr, align 8
  %tobool3243 = icmp ne i64 %1908, 0
  br i1 %tobool3243, label %if.then3244, label %if.end3258

if.then3244:                                      ; preds = %sw.bb3242
  %1909 = load i64, ptr %arg2.addr, align 8
  %cmp3245 = icmp ne i64 %1909, 2
  br i1 %cmp3245, label %if.then3247, label %if.end3257

if.then3247:                                      ; preds = %if.then3244
  %1910 = load i64, ptr %arg4.addr, align 8
  %call3248 = call ptr @lock_user(i32 noundef 1, i64 noundef %1910, i64 noundef 16, i1 noundef zeroext true)
  store ptr %call3248, ptr %target_ep, align 8
  %tobool3249 = icmp ne ptr %call3248, null
  br i1 %tobool3249, label %if.end3251, label %if.then3250

if.then3250:                                      ; preds = %if.then3247
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3251:                                       ; preds = %if.then3247
  %1911 = load ptr, ptr %target_ep, align 8
  %events = getelementptr inbounds %struct.target_epoll_event, ptr %1911, i32 0, i32 0
  %1912 = load i32, ptr %events, align 8
  %call3252 = call i32 @tswap32(i32 noundef %1912)
  %events3253 = getelementptr inbounds %struct.epoll_event, ptr %ep, i32 0, i32 0
  store i32 %call3252, ptr %events3253, align 1
  %1913 = load ptr, ptr %target_ep, align 8
  %data3254 = getelementptr inbounds %struct.target_epoll_event, ptr %1913, i32 0, i32 1
  %1914 = load i64, ptr %data3254, align 8
  %call3255 = call i64 @tswap64(i64 noundef %1914)
  %data3256 = getelementptr inbounds %struct.epoll_event, ptr %ep, i32 0, i32 1
  store i64 %call3255, ptr %data3256, align 1
  %1915 = load ptr, ptr %target_ep, align 8
  %1916 = load i64, ptr %arg4.addr, align 8
  call void @unlock_user(ptr noundef %1915, i64 noundef %1916, i64 noundef 0)
  br label %if.end3257

if.end3257:                                       ; preds = %if.end3251, %if.then3244
  store ptr %ep, ptr %epp, align 8
  br label %if.end3258

if.end3258:                                       ; preds = %if.end3257, %sw.bb3242
  %1917 = load i64, ptr %arg1.addr, align 8
  %conv3259 = trunc i64 %1917 to i32
  %1918 = load i64, ptr %arg2.addr, align 8
  %conv3260 = trunc i64 %1918 to i32
  %1919 = load i64, ptr %arg3.addr, align 8
  %conv3261 = trunc i64 %1919 to i32
  %1920 = load ptr, ptr %epp, align 8
  %call3262 = call i32 @epoll_ctl(i32 noundef %conv3259, i32 noundef %conv3260, i32 noundef %conv3261, ptr noundef %1920) #14
  %conv3263 = sext i32 %call3262 to i64
  %call3264 = call i64 @get_errno(i64 noundef %conv3263)
  store i64 %call3264, ptr %retval, align 8
  br label %return

sw.bb3265:                                        ; preds = %entry
  %1921 = load i64, ptr %arg1.addr, align 8
  %conv3268 = trunc i64 %1921 to i32
  store i32 %conv3268, ptr %epfd, align 4
  %1922 = load i64, ptr %arg3.addr, align 8
  %conv3269 = trunc i64 %1922 to i32
  store i32 %conv3269, ptr %maxevents, align 4
  %1923 = load i64, ptr %arg4.addr, align 8
  %conv3270 = trunc i64 %1923 to i32
  store i32 %conv3270, ptr %timeout, align 4
  %1924 = load i32, ptr %maxevents, align 4
  %cmp3271 = icmp sle i32 %1924, 0
  br i1 %cmp3271, label %if.then3277, label %lor.lhs.false3273

lor.lhs.false3273:                                ; preds = %sw.bb3265
  %1925 = load i32, ptr %maxevents, align 4
  %conv3274 = sext i32 %1925 to i64
  %cmp3275 = icmp ugt i64 %conv3274, 134217727
  br i1 %cmp3275, label %if.then3277, label %if.end3278

if.then3277:                                      ; preds = %lor.lhs.false3273, %sw.bb3265
  store i64 -22, ptr %retval, align 8
  br label %return

if.end3278:                                       ; preds = %lor.lhs.false3273
  %1926 = load i64, ptr %arg2.addr, align 8
  %1927 = load i32, ptr %maxevents, align 4
  %conv3279 = sext i32 %1927 to i64
  %mul3280 = mul i64 %conv3279, 16
  %call3281 = call ptr @lock_user(i32 noundef 3, i64 noundef %1926, i64 noundef %mul3280, i1 noundef zeroext true)
  store ptr %call3281, ptr %target_ep3266, align 8
  %1928 = load ptr, ptr %target_ep3266, align 8
  %tobool3282 = icmp ne ptr %1928, null
  br i1 %tobool3282, label %if.end3284, label %if.then3283

if.then3283:                                      ; preds = %if.end3278
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3284:                                       ; preds = %if.end3278
  %1929 = load i32, ptr %maxevents, align 4
  %conv3285 = sext i32 %1929 to i64
  %call3286 = call noalias ptr @g_try_malloc_n(i64 noundef %conv3285, i64 noundef 12) #17
  store ptr %call3286, ptr %ep3267, align 8
  %1930 = load ptr, ptr %ep3267, align 8
  %tobool3287 = icmp ne ptr %1930, null
  br i1 %tobool3287, label %if.end3289, label %if.then3288

if.then3288:                                      ; preds = %if.end3284
  %1931 = load ptr, ptr %target_ep3266, align 8
  %1932 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1931, i64 noundef %1932, i64 noundef 0)
  store i64 -12, ptr %retval, align 8
  br label %return

if.end3289:                                       ; preds = %if.end3284
  %1933 = load i32, ptr %num.addr, align 4
  switch i32 %1933, label %sw.default3308 [
    i32 22, label %sw.bb3290
  ]

sw.bb3290:                                        ; preds = %if.end3289
  store ptr null, ptr %set3291, align 8
  %1934 = load i64, ptr %arg5.addr, align 8
  %tobool3292 = icmp ne i64 %1934, 0
  br i1 %tobool3292, label %if.then3293, label %if.end3300

if.then3293:                                      ; preds = %sw.bb3290
  %1935 = load i64, ptr %arg5.addr, align 8
  %1936 = load i64, ptr %arg6.addr, align 8
  %call3294 = call i32 @process_sigsuspend_mask(ptr noundef %set3291, i64 noundef %1935, i64 noundef %1936)
  %conv3295 = sext i32 %call3294 to i64
  store i64 %conv3295, ptr %ret, align 8
  %1937 = load i64, ptr %ret, align 8
  %cmp3296 = icmp ne i64 %1937, 0
  br i1 %cmp3296, label %if.then3298, label %if.end3299

if.then3298:                                      ; preds = %if.then3293
  br label %sw.epilog3309

if.end3299:                                       ; preds = %if.then3293
  br label %if.end3300

if.end3300:                                       ; preds = %if.end3299, %sw.bb3290
  %1938 = load i32, ptr %epfd, align 4
  %1939 = load ptr, ptr %ep3267, align 8
  %1940 = load i32, ptr %maxevents, align 4
  %1941 = load i32, ptr %timeout, align 4
  %1942 = load ptr, ptr %set3291, align 8
  %call3301 = call i32 @safe_epoll_pwait(i32 noundef %1938, ptr noundef %1939, i32 noundef %1940, i32 noundef %1941, ptr noundef %1942, i64 noundef 8)
  %conv3302 = sext i32 %call3301 to i64
  %call3303 = call i64 @get_errno(i64 noundef %conv3302)
  store i64 %call3303, ptr %ret, align 8
  %1943 = load ptr, ptr %set3291, align 8
  %tobool3304 = icmp ne ptr %1943, null
  br i1 %tobool3304, label %if.then3305, label %if.end3307

if.then3305:                                      ; preds = %if.end3300
  %1944 = load i64, ptr %ret, align 8
  %conv3306 = trunc i64 %1944 to i32
  call void @finish_sigsuspend_mask(i32 noundef %conv3306)
  br label %if.end3307

if.end3307:                                       ; preds = %if.then3305, %if.end3300
  br label %sw.epilog3309

sw.default3308:                                   ; preds = %if.end3289
  store i64 -38, ptr %ret, align 8
  br label %sw.epilog3309

sw.epilog3309:                                    ; preds = %sw.default3308, %if.end3307, %if.then3298
  %1945 = load i64, ptr %ret, align 8
  %call3310 = call i32 @is_error(i64 noundef %1945)
  %tobool3311 = icmp ne i32 %call3310, 0
  br i1 %tobool3311, label %if.else3337, label %if.then3312

if.then3312:                                      ; preds = %sw.epilog3309
  store i32 0, ptr %i3313, align 4
  br label %for.cond3314

for.cond3314:                                     ; preds = %for.inc3333, %if.then3312
  %1946 = load i32, ptr %i3313, align 4
  %conv3315 = sext i32 %1946 to i64
  %1947 = load i64, ptr %ret, align 8
  %cmp3316 = icmp slt i64 %conv3315, %1947
  br i1 %cmp3316, label %for.body3318, label %for.end3335

for.body3318:                                     ; preds = %for.cond3314
  %1948 = load ptr, ptr %ep3267, align 8
  %1949 = load i32, ptr %i3313, align 4
  %idxprom3319 = sext i32 %1949 to i64
  %arrayidx3320 = getelementptr %struct.epoll_event, ptr %1948, i64 %idxprom3319
  %events3321 = getelementptr inbounds %struct.epoll_event, ptr %arrayidx3320, i32 0, i32 0
  %1950 = load i32, ptr %events3321, align 1
  %call3322 = call i32 @tswap32(i32 noundef %1950)
  %1951 = load ptr, ptr %target_ep3266, align 8
  %1952 = load i32, ptr %i3313, align 4
  %idxprom3323 = sext i32 %1952 to i64
  %arrayidx3324 = getelementptr %struct.target_epoll_event, ptr %1951, i64 %idxprom3323
  %events3325 = getelementptr inbounds %struct.target_epoll_event, ptr %arrayidx3324, i32 0, i32 0
  store i32 %call3322, ptr %events3325, align 8
  %1953 = load ptr, ptr %ep3267, align 8
  %1954 = load i32, ptr %i3313, align 4
  %idxprom3326 = sext i32 %1954 to i64
  %arrayidx3327 = getelementptr %struct.epoll_event, ptr %1953, i64 %idxprom3326
  %data3328 = getelementptr inbounds %struct.epoll_event, ptr %arrayidx3327, i32 0, i32 1
  %1955 = load i64, ptr %data3328, align 1
  %call3329 = call i64 @tswap64(i64 noundef %1955)
  %1956 = load ptr, ptr %target_ep3266, align 8
  %1957 = load i32, ptr %i3313, align 4
  %idxprom3330 = sext i32 %1957 to i64
  %arrayidx3331 = getelementptr %struct.target_epoll_event, ptr %1956, i64 %idxprom3330
  %data3332 = getelementptr inbounds %struct.target_epoll_event, ptr %arrayidx3331, i32 0, i32 1
  store i64 %call3329, ptr %data3332, align 8
  br label %for.inc3333

for.inc3333:                                      ; preds = %for.body3318
  %1958 = load i32, ptr %i3313, align 4
  %inc3334 = add i32 %1958, 1
  store i32 %inc3334, ptr %i3313, align 4
  br label %for.cond3314, !llvm.loop !25

for.end3335:                                      ; preds = %for.cond3314
  %1959 = load ptr, ptr %target_ep3266, align 8
  %1960 = load i64, ptr %arg2.addr, align 8
  %1961 = load i64, ptr %ret, align 8
  %mul3336 = mul i64 %1961, 16
  call void @unlock_user(ptr noundef %1959, i64 noundef %1960, i64 noundef %mul3336)
  br label %if.end3338

if.else3337:                                      ; preds = %sw.epilog3309
  %1962 = load ptr, ptr %target_ep3266, align 8
  %1963 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %1962, i64 noundef %1963, i64 noundef 0)
  br label %if.end3338

if.end3338:                                       ; preds = %if.else3337, %for.end3335
  %1964 = load ptr, ptr %ep3267, align 8
  call void @g_free(ptr noundef %1964)
  %1965 = load i64, ptr %ret, align 8
  store i64 %1965, ptr %retval, align 8
  br label %return

sw.bb3339:                                        ; preds = %entry
  store ptr null, ptr %rnewp, align 8
  %1966 = load i64, ptr %arg2.addr, align 8
  %conv3341 = trunc i64 %1966 to i32
  %call3342 = call i32 @target_to_host_resource(i32 noundef %conv3341)
  store i32 %call3342, ptr %resource3340, align 4
  %1967 = load i64, ptr %arg3.addr, align 8
  %tobool3343 = icmp ne i64 %1967, 0
  br i1 %tobool3343, label %land.lhs.true3344, label %if.end3368

land.lhs.true3344:                                ; preds = %sw.bb3339
  %1968 = load i32, ptr %resource3340, align 4
  %cmp3345 = icmp ne i32 %1968, 9
  br i1 %cmp3345, label %land.lhs.true3347, label %if.end3368

land.lhs.true3347:                                ; preds = %land.lhs.true3344
  %1969 = load i32, ptr %resource3340, align 4
  %cmp3348 = icmp ne i32 %1969, 2
  br i1 %cmp3348, label %land.lhs.true3350, label %if.end3368

land.lhs.true3350:                                ; preds = %land.lhs.true3347
  %1970 = load i32, ptr %resource3340, align 4
  %cmp3351 = icmp ne i32 %1970, 3
  br i1 %cmp3351, label %if.then3353, label %if.end3368

if.then3353:                                      ; preds = %land.lhs.true3350
  %1971 = load i64, ptr %arg3.addr, align 8
  %call3354 = call ptr @lock_user(i32 noundef 1, i64 noundef %1971, i64 noundef 16, i1 noundef zeroext true)
  store ptr %call3354, ptr %target_rnew, align 8
  %tobool3355 = icmp ne ptr %call3354, null
  br i1 %tobool3355, label %if.end3357, label %if.then3356

if.then3356:                                      ; preds = %if.then3353
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3357:                                       ; preds = %if.then3353
  br label %do.body3358

do.body3358:                                      ; preds = %if.end3357
  %1972 = load ptr, ptr %target_rnew, align 8
  %rlim_cur3359 = getelementptr inbounds %struct.target_rlimit64, ptr %1972, i32 0, i32 0
  %call3360 = call i64 @ldq_le_p(ptr noundef %rlim_cur3359)
  %rlim_cur3361 = getelementptr inbounds %struct.host_rlimit64, ptr %rnew, i32 0, i32 0
  store i64 %call3360, ptr %rlim_cur3361, align 8
  br label %do.end3362

do.end3362:                                       ; preds = %do.body3358
  br label %do.body3363

do.body3363:                                      ; preds = %do.end3362
  %1973 = load ptr, ptr %target_rnew, align 8
  %rlim_max3364 = getelementptr inbounds %struct.target_rlimit64, ptr %1973, i32 0, i32 1
  %call3365 = call i64 @ldq_le_p(ptr noundef %rlim_max3364)
  %rlim_max3366 = getelementptr inbounds %struct.host_rlimit64, ptr %rnew, i32 0, i32 1
  store i64 %call3365, ptr %rlim_max3366, align 8
  br label %do.end3367

do.end3367:                                       ; preds = %do.body3363
  %1974 = load ptr, ptr %target_rnew, align 8
  %1975 = load i64, ptr %arg3.addr, align 8
  call void @unlock_user(ptr noundef %1974, i64 noundef %1975, i64 noundef 0)
  store ptr %rnew, ptr %rnewp, align 8
  br label %if.end3368

if.end3368:                                       ; preds = %do.end3367, %land.lhs.true3350, %land.lhs.true3347, %land.lhs.true3344, %sw.bb3339
  %1976 = load i64, ptr %arg1.addr, align 8
  %conv3369 = trunc i64 %1976 to i32
  %1977 = load i32, ptr %resource3340, align 4
  %1978 = load ptr, ptr %rnewp, align 8
  %1979 = load i64, ptr %arg4.addr, align 8
  %tobool3370 = icmp ne i64 %1979, 0
  br i1 %tobool3370, label %cond.true3371, label %cond.false3372

cond.true3371:                                    ; preds = %if.end3368
  br label %cond.end3373

cond.false3372:                                   ; preds = %if.end3368
  br label %cond.end3373

cond.end3373:                                     ; preds = %cond.false3372, %cond.true3371
  %cond3374 = phi ptr [ %rold, %cond.true3371 ], [ null, %cond.false3372 ]
  %call3375 = call i32 @sys_prlimit64(i32 noundef %conv3369, i32 noundef %1977, ptr noundef %1978, ptr noundef %cond3374)
  %conv3376 = sext i32 %call3375 to i64
  %call3377 = call i64 @get_errno(i64 noundef %conv3376)
  store i64 %call3377, ptr %ret, align 8
  %1980 = load i64, ptr %ret, align 8
  %call3378 = call i32 @is_error(i64 noundef %1980)
  %tobool3379 = icmp ne i32 %call3378, 0
  br i1 %tobool3379, label %if.end3395, label %land.lhs.true3380

land.lhs.true3380:                                ; preds = %cond.end3373
  %1981 = load i64, ptr %arg4.addr, align 8
  %tobool3381 = icmp ne i64 %1981, 0
  br i1 %tobool3381, label %if.then3382, label %if.end3395

if.then3382:                                      ; preds = %land.lhs.true3380
  %1982 = load i64, ptr %arg4.addr, align 8
  %call3383 = call ptr @lock_user(i32 noundef 3, i64 noundef %1982, i64 noundef 16, i1 noundef zeroext true)
  store ptr %call3383, ptr %target_rold, align 8
  %tobool3384 = icmp ne ptr %call3383, null
  br i1 %tobool3384, label %if.end3386, label %if.then3385

if.then3385:                                      ; preds = %if.then3382
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3386:                                       ; preds = %if.then3382
  br label %do.body3387

do.body3387:                                      ; preds = %if.end3386
  %1983 = load ptr, ptr %target_rold, align 8
  %rlim_cur3388 = getelementptr inbounds %struct.target_rlimit64, ptr %1983, i32 0, i32 0
  %rlim_cur3389 = getelementptr inbounds %struct.host_rlimit64, ptr %rold, i32 0, i32 0
  %1984 = load i64, ptr %rlim_cur3389, align 8
  call void @stq_le_p(ptr noundef %rlim_cur3388, i64 noundef %1984)
  br label %do.end3390

do.end3390:                                       ; preds = %do.body3387
  br label %do.body3391

do.body3391:                                      ; preds = %do.end3390
  %1985 = load ptr, ptr %target_rold, align 8
  %rlim_max3392 = getelementptr inbounds %struct.target_rlimit64, ptr %1985, i32 0, i32 1
  %rlim_max3393 = getelementptr inbounds %struct.host_rlimit64, ptr %rold, i32 0, i32 1
  %1986 = load i64, ptr %rlim_max3393, align 8
  call void @stq_le_p(ptr noundef %rlim_max3392, i64 noundef %1986)
  br label %do.end3394

do.end3394:                                       ; preds = %do.body3391
  %1987 = load ptr, ptr %target_rold, align 8
  %1988 = load i64, ptr %arg4.addr, align 8
  call void @unlock_user(ptr noundef %1987, i64 noundef %1988, i64 noundef 16)
  br label %if.end3395

if.end3395:                                       ; preds = %do.end3394, %land.lhs.true3380, %cond.end3373
  %1989 = load i64, ptr %ret, align 8
  store i64 %1989, ptr %retval, align 8
  br label %return

sw.bb3396:                                        ; preds = %entry
  call void @llvm.memset.p0.i64(ptr align 8 %host_sevp, i8 0, i64 64, i1 false)
  store ptr null, ptr %phost_sevp, align 8
  %1990 = load i64, ptr %arg1.addr, align 8
  %conv3397 = trunc i64 %1990 to i32
  store i32 %conv3397, ptr %clkid, align 4
  %call3398 = call i32 @next_free_host_timer()
  store i32 %call3398, ptr %timer_index, align 4
  %1991 = load i32, ptr %timer_index, align 4
  %cmp3399 = icmp slt i32 %1991, 0
  br i1 %cmp3399, label %if.then3401, label %if.else3402

if.then3401:                                      ; preds = %sw.bb3396
  store i64 -11, ptr %ret, align 8
  br label %if.end3435

if.else3402:                                      ; preds = %sw.bb3396
  %1992 = load i32, ptr %timer_index, align 4
  %idx.ext = sext i32 %1992 to i64
  %add.ptr3403 = getelementptr ptr, ptr @g_posix_timers, i64 %idx.ext
  store ptr %add.ptr3403, ptr %phtimer, align 8
  %1993 = load i64, ptr %arg2.addr, align 8
  %tobool3404 = icmp ne i64 %1993, 0
  br i1 %tobool3404, label %if.then3405, label %if.end3411

if.then3405:                                      ; preds = %if.else3402
  store ptr %host_sevp, ptr %phost_sevp, align 8
  %1994 = load ptr, ptr %phost_sevp, align 8
  %1995 = load i64, ptr %arg2.addr, align 8
  %call3406 = call i64 @target_to_host_sigevent(ptr noundef %1994, i64 noundef %1995)
  store i64 %call3406, ptr %ret, align 8
  %1996 = load i64, ptr %ret, align 8
  %cmp3407 = icmp ne i64 %1996, 0
  br i1 %cmp3407, label %if.then3409, label %if.end3410

if.then3409:                                      ; preds = %if.then3405
  %1997 = load i32, ptr %timer_index, align 4
  call void @free_host_timer_slot(i32 noundef %1997)
  %1998 = load i64, ptr %ret, align 8
  store i64 %1998, ptr %retval, align 8
  br label %return

if.end3410:                                       ; preds = %if.then3405
  br label %if.end3411

if.end3411:                                       ; preds = %if.end3410, %if.else3402
  %1999 = load i32, ptr %clkid, align 4
  %2000 = load ptr, ptr %phost_sevp, align 8
  %2001 = load ptr, ptr %phtimer, align 8
  %call3412 = call i32 @timer_create(i32 noundef %1999, ptr noundef %2000, ptr noundef %2001) #14
  %conv3413 = sext i32 %call3412 to i64
  %call3414 = call i64 @get_errno(i64 noundef %conv3413)
  store i64 %call3414, ptr %ret, align 8
  %2002 = load i64, ptr %ret, align 8
  %tobool3415 = icmp ne i64 %2002, 0
  br i1 %tobool3415, label %if.then3416, label %if.else3417

if.then3416:                                      ; preds = %if.end3411
  %2003 = load i32, ptr %timer_index, align 4
  call void @free_host_timer_slot(i32 noundef %2003)
  br label %if.end3434

if.else3417:                                      ; preds = %if.end3411
  %2004 = load i64, ptr %arg3.addr, align 8
  store i64 %2004, ptr %__gaddr3418, align 8
  store i64 0, ptr %__ret3420, align 8
  %2005 = load i64, ptr %__gaddr3418, align 8
  %call3421 = call ptr @lock_user(i32 noundef 3, i64 noundef %2005, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call3421, ptr %__hptr3419, align 8
  %tobool3422 = icmp ne ptr %call3421, null
  br i1 %tobool3422, label %if.then3423, label %if.else3427

if.then3423:                                      ; preds = %if.else3417
  br label %do.body3424

do.body3424:                                      ; preds = %if.then3423
  %2006 = load ptr, ptr %__hptr3419, align 8
  %2007 = load i32, ptr %timer_index, align 4
  %or3425 = or i32 212795392, %2007
  call void @stl_le_p(ptr noundef %2006, i32 noundef %or3425)
  br label %do.end3426

do.end3426:                                       ; preds = %do.body3424
  %2008 = load ptr, ptr %__hptr3419, align 8
  %2009 = load i64, ptr %__gaddr3418, align 8
  call void @unlock_user(ptr noundef %2008, i64 noundef %2009, i64 noundef 4)
  br label %if.end3428

if.else3427:                                      ; preds = %if.else3417
  store i64 -14, ptr %__ret3420, align 8
  br label %if.end3428

if.end3428:                                       ; preds = %if.else3427, %do.end3426
  %2010 = load i64, ptr %__ret3420, align 8
  store i64 %2010, ptr %tmp3429, align 8
  %2011 = load i64, ptr %tmp3429, align 8
  %tobool3430 = icmp ne i64 %2011, 0
  br i1 %tobool3430, label %if.then3431, label %if.end3433

if.then3431:                                      ; preds = %if.end3428
  %2012 = load ptr, ptr %phtimer, align 8
  %2013 = load ptr, ptr %2012, align 8
  %call3432 = call i32 @timer_delete(ptr noundef %2013) #14
  %2014 = load i32, ptr %timer_index, align 4
  call void @free_host_timer_slot(i32 noundef %2014)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3433:                                       ; preds = %if.end3428
  br label %if.end3434

if.end3434:                                       ; preds = %if.end3433, %if.then3416
  br label %if.end3435

if.end3435:                                       ; preds = %if.end3434, %if.then3401
  %2015 = load i64, ptr %ret, align 8
  store i64 %2015, ptr %retval, align 8
  br label %return

sw.bb3436:                                        ; preds = %entry
  %2016 = load i64, ptr %arg1.addr, align 8
  %call3437 = call i32 @get_timer_id(i64 noundef %2016)
  store i32 %call3437, ptr %timerid, align 4
  %2017 = load i32, ptr %timerid, align 4
  %cmp3438 = icmp slt i32 %2017, 0
  br i1 %cmp3438, label %if.then3440, label %if.else3442

if.then3440:                                      ; preds = %sw.bb3436
  %2018 = load i32, ptr %timerid, align 4
  %conv3441 = sext i32 %2018 to i64
  store i64 %conv3441, ptr %ret, align 8
  br label %if.end3464

if.else3442:                                      ; preds = %sw.bb3436
  %2019 = load i64, ptr %arg3.addr, align 8
  %cmp3443 = icmp eq i64 %2019, 0
  br i1 %cmp3443, label %if.then3445, label %if.else3446

if.then3445:                                      ; preds = %if.else3442
  store i64 -22, ptr %ret, align 8
  br label %if.end3463

if.else3446:                                      ; preds = %if.else3442
  %2020 = load i32, ptr %timerid, align 4
  %idxprom3447 = sext i32 %2020 to i64
  %arrayidx3448 = getelementptr [32 x ptr], ptr @g_posix_timers, i64 0, i64 %idxprom3447
  %2021 = load ptr, ptr %arrayidx3448, align 8
  store ptr %2021, ptr %htimer, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %hspec_new, i8 0, i64 32, i1 false)
  call void @llvm.memset.p0.i64(ptr align 8 %hspec_old, i8 0, i64 32, i1 false)
  %2022 = load i64, ptr %arg3.addr, align 8
  %call3449 = call i64 @target_to_host_itimerspec(ptr noundef %hspec_new, i64 noundef %2022)
  %tobool3450 = icmp ne i64 %call3449, 0
  br i1 %tobool3450, label %if.then3451, label %if.end3452

if.then3451:                                      ; preds = %if.else3446
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3452:                                       ; preds = %if.else3446
  %2023 = load ptr, ptr %htimer, align 8
  %2024 = load i64, ptr %arg2.addr, align 8
  %conv3453 = trunc i64 %2024 to i32
  %call3454 = call i32 @timer_settime(ptr noundef %2023, i32 noundef %conv3453, ptr noundef %hspec_new, ptr noundef %hspec_old) #14
  %conv3455 = sext i32 %call3454 to i64
  %call3456 = call i64 @get_errno(i64 noundef %conv3455)
  store i64 %call3456, ptr %ret, align 8
  %2025 = load i64, ptr %arg4.addr, align 8
  %tobool3457 = icmp ne i64 %2025, 0
  br i1 %tobool3457, label %land.lhs.true3458, label %if.end3462

land.lhs.true3458:                                ; preds = %if.end3452
  %2026 = load i64, ptr %arg4.addr, align 8
  %call3459 = call i64 @host_to_target_itimerspec(i64 noundef %2026, ptr noundef %hspec_old)
  %tobool3460 = icmp ne i64 %call3459, 0
  br i1 %tobool3460, label %if.then3461, label %if.end3462

if.then3461:                                      ; preds = %land.lhs.true3458
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3462:                                       ; preds = %land.lhs.true3458, %if.end3452
  br label %if.end3463

if.end3463:                                       ; preds = %if.end3462, %if.then3445
  br label %if.end3464

if.end3464:                                       ; preds = %if.end3463, %if.then3440
  %2027 = load i64, ptr %ret, align 8
  store i64 %2027, ptr %retval, align 8
  br label %return

sw.bb3465:                                        ; preds = %entry
  %2028 = load i64, ptr %arg1.addr, align 8
  %call3467 = call i32 @get_timer_id(i64 noundef %2028)
  store i32 %call3467, ptr %timerid3466, align 4
  %2029 = load i32, ptr %timerid3466, align 4
  %cmp3468 = icmp slt i32 %2029, 0
  br i1 %cmp3468, label %if.then3470, label %if.else3472

if.then3470:                                      ; preds = %sw.bb3465
  %2030 = load i32, ptr %timerid3466, align 4
  %conv3471 = sext i32 %2030 to i64
  store i64 %conv3471, ptr %ret, align 8
  br label %if.end3487

if.else3472:                                      ; preds = %sw.bb3465
  %2031 = load i64, ptr %arg2.addr, align 8
  %tobool3473 = icmp ne i64 %2031, 0
  br i1 %tobool3473, label %if.else3475, label %if.then3474

if.then3474:                                      ; preds = %if.else3472
  store i64 -14, ptr %ret, align 8
  br label %if.end3486

if.else3475:                                      ; preds = %if.else3472
  %2032 = load i32, ptr %timerid3466, align 4
  %idxprom3477 = sext i32 %2032 to i64
  %arrayidx3478 = getelementptr [32 x ptr], ptr @g_posix_timers, i64 0, i64 %idxprom3477
  %2033 = load ptr, ptr %arrayidx3478, align 8
  store ptr %2033, ptr %htimer3476, align 8
  %2034 = load ptr, ptr %htimer3476, align 8
  %call3479 = call i32 @timer_gettime(ptr noundef %2034, ptr noundef %hspec) #14
  %conv3480 = sext i32 %call3479 to i64
  %call3481 = call i64 @get_errno(i64 noundef %conv3480)
  store i64 %call3481, ptr %ret, align 8
  %2035 = load i64, ptr %arg2.addr, align 8
  %call3482 = call i64 @host_to_target_itimerspec(i64 noundef %2035, ptr noundef %hspec)
  %tobool3483 = icmp ne i64 %call3482, 0
  br i1 %tobool3483, label %if.then3484, label %if.end3485

if.then3484:                                      ; preds = %if.else3475
  store i64 -14, ptr %ret, align 8
  br label %if.end3485

if.end3485:                                       ; preds = %if.then3484, %if.else3475
  br label %if.end3486

if.end3486:                                       ; preds = %if.end3485, %if.then3474
  br label %if.end3487

if.end3487:                                       ; preds = %if.end3486, %if.then3470
  %2036 = load i64, ptr %ret, align 8
  store i64 %2036, ptr %retval, align 8
  br label %return

sw.bb3488:                                        ; preds = %entry
  %2037 = load i64, ptr %arg1.addr, align 8
  %call3490 = call i32 @get_timer_id(i64 noundef %2037)
  store i32 %call3490, ptr %timerid3489, align 4
  %2038 = load i32, ptr %timerid3489, align 4
  %cmp3491 = icmp slt i32 %2038, 0
  br i1 %cmp3491, label %if.then3493, label %if.else3495

if.then3493:                                      ; preds = %sw.bb3488
  %2039 = load i32, ptr %timerid3489, align 4
  %conv3494 = sext i32 %2039 to i64
  store i64 %conv3494, ptr %ret, align 8
  br label %if.end3502

if.else3495:                                      ; preds = %sw.bb3488
  %2040 = load i32, ptr %timerid3489, align 4
  %idxprom3497 = sext i32 %2040 to i64
  %arrayidx3498 = getelementptr [32 x ptr], ptr @g_posix_timers, i64 0, i64 %idxprom3497
  %2041 = load ptr, ptr %arrayidx3498, align 8
  store ptr %2041, ptr %htimer3496, align 8
  %2042 = load ptr, ptr %htimer3496, align 8
  %call3499 = call i32 @timer_getoverrun(ptr noundef %2042) #14
  %conv3500 = sext i32 %call3499 to i64
  %call3501 = call i64 @get_errno(i64 noundef %conv3500)
  store i64 %call3501, ptr %ret, align 8
  br label %if.end3502

if.end3502:                                       ; preds = %if.else3495, %if.then3493
  %2043 = load i64, ptr %ret, align 8
  store i64 %2043, ptr %retval, align 8
  br label %return

sw.bb3503:                                        ; preds = %entry
  %2044 = load i64, ptr %arg1.addr, align 8
  %call3505 = call i32 @get_timer_id(i64 noundef %2044)
  store i32 %call3505, ptr %timerid3504, align 4
  %2045 = load i32, ptr %timerid3504, align 4
  %cmp3506 = icmp slt i32 %2045, 0
  br i1 %cmp3506, label %if.then3508, label %if.else3510

if.then3508:                                      ; preds = %sw.bb3503
  %2046 = load i32, ptr %timerid3504, align 4
  %conv3509 = sext i32 %2046 to i64
  store i64 %conv3509, ptr %ret, align 8
  br label %if.end3517

if.else3510:                                      ; preds = %sw.bb3503
  %2047 = load i32, ptr %timerid3504, align 4
  %idxprom3512 = sext i32 %2047 to i64
  %arrayidx3513 = getelementptr [32 x ptr], ptr @g_posix_timers, i64 0, i64 %idxprom3512
  %2048 = load ptr, ptr %arrayidx3513, align 8
  store ptr %2048, ptr %htimer3511, align 8
  %2049 = load ptr, ptr %htimer3511, align 8
  %call3514 = call i32 @timer_delete(ptr noundef %2049) #14
  %conv3515 = sext i32 %call3514 to i64
  %call3516 = call i64 @get_errno(i64 noundef %conv3515)
  store i64 %call3516, ptr %ret, align 8
  %2050 = load i32, ptr %timerid3504, align 4
  call void @free_host_timer_slot(i32 noundef %2050)
  br label %if.end3517

if.end3517:                                       ; preds = %if.else3510, %if.then3508
  %2051 = load i64, ptr %ret, align 8
  store i64 %2051, ptr %retval, align 8
  br label %return

sw.bb3518:                                        ; preds = %entry
  %2052 = load i64, ptr %arg1.addr, align 8
  %conv3519 = trunc i64 %2052 to i32
  %2053 = load i64, ptr %arg2.addr, align 8
  %conv3520 = trunc i64 %2053 to i32
  %call3521 = call i32 @target_to_host_bitmask_len(i32 noundef %conv3520, ptr noundef @fcntl_flags_tbl, i64 noundef 19)
  %call3522 = call i32 @timerfd_create(i32 noundef %conv3519, i32 noundef %call3521) #14
  %conv3523 = sext i32 %call3522 to i64
  %call3524 = call i64 @get_errno(i64 noundef %conv3523)
  store i64 %call3524, ptr %ret, align 8
  %2054 = load i64, ptr %ret, align 8
  %cmp3525 = icmp sge i64 %2054, 0
  br i1 %cmp3525, label %if.then3527, label %if.end3529

if.then3527:                                      ; preds = %sw.bb3518
  %2055 = load i64, ptr %ret, align 8
  %conv3528 = trunc i64 %2055 to i32
  call void @fd_trans_register(i32 noundef %conv3528, ptr noundef @target_timerfd_trans)
  br label %if.end3529

if.end3529:                                       ; preds = %if.then3527, %sw.bb3518
  %2056 = load i64, ptr %ret, align 8
  store i64 %2056, ptr %retval, align 8
  br label %return

sw.bb3530:                                        ; preds = %entry
  %2057 = load i64, ptr %arg1.addr, align 8
  %conv3531 = trunc i64 %2057 to i32
  %call3532 = call i32 @timerfd_gettime(i32 noundef %conv3531, ptr noundef %its_curr) #14
  %conv3533 = sext i32 %call3532 to i64
  %call3534 = call i64 @get_errno(i64 noundef %conv3533)
  store i64 %call3534, ptr %ret, align 8
  %2058 = load i64, ptr %arg2.addr, align 8
  %tobool3535 = icmp ne i64 %2058, 0
  br i1 %tobool3535, label %land.lhs.true3536, label %if.end3540

land.lhs.true3536:                                ; preds = %sw.bb3530
  %2059 = load i64, ptr %arg2.addr, align 8
  %call3537 = call i64 @host_to_target_itimerspec(i64 noundef %2059, ptr noundef %its_curr)
  %tobool3538 = icmp ne i64 %call3537, 0
  br i1 %tobool3538, label %if.then3539, label %if.end3540

if.then3539:                                      ; preds = %land.lhs.true3536
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3540:                                       ; preds = %land.lhs.true3536, %sw.bb3530
  %2060 = load i64, ptr %ret, align 8
  store i64 %2060, ptr %retval, align 8
  br label %return

sw.bb3541:                                        ; preds = %entry
  %2061 = load i64, ptr %arg3.addr, align 8
  %tobool3542 = icmp ne i64 %2061, 0
  br i1 %tobool3542, label %if.then3543, label %if.else3548

if.then3543:                                      ; preds = %sw.bb3541
  %2062 = load i64, ptr %arg3.addr, align 8
  %call3544 = call i64 @target_to_host_itimerspec(ptr noundef %its_new, i64 noundef %2062)
  %tobool3545 = icmp ne i64 %call3544, 0
  br i1 %tobool3545, label %if.then3546, label %if.end3547

if.then3546:                                      ; preds = %if.then3543
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3547:                                       ; preds = %if.then3543
  store ptr %its_new, ptr %p_new, align 8
  br label %if.end3549

if.else3548:                                      ; preds = %sw.bb3541
  store ptr null, ptr %p_new, align 8
  br label %if.end3549

if.end3549:                                       ; preds = %if.else3548, %if.end3547
  %2063 = load i64, ptr %arg1.addr, align 8
  %conv3550 = trunc i64 %2063 to i32
  %2064 = load i64, ptr %arg2.addr, align 8
  %conv3551 = trunc i64 %2064 to i32
  %2065 = load ptr, ptr %p_new, align 8
  %call3552 = call i32 @timerfd_settime(i32 noundef %conv3550, i32 noundef %conv3551, ptr noundef %2065, ptr noundef %its_old) #14
  %conv3553 = sext i32 %call3552 to i64
  %call3554 = call i64 @get_errno(i64 noundef %conv3553)
  store i64 %call3554, ptr %ret, align 8
  %2066 = load i64, ptr %arg4.addr, align 8
  %tobool3555 = icmp ne i64 %2066, 0
  br i1 %tobool3555, label %land.lhs.true3556, label %if.end3560

land.lhs.true3556:                                ; preds = %if.end3549
  %2067 = load i64, ptr %arg4.addr, align 8
  %call3557 = call i64 @host_to_target_itimerspec(i64 noundef %2067, ptr noundef %its_old)
  %tobool3558 = icmp ne i64 %call3557, 0
  br i1 %tobool3558, label %if.then3559, label %if.end3560

if.then3559:                                      ; preds = %land.lhs.true3556
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3560:                                       ; preds = %land.lhs.true3556, %if.end3549
  %2068 = load i64, ptr %ret, align 8
  store i64 %2068, ptr %retval, align 8
  br label %return

sw.bb3561:                                        ; preds = %entry
  %2069 = load i64, ptr %arg1.addr, align 8
  %conv3562 = trunc i64 %2069 to i32
  %2070 = load i64, ptr %arg2.addr, align 8
  %conv3563 = trunc i64 %2070 to i32
  %call3564 = call i32 @ioprio_get(i32 noundef %conv3562, i32 noundef %conv3563)
  %conv3565 = sext i32 %call3564 to i64
  %call3566 = call i64 @get_errno(i64 noundef %conv3565)
  store i64 %call3566, ptr %retval, align 8
  br label %return

sw.bb3567:                                        ; preds = %entry
  %2071 = load i64, ptr %arg1.addr, align 8
  %conv3568 = trunc i64 %2071 to i32
  %2072 = load i64, ptr %arg2.addr, align 8
  %conv3569 = trunc i64 %2072 to i32
  %2073 = load i64, ptr %arg3.addr, align 8
  %conv3570 = trunc i64 %2073 to i32
  %call3571 = call i32 @ioprio_set(i32 noundef %conv3568, i32 noundef %conv3569, i32 noundef %conv3570)
  %conv3572 = sext i32 %call3571 to i64
  %call3573 = call i64 @get_errno(i64 noundef %conv3572)
  store i64 %call3573, ptr %retval, align 8
  br label %return

sw.bb3574:                                        ; preds = %entry
  %2074 = load i64, ptr %arg1.addr, align 8
  %conv3575 = trunc i64 %2074 to i32
  %2075 = load i64, ptr %arg2.addr, align 8
  %conv3576 = trunc i64 %2075 to i32
  %call3577 = call i32 @setns(i32 noundef %conv3575, i32 noundef %conv3576) #14
  %conv3578 = sext i32 %call3577 to i64
  %call3579 = call i64 @get_errno(i64 noundef %conv3578)
  store i64 %call3579, ptr %retval, align 8
  br label %return

sw.bb3580:                                        ; preds = %entry
  %2076 = load i64, ptr %arg1.addr, align 8
  %conv3581 = trunc i64 %2076 to i32
  %call3582 = call i32 @unshare(i32 noundef %conv3581) #14
  %conv3583 = sext i32 %call3582 to i64
  %call3584 = call i64 @get_errno(i64 noundef %conv3583)
  store i64 %call3584, ptr %retval, align 8
  br label %return

sw.bb3585:                                        ; preds = %entry
  %2077 = load i64, ptr %arg1.addr, align 8
  %conv3586 = trunc i64 %2077 to i32
  %2078 = load i64, ptr %arg2.addr, align 8
  %conv3587 = trunc i64 %2078 to i32
  %2079 = load i64, ptr %arg3.addr, align 8
  %conv3588 = trunc i64 %2079 to i32
  %2080 = load i64, ptr %arg4.addr, align 8
  %2081 = load i64, ptr %arg5.addr, align 8
  %call3589 = call i32 @kcmp(i32 noundef %conv3586, i32 noundef %conv3587, i32 noundef %conv3588, i64 noundef %2080, i64 noundef %2081)
  %conv3590 = sext i32 %call3589 to i64
  %call3591 = call i64 @get_errno(i64 noundef %conv3590)
  store i64 %call3591, ptr %retval, align 8
  br label %return

sw.bb3592:                                        ; preds = %entry
  %2082 = load i64, ptr %arg1.addr, align 8
  %call3593 = call ptr @lock_user_string(i64 noundef %2082)
  store ptr %call3593, ptr %p, align 8
  %2083 = load ptr, ptr %p, align 8
  %tobool3594 = icmp ne ptr %2083, null
  br i1 %tobool3594, label %if.end3596, label %if.then3595

if.then3595:                                      ; preds = %sw.bb3592
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3596:                                       ; preds = %sw.bb3592
  %2084 = load ptr, ptr %p, align 8
  %2085 = load i64, ptr %arg2.addr, align 8
  %conv3597 = trunc i64 %2085 to i32
  %call3598 = call i32 @memfd_create(ptr noundef %2084, i32 noundef %conv3597) #14
  %conv3599 = sext i32 %call3598 to i64
  %call3600 = call i64 @get_errno(i64 noundef %conv3599)
  store i64 %call3600, ptr %ret, align 8
  %2086 = load i64, ptr %ret, align 8
  %conv3601 = trunc i64 %2086 to i32
  call void @fd_trans_unregister(i32 noundef %conv3601)
  %2087 = load ptr, ptr %p, align 8
  %2088 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %2087, i64 noundef %2088, i64 noundef 0)
  %2089 = load i64, ptr %ret, align 8
  store i64 %2089, ptr %retval, align 8
  br label %return

sw.bb3602:                                        ; preds = %entry
  %2090 = load i64, ptr %arg1.addr, align 8
  %conv3603 = trunc i64 %2090 to i32
  %2091 = load i64, ptr %arg2.addr, align 8
  %conv3604 = trunc i64 %2091 to i32
  %call3605 = call i32 @membarrier(i32 noundef %conv3603, i32 noundef %conv3604)
  %conv3606 = sext i32 %call3605 to i64
  %call3607 = call i64 @get_errno(i64 noundef %conv3606)
  store i64 %call3607, ptr %retval, align 8
  br label %return

sw.bb3608:                                        ; preds = %entry
  store ptr null, ptr %pinoff, align 8
  store ptr null, ptr %poutoff, align 8
  %2092 = load i64, ptr %arg2.addr, align 8
  %tobool3609 = icmp ne i64 %2092, 0
  br i1 %tobool3609, label %if.then3610, label %if.end3626

if.then3610:                                      ; preds = %sw.bb3608
  %2093 = load i64, ptr %arg2.addr, align 8
  store i64 %2093, ptr %__gaddr3611, align 8
  store i64 0, ptr %__ret3613, align 8
  %2094 = load i64, ptr %__gaddr3611, align 8
  %call3614 = call ptr @lock_user(i32 noundef 1, i64 noundef %2094, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call3614, ptr %__hptr3612, align 8
  %tobool3615 = icmp ne ptr %call3614, null
  br i1 %tobool3615, label %if.then3616, label %if.else3620

if.then3616:                                      ; preds = %if.then3610
  br label %do.body3617

do.body3617:                                      ; preds = %if.then3616
  %2095 = load ptr, ptr %__hptr3612, align 8
  %call3618 = call i64 @ldq_le_p(ptr noundef %2095)
  store i64 %call3618, ptr %inoff, align 8
  br label %do.end3619

do.end3619:                                       ; preds = %do.body3617
  %2096 = load ptr, ptr %__hptr3612, align 8
  %2097 = load i64, ptr %__gaddr3611, align 8
  call void @unlock_user(ptr noundef %2096, i64 noundef %2097, i64 noundef 0)
  br label %if.end3621

if.else3620:                                      ; preds = %if.then3610
  store i64 0, ptr %inoff, align 8
  store i64 -14, ptr %__ret3613, align 8
  br label %if.end3621

if.end3621:                                       ; preds = %if.else3620, %do.end3619
  %2098 = load i64, ptr %__ret3613, align 8
  store i64 %2098, ptr %tmp3622, align 8
  %2099 = load i64, ptr %tmp3622, align 8
  %tobool3623 = icmp ne i64 %2099, 0
  br i1 %tobool3623, label %if.then3624, label %if.end3625

if.then3624:                                      ; preds = %if.end3621
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3625:                                       ; preds = %if.end3621
  store ptr %inoff, ptr %pinoff, align 8
  br label %if.end3626

if.end3626:                                       ; preds = %if.end3625, %sw.bb3608
  %2100 = load i64, ptr %arg4.addr, align 8
  %tobool3627 = icmp ne i64 %2100, 0
  br i1 %tobool3627, label %if.then3628, label %if.end3644

if.then3628:                                      ; preds = %if.end3626
  %2101 = load i64, ptr %arg4.addr, align 8
  store i64 %2101, ptr %__gaddr3629, align 8
  store i64 0, ptr %__ret3631, align 8
  %2102 = load i64, ptr %__gaddr3629, align 8
  %call3632 = call ptr @lock_user(i32 noundef 1, i64 noundef %2102, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call3632, ptr %__hptr3630, align 8
  %tobool3633 = icmp ne ptr %call3632, null
  br i1 %tobool3633, label %if.then3634, label %if.else3638

if.then3634:                                      ; preds = %if.then3628
  br label %do.body3635

do.body3635:                                      ; preds = %if.then3634
  %2103 = load ptr, ptr %__hptr3630, align 8
  %call3636 = call i64 @ldq_le_p(ptr noundef %2103)
  store i64 %call3636, ptr %outoff, align 8
  br label %do.end3637

do.end3637:                                       ; preds = %do.body3635
  %2104 = load ptr, ptr %__hptr3630, align 8
  %2105 = load i64, ptr %__gaddr3629, align 8
  call void @unlock_user(ptr noundef %2104, i64 noundef %2105, i64 noundef 0)
  br label %if.end3639

if.else3638:                                      ; preds = %if.then3628
  store i64 0, ptr %outoff, align 8
  store i64 -14, ptr %__ret3631, align 8
  br label %if.end3639

if.end3639:                                       ; preds = %if.else3638, %do.end3637
  %2106 = load i64, ptr %__ret3631, align 8
  store i64 %2106, ptr %tmp3640, align 8
  %2107 = load i64, ptr %tmp3640, align 8
  %tobool3641 = icmp ne i64 %2107, 0
  br i1 %tobool3641, label %if.then3642, label %if.end3643

if.then3642:                                      ; preds = %if.end3639
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3643:                                       ; preds = %if.end3639
  store ptr %outoff, ptr %poutoff, align 8
  br label %if.end3644

if.end3644:                                       ; preds = %if.end3643, %if.end3626
  %2108 = load i64, ptr %arg1.addr, align 8
  %conv3645 = trunc i64 %2108 to i32
  %2109 = load ptr, ptr %pinoff, align 8
  %2110 = load i64, ptr %arg3.addr, align 8
  %conv3646 = trunc i64 %2110 to i32
  %2111 = load ptr, ptr %poutoff, align 8
  %2112 = load i64, ptr %arg5.addr, align 8
  %2113 = load i64, ptr %arg6.addr, align 8
  %conv3647 = trunc i64 %2113 to i32
  %call3648 = call i64 @safe_copy_file_range(i32 noundef %conv3645, ptr noundef %2109, i32 noundef %conv3646, ptr noundef %2111, i64 noundef %2112, i32 noundef %conv3647)
  %call3649 = call i64 @get_errno(i64 noundef %call3648)
  store i64 %call3649, ptr %ret, align 8
  %2114 = load i64, ptr %ret, align 8
  %call3650 = call i32 @is_error(i64 noundef %2114)
  %tobool3651 = icmp ne i32 %call3650, 0
  br i1 %tobool3651, label %if.end3690, label %land.lhs.true3652

land.lhs.true3652:                                ; preds = %if.end3644
  %2115 = load i64, ptr %ret, align 8
  %cmp3653 = icmp sgt i64 %2115, 0
  br i1 %cmp3653, label %if.then3655, label %if.end3690

if.then3655:                                      ; preds = %land.lhs.true3652
  %2116 = load i64, ptr %arg2.addr, align 8
  %tobool3656 = icmp ne i64 %2116, 0
  br i1 %tobool3656, label %if.then3657, label %if.end3672

if.then3657:                                      ; preds = %if.then3655
  %2117 = load i64, ptr %arg2.addr, align 8
  store i64 %2117, ptr %__gaddr3658, align 8
  store i64 0, ptr %__ret3660, align 8
  %2118 = load i64, ptr %__gaddr3658, align 8
  %call3661 = call ptr @lock_user(i32 noundef 3, i64 noundef %2118, i64 noundef 8, i1 noundef zeroext false)
  store ptr %call3661, ptr %__hptr3659, align 8
  %tobool3662 = icmp ne ptr %call3661, null
  br i1 %tobool3662, label %if.then3663, label %if.else3666

if.then3663:                                      ; preds = %if.then3657
  br label %do.body3664

do.body3664:                                      ; preds = %if.then3663
  %2119 = load ptr, ptr %__hptr3659, align 8
  %2120 = load i64, ptr %inoff, align 8
  call void @stq_le_p(ptr noundef %2119, i64 noundef %2120)
  br label %do.end3665

do.end3665:                                       ; preds = %do.body3664
  %2121 = load ptr, ptr %__hptr3659, align 8
  %2122 = load i64, ptr %__gaddr3658, align 8
  call void @unlock_user(ptr noundef %2121, i64 noundef %2122, i64 noundef 8)
  br label %if.end3667

if.else3666:                                      ; preds = %if.then3657
  store i64 -14, ptr %__ret3660, align 8
  br label %if.end3667

if.end3667:                                       ; preds = %if.else3666, %do.end3665
  %2123 = load i64, ptr %__ret3660, align 8
  store i64 %2123, ptr %tmp3668, align 8
  %2124 = load i64, ptr %tmp3668, align 8
  %tobool3669 = icmp ne i64 %2124, 0
  br i1 %tobool3669, label %if.then3670, label %if.end3671

if.then3670:                                      ; preds = %if.end3667
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3671:                                       ; preds = %if.end3667
  br label %if.end3672

if.end3672:                                       ; preds = %if.end3671, %if.then3655
  %2125 = load i64, ptr %arg4.addr, align 8
  %tobool3673 = icmp ne i64 %2125, 0
  br i1 %tobool3673, label %if.then3674, label %if.end3689

if.then3674:                                      ; preds = %if.end3672
  %2126 = load i64, ptr %arg4.addr, align 8
  store i64 %2126, ptr %__gaddr3675, align 8
  store i64 0, ptr %__ret3677, align 8
  %2127 = load i64, ptr %__gaddr3675, align 8
  %call3678 = call ptr @lock_user(i32 noundef 3, i64 noundef %2127, i64 noundef 8, i1 noundef zeroext false)
  store ptr %call3678, ptr %__hptr3676, align 8
  %tobool3679 = icmp ne ptr %call3678, null
  br i1 %tobool3679, label %if.then3680, label %if.else3683

if.then3680:                                      ; preds = %if.then3674
  br label %do.body3681

do.body3681:                                      ; preds = %if.then3680
  %2128 = load ptr, ptr %__hptr3676, align 8
  %2129 = load i64, ptr %outoff, align 8
  call void @stq_le_p(ptr noundef %2128, i64 noundef %2129)
  br label %do.end3682

do.end3682:                                       ; preds = %do.body3681
  %2130 = load ptr, ptr %__hptr3676, align 8
  %2131 = load i64, ptr %__gaddr3675, align 8
  call void @unlock_user(ptr noundef %2130, i64 noundef %2131, i64 noundef 8)
  br label %if.end3684

if.else3683:                                      ; preds = %if.then3674
  store i64 -14, ptr %__ret3677, align 8
  br label %if.end3684

if.end3684:                                       ; preds = %if.else3683, %do.end3682
  %2132 = load i64, ptr %__ret3677, align 8
  store i64 %2132, ptr %tmp3685, align 8
  %2133 = load i64, ptr %tmp3685, align 8
  %tobool3686 = icmp ne i64 %2133, 0
  br i1 %tobool3686, label %if.then3687, label %if.end3688

if.then3687:                                      ; preds = %if.end3684
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3688:                                       ; preds = %if.end3684
  br label %if.end3689

if.end3689:                                       ; preds = %if.end3688, %if.end3672
  br label %if.end3690

if.end3690:                                       ; preds = %if.end3689, %land.lhs.true3652, %if.end3644
  %2134 = load i64, ptr %ret, align 8
  store i64 %2134, ptr %retval, align 8
  br label %return

sw.bb3691:                                        ; preds = %entry
  %2135 = load i64, ptr %arg1.addr, align 8
  %call3693 = call ptr @lock_user_string(i64 noundef %2135)
  store ptr %call3693, ptr %p, align 8
  %2136 = load i64, ptr %arg2.addr, align 8
  %call3694 = call ptr @lock_user_string(i64 noundef %2136)
  store ptr %call3694, ptr %p23692, align 8
  %2137 = load ptr, ptr %p, align 8
  %tobool3695 = icmp ne ptr %2137, null
  br i1 %tobool3695, label %lor.lhs.false3696, label %if.then3698

lor.lhs.false3696:                                ; preds = %sw.bb3691
  %2138 = load ptr, ptr %p23692, align 8
  %tobool3697 = icmp ne ptr %2138, null
  br i1 %tobool3697, label %if.else3699, label %if.then3698

if.then3698:                                      ; preds = %lor.lhs.false3696, %sw.bb3691
  store i64 -14, ptr %ret, align 8
  br label %if.end3703

if.else3699:                                      ; preds = %lor.lhs.false3696
  %2139 = load ptr, ptr %p, align 8
  %2140 = load ptr, ptr %p23692, align 8
  %call3700 = call i32 @pivot_root(ptr noundef %2139, ptr noundef %2140)
  %conv3701 = sext i32 %call3700 to i64
  %call3702 = call i64 @get_errno(i64 noundef %conv3701)
  store i64 %call3702, ptr %ret, align 8
  br label %if.end3703

if.end3703:                                       ; preds = %if.else3699, %if.then3698
  %2141 = load ptr, ptr %p23692, align 8
  %2142 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %2141, i64 noundef %2142, i64 noundef 0)
  %2143 = load ptr, ptr %p, align 8
  %2144 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %2143, i64 noundef %2144, i64 noundef 0)
  %2145 = load i64, ptr %ret, align 8
  store i64 %2145, ptr %retval, align 8
  br label %return

sw.bb3704:                                        ; preds = %entry
  %2146 = load ptr, ptr %cpu_env.addr, align 8
  %2147 = load i64, ptr %arg1.addr, align 8
  %2148 = load i64, ptr %arg2.addr, align 8
  %2149 = load i64, ptr %arg3.addr, align 8
  %2150 = load i64, ptr %arg4.addr, align 8
  %2151 = load i64, ptr %arg5.addr, align 8
  %call3705 = call i64 @do_riscv_hwprobe(ptr noundef %2146, i64 noundef %2147, i64 noundef %2148, i64 noundef %2149, i64 noundef %2150, i64 noundef %2151)
  store i64 %call3705, ptr %retval, align 8
  br label %return

sw.default3706:                                   ; preds = %entry
  br label %do.body3707

do.body3707:                                      ; preds = %sw.default3706
  %call3708 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 1024)
  %lnot = xor i1 %call3708, true
  %lnot3709 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3709 to i32
  %conv3710 = sext i32 %lnot.ext to i64
  %tobool3711 = icmp ne i64 %conv3710, 0
  br i1 %tobool3711, label %if.then3712, label %if.end3713

if.then3712:                                      ; preds = %do.body3707
  %2152 = load i32, ptr %num.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.629, i32 noundef %2152)
  br label %if.end3713

if.end3713:                                       ; preds = %if.then3712, %do.body3707
  br label %do.end3714

do.end3714:                                       ; preds = %if.end3713
  store i64 -38, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end3714, %sw.bb3704, %if.end3703, %if.end3690, %if.then3687, %if.then3670, %if.then3642, %if.then3624, %sw.bb3602, %if.end3596, %if.then3595, %sw.bb3585, %sw.bb3580, %sw.bb3574, %sw.bb3567, %sw.bb3561, %if.end3560, %if.then3559, %if.then3546, %if.end3540, %if.then3539, %if.end3529, %if.end3517, %if.end3502, %if.end3487, %if.end3464, %if.then3461, %if.then3451, %if.end3435, %if.then3431, %if.then3409, %if.end3395, %if.then3385, %if.then3356, %if.end3338, %if.then3288, %if.then3283, %if.then3277, %if.end3258, %if.then3250, %sw.bb3236, %sw.bb3232, %sw.bb3226, %sw.bb3220, %if.end3219, %if.end3196, %if.end3180, %if.then3178, %if.then3161, %if.then3139, %if.then3121, %sw.bb3099, %if.end3098, %if.end3071, %if.then3049, %if.then3038, %if.end3029, %if.then3021, %if.then3009, %if.end2997, %if.then2996, %if.end2988, %if.then2987, %if.then2981, %sw.bb2966, %sw.bb2958, %if.end2957, %sw.bb2941, %if.end2940, %if.then2932, %if.then2918, %if.then2912, %sw.bb2903, %sw.bb2895, %sw.bb2888, %sw.bb2881, %if.end2880, %if.then2879, %if.then2857, %if.end2852, %if.end2841, %if.end2830, %if.end2819, %if.end2808, %if.end2787, %if.then2777, %if.end2769, %if.then2750, %if.end2742, %if.then2730, %if.end2722, %if.then2699, %if.end2690, %if.then2688, %if.end2681, %if.then2665, %sw.bb2656, %sw.bb2652, %sw.bb2649, %sw.bb2642, %if.end2641, %if.then2632, %sw.bb2624, %sw.bb2619, %sw.bb2613, %sw.bb2607, %if.end2606, %if.then2604, %sw.bb2546, %if.end2545, %if.then2543, %sw.bb2485, %if.end2475, %if.then2474, %sw.bb2462, %cleanup2461, %cleanup, %sw.bb2355, %sw.bb2347, %sw.bb2342, %sw.bb2337, %sw.bb2332, %sw.bb2327, %if.end2326, %if.then2266, %if.then2255, %if.then2250, %if.then2237, %if.end2230, %if.then2218, %if.end2214, %if.then2187, %sw.bb2168, %if.end2167, %if.then2085, %if.then2059, %if.end2052, %if.then2051, %if.end2043, %if.then2041, %if.end2022, %if.then2020, %sw.bb2004, %if.end2003, %if.end1991, %sw.bb1976, %sw.bb1971, %sw.bb1967, %if.end1961, %if.then1927, %if.end1916, %if.then1915, %if.then1897, %if.end1891, %if.then1890, %if.then1869, %if.then1854, %if.end1847, %if.then1818, %if.then1801, %sw.bb1793, %if.end1784, %if.then1783, %if.then1779, %if.end1773, %if.then1768, %if.then1757, %if.end1745, %if.then1744, %if.then1740, %if.end1736, %if.then1735, %if.then1719, %if.then1703, %if.end1681, %if.then1680, %if.then1670, %if.end1664, %if.then1662, %if.then1656, %if.then1634, %sw.bb1626, %sw.bb1621, %if.end1620, %if.end1602, %if.end1586, %if.end1570, %sw.bb1550, %sw.bb1548, %sw.bb1545, %sw.bb1541, %sw.bb1536, %sw.bb1531, %if.end1530, %if.then1529, %if.then1518, %if.end1513, %if.then1511, %if.then1500, %if.end1495, %if.then1476, %if.end1469, %if.then1468, %sw.bb1459, %sw.bb1454, %sw.bb1449, %sw.bb1447, %sw.bb1443, %sw.bb1439, %sw.bb1433, %sw.bb1429, %sw.bb1425, %sw.bb1419, %sw.bb1415, %sw.bb1410, %sw.bb1406, %sw.bb1402, %sw.bb1395, %if.end1394, %if.then1342, %if.end1326, %if.then1325, %if.end1321, %if.then1311, %sw.bb1276, %if.end1275, %if.then1222, %if.end1211, %if.then1209, %if.end1189, %if.then1187, %if.then1166, %sw.default1156, %if.end1150, %if.then1149, %if.then1145, %if.then1141, %sw.bb1132, %sw.bb1124, %sw.bb1119, %sw.bb1114, %if.end1109, %if.then1108, %sw.bb1099, %sw.bb1094, %sw.bb1089, %sw.bb1084, %sw.bb1080, %sw.bb1076, %sw.bb1072, %sw.bb1066, %sw.bb1061, %sw.bb1058, %sw.bb1055, %sw.bb1051, %sw.bb1047, %sw.bb1043, %sw.bb1040, %if.end1034, %if.then990, %if.then979, %sw.bb969, %if.end967, %if.then962, %if.end944, %if.then943, %sw.bb934, %sw.bb929, %if.end925, %if.then924, %sw.bb917, %sw.bb911, %sw.bb906, %sw.bb901, %sw.bb895, %sw.bb891, %if.end886, %sw.bb861, %sw.bb856, %if.end855, %if.then840, %if.end829, %if.then828, %if.end824, %if.end793, %sw.bb778, %if.end774, %if.then772, %if.then765, %if.end757, %if.then755, %if.then749, %if.end737, %if.end727, %if.then719, %if.else704, %if.then700, %if.then686, %if.end677, %if.then676, %if.end671, %if.then670, %if.end659, %if.then658, %if.end647, %if.then646, %if.end641, %if.then635, %if.then621, %if.then615, %if.then611, %if.end601, %if.then600, %if.end593, %if.then591, %if.then581, %if.end576, %if.then574, %sw.default, %if.then558, %if.then552, %if.end547, %if.then529, %if.then523, %sw.bb516, %sw.bb512, %if.end511, %if.then497, %if.end488, %if.then487, %sw.bb479, %sw.bb473, %sw.bb469, %sw.bb465, %if.end460, %if.then459, %if.end455, %if.then449, %if.end438, %if.then419, %sw.bb408, %if.end407, %if.end391, %if.then390, %if.end386, %sw.bb364, %sw.bb359, %sw.bb358, %if.end351, %if.then350, %if.end341, %if.then340, %if.end332, %if.then325, %if.then321, %if.end311, %if.then310, %if.then306, %if.then302, %if.end296, %if.end277, %if.end268, %if.then259, %sw.bb249, %sw.bb244, %if.end238, %if.then237, %if.end230, %if.then229, %sw.bb223, %sw.bb218, %if.end212, %if.then211, %if.end207, %if.then192, %if.end188, %if.then186, %sw.bb165, %if.end164, %sw.bb139, %sw.bb132, %if.end124, %if.then121, %sw.bb110, %sw.bb107, %sw.bb105, %if.end96, %if.then95, %if.end91, %if.then70, %if.then63, %if.end56, %if.then40, %if.then33, %if.then
  %2153 = load i64, ptr %retval, align 8
  ret i64 %2153
}

declare void @print_syscall_ret(ptr noundef, i32 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal void @record_syscall_return(ptr noundef %cpu, i32 noundef %num, i64 noundef %ret) #0 {
entry:
  %cpu.addr = alloca ptr, align 8
  %num.addr = alloca i32, align 4
  %ret.addr = alloca i64, align 8
  store ptr %cpu, ptr %cpu.addr, align 8
  store i32 %num, ptr %num.addr, align 4
  store i64 %ret, ptr %ret.addr, align 8
  %0 = load ptr, ptr %cpu.addr, align 8
  %1 = load i32, ptr %num.addr, align 4
  %conv = sext i32 %1 to i64
  %2 = load i64, ptr %ret.addr, align 8
  call void @qemu_plugin_vcpu_syscall_ret(ptr noundef %0, i64 noundef %conv, i64 noundef %2)
  ret void
}

declare i32 @target_to_host_bitmask_len(i32 noundef, ptr noundef, i64 noundef) #3

declare i64 @safe_syscall_base(ptr noundef, i64 noundef, ...) #3

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare nonnull ptr @llvm.threadlocal.address.p0(ptr nonnull) #7

declare i32 @target_to_host_signal(i32 noundef) #3

declare ptr @lock_user(i32 noundef, i64 noundef, i64 noundef, i1 noundef zeroext) #3

declare ptr @thunk_convert(ptr noundef, ptr noundef, ptr noundef, i32 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal void @unlock_user(ptr noundef %host_ptr, i64 noundef %guest_addr, i64 noundef %len) #0 {
entry:
  %host_ptr.addr = alloca ptr, align 8
  %guest_addr.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  store ptr %host_ptr, ptr %host_ptr.addr, align 8
  store i64 %guest_addr, ptr %guest_addr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  ret void
}

; Function Attrs: noreturn nounwind
declare void @__assert_fail(ptr noundef, ptr noundef, i32 noundef, ptr noundef) #4

; Function Attrs: allocsize(0)
declare noalias ptr @g_try_malloc(i64 noundef) #8

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @is_error(i64 noundef %ret) #0 {
entry:
  %ret.addr = alloca i64, align 8
  store i64 %ret, ptr %ret.addr, align 8
  %0 = load i64, ptr %ret.addr, align 8
  %cmp = icmp uge i64 %0, -4096
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare void @g_free(ptr noundef) #3

; Function Attrs: allocsize(0,1)
declare noalias ptr @g_try_malloc0_n(i64 noundef, i64 noundef) #9

; Function Attrs: nounwind sspstrong uwtable
define internal void @urb_hashtable_insert(ptr noundef %urb) #0 {
entry:
  %urb.addr = alloca ptr, align 8
  %urb_hashtable = alloca ptr, align 8
  store ptr %urb, ptr %urb.addr, align 8
  %call = call ptr @usbdevfs_urb_hashtable()
  store ptr %call, ptr %urb_hashtable, align 8
  %0 = load ptr, ptr %urb_hashtable, align 8
  %1 = load ptr, ptr %urb.addr, align 8
  %2 = load ptr, ptr %urb.addr, align 8
  %call1 = call i32 @g_hash_table_insert(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @usbdevfs_urb_hashtable() #0 {
entry:
  %0 = load ptr, ptr @usbdevfs_urb_hashtable.urb_hashtable, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @g_hash_table_new(ptr noundef @g_int64_hash, ptr noundef @g_int64_equal)
  store ptr %call, ptr @usbdevfs_urb_hashtable.urb_hashtable, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr @usbdevfs_urb_hashtable.urb_hashtable, align 8
  ret ptr %1
}

declare i32 @g_hash_table_insert(ptr noundef, ptr noundef, ptr noundef) #3

declare ptr @g_hash_table_new(ptr noundef, ptr noundef) #3

declare i32 @g_int64_hash(ptr noundef) #3

declare i32 @g_int64_equal(ptr noundef, ptr noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @urb_hashtable_lookup(i64 noundef %target_urb_adr) #0 {
entry:
  %target_urb_adr.addr = alloca i64, align 8
  %urb_hashtable = alloca ptr, align 8
  store i64 %target_urb_adr, ptr %target_urb_adr.addr, align 8
  %call = call ptr @usbdevfs_urb_hashtable()
  store ptr %call, ptr %urb_hashtable, align 8
  %0 = load ptr, ptr %urb_hashtable, align 8
  %call1 = call ptr @g_hash_table_lookup(ptr noundef %0, ptr noundef %target_urb_adr.addr)
  ret ptr %call1
}

declare ptr @g_hash_table_lookup(ptr noundef, ptr noundef) #3

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #10

; Function Attrs: nounwind sspstrong uwtable
define internal void @urb_hashtable_remove(ptr noundef %urb) #0 {
entry:
  %urb.addr = alloca ptr, align 8
  %urb_hashtable = alloca ptr, align 8
  store ptr %urb, ptr %urb.addr, align 8
  %call = call ptr @usbdevfs_urb_hashtable()
  store ptr %call, ptr %urb_hashtable, align 8
  %0 = load ptr, ptr %urb_hashtable, align 8
  %1 = load ptr, ptr %urb.addr, align 8
  %call1 = call i32 @g_hash_table_remove(ptr noundef %0, ptr noundef %1)
  ret void
}

declare i32 @g_hash_table_remove(ptr noundef, ptr noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_to_user_timeval(i64 noundef %target_tv_addr, ptr noundef %tv) #0 {
entry:
  %retval = alloca i64, align 8
  %target_tv_addr.addr = alloca i64, align 8
  %tv.addr = alloca ptr, align 8
  %target_tv = alloca ptr, align 8
  store i64 %target_tv_addr, ptr %target_tv_addr.addr, align 8
  store ptr %tv, ptr %tv.addr, align 8
  %0 = load i64, ptr %target_tv_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 16, i1 noundef zeroext false)
  store ptr %call, ptr %target_tv, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_tv, align 8
  %tv_sec = getelementptr inbounds %struct.target_timeval, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %tv.addr, align 8
  %tv_sec1 = getelementptr inbounds %struct.timeval, ptr %2, i32 0, i32 0
  %3 = load i64, ptr %tv_sec1, align 8
  call void @stq_le_p(ptr noundef %tv_sec, i64 noundef %3)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %4 = load ptr, ptr %target_tv, align 8
  %tv_usec = getelementptr inbounds %struct.target_timeval, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %tv.addr, align 8
  %tv_usec3 = getelementptr inbounds %struct.timeval, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %tv_usec3, align 8
  call void @stq_le_p(ptr noundef %tv_usec, i64 noundef %6)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  %7 = load ptr, ptr %target_tv, align 8
  %8 = load i64, ptr %target_tv_addr.addr, align 8
  call void @unlock_user(ptr noundef %7, i64 noundef %8, i64 noundef 16)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end4, %if.then
  %9 = load i64, ptr %retval, align 8
  ret i64 %9
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_to_user_timeval64(i64 noundef %target_tv_addr, ptr noundef %tv) #0 {
entry:
  %retval = alloca i64, align 8
  %target_tv_addr.addr = alloca i64, align 8
  %tv.addr = alloca ptr, align 8
  %target_tv = alloca ptr, align 8
  store i64 %target_tv_addr, ptr %target_tv_addr.addr, align 8
  store ptr %tv, ptr %tv.addr, align 8
  %0 = load i64, ptr %target_tv_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 16, i1 noundef zeroext false)
  store ptr %call, ptr %target_tv, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_tv, align 8
  %tv_sec = getelementptr inbounds %struct.target__kernel_sock_timeval, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %tv.addr, align 8
  %tv_sec1 = getelementptr inbounds %struct.timeval, ptr %2, i32 0, i32 0
  %3 = load i64, ptr %tv_sec1, align 8
  call void @stq_le_p(ptr noundef %tv_sec, i64 noundef %3)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %4 = load ptr, ptr %target_tv, align 8
  %tv_usec = getelementptr inbounds %struct.target__kernel_sock_timeval, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %tv.addr, align 8
  %tv_usec3 = getelementptr inbounds %struct.timeval, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %tv_usec3, align 8
  call void @stq_le_p(ptr noundef %tv_usec, i64 noundef %6)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  %7 = load ptr, ptr %target_tv, align 8
  %8 = load i64, ptr %target_tv_addr.addr, align 8
  call void @unlock_user(ptr noundef %7, i64 noundef %8, i64 noundef 16)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end4, %if.then
  %9 = load i64, ptr %retval, align 8
  ret i64 %9
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stq_le_p(ptr noundef %ptr, i64 noundef %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i64, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i64, ptr %v.addr, align 8
  call void @stq_he_p(ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stq_he_p(ptr noundef %ptr, i64 noundef %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i64, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %0, ptr align 8 %v.addr, i64 8, i1 false)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_timespec(i64 noundef %target_addr, ptr noundef %host_ts) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %host_ts.addr = alloca ptr, align 8
  %target_ts = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_ts, ptr %host_ts.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 16, i1 noundef zeroext false)
  store ptr %call, ptr %target_ts, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_ts, align 8
  %tv_sec = getelementptr inbounds %struct.target_timespec, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %host_ts.addr, align 8
  %tv_sec1 = getelementptr inbounds %struct.timespec, ptr %2, i32 0, i32 0
  %3 = load i64, ptr %tv_sec1, align 8
  call void @stq_le_p(ptr noundef %tv_sec, i64 noundef %3)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %4 = load ptr, ptr %target_ts, align 8
  %tv_nsec = getelementptr inbounds %struct.target_timespec, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %host_ts.addr, align 8
  %tv_nsec3 = getelementptr inbounds %struct.timespec, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %tv_nsec3, align 8
  call void @stq_le_p(ptr noundef %tv_nsec, i64 noundef %6)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  %7 = load ptr, ptr %target_ts, align 8
  %8 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %7, i64 noundef %8, i64 noundef 16)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end4, %if.then
  %9 = load i64, ptr %retval, align 8
  ret i64 %9
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_timespec64(i64 noundef %target_addr, ptr noundef %host_ts) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %host_ts.addr = alloca ptr, align 8
  %target_ts = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_ts, ptr %host_ts.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 16, i1 noundef zeroext false)
  store ptr %call, ptr %target_ts, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_ts, align 8
  %tv_sec = getelementptr inbounds %struct.target__kernel_timespec, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %host_ts.addr, align 8
  %tv_sec1 = getelementptr inbounds %struct.timespec, ptr %2, i32 0, i32 0
  %3 = load i64, ptr %tv_sec1, align 8
  call void @stq_le_p(ptr noundef %tv_sec, i64 noundef %3)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %4 = load ptr, ptr %target_ts, align 8
  %tv_nsec = getelementptr inbounds %struct.target__kernel_timespec, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %host_ts.addr, align 8
  %tv_nsec3 = getelementptr inbounds %struct.timespec, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %tv_nsec3, align 8
  call void @stq_le_p(ptr noundef %tv_nsec, i64 noundef %6)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  %7 = load ptr, ptr %target_ts, align 8
  %8 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %7, i64 noundef %8, i64 noundef 16)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end4, %if.then
  %9 = load i64, ptr %retval, align 8
  ret i64 %9
}

; Function Attrs: allocsize(0)
declare noalias ptr @g_malloc0(i64 noundef) #8

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @tswap64(i64 noundef %s) #0 {
entry:
  %s.addr = alloca i64, align 8
  store i64 %s, ptr %s.addr, align 8
  %0 = load i64, ptr %s.addr, align 8
  ret i64 %0
}

; Function Attrs: nounwind
declare ptr @strcpy(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tswap32(i32 noundef %s) #0 {
entry:
  %s.addr = alloca i32, align 4
  store i32 %s, ptr %s.addr, align 4
  %0 = load i32, ptr %s.addr, align 4
  ret i32 %0
}

declare ptr @lock_user_string(i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @tswapal(i64 noundef %v) #0 {
entry:
  %v.addr = alloca i64, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load i64, ptr %v.addr, align 8
  %call = call i64 @tswap64(i64 noundef %0)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_drmversion(ptr noundef %host_ver, ptr noundef %target_ver) #0 {
entry:
  %retval = alloca i64, align 8
  %host_ver.addr = alloca ptr, align 8
  %target_ver.addr = alloca ptr, align 8
  store ptr %host_ver, ptr %host_ver.addr, align 8
  store ptr %target_ver, ptr %target_ver.addr, align 8
  %0 = load ptr, ptr %host_ver.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %0, i8 0, i64 64, i1 false)
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load ptr, ptr %target_ver.addr, align 8
  %name_len = getelementptr inbounds %struct.target_drm_version, ptr %1, i32 0, i32 3
  %call = call i64 @ldq_le_p(ptr noundef %name_len)
  %2 = load ptr, ptr %host_ver.addr, align 8
  %name_len1 = getelementptr inbounds %struct.drm_version, ptr %2, i32 0, i32 3
  store i64 %call, ptr %name_len1, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %3 = load ptr, ptr %host_ver.addr, align 8
  %name_len2 = getelementptr inbounds %struct.drm_version, ptr %3, i32 0, i32 3
  %4 = load i64, ptr %name_len2, align 8
  %tobool = icmp ne i64 %4, 0
  br i1 %tobool, label %if.then, label %if.end9

if.then:                                          ; preds = %do.end
  %5 = load ptr, ptr %target_ver.addr, align 8
  %name = getelementptr inbounds %struct.target_drm_version, ptr %5, i32 0, i32 4
  %6 = load i64, ptr %name, align 8
  %7 = load ptr, ptr %target_ver.addr, align 8
  %name_len3 = getelementptr inbounds %struct.target_drm_version, ptr %7, i32 0, i32 3
  %8 = load i64, ptr %name_len3, align 8
  %call4 = call ptr @lock_user(i32 noundef 3, i64 noundef %6, i64 noundef %8, i1 noundef zeroext false)
  %9 = load ptr, ptr %host_ver.addr, align 8
  %name5 = getelementptr inbounds %struct.drm_version, ptr %9, i32 0, i32 4
  store ptr %call4, ptr %name5, align 8
  %10 = load ptr, ptr %host_ver.addr, align 8
  %name6 = getelementptr inbounds %struct.drm_version, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %name6, align 8
  %tobool7 = icmp ne ptr %11, null
  br i1 %tobool7, label %if.end, label %if.then8

if.then8:                                         ; preds = %if.then
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end9

if.end9:                                          ; preds = %if.end, %do.end
  br label %do.body10

do.body10:                                        ; preds = %if.end9
  %12 = load ptr, ptr %target_ver.addr, align 8
  %date_len = getelementptr inbounds %struct.target_drm_version, ptr %12, i32 0, i32 5
  %call11 = call i64 @ldq_le_p(ptr noundef %date_len)
  %13 = load ptr, ptr %host_ver.addr, align 8
  %date_len12 = getelementptr inbounds %struct.drm_version, ptr %13, i32 0, i32 5
  store i64 %call11, ptr %date_len12, align 8
  br label %do.end13

do.end13:                                         ; preds = %do.body10
  %14 = load ptr, ptr %host_ver.addr, align 8
  %date_len14 = getelementptr inbounds %struct.drm_version, ptr %14, i32 0, i32 5
  %15 = load i64, ptr %date_len14, align 8
  %tobool15 = icmp ne i64 %15, 0
  br i1 %tobool15, label %if.then16, label %if.end24

if.then16:                                        ; preds = %do.end13
  %16 = load ptr, ptr %target_ver.addr, align 8
  %date = getelementptr inbounds %struct.target_drm_version, ptr %16, i32 0, i32 6
  %17 = load i64, ptr %date, align 8
  %18 = load ptr, ptr %target_ver.addr, align 8
  %date_len17 = getelementptr inbounds %struct.target_drm_version, ptr %18, i32 0, i32 5
  %19 = load i64, ptr %date_len17, align 8
  %call18 = call ptr @lock_user(i32 noundef 3, i64 noundef %17, i64 noundef %19, i1 noundef zeroext false)
  %20 = load ptr, ptr %host_ver.addr, align 8
  %date19 = getelementptr inbounds %struct.drm_version, ptr %20, i32 0, i32 6
  store ptr %call18, ptr %date19, align 8
  %21 = load ptr, ptr %host_ver.addr, align 8
  %date20 = getelementptr inbounds %struct.drm_version, ptr %21, i32 0, i32 6
  %22 = load ptr, ptr %date20, align 8
  %tobool21 = icmp ne ptr %22, null
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.then16
  br label %err

if.end23:                                         ; preds = %if.then16
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %do.end13
  br label %do.body25

do.body25:                                        ; preds = %if.end24
  %23 = load ptr, ptr %target_ver.addr, align 8
  %desc_len = getelementptr inbounds %struct.target_drm_version, ptr %23, i32 0, i32 7
  %call26 = call i64 @ldq_le_p(ptr noundef %desc_len)
  %24 = load ptr, ptr %host_ver.addr, align 8
  %desc_len27 = getelementptr inbounds %struct.drm_version, ptr %24, i32 0, i32 7
  store i64 %call26, ptr %desc_len27, align 8
  br label %do.end28

do.end28:                                         ; preds = %do.body25
  %25 = load ptr, ptr %host_ver.addr, align 8
  %desc_len29 = getelementptr inbounds %struct.drm_version, ptr %25, i32 0, i32 7
  %26 = load i64, ptr %desc_len29, align 8
  %tobool30 = icmp ne i64 %26, 0
  br i1 %tobool30, label %if.then31, label %if.end39

if.then31:                                        ; preds = %do.end28
  %27 = load ptr, ptr %target_ver.addr, align 8
  %desc = getelementptr inbounds %struct.target_drm_version, ptr %27, i32 0, i32 8
  %28 = load i64, ptr %desc, align 8
  %29 = load ptr, ptr %target_ver.addr, align 8
  %desc_len32 = getelementptr inbounds %struct.target_drm_version, ptr %29, i32 0, i32 7
  %30 = load i64, ptr %desc_len32, align 8
  %call33 = call ptr @lock_user(i32 noundef 3, i64 noundef %28, i64 noundef %30, i1 noundef zeroext false)
  %31 = load ptr, ptr %host_ver.addr, align 8
  %desc34 = getelementptr inbounds %struct.drm_version, ptr %31, i32 0, i32 8
  store ptr %call33, ptr %desc34, align 8
  %32 = load ptr, ptr %host_ver.addr, align 8
  %desc35 = getelementptr inbounds %struct.drm_version, ptr %32, i32 0, i32 8
  %33 = load ptr, ptr %desc35, align 8
  %tobool36 = icmp ne ptr %33, null
  br i1 %tobool36, label %if.end38, label %if.then37

if.then37:                                        ; preds = %if.then31
  br label %err

if.end38:                                         ; preds = %if.then31
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %do.end28
  store i64 0, ptr %retval, align 8
  br label %return

err:                                              ; preds = %if.then37, %if.then22
  %34 = load ptr, ptr %host_ver.addr, align 8
  %35 = load ptr, ptr %target_ver.addr, align 8
  call void @unlock_drm_version(ptr noundef %34, ptr noundef %35, i1 noundef zeroext false)
  store i64 -14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %err, %if.end39, %if.then8
  %36 = load i64, ptr %retval, align 8
  ret i64 %36
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @unlock_drm_version(ptr noundef %host_ver, ptr noundef %target_ver, i1 noundef zeroext %copy) #0 {
entry:
  %host_ver.addr = alloca ptr, align 8
  %target_ver.addr = alloca ptr, align 8
  %copy.addr = alloca i8, align 1
  store ptr %host_ver, ptr %host_ver.addr, align 8
  store ptr %target_ver, ptr %target_ver.addr, align 8
  %frombool = zext i1 %copy to i8
  store i8 %frombool, ptr %copy.addr, align 1
  %0 = load ptr, ptr %host_ver.addr, align 8
  %name = getelementptr inbounds %struct.drm_version, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %name, align 8
  %2 = load ptr, ptr %target_ver.addr, align 8
  %name1 = getelementptr inbounds %struct.target_drm_version, ptr %2, i32 0, i32 4
  %3 = load i64, ptr %name1, align 8
  %4 = load i8, ptr %copy.addr, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load ptr, ptr %host_ver.addr, align 8
  %name_len = getelementptr inbounds %struct.drm_version, ptr %5, i32 0, i32 3
  %6 = load i64, ptr %name_len, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %6, %cond.true ], [ 0, %cond.false ]
  call void @unlock_user(ptr noundef %1, i64 noundef %3, i64 noundef %cond)
  %7 = load ptr, ptr %host_ver.addr, align 8
  %date = getelementptr inbounds %struct.drm_version, ptr %7, i32 0, i32 6
  %8 = load ptr, ptr %date, align 8
  %9 = load ptr, ptr %target_ver.addr, align 8
  %date2 = getelementptr inbounds %struct.target_drm_version, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %date2, align 8
  %11 = load i8, ptr %copy.addr, align 1
  %tobool3 = trunc i8 %11 to i1
  br i1 %tobool3, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %12 = load ptr, ptr %host_ver.addr, align 8
  %date_len = getelementptr inbounds %struct.drm_version, ptr %12, i32 0, i32 5
  %13 = load i64, ptr %date_len, align 8
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i64 [ %13, %cond.true4 ], [ 0, %cond.false5 ]
  call void @unlock_user(ptr noundef %8, i64 noundef %10, i64 noundef %cond7)
  %14 = load ptr, ptr %host_ver.addr, align 8
  %desc = getelementptr inbounds %struct.drm_version, ptr %14, i32 0, i32 8
  %15 = load ptr, ptr %desc, align 8
  %16 = load ptr, ptr %target_ver.addr, align 8
  %desc8 = getelementptr inbounds %struct.target_drm_version, ptr %16, i32 0, i32 8
  %17 = load i64, ptr %desc8, align 8
  %18 = load i8, ptr %copy.addr, align 1
  %tobool9 = trunc i8 %18 to i1
  br i1 %tobool9, label %cond.true10, label %cond.false11

cond.true10:                                      ; preds = %cond.end6
  %19 = load ptr, ptr %host_ver.addr, align 8
  %desc_len = getelementptr inbounds %struct.drm_version, ptr %19, i32 0, i32 7
  %20 = load i64, ptr %desc_len, align 8
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end6
  br label %cond.end12

cond.end12:                                       ; preds = %cond.false11, %cond.true10
  %cond13 = phi i64 [ %20, %cond.true10 ], [ 0, %cond.false11 ]
  call void @unlock_user(ptr noundef %15, i64 noundef %17, i64 noundef %cond13)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @host_to_target_drmversion(ptr noundef %target_ver, ptr noundef %host_ver) #0 {
entry:
  %target_ver.addr = alloca ptr, align 8
  %host_ver.addr = alloca ptr, align 8
  store ptr %target_ver, ptr %target_ver.addr, align 8
  store ptr %host_ver, ptr %host_ver.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load ptr, ptr %target_ver.addr, align 8
  %version_major = getelementptr inbounds %struct.target_drm_version, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %host_ver.addr, align 8
  %version_major1 = getelementptr inbounds %struct.drm_version, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %version_major1, align 8
  call void @stl_le_p(ptr noundef %version_major, i32 noundef %2)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %3 = load ptr, ptr %target_ver.addr, align 8
  %version_minor = getelementptr inbounds %struct.target_drm_version, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %host_ver.addr, align 8
  %version_minor3 = getelementptr inbounds %struct.drm_version, ptr %4, i32 0, i32 1
  %5 = load i32, ptr %version_minor3, align 4
  call void @stl_le_p(ptr noundef %version_minor, i32 noundef %5)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  br label %do.body5

do.body5:                                         ; preds = %do.end4
  %6 = load ptr, ptr %target_ver.addr, align 8
  %version_patchlevel = getelementptr inbounds %struct.target_drm_version, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %host_ver.addr, align 8
  %version_patchlevel6 = getelementptr inbounds %struct.drm_version, ptr %7, i32 0, i32 2
  %8 = load i32, ptr %version_patchlevel6, align 8
  call void @stl_le_p(ptr noundef %version_patchlevel, i32 noundef %8)
  br label %do.end7

do.end7:                                          ; preds = %do.body5
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %9 = load ptr, ptr %target_ver.addr, align 8
  %name_len = getelementptr inbounds %struct.target_drm_version, ptr %9, i32 0, i32 3
  %10 = load ptr, ptr %host_ver.addr, align 8
  %name_len9 = getelementptr inbounds %struct.drm_version, ptr %10, i32 0, i32 3
  %11 = load i64, ptr %name_len9, align 8
  call void @stq_le_p(ptr noundef %name_len, i64 noundef %11)
  br label %do.end10

do.end10:                                         ; preds = %do.body8
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %12 = load ptr, ptr %target_ver.addr, align 8
  %date_len = getelementptr inbounds %struct.target_drm_version, ptr %12, i32 0, i32 5
  %13 = load ptr, ptr %host_ver.addr, align 8
  %date_len12 = getelementptr inbounds %struct.drm_version, ptr %13, i32 0, i32 5
  %14 = load i64, ptr %date_len12, align 8
  call void @stq_le_p(ptr noundef %date_len, i64 noundef %14)
  br label %do.end13

do.end13:                                         ; preds = %do.body11
  br label %do.body14

do.body14:                                        ; preds = %do.end13
  %15 = load ptr, ptr %target_ver.addr, align 8
  %desc_len = getelementptr inbounds %struct.target_drm_version, ptr %15, i32 0, i32 7
  %16 = load ptr, ptr %host_ver.addr, align 8
  %desc_len15 = getelementptr inbounds %struct.drm_version, ptr %16, i32 0, i32 7
  %17 = load i64, ptr %desc_len15, align 8
  call void @stq_le_p(ptr noundef %desc_len, i64 noundef %17)
  br label %do.end16

do.end16:                                         ; preds = %do.body14
  %18 = load ptr, ptr %host_ver.addr, align 8
  %19 = load ptr, ptr %target_ver.addr, align 8
  call void @unlock_drm_version(ptr noundef %18, ptr noundef %19, i1 noundef zeroext true)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @ldq_le_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %call = call i64 @ldq_he_p(ptr noundef %0)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @ldq_he_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %r = alloca i64, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %r, ptr align 1 %0, i64 8, i1 false)
  %1 = load i64, ptr %r, align 8
  ret i64 %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stl_le_p(ptr noundef %ptr, i32 noundef %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i32, align 4
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %v, ptr %v.addr, align 4
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i32, ptr %v.addr, align 4
  call void @stl_he_p(ptr noundef %0, i32 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stl_he_p(ptr noundef %ptr, i32 noundef %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i32, align 4
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %v, ptr %v.addr, align 4
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %0, ptr align 4 %v.addr, i64 4, i1 false)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl_drm_i915_getparam(ptr noundef %ie, ptr noundef %gparam, i32 noundef %fd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %ie.addr = alloca ptr, align 8
  %gparam.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %ret = alloca i64, align 8
  %value = alloca i32, align 4
  %target_gparam = alloca ptr, align 8
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %ie, ptr %ie.addr, align 8
  store ptr %gparam, ptr %gparam.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load i64, ptr %arg.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 16, i1 noundef zeroext false)
  store ptr %call, ptr %target_gparam, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_gparam, align 8
  %param = getelementptr inbounds %struct.target_drm_i915_getparam, ptr %1, i32 0, i32 0
  %call1 = call i32 @ldl_le_p(ptr noundef %param)
  %2 = load ptr, ptr %gparam.addr, align 8
  %param2 = getelementptr inbounds %struct.drm_i915_getparam, ptr %2, i32 0, i32 0
  store i32 %call1, ptr %param2, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %3 = load ptr, ptr %gparam.addr, align 8
  %value3 = getelementptr inbounds %struct.drm_i915_getparam, ptr %3, i32 0, i32 1
  store ptr %value, ptr %value3, align 8
  %4 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %5 = load ptr, ptr %4, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %5, i32 0, i32 39
  %6 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %6, i32 0, i32 14
  %7 = load i32, ptr %fd.addr, align 4
  %8 = load ptr, ptr %ie.addr, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %8, i32 0, i32 1
  %9 = load i32, ptr %host_cmd, align 4
  %10 = load ptr, ptr %gparam.addr, align 8
  %call4 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %7, i32 noundef %9, ptr noundef %10)
  %call5 = call i64 @get_errno(i64 noundef %call4)
  store i64 %call5, ptr %ret, align 8
  %11 = load ptr, ptr %target_gparam, align 8
  %value6 = getelementptr inbounds %struct.target_drm_i915_getparam, ptr %11, i32 0, i32 1
  %12 = load i64, ptr %value6, align 8
  store i64 %12, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %13 = load i64, ptr %__gaddr, align 8
  %call7 = call ptr @lock_user(i32 noundef 3, i64 noundef %13, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call7, ptr %__hptr, align 8
  %tobool8 = icmp ne ptr %call7, null
  br i1 %tobool8, label %if.then9, label %if.else

if.then9:                                         ; preds = %do.end
  br label %do.body10

do.body10:                                        ; preds = %if.then9
  %14 = load ptr, ptr %__hptr, align 8
  %15 = load i32, ptr %value, align 4
  call void @stl_le_p(ptr noundef %14, i32 noundef %15)
  br label %do.end11

do.end11:                                         ; preds = %do.body10
  %16 = load ptr, ptr %__hptr, align 8
  %17 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %16, i64 noundef %17, i64 noundef 4)
  br label %if.end12

if.else:                                          ; preds = %do.end
  store i64 -14, ptr %__ret, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else, %do.end11
  %18 = load i64, ptr %__ret, align 8
  store i64 %18, ptr %tmp, align 8
  %19 = load ptr, ptr %target_gparam, align 8
  %20 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %19, i64 noundef %20, i64 noundef 0)
  %21 = load i64, ptr %ret, align 8
  store i64 %21, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then
  %22 = load i64, ptr %retval, align 8
  ret i64 %22
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ldl_le_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %call = call i32 @ldl_he_p(ptr noundef %0)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ldl_he_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %r = alloca i32, align 4
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %r, ptr align 1 %0, i64 4, i1 false)
  %1 = load i32, ptr %r, align 4
  ret i32 %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @tswap16(i16 noundef zeroext %s) #0 {
entry:
  %s.addr = alloca i16, align 2
  store i16 %s, ptr %s.addr, align 2
  %0 = load i16, ptr %s.addr, align 2
  ret i16 %0
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @host_to_target_termios(ptr noundef %dst, ptr noundef %src) #0 {
entry:
  %dst.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %target = alloca ptr, align 8
  %host = alloca ptr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  store ptr %0, ptr %target, align 8
  %1 = load ptr, ptr %src.addr, align 8
  store ptr %1, ptr %host, align 8
  %2 = load ptr, ptr %host, align 8
  %c_iflag = getelementptr inbounds %struct.host_termios, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %c_iflag, align 4
  %call = call i32 @host_to_target_bitmask_len(i32 noundef %3, ptr noundef @iflag_tbl, i64 noundef 15)
  %call1 = call i32 @tswap32(i32 noundef %call)
  %4 = load ptr, ptr %target, align 8
  %c_iflag2 = getelementptr inbounds %struct.target_termios, ptr %4, i32 0, i32 0
  store i32 %call1, ptr %c_iflag2, align 4
  %5 = load ptr, ptr %host, align 8
  %c_oflag = getelementptr inbounds %struct.host_termios, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %c_oflag, align 4
  %call3 = call i32 @host_to_target_bitmask_len(i32 noundef %6, ptr noundef @oflag_tbl, i64 noundef 24)
  %call4 = call i32 @tswap32(i32 noundef %call3)
  %7 = load ptr, ptr %target, align 8
  %c_oflag5 = getelementptr inbounds %struct.target_termios, ptr %7, i32 0, i32 1
  store i32 %call4, ptr %c_oflag5, align 4
  %8 = load ptr, ptr %host, align 8
  %c_cflag = getelementptr inbounds %struct.host_termios, ptr %8, i32 0, i32 2
  %9 = load i32, ptr %c_cflag, align 4
  %call6 = call i32 @host_to_target_bitmask_len(i32 noundef %9, ptr noundef @cflag_tbl, i64 noundef 31)
  %call7 = call i32 @tswap32(i32 noundef %call6)
  %10 = load ptr, ptr %target, align 8
  %c_cflag8 = getelementptr inbounds %struct.target_termios, ptr %10, i32 0, i32 2
  store i32 %call7, ptr %c_cflag8, align 4
  %11 = load ptr, ptr %host, align 8
  %c_lflag = getelementptr inbounds %struct.host_termios, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %c_lflag, align 4
  %call9 = call i32 @host_to_target_bitmask_len(i32 noundef %12, ptr noundef @lflag_tbl, i64 noundef 16)
  %call10 = call i32 @tswap32(i32 noundef %call9)
  %13 = load ptr, ptr %target, align 8
  %c_lflag11 = getelementptr inbounds %struct.target_termios, ptr %13, i32 0, i32 3
  store i32 %call10, ptr %c_lflag11, align 4
  %14 = load ptr, ptr %host, align 8
  %c_line = getelementptr inbounds %struct.host_termios, ptr %14, i32 0, i32 4
  %15 = load i8, ptr %c_line, align 4
  %16 = load ptr, ptr %target, align 8
  %c_line12 = getelementptr inbounds %struct.target_termios, ptr %16, i32 0, i32 4
  store i8 %15, ptr %c_line12, align 4
  %17 = load ptr, ptr %target, align 8
  %c_cc = getelementptr inbounds %struct.target_termios, ptr %17, i32 0, i32 5
  %arraydecay = getelementptr inbounds [19 x i8], ptr %c_cc, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 1 %arraydecay, i8 0, i64 19, i1 false)
  %18 = load ptr, ptr %host, align 8
  %c_cc13 = getelementptr inbounds %struct.host_termios, ptr %18, i32 0, i32 5
  %arrayidx = getelementptr [19 x i8], ptr %c_cc13, i64 0, i64 0
  %19 = load i8, ptr %arrayidx, align 1
  %20 = load ptr, ptr %target, align 8
  %c_cc14 = getelementptr inbounds %struct.target_termios, ptr %20, i32 0, i32 5
  %arrayidx15 = getelementptr [19 x i8], ptr %c_cc14, i64 0, i64 0
  store i8 %19, ptr %arrayidx15, align 1
  %21 = load ptr, ptr %host, align 8
  %c_cc16 = getelementptr inbounds %struct.host_termios, ptr %21, i32 0, i32 5
  %arrayidx17 = getelementptr [19 x i8], ptr %c_cc16, i64 0, i64 1
  %22 = load i8, ptr %arrayidx17, align 1
  %23 = load ptr, ptr %target, align 8
  %c_cc18 = getelementptr inbounds %struct.target_termios, ptr %23, i32 0, i32 5
  %arrayidx19 = getelementptr [19 x i8], ptr %c_cc18, i64 0, i64 1
  store i8 %22, ptr %arrayidx19, align 1
  %24 = load ptr, ptr %host, align 8
  %c_cc20 = getelementptr inbounds %struct.host_termios, ptr %24, i32 0, i32 5
  %arrayidx21 = getelementptr [19 x i8], ptr %c_cc20, i64 0, i64 2
  %25 = load i8, ptr %arrayidx21, align 1
  %26 = load ptr, ptr %target, align 8
  %c_cc22 = getelementptr inbounds %struct.target_termios, ptr %26, i32 0, i32 5
  %arrayidx23 = getelementptr [19 x i8], ptr %c_cc22, i64 0, i64 2
  store i8 %25, ptr %arrayidx23, align 1
  %27 = load ptr, ptr %host, align 8
  %c_cc24 = getelementptr inbounds %struct.host_termios, ptr %27, i32 0, i32 5
  %arrayidx25 = getelementptr [19 x i8], ptr %c_cc24, i64 0, i64 3
  %28 = load i8, ptr %arrayidx25, align 1
  %29 = load ptr, ptr %target, align 8
  %c_cc26 = getelementptr inbounds %struct.target_termios, ptr %29, i32 0, i32 5
  %arrayidx27 = getelementptr [19 x i8], ptr %c_cc26, i64 0, i64 3
  store i8 %28, ptr %arrayidx27, align 1
  %30 = load ptr, ptr %host, align 8
  %c_cc28 = getelementptr inbounds %struct.host_termios, ptr %30, i32 0, i32 5
  %arrayidx29 = getelementptr [19 x i8], ptr %c_cc28, i64 0, i64 4
  %31 = load i8, ptr %arrayidx29, align 1
  %32 = load ptr, ptr %target, align 8
  %c_cc30 = getelementptr inbounds %struct.target_termios, ptr %32, i32 0, i32 5
  %arrayidx31 = getelementptr [19 x i8], ptr %c_cc30, i64 0, i64 4
  store i8 %31, ptr %arrayidx31, align 1
  %33 = load ptr, ptr %host, align 8
  %c_cc32 = getelementptr inbounds %struct.host_termios, ptr %33, i32 0, i32 5
  %arrayidx33 = getelementptr [19 x i8], ptr %c_cc32, i64 0, i64 5
  %34 = load i8, ptr %arrayidx33, align 1
  %35 = load ptr, ptr %target, align 8
  %c_cc34 = getelementptr inbounds %struct.target_termios, ptr %35, i32 0, i32 5
  %arrayidx35 = getelementptr [19 x i8], ptr %c_cc34, i64 0, i64 5
  store i8 %34, ptr %arrayidx35, align 1
  %36 = load ptr, ptr %host, align 8
  %c_cc36 = getelementptr inbounds %struct.host_termios, ptr %36, i32 0, i32 5
  %arrayidx37 = getelementptr [19 x i8], ptr %c_cc36, i64 0, i64 6
  %37 = load i8, ptr %arrayidx37, align 1
  %38 = load ptr, ptr %target, align 8
  %c_cc38 = getelementptr inbounds %struct.target_termios, ptr %38, i32 0, i32 5
  %arrayidx39 = getelementptr [19 x i8], ptr %c_cc38, i64 0, i64 6
  store i8 %37, ptr %arrayidx39, align 1
  %39 = load ptr, ptr %host, align 8
  %c_cc40 = getelementptr inbounds %struct.host_termios, ptr %39, i32 0, i32 5
  %arrayidx41 = getelementptr [19 x i8], ptr %c_cc40, i64 0, i64 7
  %40 = load i8, ptr %arrayidx41, align 1
  %41 = load ptr, ptr %target, align 8
  %c_cc42 = getelementptr inbounds %struct.target_termios, ptr %41, i32 0, i32 5
  %arrayidx43 = getelementptr [19 x i8], ptr %c_cc42, i64 0, i64 7
  store i8 %40, ptr %arrayidx43, align 1
  %42 = load ptr, ptr %host, align 8
  %c_cc44 = getelementptr inbounds %struct.host_termios, ptr %42, i32 0, i32 5
  %arrayidx45 = getelementptr [19 x i8], ptr %c_cc44, i64 0, i64 8
  %43 = load i8, ptr %arrayidx45, align 1
  %44 = load ptr, ptr %target, align 8
  %c_cc46 = getelementptr inbounds %struct.target_termios, ptr %44, i32 0, i32 5
  %arrayidx47 = getelementptr [19 x i8], ptr %c_cc46, i64 0, i64 8
  store i8 %43, ptr %arrayidx47, align 1
  %45 = load ptr, ptr %host, align 8
  %c_cc48 = getelementptr inbounds %struct.host_termios, ptr %45, i32 0, i32 5
  %arrayidx49 = getelementptr [19 x i8], ptr %c_cc48, i64 0, i64 9
  %46 = load i8, ptr %arrayidx49, align 1
  %47 = load ptr, ptr %target, align 8
  %c_cc50 = getelementptr inbounds %struct.target_termios, ptr %47, i32 0, i32 5
  %arrayidx51 = getelementptr [19 x i8], ptr %c_cc50, i64 0, i64 9
  store i8 %46, ptr %arrayidx51, align 1
  %48 = load ptr, ptr %host, align 8
  %c_cc52 = getelementptr inbounds %struct.host_termios, ptr %48, i32 0, i32 5
  %arrayidx53 = getelementptr [19 x i8], ptr %c_cc52, i64 0, i64 10
  %49 = load i8, ptr %arrayidx53, align 1
  %50 = load ptr, ptr %target, align 8
  %c_cc54 = getelementptr inbounds %struct.target_termios, ptr %50, i32 0, i32 5
  %arrayidx55 = getelementptr [19 x i8], ptr %c_cc54, i64 0, i64 10
  store i8 %49, ptr %arrayidx55, align 1
  %51 = load ptr, ptr %host, align 8
  %c_cc56 = getelementptr inbounds %struct.host_termios, ptr %51, i32 0, i32 5
  %arrayidx57 = getelementptr [19 x i8], ptr %c_cc56, i64 0, i64 11
  %52 = load i8, ptr %arrayidx57, align 1
  %53 = load ptr, ptr %target, align 8
  %c_cc58 = getelementptr inbounds %struct.target_termios, ptr %53, i32 0, i32 5
  %arrayidx59 = getelementptr [19 x i8], ptr %c_cc58, i64 0, i64 11
  store i8 %52, ptr %arrayidx59, align 1
  %54 = load ptr, ptr %host, align 8
  %c_cc60 = getelementptr inbounds %struct.host_termios, ptr %54, i32 0, i32 5
  %arrayidx61 = getelementptr [19 x i8], ptr %c_cc60, i64 0, i64 12
  %55 = load i8, ptr %arrayidx61, align 1
  %56 = load ptr, ptr %target, align 8
  %c_cc62 = getelementptr inbounds %struct.target_termios, ptr %56, i32 0, i32 5
  %arrayidx63 = getelementptr [19 x i8], ptr %c_cc62, i64 0, i64 12
  store i8 %55, ptr %arrayidx63, align 1
  %57 = load ptr, ptr %host, align 8
  %c_cc64 = getelementptr inbounds %struct.host_termios, ptr %57, i32 0, i32 5
  %arrayidx65 = getelementptr [19 x i8], ptr %c_cc64, i64 0, i64 13
  %58 = load i8, ptr %arrayidx65, align 1
  %59 = load ptr, ptr %target, align 8
  %c_cc66 = getelementptr inbounds %struct.target_termios, ptr %59, i32 0, i32 5
  %arrayidx67 = getelementptr [19 x i8], ptr %c_cc66, i64 0, i64 13
  store i8 %58, ptr %arrayidx67, align 1
  %60 = load ptr, ptr %host, align 8
  %c_cc68 = getelementptr inbounds %struct.host_termios, ptr %60, i32 0, i32 5
  %arrayidx69 = getelementptr [19 x i8], ptr %c_cc68, i64 0, i64 14
  %61 = load i8, ptr %arrayidx69, align 1
  %62 = load ptr, ptr %target, align 8
  %c_cc70 = getelementptr inbounds %struct.target_termios, ptr %62, i32 0, i32 5
  %arrayidx71 = getelementptr [19 x i8], ptr %c_cc70, i64 0, i64 14
  store i8 %61, ptr %arrayidx71, align 1
  %63 = load ptr, ptr %host, align 8
  %c_cc72 = getelementptr inbounds %struct.host_termios, ptr %63, i32 0, i32 5
  %arrayidx73 = getelementptr [19 x i8], ptr %c_cc72, i64 0, i64 15
  %64 = load i8, ptr %arrayidx73, align 1
  %65 = load ptr, ptr %target, align 8
  %c_cc74 = getelementptr inbounds %struct.target_termios, ptr %65, i32 0, i32 5
  %arrayidx75 = getelementptr [19 x i8], ptr %c_cc74, i64 0, i64 15
  store i8 %64, ptr %arrayidx75, align 1
  %66 = load ptr, ptr %host, align 8
  %c_cc76 = getelementptr inbounds %struct.host_termios, ptr %66, i32 0, i32 5
  %arrayidx77 = getelementptr [19 x i8], ptr %c_cc76, i64 0, i64 16
  %67 = load i8, ptr %arrayidx77, align 1
  %68 = load ptr, ptr %target, align 8
  %c_cc78 = getelementptr inbounds %struct.target_termios, ptr %68, i32 0, i32 5
  %arrayidx79 = getelementptr [19 x i8], ptr %c_cc78, i64 0, i64 16
  store i8 %67, ptr %arrayidx79, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @target_to_host_termios(ptr noundef %dst, ptr noundef %src) #0 {
entry:
  %dst.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %host = alloca ptr, align 8
  %target = alloca ptr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  store ptr %0, ptr %host, align 8
  %1 = load ptr, ptr %src.addr, align 8
  store ptr %1, ptr %target, align 8
  %2 = load ptr, ptr %target, align 8
  %c_iflag = getelementptr inbounds %struct.target_termios, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %c_iflag, align 4
  %call = call i32 @tswap32(i32 noundef %3)
  %call1 = call i32 @target_to_host_bitmask_len(i32 noundef %call, ptr noundef @iflag_tbl, i64 noundef 15)
  %4 = load ptr, ptr %host, align 8
  %c_iflag2 = getelementptr inbounds %struct.host_termios, ptr %4, i32 0, i32 0
  store i32 %call1, ptr %c_iflag2, align 4
  %5 = load ptr, ptr %target, align 8
  %c_oflag = getelementptr inbounds %struct.target_termios, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %c_oflag, align 4
  %call3 = call i32 @tswap32(i32 noundef %6)
  %call4 = call i32 @target_to_host_bitmask_len(i32 noundef %call3, ptr noundef @oflag_tbl, i64 noundef 24)
  %7 = load ptr, ptr %host, align 8
  %c_oflag5 = getelementptr inbounds %struct.host_termios, ptr %7, i32 0, i32 1
  store i32 %call4, ptr %c_oflag5, align 4
  %8 = load ptr, ptr %target, align 8
  %c_cflag = getelementptr inbounds %struct.target_termios, ptr %8, i32 0, i32 2
  %9 = load i32, ptr %c_cflag, align 4
  %call6 = call i32 @tswap32(i32 noundef %9)
  %call7 = call i32 @target_to_host_bitmask_len(i32 noundef %call6, ptr noundef @cflag_tbl, i64 noundef 31)
  %10 = load ptr, ptr %host, align 8
  %c_cflag8 = getelementptr inbounds %struct.host_termios, ptr %10, i32 0, i32 2
  store i32 %call7, ptr %c_cflag8, align 4
  %11 = load ptr, ptr %target, align 8
  %c_lflag = getelementptr inbounds %struct.target_termios, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %c_lflag, align 4
  %call9 = call i32 @tswap32(i32 noundef %12)
  %call10 = call i32 @target_to_host_bitmask_len(i32 noundef %call9, ptr noundef @lflag_tbl, i64 noundef 16)
  %13 = load ptr, ptr %host, align 8
  %c_lflag11 = getelementptr inbounds %struct.host_termios, ptr %13, i32 0, i32 3
  store i32 %call10, ptr %c_lflag11, align 4
  %14 = load ptr, ptr %target, align 8
  %c_line = getelementptr inbounds %struct.target_termios, ptr %14, i32 0, i32 4
  %15 = load i8, ptr %c_line, align 4
  %16 = load ptr, ptr %host, align 8
  %c_line12 = getelementptr inbounds %struct.host_termios, ptr %16, i32 0, i32 4
  store i8 %15, ptr %c_line12, align 4
  %17 = load ptr, ptr %host, align 8
  %c_cc = getelementptr inbounds %struct.host_termios, ptr %17, i32 0, i32 5
  %arraydecay = getelementptr inbounds [19 x i8], ptr %c_cc, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 1 %arraydecay, i8 0, i64 19, i1 false)
  %18 = load ptr, ptr %target, align 8
  %c_cc13 = getelementptr inbounds %struct.target_termios, ptr %18, i32 0, i32 5
  %arrayidx = getelementptr [19 x i8], ptr %c_cc13, i64 0, i64 0
  %19 = load i8, ptr %arrayidx, align 1
  %20 = load ptr, ptr %host, align 8
  %c_cc14 = getelementptr inbounds %struct.host_termios, ptr %20, i32 0, i32 5
  %arrayidx15 = getelementptr [19 x i8], ptr %c_cc14, i64 0, i64 0
  store i8 %19, ptr %arrayidx15, align 1
  %21 = load ptr, ptr %target, align 8
  %c_cc16 = getelementptr inbounds %struct.target_termios, ptr %21, i32 0, i32 5
  %arrayidx17 = getelementptr [19 x i8], ptr %c_cc16, i64 0, i64 1
  %22 = load i8, ptr %arrayidx17, align 1
  %23 = load ptr, ptr %host, align 8
  %c_cc18 = getelementptr inbounds %struct.host_termios, ptr %23, i32 0, i32 5
  %arrayidx19 = getelementptr [19 x i8], ptr %c_cc18, i64 0, i64 1
  store i8 %22, ptr %arrayidx19, align 1
  %24 = load ptr, ptr %target, align 8
  %c_cc20 = getelementptr inbounds %struct.target_termios, ptr %24, i32 0, i32 5
  %arrayidx21 = getelementptr [19 x i8], ptr %c_cc20, i64 0, i64 2
  %25 = load i8, ptr %arrayidx21, align 1
  %26 = load ptr, ptr %host, align 8
  %c_cc22 = getelementptr inbounds %struct.host_termios, ptr %26, i32 0, i32 5
  %arrayidx23 = getelementptr [19 x i8], ptr %c_cc22, i64 0, i64 2
  store i8 %25, ptr %arrayidx23, align 1
  %27 = load ptr, ptr %target, align 8
  %c_cc24 = getelementptr inbounds %struct.target_termios, ptr %27, i32 0, i32 5
  %arrayidx25 = getelementptr [19 x i8], ptr %c_cc24, i64 0, i64 3
  %28 = load i8, ptr %arrayidx25, align 1
  %29 = load ptr, ptr %host, align 8
  %c_cc26 = getelementptr inbounds %struct.host_termios, ptr %29, i32 0, i32 5
  %arrayidx27 = getelementptr [19 x i8], ptr %c_cc26, i64 0, i64 3
  store i8 %28, ptr %arrayidx27, align 1
  %30 = load ptr, ptr %target, align 8
  %c_cc28 = getelementptr inbounds %struct.target_termios, ptr %30, i32 0, i32 5
  %arrayidx29 = getelementptr [19 x i8], ptr %c_cc28, i64 0, i64 4
  %31 = load i8, ptr %arrayidx29, align 1
  %32 = load ptr, ptr %host, align 8
  %c_cc30 = getelementptr inbounds %struct.host_termios, ptr %32, i32 0, i32 5
  %arrayidx31 = getelementptr [19 x i8], ptr %c_cc30, i64 0, i64 4
  store i8 %31, ptr %arrayidx31, align 1
  %33 = load ptr, ptr %target, align 8
  %c_cc32 = getelementptr inbounds %struct.target_termios, ptr %33, i32 0, i32 5
  %arrayidx33 = getelementptr [19 x i8], ptr %c_cc32, i64 0, i64 5
  %34 = load i8, ptr %arrayidx33, align 1
  %35 = load ptr, ptr %host, align 8
  %c_cc34 = getelementptr inbounds %struct.host_termios, ptr %35, i32 0, i32 5
  %arrayidx35 = getelementptr [19 x i8], ptr %c_cc34, i64 0, i64 5
  store i8 %34, ptr %arrayidx35, align 1
  %36 = load ptr, ptr %target, align 8
  %c_cc36 = getelementptr inbounds %struct.target_termios, ptr %36, i32 0, i32 5
  %arrayidx37 = getelementptr [19 x i8], ptr %c_cc36, i64 0, i64 6
  %37 = load i8, ptr %arrayidx37, align 1
  %38 = load ptr, ptr %host, align 8
  %c_cc38 = getelementptr inbounds %struct.host_termios, ptr %38, i32 0, i32 5
  %arrayidx39 = getelementptr [19 x i8], ptr %c_cc38, i64 0, i64 6
  store i8 %37, ptr %arrayidx39, align 1
  %39 = load ptr, ptr %target, align 8
  %c_cc40 = getelementptr inbounds %struct.target_termios, ptr %39, i32 0, i32 5
  %arrayidx41 = getelementptr [19 x i8], ptr %c_cc40, i64 0, i64 7
  %40 = load i8, ptr %arrayidx41, align 1
  %41 = load ptr, ptr %host, align 8
  %c_cc42 = getelementptr inbounds %struct.host_termios, ptr %41, i32 0, i32 5
  %arrayidx43 = getelementptr [19 x i8], ptr %c_cc42, i64 0, i64 7
  store i8 %40, ptr %arrayidx43, align 1
  %42 = load ptr, ptr %target, align 8
  %c_cc44 = getelementptr inbounds %struct.target_termios, ptr %42, i32 0, i32 5
  %arrayidx45 = getelementptr [19 x i8], ptr %c_cc44, i64 0, i64 8
  %43 = load i8, ptr %arrayidx45, align 1
  %44 = load ptr, ptr %host, align 8
  %c_cc46 = getelementptr inbounds %struct.host_termios, ptr %44, i32 0, i32 5
  %arrayidx47 = getelementptr [19 x i8], ptr %c_cc46, i64 0, i64 8
  store i8 %43, ptr %arrayidx47, align 1
  %45 = load ptr, ptr %target, align 8
  %c_cc48 = getelementptr inbounds %struct.target_termios, ptr %45, i32 0, i32 5
  %arrayidx49 = getelementptr [19 x i8], ptr %c_cc48, i64 0, i64 9
  %46 = load i8, ptr %arrayidx49, align 1
  %47 = load ptr, ptr %host, align 8
  %c_cc50 = getelementptr inbounds %struct.host_termios, ptr %47, i32 0, i32 5
  %arrayidx51 = getelementptr [19 x i8], ptr %c_cc50, i64 0, i64 9
  store i8 %46, ptr %arrayidx51, align 1
  %48 = load ptr, ptr %target, align 8
  %c_cc52 = getelementptr inbounds %struct.target_termios, ptr %48, i32 0, i32 5
  %arrayidx53 = getelementptr [19 x i8], ptr %c_cc52, i64 0, i64 10
  %49 = load i8, ptr %arrayidx53, align 1
  %50 = load ptr, ptr %host, align 8
  %c_cc54 = getelementptr inbounds %struct.host_termios, ptr %50, i32 0, i32 5
  %arrayidx55 = getelementptr [19 x i8], ptr %c_cc54, i64 0, i64 10
  store i8 %49, ptr %arrayidx55, align 1
  %51 = load ptr, ptr %target, align 8
  %c_cc56 = getelementptr inbounds %struct.target_termios, ptr %51, i32 0, i32 5
  %arrayidx57 = getelementptr [19 x i8], ptr %c_cc56, i64 0, i64 11
  %52 = load i8, ptr %arrayidx57, align 1
  %53 = load ptr, ptr %host, align 8
  %c_cc58 = getelementptr inbounds %struct.host_termios, ptr %53, i32 0, i32 5
  %arrayidx59 = getelementptr [19 x i8], ptr %c_cc58, i64 0, i64 11
  store i8 %52, ptr %arrayidx59, align 1
  %54 = load ptr, ptr %target, align 8
  %c_cc60 = getelementptr inbounds %struct.target_termios, ptr %54, i32 0, i32 5
  %arrayidx61 = getelementptr [19 x i8], ptr %c_cc60, i64 0, i64 12
  %55 = load i8, ptr %arrayidx61, align 1
  %56 = load ptr, ptr %host, align 8
  %c_cc62 = getelementptr inbounds %struct.host_termios, ptr %56, i32 0, i32 5
  %arrayidx63 = getelementptr [19 x i8], ptr %c_cc62, i64 0, i64 12
  store i8 %55, ptr %arrayidx63, align 1
  %57 = load ptr, ptr %target, align 8
  %c_cc64 = getelementptr inbounds %struct.target_termios, ptr %57, i32 0, i32 5
  %arrayidx65 = getelementptr [19 x i8], ptr %c_cc64, i64 0, i64 13
  %58 = load i8, ptr %arrayidx65, align 1
  %59 = load ptr, ptr %host, align 8
  %c_cc66 = getelementptr inbounds %struct.host_termios, ptr %59, i32 0, i32 5
  %arrayidx67 = getelementptr [19 x i8], ptr %c_cc66, i64 0, i64 13
  store i8 %58, ptr %arrayidx67, align 1
  %60 = load ptr, ptr %target, align 8
  %c_cc68 = getelementptr inbounds %struct.target_termios, ptr %60, i32 0, i32 5
  %arrayidx69 = getelementptr [19 x i8], ptr %c_cc68, i64 0, i64 14
  %61 = load i8, ptr %arrayidx69, align 1
  %62 = load ptr, ptr %host, align 8
  %c_cc70 = getelementptr inbounds %struct.host_termios, ptr %62, i32 0, i32 5
  %arrayidx71 = getelementptr [19 x i8], ptr %c_cc70, i64 0, i64 14
  store i8 %61, ptr %arrayidx71, align 1
  %63 = load ptr, ptr %target, align 8
  %c_cc72 = getelementptr inbounds %struct.target_termios, ptr %63, i32 0, i32 5
  %arrayidx73 = getelementptr [19 x i8], ptr %c_cc72, i64 0, i64 15
  %64 = load i8, ptr %arrayidx73, align 1
  %65 = load ptr, ptr %host, align 8
  %c_cc74 = getelementptr inbounds %struct.host_termios, ptr %65, i32 0, i32 5
  %arrayidx75 = getelementptr [19 x i8], ptr %c_cc74, i64 0, i64 15
  store i8 %64, ptr %arrayidx75, align 1
  %66 = load ptr, ptr %target, align 8
  %c_cc76 = getelementptr inbounds %struct.target_termios, ptr %66, i32 0, i32 5
  %arrayidx77 = getelementptr [19 x i8], ptr %c_cc76, i64 0, i64 16
  %67 = load i8, ptr %arrayidx77, align 1
  %68 = load ptr, ptr %host, align 8
  %c_cc78 = getelementptr inbounds %struct.host_termios, ptr %68, i32 0, i32 5
  %arrayidx79 = getelementptr [19 x i8], ptr %c_cc78, i64 0, i64 16
  store i8 %67, ptr %arrayidx79, align 1
  ret void
}

declare void @print_termios(ptr noundef) #3

declare i32 @host_to_target_bitmask_len(i32 noundef, ptr noundef, i64 noundef) #3

declare i32 @thunk_type_size_array(ptr noundef, i32 noundef) #3

; Function Attrs: noreturn
declare void @g_assertion_message_expr(ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) #11

declare void @cpu_dump_state(ptr noundef, ptr noundef, i32 noundef) #3

; Function Attrs: nounwind
declare i32 @fileno(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @open_self_maps_1(ptr noundef %env, i32 noundef %fd, i1 noundef zeroext %smaps) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %smaps.addr = alloca i8, align 1
  %d = alloca %struct.open_self_maps_data, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %frombool = zext i1 %smaps to i8
  store i8 %frombool, ptr %smaps.addr, align 1
  %ts = getelementptr inbounds %struct.open_self_maps_data, ptr %d, i32 0, i32 0
  %0 = load ptr, ptr %env.addr, align 8
  %call = call ptr @env_cpu(ptr noundef %0)
  %opaque = getelementptr inbounds %struct.CPUState, ptr %call, i32 0, i32 39
  %1 = load ptr, ptr %opaque, align 16
  store ptr %1, ptr %ts, align 8
  %host_maps = getelementptr inbounds %struct.open_self_maps_data, ptr %d, i32 0, i32 1
  %call1 = call ptr @read_self_maps()
  store ptr %call1, ptr %host_maps, align 8
  %fd2 = getelementptr inbounds %struct.open_self_maps_data, ptr %d, i32 0, i32 2
  %2 = load i32, ptr %fd.addr, align 4
  store i32 %2, ptr %fd2, align 8
  %smaps3 = getelementptr inbounds %struct.open_self_maps_data, ptr %d, i32 0, i32 3
  %3 = load i8, ptr %smaps.addr, align 1
  %tobool = trunc i8 %3 to i1
  %frombool4 = zext i1 %tobool to i8
  store i8 %frombool4, ptr %smaps3, align 4
  %host_maps5 = getelementptr inbounds %struct.open_self_maps_data, ptr %d, i32 0, i32 1
  %4 = load ptr, ptr %host_maps5, align 8
  %tobool6 = icmp ne ptr %4, null
  br i1 %tobool6, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call7 = call i32 @walk_memory_regions(ptr noundef %d, ptr noundef @open_self_maps_2)
  %host_maps8 = getelementptr inbounds %struct.open_self_maps_data, ptr %d, i32 0, i32 1
  %5 = load ptr, ptr %host_maps8, align 8
  call void @free_self_maps(ptr noundef %5)
  br label %if.end

if.else:                                          ; preds = %entry
  %call9 = call i32 @walk_memory_regions(ptr noundef %d, ptr noundef @open_self_maps_3)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret i32 0
}

declare ptr @read_self_maps() #3

declare i32 @walk_memory_regions(ptr noundef, ptr noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @open_self_maps_2(ptr noundef %opaque, i64 noundef %guest_start, i64 noundef %guest_end, i64 noundef %flags) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %guest_start.addr = alloca i64, align 8
  %guest_end.addr = alloca i64, align 8
  %flags.addr = alloca i64, align 8
  %d = alloca ptr, align 8
  %host_start = alloca i64, align 8
  %host_last = alloca i64, align 8
  %n = alloca ptr, align 8
  %mi = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %this_hlast = alloca i64, align 8
  %_a20 = alloca i64, align 8
  %_b21 = alloca i64, align 8
  %tmp3 = alloca i64, align 8
  %this_gend = alloca i64, align 8
  %tmp10 = alloca i64, align 8
  %__ret = alloca i64, align 8
  %tmp12 = alloca i64, align 8
  %tmp29 = alloca i64, align 8
  %__ret30 = alloca i64, align 8
  %tmp32 = alloca i64, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i64 %guest_start, ptr %guest_start.addr, align 8
  store i64 %guest_end, ptr %guest_end.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %d, align 8
  %1 = load i64, ptr %guest_start.addr, align 8
  %call = call ptr @g2h_untagged(i64 noundef %1)
  %2 = ptrtoint ptr %call to i64
  store i64 %2, ptr %host_start, align 8
  %3 = load i64, ptr %guest_end.addr, align 8
  %sub = sub i64 %3, 1
  %call1 = call ptr @g2h_untagged(i64 noundef %sub)
  %4 = ptrtoint ptr %call1 to i64
  store i64 %4, ptr %host_last, align 8
  br label %while.body

while.body:                                       ; preds = %if.end28, %entry
  %5 = load ptr, ptr %d, align 8
  %host_maps = getelementptr inbounds %struct.open_self_maps_data, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %host_maps, align 8
  %7 = load i64, ptr %host_start, align 8
  %8 = load i64, ptr %host_start, align 8
  %call2 = call ptr @interval_tree_iter_first(ptr noundef %6, i64 noundef %7, i64 noundef %8)
  store ptr %call2, ptr %n, align 8
  %9 = load ptr, ptr %n, align 8
  store ptr %9, ptr %__mptr, align 8
  %10 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %10, i64 0
  store ptr %add.ptr, ptr %tmp, align 8
  %11 = load ptr, ptr %tmp, align 8
  store ptr %11, ptr %mi, align 8
  %12 = load i64, ptr %host_last, align 8
  store i64 %12, ptr %_a20, align 8
  %13 = load ptr, ptr %n, align 8
  %last = getelementptr inbounds %struct.IntervalTreeNode, ptr %13, i32 0, i32 2
  %14 = load i64, ptr %last, align 8
  store i64 %14, ptr %_b21, align 8
  %15 = load i64, ptr %_a20, align 8
  %16 = load i64, ptr %_b21, align 8
  %cmp = icmp ult i64 %15, %16
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body
  %17 = load i64, ptr %_a20, align 8
  br label %cond.end

cond.false:                                       ; preds = %while.body
  %18 = load i64, ptr %_b21, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %17, %cond.true ], [ %18, %cond.false ]
  store i64 %cond, ptr %tmp3, align 8
  %19 = load i64, ptr %tmp3, align 8
  store i64 %19, ptr %this_hlast, align 8
  %20 = load i64, ptr %this_hlast, align 8
  %21 = load i64, ptr @guest_base, align 8
  %sub4 = sub i64 %20, %21
  %22 = load i64, ptr @reserved_va, align 8
  %tobool = icmp ne i64 %22, 0
  br i1 %tobool, label %cond.true5, label %cond.false6

cond.true5:                                       ; preds = %cond.end
  br label %cond.end7

cond.false6:                                      ; preds = %cond.end
  br label %cond.end7

cond.end7:                                        ; preds = %cond.false6, %cond.true5
  %cond8 = phi i64 [ %22, %cond.true5 ], [ -1, %cond.false6 ]
  %cmp9 = icmp ule i64 %sub4, %cond8
  br i1 %cmp9, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end7
  br label %if.end

if.else:                                          ; preds = %cond.end7
  call void @__assert_fail(ptr noundef @.str.594, ptr noundef @.str.579, i32 noundef 8090, ptr noundef @__PRETTY_FUNCTION__.open_self_maps_2) #15
  unreachable

if.end:                                           ; preds = %if.then
  %23 = load i64, ptr %this_hlast, align 8
  %24 = load i64, ptr @guest_base, align 8
  %sub11 = sub i64 %23, %24
  store i64 %sub11, ptr %__ret, align 8
  %25 = load i64, ptr %__ret, align 8
  store i64 %25, ptr %tmp12, align 8
  %26 = load i64, ptr %tmp12, align 8
  store i64 %26, ptr %tmp10, align 8
  %27 = load i64, ptr %tmp10, align 8
  %add = add i64 %27, 1
  store i64 %add, ptr %this_gend, align 8
  %28 = load ptr, ptr %d, align 8
  %29 = load ptr, ptr %mi, align 8
  %30 = load i64, ptr %guest_start.addr, align 8
  %31 = load i64, ptr %this_gend, align 8
  %32 = load i64, ptr %flags.addr, align 8
  %conv = trunc i64 %32 to i32
  call void @open_self_maps_4(ptr noundef %28, ptr noundef %29, i64 noundef %30, i64 noundef %31, i32 noundef %conv)
  %33 = load i64, ptr %this_hlast, align 8
  %34 = load i64, ptr %host_last, align 8
  %cmp13 = icmp eq i64 %33, %34
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end
  ret i32 0

if.end16:                                         ; preds = %if.end
  %35 = load i64, ptr %this_hlast, align 8
  %add17 = add i64 %35, 1
  store i64 %add17, ptr %host_start, align 8
  %36 = load i64, ptr %host_start, align 8
  %37 = load i64, ptr @guest_base, align 8
  %sub18 = sub i64 %36, %37
  %38 = load i64, ptr @reserved_va, align 8
  %tobool19 = icmp ne i64 %38, 0
  br i1 %tobool19, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %if.end16
  br label %cond.end22

cond.false21:                                     ; preds = %if.end16
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false21, %cond.true20
  %cond23 = phi i64 [ %38, %cond.true20 ], [ -1, %cond.false21 ]
  %cmp24 = icmp ule i64 %sub18, %cond23
  br i1 %cmp24, label %if.then26, label %if.else27

if.then26:                                        ; preds = %cond.end22
  br label %if.end28

if.else27:                                        ; preds = %cond.end22
  call void @__assert_fail(ptr noundef @.str.595, ptr noundef @.str.579, i32 noundef 8098, ptr noundef @__PRETTY_FUNCTION__.open_self_maps_2) #15
  unreachable

if.end28:                                         ; preds = %if.then26
  %39 = load i64, ptr %host_start, align 8
  %40 = load i64, ptr @guest_base, align 8
  %sub31 = sub i64 %39, %40
  store i64 %sub31, ptr %__ret30, align 8
  %41 = load i64, ptr %__ret30, align 8
  store i64 %41, ptr %tmp32, align 8
  %42 = load i64, ptr %tmp32, align 8
  store i64 %42, ptr %tmp29, align 8
  %43 = load i64, ptr %tmp29, align 8
  store i64 %43, ptr %guest_start.addr, align 8
  br label %while.body
}

declare void @free_self_maps(ptr noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @open_self_maps_3(ptr noundef %opaque, i64 noundef %guest_start, i64 noundef %guest_end, i64 noundef %flags) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %guest_start.addr = alloca i64, align 8
  %guest_end.addr = alloca i64, align 8
  %flags.addr = alloca i64, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i64 %guest_start, ptr %guest_start.addr, align 8
  store i64 %guest_end, ptr %guest_end.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  %1 = load i64, ptr %guest_start.addr, align 8
  %2 = load i64, ptr %guest_end.addr, align 8
  %3 = load i64, ptr %flags.addr, align 8
  %conv = trunc i64 %3 to i32
  call void @open_self_maps_4(ptr noundef %0, ptr noundef @open_self_maps_3.mi, i64 noundef %1, i64 noundef %2, i32 noundef %conv)
  ret i32 0
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @g2h_untagged(i64 noundef %x) #0 {
entry:
  %x.addr = alloca i64, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load i64, ptr %x.addr, align 8
  %1 = load i64, ptr @guest_base, align 8
  %add = add i64 %0, %1
  %2 = inttoptr i64 %add to ptr
  ret ptr %2
}

declare ptr @interval_tree_iter_first(ptr noundef, i64 noundef, i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal void @open_self_maps_4(ptr noundef %d, ptr noundef %mi, i64 noundef %start, i64 noundef %end, i32 noundef %flags) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %mi.addr = alloca ptr, align 8
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %info = alloca ptr, align 8
  %path = alloca ptr, align 8
  %offset = alloca i64, align 8
  %fd = alloca i32, align 4
  %count = alloca i32, align 4
  %hstart = alloca i64, align 8
  %size = alloca i64, align 8
  %page_size_kb = alloca i64, align 8
  %size_kb = alloca i64, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %mi, ptr %mi.addr, align 8
  store i64 %start, ptr %start.addr, align 8
  store i64 %end, ptr %end.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %d.addr, align 8
  %ts = getelementptr inbounds %struct.open_self_maps_data, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %ts, align 8
  %info1 = getelementptr inbounds %struct.TaskState, ptr %1, i32 0, i32 7
  %2 = load ptr, ptr %info1, align 8
  store ptr %2, ptr %info, align 8
  %3 = load ptr, ptr %mi.addr, align 8
  %path2 = getelementptr inbounds %struct.MapInfo, ptr %3, i32 0, i32 8
  %4 = load ptr, ptr %path2, align 8
  store ptr %4, ptr %path, align 8
  %5 = load ptr, ptr %d.addr, align 8
  %fd3 = getelementptr inbounds %struct.open_self_maps_data, ptr %5, i32 0, i32 2
  %6 = load i32, ptr %fd3, align 8
  store i32 %6, ptr %fd, align 4
  %7 = load i64, ptr %start.addr, align 8
  %8 = load ptr, ptr %info, align 8
  %stack_limit = getelementptr inbounds %struct.image_info, ptr %8, i32 0, i32 8
  %9 = load i64, ptr %stack_limit, align 8
  %cmp = icmp eq i64 %7, %9
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr @.str.596, ptr %path, align 8
  br label %if.end10

if.else:                                          ; preds = %entry
  %10 = load i64, ptr %start.addr, align 8
  %11 = load ptr, ptr %info, align 8
  %brk = getelementptr inbounds %struct.image_info, ptr %11, i32 0, i32 6
  %12 = load i64, ptr %brk, align 8
  %cmp4 = icmp eq i64 %10, %12
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  store ptr @.str.597, ptr %path, align 8
  br label %if.end9

if.else6:                                         ; preds = %if.else
  %13 = load i64, ptr %start.addr, align 8
  %14 = load ptr, ptr %info, align 8
  %vdso = getelementptr inbounds %struct.image_info, ptr %14, i32 0, i32 9
  %15 = load i64, ptr %vdso, align 8
  %cmp7 = icmp eq i64 %13, %15
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else6
  store ptr @.str.598, ptr %path, align 8
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.else6
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then5
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.then
  %16 = load ptr, ptr %mi.addr, align 8
  %offset11 = getelementptr inbounds %struct.MapInfo, ptr %16, i32 0, i32 7
  %17 = load i64, ptr %offset11, align 8
  store i64 %17, ptr %offset, align 8
  %18 = load ptr, ptr %mi.addr, align 8
  %dev = getelementptr inbounds %struct.MapInfo, ptr %18, i32 0, i32 5
  %19 = load i64, ptr %dev, align 8
  %tobool = icmp ne i64 %19, 0
  br i1 %tobool, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %20 = load i64, ptr %start.addr, align 8
  %call = call ptr @g2h_untagged(i64 noundef %20)
  %21 = ptrtoint ptr %call to i64
  store i64 %21, ptr %hstart, align 8
  %22 = load i64, ptr %hstart, align 8
  %23 = load ptr, ptr %mi.addr, align 8
  %itree = getelementptr inbounds %struct.MapInfo, ptr %23, i32 0, i32 0
  %start13 = getelementptr inbounds %struct.IntervalTreeNode, ptr %itree, i32 0, i32 1
  %24 = load i64, ptr %start13, align 8
  %sub = sub i64 %22, %24
  %25 = load i64, ptr %offset, align 8
  %add = add i64 %25, %sub
  store i64 %add, ptr %offset, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  %26 = load i32, ptr %fd, align 4
  %27 = load i64, ptr %start.addr, align 8
  %28 = load i64, ptr %end.addr, align 8
  %29 = load i32, ptr %flags.addr, align 4
  %and = and i32 %29, 1
  %tobool15 = icmp ne i32 %and, 0
  %cond = select i1 %tobool15, i32 114, i32 45
  %30 = load i32, ptr %flags.addr, align 4
  %and16 = and i32 %30, 16
  %tobool17 = icmp ne i32 %and16, 0
  %cond18 = select i1 %tobool17, i32 119, i32 45
  %31 = load i32, ptr %flags.addr, align 4
  %and19 = and i32 %31, 4
  %tobool20 = icmp ne i32 %and19, 0
  %cond21 = select i1 %tobool20, i32 120, i32 45
  %32 = load ptr, ptr %mi.addr, align 8
  %is_priv = getelementptr inbounds %struct.MapInfo, ptr %32, i32 0, i32 4
  %33 = load i8, ptr %is_priv, align 1
  %tobool22 = trunc i8 %33 to i1
  %cond23 = select i1 %tobool22, i32 112, i32 115
  %34 = load i64, ptr %offset, align 8
  %35 = load ptr, ptr %mi.addr, align 8
  %dev24 = getelementptr inbounds %struct.MapInfo, ptr %35, i32 0, i32 5
  %36 = load i64, ptr %dev24, align 8
  %call25 = call i32 @gnu_dev_major(i64 noundef %36) #13
  %37 = load ptr, ptr %mi.addr, align 8
  %dev26 = getelementptr inbounds %struct.MapInfo, ptr %37, i32 0, i32 5
  %38 = load i64, ptr %dev26, align 8
  %call27 = call i32 @gnu_dev_minor(i64 noundef %38) #13
  %39 = load ptr, ptr %mi.addr, align 8
  %inode = getelementptr inbounds %struct.MapInfo, ptr %39, i32 0, i32 6
  %40 = load i64, ptr %inode, align 8
  %call28 = call i32 (i32, ptr, ...) @dprintf(i32 noundef %26, ptr noundef @.str.599, i64 noundef %27, i64 noundef %28, i32 noundef %cond, i32 noundef %cond18, i32 noundef %cond21, i32 noundef %cond23, i64 noundef %34, i32 noundef %call25, i32 noundef %call27, i64 noundef %40)
  store i32 %call28, ptr %count, align 4
  %41 = load ptr, ptr %path, align 8
  %tobool29 = icmp ne ptr %41, null
  br i1 %tobool29, label %if.then30, label %if.else33

if.then30:                                        ; preds = %if.end14
  %42 = load i32, ptr %fd, align 4
  %43 = load i32, ptr %count, align 4
  %sub31 = sub i32 73, %43
  %44 = load ptr, ptr %path, align 8
  %call32 = call i32 (i32, ptr, ...) @dprintf(i32 noundef %42, ptr noundef @.str.600, i32 noundef %sub31, ptr noundef @.str.601, ptr noundef %44)
  br label %if.end35

if.else33:                                        ; preds = %if.end14
  %45 = load i32, ptr %fd, align 4
  %call34 = call i32 (i32, ptr, ...) @dprintf(i32 noundef %45, ptr noundef @.str.602)
  br label %if.end35

if.end35:                                         ; preds = %if.else33, %if.then30
  %46 = load ptr, ptr %d.addr, align 8
  %smaps = getelementptr inbounds %struct.open_self_maps_data, ptr %46, i32 0, i32 3
  %47 = load i8, ptr %smaps, align 4
  %tobool36 = trunc i8 %47 to i1
  br i1 %tobool36, label %if.then37, label %if.end67

if.then37:                                        ; preds = %if.end35
  %48 = load i64, ptr %end.addr, align 8
  %49 = load i64, ptr %start.addr, align 8
  %sub38 = sub i64 %48, %49
  store i64 %sub38, ptr %size, align 8
  store i64 4, ptr %page_size_kb, align 8
  %50 = load i64, ptr %size, align 8
  %shr = lshr i64 %50, 10
  store i64 %shr, ptr %size_kb, align 8
  %51 = load i32, ptr %fd, align 4
  %52 = load i64, ptr %size_kb, align 8
  %53 = load i64, ptr %page_size_kb, align 8
  %54 = load i64, ptr %page_size_kb, align 8
  %55 = load i32, ptr %flags.addr, align 4
  %and39 = and i32 %55, 128
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then37
  %56 = load i64, ptr %size_kb, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then37
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond41 = phi i64 [ %56, %cond.true ], [ 0, %cond.false ]
  %57 = load i32, ptr %flags.addr, align 4
  %and42 = and i32 %57, 1
  %tobool43 = icmp ne i32 %and42, 0
  %cond44 = select i1 %tobool43, ptr @.str.604, ptr @.str.601
  %58 = load i32, ptr %flags.addr, align 4
  %and45 = and i32 %58, 16
  %tobool46 = icmp ne i32 %and45, 0
  %cond47 = select i1 %tobool46, ptr @.str.605, ptr @.str.601
  %59 = load i32, ptr %flags.addr, align 4
  %and48 = and i32 %59, 4
  %tobool49 = icmp ne i32 %and48, 0
  %cond50 = select i1 %tobool49, ptr @.str.606, ptr @.str.601
  %60 = load ptr, ptr %mi.addr, align 8
  %is_priv51 = getelementptr inbounds %struct.MapInfo, ptr %60, i32 0, i32 4
  %61 = load i8, ptr %is_priv51, align 1
  %tobool52 = trunc i8 %61 to i1
  %cond53 = select i1 %tobool52, ptr @.str.601, ptr @.str.607
  %62 = load i32, ptr %flags.addr, align 4
  %and54 = and i32 %62, 1
  %tobool55 = icmp ne i32 %and54, 0
  %cond56 = select i1 %tobool55, ptr @.str.608, ptr @.str.601
  %63 = load i32, ptr %flags.addr, align 4
  %and57 = and i32 %63, 16
  %tobool58 = icmp ne i32 %and57, 0
  %cond59 = select i1 %tobool58, ptr @.str.609, ptr @.str.601
  %64 = load i32, ptr %flags.addr, align 4
  %and60 = and i32 %64, 4
  %tobool61 = icmp ne i32 %and60, 0
  %cond62 = select i1 %tobool61, ptr @.str.610, ptr @.str.601
  %65 = load ptr, ptr %mi.addr, align 8
  %is_priv63 = getelementptr inbounds %struct.MapInfo, ptr %65, i32 0, i32 4
  %66 = load i8, ptr %is_priv63, align 1
  %tobool64 = trunc i8 %66 to i1
  %cond65 = select i1 %tobool64, ptr @.str.601, ptr @.str.611
  %call66 = call i32 (i32, ptr, ...) @dprintf(i32 noundef %51, ptr noundef @.str.603, i64 noundef %52, i64 noundef %53, i64 noundef %54, i64 noundef %cond41, ptr noundef %cond44, ptr noundef %cond47, ptr noundef %cond50, ptr noundef %cond53, ptr noundef %cond56, ptr noundef %cond59, ptr noundef %cond62, ptr noundef %cond65)
  br label %if.end67

if.end67:                                         ; preds = %cond.end, %if.end35
  ret void
}

declare i32 @dprintf(i32 noundef, ptr noundef, ...) #3

; Function Attrs: nounwind willreturn memory(none)
declare i32 @gnu_dev_major(i64 noundef) #1

; Function Attrs: nounwind willreturn memory(none)
declare i32 @gnu_dev_minor(i64 noundef) #1

; Function Attrs: nounwind
declare i32 @getpid() #2

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcmp(ptr noundef, ptr noundef) #5

declare ptr @g_string_new(ptr noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_cleanup_GString(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %1 = load ptr, ptr %0, align 8
  call void @glib_autoptr_clear_GString(ptr noundef %1)
  ret void
}

declare void @g_string_printf(ptr noundef, ptr noundef, ...) #3

declare ptr @g_strrstr(ptr noundef, ptr noundef) #3

declare ptr @g_string_assign(ptr noundef, ptr noundef) #3

; Function Attrs: nounwind
declare i32 @getppid() #2

declare i64 @write(i32 noundef, ptr noundef, i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_clear_GString(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %_ptr.addr, align 8
  call void @g_autoptr_cleanup_gstring_free(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @g_autoptr_cleanup_gstring_free(ptr noundef %string) #0 {
entry:
  %string.addr = alloca ptr, align 8
  store ptr %string, ptr %string.addr, align 8
  %0 = load ptr, ptr %string.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %string.addr, align 8
  %call = call ptr @g_string_free(ptr noundef %1, i32 noundef 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare ptr @g_string_free(ptr noundef, i32 noundef) #3

; Function Attrs: nounwind
declare i64 @sysconf(i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @env_archcpu(ptr noundef %env) #0 {
entry:
  %env.addr = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %env.addr, align 8
  %add.ptr = getelementptr i8, ptr %0, i64 -10176
  ret ptr %add.ptr
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @riscv_cpu_cfg(ptr noundef %env) #0 {
entry:
  %env.addr = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  %0 = load ptr, ptr %env.addr, align 8
  %call = call ptr @env_archcpu(ptr noundef %0)
  %cfg = getelementptr inbounds %struct.ArchCPU, ptr %call, i32 0, i32 4
  ret ptr %cfg
}

declare ptr @riscv_isa_string(ptr noundef) #3

declare void @qemu_plugin_vcpu_syscall(ptr noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef) #3

declare i32 @block_signals() #3

; Function Attrs: nounwind
declare i32 @pthread_mutex_lock(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @do_sys_futex(ptr noundef %uaddr, i32 noundef %op, i32 noundef %val, ptr noundef %timeout, ptr noundef %uaddr2, i32 noundef %val3) #0 {
entry:
  %uaddr.addr = alloca ptr, align 8
  %op.addr = alloca i32, align 4
  %val.addr = alloca i32, align 4
  %timeout.addr = alloca ptr, align 8
  %uaddr2.addr = alloca ptr, align 8
  %val3.addr = alloca i32, align 4
  store ptr %uaddr, ptr %uaddr.addr, align 8
  store i32 %op, ptr %op.addr, align 4
  store i32 %val, ptr %val.addr, align 4
  store ptr %timeout, ptr %timeout.addr, align 8
  store ptr %uaddr2, ptr %uaddr2.addr, align 8
  store i32 %val3, ptr %val3.addr, align 4
  %0 = load ptr, ptr %uaddr.addr, align 8
  %1 = load i32, ptr %op.addr, align 4
  %2 = load i32, ptr %val.addr, align 4
  %3 = load ptr, ptr %timeout.addr, align 8
  %4 = load ptr, ptr %uaddr2.addr, align 8
  %5 = load i32, ptr %val3.addr, align 4
  %call = call i32 @sys_futex(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @g2h(ptr noundef %cs, i64 noundef %x) #0 {
entry:
  %cs.addr = alloca ptr, align 8
  %x.addr = alloca i64, align 8
  store ptr %cs, ptr %cs.addr, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %cs.addr, align 8
  %1 = load i64, ptr %x.addr, align 8
  %call = call i64 @cpu_untagged_addr(ptr noundef %0, i64 noundef %1)
  %call1 = call ptr @g2h_untagged(i64 noundef %call)
  ret ptr %call1
}

declare void @object_unparent(ptr noundef) #3

declare void @object_unref(ptr noundef) #3

; Function Attrs: nounwind
declare i32 @pthread_mutex_unlock(ptr noundef) #2

declare void @rcu_unregister_thread() #3

; Function Attrs: noreturn
declare void @pthread_exit(ptr noundef) #11

declare void @preexit_cleanup(ptr noundef, i32 noundef) #3

; Function Attrs: noreturn
declare void @_exit(i32 noundef) #11

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @safe_read(i32 noundef %fd, ptr noundef %buff, i64 noundef %count) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %buff.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %buff, ptr %buff.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %buff.addr, align 8
  %5 = load i64, ptr %count.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 0, i32 noundef %3, ptr noundef %4, i64 noundef %5)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @fd_trans_host_to_target_data(i32 noundef %fd) #0 {
entry:
  %x.addr.i = alloca ptr, align 8
  %lockable.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %qemu_lockable_auto1 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.QemuLockable, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %object = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 0
  store ptr @target_fd_trans_lock, ptr %object, align 8
  %lock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 1
  store ptr @qemu_mutex_lock, ptr %lock, align 8
  %unlock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 2
  store ptr @qemu_mutex_unlock, ptr %unlock, align 8
  store ptr @target_fd_trans_lock, ptr %x.addr.i, align 8
  store ptr %.compoundliteral, ptr %lockable.addr.i, align 8
  %1 = load ptr, ptr %x.addr.i, align 8
  %tobool.i = icmp ne ptr %1, null
  br i1 %tobool.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %if.end
  %2 = load ptr, ptr %lockable.addr.i, align 8
  br label %qemu_make_lockable.exit

cond.false.i:                                     ; preds = %if.end
  br label %qemu_make_lockable.exit

qemu_make_lockable.exit:                          ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi ptr [ %2, %cond.true.i ], [ null, %cond.false.i ]
  %call1 = call ptr @qemu_lockable_auto_lock(ptr noundef %cond.i)
  store ptr %call1, ptr %qemu_lockable_auto1, align 8
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load i32, ptr @target_fd_max, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %qemu_make_lockable.exit
  %5 = load ptr, ptr @target_fd_trans, align 8
  %6 = load i32, ptr %fd.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr ptr, ptr %5, i64 %idxprom
  %7 = load ptr, ptr %arrayidx, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %if.then3, label %if.end6

if.then3:                                         ; preds = %land.lhs.true
  %8 = load ptr, ptr @target_fd_trans, align 8
  %9 = load i32, ptr %fd.addr, align 4
  %idxprom4 = sext i32 %9 to i64
  %arrayidx5 = getelementptr ptr, ptr %8, i64 %idxprom4
  %10 = load ptr, ptr %arrayidx5, align 8
  %host_to_target_data = getelementptr inbounds %struct.TargetFdTrans, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %host_to_target_data, align 8
  store ptr %11, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end6:                                          ; preds = %land.lhs.true, %qemu_make_lockable.exit
  store ptr null, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.then3
  call void @glib_autoptr_cleanup_QemuLockable(ptr noundef %qemu_lockable_auto1)
  br label %return

return:                                           ; preds = %cleanup, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @safe_write(i32 noundef %fd, ptr noundef %buff, i64 noundef %count) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %buff.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %buff, ptr %buff.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %buff.addr, align 8
  %5 = load i64, ptr %count.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 1, i32 noundef %3, ptr noundef %4, i64 noundef %5)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @fd_trans_target_to_host_data(i32 noundef %fd) #0 {
entry:
  %x.addr.i = alloca ptr, align 8
  %lockable.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %qemu_lockable_auto0 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.QemuLockable, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %object = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 0
  store ptr @target_fd_trans_lock, ptr %object, align 8
  %lock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 1
  store ptr @qemu_mutex_lock, ptr %lock, align 8
  %unlock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 2
  store ptr @qemu_mutex_unlock, ptr %unlock, align 8
  store ptr @target_fd_trans_lock, ptr %x.addr.i, align 8
  store ptr %.compoundliteral, ptr %lockable.addr.i, align 8
  %1 = load ptr, ptr %x.addr.i, align 8
  %tobool.i = icmp ne ptr %1, null
  br i1 %tobool.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %if.end
  %2 = load ptr, ptr %lockable.addr.i, align 8
  br label %qemu_make_lockable.exit

cond.false.i:                                     ; preds = %if.end
  br label %qemu_make_lockable.exit

qemu_make_lockable.exit:                          ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi ptr [ %2, %cond.true.i ], [ null, %cond.false.i ]
  %call1 = call ptr @qemu_lockable_auto_lock(ptr noundef %cond.i)
  store ptr %call1, ptr %qemu_lockable_auto0, align 8
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load i32, ptr @target_fd_max, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %qemu_make_lockable.exit
  %5 = load ptr, ptr @target_fd_trans, align 8
  %6 = load i32, ptr %fd.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr ptr, ptr %5, i64 %idxprom
  %7 = load ptr, ptr %arrayidx, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %if.then3, label %if.end6

if.then3:                                         ; preds = %land.lhs.true
  %8 = load ptr, ptr @target_fd_trans, align 8
  %9 = load i32, ptr %fd.addr, align 4
  %idxprom4 = sext i32 %9 to i64
  %arrayidx5 = getelementptr ptr, ptr %8, i64 %idxprom4
  %10 = load ptr, ptr %arrayidx5, align 8
  %target_to_host_data = getelementptr inbounds %struct.TargetFdTrans, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %target_to_host_data, align 8
  store ptr %11, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end6:                                          ; preds = %land.lhs.true, %qemu_make_lockable.exit
  store ptr null, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.then3
  call void @glib_autoptr_cleanup_QemuLockable(ptr noundef %qemu_lockable_auto0)
  br label %return

return:                                           ; preds = %cleanup, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: allocsize(0)
declare noalias ptr @g_malloc(i64 noundef) #8

; Function Attrs: nounwind sspstrong uwtable
define internal void @fd_trans_unregister(i32 noundef %fd) #0 {
entry:
  %x.addr.i = alloca ptr, align 8
  %lockable.addr.i = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %qemu_lockable_auto4 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.QemuLockable, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %object = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 0
  store ptr @target_fd_trans_lock, ptr %object, align 8
  %lock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 1
  store ptr @qemu_mutex_lock, ptr %lock, align 8
  %unlock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 2
  store ptr @qemu_mutex_unlock, ptr %unlock, align 8
  store ptr @target_fd_trans_lock, ptr %x.addr.i, align 8
  store ptr %.compoundliteral, ptr %lockable.addr.i, align 8
  %1 = load ptr, ptr %x.addr.i, align 8
  %tobool.i = icmp ne ptr %1, null
  br i1 %tobool.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %if.end
  %2 = load ptr, ptr %lockable.addr.i, align 8
  br label %qemu_make_lockable.exit

cond.false.i:                                     ; preds = %if.end
  br label %qemu_make_lockable.exit

qemu_make_lockable.exit:                          ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi ptr [ %2, %cond.true.i ], [ null, %cond.false.i ]
  %call1 = call ptr @qemu_lockable_auto_lock(ptr noundef %cond.i)
  store ptr %call1, ptr %qemu_lockable_auto4, align 8
  %3 = load i32, ptr %fd.addr, align 4
  call void @internal_fd_trans_unregister_unsafe(i32 noundef %3)
  call void @glib_autoptr_cleanup_QemuLockable(ptr noundef %qemu_lockable_auto4)
  br label %return

return:                                           ; preds = %qemu_make_lockable.exit, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_name_to_handle_at(i64 noundef %dirfd, i64 noundef %pathname, i64 noundef %handle, i64 noundef %mount_id, i64 noundef %flags) #0 {
entry:
  %retval = alloca i64, align 8
  %dirfd.addr = alloca i64, align 8
  %pathname.addr = alloca i64, align 8
  %handle.addr = alloca i64, align 8
  %mount_id.addr = alloca i64, align 8
  %flags.addr = alloca i64, align 8
  %target_fh = alloca ptr, align 8
  %fh = alloca ptr, align 8
  %mid = alloca i32, align 4
  %ret = alloca i64, align 8
  %name = alloca ptr, align 8
  %size = alloca i32, align 4
  %total_size = alloca i32, align 4
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__gaddr30 = alloca i64, align 8
  %__hptr31 = alloca ptr, align 8
  %__ret32 = alloca i64, align 8
  %tmp40 = alloca i64, align 8
  store i64 %dirfd, ptr %dirfd.addr, align 8
  store i64 %pathname, ptr %pathname.addr, align 8
  store i64 %handle, ptr %handle.addr, align 8
  store i64 %mount_id, ptr %mount_id.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  store i32 0, ptr %mid, align 4
  %0 = load i64, ptr %handle.addr, align 8
  store i64 %0, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %1 = load i64, ptr %__gaddr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %1, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call, ptr %__hptr, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load ptr, ptr %__hptr, align 8
  %call1 = call i32 @ldl_le_p(ptr noundef %2)
  store i32 %call1, ptr %size, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  %3 = load ptr, ptr %__hptr, align 8
  %4 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %3, i64 noundef %4, i64 noundef 0)
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 0, ptr %size, align 4
  store i64 -14, ptr %__ret, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %5 = load i64, ptr %__ret, align 8
  store i64 %5, ptr %tmp, align 8
  %6 = load i64, ptr %tmp, align 8
  %tobool2 = icmp ne i64 %6, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %7 = load i64, ptr %pathname.addr, align 8
  %call5 = call ptr @lock_user_string(i64 noundef %7)
  store ptr %call5, ptr %name, align 8
  %8 = load ptr, ptr %name, align 8
  %tobool6 = icmp ne ptr %8, null
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end4
  store i64 -14, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end4
  %9 = load i32, ptr %size, align 4
  %conv = zext i32 %9 to i64
  %add = add i64 8, %conv
  %conv9 = trunc i64 %add to i32
  store i32 %conv9, ptr %total_size, align 4
  %10 = load i64, ptr %handle.addr, align 8
  %11 = load i32, ptr %total_size, align 4
  %conv10 = zext i32 %11 to i64
  %call11 = call ptr @lock_user(i32 noundef 3, i64 noundef %10, i64 noundef %conv10, i1 noundef zeroext false)
  store ptr %call11, ptr %target_fh, align 8
  %12 = load ptr, ptr %target_fh, align 8
  %tobool12 = icmp ne ptr %12, null
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end8
  %13 = load ptr, ptr %name, align 8
  %14 = load i64, ptr %pathname.addr, align 8
  call void @unlock_user(ptr noundef %13, i64 noundef %14, i64 noundef 0)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end8
  %15 = load i32, ptr %total_size, align 4
  %conv15 = zext i32 %15 to i64
  %call16 = call noalias ptr @g_malloc0(i64 noundef %conv15) #16
  store ptr %call16, ptr %fh, align 8
  %16 = load i32, ptr %size, align 4
  %17 = load ptr, ptr %fh, align 8
  %handle_bytes = getelementptr inbounds %struct.file_handle, ptr %17, i32 0, i32 0
  store i32 %16, ptr %handle_bytes, align 4
  %18 = load i64, ptr %dirfd.addr, align 8
  %conv17 = trunc i64 %18 to i32
  %19 = load ptr, ptr %name, align 8
  %call18 = call ptr @path(ptr noundef %19)
  %20 = load ptr, ptr %fh, align 8
  %21 = load i64, ptr %flags.addr, align 8
  %conv19 = trunc i64 %21 to i32
  %call20 = call i32 @name_to_handle_at(i32 noundef %conv17, ptr noundef %call18, ptr noundef %20, ptr noundef %mid, i32 noundef %conv19) #14
  %conv21 = sext i32 %call20 to i64
  %call22 = call i64 @get_errno(i64 noundef %conv21)
  store i64 %call22, ptr %ret, align 8
  %22 = load ptr, ptr %name, align 8
  %23 = load i64, ptr %pathname.addr, align 8
  call void @unlock_user(ptr noundef %22, i64 noundef %23, i64 noundef 0)
  %24 = load ptr, ptr %target_fh, align 8
  %25 = load ptr, ptr %fh, align 8
  %26 = load i32, ptr %total_size, align 4
  %conv23 = zext i32 %26 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %24, ptr align 4 %25, i64 %conv23, i1 false)
  %27 = load ptr, ptr %fh, align 8
  %handle_bytes24 = getelementptr inbounds %struct.file_handle, ptr %27, i32 0, i32 0
  %28 = load i32, ptr %handle_bytes24, align 4
  %call25 = call i32 @tswap32(i32 noundef %28)
  %29 = load ptr, ptr %target_fh, align 8
  %handle_bytes26 = getelementptr inbounds %struct.file_handle, ptr %29, i32 0, i32 0
  store i32 %call25, ptr %handle_bytes26, align 4
  %30 = load ptr, ptr %fh, align 8
  %handle_type = getelementptr inbounds %struct.file_handle, ptr %30, i32 0, i32 1
  %31 = load i32, ptr %handle_type, align 4
  %call27 = call i32 @tswap32(i32 noundef %31)
  %32 = load ptr, ptr %target_fh, align 8
  %handle_type28 = getelementptr inbounds %struct.file_handle, ptr %32, i32 0, i32 1
  store i32 %call27, ptr %handle_type28, align 4
  %33 = load ptr, ptr %fh, align 8
  call void @g_free(ptr noundef %33)
  %34 = load ptr, ptr %target_fh, align 8
  %35 = load i64, ptr %handle.addr, align 8
  %36 = load i32, ptr %total_size, align 4
  %conv29 = zext i32 %36 to i64
  call void @unlock_user(ptr noundef %34, i64 noundef %35, i64 noundef %conv29)
  %37 = load i64, ptr %mount_id.addr, align 8
  store i64 %37, ptr %__gaddr30, align 8
  store i64 0, ptr %__ret32, align 8
  %38 = load i64, ptr %__gaddr30, align 8
  %call33 = call ptr @lock_user(i32 noundef 3, i64 noundef %38, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call33, ptr %__hptr31, align 8
  %tobool34 = icmp ne ptr %call33, null
  br i1 %tobool34, label %if.then35, label %if.else38

if.then35:                                        ; preds = %if.end14
  br label %do.body36

do.body36:                                        ; preds = %if.then35
  %39 = load ptr, ptr %__hptr31, align 8
  %40 = load i32, ptr %mid, align 4
  call void @stl_le_p(ptr noundef %39, i32 noundef %40)
  br label %do.end37

do.end37:                                         ; preds = %do.body36
  %41 = load ptr, ptr %__hptr31, align 8
  %42 = load i64, ptr %__gaddr30, align 8
  call void @unlock_user(ptr noundef %41, i64 noundef %42, i64 noundef 4)
  br label %if.end39

if.else38:                                        ; preds = %if.end14
  store i64 -14, ptr %__ret32, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.else38, %do.end37
  %43 = load i64, ptr %__ret32, align 8
  store i64 %43, ptr %tmp40, align 8
  %44 = load i64, ptr %tmp40, align 8
  %tobool41 = icmp ne i64 %44, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end39
  store i64 -14, ptr %retval, align 8
  br label %return

if.end43:                                         ; preds = %if.end39
  %45 = load i64, ptr %ret, align 8
  store i64 %45, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end43, %if.then42, %if.then13, %if.then7, %if.then3
  %46 = load i64, ptr %retval, align 8
  ret i64 %46
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_open_by_handle_at(i64 noundef %mount_fd, i64 noundef %handle, i64 noundef %flags) #0 {
entry:
  %retval = alloca i64, align 8
  %mount_fd.addr = alloca i64, align 8
  %handle.addr = alloca i64, align 8
  %flags.addr = alloca i64, align 8
  %target_fh = alloca ptr, align 8
  %fh = alloca ptr, align 8
  %size = alloca i32, align 4
  %total_size = alloca i32, align 4
  %ret = alloca i64, align 8
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  store i64 %mount_fd, ptr %mount_fd.addr, align 8
  store i64 %handle, ptr %handle.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  %0 = load i64, ptr %handle.addr, align 8
  store i64 %0, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %1 = load i64, ptr %__gaddr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %1, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call, ptr %__hptr, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load ptr, ptr %__hptr, align 8
  %call1 = call i32 @ldl_le_p(ptr noundef %2)
  store i32 %call1, ptr %size, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  %3 = load ptr, ptr %__hptr, align 8
  %4 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %3, i64 noundef %4, i64 noundef 0)
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 0, ptr %size, align 4
  store i64 -14, ptr %__ret, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %5 = load i64, ptr %__ret, align 8
  store i64 %5, ptr %tmp, align 8
  %6 = load i64, ptr %tmp, align 8
  %tobool2 = icmp ne i64 %6, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %7 = load i32, ptr %size, align 4
  %conv = zext i32 %7 to i64
  %add = add i64 8, %conv
  %conv5 = trunc i64 %add to i32
  store i32 %conv5, ptr %total_size, align 4
  %8 = load i64, ptr %handle.addr, align 8
  %9 = load i32, ptr %total_size, align 4
  %conv6 = zext i32 %9 to i64
  %call7 = call ptr @lock_user(i32 noundef 1, i64 noundef %8, i64 noundef %conv6, i1 noundef zeroext true)
  store ptr %call7, ptr %target_fh, align 8
  %10 = load ptr, ptr %target_fh, align 8
  %tobool8 = icmp ne ptr %10, null
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end4
  store i64 -14, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end4
  %11 = load ptr, ptr %target_fh, align 8
  %12 = load i32, ptr %total_size, align 4
  %call11 = call ptr @g_memdup(ptr noundef %11, i32 noundef %12) #20
  store ptr %call11, ptr %fh, align 8
  %13 = load i32, ptr %size, align 4
  %14 = load ptr, ptr %fh, align 8
  %handle_bytes = getelementptr inbounds %struct.file_handle, ptr %14, i32 0, i32 0
  store i32 %13, ptr %handle_bytes, align 4
  %15 = load ptr, ptr %target_fh, align 8
  %handle_type = getelementptr inbounds %struct.file_handle, ptr %15, i32 0, i32 1
  %16 = load i32, ptr %handle_type, align 4
  %call12 = call i32 @tswap32(i32 noundef %16)
  %17 = load ptr, ptr %fh, align 8
  %handle_type13 = getelementptr inbounds %struct.file_handle, ptr %17, i32 0, i32 1
  store i32 %call12, ptr %handle_type13, align 4
  %18 = load i64, ptr %mount_fd.addr, align 8
  %conv14 = trunc i64 %18 to i32
  %19 = load ptr, ptr %fh, align 8
  %20 = load i64, ptr %flags.addr, align 8
  %conv15 = trunc i64 %20 to i32
  %call16 = call i32 @target_to_host_bitmask_len(i32 noundef %conv15, ptr noundef @fcntl_flags_tbl, i64 noundef 19)
  %call17 = call i32 @open_by_handle_at(i32 noundef %conv14, ptr noundef %19, i32 noundef %call16)
  %conv18 = sext i32 %call17 to i64
  %call19 = call i64 @get_errno(i64 noundef %conv18)
  store i64 %call19, ptr %ret, align 8
  %21 = load ptr, ptr %fh, align 8
  call void @g_free(ptr noundef %21)
  %22 = load ptr, ptr %target_fh, align 8
  %23 = load i64, ptr %handle.addr, align 8
  %24 = load i32, ptr %total_size, align 4
  %conv20 = zext i32 %24 to i64
  call void @unlock_user(ptr noundef %22, i64 noundef %23, i64 noundef %conv20)
  %25 = load i64, ptr %ret, align 8
  store i64 %25, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.then9, %if.then3
  %26 = load i64, ptr %retval, align 8
  ret i64 %26
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @pidfd_open(i32 noundef %pid, i32 noundef %flags) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load i32, ptr %flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 434, i32 noundef %0, i32 noundef %1) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

declare void @target_to_host_siginfo(ptr noundef, ptr noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @pidfd_send_signal(i32 noundef %pidfd, i32 noundef %sig, ptr noundef %info, i32 noundef %flags) #0 {
entry:
  %pidfd.addr = alloca i32, align 4
  %sig.addr = alloca i32, align 4
  %info.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store i32 %pidfd, ptr %pidfd.addr, align 4
  store i32 %sig, ptr %sig.addr, align 4
  store ptr %info, ptr %info.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %pidfd.addr, align 4
  %1 = load i32, ptr %sig.addr, align 4
  %2 = load ptr, ptr %info.addr, align 8
  %3 = load i32, ptr %flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 424, i32 noundef %0, i32 noundef %1, ptr noundef %2, i32 noundef %3) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @pidfd_getfd(i32 noundef %pidfd, i32 noundef %targetfd, i32 noundef %flags) #0 {
entry:
  %pidfd.addr = alloca i32, align 4
  %targetfd.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  store i32 %pidfd, ptr %pidfd.addr, align 4
  store i32 %targetfd, ptr %targetfd.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %pidfd.addr, align 4
  %1 = load i32, ptr %targetfd.addr, align 4
  %2 = load i32, ptr %flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 438, i32 noundef %0, i32 noundef %1, i32 noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_close_range(i32 noundef %first, i32 noundef %last, i32 noundef %flags) #0 {
entry:
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  %1 = load i32, ptr %last.addr, align 4
  %2 = load i32, ptr %flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 436, i32 noundef %0, i32 noundef %1, i32 noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_waitid(i32 noundef %idtype, i32 noundef %id, ptr noundef %infop, i32 noundef %options, ptr noundef %rusage) #0 {
entry:
  %idtype.addr = alloca i32, align 4
  %id.addr = alloca i32, align 4
  %infop.addr = alloca ptr, align 8
  %options.addr = alloca i32, align 4
  %rusage.addr = alloca ptr, align 8
  store i32 %idtype, ptr %idtype.addr, align 4
  store i32 %id, ptr %id.addr, align 4
  store ptr %infop, ptr %infop.addr, align 8
  store i32 %options, ptr %options.addr, align 4
  store ptr %rusage, ptr %rusage.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %idtype.addr, align 4
  %4 = load i32, ptr %id.addr, align 4
  %5 = load ptr, ptr %infop.addr, align 8
  %6 = load i32, ptr %options.addr, align 4
  %7 = load ptr, ptr %rusage.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 247, i32 noundef %3, i32 noundef %4, ptr noundef %5, i32 noundef %6, ptr noundef %7)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

declare void @host_to_target_siginfo(ptr noundef, ptr noundef) #3

; Function Attrs: nounwind
declare i32 @linkat(i32 noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @unlinkat(i32 noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @do_execv(ptr noundef %cpu_env, i32 noundef %dirfd, i64 noundef %pathname, i64 noundef %guest_argp, i64 noundef %guest_envp, i32 noundef %flags, i1 noundef zeroext %is_execveat) #0 {
entry:
  %retval = alloca i32, align 4
  %cpu_env.addr = alloca ptr, align 8
  %dirfd.addr = alloca i32, align 4
  %pathname.addr = alloca i64, align 8
  %guest_argp.addr = alloca i64, align 8
  %guest_envp.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %is_execveat.addr = alloca i8, align 1
  %ret = alloca i32, align 4
  %argp = alloca ptr, align 8
  %envp = alloca ptr, align 8
  %argc = alloca i32, align 4
  %envc = alloca i32, align 4
  %gp = alloca i64, align 8
  %addr = alloca i64, align 8
  %q = alloca ptr, align 8
  %p = alloca ptr, align 8
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__gaddr12 = alloca i64, align 8
  %__hptr13 = alloca ptr, align 8
  %__ret14 = alloca i64, align 8
  %tmp23 = alloca i64, align 8
  %__gaddr42 = alloca i64, align 8
  %__hptr43 = alloca ptr, align 8
  %__ret44 = alloca i64, align 8
  %tmp53 = alloca i64, align 8
  %__gaddr70 = alloca i64, align 8
  %__hptr71 = alloca ptr, align 8
  %__ret72 = alloca i64, align 8
  %tmp81 = alloca i64, align 8
  %exe = alloca ptr, align 8
  %__gaddr114 = alloca i64, align 8
  %__hptr115 = alloca ptr, align 8
  %__ret116 = alloca i64, align 8
  %tmp125 = alloca i64, align 8
  %__gaddr137 = alloca i64, align 8
  %__hptr138 = alloca ptr, align 8
  %__ret139 = alloca i64, align 8
  %tmp148 = alloca i64, align 8
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i32 %dirfd, ptr %dirfd.addr, align 4
  store i64 %pathname, ptr %pathname.addr, align 8
  store i64 %guest_argp, ptr %guest_argp.addr, align 8
  store i64 %guest_envp, ptr %guest_envp.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %frombool = zext i1 %is_execveat to i8
  store i8 %frombool, ptr %is_execveat.addr, align 1
  store i32 0, ptr %argc, align 4
  %0 = load i64, ptr %guest_argp.addr, align 8
  store i64 %0, ptr %gp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %gp, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64, ptr %gp, align 8
  store i64 %2, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %3 = load i64, ptr %__gaddr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %3, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call, ptr %__hptr, align 8
  %tobool1 = icmp ne ptr %call, null
  br i1 %tobool1, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %if.then
  %4 = load ptr, ptr %__hptr, align 8
  %call2 = call i64 @ldq_le_p(ptr noundef %4)
  store i64 %call2, ptr %addr, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %5 = load ptr, ptr %__hptr, align 8
  %6 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %5, i64 noundef %6, i64 noundef 0)
  br label %if.end

if.else:                                          ; preds = %for.body
  store i64 0, ptr %addr, align 8
  store i64 -14, ptr %__ret, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %7 = load i64, ptr %__ret, align 8
  store i64 %7, ptr %tmp, align 8
  %8 = load i64, ptr %tmp, align 8
  %tobool3 = icmp ne i64 %8, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i32 -14, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %9 = load i64, ptr %addr, align 8
  %tobool6 = icmp ne i64 %9, 0
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end5
  br label %for.end

if.end8:                                          ; preds = %if.end5
  %10 = load i32, ptr %argc, align 4
  %inc = add i32 %10, 1
  store i32 %inc, ptr %argc, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end8
  %11 = load i64, ptr %gp, align 8
  %add = add i64 %11, 8
  store i64 %add, ptr %gp, align 8
  br label %for.cond, !llvm.loop !26

for.end:                                          ; preds = %if.then7, %for.cond
  store i32 0, ptr %envc, align 4
  %12 = load i64, ptr %guest_envp.addr, align 8
  store i64 %12, ptr %gp, align 8
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc31, %for.end
  %13 = load i64, ptr %gp, align 8
  %tobool10 = icmp ne i64 %13, 0
  br i1 %tobool10, label %for.body11, label %for.end33

for.body11:                                       ; preds = %for.cond9
  %14 = load i64, ptr %gp, align 8
  store i64 %14, ptr %__gaddr12, align 8
  store i64 0, ptr %__ret14, align 8
  %15 = load i64, ptr %__gaddr12, align 8
  %call15 = call ptr @lock_user(i32 noundef 1, i64 noundef %15, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call15, ptr %__hptr13, align 8
  %tobool16 = icmp ne ptr %call15, null
  br i1 %tobool16, label %if.then17, label %if.else21

if.then17:                                        ; preds = %for.body11
  br label %do.body18

do.body18:                                        ; preds = %if.then17
  %16 = load ptr, ptr %__hptr13, align 8
  %call19 = call i64 @ldq_le_p(ptr noundef %16)
  store i64 %call19, ptr %addr, align 8
  br label %do.end20

do.end20:                                         ; preds = %do.body18
  %17 = load ptr, ptr %__hptr13, align 8
  %18 = load i64, ptr %__gaddr12, align 8
  call void @unlock_user(ptr noundef %17, i64 noundef %18, i64 noundef 0)
  br label %if.end22

if.else21:                                        ; preds = %for.body11
  store i64 0, ptr %addr, align 8
  store i64 -14, ptr %__ret14, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else21, %do.end20
  %19 = load i64, ptr %__ret14, align 8
  store i64 %19, ptr %tmp23, align 8
  %20 = load i64, ptr %tmp23, align 8
  %tobool24 = icmp ne i64 %20, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end22
  store i32 -14, ptr %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.end22
  %21 = load i64, ptr %addr, align 8
  %tobool27 = icmp ne i64 %21, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %if.end26
  br label %for.end33

if.end29:                                         ; preds = %if.end26
  %22 = load i32, ptr %envc, align 4
  %inc30 = add i32 %22, 1
  store i32 %inc30, ptr %envc, align 4
  br label %for.inc31

for.inc31:                                        ; preds = %if.end29
  %23 = load i64, ptr %gp, align 8
  %add32 = add i64 %23, 8
  store i64 %add32, ptr %gp, align 8
  br label %for.cond9, !llvm.loop !27

for.end33:                                        ; preds = %if.then28, %for.cond9
  %24 = load i32, ptr %argc, align 4
  %add34 = add i32 %24, 1
  %conv = sext i32 %add34 to i64
  %call35 = call noalias ptr @g_malloc0_n(i64 noundef %conv, i64 noundef 8) #17
  store ptr %call35, ptr %argp, align 8
  %25 = load i32, ptr %envc, align 4
  %add36 = add i32 %25, 1
  %conv37 = sext i32 %add36 to i64
  %call38 = call noalias ptr @g_malloc0_n(i64 noundef %conv37, i64 noundef 8) #17
  store ptr %call38, ptr %envp, align 8
  %26 = load i64, ptr %guest_argp.addr, align 8
  store i64 %26, ptr %gp, align 8
  %27 = load ptr, ptr %argp, align 8
  store ptr %27, ptr %q, align 8
  br label %for.cond39

for.cond39:                                       ; preds = %for.inc64, %for.end33
  %28 = load i64, ptr %gp, align 8
  %tobool40 = icmp ne i64 %28, 0
  br i1 %tobool40, label %for.body41, label %for.end66

for.body41:                                       ; preds = %for.cond39
  %29 = load i64, ptr %gp, align 8
  store i64 %29, ptr %__gaddr42, align 8
  store i64 0, ptr %__ret44, align 8
  %30 = load i64, ptr %__gaddr42, align 8
  %call45 = call ptr @lock_user(i32 noundef 1, i64 noundef %30, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call45, ptr %__hptr43, align 8
  %tobool46 = icmp ne ptr %call45, null
  br i1 %tobool46, label %if.then47, label %if.else51

if.then47:                                        ; preds = %for.body41
  br label %do.body48

do.body48:                                        ; preds = %if.then47
  %31 = load ptr, ptr %__hptr43, align 8
  %call49 = call i64 @ldq_le_p(ptr noundef %31)
  store i64 %call49, ptr %addr, align 8
  br label %do.end50

do.end50:                                         ; preds = %do.body48
  %32 = load ptr, ptr %__hptr43, align 8
  %33 = load i64, ptr %__gaddr42, align 8
  call void @unlock_user(ptr noundef %32, i64 noundef %33, i64 noundef 0)
  br label %if.end52

if.else51:                                        ; preds = %for.body41
  store i64 0, ptr %addr, align 8
  store i64 -14, ptr %__ret44, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.else51, %do.end50
  %34 = load i64, ptr %__ret44, align 8
  store i64 %34, ptr %tmp53, align 8
  %35 = load i64, ptr %tmp53, align 8
  %tobool54 = icmp ne i64 %35, 0
  br i1 %tobool54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end52
  br label %execve_efault

if.end56:                                         ; preds = %if.end52
  %36 = load i64, ptr %addr, align 8
  %tobool57 = icmp ne i64 %36, 0
  br i1 %tobool57, label %if.end59, label %if.then58

if.then58:                                        ; preds = %if.end56
  br label %for.end66

if.end59:                                         ; preds = %if.end56
  %37 = load i64, ptr %addr, align 8
  %call60 = call ptr @lock_user_string(i64 noundef %37)
  %38 = load ptr, ptr %q, align 8
  store ptr %call60, ptr %38, align 8
  %39 = load ptr, ptr %q, align 8
  %40 = load ptr, ptr %39, align 8
  %tobool61 = icmp ne ptr %40, null
  br i1 %tobool61, label %if.end63, label %if.then62

if.then62:                                        ; preds = %if.end59
  br label %execve_efault

if.end63:                                         ; preds = %if.end59
  br label %for.inc64

for.inc64:                                        ; preds = %if.end63
  %41 = load i64, ptr %gp, align 8
  %add65 = add i64 %41, 8
  store i64 %add65, ptr %gp, align 8
  %42 = load ptr, ptr %q, align 8
  %incdec.ptr = getelementptr ptr, ptr %42, i32 1
  store ptr %incdec.ptr, ptr %q, align 8
  br label %for.cond39, !llvm.loop !28

for.end66:                                        ; preds = %if.then58, %for.cond39
  %43 = load ptr, ptr %q, align 8
  store ptr null, ptr %43, align 8
  %44 = load i64, ptr %guest_envp.addr, align 8
  store i64 %44, ptr %gp, align 8
  %45 = load ptr, ptr %envp, align 8
  store ptr %45, ptr %q, align 8
  br label %for.cond67

for.cond67:                                       ; preds = %for.inc92, %for.end66
  %46 = load i64, ptr %gp, align 8
  %tobool68 = icmp ne i64 %46, 0
  br i1 %tobool68, label %for.body69, label %for.end95

for.body69:                                       ; preds = %for.cond67
  %47 = load i64, ptr %gp, align 8
  store i64 %47, ptr %__gaddr70, align 8
  store i64 0, ptr %__ret72, align 8
  %48 = load i64, ptr %__gaddr70, align 8
  %call73 = call ptr @lock_user(i32 noundef 1, i64 noundef %48, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call73, ptr %__hptr71, align 8
  %tobool74 = icmp ne ptr %call73, null
  br i1 %tobool74, label %if.then75, label %if.else79

if.then75:                                        ; preds = %for.body69
  br label %do.body76

do.body76:                                        ; preds = %if.then75
  %49 = load ptr, ptr %__hptr71, align 8
  %call77 = call i64 @ldq_le_p(ptr noundef %49)
  store i64 %call77, ptr %addr, align 8
  br label %do.end78

do.end78:                                         ; preds = %do.body76
  %50 = load ptr, ptr %__hptr71, align 8
  %51 = load i64, ptr %__gaddr70, align 8
  call void @unlock_user(ptr noundef %50, i64 noundef %51, i64 noundef 0)
  br label %if.end80

if.else79:                                        ; preds = %for.body69
  store i64 0, ptr %addr, align 8
  store i64 -14, ptr %__ret72, align 8
  br label %if.end80

if.end80:                                         ; preds = %if.else79, %do.end78
  %52 = load i64, ptr %__ret72, align 8
  store i64 %52, ptr %tmp81, align 8
  %53 = load i64, ptr %tmp81, align 8
  %tobool82 = icmp ne i64 %53, 0
  br i1 %tobool82, label %if.then83, label %if.end84

if.then83:                                        ; preds = %if.end80
  br label %execve_efault

if.end84:                                         ; preds = %if.end80
  %54 = load i64, ptr %addr, align 8
  %tobool85 = icmp ne i64 %54, 0
  br i1 %tobool85, label %if.end87, label %if.then86

if.then86:                                        ; preds = %if.end84
  br label %for.end95

if.end87:                                         ; preds = %if.end84
  %55 = load i64, ptr %addr, align 8
  %call88 = call ptr @lock_user_string(i64 noundef %55)
  %56 = load ptr, ptr %q, align 8
  store ptr %call88, ptr %56, align 8
  %57 = load ptr, ptr %q, align 8
  %58 = load ptr, ptr %57, align 8
  %tobool89 = icmp ne ptr %58, null
  br i1 %tobool89, label %if.end91, label %if.then90

if.then90:                                        ; preds = %if.end87
  br label %execve_efault

if.end91:                                         ; preds = %if.end87
  br label %for.inc92

for.inc92:                                        ; preds = %if.end91
  %59 = load i64, ptr %gp, align 8
  %add93 = add i64 %59, 8
  store i64 %add93, ptr %gp, align 8
  %60 = load ptr, ptr %q, align 8
  %incdec.ptr94 = getelementptr ptr, ptr %60, i32 1
  store ptr %incdec.ptr94, ptr %q, align 8
  br label %for.cond67, !llvm.loop !29

for.end95:                                        ; preds = %if.then86, %for.cond67
  %61 = load ptr, ptr %q, align 8
  store ptr null, ptr %61, align 8
  %62 = load i64, ptr %pathname.addr, align 8
  %call96 = call ptr @lock_user_string(i64 noundef %62)
  store ptr %call96, ptr %p, align 8
  %63 = load ptr, ptr %p, align 8
  %tobool97 = icmp ne ptr %63, null
  br i1 %tobool97, label %if.end99, label %if.then98

if.then98:                                        ; preds = %for.end95
  br label %execve_efault

if.end99:                                         ; preds = %for.end95
  %64 = load ptr, ptr %p, align 8
  store ptr %64, ptr %exe, align 8
  %65 = load ptr, ptr %p, align 8
  %call100 = call i32 @is_proc_myself(ptr noundef %65, ptr noundef @.str.573)
  %tobool101 = icmp ne i32 %call100, 0
  br i1 %tobool101, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.end99
  %66 = load ptr, ptr @exec_path, align 8
  store ptr %66, ptr %exe, align 8
  br label %if.end103

if.end103:                                        ; preds = %if.then102, %if.end99
  %67 = load i8, ptr %is_execveat.addr, align 1
  %tobool104 = trunc i8 %67 to i1
  br i1 %tobool104, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end103
  %68 = load i32, ptr %dirfd.addr, align 4
  %69 = load ptr, ptr %exe, align 8
  %70 = load ptr, ptr %argp, align 8
  %71 = load ptr, ptr %envp, align 8
  %72 = load i32, ptr %flags.addr, align 4
  %call106 = call i32 @safe_execveat(i32 noundef %68, ptr noundef %69, ptr noundef %70, ptr noundef %71, i32 noundef %72)
  br label %cond.end

cond.false:                                       ; preds = %if.end103
  %73 = load ptr, ptr %exe, align 8
  %74 = load ptr, ptr %argp, align 8
  %75 = load ptr, ptr %envp, align 8
  %call107 = call i32 @safe_execve(ptr noundef %73, ptr noundef %74, ptr noundef %75)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call106, %cond.true ], [ %call107, %cond.false ]
  store i32 %cond, ptr %ret, align 4
  %76 = load i32, ptr %ret, align 4
  %conv108 = sext i32 %76 to i64
  %call109 = call i64 @get_errno(i64 noundef %conv108)
  %conv110 = trunc i64 %call109 to i32
  store i32 %conv110, ptr %ret, align 4
  %77 = load ptr, ptr %p, align 8
  %78 = load i64, ptr %pathname.addr, align 8
  call void @unlock_user(ptr noundef %77, i64 noundef %78, i64 noundef 0)
  br label %execve_end

execve_efault:                                    ; preds = %if.then98, %if.then90, %if.then83, %if.then62, %if.then55
  store i32 -14, ptr %ret, align 4
  br label %execve_end

execve_end:                                       ; preds = %execve_efault, %cond.end
  %79 = load i64, ptr %guest_argp.addr, align 8
  store i64 %79, ptr %gp, align 8
  %80 = load ptr, ptr %argp, align 8
  store ptr %80, ptr %q, align 8
  br label %for.cond111

for.cond111:                                      ; preds = %for.inc130, %execve_end
  %81 = load ptr, ptr %q, align 8
  %82 = load ptr, ptr %81, align 8
  %tobool112 = icmp ne ptr %82, null
  br i1 %tobool112, label %for.body113, label %for.end133

for.body113:                                      ; preds = %for.cond111
  %83 = load i64, ptr %gp, align 8
  store i64 %83, ptr %__gaddr114, align 8
  store i64 0, ptr %__ret116, align 8
  %84 = load i64, ptr %__gaddr114, align 8
  %call117 = call ptr @lock_user(i32 noundef 1, i64 noundef %84, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call117, ptr %__hptr115, align 8
  %tobool118 = icmp ne ptr %call117, null
  br i1 %tobool118, label %if.then119, label %if.else123

if.then119:                                       ; preds = %for.body113
  br label %do.body120

do.body120:                                       ; preds = %if.then119
  %85 = load ptr, ptr %__hptr115, align 8
  %call121 = call i64 @ldq_le_p(ptr noundef %85)
  store i64 %call121, ptr %addr, align 8
  br label %do.end122

do.end122:                                        ; preds = %do.body120
  %86 = load ptr, ptr %__hptr115, align 8
  %87 = load i64, ptr %__gaddr114, align 8
  call void @unlock_user(ptr noundef %86, i64 noundef %87, i64 noundef 0)
  br label %if.end124

if.else123:                                       ; preds = %for.body113
  store i64 0, ptr %addr, align 8
  store i64 -14, ptr %__ret116, align 8
  br label %if.end124

if.end124:                                        ; preds = %if.else123, %do.end122
  %88 = load i64, ptr %__ret116, align 8
  store i64 %88, ptr %tmp125, align 8
  %89 = load i64, ptr %tmp125, align 8
  %tobool126 = icmp ne i64 %89, 0
  br i1 %tobool126, label %if.then128, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end124
  %90 = load i64, ptr %addr, align 8
  %tobool127 = icmp ne i64 %90, 0
  br i1 %tobool127, label %if.end129, label %if.then128

if.then128:                                       ; preds = %lor.lhs.false, %if.end124
  br label %for.end133

if.end129:                                        ; preds = %lor.lhs.false
  %91 = load ptr, ptr %q, align 8
  %92 = load ptr, ptr %91, align 8
  %93 = load i64, ptr %addr, align 8
  call void @unlock_user(ptr noundef %92, i64 noundef %93, i64 noundef 0)
  br label %for.inc130

for.inc130:                                       ; preds = %if.end129
  %94 = load i64, ptr %gp, align 8
  %add131 = add i64 %94, 8
  store i64 %add131, ptr %gp, align 8
  %95 = load ptr, ptr %q, align 8
  %incdec.ptr132 = getelementptr ptr, ptr %95, i32 1
  store ptr %incdec.ptr132, ptr %q, align 8
  br label %for.cond111, !llvm.loop !30

for.end133:                                       ; preds = %if.then128, %for.cond111
  %96 = load i64, ptr %guest_envp.addr, align 8
  store i64 %96, ptr %gp, align 8
  %97 = load ptr, ptr %envp, align 8
  store ptr %97, ptr %q, align 8
  br label %for.cond134

for.cond134:                                      ; preds = %for.inc154, %for.end133
  %98 = load ptr, ptr %q, align 8
  %99 = load ptr, ptr %98, align 8
  %tobool135 = icmp ne ptr %99, null
  br i1 %tobool135, label %for.body136, label %for.end157

for.body136:                                      ; preds = %for.cond134
  %100 = load i64, ptr %gp, align 8
  store i64 %100, ptr %__gaddr137, align 8
  store i64 0, ptr %__ret139, align 8
  %101 = load i64, ptr %__gaddr137, align 8
  %call140 = call ptr @lock_user(i32 noundef 1, i64 noundef %101, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call140, ptr %__hptr138, align 8
  %tobool141 = icmp ne ptr %call140, null
  br i1 %tobool141, label %if.then142, label %if.else146

if.then142:                                       ; preds = %for.body136
  br label %do.body143

do.body143:                                       ; preds = %if.then142
  %102 = load ptr, ptr %__hptr138, align 8
  %call144 = call i64 @ldq_le_p(ptr noundef %102)
  store i64 %call144, ptr %addr, align 8
  br label %do.end145

do.end145:                                        ; preds = %do.body143
  %103 = load ptr, ptr %__hptr138, align 8
  %104 = load i64, ptr %__gaddr137, align 8
  call void @unlock_user(ptr noundef %103, i64 noundef %104, i64 noundef 0)
  br label %if.end147

if.else146:                                       ; preds = %for.body136
  store i64 0, ptr %addr, align 8
  store i64 -14, ptr %__ret139, align 8
  br label %if.end147

if.end147:                                        ; preds = %if.else146, %do.end145
  %105 = load i64, ptr %__ret139, align 8
  store i64 %105, ptr %tmp148, align 8
  %106 = load i64, ptr %tmp148, align 8
  %tobool149 = icmp ne i64 %106, 0
  br i1 %tobool149, label %if.then152, label %lor.lhs.false150

lor.lhs.false150:                                 ; preds = %if.end147
  %107 = load i64, ptr %addr, align 8
  %tobool151 = icmp ne i64 %107, 0
  br i1 %tobool151, label %if.end153, label %if.then152

if.then152:                                       ; preds = %lor.lhs.false150, %if.end147
  br label %for.end157

if.end153:                                        ; preds = %lor.lhs.false150
  %108 = load ptr, ptr %q, align 8
  %109 = load ptr, ptr %108, align 8
  %110 = load i64, ptr %addr, align 8
  call void @unlock_user(ptr noundef %109, i64 noundef %110, i64 noundef 0)
  br label %for.inc154

for.inc154:                                       ; preds = %if.end153
  %111 = load i64, ptr %gp, align 8
  %add155 = add i64 %111, 8
  store i64 %add155, ptr %gp, align 8
  %112 = load ptr, ptr %q, align 8
  %incdec.ptr156 = getelementptr ptr, ptr %112, i32 1
  store ptr %incdec.ptr156, ptr %q, align 8
  br label %for.cond134, !llvm.loop !31

for.end157:                                       ; preds = %if.then152, %for.cond134
  %113 = load ptr, ptr %argp, align 8
  call void @g_free(ptr noundef %113)
  %114 = load ptr, ptr %envp, align 8
  call void @g_free(ptr noundef %114)
  %115 = load i32, ptr %ret, align 4
  store i32 %115, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end157, %if.then25, %if.then4
  %116 = load i32, ptr %retval, align 4
  ret i32 %116
}

; Function Attrs: nounwind
declare i32 @chdir(ptr noundef) #2

; Function Attrs: nounwind
declare i32 @mknodat(i32 noundef, ptr noundef, i32 noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i32 @mount(ptr noundef, ptr noundef, ptr noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_move_mount(i32 noundef %__from_dfd, ptr noundef %__from_pathname, i32 noundef %__to_dfd, ptr noundef %__to_pathname, i32 noundef %flag) #0 {
entry:
  %__from_dfd.addr = alloca i32, align 4
  %__from_pathname.addr = alloca ptr, align 8
  %__to_dfd.addr = alloca i32, align 4
  %__to_pathname.addr = alloca ptr, align 8
  %flag.addr = alloca i32, align 4
  store i32 %__from_dfd, ptr %__from_dfd.addr, align 4
  store ptr %__from_pathname, ptr %__from_pathname.addr, align 8
  store i32 %__to_dfd, ptr %__to_dfd.addr, align 4
  store ptr %__to_pathname, ptr %__to_pathname.addr, align 8
  store i32 %flag, ptr %flag.addr, align 4
  %0 = load i32, ptr %__from_dfd.addr, align 4
  %1 = load ptr, ptr %__from_pathname.addr, align 8
  %2 = load i32, ptr %__to_dfd.addr, align 4
  %3 = load ptr, ptr %__to_pathname.addr, align 8
  %4 = load i32, ptr %flag.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 429, i32 noundef %0, ptr noundef %1, i32 noundef %2, ptr noundef %3, i32 noundef %4) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_open_tree(i32 noundef %__dfd, ptr noundef %__filename, i32 noundef %__flags) #0 {
entry:
  %__dfd.addr = alloca i32, align 4
  %__filename.addr = alloca ptr, align 8
  %__flags.addr = alloca i32, align 4
  store i32 %__dfd, ptr %__dfd.addr, align 4
  store ptr %__filename, ptr %__filename.addr, align 8
  store i32 %__flags, ptr %__flags.addr, align 4
  %0 = load i32, ptr %__dfd.addr, align 4
  %1 = load ptr, ptr %__filename.addr, align 8
  %2 = load i32, ptr %__flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 428, i32 noundef %0, ptr noundef %1, i32 noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @faccessat(i32 noundef, ptr noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare void @sync() #2

; Function Attrs: nounwind
declare i32 @syncfs(i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_kill(i32 noundef %pid, i32 noundef %sig) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %sig.addr = alloca i32, align 4
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %sig, ptr %sig.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %pid.addr, align 4
  %4 = load i32, ptr %sig.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 62, i32 noundef %3, i32 noundef %4)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_renameat2(i32 noundef %oldfd, ptr noundef %old, i32 noundef %newfd, ptr noundef %new, i32 noundef %flags) #0 {
entry:
  %oldfd.addr = alloca i32, align 4
  %old.addr = alloca ptr, align 8
  %newfd.addr = alloca i32, align 4
  %new.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store i32 %oldfd, ptr %oldfd.addr, align 4
  store ptr %old, ptr %old.addr, align 8
  store i32 %newfd, ptr %newfd.addr, align 4
  store ptr %new, ptr %new.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %oldfd.addr, align 4
  %1 = load ptr, ptr %old.addr, align 8
  %2 = load i32, ptr %newfd.addr, align 4
  %3 = load ptr, ptr %new.addr, align 8
  %4 = load i32, ptr %flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 316, i32 noundef %0, ptr noundef %1, i32 noundef %2, ptr noundef %3, i32 noundef %4) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @mkdirat(i32 noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @dup(i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @fd_trans_dup(i32 noundef %oldfd, i32 noundef %newfd) #0 {
entry:
  %x.addr.i = alloca ptr, align 8
  %lockable.addr.i = alloca ptr, align 8
  %oldfd.addr = alloca i32, align 4
  %newfd.addr = alloca i32, align 4
  %qemu_lockable_auto5 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.QemuLockable, align 8
  store i32 %oldfd, ptr %oldfd.addr, align 4
  store i32 %newfd, ptr %newfd.addr, align 4
  %object = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 0
  store ptr @target_fd_trans_lock, ptr %object, align 8
  %lock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 1
  store ptr @qemu_mutex_lock, ptr %lock, align 8
  %unlock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 2
  store ptr @qemu_mutex_unlock, ptr %unlock, align 8
  store ptr @target_fd_trans_lock, ptr %x.addr.i, align 8
  store ptr %.compoundliteral, ptr %lockable.addr.i, align 8
  %0 = load ptr, ptr %x.addr.i, align 8
  %tobool.i = icmp ne ptr %0, null
  br i1 %tobool.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %entry
  %1 = load ptr, ptr %lockable.addr.i, align 8
  br label %qemu_make_lockable.exit

cond.false.i:                                     ; preds = %entry
  br label %qemu_make_lockable.exit

qemu_make_lockable.exit:                          ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi ptr [ %1, %cond.true.i ], [ null, %cond.false.i ]
  %call1 = call ptr @qemu_lockable_auto_lock(ptr noundef %cond.i)
  store ptr %call1, ptr %qemu_lockable_auto5, align 8
  %2 = load i32, ptr %newfd.addr, align 4
  call void @internal_fd_trans_unregister_unsafe(i32 noundef %2)
  %3 = load i32, ptr %oldfd.addr, align 4
  %4 = load i32, ptr @target_fd_max, align 4
  %cmp = icmp ult i32 %3, %4
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %qemu_make_lockable.exit
  %5 = load ptr, ptr @target_fd_trans, align 8
  %6 = load i32, ptr %oldfd.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr ptr, ptr %5, i64 %idxprom
  %7 = load ptr, ptr %arrayidx, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load i32, ptr %newfd.addr, align 4
  %9 = load ptr, ptr @target_fd_trans, align 8
  %10 = load i32, ptr %oldfd.addr, align 4
  %idxprom2 = sext i32 %10 to i64
  %arrayidx3 = getelementptr ptr, ptr %9, i64 %idxprom2
  %11 = load ptr, ptr %arrayidx3, align 8
  call void @internal_fd_trans_register_unsafe(i32 noundef %8, ptr noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %qemu_make_lockable.exit
  call void @glib_autoptr_cleanup_QemuLockable(ptr noundef %qemu_lockable_auto5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_pipe(ptr noundef %cpu_env, i64 noundef %pipedes, i32 noundef %flags, i32 noundef %is_pipe2) #0 {
entry:
  %retval = alloca i64, align 8
  %cpu_env.addr = alloca ptr, align 8
  %pipedes.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %is_pipe2.addr = alloca i32, align 4
  %host_pipe = alloca [2 x i32], align 4
  %ret = alloca i64, align 8
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__gaddr11 = alloca i64, align 8
  %__hptr12 = alloca ptr, align 8
  %__ret13 = alloca i64, align 8
  %tmp22 = alloca i64, align 8
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i64 %pipedes, ptr %pipedes.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %is_pipe2, ptr %is_pipe2.addr, align 4
  %arraydecay = getelementptr inbounds [2 x i32], ptr %host_pipe, i64 0, i64 0
  %0 = load i32, ptr %flags.addr, align 4
  %call = call i32 @pipe2(ptr noundef %arraydecay, i32 noundef %0) #14
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %ret, align 8
  %1 = load i64, ptr %ret, align 8
  %call1 = call i32 @is_error(i64 noundef %1)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %ret, align 8
  %call2 = call i64 @get_errno(i64 noundef %2)
  store i64 %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %is_pipe2.addr, align 4
  %tobool3 = icmp ne i32 %3, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %4 = load i64, ptr %pipedes.addr, align 8
  store i64 %4, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %5 = load i64, ptr %__gaddr, align 8
  %call6 = call ptr @lock_user(i32 noundef 3, i64 noundef %5, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call6, ptr %__hptr, align 8
  %tobool7 = icmp ne ptr %call6, null
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end5
  br label %do.body

do.body:                                          ; preds = %if.then8
  %6 = load ptr, ptr %__hptr, align 8
  %arrayidx = getelementptr [2 x i32], ptr %host_pipe, i64 0, i64 0
  %7 = load i32, ptr %arrayidx, align 4
  call void @stl_le_p(ptr noundef %6, i32 noundef %7)
  br label %do.end

do.end:                                           ; preds = %do.body
  %8 = load ptr, ptr %__hptr, align 8
  %9 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %8, i64 noundef %9, i64 noundef 4)
  br label %if.end9

if.else:                                          ; preds = %if.end5
  store i64 -14, ptr %__ret, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.else, %do.end
  %10 = load i64, ptr %__ret, align 8
  store i64 %10, ptr %tmp, align 8
  %11 = load i64, ptr %tmp, align 8
  %tobool10 = icmp ne i64 %11, 0
  br i1 %tobool10, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end9
  %12 = load i64, ptr %pipedes.addr, align 8
  %add = add i64 %12, 4
  store i64 %add, ptr %__gaddr11, align 8
  store i64 0, ptr %__ret13, align 8
  %13 = load i64, ptr %__gaddr11, align 8
  %call14 = call ptr @lock_user(i32 noundef 3, i64 noundef %13, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call14, ptr %__hptr12, align 8
  %tobool15 = icmp ne ptr %call14, null
  br i1 %tobool15, label %if.then16, label %if.else20

if.then16:                                        ; preds = %lor.lhs.false
  br label %do.body17

do.body17:                                        ; preds = %if.then16
  %14 = load ptr, ptr %__hptr12, align 8
  %arrayidx18 = getelementptr [2 x i32], ptr %host_pipe, i64 0, i64 1
  %15 = load i32, ptr %arrayidx18, align 4
  call void @stl_le_p(ptr noundef %14, i32 noundef %15)
  br label %do.end19

do.end19:                                         ; preds = %do.body17
  %16 = load ptr, ptr %__hptr12, align 8
  %17 = load i64, ptr %__gaddr11, align 8
  call void @unlock_user(ptr noundef %16, i64 noundef %17, i64 noundef 4)
  br label %if.end21

if.else20:                                        ; preds = %lor.lhs.false
  store i64 -14, ptr %__ret13, align 8
  br label %if.end21

if.end21:                                         ; preds = %if.else20, %do.end19
  %18 = load i64, ptr %__ret13, align 8
  store i64 %18, ptr %tmp22, align 8
  %19 = load i64, ptr %tmp22, align 8
  %tobool23 = icmp ne i64 %19, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end21, %if.end9
  store i64 -14, ptr %retval, align 8
  br label %return

if.end25:                                         ; preds = %if.end21
  %20 = load i64, ptr %ret, align 8
  %call26 = call i64 @get_errno(i64 noundef %20)
  store i64 %call26, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end25, %if.then24, %if.then
  %21 = load i64, ptr %retval, align 8
  ret i64 %21
}

; Function Attrs: nounwind
declare i64 @times(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_clock_t(i64 noundef %ticks) #0 {
entry:
  %ticks.addr = alloca i64, align 8
  store i64 %ticks, ptr %ticks.addr, align 8
  %0 = load i64, ptr %ticks.addr, align 8
  ret i64 %0
}

; Function Attrs: nounwind
declare i32 @acct(ptr noundef) #2

; Function Attrs: nounwind
declare i32 @umount2(ptr noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ioctl(i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %ie = alloca ptr, align 8
  %arg_type = alloca ptr, align 8
  %ret = alloca i64, align 8
  %buf_temp = alloca [4096 x i8], align 16
  %target_size = alloca i32, align 4
  %argptr = alloca ptr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  store ptr @ioctl_entries, ptr %ie, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end9, %entry
  %0 = load ptr, ptr %ie, align 8
  %target_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %target_cmd, align 8
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %if.then
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 1024)
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then2, label %if.end

if.then2:                                         ; preds = %do.body
  %2 = load i32, ptr %cmd.addr, align 4
  %conv3 = sext i32 %2 to i64
  call void (ptr, ...) @qemu_log(ptr noundef @.str.631, i64 noundef %conv3)
  br label %if.end

if.end:                                           ; preds = %if.then2, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  store i64 -25, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %for.cond
  %3 = load ptr, ptr %ie, align 8
  %target_cmd5 = getelementptr inbounds %struct.IOCTLEntry, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %target_cmd5, align 8
  %5 = load i32, ptr %cmd.addr, align 4
  %cmp6 = icmp eq i32 %4, %5
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  br label %for.end

if.end9:                                          ; preds = %if.end4
  %6 = load ptr, ptr %ie, align 8
  %incdec.ptr = getelementptr %struct.IOCTLEntry, ptr %6, i32 1
  store ptr %incdec.ptr, ptr %ie, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then8
  %7 = load ptr, ptr %ie, align 8
  %arg_type10 = getelementptr inbounds %struct.IOCTLEntry, ptr %7, i32 0, i32 5
  %arraydecay = getelementptr inbounds [5 x i32], ptr %arg_type10, i64 0, i64 0
  store ptr %arraydecay, ptr %arg_type, align 8
  %8 = load ptr, ptr %ie, align 8
  %do_ioctl = getelementptr inbounds %struct.IOCTLEntry, ptr %8, i32 0, i32 4
  %9 = load ptr, ptr %do_ioctl, align 8
  %tobool11 = icmp ne ptr %9, null
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %for.end
  %10 = load ptr, ptr %ie, align 8
  %do_ioctl13 = getelementptr inbounds %struct.IOCTLEntry, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %do_ioctl13, align 8
  %12 = load ptr, ptr %ie, align 8
  %arraydecay14 = getelementptr inbounds [4096 x i8], ptr %buf_temp, i64 0, i64 0
  %13 = load i32, ptr %fd.addr, align 4
  %14 = load i32, ptr %cmd.addr, align 4
  %15 = load i64, ptr %arg.addr, align 8
  %call15 = call i64 %11(ptr noundef %12, ptr noundef %arraydecay14, i32 noundef %13, i32 noundef %14, i64 noundef %15)
  store i64 %call15, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %for.end
  %16 = load ptr, ptr %ie, align 8
  %host_cmd = getelementptr inbounds %struct.IOCTLEntry, ptr %16, i32 0, i32 1
  %17 = load i32, ptr %host_cmd, align 4
  %tobool16 = icmp ne i32 %17, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.else
  store i64 -25, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %if.else
  br label %if.end19

if.end19:                                         ; preds = %if.end18
  %18 = load ptr, ptr %arg_type, align 8
  %arrayidx = getelementptr i32, ptr %18, i64 0
  %19 = load i32, ptr %arrayidx, align 4
  switch i32 %19, label %sw.default91 [
    i32 0, label %sw.bb
    i32 6, label %sw.bb23
    i32 3, label %sw.bb23
    i32 4, label %sw.bb23
    i32 5, label %sw.bb23
    i32 9, label %sw.bb29
  ]

sw.bb:                                            ; preds = %if.end19
  %20 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %21 = load ptr, ptr %20, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %21, i32 0, i32 39
  %22 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %22, i32 0, i32 14
  %23 = load i32, ptr %fd.addr, align 4
  %24 = load ptr, ptr %ie, align 8
  %host_cmd20 = getelementptr inbounds %struct.IOCTLEntry, ptr %24, i32 0, i32 1
  %25 = load i32, ptr %host_cmd20, align 4
  %call21 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 16, i32 noundef %23, i32 noundef %25)
  %call22 = call i64 @get_errno(i64 noundef %call21)
  store i64 %call22, ptr %ret, align 8
  br label %sw.epilog105

sw.bb23:                                          ; preds = %if.end19, %if.end19, %if.end19, %if.end19
  %26 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %27 = load ptr, ptr %26, align 8
  %opaque24 = getelementptr inbounds %struct.CPUState, ptr %27, i32 0, i32 39
  %28 = load ptr, ptr %opaque24, align 16
  %signal_pending25 = getelementptr inbounds %struct.TaskState, ptr %28, i32 0, i32 14
  %29 = load i32, ptr %fd.addr, align 4
  %30 = load ptr, ptr %ie, align 8
  %host_cmd26 = getelementptr inbounds %struct.IOCTLEntry, ptr %30, i32 0, i32 1
  %31 = load i32, ptr %host_cmd26, align 4
  %32 = load i64, ptr %arg.addr, align 8
  %call27 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending25, i64 noundef 16, i32 noundef %29, i32 noundef %31, i64 noundef %32)
  %call28 = call i64 @get_errno(i64 noundef %call27)
  store i64 %call28, ptr %ret, align 8
  br label %sw.epilog105

sw.bb29:                                          ; preds = %if.end19
  %33 = load ptr, ptr %arg_type, align 8
  %incdec.ptr30 = getelementptr i32, ptr %33, i32 1
  store ptr %incdec.ptr30, ptr %arg_type, align 8
  %34 = load ptr, ptr %arg_type, align 8
  %call31 = call i32 @thunk_type_size(ptr noundef %34, i32 noundef 0)
  store i32 %call31, ptr %target_size, align 4
  %35 = load ptr, ptr %ie, align 8
  %access = getelementptr inbounds %struct.IOCTLEntry, ptr %35, i32 0, i32 3
  %36 = load i32, ptr %access, align 8
  switch i32 %36, label %sw.default [
    i32 1, label %sw.bb32
    i32 2, label %sw.bb51
    i32 3, label %sw.bb65
  ]

sw.bb32:                                          ; preds = %sw.bb29
  %37 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %38 = load ptr, ptr %37, align 8
  %opaque33 = getelementptr inbounds %struct.CPUState, ptr %38, i32 0, i32 39
  %39 = load ptr, ptr %opaque33, align 16
  %signal_pending34 = getelementptr inbounds %struct.TaskState, ptr %39, i32 0, i32 14
  %40 = load i32, ptr %fd.addr, align 4
  %41 = load ptr, ptr %ie, align 8
  %host_cmd35 = getelementptr inbounds %struct.IOCTLEntry, ptr %41, i32 0, i32 1
  %42 = load i32, ptr %host_cmd35, align 4
  %arraydecay36 = getelementptr inbounds [4096 x i8], ptr %buf_temp, i64 0, i64 0
  %call37 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending34, i64 noundef 16, i32 noundef %40, i32 noundef %42, ptr noundef %arraydecay36)
  %call38 = call i64 @get_errno(i64 noundef %call37)
  store i64 %call38, ptr %ret, align 8
  %43 = load i64, ptr %ret, align 8
  %call39 = call i32 @is_error(i64 noundef %43)
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.end50, label %if.then41

if.then41:                                        ; preds = %sw.bb32
  %44 = load i64, ptr %arg.addr, align 8
  %45 = load i32, ptr %target_size, align 4
  %conv42 = sext i32 %45 to i64
  %call43 = call ptr @lock_user(i32 noundef 3, i64 noundef %44, i64 noundef %conv42, i1 noundef zeroext false)
  store ptr %call43, ptr %argptr, align 8
  %46 = load ptr, ptr %argptr, align 8
  %tobool44 = icmp ne ptr %46, null
  br i1 %tobool44, label %if.end46, label %if.then45

if.then45:                                        ; preds = %if.then41
  store i64 -14, ptr %retval, align 8
  br label %return

if.end46:                                         ; preds = %if.then41
  %47 = load ptr, ptr %argptr, align 8
  %arraydecay47 = getelementptr inbounds [4096 x i8], ptr %buf_temp, i64 0, i64 0
  %48 = load ptr, ptr %arg_type, align 8
  %call48 = call ptr @thunk_convert(ptr noundef %47, ptr noundef %arraydecay47, ptr noundef %48, i32 noundef 0)
  %49 = load ptr, ptr %argptr, align 8
  %50 = load i64, ptr %arg.addr, align 8
  %51 = load i32, ptr %target_size, align 4
  %conv49 = sext i32 %51 to i64
  call void @unlock_user(ptr noundef %49, i64 noundef %50, i64 noundef %conv49)
  br label %if.end50

if.end50:                                         ; preds = %if.end46, %sw.bb32
  br label %sw.epilog

sw.bb51:                                          ; preds = %sw.bb29
  %52 = load i64, ptr %arg.addr, align 8
  %53 = load i32, ptr %target_size, align 4
  %conv52 = sext i32 %53 to i64
  %call53 = call ptr @lock_user(i32 noundef 1, i64 noundef %52, i64 noundef %conv52, i1 noundef zeroext true)
  store ptr %call53, ptr %argptr, align 8
  %54 = load ptr, ptr %argptr, align 8
  %tobool54 = icmp ne ptr %54, null
  br i1 %tobool54, label %if.end56, label %if.then55

if.then55:                                        ; preds = %sw.bb51
  store i64 -14, ptr %retval, align 8
  br label %return

if.end56:                                         ; preds = %sw.bb51
  %arraydecay57 = getelementptr inbounds [4096 x i8], ptr %buf_temp, i64 0, i64 0
  %55 = load ptr, ptr %argptr, align 8
  %56 = load ptr, ptr %arg_type, align 8
  %call58 = call ptr @thunk_convert(ptr noundef %arraydecay57, ptr noundef %55, ptr noundef %56, i32 noundef 1)
  %57 = load ptr, ptr %argptr, align 8
  %58 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %57, i64 noundef %58, i64 noundef 0)
  %59 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %60 = load ptr, ptr %59, align 8
  %opaque59 = getelementptr inbounds %struct.CPUState, ptr %60, i32 0, i32 39
  %61 = load ptr, ptr %opaque59, align 16
  %signal_pending60 = getelementptr inbounds %struct.TaskState, ptr %61, i32 0, i32 14
  %62 = load i32, ptr %fd.addr, align 4
  %63 = load ptr, ptr %ie, align 8
  %host_cmd61 = getelementptr inbounds %struct.IOCTLEntry, ptr %63, i32 0, i32 1
  %64 = load i32, ptr %host_cmd61, align 4
  %arraydecay62 = getelementptr inbounds [4096 x i8], ptr %buf_temp, i64 0, i64 0
  %call63 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending60, i64 noundef 16, i32 noundef %62, i32 noundef %64, ptr noundef %arraydecay62)
  %call64 = call i64 @get_errno(i64 noundef %call63)
  store i64 %call64, ptr %ret, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %sw.bb29
  br label %sw.bb65

sw.bb65:                                          ; preds = %sw.default, %sw.bb29
  %65 = load i64, ptr %arg.addr, align 8
  %66 = load i32, ptr %target_size, align 4
  %conv66 = sext i32 %66 to i64
  %call67 = call ptr @lock_user(i32 noundef 1, i64 noundef %65, i64 noundef %conv66, i1 noundef zeroext true)
  store ptr %call67, ptr %argptr, align 8
  %67 = load ptr, ptr %argptr, align 8
  %tobool68 = icmp ne ptr %67, null
  br i1 %tobool68, label %if.end70, label %if.then69

if.then69:                                        ; preds = %sw.bb65
  store i64 -14, ptr %retval, align 8
  br label %return

if.end70:                                         ; preds = %sw.bb65
  %arraydecay71 = getelementptr inbounds [4096 x i8], ptr %buf_temp, i64 0, i64 0
  %68 = load ptr, ptr %argptr, align 8
  %69 = load ptr, ptr %arg_type, align 8
  %call72 = call ptr @thunk_convert(ptr noundef %arraydecay71, ptr noundef %68, ptr noundef %69, i32 noundef 1)
  %70 = load ptr, ptr %argptr, align 8
  %71 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %70, i64 noundef %71, i64 noundef 0)
  %72 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %73 = load ptr, ptr %72, align 8
  %opaque73 = getelementptr inbounds %struct.CPUState, ptr %73, i32 0, i32 39
  %74 = load ptr, ptr %opaque73, align 16
  %signal_pending74 = getelementptr inbounds %struct.TaskState, ptr %74, i32 0, i32 14
  %75 = load i32, ptr %fd.addr, align 4
  %76 = load ptr, ptr %ie, align 8
  %host_cmd75 = getelementptr inbounds %struct.IOCTLEntry, ptr %76, i32 0, i32 1
  %77 = load i32, ptr %host_cmd75, align 4
  %arraydecay76 = getelementptr inbounds [4096 x i8], ptr %buf_temp, i64 0, i64 0
  %call77 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending74, i64 noundef 16, i32 noundef %75, i32 noundef %77, ptr noundef %arraydecay76)
  %call78 = call i64 @get_errno(i64 noundef %call77)
  store i64 %call78, ptr %ret, align 8
  %78 = load i64, ptr %ret, align 8
  %call79 = call i32 @is_error(i64 noundef %78)
  %tobool80 = icmp ne i32 %call79, 0
  br i1 %tobool80, label %if.end90, label %if.then81

if.then81:                                        ; preds = %if.end70
  %79 = load i64, ptr %arg.addr, align 8
  %80 = load i32, ptr %target_size, align 4
  %conv82 = sext i32 %80 to i64
  %call83 = call ptr @lock_user(i32 noundef 3, i64 noundef %79, i64 noundef %conv82, i1 noundef zeroext false)
  store ptr %call83, ptr %argptr, align 8
  %81 = load ptr, ptr %argptr, align 8
  %tobool84 = icmp ne ptr %81, null
  br i1 %tobool84, label %if.end86, label %if.then85

if.then85:                                        ; preds = %if.then81
  store i64 -14, ptr %retval, align 8
  br label %return

if.end86:                                         ; preds = %if.then81
  %82 = load ptr, ptr %argptr, align 8
  %arraydecay87 = getelementptr inbounds [4096 x i8], ptr %buf_temp, i64 0, i64 0
  %83 = load ptr, ptr %arg_type, align 8
  %call88 = call ptr @thunk_convert(ptr noundef %82, ptr noundef %arraydecay87, ptr noundef %83, i32 noundef 0)
  %84 = load ptr, ptr %argptr, align 8
  %85 = load i64, ptr %arg.addr, align 8
  %86 = load i32, ptr %target_size, align 4
  %conv89 = sext i32 %86 to i64
  call void @unlock_user(ptr noundef %84, i64 noundef %85, i64 noundef %conv89)
  br label %if.end90

if.end90:                                         ; preds = %if.end86, %if.end70
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end90, %if.end56, %if.end50
  br label %sw.epilog105

sw.default91:                                     ; preds = %if.end19
  br label %do.body92

do.body92:                                        ; preds = %sw.default91
  %call93 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 1024)
  %lnot94 = xor i1 %call93, true
  %lnot96 = xor i1 %lnot94, true
  %lnot.ext97 = zext i1 %lnot96 to i32
  %conv98 = sext i32 %lnot.ext97 to i64
  %tobool99 = icmp ne i64 %conv98, 0
  br i1 %tobool99, label %if.then100, label %if.end103

if.then100:                                       ; preds = %do.body92
  %87 = load i32, ptr %cmd.addr, align 4
  %conv101 = sext i32 %87 to i64
  %88 = load ptr, ptr %arg_type, align 8
  %arrayidx102 = getelementptr i32, ptr %88, i64 0
  %89 = load i32, ptr %arrayidx102, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.632, i64 noundef %conv101, i32 noundef %89)
  br label %if.end103

if.end103:                                        ; preds = %if.then100, %do.body92
  br label %do.end104

do.end104:                                        ; preds = %if.end103
  store i64 -25, ptr %ret, align 8
  br label %sw.epilog105

sw.epilog105:                                     ; preds = %do.end104, %sw.epilog, %sw.bb23, %sw.bb
  %90 = load i64, ptr %ret, align 8
  store i64 %90, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog105, %if.then85, %if.then69, %if.then55, %if.then45, %if.then17, %if.then12, %do.end
  %91 = load i64, ptr %retval, align 8
  ret i64 %91
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_fcntl(i32 noundef %fd, i32 noundef %cmd, i64 noundef %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %fd.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %fl64 = alloca %struct.flock64, align 8
  %fox = alloca %struct.f_owner_ex, align 4
  %target_fox = alloca ptr, align 8
  %ret = alloca i64, align 8
  %host_cmd = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load i32, ptr %cmd.addr, align 4
  %call = call i32 @target_to_host_fcntl_cmd(i32 noundef %0)
  store i32 %call, ptr %host_cmd, align 4
  %1 = load i32, ptr %host_cmd, align 4
  %cmp = icmp eq i32 %1, -22
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %host_cmd, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %cmd.addr, align 4
  switch i32 %3, label %sw.default [
    i32 5, label %sw.bb
    i32 6, label %sw.bb11
    i32 7, label %sw.bb11
    i32 12, label %sw.bb20
    i32 36, label %sw.bb20
    i32 13, label %sw.bb34
    i32 14, label %sw.bb34
    i32 37, label %sw.bb34
    i32 38, label %sw.bb34
    i32 3, label %sw.bb43
    i32 4, label %sw.bb55
    i32 16, label %sw.bb62
    i32 15, label %sw.bb79
    i32 10, label %sw.bb94
    i32 11, label %sw.bb101
    i32 8, label %sw.bb109
    i32 9, label %sw.bb109
    i32 1024, label %sw.bb109
    i32 1025, label %sw.bb109
    i32 1031, label %sw.bb109
    i32 1032, label %sw.bb109
    i32 1033, label %sw.bb109
    i32 1034, label %sw.bb109
  ]

sw.bb:                                            ; preds = %if.end
  %4 = load i64, ptr %arg.addr, align 8
  %call1 = call i64 @copy_from_user_flock(ptr noundef %fl64, i64 noundef %4)
  store i64 %call1, ptr %ret, align 8
  %5 = load i64, ptr %ret, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %sw.bb
  %6 = load i64, ptr %ret, align 8
  store i64 %6, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %sw.bb
  %7 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %8 = load ptr, ptr %7, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %8, i32 0, i32 39
  %9 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %9, i32 0, i32 14
  %10 = load i32, ptr %fd.addr, align 4
  %11 = load i32, ptr %host_cmd, align 4
  %call4 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 72, i32 noundef %10, i32 noundef %11, ptr noundef %fl64)
  %call5 = call i64 @get_errno(i64 noundef %call4)
  store i64 %call5, ptr %ret, align 8
  %12 = load i64, ptr %ret, align 8
  %cmp6 = icmp eq i64 %12, 0
  br i1 %cmp6, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end3
  %13 = load i64, ptr %arg.addr, align 8
  %call9 = call i64 @copy_to_user_flock(i64 noundef %13, ptr noundef %fl64)
  store i64 %call9, ptr %ret, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end3
  br label %sw.epilog

sw.bb11:                                          ; preds = %if.end, %if.end
  %14 = load i64, ptr %arg.addr, align 8
  %call12 = call i64 @copy_from_user_flock(ptr noundef %fl64, i64 noundef %14)
  store i64 %call12, ptr %ret, align 8
  %15 = load i64, ptr %ret, align 8
  %tobool13 = icmp ne i64 %15, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %sw.bb11
  %16 = load i64, ptr %ret, align 8
  store i64 %16, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %sw.bb11
  %17 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %18 = load ptr, ptr %17, align 8
  %opaque16 = getelementptr inbounds %struct.CPUState, ptr %18, i32 0, i32 39
  %19 = load ptr, ptr %opaque16, align 16
  %signal_pending17 = getelementptr inbounds %struct.TaskState, ptr %19, i32 0, i32 14
  %20 = load i32, ptr %fd.addr, align 4
  %21 = load i32, ptr %host_cmd, align 4
  %call18 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending17, i64 noundef 72, i32 noundef %20, i32 noundef %21, ptr noundef %fl64)
  %call19 = call i64 @get_errno(i64 noundef %call18)
  store i64 %call19, ptr %ret, align 8
  br label %sw.epilog

sw.bb20:                                          ; preds = %if.end, %if.end
  %22 = load i64, ptr %arg.addr, align 8
  %call21 = call i64 @copy_from_user_flock64(ptr noundef %fl64, i64 noundef %22)
  store i64 %call21, ptr %ret, align 8
  %23 = load i64, ptr %ret, align 8
  %tobool22 = icmp ne i64 %23, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %sw.bb20
  %24 = load i64, ptr %ret, align 8
  store i64 %24, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %sw.bb20
  %25 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %26 = load ptr, ptr %25, align 8
  %opaque25 = getelementptr inbounds %struct.CPUState, ptr %26, i32 0, i32 39
  %27 = load ptr, ptr %opaque25, align 16
  %signal_pending26 = getelementptr inbounds %struct.TaskState, ptr %27, i32 0, i32 14
  %28 = load i32, ptr %fd.addr, align 4
  %29 = load i32, ptr %host_cmd, align 4
  %call27 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending26, i64 noundef 72, i32 noundef %28, i32 noundef %29, ptr noundef %fl64)
  %call28 = call i64 @get_errno(i64 noundef %call27)
  store i64 %call28, ptr %ret, align 8
  %30 = load i64, ptr %ret, align 8
  %cmp29 = icmp eq i64 %30, 0
  br i1 %cmp29, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end24
  %31 = load i64, ptr %arg.addr, align 8
  %call32 = call i64 @copy_to_user_flock64(i64 noundef %31, ptr noundef %fl64)
  store i64 %call32, ptr %ret, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end24
  br label %sw.epilog

sw.bb34:                                          ; preds = %if.end, %if.end, %if.end, %if.end
  %32 = load i64, ptr %arg.addr, align 8
  %call35 = call i64 @copy_from_user_flock64(ptr noundef %fl64, i64 noundef %32)
  store i64 %call35, ptr %ret, align 8
  %33 = load i64, ptr %ret, align 8
  %tobool36 = icmp ne i64 %33, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %sw.bb34
  %34 = load i64, ptr %ret, align 8
  store i64 %34, ptr %retval, align 8
  br label %return

if.end38:                                         ; preds = %sw.bb34
  %35 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %36 = load ptr, ptr %35, align 8
  %opaque39 = getelementptr inbounds %struct.CPUState, ptr %36, i32 0, i32 39
  %37 = load ptr, ptr %opaque39, align 16
  %signal_pending40 = getelementptr inbounds %struct.TaskState, ptr %37, i32 0, i32 14
  %38 = load i32, ptr %fd.addr, align 4
  %39 = load i32, ptr %host_cmd, align 4
  %call41 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending40, i64 noundef 72, i32 noundef %38, i32 noundef %39, ptr noundef %fl64)
  %call42 = call i64 @get_errno(i64 noundef %call41)
  store i64 %call42, ptr %ret, align 8
  br label %sw.epilog

sw.bb43:                                          ; preds = %if.end
  %40 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %41 = load ptr, ptr %40, align 8
  %opaque44 = getelementptr inbounds %struct.CPUState, ptr %41, i32 0, i32 39
  %42 = load ptr, ptr %opaque44, align 16
  %signal_pending45 = getelementptr inbounds %struct.TaskState, ptr %42, i32 0, i32 14
  %43 = load i32, ptr %fd.addr, align 4
  %44 = load i32, ptr %host_cmd, align 4
  %45 = load i64, ptr %arg.addr, align 8
  %call46 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending45, i64 noundef 72, i32 noundef %43, i32 noundef %44, i64 noundef %45)
  %call47 = call i64 @get_errno(i64 noundef %call46)
  store i64 %call47, ptr %ret, align 8
  %46 = load i64, ptr %ret, align 8
  %cmp48 = icmp sge i64 %46, 0
  br i1 %cmp48, label %if.then50, label %if.end54

if.then50:                                        ; preds = %sw.bb43
  %47 = load i64, ptr %ret, align 8
  %conv51 = trunc i64 %47 to i32
  %call52 = call i32 @host_to_target_bitmask_len(i32 noundef %conv51, ptr noundef @fcntl_flags_tbl, i64 noundef 19)
  %conv53 = zext i32 %call52 to i64
  store i64 %conv53, ptr %ret, align 8
  %48 = load i64, ptr %ret, align 8
  %or = or i64 %48, 32768
  store i64 %or, ptr %ret, align 8
  br label %if.end54

if.end54:                                         ; preds = %if.then50, %sw.bb43
  br label %sw.epilog

sw.bb55:                                          ; preds = %if.end
  %49 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %50 = load ptr, ptr %49, align 8
  %opaque56 = getelementptr inbounds %struct.CPUState, ptr %50, i32 0, i32 39
  %51 = load ptr, ptr %opaque56, align 16
  %signal_pending57 = getelementptr inbounds %struct.TaskState, ptr %51, i32 0, i32 14
  %52 = load i32, ptr %fd.addr, align 4
  %53 = load i32, ptr %host_cmd, align 4
  %54 = load i64, ptr %arg.addr, align 8
  %conv58 = trunc i64 %54 to i32
  %call59 = call i32 @target_to_host_bitmask_len(i32 noundef %conv58, ptr noundef @fcntl_flags_tbl, i64 noundef 19)
  %call60 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending57, i64 noundef 72, i32 noundef %52, i32 noundef %53, i32 noundef %call59)
  %call61 = call i64 @get_errno(i64 noundef %call60)
  store i64 %call61, ptr %ret, align 8
  br label %sw.epilog

sw.bb62:                                          ; preds = %if.end
  %55 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %56 = load ptr, ptr %55, align 8
  %opaque63 = getelementptr inbounds %struct.CPUState, ptr %56, i32 0, i32 39
  %57 = load ptr, ptr %opaque63, align 16
  %signal_pending64 = getelementptr inbounds %struct.TaskState, ptr %57, i32 0, i32 14
  %58 = load i32, ptr %fd.addr, align 4
  %59 = load i32, ptr %host_cmd, align 4
  %call65 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending64, i64 noundef 72, i32 noundef %58, i32 noundef %59, ptr noundef %fox)
  %call66 = call i64 @get_errno(i64 noundef %call65)
  store i64 %call66, ptr %ret, align 8
  %60 = load i64, ptr %ret, align 8
  %cmp67 = icmp sge i64 %60, 0
  br i1 %cmp67, label %if.then69, label %if.end78

if.then69:                                        ; preds = %sw.bb62
  %61 = load i64, ptr %arg.addr, align 8
  %call70 = call ptr @lock_user(i32 noundef 3, i64 noundef %61, i64 noundef 8, i1 noundef zeroext false)
  store ptr %call70, ptr %target_fox, align 8
  %tobool71 = icmp ne ptr %call70, null
  br i1 %tobool71, label %if.end73, label %if.then72

if.then72:                                        ; preds = %if.then69
  store i64 -14, ptr %retval, align 8
  br label %return

if.end73:                                         ; preds = %if.then69
  %type = getelementptr inbounds %struct.f_owner_ex, ptr %fox, i32 0, i32 0
  %62 = load i32, ptr %type, align 4
  %call74 = call i32 @tswap32(i32 noundef %62)
  %63 = load ptr, ptr %target_fox, align 8
  %type75 = getelementptr inbounds %struct.target_f_owner_ex, ptr %63, i32 0, i32 0
  store i32 %call74, ptr %type75, align 4
  %pid = getelementptr inbounds %struct.f_owner_ex, ptr %fox, i32 0, i32 1
  %64 = load i32, ptr %pid, align 4
  %call76 = call i32 @tswap32(i32 noundef %64)
  %65 = load ptr, ptr %target_fox, align 8
  %pid77 = getelementptr inbounds %struct.target_f_owner_ex, ptr %65, i32 0, i32 1
  store i32 %call76, ptr %pid77, align 4
  %66 = load ptr, ptr %target_fox, align 8
  %67 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %66, i64 noundef %67, i64 noundef 8)
  br label %if.end78

if.end78:                                         ; preds = %if.end73, %sw.bb62
  br label %sw.epilog

sw.bb79:                                          ; preds = %if.end
  %68 = load i64, ptr %arg.addr, align 8
  %call80 = call ptr @lock_user(i32 noundef 1, i64 noundef %68, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call80, ptr %target_fox, align 8
  %tobool81 = icmp ne ptr %call80, null
  br i1 %tobool81, label %if.end83, label %if.then82

if.then82:                                        ; preds = %sw.bb79
  store i64 -14, ptr %retval, align 8
  br label %return

if.end83:                                         ; preds = %sw.bb79
  %69 = load ptr, ptr %target_fox, align 8
  %type84 = getelementptr inbounds %struct.target_f_owner_ex, ptr %69, i32 0, i32 0
  %70 = load i32, ptr %type84, align 4
  %call85 = call i32 @tswap32(i32 noundef %70)
  %type86 = getelementptr inbounds %struct.f_owner_ex, ptr %fox, i32 0, i32 0
  store i32 %call85, ptr %type86, align 4
  %71 = load ptr, ptr %target_fox, align 8
  %pid87 = getelementptr inbounds %struct.target_f_owner_ex, ptr %71, i32 0, i32 1
  %72 = load i32, ptr %pid87, align 4
  %call88 = call i32 @tswap32(i32 noundef %72)
  %pid89 = getelementptr inbounds %struct.f_owner_ex, ptr %fox, i32 0, i32 1
  store i32 %call88, ptr %pid89, align 4
  %73 = load ptr, ptr %target_fox, align 8
  %74 = load i64, ptr %arg.addr, align 8
  call void @unlock_user(ptr noundef %73, i64 noundef %74, i64 noundef 0)
  %75 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %76 = load ptr, ptr %75, align 8
  %opaque90 = getelementptr inbounds %struct.CPUState, ptr %76, i32 0, i32 39
  %77 = load ptr, ptr %opaque90, align 16
  %signal_pending91 = getelementptr inbounds %struct.TaskState, ptr %77, i32 0, i32 14
  %78 = load i32, ptr %fd.addr, align 4
  %79 = load i32, ptr %host_cmd, align 4
  %call92 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending91, i64 noundef 72, i32 noundef %78, i32 noundef %79, ptr noundef %fox)
  %call93 = call i64 @get_errno(i64 noundef %call92)
  store i64 %call93, ptr %ret, align 8
  br label %sw.epilog

sw.bb94:                                          ; preds = %if.end
  %80 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %81 = load ptr, ptr %80, align 8
  %opaque95 = getelementptr inbounds %struct.CPUState, ptr %81, i32 0, i32 39
  %82 = load ptr, ptr %opaque95, align 16
  %signal_pending96 = getelementptr inbounds %struct.TaskState, ptr %82, i32 0, i32 14
  %83 = load i32, ptr %fd.addr, align 4
  %84 = load i32, ptr %host_cmd, align 4
  %85 = load i64, ptr %arg.addr, align 8
  %conv97 = trunc i64 %85 to i32
  %call98 = call i32 @target_to_host_signal(i32 noundef %conv97)
  %call99 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending96, i64 noundef 72, i32 noundef %83, i32 noundef %84, i32 noundef %call98)
  %call100 = call i64 @get_errno(i64 noundef %call99)
  store i64 %call100, ptr %ret, align 8
  br label %sw.epilog

sw.bb101:                                         ; preds = %if.end
  %86 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %87 = load ptr, ptr %86, align 8
  %opaque102 = getelementptr inbounds %struct.CPUState, ptr %87, i32 0, i32 39
  %88 = load ptr, ptr %opaque102, align 16
  %signal_pending103 = getelementptr inbounds %struct.TaskState, ptr %88, i32 0, i32 14
  %89 = load i32, ptr %fd.addr, align 4
  %90 = load i32, ptr %host_cmd, align 4
  %91 = load i64, ptr %arg.addr, align 8
  %call104 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending103, i64 noundef 72, i32 noundef %89, i32 noundef %90, i64 noundef %91)
  %call105 = call i64 @get_errno(i64 noundef %call104)
  %conv106 = trunc i64 %call105 to i32
  %call107 = call i32 @host_to_target_signal(i32 noundef %conv106)
  %conv108 = sext i32 %call107 to i64
  store i64 %conv108, ptr %ret, align 8
  br label %sw.epilog

sw.bb109:                                         ; preds = %if.end, %if.end, %if.end, %if.end, %if.end, %if.end, %if.end, %if.end
  %92 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %93 = load ptr, ptr %92, align 8
  %opaque110 = getelementptr inbounds %struct.CPUState, ptr %93, i32 0, i32 39
  %94 = load ptr, ptr %opaque110, align 16
  %signal_pending111 = getelementptr inbounds %struct.TaskState, ptr %94, i32 0, i32 14
  %95 = load i32, ptr %fd.addr, align 4
  %96 = load i32, ptr %host_cmd, align 4
  %97 = load i64, ptr %arg.addr, align 8
  %call112 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending111, i64 noundef 72, i32 noundef %95, i32 noundef %96, i64 noundef %97)
  %call113 = call i64 @get_errno(i64 noundef %call112)
  store i64 %call113, ptr %ret, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  %98 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %99 = load ptr, ptr %98, align 8
  %opaque114 = getelementptr inbounds %struct.CPUState, ptr %99, i32 0, i32 39
  %100 = load ptr, ptr %opaque114, align 16
  %signal_pending115 = getelementptr inbounds %struct.TaskState, ptr %100, i32 0, i32 14
  %101 = load i32, ptr %fd.addr, align 4
  %102 = load i32, ptr %cmd.addr, align 4
  %103 = load i64, ptr %arg.addr, align 8
  %call116 = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending115, i64 noundef 72, i32 noundef %101, i32 noundef %102, i64 noundef %103)
  %call117 = call i64 @get_errno(i64 noundef %call116)
  store i64 %call117, ptr %ret, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb109, %sw.bb101, %sw.bb94, %if.end83, %if.end78, %sw.bb55, %if.end54, %if.end38, %if.end33, %if.end15, %if.end10
  %104 = load i64, ptr %ret, align 8
  store i64 %104, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %if.then82, %if.then72, %if.then37, %if.then23, %if.then14, %if.then2, %if.then
  %105 = load i64, ptr %retval, align 8
  ret i64 %105
}

; Function Attrs: nounwind
declare i32 @setpgid(i32 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @umask(i32 noundef) #2

; Function Attrs: nounwind
declare i32 @chroot(ptr noundef) #2

; Function Attrs: nounwind
declare i32 @dup3(i32 noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @setsid() #2

declare i32 @do_sigaction(i32 noundef, ptr noundef, ptr noundef, i64 noundef) #3

declare void @target_to_host_sigset(ptr noundef, ptr noundef) #3

declare i32 @do_sigprocmask(i32 noundef, ptr noundef, ptr noundef) #3

declare void @host_to_target_sigset(ptr noundef, ptr noundef) #3

; Function Attrs: nounwind
declare i32 @sigpending(ptr noundef) #2

declare i32 @process_sigsuspend_mask(ptr noundef, i64 noundef, i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_rt_sigsuspend(ptr noundef %newset, i64 noundef %sigsetsize) #0 {
entry:
  %newset.addr = alloca ptr, align 8
  %sigsetsize.addr = alloca i64, align 8
  store ptr %newset, ptr %newset.addr, align 8
  store i64 %sigsetsize, ptr %sigsetsize.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load ptr, ptr %newset.addr, align 8
  %4 = load i64, ptr %sigsetsize.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 130, ptr noundef %3, i64 noundef %4)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @finish_sigsuspend_mask(i32 noundef %ret) #0 {
entry:
  %ret.addr = alloca i32, align 4
  %ts = alloca ptr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load i32, ptr %ret.addr, align 4
  %cmp = icmp ne i32 %0, -512
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %2 = load ptr, ptr %1, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %2, i32 0, i32 39
  %3 = load ptr, ptr %opaque, align 16
  store ptr %3, ptr %ts, align 8
  %4 = load ptr, ptr %ts, align 8
  %in_sigsuspend = getelementptr inbounds %struct.TaskState, ptr %4, i32 0, i32 13
  store i32 1, ptr %in_sigsuspend, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_timespec(ptr noundef %host_ts, i64 noundef %target_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %host_ts.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %target_ts = alloca ptr, align 8
  store ptr %host_ts, ptr %host_ts.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 16, i1 noundef zeroext true)
  store ptr %call, ptr %target_ts, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_ts, align 8
  %tv_sec = getelementptr inbounds %struct.target_timespec, ptr %1, i32 0, i32 0
  %call1 = call i64 @ldq_le_p(ptr noundef %tv_sec)
  %2 = load ptr, ptr %host_ts.addr, align 8
  %tv_sec2 = getelementptr inbounds %struct.timespec, ptr %2, i32 0, i32 0
  store i64 %call1, ptr %tv_sec2, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body3

do.body3:                                         ; preds = %do.end
  %3 = load ptr, ptr %target_ts, align 8
  %tv_nsec = getelementptr inbounds %struct.target_timespec, ptr %3, i32 0, i32 1
  %call4 = call i64 @ldq_le_p(ptr noundef %tv_nsec)
  %4 = load ptr, ptr %host_ts.addr, align 8
  %tv_nsec5 = getelementptr inbounds %struct.timespec, ptr %4, i32 0, i32 1
  store i64 %call4, ptr %tv_nsec5, align 8
  br label %do.end6

do.end6:                                          ; preds = %do.body3
  %5 = load ptr, ptr %target_ts, align 8
  %6 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %5, i64 noundef %6, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end6, %if.then
  %7 = load i64, ptr %retval, align 8
  ret i64 %7
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_rt_sigtimedwait(ptr noundef %these, ptr noundef %uinfo, ptr noundef %uts, i64 noundef %sigsetsize) #0 {
entry:
  %these.addr = alloca ptr, align 8
  %uinfo.addr = alloca ptr, align 8
  %uts.addr = alloca ptr, align 8
  %sigsetsize.addr = alloca i64, align 8
  store ptr %these, ptr %these.addr, align 8
  store ptr %uinfo, ptr %uinfo.addr, align 8
  store ptr %uts, ptr %uts.addr, align 8
  store i64 %sigsetsize, ptr %sigsetsize.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load ptr, ptr %these.addr, align 8
  %4 = load ptr, ptr %uinfo.addr, align 8
  %5 = load ptr, ptr %uts.addr, align 8
  %6 = load i64, ptr %sigsetsize.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 128, ptr noundef %3, ptr noundef %4, ptr noundef %5, i64 noundef %6)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_rt_sigqueueinfo(i32 noundef %pid, i32 noundef %sig, ptr noundef %uinfo) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %sig.addr = alloca i32, align 4
  %uinfo.addr = alloca ptr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %sig, ptr %sig.addr, align 4
  store ptr %uinfo, ptr %uinfo.addr, align 8
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load i32, ptr %sig.addr, align 4
  %2 = load ptr, ptr %uinfo.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 129, i32 noundef %0, i32 noundef %1, ptr noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_rt_tgsigqueueinfo(i32 noundef %pid, i32 noundef %tid, i32 noundef %sig, ptr noundef %uinfo) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %tid.addr = alloca i32, align 4
  %sig.addr = alloca i32, align 4
  %uinfo.addr = alloca ptr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %tid, ptr %tid.addr, align 4
  store i32 %sig, ptr %sig.addr, align 4
  store ptr %uinfo, ptr %uinfo.addr, align 8
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load i32, ptr %tid.addr, align 4
  %2 = load i32, ptr %sig.addr, align 4
  %3 = load ptr, ptr %uinfo.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 297, i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

declare i64 @do_rt_sigreturn(ptr noundef) #3

; Function Attrs: nounwind
declare i32 @sethostname(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @target_to_host_resource(i32 noundef %code) #0 {
entry:
  %retval = alloca i32, align 4
  %code.addr = alloca i32, align 4
  store i32 %code, ptr %code.addr, align 4
  %0 = load i32, ptr %code.addr, align 4
  switch i32 %0, label %sw.default [
    i32 9, label %sw.bb
    i32 4, label %sw.bb1
    i32 0, label %sw.bb2
    i32 2, label %sw.bb3
    i32 1, label %sw.bb4
    i32 10, label %sw.bb5
    i32 8, label %sw.bb6
    i32 12, label %sw.bb7
    i32 13, label %sw.bb8
    i32 7, label %sw.bb9
    i32 6, label %sw.bb10
    i32 5, label %sw.bb11
    i32 14, label %sw.bb12
    i32 15, label %sw.bb13
    i32 11, label %sw.bb14
    i32 3, label %sw.bb15
  ]

sw.bb:                                            ; preds = %entry
  store i32 9, ptr %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %entry
  store i32 4, ptr %retval, align 4
  br label %return

sw.bb2:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb3:                                           ; preds = %entry
  store i32 2, ptr %retval, align 4
  br label %return

sw.bb4:                                           ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb5:                                           ; preds = %entry
  store i32 10, ptr %retval, align 4
  br label %return

sw.bb6:                                           ; preds = %entry
  store i32 8, ptr %retval, align 4
  br label %return

sw.bb7:                                           ; preds = %entry
  store i32 12, ptr %retval, align 4
  br label %return

sw.bb8:                                           ; preds = %entry
  store i32 13, ptr %retval, align 4
  br label %return

sw.bb9:                                           ; preds = %entry
  store i32 7, ptr %retval, align 4
  br label %return

sw.bb10:                                          ; preds = %entry
  store i32 6, ptr %retval, align 4
  br label %return

sw.bb11:                                          ; preds = %entry
  store i32 5, ptr %retval, align 4
  br label %return

sw.bb12:                                          ; preds = %entry
  store i32 14, ptr %retval, align 4
  br label %return

sw.bb13:                                          ; preds = %entry
  store i32 15, ptr %retval, align 4
  br label %return

sw.bb14:                                          ; preds = %entry
  store i32 11, ptr %retval, align 4
  br label %return

sw.bb15:                                          ; preds = %entry
  store i32 3, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  %1 = load i32, ptr %code.addr, align 4
  store i32 %1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %sw.bb15, %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_rlim(i64 noundef %target_rlim) #0 {
entry:
  %retval = alloca i64, align 8
  %target_rlim.addr = alloca i64, align 8
  %target_rlim_swap = alloca i64, align 8
  %result = alloca i64, align 8
  store i64 %target_rlim, ptr %target_rlim.addr, align 8
  %0 = load i64, ptr %target_rlim.addr, align 8
  %call = call i64 @tswapal(i64 noundef %0)
  store i64 %call, ptr %target_rlim_swap, align 8
  %1 = load i64, ptr %target_rlim_swap, align 8
  %cmp = icmp eq i64 %1, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %target_rlim_swap, align 8
  store i64 %2, ptr %result, align 8
  %3 = load i64, ptr %target_rlim_swap, align 8
  %4 = load i64, ptr %result, align 8
  %cmp1 = icmp ne i64 %3, %4
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i64 -1, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load i64, ptr %result, align 8
  store i64 %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %6 = load i64, ptr %retval, align 8
  ret i64 %6
}

; Function Attrs: nounwind
declare i32 @setrlimit64(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @getrlimit64(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_rlim(i64 noundef %rlim) #0 {
entry:
  %rlim.addr = alloca i64, align 8
  %target_rlim_swap = alloca i64, align 8
  %result = alloca i64, align 8
  store i64 %rlim, ptr %rlim.addr, align 8
  %0 = load i64, ptr %rlim.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %rlim.addr, align 8
  %2 = load i64, ptr %rlim.addr, align 8
  %cmp1 = icmp ne i64 %1, %2
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 -1, ptr %target_rlim_swap, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %3 = load i64, ptr %rlim.addr, align 8
  store i64 %3, ptr %target_rlim_swap, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %4 = load i64, ptr %target_rlim_swap, align 8
  %call = call i64 @tswapal(i64 noundef %4)
  store i64 %call, ptr %result, align 8
  %5 = load i64, ptr %result, align 8
  ret i64 %5
}

; Function Attrs: nounwind
declare i32 @getrusage(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_rusage(i64 noundef %target_addr, ptr noundef %rusage) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %rusage.addr = alloca ptr, align 8
  %target_rusage = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %rusage, ptr %rusage.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 144, i1 noundef zeroext false)
  store ptr %call, ptr %target_rusage, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %rusage.addr, align 8
  %ru_utime = getelementptr inbounds %struct.rusage, ptr %1, i32 0, i32 0
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %ru_utime, i32 0, i32 0
  %2 = load i64, ptr %tv_sec, align 8
  %call1 = call i64 @tswapal(i64 noundef %2)
  %3 = load ptr, ptr %target_rusage, align 8
  %ru_utime2 = getelementptr inbounds %struct.target_rusage, ptr %3, i32 0, i32 0
  %tv_sec3 = getelementptr inbounds %struct.target_timeval, ptr %ru_utime2, i32 0, i32 0
  store i64 %call1, ptr %tv_sec3, align 8
  %4 = load ptr, ptr %rusage.addr, align 8
  %ru_utime4 = getelementptr inbounds %struct.rusage, ptr %4, i32 0, i32 0
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %ru_utime4, i32 0, i32 1
  %5 = load i64, ptr %tv_usec, align 8
  %call5 = call i64 @tswapal(i64 noundef %5)
  %6 = load ptr, ptr %target_rusage, align 8
  %ru_utime6 = getelementptr inbounds %struct.target_rusage, ptr %6, i32 0, i32 0
  %tv_usec7 = getelementptr inbounds %struct.target_timeval, ptr %ru_utime6, i32 0, i32 1
  store i64 %call5, ptr %tv_usec7, align 8
  %7 = load ptr, ptr %rusage.addr, align 8
  %ru_stime = getelementptr inbounds %struct.rusage, ptr %7, i32 0, i32 1
  %tv_sec8 = getelementptr inbounds %struct.timeval, ptr %ru_stime, i32 0, i32 0
  %8 = load i64, ptr %tv_sec8, align 8
  %call9 = call i64 @tswapal(i64 noundef %8)
  %9 = load ptr, ptr %target_rusage, align 8
  %ru_stime10 = getelementptr inbounds %struct.target_rusage, ptr %9, i32 0, i32 1
  %tv_sec11 = getelementptr inbounds %struct.target_timeval, ptr %ru_stime10, i32 0, i32 0
  store i64 %call9, ptr %tv_sec11, align 8
  %10 = load ptr, ptr %rusage.addr, align 8
  %ru_stime12 = getelementptr inbounds %struct.rusage, ptr %10, i32 0, i32 1
  %tv_usec13 = getelementptr inbounds %struct.timeval, ptr %ru_stime12, i32 0, i32 1
  %11 = load i64, ptr %tv_usec13, align 8
  %call14 = call i64 @tswapal(i64 noundef %11)
  %12 = load ptr, ptr %target_rusage, align 8
  %ru_stime15 = getelementptr inbounds %struct.target_rusage, ptr %12, i32 0, i32 1
  %tv_usec16 = getelementptr inbounds %struct.target_timeval, ptr %ru_stime15, i32 0, i32 1
  store i64 %call14, ptr %tv_usec16, align 8
  %13 = load ptr, ptr %rusage.addr, align 8
  %14 = getelementptr inbounds %struct.rusage, ptr %13, i32 0, i32 2
  %15 = load i64, ptr %14, align 8
  %call17 = call i64 @tswapal(i64 noundef %15)
  %16 = load ptr, ptr %target_rusage, align 8
  %ru_maxrss = getelementptr inbounds %struct.target_rusage, ptr %16, i32 0, i32 2
  store i64 %call17, ptr %ru_maxrss, align 8
  %17 = load ptr, ptr %rusage.addr, align 8
  %18 = getelementptr inbounds %struct.rusage, ptr %17, i32 0, i32 3
  %19 = load i64, ptr %18, align 8
  %call18 = call i64 @tswapal(i64 noundef %19)
  %20 = load ptr, ptr %target_rusage, align 8
  %ru_ixrss = getelementptr inbounds %struct.target_rusage, ptr %20, i32 0, i32 3
  store i64 %call18, ptr %ru_ixrss, align 8
  %21 = load ptr, ptr %rusage.addr, align 8
  %22 = getelementptr inbounds %struct.rusage, ptr %21, i32 0, i32 4
  %23 = load i64, ptr %22, align 8
  %call19 = call i64 @tswapal(i64 noundef %23)
  %24 = load ptr, ptr %target_rusage, align 8
  %ru_idrss = getelementptr inbounds %struct.target_rusage, ptr %24, i32 0, i32 4
  store i64 %call19, ptr %ru_idrss, align 8
  %25 = load ptr, ptr %rusage.addr, align 8
  %26 = getelementptr inbounds %struct.rusage, ptr %25, i32 0, i32 5
  %27 = load i64, ptr %26, align 8
  %call20 = call i64 @tswapal(i64 noundef %27)
  %28 = load ptr, ptr %target_rusage, align 8
  %ru_isrss = getelementptr inbounds %struct.target_rusage, ptr %28, i32 0, i32 5
  store i64 %call20, ptr %ru_isrss, align 8
  %29 = load ptr, ptr %rusage.addr, align 8
  %30 = getelementptr inbounds %struct.rusage, ptr %29, i32 0, i32 6
  %31 = load i64, ptr %30, align 8
  %call21 = call i64 @tswapal(i64 noundef %31)
  %32 = load ptr, ptr %target_rusage, align 8
  %ru_minflt = getelementptr inbounds %struct.target_rusage, ptr %32, i32 0, i32 6
  store i64 %call21, ptr %ru_minflt, align 8
  %33 = load ptr, ptr %rusage.addr, align 8
  %34 = getelementptr inbounds %struct.rusage, ptr %33, i32 0, i32 7
  %35 = load i64, ptr %34, align 8
  %call22 = call i64 @tswapal(i64 noundef %35)
  %36 = load ptr, ptr %target_rusage, align 8
  %ru_majflt = getelementptr inbounds %struct.target_rusage, ptr %36, i32 0, i32 7
  store i64 %call22, ptr %ru_majflt, align 8
  %37 = load ptr, ptr %rusage.addr, align 8
  %38 = getelementptr inbounds %struct.rusage, ptr %37, i32 0, i32 8
  %39 = load i64, ptr %38, align 8
  %call23 = call i64 @tswapal(i64 noundef %39)
  %40 = load ptr, ptr %target_rusage, align 8
  %ru_nswap = getelementptr inbounds %struct.target_rusage, ptr %40, i32 0, i32 8
  store i64 %call23, ptr %ru_nswap, align 8
  %41 = load ptr, ptr %rusage.addr, align 8
  %42 = getelementptr inbounds %struct.rusage, ptr %41, i32 0, i32 9
  %43 = load i64, ptr %42, align 8
  %call24 = call i64 @tswapal(i64 noundef %43)
  %44 = load ptr, ptr %target_rusage, align 8
  %ru_inblock = getelementptr inbounds %struct.target_rusage, ptr %44, i32 0, i32 9
  store i64 %call24, ptr %ru_inblock, align 8
  %45 = load ptr, ptr %rusage.addr, align 8
  %46 = getelementptr inbounds %struct.rusage, ptr %45, i32 0, i32 10
  %47 = load i64, ptr %46, align 8
  %call25 = call i64 @tswapal(i64 noundef %47)
  %48 = load ptr, ptr %target_rusage, align 8
  %ru_oublock = getelementptr inbounds %struct.target_rusage, ptr %48, i32 0, i32 10
  store i64 %call25, ptr %ru_oublock, align 8
  %49 = load ptr, ptr %rusage.addr, align 8
  %50 = getelementptr inbounds %struct.rusage, ptr %49, i32 0, i32 11
  %51 = load i64, ptr %50, align 8
  %call26 = call i64 @tswapal(i64 noundef %51)
  %52 = load ptr, ptr %target_rusage, align 8
  %ru_msgsnd = getelementptr inbounds %struct.target_rusage, ptr %52, i32 0, i32 11
  store i64 %call26, ptr %ru_msgsnd, align 8
  %53 = load ptr, ptr %rusage.addr, align 8
  %54 = getelementptr inbounds %struct.rusage, ptr %53, i32 0, i32 12
  %55 = load i64, ptr %54, align 8
  %call27 = call i64 @tswapal(i64 noundef %55)
  %56 = load ptr, ptr %target_rusage, align 8
  %ru_msgrcv = getelementptr inbounds %struct.target_rusage, ptr %56, i32 0, i32 12
  store i64 %call27, ptr %ru_msgrcv, align 8
  %57 = load ptr, ptr %rusage.addr, align 8
  %58 = getelementptr inbounds %struct.rusage, ptr %57, i32 0, i32 13
  %59 = load i64, ptr %58, align 8
  %call28 = call i64 @tswapal(i64 noundef %59)
  %60 = load ptr, ptr %target_rusage, align 8
  %ru_nsignals = getelementptr inbounds %struct.target_rusage, ptr %60, i32 0, i32 13
  store i64 %call28, ptr %ru_nsignals, align 8
  %61 = load ptr, ptr %rusage.addr, align 8
  %62 = getelementptr inbounds %struct.rusage, ptr %61, i32 0, i32 14
  %63 = load i64, ptr %62, align 8
  %call29 = call i64 @tswapal(i64 noundef %63)
  %64 = load ptr, ptr %target_rusage, align 8
  %ru_nvcsw = getelementptr inbounds %struct.target_rusage, ptr %64, i32 0, i32 14
  store i64 %call29, ptr %ru_nvcsw, align 8
  %65 = load ptr, ptr %rusage.addr, align 8
  %66 = getelementptr inbounds %struct.rusage, ptr %65, i32 0, i32 15
  %67 = load i64, ptr %66, align 8
  %call30 = call i64 @tswapal(i64 noundef %67)
  %68 = load ptr, ptr %target_rusage, align 8
  %ru_nivcsw = getelementptr inbounds %struct.target_rusage, ptr %68, i32 0, i32 15
  store i64 %call30, ptr %ru_nivcsw, align 8
  %69 = load ptr, ptr %target_rusage, align 8
  %70 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %69, i64 noundef %70, i64 noundef 144)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %71 = load i64, ptr %retval, align 8
  ret i64 %71
}

; Function Attrs: nounwind
declare i32 @gettimeofday(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_to_user_timezone(i64 noundef %target_tz_addr, ptr noundef %tz) #0 {
entry:
  %retval = alloca i64, align 8
  %target_tz_addr.addr = alloca i64, align 8
  %tz.addr = alloca ptr, align 8
  %target_tz = alloca ptr, align 8
  store i64 %target_tz_addr, ptr %target_tz_addr.addr, align 8
  store ptr %tz, ptr %tz.addr, align 8
  %0 = load i64, ptr %target_tz_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call, ptr %target_tz, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_tz, align 8
  %tz_minuteswest = getelementptr inbounds %struct.target_timezone, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %tz.addr, align 8
  %tz_minuteswest1 = getelementptr inbounds %struct.timezone, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %tz_minuteswest1, align 4
  call void @stl_le_p(ptr noundef %tz_minuteswest, i32 noundef %3)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %4 = load ptr, ptr %target_tz, align 8
  %tz_dsttime = getelementptr inbounds %struct.target_timezone, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %tz.addr, align 8
  %tz_dsttime3 = getelementptr inbounds %struct.timezone, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %tz_dsttime3, align 4
  call void @stl_le_p(ptr noundef %tz_dsttime, i32 noundef %6)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  %7 = load ptr, ptr %target_tz, align 8
  %8 = load i64, ptr %target_tz_addr.addr, align 8
  call void @unlock_user(ptr noundef %7, i64 noundef %8, i64 noundef 8)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end4, %if.then
  %9 = load i64, ptr %retval, align 8
  ret i64 %9
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_from_user_timeval(ptr noundef %tv, i64 noundef %target_tv_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %tv.addr = alloca ptr, align 8
  %target_tv_addr.addr = alloca i64, align 8
  %target_tv = alloca ptr, align 8
  store ptr %tv, ptr %tv.addr, align 8
  store i64 %target_tv_addr, ptr %target_tv_addr.addr, align 8
  %0 = load i64, ptr %target_tv_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 16, i1 noundef zeroext true)
  store ptr %call, ptr %target_tv, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_tv, align 8
  %tv_sec = getelementptr inbounds %struct.target_timeval, ptr %1, i32 0, i32 0
  %call1 = call i64 @ldq_le_p(ptr noundef %tv_sec)
  %2 = load ptr, ptr %tv.addr, align 8
  %tv_sec2 = getelementptr inbounds %struct.timeval, ptr %2, i32 0, i32 0
  store i64 %call1, ptr %tv_sec2, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body3

do.body3:                                         ; preds = %do.end
  %3 = load ptr, ptr %target_tv, align 8
  %tv_usec = getelementptr inbounds %struct.target_timeval, ptr %3, i32 0, i32 1
  %call4 = call i64 @ldq_le_p(ptr noundef %tv_usec)
  %4 = load ptr, ptr %tv.addr, align 8
  %tv_usec5 = getelementptr inbounds %struct.timeval, ptr %4, i32 0, i32 1
  store i64 %call4, ptr %tv_usec5, align 8
  br label %do.end6

do.end6:                                          ; preds = %do.body3
  %5 = load ptr, ptr %target_tv, align 8
  %6 = load i64, ptr %target_tv_addr.addr, align 8
  call void @unlock_user(ptr noundef %5, i64 noundef %6, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end6, %if.then
  %7 = load i64, ptr %retval, align 8
  ret i64 %7
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_from_user_timezone(ptr noundef %tz, i64 noundef %target_tz_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %tz.addr = alloca ptr, align 8
  %target_tz_addr.addr = alloca i64, align 8
  %target_tz = alloca ptr, align 8
  store ptr %tz, ptr %tz.addr, align 8
  store i64 %target_tz_addr, ptr %target_tz_addr.addr, align 8
  %0 = load i64, ptr %target_tz_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call, ptr %target_tz, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_tz, align 8
  %tz_minuteswest = getelementptr inbounds %struct.target_timezone, ptr %1, i32 0, i32 0
  %call1 = call i32 @ldl_le_p(ptr noundef %tz_minuteswest)
  %2 = load ptr, ptr %tz.addr, align 8
  %tz_minuteswest2 = getelementptr inbounds %struct.timezone, ptr %2, i32 0, i32 0
  store i32 %call1, ptr %tz_minuteswest2, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body3

do.body3:                                         ; preds = %do.end
  %3 = load ptr, ptr %target_tz, align 8
  %tz_dsttime = getelementptr inbounds %struct.target_timezone, ptr %3, i32 0, i32 1
  %call4 = call i32 @ldl_le_p(ptr noundef %tz_dsttime)
  %4 = load ptr, ptr %tz.addr, align 8
  %tz_dsttime5 = getelementptr inbounds %struct.timezone, ptr %4, i32 0, i32 1
  store i32 %call4, ptr %tz_dsttime5, align 4
  br label %do.end6

do.end6:                                          ; preds = %do.body3
  %5 = load ptr, ptr %target_tz, align 8
  %6 = load i64, ptr %target_tz_addr.addr, align 8
  call void @unlock_user(ptr noundef %5, i64 noundef %6, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end6, %if.then
  %7 = load i64, ptr %retval, align 8
  ret i64 %7
}

; Function Attrs: nounwind
declare i32 @settimeofday(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_pselect6(i64 noundef %arg1, i64 noundef %arg2, i64 noundef %arg3, i64 noundef %arg4, i64 noundef %arg5, i64 noundef %arg6, i1 noundef zeroext %time64) #0 {
entry:
  %retval = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  %arg4.addr = alloca i64, align 8
  %arg5.addr = alloca i64, align 8
  %arg6.addr = alloca i64, align 8
  %time64.addr = alloca i8, align 1
  %rfd_addr = alloca i64, align 8
  %wfd_addr = alloca i64, align 8
  %efd_addr = alloca i64, align 8
  %n = alloca i64, align 8
  %ts_addr = alloca i64, align 8
  %rfds = alloca %struct.fd_set, align 8
  %wfds = alloca %struct.fd_set, align 8
  %efds = alloca %struct.fd_set, align 8
  %rfds_ptr = alloca ptr, align 8
  %wfds_ptr = alloca ptr, align 8
  %efds_ptr = alloca ptr, align 8
  %ts = alloca %struct.timespec, align 8
  %ts_ptr = alloca ptr, align 8
  %ret = alloca i64, align 8
  %sig = alloca %struct.anon.41, align 8
  %sig_ptr = alloca ptr, align 8
  %arg_sigset = alloca i64, align 8
  %arg_sigsize = alloca i64, align 8
  %arg7 = alloca ptr, align 8
  store i64 %arg1, ptr %arg1.addr, align 8
  store i64 %arg2, ptr %arg2.addr, align 8
  store i64 %arg3, ptr %arg3.addr, align 8
  store i64 %arg4, ptr %arg4.addr, align 8
  store i64 %arg5, ptr %arg5.addr, align 8
  store i64 %arg6, ptr %arg6.addr, align 8
  %frombool = zext i1 %time64 to i8
  store i8 %frombool, ptr %time64.addr, align 1
  %0 = load i64, ptr %arg1.addr, align 8
  store i64 %0, ptr %n, align 8
  %1 = load i64, ptr %arg2.addr, align 8
  store i64 %1, ptr %rfd_addr, align 8
  %2 = load i64, ptr %arg3.addr, align 8
  store i64 %2, ptr %wfd_addr, align 8
  %3 = load i64, ptr %arg4.addr, align 8
  store i64 %3, ptr %efd_addr, align 8
  %4 = load i64, ptr %arg5.addr, align 8
  store i64 %4, ptr %ts_addr, align 8
  %5 = load i64, ptr %rfd_addr, align 8
  %6 = load i64, ptr %n, align 8
  %conv = trunc i64 %6 to i32
  %call = call i64 @copy_from_user_fdset_ptr(ptr noundef %rfds, ptr noundef %rfds_ptr, i64 noundef %5, i32 noundef %conv)
  store i64 %call, ptr %ret, align 8
  %7 = load i64, ptr %ret, align 8
  %tobool = icmp ne i64 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load i64, ptr %ret, align 8
  store i64 %8, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %9 = load i64, ptr %wfd_addr, align 8
  %10 = load i64, ptr %n, align 8
  %conv1 = trunc i64 %10 to i32
  %call2 = call i64 @copy_from_user_fdset_ptr(ptr noundef %wfds, ptr noundef %wfds_ptr, i64 noundef %9, i32 noundef %conv1)
  store i64 %call2, ptr %ret, align 8
  %11 = load i64, ptr %ret, align 8
  %tobool3 = icmp ne i64 %11, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %12 = load i64, ptr %ret, align 8
  store i64 %12, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %13 = load i64, ptr %efd_addr, align 8
  %14 = load i64, ptr %n, align 8
  %conv6 = trunc i64 %14 to i32
  %call7 = call i64 @copy_from_user_fdset_ptr(ptr noundef %efds, ptr noundef %efds_ptr, i64 noundef %13, i32 noundef %conv6)
  store i64 %call7, ptr %ret, align 8
  %15 = load i64, ptr %ret, align 8
  %tobool8 = icmp ne i64 %15, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end5
  %16 = load i64, ptr %ret, align 8
  store i64 %16, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end5
  %17 = load i64, ptr %ts_addr, align 8
  %tobool11 = icmp ne i64 %17, 0
  br i1 %tobool11, label %if.then12, label %if.else24

if.then12:                                        ; preds = %if.end10
  %18 = load i8, ptr %time64.addr, align 1
  %tobool13 = trunc i8 %18 to i1
  br i1 %tobool13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.then12
  %19 = load i64, ptr %ts_addr, align 8
  %call15 = call i64 @target_to_host_timespec64(ptr noundef %ts, i64 noundef %19)
  %tobool16 = icmp ne i64 %call15, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then14
  store i64 -14, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %if.then14
  br label %if.end23

if.else:                                          ; preds = %if.then12
  %20 = load i64, ptr %ts_addr, align 8
  %call19 = call i64 @target_to_host_timespec(ptr noundef %ts, i64 noundef %20)
  %tobool20 = icmp ne i64 %call19, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.else
  store i64 -14, ptr %retval, align 8
  br label %return

if.end22:                                         ; preds = %if.else
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.end18
  store ptr %ts, ptr %ts_ptr, align 8
  br label %if.end25

if.else24:                                        ; preds = %if.end10
  store ptr null, ptr %ts_ptr, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.else24, %if.end23
  store ptr null, ptr %sig_ptr, align 8
  %21 = load i64, ptr %arg6.addr, align 8
  %tobool26 = icmp ne i64 %21, 0
  br i1 %tobool26, label %if.then27, label %if.end43

if.then27:                                        ; preds = %if.end25
  %22 = load i64, ptr %arg6.addr, align 8
  %call28 = call ptr @lock_user(i32 noundef 1, i64 noundef %22, i64 noundef 16, i1 noundef zeroext true)
  store ptr %call28, ptr %arg7, align 8
  %23 = load ptr, ptr %arg7, align 8
  %tobool29 = icmp ne ptr %23, null
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.then27
  store i64 -14, ptr %retval, align 8
  br label %return

if.end31:                                         ; preds = %if.then27
  %24 = load ptr, ptr %arg7, align 8
  %arrayidx = getelementptr i64, ptr %24, i64 0
  %25 = load i64, ptr %arrayidx, align 8
  %call32 = call i64 @tswapal(i64 noundef %25)
  store i64 %call32, ptr %arg_sigset, align 8
  %26 = load ptr, ptr %arg7, align 8
  %arrayidx33 = getelementptr i64, ptr %26, i64 1
  %27 = load i64, ptr %arrayidx33, align 8
  %call34 = call i64 @tswapal(i64 noundef %27)
  store i64 %call34, ptr %arg_sigsize, align 8
  %28 = load ptr, ptr %arg7, align 8
  %29 = load i64, ptr %arg6.addr, align 8
  call void @unlock_user(ptr noundef %28, i64 noundef %29, i64 noundef 0)
  %30 = load i64, ptr %arg_sigset, align 8
  %tobool35 = icmp ne i64 %30, 0
  br i1 %tobool35, label %if.then36, label %if.end42

if.then36:                                        ; preds = %if.end31
  %set = getelementptr inbounds %struct.anon.41, ptr %sig, i32 0, i32 0
  %31 = load i64, ptr %arg_sigset, align 8
  %32 = load i64, ptr %arg_sigsize, align 8
  %call37 = call i32 @process_sigsuspend_mask(ptr noundef %set, i64 noundef %31, i64 noundef %32)
  %conv38 = sext i32 %call37 to i64
  store i64 %conv38, ptr %ret, align 8
  %33 = load i64, ptr %ret, align 8
  %cmp = icmp ne i64 %33, 0
  br i1 %cmp, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.then36
  %34 = load i64, ptr %ret, align 8
  store i64 %34, ptr %retval, align 8
  br label %return

if.end41:                                         ; preds = %if.then36
  store ptr %sig, ptr %sig_ptr, align 8
  %size = getelementptr inbounds %struct.anon.41, ptr %sig, i32 0, i32 1
  store i64 8, ptr %size, align 8
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.end31
  br label %if.end43

if.end43:                                         ; preds = %if.end42, %if.end25
  %35 = load i64, ptr %n, align 8
  %conv44 = trunc i64 %35 to i32
  %36 = load ptr, ptr %rfds_ptr, align 8
  %37 = load ptr, ptr %wfds_ptr, align 8
  %38 = load ptr, ptr %efds_ptr, align 8
  %39 = load ptr, ptr %ts_ptr, align 8
  %40 = load ptr, ptr %sig_ptr, align 8
  %call45 = call i32 @safe_pselect6(i32 noundef %conv44, ptr noundef %36, ptr noundef %37, ptr noundef %38, ptr noundef %39, ptr noundef %40)
  %conv46 = sext i32 %call45 to i64
  %call47 = call i64 @get_errno(i64 noundef %conv46)
  store i64 %call47, ptr %ret, align 8
  %41 = load ptr, ptr %sig_ptr, align 8
  %tobool48 = icmp ne ptr %41, null
  br i1 %tobool48, label %if.then49, label %if.end51

if.then49:                                        ; preds = %if.end43
  %42 = load i64, ptr %ret, align 8
  %conv50 = trunc i64 %42 to i32
  call void @finish_sigsuspend_mask(i32 noundef %conv50)
  br label %if.end51

if.end51:                                         ; preds = %if.then49, %if.end43
  %43 = load i64, ptr %ret, align 8
  %call52 = call i32 @is_error(i64 noundef %43)
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %if.end91, label %if.then54

if.then54:                                        ; preds = %if.end51
  %44 = load i64, ptr %rfd_addr, align 8
  %tobool55 = icmp ne i64 %44, 0
  br i1 %tobool55, label %land.lhs.true, label %if.end60

land.lhs.true:                                    ; preds = %if.then54
  %45 = load i64, ptr %rfd_addr, align 8
  %46 = load i64, ptr %n, align 8
  %conv56 = trunc i64 %46 to i32
  %call57 = call i64 @copy_to_user_fdset(i64 noundef %45, ptr noundef %rfds, i32 noundef %conv56)
  %tobool58 = icmp ne i64 %call57, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %land.lhs.true
  store i64 -14, ptr %retval, align 8
  br label %return

if.end60:                                         ; preds = %land.lhs.true, %if.then54
  %47 = load i64, ptr %wfd_addr, align 8
  %tobool61 = icmp ne i64 %47, 0
  br i1 %tobool61, label %land.lhs.true62, label %if.end67

land.lhs.true62:                                  ; preds = %if.end60
  %48 = load i64, ptr %wfd_addr, align 8
  %49 = load i64, ptr %n, align 8
  %conv63 = trunc i64 %49 to i32
  %call64 = call i64 @copy_to_user_fdset(i64 noundef %48, ptr noundef %wfds, i32 noundef %conv63)
  %tobool65 = icmp ne i64 %call64, 0
  br i1 %tobool65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %land.lhs.true62
  store i64 -14, ptr %retval, align 8
  br label %return

if.end67:                                         ; preds = %land.lhs.true62, %if.end60
  %50 = load i64, ptr %efd_addr, align 8
  %tobool68 = icmp ne i64 %50, 0
  br i1 %tobool68, label %land.lhs.true69, label %if.end74

land.lhs.true69:                                  ; preds = %if.end67
  %51 = load i64, ptr %efd_addr, align 8
  %52 = load i64, ptr %n, align 8
  %conv70 = trunc i64 %52 to i32
  %call71 = call i64 @copy_to_user_fdset(i64 noundef %51, ptr noundef %efds, i32 noundef %conv70)
  %tobool72 = icmp ne i64 %call71, 0
  br i1 %tobool72, label %if.then73, label %if.end74

if.then73:                                        ; preds = %land.lhs.true69
  store i64 -14, ptr %retval, align 8
  br label %return

if.end74:                                         ; preds = %land.lhs.true69, %if.end67
  %53 = load i8, ptr %time64.addr, align 1
  %tobool75 = trunc i8 %53 to i1
  br i1 %tobool75, label %if.then76, label %if.else83

if.then76:                                        ; preds = %if.end74
  %54 = load i64, ptr %ts_addr, align 8
  %tobool77 = icmp ne i64 %54, 0
  br i1 %tobool77, label %land.lhs.true78, label %if.end82

land.lhs.true78:                                  ; preds = %if.then76
  %55 = load i64, ptr %ts_addr, align 8
  %call79 = call i64 @host_to_target_timespec64(i64 noundef %55, ptr noundef %ts)
  %tobool80 = icmp ne i64 %call79, 0
  br i1 %tobool80, label %if.then81, label %if.end82

if.then81:                                        ; preds = %land.lhs.true78
  store i64 -14, ptr %retval, align 8
  br label %return

if.end82:                                         ; preds = %land.lhs.true78, %if.then76
  br label %if.end90

if.else83:                                        ; preds = %if.end74
  %56 = load i64, ptr %ts_addr, align 8
  %tobool84 = icmp ne i64 %56, 0
  br i1 %tobool84, label %land.lhs.true85, label %if.end89

land.lhs.true85:                                  ; preds = %if.else83
  %57 = load i64, ptr %ts_addr, align 8
  %call86 = call i64 @host_to_target_timespec(i64 noundef %57, ptr noundef %ts)
  %tobool87 = icmp ne i64 %call86, 0
  br i1 %tobool87, label %if.then88, label %if.end89

if.then88:                                        ; preds = %land.lhs.true85
  store i64 -14, ptr %retval, align 8
  br label %return

if.end89:                                         ; preds = %land.lhs.true85, %if.else83
  br label %if.end90

if.end90:                                         ; preds = %if.end89, %if.end82
  br label %if.end91

if.end91:                                         ; preds = %if.end90, %if.end51
  %58 = load i64, ptr %ret, align 8
  store i64 %58, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end91, %if.then88, %if.then81, %if.then73, %if.then66, %if.then59, %if.then40, %if.then30, %if.then21, %if.then17, %if.then9, %if.then4, %if.then
  %59 = load i64, ptr %retval, align 8
  ret i64 %59
}

; Function Attrs: nounwind
declare i32 @symlinkat(ptr noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i64 @readlinkat(i32 noundef, ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i32 @swapon(ptr noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @reboot(i32 noundef %magic1, i32 noundef %magic2, i32 noundef %cmd, ptr noundef %arg) #0 {
entry:
  %magic1.addr = alloca i32, align 4
  %magic2.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca ptr, align 8
  store i32 %magic1, ptr %magic1.addr, align 4
  store i32 %magic2, ptr %magic2.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load i32, ptr %magic1.addr, align 4
  %1 = load i32, ptr %magic2.addr, align 4
  %2 = load i32, ptr %cmd.addr, align 4
  %3 = load ptr, ptr %arg.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 169, i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_mmap(i64 noundef %addr, i64 noundef %len, i32 noundef %prot, i32 noundef %target_flags, i32 noundef %fd, i64 noundef %offset) #0 {
entry:
  %retval = alloca i64, align 8
  %addr.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %prot.addr = alloca i32, align 4
  %target_flags.addr = alloca i32, align 4
  %fd.addr = alloca i32, align 4
  %offset.addr = alloca i64, align 8
  %host_flags = alloca i32, align 4
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 %prot, ptr %prot.addr, align 4
  store i32 %target_flags, ptr %target_flags.addr, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i32, ptr %target_flags.addr, align 4
  %and = and i32 %0, 15
  switch i32 %and, label %sw.default [
    i32 2, label %sw.bb
    i32 1, label %sw.bb1
    i32 3, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  store i32 2, ptr %host_flags, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  store i32 1, ptr %host_flags, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %1 = load i32, ptr %target_flags.addr, align 4
  %and3 = and i32 %1, -68155700
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb2
  store i64 -95, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %sw.bb2
  store i32 3, ptr %host_flags, align 4
  %2 = load i32, ptr %target_flags.addr, align 4
  %and4 = and i32 %2, 524288
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %3 = load i32, ptr %host_flags, align 4
  %or = or i32 %3, 524288
  store i32 %or, ptr %host_flags, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i64 -22, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %if.end7, %sw.bb1, %sw.bb
  %4 = load i32, ptr %target_flags.addr, align 4
  %call = call i32 @target_to_host_bitmask_len(i32 noundef %4, ptr noundef @mmap_flags_tbl, i64 noundef 13)
  %5 = load i32, ptr %host_flags, align 4
  %or8 = or i32 %5, %call
  store i32 %or8, ptr %host_flags, align 4
  %6 = load i64, ptr %addr.addr, align 8
  %7 = load i64, ptr %len.addr, align 8
  %8 = load i32, ptr %prot.addr, align 4
  %9 = load i32, ptr %host_flags, align 4
  %10 = load i32, ptr %fd.addr, align 4
  %11 = load i64, ptr %offset.addr, align 8
  %call9 = call i64 @target_mmap(i64 noundef %6, i64 noundef %7, i32 noundef %8, i32 noundef %9, i32 noundef %10, i64 noundef %11)
  %call10 = call i64 @get_errno(i64 noundef %call9)
  store i64 %call10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %if.then
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @cpu_untagged_addr(ptr noundef %cs, i64 noundef %x) #0 {
entry:
  %cs.addr = alloca ptr, align 8
  %x.addr = alloca i64, align 8
  store ptr %cs, ptr %cs.addr, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load i64, ptr %x.addr, align 8
  ret i64 %0
}

declare i32 @target_mprotect(i64 noundef, i64 noundef, i32 noundef) #3

declare i64 @target_mremap(i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef) #3

declare i32 @msync(ptr noundef, i64 noundef, i32 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @target_to_host_msync_arg(i64 noundef %arg) #0 {
entry:
  %arg.addr = alloca i64, align 8
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load i64, ptr %arg.addr, align 8
  %and = and i64 %0, 1
  %tobool = icmp ne i64 %and, 0
  %cond = select i1 %tobool, i32 1, i32 0
  %1 = load i64, ptr %arg.addr, align 8
  %and1 = and i64 %1, 2
  %tobool2 = icmp ne i64 %and1, 0
  %cond3 = select i1 %tobool2, i32 2, i32 0
  %or = or i32 %cond, %cond3
  %2 = load i64, ptr %arg.addr, align 8
  %and4 = and i64 %2, 4
  %tobool5 = icmp ne i64 %and4, 0
  %cond6 = select i1 %tobool5, i32 4, i32 0
  %or7 = or i32 %or, %cond6
  %conv = sext i32 %or7 to i64
  %3 = load i64, ptr %arg.addr, align 8
  %and8 = and i64 %3, -8
  %or9 = or i64 %conv, %and8
  %conv10 = trunc i64 %or9 to i32
  ret i32 %conv10
}

; Function Attrs: nounwind
declare i32 @mlock(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i32 @munlock(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i32 @mlockall(i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @target_to_host_mlockall_arg(i32 noundef %arg) #0 {
entry:
  %arg.addr = alloca i32, align 4
  %result = alloca i32, align 4
  store i32 %arg, ptr %arg.addr, align 4
  store i32 0, ptr %result, align 4
  %0 = load i32, ptr %arg.addr, align 4
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %result, align 4
  %or = or i32 %1, 1
  store i32 %or, ptr %result, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %arg.addr, align 4
  %and1 = and i32 %2, 2
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %3 = load i32, ptr %result, align 4
  %or4 = or i32 %3, 2
  store i32 %or4, ptr %result, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %4 = load i32, ptr %arg.addr, align 4
  %and6 = and i32 %4, 4
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end5
  %5 = load i32, ptr %result, align 4
  %or9 = or i32 %5, 4
  store i32 %or9, ptr %result, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end5
  %6 = load i32, ptr %result, align 4
  ret i32 %6
}

; Function Attrs: nounwind
declare i32 @munlockall() #2

; Function Attrs: nounwind
declare i32 @truncate64(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i32 @ftruncate64(i32 noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i32 @fchmod(i32 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @fchmodat(i32 noundef, ptr noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @getpriority(i32 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @setpriority(i32 noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @statfs64(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @fstatfs64(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_accept4(i32 noundef %fd, i64 noundef %target_addr, i64 noundef %target_addrlen_addr, i32 noundef %flags) #0 {
entry:
  %retval = alloca i64, align 8
  %fd.addr = alloca i32, align 4
  %target_addr.addr = alloca i64, align 8
  %target_addrlen_addr.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %addrlen = alloca i32, align 4
  %ret_addrlen = alloca i32, align 4
  %addr = alloca ptr, align 8
  %ret = alloca i64, align 8
  %host_flags = alloca i32, align 4
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %_a10 = alloca i32, align 4
  %_b11 = alloca i32, align 4
  %tmp36 = alloca i32, align 4
  %__gaddr40 = alloca i64, align 8
  %__hptr41 = alloca ptr, align 8
  %__ret42 = alloca i64, align 8
  %tmp50 = alloca i64, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i64 %target_addrlen_addr, ptr %target_addrlen_addr.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %and = and i32 %0, -526337
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -22, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %host_flags, align 4
  %1 = load i32, ptr %flags.addr, align 4
  %and1 = and i32 %1, 2048
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %2 = load i32, ptr %host_flags, align 4
  %or = or i32 %2, 2048
  store i32 %or, ptr %host_flags, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %3 = load i32, ptr %flags.addr, align 4
  %and5 = and i32 %3, 524288
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end4
  %4 = load i32, ptr %host_flags, align 4
  %or8 = or i32 %4, 524288
  store i32 %or8, ptr %host_flags, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end4
  %5 = load i64, ptr %target_addr.addr, align 8
  %cmp = icmp eq i64 %5, 0
  br i1 %cmp, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end9
  %6 = load i32, ptr %fd.addr, align 4
  %7 = load i32, ptr %host_flags, align 4
  %call = call i32 @safe_accept4(i32 noundef %6, ptr noundef null, ptr noundef null, i32 noundef %7)
  %conv = sext i32 %call to i64
  %call11 = call i64 @get_errno(i64 noundef %conv)
  store i64 %call11, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end9
  %8 = load i64, ptr %target_addrlen_addr.addr, align 8
  store i64 %8, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %9 = load i64, ptr %__gaddr, align 8
  %call13 = call ptr @lock_user(i32 noundef 1, i64 noundef %9, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call13, ptr %__hptr, align 8
  %tobool14 = icmp ne ptr %call13, null
  br i1 %tobool14, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end12
  br label %do.body

do.body:                                          ; preds = %if.then15
  %10 = load ptr, ptr %__hptr, align 8
  %call16 = call i32 @ldl_le_p(ptr noundef %10)
  store i32 %call16, ptr %addrlen, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  %11 = load ptr, ptr %__hptr, align 8
  %12 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %11, i64 noundef %12, i64 noundef 0)
  br label %if.end17

if.else:                                          ; preds = %if.end12
  store i32 0, ptr %addrlen, align 4
  store i64 -14, ptr %__ret, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.else, %do.end
  %13 = load i64, ptr %__ret, align 8
  store i64 %13, ptr %tmp, align 8
  %14 = load i64, ptr %tmp, align 8
  %tobool18 = icmp ne i64 %14, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end17
  store i64 -14, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %if.end17
  %15 = load i32, ptr %addrlen, align 4
  %cmp21 = icmp slt i32 %15, 0
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  store i64 -22, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %if.end20
  %16 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %17 = load ptr, ptr %16, align 8
  %18 = load i64, ptr %target_addr.addr, align 8
  %19 = load i32, ptr %addrlen, align 4
  %conv25 = zext i32 %19 to i64
  %call26 = call zeroext i1 @access_ok(ptr noundef %17, i32 noundef 3, i64 noundef %18, i64 noundef %conv25)
  br i1 %call26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end24
  store i64 -14, ptr %retval, align 8
  br label %return

if.end28:                                         ; preds = %if.end24
  %20 = load i32, ptr %addrlen, align 4
  %conv29 = zext i32 %20 to i64
  %21 = alloca i8, i64 %conv29, align 16
  store ptr %21, ptr %addr, align 8
  %22 = load i32, ptr %addrlen, align 4
  store i32 %22, ptr %ret_addrlen, align 4
  %23 = load i32, ptr %fd.addr, align 4
  %24 = load ptr, ptr %addr, align 8
  %25 = load i32, ptr %host_flags, align 4
  %call30 = call i32 @safe_accept4(i32 noundef %23, ptr noundef %24, ptr noundef %ret_addrlen, i32 noundef %25)
  %conv31 = sext i32 %call30 to i64
  %call32 = call i64 @get_errno(i64 noundef %conv31)
  store i64 %call32, ptr %ret, align 8
  %26 = load i64, ptr %ret, align 8
  %call33 = call i32 @is_error(i64 noundef %26)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.end54, label %if.then35

if.then35:                                        ; preds = %if.end28
  %27 = load i64, ptr %target_addr.addr, align 8
  %28 = load ptr, ptr %addr, align 8
  %29 = load i32, ptr %addrlen, align 4
  store i32 %29, ptr %_a10, align 4
  %30 = load i32, ptr %ret_addrlen, align 4
  store i32 %30, ptr %_b11, align 4
  %31 = load i32, ptr %_a10, align 4
  %32 = load i32, ptr %_b11, align 4
  %cmp37 = icmp ult i32 %31, %32
  br i1 %cmp37, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then35
  %33 = load i32, ptr %_a10, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then35
  %34 = load i32, ptr %_b11, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %33, %cond.true ], [ %34, %cond.false ]
  store i32 %cond, ptr %tmp36, align 4
  %35 = load i32, ptr %tmp36, align 4
  %call39 = call i64 @host_to_target_sockaddr(i64 noundef %27, ptr noundef %28, i32 noundef %35)
  %36 = load i64, ptr %target_addrlen_addr.addr, align 8
  store i64 %36, ptr %__gaddr40, align 8
  store i64 0, ptr %__ret42, align 8
  %37 = load i64, ptr %__gaddr40, align 8
  %call43 = call ptr @lock_user(i32 noundef 3, i64 noundef %37, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call43, ptr %__hptr41, align 8
  %tobool44 = icmp ne ptr %call43, null
  br i1 %tobool44, label %if.then45, label %if.else48

if.then45:                                        ; preds = %cond.end
  br label %do.body46

do.body46:                                        ; preds = %if.then45
  %38 = load ptr, ptr %__hptr41, align 8
  %39 = load i32, ptr %ret_addrlen, align 4
  call void @stl_le_p(ptr noundef %38, i32 noundef %39)
  br label %do.end47

do.end47:                                         ; preds = %do.body46
  %40 = load ptr, ptr %__hptr41, align 8
  %41 = load i64, ptr %__gaddr40, align 8
  call void @unlock_user(ptr noundef %40, i64 noundef %41, i64 noundef 4)
  br label %if.end49

if.else48:                                        ; preds = %cond.end
  store i64 -14, ptr %__ret42, align 8
  br label %if.end49

if.end49:                                         ; preds = %if.else48, %do.end47
  %42 = load i64, ptr %__ret42, align 8
  store i64 %42, ptr %tmp50, align 8
  %43 = load i64, ptr %tmp50, align 8
  %tobool51 = icmp ne i64 %43, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end49
  store i64 -14, ptr %ret, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.then52, %if.end49
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.end28
  %44 = load i64, ptr %ret, align 8
  store i64 %44, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end54, %if.then27, %if.then23, %if.then19, %if.then10, %if.then
  %45 = load i64, ptr %retval, align 8
  ret i64 %45
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_bind(i32 noundef %sockfd, i64 noundef %target_addr, i32 noundef %addrlen) #0 {
entry:
  %retval = alloca i64, align 8
  %sockfd.addr = alloca i32, align 4
  %target_addr.addr = alloca i64, align 8
  %addrlen.addr = alloca i32, align 4
  %addr = alloca ptr, align 8
  %ret = alloca i64, align 8
  %agg.tmp = alloca %union.__CONST_SOCKADDR_ARG, align 8
  store i32 %sockfd, ptr %sockfd.addr, align 4
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i32 %addrlen, ptr %addrlen.addr, align 4
  %0 = load i32, ptr %addrlen.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -22, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %addrlen.addr, align 4
  %add = add i32 %1, 1
  %conv = zext i32 %add to i64
  %2 = alloca i8, i64 %conv, align 16
  store ptr %2, ptr %addr, align 8
  %3 = load i32, ptr %sockfd.addr, align 4
  %4 = load ptr, ptr %addr, align 8
  %5 = load i64, ptr %target_addr.addr, align 8
  %6 = load i32, ptr %addrlen.addr, align 4
  %call = call i64 @target_to_host_sockaddr(i32 noundef %3, ptr noundef %4, i64 noundef %5, i32 noundef %6)
  store i64 %call, ptr %ret, align 8
  %7 = load i64, ptr %ret, align 8
  %tobool = icmp ne i64 %7, 0
  br i1 %tobool, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %8 = load i64, ptr %ret, align 8
  store i64 %8, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  %9 = load i32, ptr %sockfd.addr, align 4
  %10 = load ptr, ptr %addr, align 8
  store ptr %10, ptr %agg.tmp, align 8
  %11 = load i32, ptr %addrlen.addr, align 4
  %coerce.dive = getelementptr inbounds %union.__CONST_SOCKADDR_ARG, ptr %agg.tmp, i32 0, i32 0
  %12 = load ptr, ptr %coerce.dive, align 8
  %call3 = call i32 @bind(i32 noundef %9, ptr %12, i32 noundef %11) #14
  %conv4 = sext i32 %call3 to i64
  %call5 = call i64 @get_errno(i64 noundef %conv4)
  store i64 %call5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end2, %if.then1, %if.then
  %13 = load i64, ptr %retval, align 8
  ret i64 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_connect(i32 noundef %sockfd, i64 noundef %target_addr, i32 noundef %addrlen) #0 {
entry:
  %retval = alloca i64, align 8
  %sockfd.addr = alloca i32, align 4
  %target_addr.addr = alloca i64, align 8
  %addrlen.addr = alloca i32, align 4
  %addr = alloca ptr, align 8
  %ret = alloca i64, align 8
  store i32 %sockfd, ptr %sockfd.addr, align 4
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i32 %addrlen, ptr %addrlen.addr, align 4
  %0 = load i32, ptr %addrlen.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -22, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %addrlen.addr, align 4
  %add = add i32 %1, 1
  %conv = zext i32 %add to i64
  %2 = alloca i8, i64 %conv, align 16
  store ptr %2, ptr %addr, align 8
  %3 = load i32, ptr %sockfd.addr, align 4
  %4 = load ptr, ptr %addr, align 8
  %5 = load i64, ptr %target_addr.addr, align 8
  %6 = load i32, ptr %addrlen.addr, align 4
  %call = call i64 @target_to_host_sockaddr(i32 noundef %3, ptr noundef %4, i64 noundef %5, i32 noundef %6)
  store i64 %call, ptr %ret, align 8
  %7 = load i64, ptr %ret, align 8
  %tobool = icmp ne i64 %7, 0
  br i1 %tobool, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %8 = load i64, ptr %ret, align 8
  store i64 %8, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  %9 = load i32, ptr %sockfd.addr, align 4
  %10 = load ptr, ptr %addr, align 8
  %11 = load i32, ptr %addrlen.addr, align 4
  %call3 = call i32 @safe_connect(i32 noundef %9, ptr noundef %10, i32 noundef %11)
  %conv4 = sext i32 %call3 to i64
  %call5 = call i64 @get_errno(i64 noundef %conv4)
  store i64 %call5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end2, %if.then1, %if.then
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_getpeername(i32 noundef %fd, i64 noundef %target_addr, i64 noundef %target_addrlen_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %fd.addr = alloca i32, align 4
  %target_addr.addr = alloca i64, align 8
  %target_addrlen_addr.addr = alloca i64, align 8
  %addrlen = alloca i32, align 4
  %ret_addrlen = alloca i32, align 4
  %addr = alloca ptr, align 8
  %ret = alloca i64, align 8
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %agg.tmp = alloca %union.__SOCKADDR_ARG, align 8
  %_a12 = alloca i32, align 4
  %_b13 = alloca i32, align 4
  %tmp17 = alloca i32, align 4
  %__gaddr21 = alloca i64, align 8
  %__hptr22 = alloca ptr, align 8
  %__ret23 = alloca i64, align 8
  %tmp31 = alloca i64, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i64 %target_addrlen_addr, ptr %target_addrlen_addr.addr, align 8
  %0 = load i64, ptr %target_addrlen_addr.addr, align 8
  store i64 %0, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %1 = load i64, ptr %__gaddr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %1, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call, ptr %__hptr, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load ptr, ptr %__hptr, align 8
  %call1 = call i32 @ldl_le_p(ptr noundef %2)
  store i32 %call1, ptr %addrlen, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  %3 = load ptr, ptr %__hptr, align 8
  %4 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %3, i64 noundef %4, i64 noundef 0)
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 0, ptr %addrlen, align 4
  store i64 -14, ptr %__ret, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %5 = load i64, ptr %__ret, align 8
  store i64 %5, ptr %tmp, align 8
  %6 = load i64, ptr %tmp, align 8
  %tobool2 = icmp ne i64 %6, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %7 = load i32, ptr %addrlen, align 4
  %cmp = icmp slt i32 %7, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end4
  store i64 -22, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end4
  %8 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %9 = load ptr, ptr %8, align 8
  %10 = load i64, ptr %target_addr.addr, align 8
  %11 = load i32, ptr %addrlen, align 4
  %conv = zext i32 %11 to i64
  %call7 = call zeroext i1 @access_ok(ptr noundef %9, i32 noundef 3, i64 noundef %10, i64 noundef %conv)
  br i1 %call7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end6
  store i64 -14, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end6
  %12 = load i32, ptr %addrlen, align 4
  %conv10 = zext i32 %12 to i64
  %13 = alloca i8, i64 %conv10, align 16
  store ptr %13, ptr %addr, align 8
  %14 = load i32, ptr %addrlen, align 4
  store i32 %14, ptr %ret_addrlen, align 4
  %15 = load i32, ptr %fd.addr, align 4
  %16 = load ptr, ptr %addr, align 8
  store ptr %16, ptr %agg.tmp, align 8
  %coerce.dive = getelementptr inbounds %union.__SOCKADDR_ARG, ptr %agg.tmp, i32 0, i32 0
  %17 = load ptr, ptr %coerce.dive, align 8
  %call11 = call i32 @getpeername(i32 noundef %15, ptr %17, ptr noundef %ret_addrlen) #14
  %conv12 = sext i32 %call11 to i64
  %call13 = call i64 @get_errno(i64 noundef %conv12)
  store i64 %call13, ptr %ret, align 8
  %18 = load i64, ptr %ret, align 8
  %call14 = call i32 @is_error(i64 noundef %18)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end35, label %if.then16

if.then16:                                        ; preds = %if.end9
  %19 = load i64, ptr %target_addr.addr, align 8
  %20 = load ptr, ptr %addr, align 8
  %21 = load i32, ptr %addrlen, align 4
  store i32 %21, ptr %_a12, align 4
  %22 = load i32, ptr %ret_addrlen, align 4
  store i32 %22, ptr %_b13, align 4
  %23 = load i32, ptr %_a12, align 4
  %24 = load i32, ptr %_b13, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then16
  %25 = load i32, ptr %_a12, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then16
  %26 = load i32, ptr %_b13, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %25, %cond.true ], [ %26, %cond.false ]
  store i32 %cond, ptr %tmp17, align 4
  %27 = load i32, ptr %tmp17, align 4
  %call20 = call i64 @host_to_target_sockaddr(i64 noundef %19, ptr noundef %20, i32 noundef %27)
  %28 = load i64, ptr %target_addrlen_addr.addr, align 8
  store i64 %28, ptr %__gaddr21, align 8
  store i64 0, ptr %__ret23, align 8
  %29 = load i64, ptr %__gaddr21, align 8
  %call24 = call ptr @lock_user(i32 noundef 3, i64 noundef %29, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call24, ptr %__hptr22, align 8
  %tobool25 = icmp ne ptr %call24, null
  br i1 %tobool25, label %if.then26, label %if.else29

if.then26:                                        ; preds = %cond.end
  br label %do.body27

do.body27:                                        ; preds = %if.then26
  %30 = load ptr, ptr %__hptr22, align 8
  %31 = load i32, ptr %ret_addrlen, align 4
  call void @stl_le_p(ptr noundef %30, i32 noundef %31)
  br label %do.end28

do.end28:                                         ; preds = %do.body27
  %32 = load ptr, ptr %__hptr22, align 8
  %33 = load i64, ptr %__gaddr21, align 8
  call void @unlock_user(ptr noundef %32, i64 noundef %33, i64 noundef 4)
  br label %if.end30

if.else29:                                        ; preds = %cond.end
  store i64 -14, ptr %__ret23, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.else29, %do.end28
  %34 = load i64, ptr %__ret23, align 8
  store i64 %34, ptr %tmp31, align 8
  %35 = load i64, ptr %tmp31, align 8
  %tobool32 = icmp ne i64 %35, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end30
  store i64 -14, ptr %ret, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.end30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.end9
  %36 = load i64, ptr %ret, align 8
  store i64 %36, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end35, %if.then8, %if.then5, %if.then3
  %37 = load i64, ptr %retval, align 8
  ret i64 %37
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_getsockname(i32 noundef %fd, i64 noundef %target_addr, i64 noundef %target_addrlen_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %fd.addr = alloca i32, align 4
  %target_addr.addr = alloca i64, align 8
  %target_addrlen_addr.addr = alloca i64, align 8
  %addrlen = alloca i32, align 4
  %ret_addrlen = alloca i32, align 4
  %addr = alloca ptr, align 8
  %ret = alloca i64, align 8
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %agg.tmp = alloca %union.__SOCKADDR_ARG, align 8
  %_a14 = alloca i32, align 4
  %_b15 = alloca i32, align 4
  %tmp17 = alloca i32, align 4
  %__gaddr21 = alloca i64, align 8
  %__hptr22 = alloca ptr, align 8
  %__ret23 = alloca i64, align 8
  %tmp31 = alloca i64, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i64 %target_addrlen_addr, ptr %target_addrlen_addr.addr, align 8
  %0 = load i64, ptr %target_addrlen_addr.addr, align 8
  store i64 %0, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %1 = load i64, ptr %__gaddr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %1, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call, ptr %__hptr, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load ptr, ptr %__hptr, align 8
  %call1 = call i32 @ldl_le_p(ptr noundef %2)
  store i32 %call1, ptr %addrlen, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  %3 = load ptr, ptr %__hptr, align 8
  %4 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %3, i64 noundef %4, i64 noundef 0)
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 0, ptr %addrlen, align 4
  store i64 -14, ptr %__ret, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %5 = load i64, ptr %__ret, align 8
  store i64 %5, ptr %tmp, align 8
  %6 = load i64, ptr %tmp, align 8
  %tobool2 = icmp ne i64 %6, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %7 = load i32, ptr %addrlen, align 4
  %cmp = icmp slt i32 %7, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end4
  store i64 -22, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end4
  %8 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %9 = load ptr, ptr %8, align 8
  %10 = load i64, ptr %target_addr.addr, align 8
  %11 = load i32, ptr %addrlen, align 4
  %conv = zext i32 %11 to i64
  %call7 = call zeroext i1 @access_ok(ptr noundef %9, i32 noundef 3, i64 noundef %10, i64 noundef %conv)
  br i1 %call7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end6
  store i64 -14, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end6
  %12 = load i32, ptr %addrlen, align 4
  %conv10 = zext i32 %12 to i64
  %13 = alloca i8, i64 %conv10, align 16
  store ptr %13, ptr %addr, align 8
  %14 = load i32, ptr %addrlen, align 4
  store i32 %14, ptr %ret_addrlen, align 4
  %15 = load i32, ptr %fd.addr, align 4
  %16 = load ptr, ptr %addr, align 8
  store ptr %16, ptr %agg.tmp, align 8
  %coerce.dive = getelementptr inbounds %union.__SOCKADDR_ARG, ptr %agg.tmp, i32 0, i32 0
  %17 = load ptr, ptr %coerce.dive, align 8
  %call11 = call i32 @getsockname(i32 noundef %15, ptr %17, ptr noundef %ret_addrlen) #14
  %conv12 = sext i32 %call11 to i64
  %call13 = call i64 @get_errno(i64 noundef %conv12)
  store i64 %call13, ptr %ret, align 8
  %18 = load i64, ptr %ret, align 8
  %call14 = call i32 @is_error(i64 noundef %18)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end35, label %if.then16

if.then16:                                        ; preds = %if.end9
  %19 = load i64, ptr %target_addr.addr, align 8
  %20 = load ptr, ptr %addr, align 8
  %21 = load i32, ptr %addrlen, align 4
  store i32 %21, ptr %_a14, align 4
  %22 = load i32, ptr %ret_addrlen, align 4
  store i32 %22, ptr %_b15, align 4
  %23 = load i32, ptr %_a14, align 4
  %24 = load i32, ptr %_b15, align 4
  %cmp18 = icmp ult i32 %23, %24
  br i1 %cmp18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then16
  %25 = load i32, ptr %_a14, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then16
  %26 = load i32, ptr %_b15, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %25, %cond.true ], [ %26, %cond.false ]
  store i32 %cond, ptr %tmp17, align 4
  %27 = load i32, ptr %tmp17, align 4
  %call20 = call i64 @host_to_target_sockaddr(i64 noundef %19, ptr noundef %20, i32 noundef %27)
  %28 = load i64, ptr %target_addrlen_addr.addr, align 8
  store i64 %28, ptr %__gaddr21, align 8
  store i64 0, ptr %__ret23, align 8
  %29 = load i64, ptr %__gaddr21, align 8
  %call24 = call ptr @lock_user(i32 noundef 3, i64 noundef %29, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call24, ptr %__hptr22, align 8
  %tobool25 = icmp ne ptr %call24, null
  br i1 %tobool25, label %if.then26, label %if.else29

if.then26:                                        ; preds = %cond.end
  br label %do.body27

do.body27:                                        ; preds = %if.then26
  %30 = load ptr, ptr %__hptr22, align 8
  %31 = load i32, ptr %ret_addrlen, align 4
  call void @stl_le_p(ptr noundef %30, i32 noundef %31)
  br label %do.end28

do.end28:                                         ; preds = %do.body27
  %32 = load ptr, ptr %__hptr22, align 8
  %33 = load i64, ptr %__gaddr21, align 8
  call void @unlock_user(ptr noundef %32, i64 noundef %33, i64 noundef 4)
  br label %if.end30

if.else29:                                        ; preds = %cond.end
  store i64 -14, ptr %__ret23, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.else29, %do.end28
  %34 = load i64, ptr %__ret23, align 8
  store i64 %34, ptr %tmp31, align 8
  %35 = load i64, ptr %tmp31, align 8
  %tobool32 = icmp ne i64 %35, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end30
  store i64 -14, ptr %ret, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.end30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.end9
  %36 = load i64, ptr %ret, align 8
  store i64 %36, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end35, %if.then8, %if.then5, %if.then3
  %37 = load i64, ptr %retval, align 8
  ret i64 %37
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_getsockopt(i32 noundef %sockfd, i32 noundef %level, i32 noundef %optname, i64 noundef %optval_addr, i64 noundef %optlen) #0 {
entry:
  %retval = alloca i64, align 8
  %sockfd.addr = alloca i32, align 4
  %level.addr = alloca i32, align 4
  %optname.addr = alloca i32, align 4
  %optval_addr.addr = alloca i64, align 8
  %optlen.addr = alloca i64, align 8
  %ret = alloca i64, align 8
  %len = alloca i32, align 4
  %val = alloca i32, align 4
  %lv = alloca i32, align 4
  %tv = alloca %struct.timeval, align 8
  %tvlen = alloca i32, align 4
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__gaddr24 = alloca i64, align 8
  %__hptr25 = alloca ptr, align 8
  %__ret26 = alloca i64, align 8
  %tmp34 = alloca i64, align 8
  %cr = alloca %struct.ucred, align 4
  %crlen = alloca i32, align 4
  %tcr = alloca ptr, align 8
  %__gaddr40 = alloca i64, align 8
  %__hptr41 = alloca ptr, align 8
  %__ret42 = alloca i64, align 8
  %tmp51 = alloca i64, align 8
  %__gaddr83 = alloca i64, align 8
  %__hptr84 = alloca ptr, align 8
  %__ret85 = alloca i64, align 8
  %tmp93 = alloca i64, align 8
  %name = alloca ptr, align 8
  %__gaddr98 = alloca i64, align 8
  %__hptr99 = alloca ptr, align 8
  %__ret100 = alloca i64, align 8
  %tmp109 = alloca i64, align 8
  %__gaddr125 = alloca i64, align 8
  %__hptr126 = alloca ptr, align 8
  %__ret127 = alloca i64, align 8
  %tmp135 = alloca i64, align 8
  %lg = alloca %struct.linger, align 4
  %lglen = alloca i32, align 4
  %tlg = alloca ptr, align 8
  %__gaddr141 = alloca i64, align 8
  %__hptr142 = alloca ptr, align 8
  %__ret143 = alloca i64, align 8
  %tmp152 = alloca i64, align 8
  %__gaddr181 = alloca i64, align 8
  %__hptr182 = alloca ptr, align 8
  %__ret183 = alloca i64, align 8
  %tmp191 = alloca i64, align 8
  %__gaddr216 = alloca i64, align 8
  %__hptr217 = alloca ptr, align 8
  %__ret218 = alloca i64, align 8
  %tmp227 = alloca i64, align 8
  %__gaddr254 = alloca i64, align 8
  %__hptr255 = alloca ptr, align 8
  %__ret256 = alloca i64, align 8
  %tmp264 = alloca i64, align 8
  %__gaddr269 = alloca i64, align 8
  %__hptr270 = alloca ptr, align 8
  %__ret271 = alloca i64, align 8
  %tmp280 = alloca i64, align 8
  %__gaddr285 = alloca i64, align 8
  %__hptr286 = alloca ptr, align 8
  %__ret287 = alloca i64, align 8
  %tmp295 = alloca i64, align 8
  %__gaddr301 = alloca i64, align 8
  %__hptr302 = alloca ptr, align 8
  %__ret303 = alloca i64, align 8
  %tmp312 = alloca i64, align 8
  %__gaddr339 = alloca i64, align 8
  %__hptr340 = alloca ptr, align 8
  %__ret341 = alloca i64, align 8
  %tmp349 = alloca i64, align 8
  %__gaddr351 = alloca i64, align 8
  %__hptr352 = alloca ptr, align 8
  %__ret353 = alloca i64, align 8
  %tmp362 = alloca i64, align 8
  %__gaddr372 = alloca i64, align 8
  %__hptr373 = alloca ptr, align 8
  %__ret374 = alloca i64, align 8
  %tmp382 = alloca i64, align 8
  %__gaddr385 = alloca i64, align 8
  %__hptr386 = alloca ptr, align 8
  %__ret387 = alloca i64, align 8
  %tmp395 = alloca i64, align 8
  %__gaddr404 = alloca i64, align 8
  %__hptr405 = alloca ptr, align 8
  %__ret406 = alloca i64, align 8
  %tmp415 = alloca i64, align 8
  %__gaddr443 = alloca i64, align 8
  %__hptr444 = alloca ptr, align 8
  %__ret445 = alloca i64, align 8
  %tmp453 = alloca i64, align 8
  %__gaddr456 = alloca i64, align 8
  %__hptr457 = alloca ptr, align 8
  %__ret458 = alloca i64, align 8
  %tmp467 = alloca i64, align 8
  %__gaddr477 = alloca i64, align 8
  %__hptr478 = alloca ptr, align 8
  %__ret479 = alloca i64, align 8
  %tmp487 = alloca i64, align 8
  %__gaddr490 = alloca i64, align 8
  %__hptr491 = alloca ptr, align 8
  %__ret492 = alloca i64, align 8
  %tmp500 = alloca i64, align 8
  %__gaddr509 = alloca i64, align 8
  %__hptr510 = alloca ptr, align 8
  %__ret511 = alloca i64, align 8
  %tmp520 = alloca i64, align 8
  %__gaddr536 = alloca i64, align 8
  %__hptr537 = alloca ptr, align 8
  %__ret538 = alloca i64, align 8
  %tmp546 = alloca i64, align 8
  %__gaddr549 = alloca i64, align 8
  %__hptr550 = alloca ptr, align 8
  %__ret551 = alloca i64, align 8
  %tmp559 = alloca i64, align 8
  %results = alloca ptr, align 8
  %i = alloca i32, align 4
  %__gaddr564 = alloca i64, align 8
  %__hptr565 = alloca ptr, align 8
  %__ret566 = alloca i64, align 8
  %tmp575 = alloca i64, align 8
  %__gaddr605 = alloca i64, align 8
  %__hptr606 = alloca ptr, align 8
  %__ret607 = alloca i64, align 8
  %tmp615 = alloca i64, align 8
  store i32 %sockfd, ptr %sockfd.addr, align 4
  store i32 %level, ptr %level.addr, align 4
  store i32 %optname, ptr %optname.addr, align 4
  store i64 %optval_addr, ptr %optval_addr.addr, align 8
  store i64 %optlen, ptr %optlen.addr, align 8
  %0 = load i32, ptr %level.addr, align 4
  switch i32 %0, label %sw.default621 [
    i32 1, label %sw.bb
    i32 6, label %sw.bb215
    i32 17, label %sw.bb215
    i32 0, label %sw.bb299
    i32 41, label %sw.bb402
    i32 270, label %sw.bb507
  ]

sw.bb:                                            ; preds = %entry
  store i32 1, ptr %level.addr, align 4
  %1 = load i32, ptr %optname.addr, align 4
  switch i32 %1, label %sw.default [
    i32 28, label %sw.bb1
    i32 20, label %sw.bb2
    i32 21, label %sw.bb38
    i32 17, label %sw.bb39
    i32 31, label %sw.bb97
    i32 13, label %sw.bb140
    i32 1, label %sw.bb195
    i32 2, label %sw.bb196
    i32 15, label %sw.bb197
    i32 3, label %sw.bb198
    i32 4, label %sw.bb199
    i32 5, label %sw.bb200
    i32 6, label %sw.bb201
    i32 7, label %sw.bb202
    i32 8, label %sw.bb203
    i32 9, label %sw.bb204
    i32 10, label %sw.bb205
    i32 11, label %sw.bb206
    i32 12, label %sw.bb207
    i32 14, label %sw.bb208
    i32 16, label %sw.bb209
    i32 29, label %sw.bb210
    i32 18, label %sw.bb211
    i32 30, label %sw.bb212
    i32 38, label %sw.bb213
    i32 39, label %sw.bb214
  ]

sw.bb1:                                           ; preds = %sw.bb
  br label %unimplemented

sw.bb2:                                           ; preds = %sw.bb
  store i32 20, ptr %optname.addr, align 4
  br label %get_timeout

get_timeout:                                      ; preds = %sw.bb38, %sw.bb2
  %2 = load i64, ptr %optlen.addr, align 8
  store i64 %2, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %3 = load i64, ptr %__gaddr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %3, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call, ptr %__hptr, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %get_timeout
  br label %do.body

do.body:                                          ; preds = %if.then
  %4 = load ptr, ptr %__hptr, align 8
  %call3 = call i32 @ldl_le_p(ptr noundef %4)
  store i32 %call3, ptr %len, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  %5 = load ptr, ptr %__hptr, align 8
  %6 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %5, i64 noundef %6, i64 noundef 0)
  br label %if.end

if.else:                                          ; preds = %get_timeout
  store i32 0, ptr %len, align 4
  store i64 -14, ptr %__ret, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %7 = load i64, ptr %__ret, align 8
  store i64 %7, ptr %tmp, align 8
  %8 = load i64, ptr %tmp, align 8
  %tobool4 = icmp ne i64 %8, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %9 = load i32, ptr %len, align 4
  %cmp = icmp slt i32 %9, 0
  br i1 %cmp, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end6
  store i64 -22, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end6
  store i32 16, ptr %tvlen, align 4
  %10 = load i32, ptr %sockfd.addr, align 4
  %11 = load i32, ptr %level.addr, align 4
  %12 = load i32, ptr %optname.addr, align 4
  %call9 = call i32 @getsockopt(i32 noundef %10, i32 noundef %11, i32 noundef %12, ptr noundef %tv, ptr noundef %tvlen) #14
  %conv = sext i32 %call9 to i64
  %call10 = call i64 @get_errno(i64 noundef %conv)
  store i64 %call10, ptr %ret, align 8
  %13 = load i64, ptr %ret, align 8
  %cmp11 = icmp slt i64 %13, 0
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end8
  %14 = load i64, ptr %ret, align 8
  store i64 %14, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end8
  %15 = load i32, ptr %len, align 4
  %conv15 = sext i32 %15 to i64
  %cmp16 = icmp ugt i64 %conv15, 16
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end14
  store i32 16, ptr %len, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end14
  %16 = load i64, ptr %optval_addr.addr, align 8
  %call20 = call i64 @copy_to_user_timeval(i64 noundef %16, ptr noundef %tv)
  %tobool21 = icmp ne i64 %call20, 0
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end19
  store i64 -14, ptr %retval, align 8
  br label %return

if.end23:                                         ; preds = %if.end19
  %17 = load i64, ptr %optlen.addr, align 8
  store i64 %17, ptr %__gaddr24, align 8
  store i64 0, ptr %__ret26, align 8
  %18 = load i64, ptr %__gaddr24, align 8
  %call27 = call ptr @lock_user(i32 noundef 3, i64 noundef %18, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call27, ptr %__hptr25, align 8
  %tobool28 = icmp ne ptr %call27, null
  br i1 %tobool28, label %if.then29, label %if.else32

if.then29:                                        ; preds = %if.end23
  br label %do.body30

do.body30:                                        ; preds = %if.then29
  %19 = load ptr, ptr %__hptr25, align 8
  %20 = load i32, ptr %len, align 4
  call void @stl_le_p(ptr noundef %19, i32 noundef %20)
  br label %do.end31

do.end31:                                         ; preds = %do.body30
  %21 = load ptr, ptr %__hptr25, align 8
  %22 = load i64, ptr %__gaddr24, align 8
  call void @unlock_user(ptr noundef %21, i64 noundef %22, i64 noundef 4)
  br label %if.end33

if.else32:                                        ; preds = %if.end23
  store i64 -14, ptr %__ret26, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.else32, %do.end31
  %23 = load i64, ptr %__ret26, align 8
  store i64 %23, ptr %tmp34, align 8
  %24 = load i64, ptr %tmp34, align 8
  %tobool35 = icmp ne i64 %24, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end33
  store i64 -14, ptr %retval, align 8
  br label %return

if.end37:                                         ; preds = %if.end33
  br label %sw.epilog

sw.bb38:                                          ; preds = %sw.bb
  store i32 21, ptr %optname.addr, align 4
  br label %get_timeout

sw.bb39:                                          ; preds = %sw.bb
  %25 = load i64, ptr %optlen.addr, align 8
  store i64 %25, ptr %__gaddr40, align 8
  store i64 0, ptr %__ret42, align 8
  %26 = load i64, ptr %__gaddr40, align 8
  %call43 = call ptr @lock_user(i32 noundef 1, i64 noundef %26, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call43, ptr %__hptr41, align 8
  %tobool44 = icmp ne ptr %call43, null
  br i1 %tobool44, label %if.then45, label %if.else49

if.then45:                                        ; preds = %sw.bb39
  br label %do.body46

do.body46:                                        ; preds = %if.then45
  %27 = load ptr, ptr %__hptr41, align 8
  %call47 = call i32 @ldl_le_p(ptr noundef %27)
  store i32 %call47, ptr %len, align 4
  br label %do.end48

do.end48:                                         ; preds = %do.body46
  %28 = load ptr, ptr %__hptr41, align 8
  %29 = load i64, ptr %__gaddr40, align 8
  call void @unlock_user(ptr noundef %28, i64 noundef %29, i64 noundef 0)
  br label %if.end50

if.else49:                                        ; preds = %sw.bb39
  store i32 0, ptr %len, align 4
  store i64 -14, ptr %__ret42, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.else49, %do.end48
  %30 = load i64, ptr %__ret42, align 8
  store i64 %30, ptr %tmp51, align 8
  %31 = load i64, ptr %tmp51, align 8
  %tobool52 = icmp ne i64 %31, 0
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end50
  store i64 -14, ptr %retval, align 8
  br label %return

if.end54:                                         ; preds = %if.end50
  %32 = load i32, ptr %len, align 4
  %cmp55 = icmp slt i32 %32, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.end54
  store i64 -22, ptr %retval, align 8
  br label %return

if.end58:                                         ; preds = %if.end54
  store i32 12, ptr %crlen, align 4
  %33 = load i32, ptr %sockfd.addr, align 4
  %34 = load i32, ptr %level.addr, align 4
  %call59 = call i32 @getsockopt(i32 noundef %33, i32 noundef %34, i32 noundef 17, ptr noundef %cr, ptr noundef %crlen) #14
  %conv60 = sext i32 %call59 to i64
  %call61 = call i64 @get_errno(i64 noundef %conv60)
  store i64 %call61, ptr %ret, align 8
  %35 = load i64, ptr %ret, align 8
  %cmp62 = icmp slt i64 %35, 0
  br i1 %cmp62, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.end58
  %36 = load i64, ptr %ret, align 8
  store i64 %36, ptr %retval, align 8
  br label %return

if.end65:                                         ; preds = %if.end58
  %37 = load i32, ptr %len, align 4
  %38 = load i32, ptr %crlen, align 4
  %cmp66 = icmp ugt i32 %37, %38
  br i1 %cmp66, label %if.then68, label %if.end69

if.then68:                                        ; preds = %if.end65
  %39 = load i32, ptr %crlen, align 4
  store i32 %39, ptr %len, align 4
  br label %if.end69

if.end69:                                         ; preds = %if.then68, %if.end65
  %40 = load i64, ptr %optval_addr.addr, align 8
  %call70 = call ptr @lock_user(i32 noundef 3, i64 noundef %40, i64 noundef 12, i1 noundef zeroext false)
  store ptr %call70, ptr %tcr, align 8
  %tobool71 = icmp ne ptr %call70, null
  br i1 %tobool71, label %if.end73, label %if.then72

if.then72:                                        ; preds = %if.end69
  store i64 -14, ptr %retval, align 8
  br label %return

if.end73:                                         ; preds = %if.end69
  br label %do.body74

do.body74:                                        ; preds = %if.end73
  %41 = load ptr, ptr %tcr, align 8
  %pid = getelementptr inbounds %struct.target_ucred, ptr %41, i32 0, i32 0
  %pid75 = getelementptr inbounds %struct.ucred, ptr %cr, i32 0, i32 0
  %42 = load i32, ptr %pid75, align 4
  call void @stl_le_p(ptr noundef %pid, i32 noundef %42)
  br label %do.end76

do.end76:                                         ; preds = %do.body74
  br label %do.body77

do.body77:                                        ; preds = %do.end76
  %43 = load ptr, ptr %tcr, align 8
  %uid = getelementptr inbounds %struct.target_ucred, ptr %43, i32 0, i32 1
  %uid78 = getelementptr inbounds %struct.ucred, ptr %cr, i32 0, i32 1
  %44 = load i32, ptr %uid78, align 4
  call void @stl_le_p(ptr noundef %uid, i32 noundef %44)
  br label %do.end79

do.end79:                                         ; preds = %do.body77
  br label %do.body80

do.body80:                                        ; preds = %do.end79
  %45 = load ptr, ptr %tcr, align 8
  %gid = getelementptr inbounds %struct.target_ucred, ptr %45, i32 0, i32 2
  %gid81 = getelementptr inbounds %struct.ucred, ptr %cr, i32 0, i32 2
  %46 = load i32, ptr %gid81, align 4
  call void @stl_le_p(ptr noundef %gid, i32 noundef %46)
  br label %do.end82

do.end82:                                         ; preds = %do.body80
  %47 = load ptr, ptr %tcr, align 8
  %48 = load i64, ptr %optval_addr.addr, align 8
  call void @unlock_user(ptr noundef %47, i64 noundef %48, i64 noundef 12)
  %49 = load i64, ptr %optlen.addr, align 8
  store i64 %49, ptr %__gaddr83, align 8
  store i64 0, ptr %__ret85, align 8
  %50 = load i64, ptr %__gaddr83, align 8
  %call86 = call ptr @lock_user(i32 noundef 3, i64 noundef %50, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call86, ptr %__hptr84, align 8
  %tobool87 = icmp ne ptr %call86, null
  br i1 %tobool87, label %if.then88, label %if.else91

if.then88:                                        ; preds = %do.end82
  br label %do.body89

do.body89:                                        ; preds = %if.then88
  %51 = load ptr, ptr %__hptr84, align 8
  %52 = load i32, ptr %len, align 4
  call void @stl_le_p(ptr noundef %51, i32 noundef %52)
  br label %do.end90

do.end90:                                         ; preds = %do.body89
  %53 = load ptr, ptr %__hptr84, align 8
  %54 = load i64, ptr %__gaddr83, align 8
  call void @unlock_user(ptr noundef %53, i64 noundef %54, i64 noundef 4)
  br label %if.end92

if.else91:                                        ; preds = %do.end82
  store i64 -14, ptr %__ret85, align 8
  br label %if.end92

if.end92:                                         ; preds = %if.else91, %do.end90
  %55 = load i64, ptr %__ret85, align 8
  store i64 %55, ptr %tmp93, align 8
  %56 = load i64, ptr %tmp93, align 8
  %tobool94 = icmp ne i64 %56, 0
  br i1 %tobool94, label %if.then95, label %if.end96

if.then95:                                        ; preds = %if.end92
  store i64 -14, ptr %retval, align 8
  br label %return

if.end96:                                         ; preds = %if.end92
  br label %sw.epilog

sw.bb97:                                          ; preds = %sw.bb
  %57 = load i64, ptr %optlen.addr, align 8
  store i64 %57, ptr %__gaddr98, align 8
  store i64 0, ptr %__ret100, align 8
  %58 = load i64, ptr %__gaddr98, align 8
  %call101 = call ptr @lock_user(i32 noundef 1, i64 noundef %58, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call101, ptr %__hptr99, align 8
  %tobool102 = icmp ne ptr %call101, null
  br i1 %tobool102, label %if.then103, label %if.else107

if.then103:                                       ; preds = %sw.bb97
  br label %do.body104

do.body104:                                       ; preds = %if.then103
  %59 = load ptr, ptr %__hptr99, align 8
  %call105 = call i32 @ldl_le_p(ptr noundef %59)
  store i32 %call105, ptr %len, align 4
  br label %do.end106

do.end106:                                        ; preds = %do.body104
  %60 = load ptr, ptr %__hptr99, align 8
  %61 = load i64, ptr %__gaddr98, align 8
  call void @unlock_user(ptr noundef %60, i64 noundef %61, i64 noundef 0)
  br label %if.end108

if.else107:                                       ; preds = %sw.bb97
  store i32 0, ptr %len, align 4
  store i64 -14, ptr %__ret100, align 8
  br label %if.end108

if.end108:                                        ; preds = %if.else107, %do.end106
  %62 = load i64, ptr %__ret100, align 8
  store i64 %62, ptr %tmp109, align 8
  %63 = load i64, ptr %tmp109, align 8
  %tobool110 = icmp ne i64 %63, 0
  br i1 %tobool110, label %if.then111, label %if.end112

if.then111:                                       ; preds = %if.end108
  store i64 -14, ptr %retval, align 8
  br label %return

if.end112:                                        ; preds = %if.end108
  %64 = load i32, ptr %len, align 4
  %cmp113 = icmp slt i32 %64, 0
  br i1 %cmp113, label %if.then115, label %if.end116

if.then115:                                       ; preds = %if.end112
  store i64 -22, ptr %retval, align 8
  br label %return

if.end116:                                        ; preds = %if.end112
  %65 = load i64, ptr %optval_addr.addr, align 8
  %66 = load i32, ptr %len, align 4
  %conv117 = sext i32 %66 to i64
  %call118 = call ptr @lock_user(i32 noundef 3, i64 noundef %65, i64 noundef %conv117, i1 noundef zeroext false)
  store ptr %call118, ptr %name, align 8
  %67 = load ptr, ptr %name, align 8
  %tobool119 = icmp ne ptr %67, null
  br i1 %tobool119, label %if.end121, label %if.then120

if.then120:                                       ; preds = %if.end116
  store i64 -14, ptr %retval, align 8
  br label %return

if.end121:                                        ; preds = %if.end116
  %68 = load i32, ptr %len, align 4
  store i32 %68, ptr %lv, align 4
  %69 = load i32, ptr %sockfd.addr, align 4
  %70 = load i32, ptr %level.addr, align 4
  %71 = load ptr, ptr %name, align 8
  %call122 = call i32 @getsockopt(i32 noundef %69, i32 noundef %70, i32 noundef 31, ptr noundef %71, ptr noundef %lv) #14
  %conv123 = sext i32 %call122 to i64
  %call124 = call i64 @get_errno(i64 noundef %conv123)
  store i64 %call124, ptr %ret, align 8
  %72 = load i64, ptr %optlen.addr, align 8
  store i64 %72, ptr %__gaddr125, align 8
  store i64 0, ptr %__ret127, align 8
  %73 = load i64, ptr %__gaddr125, align 8
  %call128 = call ptr @lock_user(i32 noundef 3, i64 noundef %73, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call128, ptr %__hptr126, align 8
  %tobool129 = icmp ne ptr %call128, null
  br i1 %tobool129, label %if.then130, label %if.else133

if.then130:                                       ; preds = %if.end121
  br label %do.body131

do.body131:                                       ; preds = %if.then130
  %74 = load ptr, ptr %__hptr126, align 8
  %75 = load i32, ptr %lv, align 4
  call void @stl_le_p(ptr noundef %74, i32 noundef %75)
  br label %do.end132

do.end132:                                        ; preds = %do.body131
  %76 = load ptr, ptr %__hptr126, align 8
  %77 = load i64, ptr %__gaddr125, align 8
  call void @unlock_user(ptr noundef %76, i64 noundef %77, i64 noundef 4)
  br label %if.end134

if.else133:                                       ; preds = %if.end121
  store i64 -14, ptr %__ret127, align 8
  br label %if.end134

if.end134:                                        ; preds = %if.else133, %do.end132
  %78 = load i64, ptr %__ret127, align 8
  store i64 %78, ptr %tmp135, align 8
  %79 = load i64, ptr %tmp135, align 8
  %tobool136 = icmp ne i64 %79, 0
  br i1 %tobool136, label %if.then137, label %if.end138

if.then137:                                       ; preds = %if.end134
  store i64 -14, ptr %ret, align 8
  br label %if.end138

if.end138:                                        ; preds = %if.then137, %if.end134
  %80 = load ptr, ptr %name, align 8
  %81 = load i64, ptr %optval_addr.addr, align 8
  %82 = load i32, ptr %lv, align 4
  %conv139 = zext i32 %82 to i64
  call void @unlock_user(ptr noundef %80, i64 noundef %81, i64 noundef %conv139)
  br label %sw.epilog

sw.bb140:                                         ; preds = %sw.bb
  %83 = load i64, ptr %optlen.addr, align 8
  store i64 %83, ptr %__gaddr141, align 8
  store i64 0, ptr %__ret143, align 8
  %84 = load i64, ptr %__gaddr141, align 8
  %call144 = call ptr @lock_user(i32 noundef 1, i64 noundef %84, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call144, ptr %__hptr142, align 8
  %tobool145 = icmp ne ptr %call144, null
  br i1 %tobool145, label %if.then146, label %if.else150

if.then146:                                       ; preds = %sw.bb140
  br label %do.body147

do.body147:                                       ; preds = %if.then146
  %85 = load ptr, ptr %__hptr142, align 8
  %call148 = call i32 @ldl_le_p(ptr noundef %85)
  store i32 %call148, ptr %len, align 4
  br label %do.end149

do.end149:                                        ; preds = %do.body147
  %86 = load ptr, ptr %__hptr142, align 8
  %87 = load i64, ptr %__gaddr141, align 8
  call void @unlock_user(ptr noundef %86, i64 noundef %87, i64 noundef 0)
  br label %if.end151

if.else150:                                       ; preds = %sw.bb140
  store i32 0, ptr %len, align 4
  store i64 -14, ptr %__ret143, align 8
  br label %if.end151

if.end151:                                        ; preds = %if.else150, %do.end149
  %88 = load i64, ptr %__ret143, align 8
  store i64 %88, ptr %tmp152, align 8
  %89 = load i64, ptr %tmp152, align 8
  %tobool153 = icmp ne i64 %89, 0
  br i1 %tobool153, label %if.then154, label %if.end155

if.then154:                                       ; preds = %if.end151
  store i64 -14, ptr %retval, align 8
  br label %return

if.end155:                                        ; preds = %if.end151
  %90 = load i32, ptr %len, align 4
  %cmp156 = icmp slt i32 %90, 0
  br i1 %cmp156, label %if.then158, label %if.end159

if.then158:                                       ; preds = %if.end155
  store i64 -22, ptr %retval, align 8
  br label %return

if.end159:                                        ; preds = %if.end155
  store i32 8, ptr %lglen, align 4
  %91 = load i32, ptr %sockfd.addr, align 4
  %92 = load i32, ptr %level.addr, align 4
  %call160 = call i32 @getsockopt(i32 noundef %91, i32 noundef %92, i32 noundef 13, ptr noundef %lg, ptr noundef %lglen) #14
  %conv161 = sext i32 %call160 to i64
  %call162 = call i64 @get_errno(i64 noundef %conv161)
  store i64 %call162, ptr %ret, align 8
  %93 = load i64, ptr %ret, align 8
  %cmp163 = icmp slt i64 %93, 0
  br i1 %cmp163, label %if.then165, label %if.end166

if.then165:                                       ; preds = %if.end159
  %94 = load i64, ptr %ret, align 8
  store i64 %94, ptr %retval, align 8
  br label %return

if.end166:                                        ; preds = %if.end159
  %95 = load i32, ptr %len, align 4
  %96 = load i32, ptr %lglen, align 4
  %cmp167 = icmp ugt i32 %95, %96
  br i1 %cmp167, label %if.then169, label %if.end170

if.then169:                                       ; preds = %if.end166
  %97 = load i32, ptr %lglen, align 4
  store i32 %97, ptr %len, align 4
  br label %if.end170

if.end170:                                        ; preds = %if.then169, %if.end166
  %98 = load i64, ptr %optval_addr.addr, align 8
  %call171 = call ptr @lock_user(i32 noundef 3, i64 noundef %98, i64 noundef 8, i1 noundef zeroext false)
  store ptr %call171, ptr %tlg, align 8
  %tobool172 = icmp ne ptr %call171, null
  br i1 %tobool172, label %if.end174, label %if.then173

if.then173:                                       ; preds = %if.end170
  store i64 -14, ptr %retval, align 8
  br label %return

if.end174:                                        ; preds = %if.end170
  br label %do.body175

do.body175:                                       ; preds = %if.end174
  %99 = load ptr, ptr %tlg, align 8
  %l_onoff = getelementptr inbounds %struct.target_linger, ptr %99, i32 0, i32 0
  %l_onoff176 = getelementptr inbounds %struct.linger, ptr %lg, i32 0, i32 0
  %100 = load i32, ptr %l_onoff176, align 4
  call void @stl_le_p(ptr noundef %l_onoff, i32 noundef %100)
  br label %do.end177

do.end177:                                        ; preds = %do.body175
  br label %do.body178

do.body178:                                       ; preds = %do.end177
  %101 = load ptr, ptr %tlg, align 8
  %l_linger = getelementptr inbounds %struct.target_linger, ptr %101, i32 0, i32 1
  %l_linger179 = getelementptr inbounds %struct.linger, ptr %lg, i32 0, i32 1
  %102 = load i32, ptr %l_linger179, align 4
  call void @stl_le_p(ptr noundef %l_linger, i32 noundef %102)
  br label %do.end180

do.end180:                                        ; preds = %do.body178
  %103 = load ptr, ptr %tlg, align 8
  %104 = load i64, ptr %optval_addr.addr, align 8
  call void @unlock_user(ptr noundef %103, i64 noundef %104, i64 noundef 8)
  %105 = load i64, ptr %optlen.addr, align 8
  store i64 %105, ptr %__gaddr181, align 8
  store i64 0, ptr %__ret183, align 8
  %106 = load i64, ptr %__gaddr181, align 8
  %call184 = call ptr @lock_user(i32 noundef 3, i64 noundef %106, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call184, ptr %__hptr182, align 8
  %tobool185 = icmp ne ptr %call184, null
  br i1 %tobool185, label %if.then186, label %if.else189

if.then186:                                       ; preds = %do.end180
  br label %do.body187

do.body187:                                       ; preds = %if.then186
  %107 = load ptr, ptr %__hptr182, align 8
  %108 = load i32, ptr %len, align 4
  call void @stl_le_p(ptr noundef %107, i32 noundef %108)
  br label %do.end188

do.end188:                                        ; preds = %do.body187
  %109 = load ptr, ptr %__hptr182, align 8
  %110 = load i64, ptr %__gaddr181, align 8
  call void @unlock_user(ptr noundef %109, i64 noundef %110, i64 noundef 4)
  br label %if.end190

if.else189:                                       ; preds = %do.end180
  store i64 -14, ptr %__ret183, align 8
  br label %if.end190

if.end190:                                        ; preds = %if.else189, %do.end188
  %111 = load i64, ptr %__ret183, align 8
  store i64 %111, ptr %tmp191, align 8
  %112 = load i64, ptr %tmp191, align 8
  %tobool192 = icmp ne i64 %112, 0
  br i1 %tobool192, label %if.then193, label %if.end194

if.then193:                                       ; preds = %if.end190
  store i64 -14, ptr %retval, align 8
  br label %return

if.end194:                                        ; preds = %if.end190
  br label %sw.epilog

sw.bb195:                                         ; preds = %sw.bb
  store i32 1, ptr %optname.addr, align 4
  br label %int_case

sw.bb196:                                         ; preds = %sw.bb
  store i32 2, ptr %optname.addr, align 4
  br label %int_case

sw.bb197:                                         ; preds = %sw.bb
  store i32 15, ptr %optname.addr, align 4
  br label %int_case

sw.bb198:                                         ; preds = %sw.bb
  store i32 3, ptr %optname.addr, align 4
  br label %int_case

sw.bb199:                                         ; preds = %sw.bb
  store i32 4, ptr %optname.addr, align 4
  br label %int_case

sw.bb200:                                         ; preds = %sw.bb
  store i32 5, ptr %optname.addr, align 4
  br label %int_case

sw.bb201:                                         ; preds = %sw.bb
  store i32 6, ptr %optname.addr, align 4
  br label %int_case

sw.bb202:                                         ; preds = %sw.bb
  store i32 7, ptr %optname.addr, align 4
  br label %int_case

sw.bb203:                                         ; preds = %sw.bb
  store i32 8, ptr %optname.addr, align 4
  br label %int_case

sw.bb204:                                         ; preds = %sw.bb
  store i32 9, ptr %optname.addr, align 4
  br label %int_case

sw.bb205:                                         ; preds = %sw.bb
  store i32 10, ptr %optname.addr, align 4
  br label %int_case

sw.bb206:                                         ; preds = %sw.bb
  store i32 11, ptr %optname.addr, align 4
  br label %int_case

sw.bb207:                                         ; preds = %sw.bb
  store i32 12, ptr %optname.addr, align 4
  br label %int_case

sw.bb208:                                         ; preds = %sw.bb
  store i32 14, ptr %optname.addr, align 4
  br label %int_case

sw.bb209:                                         ; preds = %sw.bb
  store i32 16, ptr %optname.addr, align 4
  br label %int_case

sw.bb210:                                         ; preds = %sw.bb
  store i32 29, ptr %optname.addr, align 4
  br label %int_case

sw.bb211:                                         ; preds = %sw.bb
  store i32 18, ptr %optname.addr, align 4
  br label %int_case

sw.bb212:                                         ; preds = %sw.bb
  store i32 30, ptr %optname.addr, align 4
  br label %int_case

sw.bb213:                                         ; preds = %sw.bb
  store i32 38, ptr %optname.addr, align 4
  br label %int_case

sw.bb214:                                         ; preds = %sw.bb
  store i32 39, ptr %optname.addr, align 4
  br label %int_case

sw.default:                                       ; preds = %sw.bb
  br label %int_case

sw.epilog:                                        ; preds = %if.end194, %if.end138, %if.end96, %if.end37
  br label %sw.epilog630

sw.bb215:                                         ; preds = %entry, %entry
  br label %int_case

int_case:                                         ; preds = %sw.bb215, %sw.default, %sw.bb214, %sw.bb213, %sw.bb212, %sw.bb211, %sw.bb210, %sw.bb209, %sw.bb208, %sw.bb207, %sw.bb206, %sw.bb205, %sw.bb204, %sw.bb203, %sw.bb202, %sw.bb201, %sw.bb200, %sw.bb199, %sw.bb198, %sw.bb197, %sw.bb196, %sw.bb195
  %113 = load i64, ptr %optlen.addr, align 8
  store i64 %113, ptr %__gaddr216, align 8
  store i64 0, ptr %__ret218, align 8
  %114 = load i64, ptr %__gaddr216, align 8
  %call219 = call ptr @lock_user(i32 noundef 1, i64 noundef %114, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call219, ptr %__hptr217, align 8
  %tobool220 = icmp ne ptr %call219, null
  br i1 %tobool220, label %if.then221, label %if.else225

if.then221:                                       ; preds = %int_case
  br label %do.body222

do.body222:                                       ; preds = %if.then221
  %115 = load ptr, ptr %__hptr217, align 8
  %call223 = call i32 @ldl_le_p(ptr noundef %115)
  store i32 %call223, ptr %len, align 4
  br label %do.end224

do.end224:                                        ; preds = %do.body222
  %116 = load ptr, ptr %__hptr217, align 8
  %117 = load i64, ptr %__gaddr216, align 8
  call void @unlock_user(ptr noundef %116, i64 noundef %117, i64 noundef 0)
  br label %if.end226

if.else225:                                       ; preds = %int_case
  store i32 0, ptr %len, align 4
  store i64 -14, ptr %__ret218, align 8
  br label %if.end226

if.end226:                                        ; preds = %if.else225, %do.end224
  %118 = load i64, ptr %__ret218, align 8
  store i64 %118, ptr %tmp227, align 8
  %119 = load i64, ptr %tmp227, align 8
  %tobool228 = icmp ne i64 %119, 0
  br i1 %tobool228, label %if.then229, label %if.end230

if.then229:                                       ; preds = %if.end226
  store i64 -14, ptr %retval, align 8
  br label %return

if.end230:                                        ; preds = %if.end226
  %120 = load i32, ptr %len, align 4
  %cmp231 = icmp slt i32 %120, 0
  br i1 %cmp231, label %if.then233, label %if.end234

if.then233:                                       ; preds = %if.end230
  store i64 -22, ptr %retval, align 8
  br label %return

if.end234:                                        ; preds = %if.end230
  store i32 4, ptr %lv, align 4
  %121 = load i32, ptr %sockfd.addr, align 4
  %122 = load i32, ptr %level.addr, align 4
  %123 = load i32, ptr %optname.addr, align 4
  %call235 = call i32 @getsockopt(i32 noundef %121, i32 noundef %122, i32 noundef %123, ptr noundef %val, ptr noundef %lv) #14
  %conv236 = sext i32 %call235 to i64
  %call237 = call i64 @get_errno(i64 noundef %conv236)
  store i64 %call237, ptr %ret, align 8
  %124 = load i64, ptr %ret, align 8
  %cmp238 = icmp slt i64 %124, 0
  br i1 %cmp238, label %if.then240, label %if.end241

if.then240:                                       ; preds = %if.end234
  %125 = load i64, ptr %ret, align 8
  store i64 %125, ptr %retval, align 8
  br label %return

if.end241:                                        ; preds = %if.end234
  %126 = load i32, ptr %optname.addr, align 4
  switch i32 %126, label %sw.epilog246 [
    i32 3, label %sw.bb242
    i32 4, label %sw.bb244
  ]

sw.bb242:                                         ; preds = %if.end241
  %127 = load i32, ptr %val, align 4
  %call243 = call i32 @host_to_target_sock_type(i32 noundef %127)
  store i32 %call243, ptr %val, align 4
  br label %sw.epilog246

sw.bb244:                                         ; preds = %if.end241
  %128 = load i32, ptr %val, align 4
  %call245 = call i32 @host_to_target_errno(i32 noundef %128)
  store i32 %call245, ptr %val, align 4
  br label %sw.epilog246

sw.epilog246:                                     ; preds = %sw.bb244, %sw.bb242, %if.end241
  %129 = load i32, ptr %len, align 4
  %130 = load i32, ptr %lv, align 4
  %cmp247 = icmp ugt i32 %129, %130
  br i1 %cmp247, label %if.then249, label %if.end250

if.then249:                                       ; preds = %sw.epilog246
  %131 = load i32, ptr %lv, align 4
  store i32 %131, ptr %len, align 4
  br label %if.end250

if.end250:                                        ; preds = %if.then249, %sw.epilog246
  %132 = load i32, ptr %len, align 4
  %cmp251 = icmp eq i32 %132, 4
  br i1 %cmp251, label %if.then253, label %if.else268

if.then253:                                       ; preds = %if.end250
  %133 = load i64, ptr %optval_addr.addr, align 8
  store i64 %133, ptr %__gaddr254, align 8
  store i64 0, ptr %__ret256, align 8
  %134 = load i64, ptr %__gaddr254, align 8
  %call257 = call ptr @lock_user(i32 noundef 3, i64 noundef %134, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call257, ptr %__hptr255, align 8
  %tobool258 = icmp ne ptr %call257, null
  br i1 %tobool258, label %if.then259, label %if.else262

if.then259:                                       ; preds = %if.then253
  br label %do.body260

do.body260:                                       ; preds = %if.then259
  %135 = load ptr, ptr %__hptr255, align 8
  %136 = load i32, ptr %val, align 4
  call void @stl_le_p(ptr noundef %135, i32 noundef %136)
  br label %do.end261

do.end261:                                        ; preds = %do.body260
  %137 = load ptr, ptr %__hptr255, align 8
  %138 = load i64, ptr %__gaddr254, align 8
  call void @unlock_user(ptr noundef %137, i64 noundef %138, i64 noundef 4)
  br label %if.end263

if.else262:                                       ; preds = %if.then253
  store i64 -14, ptr %__ret256, align 8
  br label %if.end263

if.end263:                                        ; preds = %if.else262, %do.end261
  %139 = load i64, ptr %__ret256, align 8
  store i64 %139, ptr %tmp264, align 8
  %140 = load i64, ptr %tmp264, align 8
  %tobool265 = icmp ne i64 %140, 0
  br i1 %tobool265, label %if.then266, label %if.end267

if.then266:                                       ; preds = %if.end263
  store i64 -14, ptr %retval, align 8
  br label %return

if.end267:                                        ; preds = %if.end263
  br label %if.end284

if.else268:                                       ; preds = %if.end250
  %141 = load i64, ptr %optval_addr.addr, align 8
  store i64 %141, ptr %__gaddr269, align 8
  store i64 0, ptr %__ret271, align 8
  %142 = load i64, ptr %__gaddr269, align 8
  %call272 = call ptr @lock_user(i32 noundef 3, i64 noundef %142, i64 noundef 1, i1 noundef zeroext false)
  store ptr %call272, ptr %__hptr270, align 8
  %tobool273 = icmp ne ptr %call272, null
  br i1 %tobool273, label %if.then274, label %if.else278

if.then274:                                       ; preds = %if.else268
  br label %do.body275

do.body275:                                       ; preds = %if.then274
  %143 = load ptr, ptr %__hptr270, align 8
  %144 = load i32, ptr %val, align 4
  %conv276 = trunc i32 %144 to i8
  call void @stb_p(ptr noundef %143, i8 noundef zeroext %conv276)
  br label %do.end277

do.end277:                                        ; preds = %do.body275
  %145 = load ptr, ptr %__hptr270, align 8
  %146 = load i64, ptr %__gaddr269, align 8
  call void @unlock_user(ptr noundef %145, i64 noundef %146, i64 noundef 1)
  br label %if.end279

if.else278:                                       ; preds = %if.else268
  store i64 -14, ptr %__ret271, align 8
  br label %if.end279

if.end279:                                        ; preds = %if.else278, %do.end277
  %147 = load i64, ptr %__ret271, align 8
  store i64 %147, ptr %tmp280, align 8
  %148 = load i64, ptr %tmp280, align 8
  %tobool281 = icmp ne i64 %148, 0
  br i1 %tobool281, label %if.then282, label %if.end283

if.then282:                                       ; preds = %if.end279
  store i64 -14, ptr %retval, align 8
  br label %return

if.end283:                                        ; preds = %if.end279
  br label %if.end284

if.end284:                                        ; preds = %if.end283, %if.end267
  %149 = load i64, ptr %optlen.addr, align 8
  store i64 %149, ptr %__gaddr285, align 8
  store i64 0, ptr %__ret287, align 8
  %150 = load i64, ptr %__gaddr285, align 8
  %call288 = call ptr @lock_user(i32 noundef 3, i64 noundef %150, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call288, ptr %__hptr286, align 8
  %tobool289 = icmp ne ptr %call288, null
  br i1 %tobool289, label %if.then290, label %if.else293

if.then290:                                       ; preds = %if.end284
  br label %do.body291

do.body291:                                       ; preds = %if.then290
  %151 = load ptr, ptr %__hptr286, align 8
  %152 = load i32, ptr %len, align 4
  call void @stl_le_p(ptr noundef %151, i32 noundef %152)
  br label %do.end292

do.end292:                                        ; preds = %do.body291
  %153 = load ptr, ptr %__hptr286, align 8
  %154 = load i64, ptr %__gaddr285, align 8
  call void @unlock_user(ptr noundef %153, i64 noundef %154, i64 noundef 4)
  br label %if.end294

if.else293:                                       ; preds = %if.end284
  store i64 -14, ptr %__ret287, align 8
  br label %if.end294

if.end294:                                        ; preds = %if.else293, %do.end292
  %155 = load i64, ptr %__ret287, align 8
  store i64 %155, ptr %tmp295, align 8
  %156 = load i64, ptr %tmp295, align 8
  %tobool296 = icmp ne i64 %156, 0
  br i1 %tobool296, label %if.then297, label %if.end298

if.then297:                                       ; preds = %if.end294
  store i64 -14, ptr %retval, align 8
  br label %return

if.end298:                                        ; preds = %if.end294
  br label %sw.epilog630

sw.bb299:                                         ; preds = %entry
  %157 = load i32, ptr %optname.addr, align 4
  switch i32 %157, label %sw.default400 [
    i32 1, label %sw.bb300
    i32 2, label %sw.bb300
    i32 3, label %sw.bb300
    i32 5, label %sw.bb300
    i32 6, label %sw.bb300
    i32 7, label %sw.bb300
    i32 8, label %sw.bb300
    i32 10, label %sw.bb300
    i32 11, label %sw.bb300
    i32 13, label %sw.bb300
    i32 15, label %sw.bb300
    i32 33, label %sw.bb300
    i32 34, label %sw.bb300
  ]

sw.bb300:                                         ; preds = %sw.bb299, %sw.bb299, %sw.bb299, %sw.bb299, %sw.bb299, %sw.bb299, %sw.bb299, %sw.bb299, %sw.bb299, %sw.bb299, %sw.bb299, %sw.bb299, %sw.bb299
  %158 = load i64, ptr %optlen.addr, align 8
  store i64 %158, ptr %__gaddr301, align 8
  store i64 0, ptr %__ret303, align 8
  %159 = load i64, ptr %__gaddr301, align 8
  %call304 = call ptr @lock_user(i32 noundef 1, i64 noundef %159, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call304, ptr %__hptr302, align 8
  %tobool305 = icmp ne ptr %call304, null
  br i1 %tobool305, label %if.then306, label %if.else310

if.then306:                                       ; preds = %sw.bb300
  br label %do.body307

do.body307:                                       ; preds = %if.then306
  %160 = load ptr, ptr %__hptr302, align 8
  %call308 = call i32 @ldl_le_p(ptr noundef %160)
  store i32 %call308, ptr %len, align 4
  br label %do.end309

do.end309:                                        ; preds = %do.body307
  %161 = load ptr, ptr %__hptr302, align 8
  %162 = load i64, ptr %__gaddr301, align 8
  call void @unlock_user(ptr noundef %161, i64 noundef %162, i64 noundef 0)
  br label %if.end311

if.else310:                                       ; preds = %sw.bb300
  store i32 0, ptr %len, align 4
  store i64 -14, ptr %__ret303, align 8
  br label %if.end311

if.end311:                                        ; preds = %if.else310, %do.end309
  %163 = load i64, ptr %__ret303, align 8
  store i64 %163, ptr %tmp312, align 8
  %164 = load i64, ptr %tmp312, align 8
  %tobool313 = icmp ne i64 %164, 0
  br i1 %tobool313, label %if.then314, label %if.end315

if.then314:                                       ; preds = %if.end311
  store i64 -14, ptr %retval, align 8
  br label %return

if.end315:                                        ; preds = %if.end311
  %165 = load i32, ptr %len, align 4
  %cmp316 = icmp slt i32 %165, 0
  br i1 %cmp316, label %if.then318, label %if.end319

if.then318:                                       ; preds = %if.end315
  store i64 -22, ptr %retval, align 8
  br label %return

if.end319:                                        ; preds = %if.end315
  store i32 4, ptr %lv, align 4
  %166 = load i32, ptr %sockfd.addr, align 4
  %167 = load i32, ptr %level.addr, align 4
  %168 = load i32, ptr %optname.addr, align 4
  %call320 = call i32 @getsockopt(i32 noundef %166, i32 noundef %167, i32 noundef %168, ptr noundef %val, ptr noundef %lv) #14
  %conv321 = sext i32 %call320 to i64
  %call322 = call i64 @get_errno(i64 noundef %conv321)
  store i64 %call322, ptr %ret, align 8
  %169 = load i64, ptr %ret, align 8
  %cmp323 = icmp slt i64 %169, 0
  br i1 %cmp323, label %if.then325, label %if.end326

if.then325:                                       ; preds = %if.end319
  %170 = load i64, ptr %ret, align 8
  store i64 %170, ptr %retval, align 8
  br label %return

if.end326:                                        ; preds = %if.end319
  %171 = load i32, ptr %len, align 4
  %conv327 = sext i32 %171 to i64
  %cmp328 = icmp ult i64 %conv327, 4
  br i1 %cmp328, label %land.lhs.true, label %if.else366

land.lhs.true:                                    ; preds = %if.end326
  %172 = load i32, ptr %len, align 4
  %cmp330 = icmp sgt i32 %172, 0
  br i1 %cmp330, label %land.lhs.true332, label %if.else366

land.lhs.true332:                                 ; preds = %land.lhs.true
  %173 = load i32, ptr %val, align 4
  %cmp333 = icmp sge i32 %173, 0
  br i1 %cmp333, label %land.lhs.true335, label %if.else366

land.lhs.true335:                                 ; preds = %land.lhs.true332
  %174 = load i32, ptr %val, align 4
  %cmp336 = icmp slt i32 %174, 255
  br i1 %cmp336, label %if.then338, label %if.else366

if.then338:                                       ; preds = %land.lhs.true335
  store i32 1, ptr %len, align 4
  %175 = load i64, ptr %optlen.addr, align 8
  store i64 %175, ptr %__gaddr339, align 8
  store i64 0, ptr %__ret341, align 8
  %176 = load i64, ptr %__gaddr339, align 8
  %call342 = call ptr @lock_user(i32 noundef 3, i64 noundef %176, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call342, ptr %__hptr340, align 8
  %tobool343 = icmp ne ptr %call342, null
  br i1 %tobool343, label %if.then344, label %if.else347

if.then344:                                       ; preds = %if.then338
  br label %do.body345

do.body345:                                       ; preds = %if.then344
  %177 = load ptr, ptr %__hptr340, align 8
  %178 = load i32, ptr %len, align 4
  call void @stl_le_p(ptr noundef %177, i32 noundef %178)
  br label %do.end346

do.end346:                                        ; preds = %do.body345
  %179 = load ptr, ptr %__hptr340, align 8
  %180 = load i64, ptr %__gaddr339, align 8
  call void @unlock_user(ptr noundef %179, i64 noundef %180, i64 noundef 4)
  br label %if.end348

if.else347:                                       ; preds = %if.then338
  store i64 -14, ptr %__ret341, align 8
  br label %if.end348

if.end348:                                        ; preds = %if.else347, %do.end346
  %181 = load i64, ptr %__ret341, align 8
  store i64 %181, ptr %tmp349, align 8
  %182 = load i64, ptr %tmp349, align 8
  %tobool350 = icmp ne i64 %182, 0
  br i1 %tobool350, label %if.then364, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end348
  %183 = load i64, ptr %optval_addr.addr, align 8
  store i64 %183, ptr %__gaddr351, align 8
  store i64 0, ptr %__ret353, align 8
  %184 = load i64, ptr %__gaddr351, align 8
  %call354 = call ptr @lock_user(i32 noundef 3, i64 noundef %184, i64 noundef 1, i1 noundef zeroext false)
  store ptr %call354, ptr %__hptr352, align 8
  %tobool355 = icmp ne ptr %call354, null
  br i1 %tobool355, label %if.then356, label %if.else360

if.then356:                                       ; preds = %lor.lhs.false
  br label %do.body357

do.body357:                                       ; preds = %if.then356
  %185 = load ptr, ptr %__hptr352, align 8
  %186 = load i32, ptr %val, align 4
  %conv358 = trunc i32 %186 to i8
  call void @stb_p(ptr noundef %185, i8 noundef zeroext %conv358)
  br label %do.end359

do.end359:                                        ; preds = %do.body357
  %187 = load ptr, ptr %__hptr352, align 8
  %188 = load i64, ptr %__gaddr351, align 8
  call void @unlock_user(ptr noundef %187, i64 noundef %188, i64 noundef 1)
  br label %if.end361

if.else360:                                       ; preds = %lor.lhs.false
  store i64 -14, ptr %__ret353, align 8
  br label %if.end361

if.end361:                                        ; preds = %if.else360, %do.end359
  %189 = load i64, ptr %__ret353, align 8
  store i64 %189, ptr %tmp362, align 8
  %190 = load i64, ptr %tmp362, align 8
  %tobool363 = icmp ne i64 %190, 0
  br i1 %tobool363, label %if.then364, label %if.end365

if.then364:                                       ; preds = %if.end361, %if.end348
  store i64 -14, ptr %retval, align 8
  br label %return

if.end365:                                        ; preds = %if.end361
  br label %if.end399

if.else366:                                       ; preds = %land.lhs.true335, %land.lhs.true332, %land.lhs.true, %if.end326
  %191 = load i32, ptr %len, align 4
  %conv367 = sext i32 %191 to i64
  %cmp368 = icmp ugt i64 %conv367, 4
  br i1 %cmp368, label %if.then370, label %if.end371

if.then370:                                       ; preds = %if.else366
  store i32 4, ptr %len, align 4
  br label %if.end371

if.end371:                                        ; preds = %if.then370, %if.else366
  %192 = load i64, ptr %optlen.addr, align 8
  store i64 %192, ptr %__gaddr372, align 8
  store i64 0, ptr %__ret374, align 8
  %193 = load i64, ptr %__gaddr372, align 8
  %call375 = call ptr @lock_user(i32 noundef 3, i64 noundef %193, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call375, ptr %__hptr373, align 8
  %tobool376 = icmp ne ptr %call375, null
  br i1 %tobool376, label %if.then377, label %if.else380

if.then377:                                       ; preds = %if.end371
  br label %do.body378

do.body378:                                       ; preds = %if.then377
  %194 = load ptr, ptr %__hptr373, align 8
  %195 = load i32, ptr %len, align 4
  call void @stl_le_p(ptr noundef %194, i32 noundef %195)
  br label %do.end379

do.end379:                                        ; preds = %do.body378
  %196 = load ptr, ptr %__hptr373, align 8
  %197 = load i64, ptr %__gaddr372, align 8
  call void @unlock_user(ptr noundef %196, i64 noundef %197, i64 noundef 4)
  br label %if.end381

if.else380:                                       ; preds = %if.end371
  store i64 -14, ptr %__ret374, align 8
  br label %if.end381

if.end381:                                        ; preds = %if.else380, %do.end379
  %198 = load i64, ptr %__ret374, align 8
  store i64 %198, ptr %tmp382, align 8
  %199 = load i64, ptr %tmp382, align 8
  %tobool383 = icmp ne i64 %199, 0
  br i1 %tobool383, label %if.then397, label %lor.lhs.false384

lor.lhs.false384:                                 ; preds = %if.end381
  %200 = load i64, ptr %optval_addr.addr, align 8
  store i64 %200, ptr %__gaddr385, align 8
  store i64 0, ptr %__ret387, align 8
  %201 = load i64, ptr %__gaddr385, align 8
  %call388 = call ptr @lock_user(i32 noundef 3, i64 noundef %201, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call388, ptr %__hptr386, align 8
  %tobool389 = icmp ne ptr %call388, null
  br i1 %tobool389, label %if.then390, label %if.else393

if.then390:                                       ; preds = %lor.lhs.false384
  br label %do.body391

do.body391:                                       ; preds = %if.then390
  %202 = load ptr, ptr %__hptr386, align 8
  %203 = load i32, ptr %val, align 4
  call void @stl_le_p(ptr noundef %202, i32 noundef %203)
  br label %do.end392

do.end392:                                        ; preds = %do.body391
  %204 = load ptr, ptr %__hptr386, align 8
  %205 = load i64, ptr %__gaddr385, align 8
  call void @unlock_user(ptr noundef %204, i64 noundef %205, i64 noundef 4)
  br label %if.end394

if.else393:                                       ; preds = %lor.lhs.false384
  store i64 -14, ptr %__ret387, align 8
  br label %if.end394

if.end394:                                        ; preds = %if.else393, %do.end392
  %206 = load i64, ptr %__ret387, align 8
  store i64 %206, ptr %tmp395, align 8
  %207 = load i64, ptr %tmp395, align 8
  %tobool396 = icmp ne i64 %207, 0
  br i1 %tobool396, label %if.then397, label %if.end398

if.then397:                                       ; preds = %if.end394, %if.end381
  store i64 -14, ptr %retval, align 8
  br label %return

if.end398:                                        ; preds = %if.end394
  br label %if.end399

if.end399:                                        ; preds = %if.end398, %if.end365
  br label %sw.epilog401

sw.default400:                                    ; preds = %sw.bb299
  store i64 -92, ptr %ret, align 8
  br label %sw.epilog401

sw.epilog401:                                     ; preds = %sw.default400, %if.end399
  br label %sw.epilog630

sw.bb402:                                         ; preds = %entry
  %208 = load i32, ptr %optname.addr, align 4
  switch i32 %208, label %sw.default505 [
    i32 23, label %sw.bb403
    i32 24, label %sw.bb403
    i32 26, label %sw.bb403
    i32 49, label %sw.bb403
    i32 16, label %sw.bb403
    i32 18, label %sw.bb403
    i32 19, label %sw.bb403
    i32 25, label %sw.bb403
    i32 51, label %sw.bb403
    i32 8, label %sw.bb403
    i32 7, label %sw.bb403
    i32 1, label %sw.bb403
    i32 2, label %sw.bb403
    i32 66, label %sw.bb403
    i32 56, label %sw.bb403
    i32 5, label %sw.bb403
    i32 53, label %sw.bb403
    i32 3, label %sw.bb403
    i32 58, label %sw.bb403
    i32 4, label %sw.bb403
    i32 67, label %sw.bb403
    i32 72, label %sw.bb403
    i32 60, label %sw.bb403
    i32 75, label %sw.bb403
    i32 78, label %sw.bb403
    i32 74, label %sw.bb403
  ]

sw.bb403:                                         ; preds = %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402, %sw.bb402
  %209 = load i64, ptr %optlen.addr, align 8
  store i64 %209, ptr %__gaddr404, align 8
  store i64 0, ptr %__ret406, align 8
  %210 = load i64, ptr %__gaddr404, align 8
  %call407 = call ptr @lock_user(i32 noundef 1, i64 noundef %210, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call407, ptr %__hptr405, align 8
  %tobool408 = icmp ne ptr %call407, null
  br i1 %tobool408, label %if.then409, label %if.else413

if.then409:                                       ; preds = %sw.bb403
  br label %do.body410

do.body410:                                       ; preds = %if.then409
  %211 = load ptr, ptr %__hptr405, align 8
  %call411 = call i32 @ldl_le_p(ptr noundef %211)
  store i32 %call411, ptr %len, align 4
  br label %do.end412

do.end412:                                        ; preds = %do.body410
  %212 = load ptr, ptr %__hptr405, align 8
  %213 = load i64, ptr %__gaddr404, align 8
  call void @unlock_user(ptr noundef %212, i64 noundef %213, i64 noundef 0)
  br label %if.end414

if.else413:                                       ; preds = %sw.bb403
  store i32 0, ptr %len, align 4
  store i64 -14, ptr %__ret406, align 8
  br label %if.end414

if.end414:                                        ; preds = %if.else413, %do.end412
  %214 = load i64, ptr %__ret406, align 8
  store i64 %214, ptr %tmp415, align 8
  %215 = load i64, ptr %tmp415, align 8
  %tobool416 = icmp ne i64 %215, 0
  br i1 %tobool416, label %if.then417, label %if.end418

if.then417:                                       ; preds = %if.end414
  store i64 -14, ptr %retval, align 8
  br label %return

if.end418:                                        ; preds = %if.end414
  %216 = load i32, ptr %len, align 4
  %cmp419 = icmp slt i32 %216, 0
  br i1 %cmp419, label %if.then421, label %if.end422

if.then421:                                       ; preds = %if.end418
  store i64 -22, ptr %retval, align 8
  br label %return

if.end422:                                        ; preds = %if.end418
  store i32 4, ptr %lv, align 4
  %217 = load i32, ptr %sockfd.addr, align 4
  %218 = load i32, ptr %level.addr, align 4
  %219 = load i32, ptr %optname.addr, align 4
  %call423 = call i32 @getsockopt(i32 noundef %217, i32 noundef %218, i32 noundef %219, ptr noundef %val, ptr noundef %lv) #14
  %conv424 = sext i32 %call423 to i64
  %call425 = call i64 @get_errno(i64 noundef %conv424)
  store i64 %call425, ptr %ret, align 8
  %220 = load i64, ptr %ret, align 8
  %cmp426 = icmp slt i64 %220, 0
  br i1 %cmp426, label %if.then428, label %if.end429

if.then428:                                       ; preds = %if.end422
  %221 = load i64, ptr %ret, align 8
  store i64 %221, ptr %retval, align 8
  br label %return

if.end429:                                        ; preds = %if.end422
  %222 = load i32, ptr %len, align 4
  %conv430 = sext i32 %222 to i64
  %cmp431 = icmp ult i64 %conv430, 4
  br i1 %cmp431, label %land.lhs.true433, label %if.else471

land.lhs.true433:                                 ; preds = %if.end429
  %223 = load i32, ptr %len, align 4
  %cmp434 = icmp sgt i32 %223, 0
  br i1 %cmp434, label %land.lhs.true436, label %if.else471

land.lhs.true436:                                 ; preds = %land.lhs.true433
  %224 = load i32, ptr %val, align 4
  %cmp437 = icmp sge i32 %224, 0
  br i1 %cmp437, label %land.lhs.true439, label %if.else471

land.lhs.true439:                                 ; preds = %land.lhs.true436
  %225 = load i32, ptr %val, align 4
  %cmp440 = icmp slt i32 %225, 255
  br i1 %cmp440, label %if.then442, label %if.else471

if.then442:                                       ; preds = %land.lhs.true439
  store i32 1, ptr %len, align 4
  %226 = load i64, ptr %optlen.addr, align 8
  store i64 %226, ptr %__gaddr443, align 8
  store i64 0, ptr %__ret445, align 8
  %227 = load i64, ptr %__gaddr443, align 8
  %call446 = call ptr @lock_user(i32 noundef 3, i64 noundef %227, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call446, ptr %__hptr444, align 8
  %tobool447 = icmp ne ptr %call446, null
  br i1 %tobool447, label %if.then448, label %if.else451

if.then448:                                       ; preds = %if.then442
  br label %do.body449

do.body449:                                       ; preds = %if.then448
  %228 = load ptr, ptr %__hptr444, align 8
  %229 = load i32, ptr %len, align 4
  call void @stl_le_p(ptr noundef %228, i32 noundef %229)
  br label %do.end450

do.end450:                                        ; preds = %do.body449
  %230 = load ptr, ptr %__hptr444, align 8
  %231 = load i64, ptr %__gaddr443, align 8
  call void @unlock_user(ptr noundef %230, i64 noundef %231, i64 noundef 4)
  br label %if.end452

if.else451:                                       ; preds = %if.then442
  store i64 -14, ptr %__ret445, align 8
  br label %if.end452

if.end452:                                        ; preds = %if.else451, %do.end450
  %232 = load i64, ptr %__ret445, align 8
  store i64 %232, ptr %tmp453, align 8
  %233 = load i64, ptr %tmp453, align 8
  %tobool454 = icmp ne i64 %233, 0
  br i1 %tobool454, label %if.then469, label %lor.lhs.false455

lor.lhs.false455:                                 ; preds = %if.end452
  %234 = load i64, ptr %optval_addr.addr, align 8
  store i64 %234, ptr %__gaddr456, align 8
  store i64 0, ptr %__ret458, align 8
  %235 = load i64, ptr %__gaddr456, align 8
  %call459 = call ptr @lock_user(i32 noundef 3, i64 noundef %235, i64 noundef 1, i1 noundef zeroext false)
  store ptr %call459, ptr %__hptr457, align 8
  %tobool460 = icmp ne ptr %call459, null
  br i1 %tobool460, label %if.then461, label %if.else465

if.then461:                                       ; preds = %lor.lhs.false455
  br label %do.body462

do.body462:                                       ; preds = %if.then461
  %236 = load ptr, ptr %__hptr457, align 8
  %237 = load i32, ptr %val, align 4
  %conv463 = trunc i32 %237 to i8
  call void @stb_p(ptr noundef %236, i8 noundef zeroext %conv463)
  br label %do.end464

do.end464:                                        ; preds = %do.body462
  %238 = load ptr, ptr %__hptr457, align 8
  %239 = load i64, ptr %__gaddr456, align 8
  call void @unlock_user(ptr noundef %238, i64 noundef %239, i64 noundef 1)
  br label %if.end466

if.else465:                                       ; preds = %lor.lhs.false455
  store i64 -14, ptr %__ret458, align 8
  br label %if.end466

if.end466:                                        ; preds = %if.else465, %do.end464
  %240 = load i64, ptr %__ret458, align 8
  store i64 %240, ptr %tmp467, align 8
  %241 = load i64, ptr %tmp467, align 8
  %tobool468 = icmp ne i64 %241, 0
  br i1 %tobool468, label %if.then469, label %if.end470

if.then469:                                       ; preds = %if.end466, %if.end452
  store i64 -14, ptr %retval, align 8
  br label %return

if.end470:                                        ; preds = %if.end466
  br label %if.end504

if.else471:                                       ; preds = %land.lhs.true439, %land.lhs.true436, %land.lhs.true433, %if.end429
  %242 = load i32, ptr %len, align 4
  %conv472 = sext i32 %242 to i64
  %cmp473 = icmp ugt i64 %conv472, 4
  br i1 %cmp473, label %if.then475, label %if.end476

if.then475:                                       ; preds = %if.else471
  store i32 4, ptr %len, align 4
  br label %if.end476

if.end476:                                        ; preds = %if.then475, %if.else471
  %243 = load i64, ptr %optlen.addr, align 8
  store i64 %243, ptr %__gaddr477, align 8
  store i64 0, ptr %__ret479, align 8
  %244 = load i64, ptr %__gaddr477, align 8
  %call480 = call ptr @lock_user(i32 noundef 3, i64 noundef %244, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call480, ptr %__hptr478, align 8
  %tobool481 = icmp ne ptr %call480, null
  br i1 %tobool481, label %if.then482, label %if.else485

if.then482:                                       ; preds = %if.end476
  br label %do.body483

do.body483:                                       ; preds = %if.then482
  %245 = load ptr, ptr %__hptr478, align 8
  %246 = load i32, ptr %len, align 4
  call void @stl_le_p(ptr noundef %245, i32 noundef %246)
  br label %do.end484

do.end484:                                        ; preds = %do.body483
  %247 = load ptr, ptr %__hptr478, align 8
  %248 = load i64, ptr %__gaddr477, align 8
  call void @unlock_user(ptr noundef %247, i64 noundef %248, i64 noundef 4)
  br label %if.end486

if.else485:                                       ; preds = %if.end476
  store i64 -14, ptr %__ret479, align 8
  br label %if.end486

if.end486:                                        ; preds = %if.else485, %do.end484
  %249 = load i64, ptr %__ret479, align 8
  store i64 %249, ptr %tmp487, align 8
  %250 = load i64, ptr %tmp487, align 8
  %tobool488 = icmp ne i64 %250, 0
  br i1 %tobool488, label %if.then502, label %lor.lhs.false489

lor.lhs.false489:                                 ; preds = %if.end486
  %251 = load i64, ptr %optval_addr.addr, align 8
  store i64 %251, ptr %__gaddr490, align 8
  store i64 0, ptr %__ret492, align 8
  %252 = load i64, ptr %__gaddr490, align 8
  %call493 = call ptr @lock_user(i32 noundef 3, i64 noundef %252, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call493, ptr %__hptr491, align 8
  %tobool494 = icmp ne ptr %call493, null
  br i1 %tobool494, label %if.then495, label %if.else498

if.then495:                                       ; preds = %lor.lhs.false489
  br label %do.body496

do.body496:                                       ; preds = %if.then495
  %253 = load ptr, ptr %__hptr491, align 8
  %254 = load i32, ptr %val, align 4
  call void @stl_le_p(ptr noundef %253, i32 noundef %254)
  br label %do.end497

do.end497:                                        ; preds = %do.body496
  %255 = load ptr, ptr %__hptr491, align 8
  %256 = load i64, ptr %__gaddr490, align 8
  call void @unlock_user(ptr noundef %255, i64 noundef %256, i64 noundef 4)
  br label %if.end499

if.else498:                                       ; preds = %lor.lhs.false489
  store i64 -14, ptr %__ret492, align 8
  br label %if.end499

if.end499:                                        ; preds = %if.else498, %do.end497
  %257 = load i64, ptr %__ret492, align 8
  store i64 %257, ptr %tmp500, align 8
  %258 = load i64, ptr %tmp500, align 8
  %tobool501 = icmp ne i64 %258, 0
  br i1 %tobool501, label %if.then502, label %if.end503

if.then502:                                       ; preds = %if.end499, %if.end486
  store i64 -14, ptr %retval, align 8
  br label %return

if.end503:                                        ; preds = %if.end499
  br label %if.end504

if.end504:                                        ; preds = %if.end503, %if.end470
  br label %sw.epilog506

sw.default505:                                    ; preds = %sw.bb402
  store i64 -92, ptr %ret, align 8
  br label %sw.epilog506

sw.epilog506:                                     ; preds = %sw.default505, %if.end504
  br label %sw.epilog630

sw.bb507:                                         ; preds = %entry
  %259 = load i32, ptr %optname.addr, align 4
  switch i32 %259, label %sw.default619 [
    i32 3, label %sw.bb508
    i32 4, label %sw.bb508
    i32 5, label %sw.bb508
    i32 8, label %sw.bb508
    i32 10, label %sw.bb508
    i32 11, label %sw.bb508
    i32 12, label %sw.bb508
    i32 9, label %sw.bb563
  ]

sw.bb508:                                         ; preds = %sw.bb507, %sw.bb507, %sw.bb507, %sw.bb507, %sw.bb507, %sw.bb507, %sw.bb507
  %260 = load i64, ptr %optlen.addr, align 8
  store i64 %260, ptr %__gaddr509, align 8
  store i64 0, ptr %__ret511, align 8
  %261 = load i64, ptr %__gaddr509, align 8
  %call512 = call ptr @lock_user(i32 noundef 1, i64 noundef %261, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call512, ptr %__hptr510, align 8
  %tobool513 = icmp ne ptr %call512, null
  br i1 %tobool513, label %if.then514, label %if.else518

if.then514:                                       ; preds = %sw.bb508
  br label %do.body515

do.body515:                                       ; preds = %if.then514
  %262 = load ptr, ptr %__hptr510, align 8
  %call516 = call i32 @ldl_le_p(ptr noundef %262)
  store i32 %call516, ptr %len, align 4
  br label %do.end517

do.end517:                                        ; preds = %do.body515
  %263 = load ptr, ptr %__hptr510, align 8
  %264 = load i64, ptr %__gaddr509, align 8
  call void @unlock_user(ptr noundef %263, i64 noundef %264, i64 noundef 0)
  br label %if.end519

if.else518:                                       ; preds = %sw.bb508
  store i32 0, ptr %len, align 4
  store i64 -14, ptr %__ret511, align 8
  br label %if.end519

if.end519:                                        ; preds = %if.else518, %do.end517
  %265 = load i64, ptr %__ret511, align 8
  store i64 %265, ptr %tmp520, align 8
  %266 = load i64, ptr %tmp520, align 8
  %tobool521 = icmp ne i64 %266, 0
  br i1 %tobool521, label %if.then522, label %if.end523

if.then522:                                       ; preds = %if.end519
  store i64 -14, ptr %retval, align 8
  br label %return

if.end523:                                        ; preds = %if.end519
  %267 = load i32, ptr %len, align 4
  %conv524 = sext i32 %267 to i64
  %cmp525 = icmp ne i64 %conv524, 4
  br i1 %cmp525, label %if.then527, label %if.end528

if.then527:                                       ; preds = %if.end523
  store i64 -22, ptr %retval, align 8
  br label %return

if.end528:                                        ; preds = %if.end523
  %268 = load i32, ptr %len, align 4
  store i32 %268, ptr %lv, align 4
  %269 = load i32, ptr %sockfd.addr, align 4
  %270 = load i32, ptr %level.addr, align 4
  %271 = load i32, ptr %optname.addr, align 4
  %call529 = call i32 @getsockopt(i32 noundef %269, i32 noundef %270, i32 noundef %271, ptr noundef %val, ptr noundef %lv) #14
  %conv530 = sext i32 %call529 to i64
  %call531 = call i64 @get_errno(i64 noundef %conv530)
  store i64 %call531, ptr %ret, align 8
  %272 = load i64, ptr %ret, align 8
  %cmp532 = icmp slt i64 %272, 0
  br i1 %cmp532, label %if.then534, label %if.end535

if.then534:                                       ; preds = %if.end528
  %273 = load i64, ptr %ret, align 8
  store i64 %273, ptr %retval, align 8
  br label %return

if.end535:                                        ; preds = %if.end528
  %274 = load i64, ptr %optlen.addr, align 8
  store i64 %274, ptr %__gaddr536, align 8
  store i64 0, ptr %__ret538, align 8
  %275 = load i64, ptr %__gaddr536, align 8
  %call539 = call ptr @lock_user(i32 noundef 3, i64 noundef %275, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call539, ptr %__hptr537, align 8
  %tobool540 = icmp ne ptr %call539, null
  br i1 %tobool540, label %if.then541, label %if.else544

if.then541:                                       ; preds = %if.end535
  br label %do.body542

do.body542:                                       ; preds = %if.then541
  %276 = load ptr, ptr %__hptr537, align 8
  %277 = load i32, ptr %lv, align 4
  call void @stl_le_p(ptr noundef %276, i32 noundef %277)
  br label %do.end543

do.end543:                                        ; preds = %do.body542
  %278 = load ptr, ptr %__hptr537, align 8
  %279 = load i64, ptr %__gaddr536, align 8
  call void @unlock_user(ptr noundef %278, i64 noundef %279, i64 noundef 4)
  br label %if.end545

if.else544:                                       ; preds = %if.end535
  store i64 -14, ptr %__ret538, align 8
  br label %if.end545

if.end545:                                        ; preds = %if.else544, %do.end543
  %280 = load i64, ptr %__ret538, align 8
  store i64 %280, ptr %tmp546, align 8
  %281 = load i64, ptr %tmp546, align 8
  %tobool547 = icmp ne i64 %281, 0
  br i1 %tobool547, label %if.then561, label %lor.lhs.false548

lor.lhs.false548:                                 ; preds = %if.end545
  %282 = load i64, ptr %optval_addr.addr, align 8
  store i64 %282, ptr %__gaddr549, align 8
  store i64 0, ptr %__ret551, align 8
  %283 = load i64, ptr %__gaddr549, align 8
  %call552 = call ptr @lock_user(i32 noundef 3, i64 noundef %283, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call552, ptr %__hptr550, align 8
  %tobool553 = icmp ne ptr %call552, null
  br i1 %tobool553, label %if.then554, label %if.else557

if.then554:                                       ; preds = %lor.lhs.false548
  br label %do.body555

do.body555:                                       ; preds = %if.then554
  %284 = load ptr, ptr %__hptr550, align 8
  %285 = load i32, ptr %val, align 4
  call void @stl_le_p(ptr noundef %284, i32 noundef %285)
  br label %do.end556

do.end556:                                        ; preds = %do.body555
  %286 = load ptr, ptr %__hptr550, align 8
  %287 = load i64, ptr %__gaddr549, align 8
  call void @unlock_user(ptr noundef %286, i64 noundef %287, i64 noundef 4)
  br label %if.end558

if.else557:                                       ; preds = %lor.lhs.false548
  store i64 -14, ptr %__ret551, align 8
  br label %if.end558

if.end558:                                        ; preds = %if.else557, %do.end556
  %288 = load i64, ptr %__ret551, align 8
  store i64 %288, ptr %tmp559, align 8
  %289 = load i64, ptr %tmp559, align 8
  %tobool560 = icmp ne i64 %289, 0
  br i1 %tobool560, label %if.then561, label %if.end562

if.then561:                                       ; preds = %if.end558, %if.end545
  store i64 -14, ptr %retval, align 8
  br label %return

if.end562:                                        ; preds = %if.end558
  br label %sw.epilog620

sw.bb563:                                         ; preds = %sw.bb507
  %290 = load i64, ptr %optlen.addr, align 8
  store i64 %290, ptr %__gaddr564, align 8
  store i64 0, ptr %__ret566, align 8
  %291 = load i64, ptr %__gaddr564, align 8
  %call567 = call ptr @lock_user(i32 noundef 1, i64 noundef %291, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call567, ptr %__hptr565, align 8
  %tobool568 = icmp ne ptr %call567, null
  br i1 %tobool568, label %if.then569, label %if.else573

if.then569:                                       ; preds = %sw.bb563
  br label %do.body570

do.body570:                                       ; preds = %if.then569
  %292 = load ptr, ptr %__hptr565, align 8
  %call571 = call i32 @ldl_le_p(ptr noundef %292)
  store i32 %call571, ptr %len, align 4
  br label %do.end572

do.end572:                                        ; preds = %do.body570
  %293 = load ptr, ptr %__hptr565, align 8
  %294 = load i64, ptr %__gaddr564, align 8
  call void @unlock_user(ptr noundef %293, i64 noundef %294, i64 noundef 0)
  br label %if.end574

if.else573:                                       ; preds = %sw.bb563
  store i32 0, ptr %len, align 4
  store i64 -14, ptr %__ret566, align 8
  br label %if.end574

if.end574:                                        ; preds = %if.else573, %do.end572
  %295 = load i64, ptr %__ret566, align 8
  store i64 %295, ptr %tmp575, align 8
  %296 = load i64, ptr %tmp575, align 8
  %tobool576 = icmp ne i64 %296, 0
  br i1 %tobool576, label %if.then577, label %if.end578

if.then577:                                       ; preds = %if.end574
  store i64 -14, ptr %retval, align 8
  br label %return

if.end578:                                        ; preds = %if.end574
  %297 = load i32, ptr %len, align 4
  %cmp579 = icmp slt i32 %297, 0
  br i1 %cmp579, label %if.then581, label %if.end582

if.then581:                                       ; preds = %if.end578
  store i64 -22, ptr %retval, align 8
  br label %return

if.end582:                                        ; preds = %if.end578
  %298 = load i64, ptr %optval_addr.addr, align 8
  %299 = load i32, ptr %len, align 4
  %conv583 = sext i32 %299 to i64
  %call584 = call ptr @lock_user(i32 noundef 3, i64 noundef %298, i64 noundef %conv583, i1 noundef zeroext true)
  store ptr %call584, ptr %results, align 8
  %300 = load ptr, ptr %results, align 8
  %tobool585 = icmp ne ptr %300, null
  br i1 %tobool585, label %if.end590, label %land.lhs.true586

land.lhs.true586:                                 ; preds = %if.end582
  %301 = load i32, ptr %len, align 4
  %cmp587 = icmp sgt i32 %301, 0
  br i1 %cmp587, label %if.then589, label %if.end590

if.then589:                                       ; preds = %land.lhs.true586
  store i64 -14, ptr %retval, align 8
  br label %return

if.end590:                                        ; preds = %land.lhs.true586, %if.end582
  %302 = load i32, ptr %len, align 4
  store i32 %302, ptr %lv, align 4
  %303 = load i32, ptr %sockfd.addr, align 4
  %304 = load i32, ptr %level.addr, align 4
  %305 = load i32, ptr %optname.addr, align 4
  %306 = load ptr, ptr %results, align 8
  %call591 = call i32 @getsockopt(i32 noundef %303, i32 noundef %304, i32 noundef %305, ptr noundef %306, ptr noundef %lv) #14
  %conv592 = sext i32 %call591 to i64
  %call593 = call i64 @get_errno(i64 noundef %conv592)
  store i64 %call593, ptr %ret, align 8
  %307 = load i64, ptr %ret, align 8
  %cmp594 = icmp slt i64 %307, 0
  br i1 %cmp594, label %if.then596, label %if.end597

if.then596:                                       ; preds = %if.end590
  %308 = load ptr, ptr %results, align 8
  %309 = load i64, ptr %optval_addr.addr, align 8
  call void @unlock_user(ptr noundef %308, i64 noundef %309, i64 noundef 0)
  %310 = load i64, ptr %ret, align 8
  store i64 %310, ptr %retval, align 8
  br label %return

if.end597:                                        ; preds = %if.end590
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end597
  %311 = load i32, ptr %i, align 4
  %conv598 = sext i32 %311 to i64
  %312 = load i32, ptr %len, align 4
  %conv599 = sext i32 %312 to i64
  %div = udiv i64 %conv599, 4
  %cmp600 = icmp ult i64 %conv598, %div
  br i1 %cmp600, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %313 = load ptr, ptr %results, align 8
  %314 = load i32, ptr %i, align 4
  %idxprom = sext i32 %314 to i64
  %arrayidx = getelementptr i32, ptr %313, i64 %idxprom
  %315 = load i32, ptr %arrayidx, align 4
  %call602 = call i32 @tswap32(i32 noundef %315)
  %316 = load ptr, ptr %results, align 8
  %317 = load i32, ptr %i, align 4
  %idxprom603 = sext i32 %317 to i64
  %arrayidx604 = getelementptr i32, ptr %316, i64 %idxprom603
  store i32 %call602, ptr %arrayidx604, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %318 = load i32, ptr %i, align 4
  %inc = add i32 %318, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !32

for.end:                                          ; preds = %for.cond
  %319 = load i64, ptr %optlen.addr, align 8
  store i64 %319, ptr %__gaddr605, align 8
  store i64 0, ptr %__ret607, align 8
  %320 = load i64, ptr %__gaddr605, align 8
  %call608 = call ptr @lock_user(i32 noundef 3, i64 noundef %320, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call608, ptr %__hptr606, align 8
  %tobool609 = icmp ne ptr %call608, null
  br i1 %tobool609, label %if.then610, label %if.else613

if.then610:                                       ; preds = %for.end
  br label %do.body611

do.body611:                                       ; preds = %if.then610
  %321 = load ptr, ptr %__hptr606, align 8
  %322 = load i32, ptr %lv, align 4
  call void @stl_le_p(ptr noundef %321, i32 noundef %322)
  br label %do.end612

do.end612:                                        ; preds = %do.body611
  %323 = load ptr, ptr %__hptr606, align 8
  %324 = load i64, ptr %__gaddr605, align 8
  call void @unlock_user(ptr noundef %323, i64 noundef %324, i64 noundef 4)
  br label %if.end614

if.else613:                                       ; preds = %for.end
  store i64 -14, ptr %__ret607, align 8
  br label %if.end614

if.end614:                                        ; preds = %if.else613, %do.end612
  %325 = load i64, ptr %__ret607, align 8
  store i64 %325, ptr %tmp615, align 8
  %326 = load i64, ptr %tmp615, align 8
  %tobool616 = icmp ne i64 %326, 0
  br i1 %tobool616, label %if.then617, label %if.end618

if.then617:                                       ; preds = %if.end614
  store i64 -14, ptr %retval, align 8
  br label %return

if.end618:                                        ; preds = %if.end614
  %327 = load ptr, ptr %results, align 8
  %328 = load i64, ptr %optval_addr.addr, align 8
  call void @unlock_user(ptr noundef %327, i64 noundef %328, i64 noundef 0)
  br label %sw.epilog620

sw.default619:                                    ; preds = %sw.bb507
  br label %unimplemented

sw.epilog620:                                     ; preds = %if.end618, %if.end562
  br label %sw.epilog630

sw.default621:                                    ; preds = %entry
  br label %unimplemented

unimplemented:                                    ; preds = %sw.default621, %sw.default619, %sw.bb1
  br label %do.body622

do.body622:                                       ; preds = %unimplemented
  %call623 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 1024)
  %lnot = xor i1 %call623, true
  %lnot624 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot624 to i32
  %conv625 = sext i32 %lnot.ext to i64
  %tobool626 = icmp ne i64 %conv625, 0
  br i1 %tobool626, label %if.then627, label %if.end628

if.then627:                                       ; preds = %do.body622
  %329 = load i32, ptr %level.addr, align 4
  %330 = load i32, ptr %optname.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.634, i32 noundef %329, i32 noundef %330)
  br label %if.end628

if.end628:                                        ; preds = %if.then627, %do.body622
  br label %do.end629

do.end629:                                        ; preds = %if.end628
  store i64 -95, ptr %ret, align 8
  br label %sw.epilog630

sw.epilog630:                                     ; preds = %do.end629, %sw.epilog620, %sw.epilog506, %sw.epilog401, %if.end298, %sw.epilog
  %331 = load i64, ptr %ret, align 8
  store i64 %331, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog630, %if.then617, %if.then596, %if.then589, %if.then581, %if.then577, %if.then561, %if.then534, %if.then527, %if.then522, %if.then502, %if.then469, %if.then428, %if.then421, %if.then417, %if.then397, %if.then364, %if.then325, %if.then318, %if.then314, %if.then297, %if.then282, %if.then266, %if.then240, %if.then233, %if.then229, %if.then193, %if.then173, %if.then165, %if.then158, %if.then154, %if.then120, %if.then115, %if.then111, %if.then95, %if.then72, %if.then64, %if.then57, %if.then53, %if.then36, %if.then22, %if.then13, %if.then7, %if.then5
  %332 = load i64, ptr %retval, align 8
  ret i64 %332
}

; Function Attrs: nounwind
declare i32 @listen(i32 noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_recvfrom(i32 noundef %fd, i64 noundef %msg, i64 noundef %len, i32 noundef %flags, i64 noundef %target_addr, i64 noundef %target_addrlen) #0 {
entry:
  %retval = alloca i64, align 8
  %fd.addr = alloca i32, align 4
  %msg.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %target_addr.addr = alloca i64, align 8
  %target_addrlen.addr = alloca i64, align 8
  %addrlen = alloca i32, align 4
  %ret_addrlen = alloca i32, align 4
  %addr = alloca ptr, align 8
  %host_msg = alloca ptr, align 8
  %ret = alloca i64, align 8
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %trans = alloca i64, align 8
  %_a16 = alloca i64, align 8
  %_b17 = alloca i64, align 8
  %tmp30 = alloca i64, align 8
  %_a18 = alloca i32, align 4
  %_b19 = alloca i32, align 4
  %tmp41 = alloca i32, align 4
  %__gaddr49 = alloca i64, align 8
  %__hptr50 = alloca ptr, align 8
  %__ret51 = alloca i64, align 8
  %tmp59 = alloca i64, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %msg, ptr %msg.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i64 %target_addrlen, ptr %target_addrlen.addr, align 8
  %0 = load i64, ptr %msg.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %host_msg, align 8
  br label %if.end3

if.else:                                          ; preds = %entry
  %1 = load i64, ptr %msg.addr, align 8
  %2 = load i64, ptr %len.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %1, i64 noundef %2, i1 noundef zeroext false)
  store ptr %call, ptr %host_msg, align 8
  %3 = load ptr, ptr %host_msg, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.else
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end, %if.then
  %4 = load i64, ptr %target_addr.addr, align 8
  %tobool4 = icmp ne i64 %4, 0
  br i1 %tobool4, label %if.then5, label %if.else19

if.then5:                                         ; preds = %if.end3
  %5 = load i64, ptr %target_addrlen.addr, align 8
  store i64 %5, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %6 = load i64, ptr %__gaddr, align 8
  %call6 = call ptr @lock_user(i32 noundef 1, i64 noundef %6, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call6, ptr %__hptr, align 8
  %tobool7 = icmp ne ptr %call6, null
  br i1 %tobool7, label %if.then8, label %if.else10

if.then8:                                         ; preds = %if.then5
  br label %do.body

do.body:                                          ; preds = %if.then8
  %7 = load ptr, ptr %__hptr, align 8
  %call9 = call i32 @ldl_le_p(ptr noundef %7)
  store i32 %call9, ptr %addrlen, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  %8 = load ptr, ptr %__hptr, align 8
  %9 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %8, i64 noundef %9, i64 noundef 0)
  br label %if.end11

if.else10:                                        ; preds = %if.then5
  store i32 0, ptr %addrlen, align 4
  store i64 -14, ptr %__ret, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.else10, %do.end
  %10 = load i64, ptr %__ret, align 8
  store i64 %10, ptr %tmp, align 8
  %11 = load i64, ptr %tmp, align 8
  %tobool12 = icmp ne i64 %11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  store i64 -14, ptr %ret, align 8
  br label %fail

if.end14:                                         ; preds = %if.end11
  %12 = load i32, ptr %addrlen, align 4
  %cmp = icmp slt i32 %12, 0
  br i1 %cmp, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end14
  store i64 -22, ptr %ret, align 8
  br label %fail

if.end16:                                         ; preds = %if.end14
  %13 = load i32, ptr %addrlen, align 4
  %conv = zext i32 %13 to i64
  %14 = alloca i8, i64 %conv, align 16
  store ptr %14, ptr %addr, align 8
  %15 = load i32, ptr %addrlen, align 4
  store i32 %15, ptr %ret_addrlen, align 4
  %16 = load i32, ptr %fd.addr, align 4
  %17 = load ptr, ptr %host_msg, align 8
  %18 = load i64, ptr %len.addr, align 8
  %19 = load i32, ptr %flags.addr, align 4
  %20 = load ptr, ptr %addr, align 8
  %call17 = call i64 @safe_recvfrom(i32 noundef %16, ptr noundef %17, i64 noundef %18, i32 noundef %19, ptr noundef %20, ptr noundef %ret_addrlen)
  %call18 = call i64 @get_errno(i64 noundef %call17)
  store i64 %call18, ptr %ret, align 8
  br label %if.end22

if.else19:                                        ; preds = %if.end3
  store ptr null, ptr %addr, align 8
  store i32 0, ptr %addrlen, align 4
  %21 = load i32, ptr %fd.addr, align 4
  %22 = load ptr, ptr %host_msg, align 8
  %23 = load i64, ptr %len.addr, align 8
  %24 = load i32, ptr %flags.addr, align 4
  %call20 = call i64 @safe_recvfrom(i32 noundef %21, ptr noundef %22, i64 noundef %23, i32 noundef %24, ptr noundef null, ptr noundef null)
  %call21 = call i64 @get_errno(i64 noundef %call20)
  store i64 %call21, ptr %ret, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else19, %if.end16
  %25 = load i64, ptr %ret, align 8
  %call23 = call i32 @is_error(i64 noundef %25)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.else64, label %if.then25

if.then25:                                        ; preds = %if.end22
  %26 = load i32, ptr %fd.addr, align 4
  %call26 = call ptr @fd_trans_host_to_target_data(i32 noundef %26)
  %tobool27 = icmp ne ptr %call26, null
  br i1 %tobool27, label %if.then28, label %if.end38

if.then28:                                        ; preds = %if.then25
  %27 = load i32, ptr %fd.addr, align 4
  %call29 = call ptr @fd_trans_host_to_target_data(i32 noundef %27)
  %28 = load ptr, ptr %host_msg, align 8
  %29 = load i64, ptr %ret, align 8
  store i64 %29, ptr %_a16, align 8
  %30 = load i64, ptr %len.addr, align 8
  store i64 %30, ptr %_b17, align 8
  %31 = load i64, ptr %_a16, align 8
  %32 = load i64, ptr %_b17, align 8
  %cmp31 = icmp ult i64 %31, %32
  br i1 %cmp31, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then28
  %33 = load i64, ptr %_a16, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then28
  %34 = load i64, ptr %_b17, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %33, %cond.true ], [ %34, %cond.false ]
  store i64 %cond, ptr %tmp30, align 8
  %35 = load i64, ptr %tmp30, align 8
  %call33 = call i64 %call29(ptr noundef %28, i64 noundef %35)
  store i64 %call33, ptr %trans, align 8
  %36 = load i64, ptr %trans, align 8
  %call34 = call i32 @is_error(i64 noundef %36)
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %cond.end
  %37 = load i64, ptr %trans, align 8
  store i64 %37, ptr %ret, align 8
  br label %fail

if.end37:                                         ; preds = %cond.end
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then25
  %38 = load i64, ptr %target_addr.addr, align 8
  %tobool39 = icmp ne i64 %38, 0
  br i1 %tobool39, label %if.then40, label %if.end63

if.then40:                                        ; preds = %if.end38
  %39 = load i64, ptr %target_addr.addr, align 8
  %40 = load ptr, ptr %addr, align 8
  %41 = load i32, ptr %addrlen, align 4
  store i32 %41, ptr %_a18, align 4
  %42 = load i32, ptr %ret_addrlen, align 4
  store i32 %42, ptr %_b19, align 4
  %43 = load i32, ptr %_a18, align 4
  %44 = load i32, ptr %_b19, align 4
  %cmp42 = icmp ult i32 %43, %44
  br i1 %cmp42, label %cond.true44, label %cond.false45

cond.true44:                                      ; preds = %if.then40
  %45 = load i32, ptr %_a18, align 4
  br label %cond.end46

cond.false45:                                     ; preds = %if.then40
  %46 = load i32, ptr %_b19, align 4
  br label %cond.end46

cond.end46:                                       ; preds = %cond.false45, %cond.true44
  %cond47 = phi i32 [ %45, %cond.true44 ], [ %46, %cond.false45 ]
  store i32 %cond47, ptr %tmp41, align 4
  %47 = load i32, ptr %tmp41, align 4
  %call48 = call i64 @host_to_target_sockaddr(i64 noundef %39, ptr noundef %40, i32 noundef %47)
  %48 = load i64, ptr %target_addrlen.addr, align 8
  store i64 %48, ptr %__gaddr49, align 8
  store i64 0, ptr %__ret51, align 8
  %49 = load i64, ptr %__gaddr49, align 8
  %call52 = call ptr @lock_user(i32 noundef 3, i64 noundef %49, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call52, ptr %__hptr50, align 8
  %tobool53 = icmp ne ptr %call52, null
  br i1 %tobool53, label %if.then54, label %if.else57

if.then54:                                        ; preds = %cond.end46
  br label %do.body55

do.body55:                                        ; preds = %if.then54
  %50 = load ptr, ptr %__hptr50, align 8
  %51 = load i32, ptr %ret_addrlen, align 4
  call void @stl_le_p(ptr noundef %50, i32 noundef %51)
  br label %do.end56

do.end56:                                         ; preds = %do.body55
  %52 = load ptr, ptr %__hptr50, align 8
  %53 = load i64, ptr %__gaddr49, align 8
  call void @unlock_user(ptr noundef %52, i64 noundef %53, i64 noundef 4)
  br label %if.end58

if.else57:                                        ; preds = %cond.end46
  store i64 -14, ptr %__ret51, align 8
  br label %if.end58

if.end58:                                         ; preds = %if.else57, %do.end56
  %54 = load i64, ptr %__ret51, align 8
  store i64 %54, ptr %tmp59, align 8
  %55 = load i64, ptr %tmp59, align 8
  %tobool60 = icmp ne i64 %55, 0
  br i1 %tobool60, label %if.then61, label %if.end62

if.then61:                                        ; preds = %if.end58
  store i64 -14, ptr %ret, align 8
  br label %fail

if.end62:                                         ; preds = %if.end58
  br label %if.end63

if.end63:                                         ; preds = %if.end62, %if.end38
  %56 = load ptr, ptr %host_msg, align 8
  %57 = load i64, ptr %msg.addr, align 8
  %58 = load i64, ptr %len.addr, align 8
  call void @unlock_user(ptr noundef %56, i64 noundef %57, i64 noundef %58)
  br label %if.end65

if.else64:                                        ; preds = %if.end22
  br label %fail

fail:                                             ; preds = %if.else64, %if.then61, %if.then36, %if.then15, %if.then13
  %59 = load ptr, ptr %host_msg, align 8
  %60 = load i64, ptr %msg.addr, align 8
  call void @unlock_user(ptr noundef %59, i64 noundef %60, i64 noundef 0)
  br label %if.end65

if.end65:                                         ; preds = %fail, %if.end63
  %61 = load i64, ptr %ret, align 8
  store i64 %61, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end65, %if.then2
  %62 = load i64, ptr %retval, align 8
  ret i64 %62
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_sendrecvmsg(i32 noundef %fd, i64 noundef %target_msg, i32 noundef %flags, i32 noundef %send) #0 {
entry:
  %retval = alloca i64, align 8
  %fd.addr = alloca i32, align 4
  %target_msg.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %send.addr = alloca i32, align 4
  %ret = alloca i64, align 8
  %msgp = alloca ptr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %target_msg, ptr %target_msg.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %send, ptr %send.addr, align 4
  %0 = load i32, ptr %send.addr, align 4
  %tobool = icmp ne i32 %0, 0
  %cond = select i1 %tobool, i32 1, i32 3
  %1 = load i64, ptr %target_msg.addr, align 8
  %2 = load i32, ptr %send.addr, align 4
  %tobool1 = icmp ne i32 %2, 0
  %cond2 = select i1 %tobool1, i32 1, i32 0
  %tobool3 = icmp ne i32 %cond2, 0
  %call = call ptr @lock_user(i32 noundef %cond, i64 noundef %1, i64 noundef 56, i1 noundef zeroext %tobool3)
  store ptr %call, ptr %msgp, align 8
  %tobool4 = icmp ne ptr %call, null
  br i1 %tobool4, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %msgp, align 8
  %5 = load i32, ptr %flags.addr, align 4
  %6 = load i32, ptr %send.addr, align 4
  %call5 = call i64 @do_sendrecvmsg_locked(i32 noundef %3, ptr noundef %4, i32 noundef %5, i32 noundef %6)
  store i64 %call5, ptr %ret, align 8
  %7 = load ptr, ptr %msgp, align 8
  %8 = load i64, ptr %target_msg.addr, align 8
  %9 = load i32, ptr %send.addr, align 4
  %tobool6 = icmp ne i32 %9, 0
  %cond7 = select i1 %tobool6, i32 0, i32 1
  %tobool8 = icmp ne i32 %cond7, 0
  %cond9 = select i1 %tobool8, i64 56, i64 0
  call void @unlock_user(ptr noundef %7, i64 noundef %8, i64 noundef %cond9)
  %10 = load i64, ptr %ret, align 8
  store i64 %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i64, ptr %retval, align 8
  ret i64 %11
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_sendrecvmmsg(i32 noundef %fd, i64 noundef %target_msgvec, i32 noundef %vlen, i32 noundef %flags, i32 noundef %send) #0 {
entry:
  %retval = alloca i64, align 8
  %fd.addr = alloca i32, align 4
  %target_msgvec.addr = alloca i64, align 8
  %vlen.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %send.addr = alloca i32, align 4
  %mmsgp = alloca ptr, align 8
  %ret = alloca i64, align 8
  %i = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %target_msgvec, ptr %target_msgvec.addr, align 8
  store i32 %vlen, ptr %vlen.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %send, ptr %send.addr, align 4
  store i64 0, ptr %ret, align 8
  %0 = load i32, ptr %vlen.addr, align 4
  %cmp = icmp ugt i32 %0, 1024
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1024, ptr %vlen.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i64, ptr %target_msgvec.addr, align 8
  %2 = load i32, ptr %vlen.addr, align 4
  %conv = zext i32 %2 to i64
  %mul = mul i64 64, %conv
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %1, i64 noundef %mul, i1 noundef zeroext true)
  store ptr %call, ptr %mmsgp, align 8
  %3 = load ptr, ptr %mmsgp, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end2
  %4 = load i32, ptr %i, align 4
  %5 = load i32, ptr %vlen.addr, align 4
  %cmp3 = icmp ult i32 %4, %5
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i32, ptr %fd.addr, align 4
  %7 = load ptr, ptr %mmsgp, align 8
  %8 = load i32, ptr %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr %struct.target_mmsghdr, ptr %7, i64 %idxprom
  %msg_hdr = getelementptr inbounds %struct.target_mmsghdr, ptr %arrayidx, i32 0, i32 0
  %9 = load i32, ptr %flags.addr, align 4
  %10 = load i32, ptr %send.addr, align 4
  %call5 = call i64 @do_sendrecvmsg_locked(i32 noundef %6, ptr noundef %msg_hdr, i32 noundef %9, i32 noundef %10)
  store i64 %call5, ptr %ret, align 8
  %11 = load i64, ptr %ret, align 8
  %call6 = call i32 @is_error(i64 noundef %11)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.body
  br label %for.end

if.end9:                                          ; preds = %for.body
  %12 = load i64, ptr %ret, align 8
  %conv10 = trunc i64 %12 to i32
  %call11 = call i32 @tswap32(i32 noundef %conv10)
  %13 = load ptr, ptr %mmsgp, align 8
  %14 = load i32, ptr %i, align 4
  %idxprom12 = sext i32 %14 to i64
  %arrayidx13 = getelementptr %struct.target_mmsghdr, ptr %13, i64 %idxprom12
  %msg_len = getelementptr inbounds %struct.target_mmsghdr, ptr %arrayidx13, i32 0, i32 1
  store i32 %call11, ptr %msg_len, align 8
  %15 = load i32, ptr %flags.addr, align 4
  %and = and i32 %15, 65536
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end9
  %16 = load i32, ptr %flags.addr, align 4
  %or = or i32 %16, 64
  store i32 %or, ptr %flags.addr, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.end9
  br label %for.inc

for.inc:                                          ; preds = %if.end16
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !33

for.end:                                          ; preds = %if.then8, %for.cond
  %18 = load ptr, ptr %mmsgp, align 8
  %19 = load i64, ptr %target_msgvec.addr, align 8
  %20 = load i32, ptr %i, align 4
  %conv17 = sext i32 %20 to i64
  %mul18 = mul i64 64, %conv17
  call void @unlock_user(ptr noundef %18, i64 noundef %19, i64 noundef %mul18)
  %21 = load i32, ptr %i, align 4
  %tobool19 = icmp ne i32 %21, 0
  br i1 %tobool19, label %if.then20, label %if.end22

if.then20:                                        ; preds = %for.end
  %22 = load i32, ptr %i, align 4
  %conv21 = sext i32 %22 to i64
  store i64 %conv21, ptr %retval, align 8
  br label %return

if.end22:                                         ; preds = %for.end
  %23 = load i64, ptr %ret, align 8
  store i64 %23, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end22, %if.then20, %if.then1
  %24 = load i64, ptr %retval, align 8
  ret i64 %24
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_sendto(i32 noundef %fd, i64 noundef %msg, i64 noundef %len, i32 noundef %flags, i64 noundef %target_addr, i32 noundef %addrlen) #0 {
entry:
  %retval = alloca i64, align 8
  %fd.addr = alloca i32, align 4
  %msg.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %target_addr.addr = alloca i64, align 8
  %addrlen.addr = alloca i32, align 4
  %addr = alloca ptr, align 8
  %host_msg = alloca ptr, align 8
  %copy_msg = alloca ptr, align 8
  %ret = alloca i64, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %msg, ptr %msg.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i32 %addrlen, ptr %addrlen.addr, align 4
  store ptr null, ptr %copy_msg, align 8
  %0 = load i32, ptr %addrlen.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -22, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %msg.addr, align 8
  %2 = load i64, ptr %len.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %1, i64 noundef %2, i1 noundef zeroext true)
  store ptr %call, ptr %host_msg, align 8
  %3 = load ptr, ptr %host_msg, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  %4 = load i32, ptr %fd.addr, align 4
  %call3 = call ptr @fd_trans_target_to_host_data(i32 noundef %4)
  %tobool4 = icmp ne ptr %call3, null
  br i1 %tobool4, label %if.then5, label %if.end12

if.then5:                                         ; preds = %if.end2
  %5 = load ptr, ptr %host_msg, align 8
  store ptr %5, ptr %copy_msg, align 8
  %6 = load i64, ptr %len.addr, align 8
  %call6 = call noalias ptr @g_malloc(i64 noundef %6) #16
  store ptr %call6, ptr %host_msg, align 8
  %7 = load ptr, ptr %host_msg, align 8
  %8 = load ptr, ptr %copy_msg, align 8
  %9 = load i64, ptr %len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %7, ptr align 1 %8, i64 %9, i1 false)
  %10 = load i32, ptr %fd.addr, align 4
  %call7 = call ptr @fd_trans_target_to_host_data(i32 noundef %10)
  %11 = load ptr, ptr %host_msg, align 8
  %12 = load i64, ptr %len.addr, align 8
  %call8 = call i64 %call7(ptr noundef %11, i64 noundef %12)
  store i64 %call8, ptr %ret, align 8
  %13 = load i64, ptr %ret, align 8
  %cmp9 = icmp slt i64 %13, 0
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.then5
  br label %fail

if.end11:                                         ; preds = %if.then5
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end2
  %14 = load i64, ptr %target_addr.addr, align 8
  %tobool13 = icmp ne i64 %14, 0
  br i1 %tobool13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end12
  %15 = load i32, ptr %addrlen.addr, align 4
  %add = add i32 %15, 1
  %conv = zext i32 %add to i64
  %16 = alloca i8, i64 %conv, align 16
  store ptr %16, ptr %addr, align 8
  %17 = load i32, ptr %fd.addr, align 4
  %18 = load ptr, ptr %addr, align 8
  %19 = load i64, ptr %target_addr.addr, align 8
  %20 = load i32, ptr %addrlen.addr, align 4
  %call15 = call i64 @target_to_host_sockaddr(i32 noundef %17, ptr noundef %18, i64 noundef %19, i32 noundef %20)
  store i64 %call15, ptr %ret, align 8
  %21 = load i64, ptr %ret, align 8
  %tobool16 = icmp ne i64 %21, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then14
  br label %fail

if.end18:                                         ; preds = %if.then14
  %22 = load i32, ptr %fd.addr, align 4
  %23 = load ptr, ptr %host_msg, align 8
  %24 = load i64, ptr %len.addr, align 8
  %25 = load i32, ptr %flags.addr, align 4
  %26 = load ptr, ptr %addr, align 8
  %27 = load i32, ptr %addrlen.addr, align 4
  %call19 = call i64 @safe_sendto(i32 noundef %22, ptr noundef %23, i64 noundef %24, i32 noundef %25, ptr noundef %26, i32 noundef %27)
  %call20 = call i64 @get_errno(i64 noundef %call19)
  store i64 %call20, ptr %ret, align 8
  br label %if.end23

if.else:                                          ; preds = %if.end12
  %28 = load i32, ptr %fd.addr, align 4
  %29 = load ptr, ptr %host_msg, align 8
  %30 = load i64, ptr %len.addr, align 8
  %31 = load i32, ptr %flags.addr, align 4
  %call21 = call i64 @safe_sendto(i32 noundef %28, ptr noundef %29, i64 noundef %30, i32 noundef %31, ptr noundef null, i32 noundef 0)
  %call22 = call i64 @get_errno(i64 noundef %call21)
  store i64 %call22, ptr %ret, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.end18
  br label %fail

fail:                                             ; preds = %if.end23, %if.then17, %if.then10
  %32 = load ptr, ptr %copy_msg, align 8
  %tobool24 = icmp ne ptr %32, null
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %fail
  %33 = load ptr, ptr %host_msg, align 8
  call void @g_free(ptr noundef %33)
  %34 = load ptr, ptr %copy_msg, align 8
  store ptr %34, ptr %host_msg, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %fail
  %35 = load ptr, ptr %host_msg, align 8
  %36 = load i64, ptr %msg.addr, align 8
  call void @unlock_user(ptr noundef %35, i64 noundef %36, i64 noundef 0)
  %37 = load i64, ptr %ret, align 8
  store i64 %37, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end26, %if.then1, %if.then
  %38 = load i64, ptr %retval, align 8
  ret i64 %38
}

; Function Attrs: nounwind
declare i32 @shutdown(i32 noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @getrandom(ptr noundef %buf, i64 noundef %buflen, i32 noundef %flags) #0 {
entry:
  %buf.addr = alloca ptr, align 8
  %buflen.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %buflen, ptr %buflen.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %buf.addr, align 8
  %1 = load i64, ptr %buflen.addr, align 8
  %2 = load i32, ptr %flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 318, ptr noundef %0, i64 noundef %1, i32 noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_socket(i32 noundef %domain, i32 noundef %type, i32 noundef %protocol) #0 {
entry:
  %retval = alloca i64, align 8
  %domain.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %protocol.addr = alloca i32, align 4
  %target_type = alloca i32, align 4
  %ret = alloca i32, align 4
  store i32 %domain, ptr %domain.addr, align 4
  store i32 %type, ptr %type.addr, align 4
  store i32 %protocol, ptr %protocol.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  store i32 %0, ptr %target_type, align 4
  %call = call i32 @target_to_host_sock_type(ptr noundef %type.addr)
  store i32 %call, ptr %ret, align 4
  %1 = load i32, ptr %ret, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %ret, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %domain.addr, align 4
  %cmp = icmp eq i32 %3, 16
  br i1 %cmp, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %if.end
  %4 = load i32, ptr %protocol.addr, align 4
  %cmp2 = icmp eq i32 %4, 0
  br i1 %cmp2, label %if.end10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %5 = load i32, ptr %protocol.addr, align 4
  %cmp4 = icmp eq i32 %5, 15
  br i1 %cmp4, label %if.end10, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %6 = load i32, ptr %protocol.addr, align 4
  %cmp7 = icmp eq i32 %6, 9
  br i1 %cmp7, label %if.end10, label %if.then9

if.then9:                                         ; preds = %lor.lhs.false6
  store i64 -93, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %lor.lhs.false6, %lor.lhs.false, %land.lhs.true, %if.end
  %7 = load i32, ptr %domain.addr, align 4
  %cmp11 = icmp eq i32 %7, 17
  br i1 %cmp11, label %if.then19, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %if.end10
  %8 = load i32, ptr %domain.addr, align 4
  %cmp14 = icmp eq i32 %8, 2
  br i1 %cmp14, label %land.lhs.true16, label %if.end23

land.lhs.true16:                                  ; preds = %lor.lhs.false13
  %9 = load i32, ptr %type.addr, align 4
  %cmp17 = icmp eq i32 %9, 10
  br i1 %cmp17, label %if.then19, label %if.end23

if.then19:                                        ; preds = %land.lhs.true16, %if.end10
  %10 = load i32, ptr %protocol.addr, align 4
  %conv20 = trunc i32 %10 to i16
  %call21 = call zeroext i16 @tswap16(i16 noundef zeroext %conv20)
  %conv22 = zext i16 %call21 to i32
  store i32 %conv22, ptr %protocol.addr, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then19, %land.lhs.true16, %lor.lhs.false13
  %11 = load i32, ptr %domain.addr, align 4
  %12 = load i32, ptr %type.addr, align 4
  %13 = load i32, ptr %protocol.addr, align 4
  %call24 = call i32 @socket(i32 noundef %11, i32 noundef %12, i32 noundef %13) #14
  %conv25 = sext i32 %call24 to i64
  %call26 = call i64 @get_errno(i64 noundef %conv25)
  %conv27 = trunc i64 %call26 to i32
  store i32 %conv27, ptr %ret, align 4
  %14 = load i32, ptr %ret, align 4
  %cmp28 = icmp sge i32 %14, 0
  br i1 %cmp28, label %if.then30, label %if.end42

if.then30:                                        ; preds = %if.end23
  %15 = load i32, ptr %ret, align 4
  %16 = load i32, ptr %target_type, align 4
  %call31 = call i32 @sock_flags_fixup(i32 noundef %15, i32 noundef %16)
  store i32 %call31, ptr %ret, align 4
  %17 = load i32, ptr %type.addr, align 4
  %cmp32 = icmp eq i32 %17, 10
  br i1 %cmp32, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.then30
  %18 = load i32, ptr %ret, align 4
  call void @fd_trans_register(i32 noundef %18, ptr noundef @target_packet_trans)
  br label %if.end41

if.else:                                          ; preds = %if.then30
  %19 = load i32, ptr %domain.addr, align 4
  %cmp35 = icmp eq i32 %19, 16
  br i1 %cmp35, label %if.then37, label %if.end40

if.then37:                                        ; preds = %if.else
  %20 = load i32, ptr %protocol.addr, align 4
  switch i32 %20, label %sw.default [
    i32 0, label %sw.bb
    i32 15, label %sw.bb38
    i32 9, label %sw.bb39
  ]

sw.bb:                                            ; preds = %if.then37
  %21 = load i32, ptr %ret, align 4
  call void @fd_trans_register(i32 noundef %21, ptr noundef @target_netlink_route_trans)
  br label %sw.epilog

sw.bb38:                                          ; preds = %if.then37
  br label %sw.epilog

sw.bb39:                                          ; preds = %if.then37
  %22 = load i32, ptr %ret, align 4
  call void @fd_trans_register(i32 noundef %22, ptr noundef @target_netlink_audit_trans)
  br label %sw.epilog

sw.default:                                       ; preds = %if.then37
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.579, i32 noundef 3174, ptr noundef @__func__.do_socket, ptr noundef null) #19
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb39, %sw.bb38, %sw.bb
  br label %if.end40

if.end40:                                         ; preds = %sw.epilog, %if.else
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then34
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.end23
  %23 = load i32, ptr %ret, align 4
  %conv43 = sext i32 %23 to i64
  store i64 %conv43, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end42, %if.then9, %if.then
  %24 = load i64, ptr %retval, align 8
  ret i64 %24
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_socketpair(i32 noundef %domain, i32 noundef %type, i32 noundef %protocol, i64 noundef %target_tab_addr) #0 {
entry:
  %domain.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %protocol.addr = alloca i32, align 4
  %target_tab_addr.addr = alloca i64, align 8
  %tab = alloca [2 x i32], align 4
  %ret = alloca i64, align 8
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__gaddr8 = alloca i64, align 8
  %__hptr9 = alloca ptr, align 8
  %__ret10 = alloca i64, align 8
  %tmp19 = alloca i64, align 8
  store i32 %domain, ptr %domain.addr, align 4
  store i32 %type, ptr %type.addr, align 4
  store i32 %protocol, ptr %protocol.addr, align 4
  store i64 %target_tab_addr, ptr %target_tab_addr.addr, align 8
  %call = call i32 @target_to_host_sock_type(ptr noundef %type.addr)
  %0 = load i32, ptr %domain.addr, align 4
  %1 = load i32, ptr %type.addr, align 4
  %2 = load i32, ptr %protocol.addr, align 4
  %arraydecay = getelementptr inbounds [2 x i32], ptr %tab, i64 0, i64 0
  %call1 = call i32 @socketpair(i32 noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %arraydecay) #14
  %conv = sext i32 %call1 to i64
  %call2 = call i64 @get_errno(i64 noundef %conv)
  store i64 %call2, ptr %ret, align 8
  %3 = load i64, ptr %ret, align 8
  %call3 = call i32 @is_error(i64 noundef %3)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end23, label %if.then

if.then:                                          ; preds = %entry
  %4 = load i64, ptr %target_tab_addr.addr, align 8
  store i64 %4, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %5 = load i64, ptr %__gaddr, align 8
  %call4 = call ptr @lock_user(i32 noundef 3, i64 noundef %5, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call4, ptr %__hptr, align 8
  %tobool5 = icmp ne ptr %call4, null
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then6
  %6 = load ptr, ptr %__hptr, align 8
  %arrayidx = getelementptr [2 x i32], ptr %tab, i64 0, i64 0
  %7 = load i32, ptr %arrayidx, align 4
  call void @stl_le_p(ptr noundef %6, i32 noundef %7)
  br label %do.end

do.end:                                           ; preds = %do.body
  %8 = load ptr, ptr %__hptr, align 8
  %9 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %8, i64 noundef %9, i64 noundef 4)
  br label %if.end

if.else:                                          ; preds = %if.then
  store i64 -14, ptr %__ret, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %10 = load i64, ptr %__ret, align 8
  store i64 %10, ptr %tmp, align 8
  %11 = load i64, ptr %tmp, align 8
  %tobool7 = icmp ne i64 %11, 0
  br i1 %tobool7, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %12 = load i64, ptr %target_tab_addr.addr, align 8
  %add = add i64 %12, 4
  store i64 %add, ptr %__gaddr8, align 8
  store i64 0, ptr %__ret10, align 8
  %13 = load i64, ptr %__gaddr8, align 8
  %call11 = call ptr @lock_user(i32 noundef 3, i64 noundef %13, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call11, ptr %__hptr9, align 8
  %tobool12 = icmp ne ptr %call11, null
  br i1 %tobool12, label %if.then13, label %if.else17

if.then13:                                        ; preds = %lor.lhs.false
  br label %do.body14

do.body14:                                        ; preds = %if.then13
  %14 = load ptr, ptr %__hptr9, align 8
  %arrayidx15 = getelementptr [2 x i32], ptr %tab, i64 0, i64 1
  %15 = load i32, ptr %arrayidx15, align 4
  call void @stl_le_p(ptr noundef %14, i32 noundef %15)
  br label %do.end16

do.end16:                                         ; preds = %do.body14
  %16 = load ptr, ptr %__hptr9, align 8
  %17 = load i64, ptr %__gaddr8, align 8
  call void @unlock_user(ptr noundef %16, i64 noundef %17, i64 noundef 4)
  br label %if.end18

if.else17:                                        ; preds = %lor.lhs.false
  store i64 -14, ptr %__ret10, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.else17, %do.end16
  %18 = load i64, ptr %__ret10, align 8
  store i64 %18, ptr %tmp19, align 8
  %19 = load i64, ptr %tmp19, align 8
  %tobool20 = icmp ne i64 %19, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18, %if.end
  store i64 -14, ptr %ret, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %if.end18
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %entry
  %20 = load i64, ptr %ret, align 8
  ret i64 %20
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_setsockopt(i32 noundef %sockfd, i32 noundef %level, i32 noundef %optname, i64 noundef %optval_addr, i32 noundef %optlen) #0 {
entry:
  %retval = alloca i64, align 8
  %sockfd.addr = alloca i32, align 4
  %level.addr = alloca i32, align 4
  %optname.addr = alloca i32, align 4
  %optval_addr.addr = alloca i64, align 8
  %optlen.addr = alloca i32, align 4
  %ret = alloca i64, align 8
  %val = alloca i32, align 4
  %ip_mreq = alloca ptr, align 8
  %ip_mreq_source = alloca ptr, align 8
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__gaddr17 = alloca i64, align 8
  %__hptr18 = alloca ptr, align 8
  %__ret19 = alloca i64, align 8
  %tmp28 = alloca i64, align 8
  %__gaddr36 = alloca i64, align 8
  %__hptr37 = alloca ptr, align 8
  %__ret38 = alloca i64, align 8
  %tmp49 = alloca i64, align 8
  %__gaddr93 = alloca i64, align 8
  %__hptr94 = alloca ptr, align 8
  %__ret95 = alloca i64, align 8
  %tmp104 = alloca i64, align 8
  %pki = alloca %struct.in6_pktinfo, align 4
  %ipv6mreq = alloca %struct.ipv6_mreq, align 4
  %icmp6f = alloca %struct.icmp6_filter, align 4
  %__gaddr173 = alloca i64, align 8
  %__hptr174 = alloca ptr, align 8
  %__ret175 = alloca i64, align 8
  %tmp184 = alloca i64, align 8
  %alg_key = alloca ptr, align 8
  %tv = alloca %struct.timeval, align 8
  %tfprog = alloca ptr, align 8
  %tfilter = alloca ptr, align 8
  %fprog = alloca %struct.sock_fprog, align 8
  %filter = alloca ptr, align 8
  %i = alloca i32, align 4
  %dev_ifname = alloca ptr, align 8
  %addr_ifname = alloca ptr, align 8
  %lg = alloca %struct.linger, align 4
  %tlg = alloca ptr, align 8
  %__gaddr355 = alloca i64, align 8
  %__hptr356 = alloca ptr, align 8
  %__ret357 = alloca i64, align 8
  %tmp366 = alloca i64, align 8
  %__gaddr382 = alloca i64, align 8
  %__hptr383 = alloca ptr, align 8
  %__ret384 = alloca i64, align 8
  %tmp393 = alloca i64, align 8
  store i32 %sockfd, ptr %sockfd.addr, align 4
  store i32 %level, ptr %level.addr, align 4
  store i32 %optname, ptr %optname.addr, align 4
  store i64 %optval_addr, ptr %optval_addr.addr, align 8
  store i32 %optlen, ptr %optlen.addr, align 4
  %0 = load i32, ptr %level.addr, align 4
  switch i32 %0, label %sw.default400 [
    i32 6, label %sw.bb
    i32 17, label %sw.bb
    i32 0, label %sw.bb11
    i32 41, label %sw.bb86
    i32 58, label %sw.bb143
    i32 255, label %sw.bb166
    i32 279, label %sw.bb193
    i32 1, label %sw.bb214
    i32 270, label %sw.bb373
  ]

sw.bb:                                            ; preds = %entry, %entry
  %1 = load i32, ptr %optlen.addr, align 4
  %conv = zext i32 %1 to i64
  %cmp = icmp ult i64 %conv, 4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i64 -22, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %sw.bb
  %2 = load i64, ptr %optval_addr.addr, align 8
  store i64 %2, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %3 = load i64, ptr %__gaddr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %3, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call, ptr %__hptr, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then2
  %4 = load ptr, ptr %__hptr, align 8
  %call3 = call i32 @ldl_le_p(ptr noundef %4)
  store i32 %call3, ptr %val, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  %5 = load ptr, ptr %__hptr, align 8
  %6 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %5, i64 noundef %6, i64 noundef 0)
  br label %if.end4

if.else:                                          ; preds = %if.end
  store i32 0, ptr %val, align 4
  store i64 -14, ptr %__ret, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.else, %do.end
  %7 = load i64, ptr %__ret, align 8
  store i64 %7, ptr %tmp, align 8
  %8 = load i64, ptr %tmp, align 8
  %tobool5 = icmp ne i64 %8, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  store i64 -14, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end4
  %9 = load i32, ptr %sockfd.addr, align 4
  %10 = load i32, ptr %level.addr, align 4
  %11 = load i32, ptr %optname.addr, align 4
  %call8 = call i32 @setsockopt(i32 noundef %9, i32 noundef %10, i32 noundef %11, ptr noundef %val, i32 noundef 4) #14
  %conv9 = sext i32 %call8 to i64
  %call10 = call i64 @get_errno(i64 noundef %conv9)
  store i64 %call10, ptr %ret, align 8
  br label %sw.epilog409

sw.bb11:                                          ; preds = %entry
  %12 = load i32, ptr %optname.addr, align 4
  switch i32 %12, label %sw.default [
    i32 1, label %sw.bb12
    i32 2, label %sw.bb12
    i32 3, label %sw.bb12
    i32 5, label %sw.bb12
    i32 6, label %sw.bb12
    i32 7, label %sw.bb12
    i32 8, label %sw.bb12
    i32 10, label %sw.bb12
    i32 11, label %sw.bb12
    i32 12, label %sw.bb12
    i32 13, label %sw.bb12
    i32 15, label %sw.bb12
    i32 33, label %sw.bb12
    i32 34, label %sw.bb12
    i32 35, label %sw.bb58
    i32 36, label %sw.bb58
    i32 38, label %sw.bb72
    i32 37, label %sw.bb72
    i32 39, label %sw.bb72
    i32 40, label %sw.bb72
  ]

sw.bb12:                                          ; preds = %sw.bb11, %sw.bb11, %sw.bb11, %sw.bb11, %sw.bb11, %sw.bb11, %sw.bb11, %sw.bb11, %sw.bb11, %sw.bb11, %sw.bb11, %sw.bb11, %sw.bb11, %sw.bb11
  store i32 0, ptr %val, align 4
  %13 = load i32, ptr %optlen.addr, align 4
  %conv13 = zext i32 %13 to i64
  %cmp14 = icmp uge i64 %conv13, 4
  br i1 %cmp14, label %if.then16, label %if.else32

if.then16:                                        ; preds = %sw.bb12
  %14 = load i64, ptr %optval_addr.addr, align 8
  store i64 %14, ptr %__gaddr17, align 8
  store i64 0, ptr %__ret19, align 8
  %15 = load i64, ptr %__gaddr17, align 8
  %call20 = call ptr @lock_user(i32 noundef 1, i64 noundef %15, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call20, ptr %__hptr18, align 8
  %tobool21 = icmp ne ptr %call20, null
  br i1 %tobool21, label %if.then22, label %if.else26

if.then22:                                        ; preds = %if.then16
  br label %do.body23

do.body23:                                        ; preds = %if.then22
  %16 = load ptr, ptr %__hptr18, align 8
  %call24 = call i32 @ldl_le_p(ptr noundef %16)
  store i32 %call24, ptr %val, align 4
  br label %do.end25

do.end25:                                         ; preds = %do.body23
  %17 = load ptr, ptr %__hptr18, align 8
  %18 = load i64, ptr %__gaddr17, align 8
  call void @unlock_user(ptr noundef %17, i64 noundef %18, i64 noundef 0)
  br label %if.end27

if.else26:                                        ; preds = %if.then16
  store i32 0, ptr %val, align 4
  store i64 -14, ptr %__ret19, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.else26, %do.end25
  %19 = load i64, ptr %__ret19, align 8
  store i64 %19, ptr %tmp28, align 8
  %20 = load i64, ptr %tmp28, align 8
  %tobool29 = icmp ne i64 %20, 0
  br i1 %tobool29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end27
  store i64 -14, ptr %retval, align 8
  br label %return

if.end31:                                         ; preds = %if.end27
  br label %if.end54

if.else32:                                        ; preds = %sw.bb12
  %21 = load i32, ptr %optlen.addr, align 4
  %cmp33 = icmp uge i32 %21, 1
  br i1 %cmp33, label %if.then35, label %if.end53

if.then35:                                        ; preds = %if.else32
  %22 = load i64, ptr %optval_addr.addr, align 8
  store i64 %22, ptr %__gaddr36, align 8
  store i64 0, ptr %__ret38, align 8
  %23 = load i64, ptr %__gaddr36, align 8
  %call39 = call ptr @lock_user(i32 noundef 1, i64 noundef %23, i64 noundef 1, i1 noundef zeroext true)
  store ptr %call39, ptr %__hptr37, align 8
  %tobool40 = icmp ne ptr %call39, null
  br i1 %tobool40, label %if.then41, label %if.else47

if.then41:                                        ; preds = %if.then35
  br label %do.body42

do.body42:                                        ; preds = %if.then41
  %24 = load ptr, ptr %__hptr37, align 8
  %call43 = call i32 @ldub_p(ptr noundef %24)
  %conv44 = trunc i32 %call43 to i8
  %conv45 = zext i8 %conv44 to i32
  store i32 %conv45, ptr %val, align 4
  br label %do.end46

do.end46:                                         ; preds = %do.body42
  %25 = load ptr, ptr %__hptr37, align 8
  %26 = load i64, ptr %__gaddr36, align 8
  call void @unlock_user(ptr noundef %25, i64 noundef %26, i64 noundef 0)
  br label %if.end48

if.else47:                                        ; preds = %if.then35
  store i32 0, ptr %val, align 4
  store i64 -14, ptr %__ret38, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.else47, %do.end46
  %27 = load i64, ptr %__ret38, align 8
  store i64 %27, ptr %tmp49, align 8
  %28 = load i64, ptr %tmp49, align 8
  %tobool50 = icmp ne i64 %28, 0
  br i1 %tobool50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.end48
  store i64 -14, ptr %retval, align 8
  br label %return

if.end52:                                         ; preds = %if.end48
  br label %if.end53

if.end53:                                         ; preds = %if.end52, %if.else32
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.end31
  %29 = load i32, ptr %sockfd.addr, align 4
  %30 = load i32, ptr %level.addr, align 4
  %31 = load i32, ptr %optname.addr, align 4
  %call55 = call i32 @setsockopt(i32 noundef %29, i32 noundef %30, i32 noundef %31, ptr noundef %val, i32 noundef 4) #14
  %conv56 = sext i32 %call55 to i64
  %call57 = call i64 @get_errno(i64 noundef %conv56)
  store i64 %call57, ptr %ret, align 8
  br label %sw.epilog

sw.bb58:                                          ; preds = %sw.bb11, %sw.bb11
  %32 = load i32, ptr %optlen.addr, align 4
  %conv59 = zext i32 %32 to i64
  %cmp60 = icmp ult i64 %conv59, 8
  br i1 %cmp60, label %if.then65, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb58
  %33 = load i32, ptr %optlen.addr, align 4
  %conv62 = zext i32 %33 to i64
  %cmp63 = icmp ugt i64 %conv62, 16
  br i1 %cmp63, label %if.then65, label %if.end66

if.then65:                                        ; preds = %lor.lhs.false, %sw.bb58
  store i64 -22, ptr %retval, align 8
  br label %return

if.end66:                                         ; preds = %lor.lhs.false
  %34 = load i32, ptr %optlen.addr, align 4
  %conv67 = zext i32 %34 to i64
  %35 = alloca i8, i64 %conv67, align 16
  store ptr %35, ptr %ip_mreq, align 8
  %36 = load ptr, ptr %ip_mreq, align 8
  %37 = load i64, ptr %optval_addr.addr, align 8
  %38 = load i32, ptr %optlen.addr, align 4
  %call68 = call i64 @target_to_host_ip_mreq(ptr noundef %36, i64 noundef %37, i32 noundef %38)
  %39 = load i32, ptr %sockfd.addr, align 4
  %40 = load i32, ptr %level.addr, align 4
  %41 = load i32, ptr %optname.addr, align 4
  %42 = load ptr, ptr %ip_mreq, align 8
  %43 = load i32, ptr %optlen.addr, align 4
  %call69 = call i32 @setsockopt(i32 noundef %39, i32 noundef %40, i32 noundef %41, ptr noundef %42, i32 noundef %43) #14
  %conv70 = sext i32 %call69 to i64
  %call71 = call i64 @get_errno(i64 noundef %conv70)
  store i64 %call71, ptr %ret, align 8
  br label %sw.epilog

sw.bb72:                                          ; preds = %sw.bb11, %sw.bb11, %sw.bb11, %sw.bb11
  %44 = load i32, ptr %optlen.addr, align 4
  %conv73 = zext i32 %44 to i64
  %cmp74 = icmp ne i64 %conv73, 12
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %sw.bb72
  store i64 -22, ptr %retval, align 8
  br label %return

if.end77:                                         ; preds = %sw.bb72
  %45 = load i64, ptr %optval_addr.addr, align 8
  %46 = load i32, ptr %optlen.addr, align 4
  %conv78 = zext i32 %46 to i64
  %call79 = call ptr @lock_user(i32 noundef 1, i64 noundef %45, i64 noundef %conv78, i1 noundef zeroext true)
  store ptr %call79, ptr %ip_mreq_source, align 8
  %47 = load ptr, ptr %ip_mreq_source, align 8
  %tobool80 = icmp ne ptr %47, null
  br i1 %tobool80, label %if.end82, label %if.then81

if.then81:                                        ; preds = %if.end77
  store i64 -14, ptr %retval, align 8
  br label %return

if.end82:                                         ; preds = %if.end77
  %48 = load i32, ptr %sockfd.addr, align 4
  %49 = load i32, ptr %level.addr, align 4
  %50 = load i32, ptr %optname.addr, align 4
  %51 = load ptr, ptr %ip_mreq_source, align 8
  %52 = load i32, ptr %optlen.addr, align 4
  %call83 = call i32 @setsockopt(i32 noundef %48, i32 noundef %49, i32 noundef %50, ptr noundef %51, i32 noundef %52) #14
  %conv84 = sext i32 %call83 to i64
  %call85 = call i64 @get_errno(i64 noundef %conv84)
  store i64 %call85, ptr %ret, align 8
  %53 = load ptr, ptr %ip_mreq_source, align 8
  %54 = load i64, ptr %optval_addr.addr, align 8
  call void @unlock_user(ptr noundef %53, i64 noundef %54, i64 noundef 0)
  br label %sw.epilog

sw.default:                                       ; preds = %sw.bb11
  br label %unimplemented

sw.epilog:                                        ; preds = %if.end82, %if.end66, %if.end54
  br label %sw.epilog409

sw.bb86:                                          ; preds = %entry
  %55 = load i32, ptr %optname.addr, align 4
  switch i32 %55, label %sw.default141 [
    i32 23, label %sw.bb87
    i32 24, label %sw.bb87
    i32 26, label %sw.bb87
    i32 49, label %sw.bb87
    i32 16, label %sw.bb87
    i32 18, label %sw.bb87
    i32 19, label %sw.bb87
    i32 25, label %sw.bb87
    i32 51, label %sw.bb87
    i32 8, label %sw.bb87
    i32 7, label %sw.bb87
    i32 1, label %sw.bb87
    i32 2, label %sw.bb87
    i32 66, label %sw.bb87
    i32 56, label %sw.bb87
    i32 5, label %sw.bb87
    i32 53, label %sw.bb87
    i32 3, label %sw.bb87
    i32 58, label %sw.bb87
    i32 4, label %sw.bb87
    i32 67, label %sw.bb87
    i32 72, label %sw.bb87
    i32 60, label %sw.bb87
    i32 75, label %sw.bb87
    i32 78, label %sw.bb87
    i32 74, label %sw.bb87
    i32 50, label %sw.bb111
    i32 20, label %sw.bb126
    i32 21, label %sw.bb126
  ]

sw.bb87:                                          ; preds = %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86, %sw.bb86
  store i32 0, ptr %val, align 4
  %56 = load i32, ptr %optlen.addr, align 4
  %conv88 = zext i32 %56 to i64
  %cmp89 = icmp ult i64 %conv88, 4
  br i1 %cmp89, label %if.then91, label %if.end92

if.then91:                                        ; preds = %sw.bb87
  store i64 -22, ptr %retval, align 8
  br label %return

if.end92:                                         ; preds = %sw.bb87
  %57 = load i64, ptr %optval_addr.addr, align 8
  store i64 %57, ptr %__gaddr93, align 8
  store i64 0, ptr %__ret95, align 8
  %58 = load i64, ptr %__gaddr93, align 8
  %call96 = call ptr @lock_user(i32 noundef 1, i64 noundef %58, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call96, ptr %__hptr94, align 8
  %tobool97 = icmp ne ptr %call96, null
  br i1 %tobool97, label %if.then98, label %if.else102

if.then98:                                        ; preds = %if.end92
  br label %do.body99

do.body99:                                        ; preds = %if.then98
  %59 = load ptr, ptr %__hptr94, align 8
  %call100 = call i32 @ldl_le_p(ptr noundef %59)
  store i32 %call100, ptr %val, align 4
  br label %do.end101

do.end101:                                        ; preds = %do.body99
  %60 = load ptr, ptr %__hptr94, align 8
  %61 = load i64, ptr %__gaddr93, align 8
  call void @unlock_user(ptr noundef %60, i64 noundef %61, i64 noundef 0)
  br label %if.end103

if.else102:                                       ; preds = %if.end92
  store i32 0, ptr %val, align 4
  store i64 -14, ptr %__ret95, align 8
  br label %if.end103

if.end103:                                        ; preds = %if.else102, %do.end101
  %62 = load i64, ptr %__ret95, align 8
  store i64 %62, ptr %tmp104, align 8
  %63 = load i64, ptr %tmp104, align 8
  %tobool105 = icmp ne i64 %63, 0
  br i1 %tobool105, label %if.then106, label %if.end107

if.then106:                                       ; preds = %if.end103
  store i64 -14, ptr %retval, align 8
  br label %return

if.end107:                                        ; preds = %if.end103
  %64 = load i32, ptr %sockfd.addr, align 4
  %65 = load i32, ptr %level.addr, align 4
  %66 = load i32, ptr %optname.addr, align 4
  %call108 = call i32 @setsockopt(i32 noundef %64, i32 noundef %65, i32 noundef %66, ptr noundef %val, i32 noundef 4) #14
  %conv109 = sext i32 %call108 to i64
  %call110 = call i64 @get_errno(i64 noundef %conv109)
  store i64 %call110, ptr %ret, align 8
  br label %sw.epilog142

sw.bb111:                                         ; preds = %sw.bb86
  %67 = load i32, ptr %optlen.addr, align 4
  %conv112 = zext i32 %67 to i64
  %cmp113 = icmp ult i64 %conv112, 20
  br i1 %cmp113, label %if.then115, label %if.end116

if.then115:                                       ; preds = %sw.bb111
  store i64 -22, ptr %retval, align 8
  br label %return

if.end116:                                        ; preds = %sw.bb111
  %68 = load i64, ptr %optval_addr.addr, align 8
  %call117 = call i32 @copy_from_user(ptr noundef %pki, i64 noundef %68, i64 noundef 20)
  %tobool118 = icmp ne i32 %call117, 0
  br i1 %tobool118, label %if.then119, label %if.end120

if.then119:                                       ; preds = %if.end116
  store i64 -14, ptr %retval, align 8
  br label %return

if.end120:                                        ; preds = %if.end116
  %ipi6_ifindex = getelementptr inbounds %struct.in6_pktinfo, ptr %pki, i32 0, i32 1
  %69 = load i32, ptr %ipi6_ifindex, align 4
  %call121 = call i32 @tswap32(i32 noundef %69)
  %ipi6_ifindex122 = getelementptr inbounds %struct.in6_pktinfo, ptr %pki, i32 0, i32 1
  store i32 %call121, ptr %ipi6_ifindex122, align 4
  %70 = load i32, ptr %sockfd.addr, align 4
  %71 = load i32, ptr %level.addr, align 4
  %72 = load i32, ptr %optname.addr, align 4
  %call123 = call i32 @setsockopt(i32 noundef %70, i32 noundef %71, i32 noundef %72, ptr noundef %pki, i32 noundef 20) #14
  %conv124 = sext i32 %call123 to i64
  %call125 = call i64 @get_errno(i64 noundef %conv124)
  store i64 %call125, ptr %ret, align 8
  br label %sw.epilog142

sw.bb126:                                         ; preds = %sw.bb86, %sw.bb86
  %73 = load i32, ptr %optlen.addr, align 4
  %conv127 = zext i32 %73 to i64
  %cmp128 = icmp ult i64 %conv127, 20
  br i1 %cmp128, label %if.then130, label %if.end131

if.then130:                                       ; preds = %sw.bb126
  store i64 -22, ptr %retval, align 8
  br label %return

if.end131:                                        ; preds = %sw.bb126
  %74 = load i64, ptr %optval_addr.addr, align 8
  %call132 = call i32 @copy_from_user(ptr noundef %ipv6mreq, i64 noundef %74, i64 noundef 20)
  %tobool133 = icmp ne i32 %call132, 0
  br i1 %tobool133, label %if.then134, label %if.end135

if.then134:                                       ; preds = %if.end131
  store i64 -14, ptr %retval, align 8
  br label %return

if.end135:                                        ; preds = %if.end131
  %ipv6mr_interface = getelementptr inbounds %struct.ipv6_mreq, ptr %ipv6mreq, i32 0, i32 1
  %75 = load i32, ptr %ipv6mr_interface, align 4
  %call136 = call i32 @tswap32(i32 noundef %75)
  %ipv6mr_interface137 = getelementptr inbounds %struct.ipv6_mreq, ptr %ipv6mreq, i32 0, i32 1
  store i32 %call136, ptr %ipv6mr_interface137, align 4
  %76 = load i32, ptr %sockfd.addr, align 4
  %77 = load i32, ptr %level.addr, align 4
  %78 = load i32, ptr %optname.addr, align 4
  %call138 = call i32 @setsockopt(i32 noundef %76, i32 noundef %77, i32 noundef %78, ptr noundef %ipv6mreq, i32 noundef 20) #14
  %conv139 = sext i32 %call138 to i64
  %call140 = call i64 @get_errno(i64 noundef %conv139)
  store i64 %call140, ptr %ret, align 8
  br label %sw.epilog142

sw.default141:                                    ; preds = %sw.bb86
  br label %unimplemented

sw.epilog142:                                     ; preds = %if.end135, %if.end120, %if.end107
  br label %sw.epilog409

sw.bb143:                                         ; preds = %entry
  %79 = load i32, ptr %optname.addr, align 4
  switch i32 %79, label %sw.default164 [
    i32 1, label %sw.bb144
  ]

sw.bb144:                                         ; preds = %sw.bb143
  %80 = load i32, ptr %optlen.addr, align 4
  %conv145 = zext i32 %80 to i64
  %cmp146 = icmp ugt i64 %conv145, 32
  br i1 %cmp146, label %if.then148, label %if.end149

if.then148:                                       ; preds = %sw.bb144
  store i32 32, ptr %optlen.addr, align 4
  br label %if.end149

if.end149:                                        ; preds = %if.then148, %sw.bb144
  %81 = load i64, ptr %optval_addr.addr, align 8
  %82 = load i32, ptr %optlen.addr, align 4
  %conv150 = zext i32 %82 to i64
  %call151 = call i32 @copy_from_user(ptr noundef %icmp6f, i64 noundef %81, i64 noundef %conv150)
  %tobool152 = icmp ne i32 %call151, 0
  br i1 %tobool152, label %if.then153, label %if.end154

if.then153:                                       ; preds = %if.end149
  store i64 -14, ptr %retval, align 8
  br label %return

if.end154:                                        ; preds = %if.end149
  store i32 0, ptr %val, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end154
  %83 = load i32, ptr %val, align 4
  %cmp155 = icmp slt i32 %83, 8
  br i1 %cmp155, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %data = getelementptr inbounds %struct.icmp6_filter, ptr %icmp6f, i32 0, i32 0
  %84 = load i32, ptr %val, align 4
  %idxprom = sext i32 %84 to i64
  %arrayidx = getelementptr [8 x i32], ptr %data, i64 0, i64 %idxprom
  %85 = load i32, ptr %arrayidx, align 4
  %call157 = call i32 @tswap32(i32 noundef %85)
  %data158 = getelementptr inbounds %struct.icmp6_filter, ptr %icmp6f, i32 0, i32 0
  %86 = load i32, ptr %val, align 4
  %idxprom159 = sext i32 %86 to i64
  %arrayidx160 = getelementptr [8 x i32], ptr %data158, i64 0, i64 %idxprom159
  store i32 %call157, ptr %arrayidx160, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %87 = load i32, ptr %val, align 4
  %inc = add i32 %87, 1
  store i32 %inc, ptr %val, align 4
  br label %for.cond, !llvm.loop !34

for.end:                                          ; preds = %for.cond
  %88 = load i32, ptr %sockfd.addr, align 4
  %89 = load i32, ptr %level.addr, align 4
  %90 = load i32, ptr %optname.addr, align 4
  %91 = load i32, ptr %optlen.addr, align 4
  %call161 = call i32 @setsockopt(i32 noundef %88, i32 noundef %89, i32 noundef %90, ptr noundef %icmp6f, i32 noundef %91) #14
  %conv162 = sext i32 %call161 to i64
  %call163 = call i64 @get_errno(i64 noundef %conv162)
  store i64 %call163, ptr %ret, align 8
  br label %sw.epilog165

sw.default164:                                    ; preds = %sw.bb143
  br label %unimplemented

sw.epilog165:                                     ; preds = %for.end
  br label %sw.epilog409

sw.bb166:                                         ; preds = %entry
  %92 = load i32, ptr %optname.addr, align 4
  switch i32 %92, label %sw.default191 [
    i32 1, label %sw.bb167
    i32 7, label %sw.bb167
  ]

sw.bb167:                                         ; preds = %sw.bb166, %sw.bb166
  %93 = load i32, ptr %optlen.addr, align 4
  %conv168 = zext i32 %93 to i64
  %cmp169 = icmp ult i64 %conv168, 4
  br i1 %cmp169, label %if.then171, label %if.end172

if.then171:                                       ; preds = %sw.bb167
  store i64 -22, ptr %retval, align 8
  br label %return

if.end172:                                        ; preds = %sw.bb167
  %94 = load i64, ptr %optval_addr.addr, align 8
  store i64 %94, ptr %__gaddr173, align 8
  store i64 0, ptr %__ret175, align 8
  %95 = load i64, ptr %__gaddr173, align 8
  %call176 = call ptr @lock_user(i32 noundef 1, i64 noundef %95, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call176, ptr %__hptr174, align 8
  %tobool177 = icmp ne ptr %call176, null
  br i1 %tobool177, label %if.then178, label %if.else182

if.then178:                                       ; preds = %if.end172
  br label %do.body179

do.body179:                                       ; preds = %if.then178
  %96 = load ptr, ptr %__hptr174, align 8
  %call180 = call i32 @ldl_le_p(ptr noundef %96)
  store i32 %call180, ptr %val, align 4
  br label %do.end181

do.end181:                                        ; preds = %do.body179
  %97 = load ptr, ptr %__hptr174, align 8
  %98 = load i64, ptr %__gaddr173, align 8
  call void @unlock_user(ptr noundef %97, i64 noundef %98, i64 noundef 0)
  br label %if.end183

if.else182:                                       ; preds = %if.end172
  store i32 0, ptr %val, align 4
  store i64 -14, ptr %__ret175, align 8
  br label %if.end183

if.end183:                                        ; preds = %if.else182, %do.end181
  %99 = load i64, ptr %__ret175, align 8
  store i64 %99, ptr %tmp184, align 8
  %100 = load i64, ptr %tmp184, align 8
  %tobool185 = icmp ne i64 %100, 0
  br i1 %tobool185, label %if.then186, label %if.end187

if.then186:                                       ; preds = %if.end183
  store i64 -14, ptr %retval, align 8
  br label %return

if.end187:                                        ; preds = %if.end183
  %101 = load i32, ptr %sockfd.addr, align 4
  %102 = load i32, ptr %level.addr, align 4
  %103 = load i32, ptr %optname.addr, align 4
  %call188 = call i32 @setsockopt(i32 noundef %101, i32 noundef %102, i32 noundef %103, ptr noundef %val, i32 noundef 4) #14
  %conv189 = sext i32 %call188 to i64
  %call190 = call i64 @get_errno(i64 noundef %conv189)
  store i64 %call190, ptr %ret, align 8
  br label %sw.epilog192

sw.default191:                                    ; preds = %sw.bb166
  br label %unimplemented

sw.epilog192:                                     ; preds = %if.end187
  br label %sw.epilog409

sw.bb193:                                         ; preds = %entry
  %104 = load i32, ptr %optname.addr, align 4
  switch i32 %104, label %sw.default212 [
    i32 1, label %sw.bb194
    i32 5, label %sw.bb208
  ]

sw.bb194:                                         ; preds = %sw.bb193
  %105 = load i32, ptr %optlen.addr, align 4
  %conv195 = zext i32 %105 to i64
  %call196 = call noalias ptr @g_malloc(i64 noundef %conv195) #16
  store ptr %call196, ptr %alg_key, align 8
  %106 = load ptr, ptr %alg_key, align 8
  %tobool197 = icmp ne ptr %106, null
  br i1 %tobool197, label %if.end199, label %if.then198

if.then198:                                       ; preds = %sw.bb194
  store i64 -12, ptr %retval, align 8
  br label %return

if.end199:                                        ; preds = %sw.bb194
  %107 = load ptr, ptr %alg_key, align 8
  %108 = load i64, ptr %optval_addr.addr, align 8
  %109 = load i32, ptr %optlen.addr, align 4
  %conv200 = zext i32 %109 to i64
  %call201 = call i32 @copy_from_user(ptr noundef %107, i64 noundef %108, i64 noundef %conv200)
  %tobool202 = icmp ne i32 %call201, 0
  br i1 %tobool202, label %if.then203, label %if.end204

if.then203:                                       ; preds = %if.end199
  %110 = load ptr, ptr %alg_key, align 8
  call void @g_free(ptr noundef %110)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end204:                                        ; preds = %if.end199
  %111 = load i32, ptr %sockfd.addr, align 4
  %112 = load i32, ptr %level.addr, align 4
  %113 = load i32, ptr %optname.addr, align 4
  %114 = load ptr, ptr %alg_key, align 8
  %115 = load i32, ptr %optlen.addr, align 4
  %call205 = call i32 @setsockopt(i32 noundef %111, i32 noundef %112, i32 noundef %113, ptr noundef %114, i32 noundef %115) #14
  %conv206 = sext i32 %call205 to i64
  %call207 = call i64 @get_errno(i64 noundef %conv206)
  store i64 %call207, ptr %ret, align 8
  %116 = load ptr, ptr %alg_key, align 8
  call void @g_free(ptr noundef %116)
  br label %sw.epilog213

sw.bb208:                                         ; preds = %sw.bb193
  %117 = load i32, ptr %sockfd.addr, align 4
  %118 = load i32, ptr %level.addr, align 4
  %119 = load i32, ptr %optname.addr, align 4
  %120 = load i32, ptr %optlen.addr, align 4
  %call209 = call i32 @setsockopt(i32 noundef %117, i32 noundef %118, i32 noundef %119, ptr noundef null, i32 noundef %120) #14
  %conv210 = sext i32 %call209 to i64
  %call211 = call i64 @get_errno(i64 noundef %conv210)
  store i64 %call211, ptr %ret, align 8
  br label %sw.epilog213

sw.default212:                                    ; preds = %sw.bb193
  br label %unimplemented

sw.epilog213:                                     ; preds = %sw.bb208, %if.end204
  br label %sw.epilog409

sw.bb214:                                         ; preds = %entry
  %121 = load i32, ptr %optname.addr, align 4
  switch i32 %121, label %sw.default348 [
    i32 20, label %sw.bb215
    i32 21, label %sw.bb228
    i32 26, label %sw.bb229
    i32 25, label %sw.bb291
    i32 13, label %sw.bb307
    i32 1, label %sw.bb328
    i32 2, label %sw.bb329
    i32 15, label %sw.bb330
    i32 3, label %sw.bb331
    i32 4, label %sw.bb332
    i32 5, label %sw.bb333
    i32 6, label %sw.bb334
    i32 7, label %sw.bb335
    i32 32, label %sw.bb336
    i32 8, label %sw.bb337
    i32 33, label %sw.bb338
    i32 9, label %sw.bb339
    i32 10, label %sw.bb340
    i32 11, label %sw.bb341
    i32 12, label %sw.bb342
    i32 14, label %sw.bb343
    i32 16, label %sw.bb344
    i32 34, label %sw.bb345
    i32 29, label %sw.bb346
    i32 18, label %sw.bb347
  ]

sw.bb215:                                         ; preds = %sw.bb214
  store i32 20, ptr %optname.addr, align 4
  br label %set_timeout

set_timeout:                                      ; preds = %sw.bb228, %sw.bb215
  %122 = load i32, ptr %optlen.addr, align 4
  %conv216 = zext i32 %122 to i64
  %cmp217 = icmp ne i64 %conv216, 16
  br i1 %cmp217, label %if.then219, label %if.end220

if.then219:                                       ; preds = %set_timeout
  store i64 -22, ptr %retval, align 8
  br label %return

if.end220:                                        ; preds = %set_timeout
  %123 = load i64, ptr %optval_addr.addr, align 8
  %call221 = call i64 @copy_from_user_timeval(ptr noundef %tv, i64 noundef %123)
  %tobool222 = icmp ne i64 %call221, 0
  br i1 %tobool222, label %if.then223, label %if.end224

if.then223:                                       ; preds = %if.end220
  store i64 -14, ptr %retval, align 8
  br label %return

if.end224:                                        ; preds = %if.end220
  %124 = load i32, ptr %sockfd.addr, align 4
  %125 = load i32, ptr %optname.addr, align 4
  %call225 = call i32 @setsockopt(i32 noundef %124, i32 noundef 1, i32 noundef %125, ptr noundef %tv, i32 noundef 16) #14
  %conv226 = sext i32 %call225 to i64
  %call227 = call i64 @get_errno(i64 noundef %conv226)
  store i64 %call227, ptr %ret, align 8
  %126 = load i64, ptr %ret, align 8
  store i64 %126, ptr %retval, align 8
  br label %return

sw.bb228:                                         ; preds = %sw.bb214
  store i32 21, ptr %optname.addr, align 4
  br label %set_timeout

sw.bb229:                                         ; preds = %sw.bb214
  %127 = load i32, ptr %optlen.addr, align 4
  %conv230 = zext i32 %127 to i64
  %cmp231 = icmp ne i64 %conv230, 16
  br i1 %cmp231, label %if.then233, label %if.end234

if.then233:                                       ; preds = %sw.bb229
  store i64 -22, ptr %retval, align 8
  br label %return

if.end234:                                        ; preds = %sw.bb229
  %128 = load i64, ptr %optval_addr.addr, align 8
  %call235 = call ptr @lock_user(i32 noundef 1, i64 noundef %128, i64 noundef 16, i1 noundef zeroext false)
  store ptr %call235, ptr %tfprog, align 8
  %tobool236 = icmp ne ptr %call235, null
  br i1 %tobool236, label %if.end238, label %if.then237

if.then237:                                       ; preds = %if.end234
  store i64 -14, ptr %retval, align 8
  br label %return

if.end238:                                        ; preds = %if.end234
  %129 = load ptr, ptr %tfprog, align 8
  %filter239 = getelementptr inbounds %struct.target_sock_fprog, ptr %129, i32 0, i32 1
  %130 = load i64, ptr %filter239, align 8
  %call240 = call i64 @tswapal(i64 noundef %130)
  %call241 = call ptr @lock_user(i32 noundef 1, i64 noundef %call240, i64 noundef 8, i1 noundef zeroext false)
  store ptr %call241, ptr %tfilter, align 8
  %tobool242 = icmp ne ptr %call241, null
  br i1 %tobool242, label %if.end244, label %if.then243

if.then243:                                       ; preds = %if.end238
  %131 = load ptr, ptr %tfprog, align 8
  %132 = load i64, ptr %optval_addr.addr, align 8
  call void @unlock_user(ptr noundef %131, i64 noundef %132, i64 noundef 16)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end244:                                        ; preds = %if.end238
  %133 = load ptr, ptr %tfprog, align 8
  %len = getelementptr inbounds %struct.target_sock_fprog, ptr %133, i32 0, i32 0
  %134 = load i16, ptr %len, align 8
  %call245 = call zeroext i16 @tswap16(i16 noundef zeroext %134)
  %len246 = getelementptr inbounds %struct.sock_fprog, ptr %fprog, i32 0, i32 0
  store i16 %call245, ptr %len246, align 8
  %len247 = getelementptr inbounds %struct.sock_fprog, ptr %fprog, i32 0, i32 0
  %135 = load i16, ptr %len247, align 8
  %conv248 = zext i16 %135 to i64
  %call249 = call noalias ptr @g_try_malloc_n(i64 noundef %conv248, i64 noundef 8) #17
  store ptr %call249, ptr %filter, align 8
  %136 = load ptr, ptr %filter, align 8
  %cmp250 = icmp eq ptr %136, null
  br i1 %cmp250, label %if.then252, label %if.end254

if.then252:                                       ; preds = %if.end244
  %137 = load ptr, ptr %tfilter, align 8
  %138 = load ptr, ptr %tfprog, align 8
  %filter253 = getelementptr inbounds %struct.target_sock_fprog, ptr %138, i32 0, i32 1
  %139 = load i64, ptr %filter253, align 8
  call void @unlock_user(ptr noundef %137, i64 noundef %139, i64 noundef 8)
  %140 = load ptr, ptr %tfprog, align 8
  %141 = load i64, ptr %optval_addr.addr, align 8
  call void @unlock_user(ptr noundef %140, i64 noundef %141, i64 noundef 16)
  store i64 -12, ptr %retval, align 8
  br label %return

if.end254:                                        ; preds = %if.end244
  store i32 0, ptr %i, align 4
  br label %for.cond255

for.cond255:                                      ; preds = %for.inc283, %if.end254
  %142 = load i32, ptr %i, align 4
  %len256 = getelementptr inbounds %struct.sock_fprog, ptr %fprog, i32 0, i32 0
  %143 = load i16, ptr %len256, align 8
  %conv257 = zext i16 %143 to i32
  %cmp258 = icmp slt i32 %142, %conv257
  br i1 %cmp258, label %for.body260, label %for.end285

for.body260:                                      ; preds = %for.cond255
  %144 = load ptr, ptr %tfilter, align 8
  %145 = load i32, ptr %i, align 4
  %idxprom261 = sext i32 %145 to i64
  %arrayidx262 = getelementptr %struct.target_sock_filter, ptr %144, i64 %idxprom261
  %code = getelementptr inbounds %struct.target_sock_filter, ptr %arrayidx262, i32 0, i32 0
  %146 = load i16, ptr %code, align 4
  %call263 = call zeroext i16 @tswap16(i16 noundef zeroext %146)
  %147 = load ptr, ptr %filter, align 8
  %148 = load i32, ptr %i, align 4
  %idxprom264 = sext i32 %148 to i64
  %arrayidx265 = getelementptr %struct.sock_filter, ptr %147, i64 %idxprom264
  %code266 = getelementptr inbounds %struct.sock_filter, ptr %arrayidx265, i32 0, i32 0
  store i16 %call263, ptr %code266, align 4
  %149 = load ptr, ptr %tfilter, align 8
  %150 = load i32, ptr %i, align 4
  %idxprom267 = sext i32 %150 to i64
  %arrayidx268 = getelementptr %struct.target_sock_filter, ptr %149, i64 %idxprom267
  %jt = getelementptr inbounds %struct.target_sock_filter, ptr %arrayidx268, i32 0, i32 1
  %151 = load i8, ptr %jt, align 2
  %152 = load ptr, ptr %filter, align 8
  %153 = load i32, ptr %i, align 4
  %idxprom269 = sext i32 %153 to i64
  %arrayidx270 = getelementptr %struct.sock_filter, ptr %152, i64 %idxprom269
  %jt271 = getelementptr inbounds %struct.sock_filter, ptr %arrayidx270, i32 0, i32 1
  store i8 %151, ptr %jt271, align 2
  %154 = load ptr, ptr %tfilter, align 8
  %155 = load i32, ptr %i, align 4
  %idxprom272 = sext i32 %155 to i64
  %arrayidx273 = getelementptr %struct.target_sock_filter, ptr %154, i64 %idxprom272
  %jf = getelementptr inbounds %struct.target_sock_filter, ptr %arrayidx273, i32 0, i32 2
  %156 = load i8, ptr %jf, align 1
  %157 = load ptr, ptr %filter, align 8
  %158 = load i32, ptr %i, align 4
  %idxprom274 = sext i32 %158 to i64
  %arrayidx275 = getelementptr %struct.sock_filter, ptr %157, i64 %idxprom274
  %jf276 = getelementptr inbounds %struct.sock_filter, ptr %arrayidx275, i32 0, i32 2
  store i8 %156, ptr %jf276, align 1
  %159 = load ptr, ptr %tfilter, align 8
  %160 = load i32, ptr %i, align 4
  %idxprom277 = sext i32 %160 to i64
  %arrayidx278 = getelementptr %struct.target_sock_filter, ptr %159, i64 %idxprom277
  %k = getelementptr inbounds %struct.target_sock_filter, ptr %arrayidx278, i32 0, i32 3
  %161 = load i32, ptr %k, align 4
  %call279 = call i32 @tswap32(i32 noundef %161)
  %162 = load ptr, ptr %filter, align 8
  %163 = load i32, ptr %i, align 4
  %idxprom280 = sext i32 %163 to i64
  %arrayidx281 = getelementptr %struct.sock_filter, ptr %162, i64 %idxprom280
  %k282 = getelementptr inbounds %struct.sock_filter, ptr %arrayidx281, i32 0, i32 3
  store i32 %call279, ptr %k282, align 4
  br label %for.inc283

for.inc283:                                       ; preds = %for.body260
  %164 = load i32, ptr %i, align 4
  %inc284 = add i32 %164, 1
  store i32 %inc284, ptr %i, align 4
  br label %for.cond255, !llvm.loop !35

for.end285:                                       ; preds = %for.cond255
  %165 = load ptr, ptr %filter, align 8
  %filter286 = getelementptr inbounds %struct.sock_fprog, ptr %fprog, i32 0, i32 1
  store ptr %165, ptr %filter286, align 8
  %166 = load i32, ptr %sockfd.addr, align 4
  %call287 = call i32 @setsockopt(i32 noundef %166, i32 noundef 1, i32 noundef 26, ptr noundef %fprog, i32 noundef 16) #14
  %conv288 = sext i32 %call287 to i64
  %call289 = call i64 @get_errno(i64 noundef %conv288)
  store i64 %call289, ptr %ret, align 8
  %167 = load ptr, ptr %filter, align 8
  call void @g_free(ptr noundef %167)
  %168 = load ptr, ptr %tfilter, align 8
  %169 = load ptr, ptr %tfprog, align 8
  %filter290 = getelementptr inbounds %struct.target_sock_fprog, ptr %169, i32 0, i32 1
  %170 = load i64, ptr %filter290, align 8
  call void @unlock_user(ptr noundef %168, i64 noundef %170, i64 noundef 8)
  %171 = load ptr, ptr %tfprog, align 8
  %172 = load i64, ptr %optval_addr.addr, align 8
  call void @unlock_user(ptr noundef %171, i64 noundef %172, i64 noundef 16)
  %173 = load i64, ptr %ret, align 8
  store i64 %173, ptr %retval, align 8
  br label %return

sw.bb291:                                         ; preds = %sw.bb214
  %174 = load i32, ptr %optlen.addr, align 4
  %cmp292 = icmp ugt i32 %174, 15
  br i1 %cmp292, label %if.then294, label %if.end295

if.then294:                                       ; preds = %sw.bb291
  store i32 15, ptr %optlen.addr, align 4
  br label %if.end295

if.end295:                                        ; preds = %if.then294, %sw.bb291
  %175 = load i64, ptr %optval_addr.addr, align 8
  %176 = load i32, ptr %optlen.addr, align 4
  %conv296 = zext i32 %176 to i64
  %call297 = call ptr @lock_user(i32 noundef 1, i64 noundef %175, i64 noundef %conv296, i1 noundef zeroext true)
  store ptr %call297, ptr %dev_ifname, align 8
  %177 = load ptr, ptr %dev_ifname, align 8
  %tobool298 = icmp ne ptr %177, null
  br i1 %tobool298, label %if.end300, label %if.then299

if.then299:                                       ; preds = %if.end295
  store i64 -14, ptr %retval, align 8
  br label %return

if.end300:                                        ; preds = %if.end295
  store i32 25, ptr %optname.addr, align 4
  %178 = alloca i8, i64 16, align 16
  store ptr %178, ptr %addr_ifname, align 8
  %179 = load ptr, ptr %addr_ifname, align 8
  %180 = load ptr, ptr %dev_ifname, align 8
  %181 = load i32, ptr %optlen.addr, align 4
  %conv301 = zext i32 %181 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %179, ptr align 1 %180, i64 %conv301, i1 false)
  %182 = load ptr, ptr %addr_ifname, align 8
  %183 = load i32, ptr %optlen.addr, align 4
  %idxprom302 = zext i32 %183 to i64
  %arrayidx303 = getelementptr i8, ptr %182, i64 %idxprom302
  store i8 0, ptr %arrayidx303, align 1
  %184 = load i32, ptr %sockfd.addr, align 4
  %185 = load i32, ptr %optname.addr, align 4
  %186 = load ptr, ptr %addr_ifname, align 8
  %187 = load i32, ptr %optlen.addr, align 4
  %call304 = call i32 @setsockopt(i32 noundef %184, i32 noundef 1, i32 noundef %185, ptr noundef %186, i32 noundef %187) #14
  %conv305 = sext i32 %call304 to i64
  %call306 = call i64 @get_errno(i64 noundef %conv305)
  store i64 %call306, ptr %ret, align 8
  %188 = load ptr, ptr %dev_ifname, align 8
  %189 = load i64, ptr %optval_addr.addr, align 8
  call void @unlock_user(ptr noundef %188, i64 noundef %189, i64 noundef 0)
  %190 = load i64, ptr %ret, align 8
  store i64 %190, ptr %retval, align 8
  br label %return

sw.bb307:                                         ; preds = %sw.bb214
  %191 = load i32, ptr %optlen.addr, align 4
  %conv308 = zext i32 %191 to i64
  %cmp309 = icmp ne i64 %conv308, 8
  br i1 %cmp309, label %if.then311, label %if.end312

if.then311:                                       ; preds = %sw.bb307
  store i64 -22, ptr %retval, align 8
  br label %return

if.end312:                                        ; preds = %sw.bb307
  %192 = load i64, ptr %optval_addr.addr, align 8
  %call313 = call ptr @lock_user(i32 noundef 1, i64 noundef %192, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call313, ptr %tlg, align 8
  %tobool314 = icmp ne ptr %call313, null
  br i1 %tobool314, label %if.end316, label %if.then315

if.then315:                                       ; preds = %if.end312
  store i64 -14, ptr %retval, align 8
  br label %return

if.end316:                                        ; preds = %if.end312
  br label %do.body317

do.body317:                                       ; preds = %if.end316
  %193 = load ptr, ptr %tlg, align 8
  %l_onoff = getelementptr inbounds %struct.target_linger, ptr %193, i32 0, i32 0
  %call318 = call i32 @ldl_le_p(ptr noundef %l_onoff)
  %l_onoff319 = getelementptr inbounds %struct.linger, ptr %lg, i32 0, i32 0
  store i32 %call318, ptr %l_onoff319, align 4
  br label %do.end320

do.end320:                                        ; preds = %do.body317
  br label %do.body321

do.body321:                                       ; preds = %do.end320
  %194 = load ptr, ptr %tlg, align 8
  %l_linger = getelementptr inbounds %struct.target_linger, ptr %194, i32 0, i32 1
  %call322 = call i32 @ldl_le_p(ptr noundef %l_linger)
  %l_linger323 = getelementptr inbounds %struct.linger, ptr %lg, i32 0, i32 1
  store i32 %call322, ptr %l_linger323, align 4
  br label %do.end324

do.end324:                                        ; preds = %do.body321
  %195 = load i32, ptr %sockfd.addr, align 4
  %call325 = call i32 @setsockopt(i32 noundef %195, i32 noundef 1, i32 noundef 13, ptr noundef %lg, i32 noundef 8) #14
  %conv326 = sext i32 %call325 to i64
  %call327 = call i64 @get_errno(i64 noundef %conv326)
  store i64 %call327, ptr %ret, align 8
  %196 = load ptr, ptr %tlg, align 8
  %197 = load i64, ptr %optval_addr.addr, align 8
  call void @unlock_user(ptr noundef %196, i64 noundef %197, i64 noundef 0)
  %198 = load i64, ptr %ret, align 8
  store i64 %198, ptr %retval, align 8
  br label %return

sw.bb328:                                         ; preds = %sw.bb214
  store i32 1, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb329:                                         ; preds = %sw.bb214
  store i32 2, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb330:                                         ; preds = %sw.bb214
  store i32 15, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb331:                                         ; preds = %sw.bb214
  store i32 3, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb332:                                         ; preds = %sw.bb214
  store i32 4, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb333:                                         ; preds = %sw.bb214
  store i32 5, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb334:                                         ; preds = %sw.bb214
  store i32 6, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb335:                                         ; preds = %sw.bb214
  store i32 7, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb336:                                         ; preds = %sw.bb214
  store i32 32, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb337:                                         ; preds = %sw.bb214
  store i32 8, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb338:                                         ; preds = %sw.bb214
  store i32 33, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb339:                                         ; preds = %sw.bb214
  store i32 9, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb340:                                         ; preds = %sw.bb214
  store i32 10, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb341:                                         ; preds = %sw.bb214
  store i32 11, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb342:                                         ; preds = %sw.bb214
  store i32 12, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb343:                                         ; preds = %sw.bb214
  store i32 14, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb344:                                         ; preds = %sw.bb214
  store i32 16, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb345:                                         ; preds = %sw.bb214
  store i32 34, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb346:                                         ; preds = %sw.bb214
  store i32 29, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.bb347:                                         ; preds = %sw.bb214
  store i32 18, ptr %optname.addr, align 4
  br label %sw.epilog349

sw.default348:                                    ; preds = %sw.bb214
  br label %unimplemented

sw.epilog349:                                     ; preds = %sw.bb347, %sw.bb346, %sw.bb345, %sw.bb344, %sw.bb343, %sw.bb342, %sw.bb341, %sw.bb340, %sw.bb339, %sw.bb338, %sw.bb337, %sw.bb336, %sw.bb335, %sw.bb334, %sw.bb333, %sw.bb332, %sw.bb331, %sw.bb330, %sw.bb329, %sw.bb328
  %199 = load i32, ptr %optlen.addr, align 4
  %conv350 = zext i32 %199 to i64
  %cmp351 = icmp ult i64 %conv350, 4
  br i1 %cmp351, label %if.then353, label %if.end354

if.then353:                                       ; preds = %sw.epilog349
  store i64 -22, ptr %retval, align 8
  br label %return

if.end354:                                        ; preds = %sw.epilog349
  %200 = load i64, ptr %optval_addr.addr, align 8
  store i64 %200, ptr %__gaddr355, align 8
  store i64 0, ptr %__ret357, align 8
  %201 = load i64, ptr %__gaddr355, align 8
  %call358 = call ptr @lock_user(i32 noundef 1, i64 noundef %201, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call358, ptr %__hptr356, align 8
  %tobool359 = icmp ne ptr %call358, null
  br i1 %tobool359, label %if.then360, label %if.else364

if.then360:                                       ; preds = %if.end354
  br label %do.body361

do.body361:                                       ; preds = %if.then360
  %202 = load ptr, ptr %__hptr356, align 8
  %call362 = call i32 @ldl_le_p(ptr noundef %202)
  store i32 %call362, ptr %val, align 4
  br label %do.end363

do.end363:                                        ; preds = %do.body361
  %203 = load ptr, ptr %__hptr356, align 8
  %204 = load i64, ptr %__gaddr355, align 8
  call void @unlock_user(ptr noundef %203, i64 noundef %204, i64 noundef 0)
  br label %if.end365

if.else364:                                       ; preds = %if.end354
  store i32 0, ptr %val, align 4
  store i64 -14, ptr %__ret357, align 8
  br label %if.end365

if.end365:                                        ; preds = %if.else364, %do.end363
  %205 = load i64, ptr %__ret357, align 8
  store i64 %205, ptr %tmp366, align 8
  %206 = load i64, ptr %tmp366, align 8
  %tobool367 = icmp ne i64 %206, 0
  br i1 %tobool367, label %if.then368, label %if.end369

if.then368:                                       ; preds = %if.end365
  store i64 -14, ptr %retval, align 8
  br label %return

if.end369:                                        ; preds = %if.end365
  %207 = load i32, ptr %sockfd.addr, align 4
  %208 = load i32, ptr %optname.addr, align 4
  %call370 = call i32 @setsockopt(i32 noundef %207, i32 noundef 1, i32 noundef %208, ptr noundef %val, i32 noundef 4) #14
  %conv371 = sext i32 %call370 to i64
  %call372 = call i64 @get_errno(i64 noundef %conv371)
  store i64 %call372, ptr %ret, align 8
  br label %sw.epilog409

sw.bb373:                                         ; preds = %entry
  %209 = load i32, ptr %optname.addr, align 4
  switch i32 %209, label %sw.default375 [
    i32 3, label %sw.bb374
    i32 1, label %sw.bb374
    i32 2, label %sw.bb374
    i32 4, label %sw.bb374
    i32 5, label %sw.bb374
    i32 8, label %sw.bb374
    i32 10, label %sw.bb374
    i32 11, label %sw.bb374
    i32 12, label %sw.bb374
  ]

sw.bb374:                                         ; preds = %sw.bb373, %sw.bb373, %sw.bb373, %sw.bb373, %sw.bb373, %sw.bb373, %sw.bb373, %sw.bb373, %sw.bb373
  br label %sw.epilog376

sw.default375:                                    ; preds = %sw.bb373
  br label %unimplemented

sw.epilog376:                                     ; preds = %sw.bb374
  store i32 0, ptr %val, align 4
  %210 = load i32, ptr %optlen.addr, align 4
  %conv377 = zext i32 %210 to i64
  %cmp378 = icmp ult i64 %conv377, 4
  br i1 %cmp378, label %if.then380, label %if.end381

if.then380:                                       ; preds = %sw.epilog376
  store i64 -22, ptr %retval, align 8
  br label %return

if.end381:                                        ; preds = %sw.epilog376
  %211 = load i64, ptr %optval_addr.addr, align 8
  store i64 %211, ptr %__gaddr382, align 8
  store i64 0, ptr %__ret384, align 8
  %212 = load i64, ptr %__gaddr382, align 8
  %call385 = call ptr @lock_user(i32 noundef 1, i64 noundef %212, i64 noundef 4, i1 noundef zeroext true)
  store ptr %call385, ptr %__hptr383, align 8
  %tobool386 = icmp ne ptr %call385, null
  br i1 %tobool386, label %if.then387, label %if.else391

if.then387:                                       ; preds = %if.end381
  br label %do.body388

do.body388:                                       ; preds = %if.then387
  %213 = load ptr, ptr %__hptr383, align 8
  %call389 = call i32 @ldl_le_p(ptr noundef %213)
  store i32 %call389, ptr %val, align 4
  br label %do.end390

do.end390:                                        ; preds = %do.body388
  %214 = load ptr, ptr %__hptr383, align 8
  %215 = load i64, ptr %__gaddr382, align 8
  call void @unlock_user(ptr noundef %214, i64 noundef %215, i64 noundef 0)
  br label %if.end392

if.else391:                                       ; preds = %if.end381
  store i32 0, ptr %val, align 4
  store i64 -14, ptr %__ret384, align 8
  br label %if.end392

if.end392:                                        ; preds = %if.else391, %do.end390
  %216 = load i64, ptr %__ret384, align 8
  store i64 %216, ptr %tmp393, align 8
  %217 = load i64, ptr %tmp393, align 8
  %tobool394 = icmp ne i64 %217, 0
  br i1 %tobool394, label %if.then395, label %if.end396

if.then395:                                       ; preds = %if.end392
  store i64 -14, ptr %retval, align 8
  br label %return

if.end396:                                        ; preds = %if.end392
  %218 = load i32, ptr %sockfd.addr, align 4
  %219 = load i32, ptr %optname.addr, align 4
  %call397 = call i32 @setsockopt(i32 noundef %218, i32 noundef 270, i32 noundef %219, ptr noundef %val, i32 noundef 4) #14
  %conv398 = sext i32 %call397 to i64
  %call399 = call i64 @get_errno(i64 noundef %conv398)
  store i64 %call399, ptr %ret, align 8
  br label %sw.epilog409

sw.default400:                                    ; preds = %entry
  br label %unimplemented

unimplemented:                                    ; preds = %sw.default400, %sw.default375, %sw.default348, %sw.default212, %sw.default191, %sw.default164, %sw.default141, %sw.default
  br label %do.body401

do.body401:                                       ; preds = %unimplemented
  %call402 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 1024)
  %lnot = xor i1 %call402, true
  %lnot403 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot403 to i32
  %conv404 = sext i32 %lnot.ext to i64
  %tobool405 = icmp ne i64 %conv404, 0
  br i1 %tobool405, label %if.then406, label %if.end407

if.then406:                                       ; preds = %do.body401
  %220 = load i32, ptr %level.addr, align 4
  %221 = load i32, ptr %optname.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.637, i32 noundef %220, i32 noundef %221)
  br label %if.end407

if.end407:                                        ; preds = %if.then406, %do.body401
  br label %do.end408

do.end408:                                        ; preds = %if.end407
  store i64 -92, ptr %ret, align 8
  br label %sw.epilog409

sw.epilog409:                                     ; preds = %do.end408, %if.end396, %if.end369, %sw.epilog213, %sw.epilog192, %sw.epilog165, %sw.epilog142, %sw.epilog, %if.end7
  %222 = load i64, ptr %ret, align 8
  store i64 %222, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog409, %if.then395, %if.then380, %if.then368, %if.then353, %do.end324, %if.then315, %if.then311, %if.end300, %if.then299, %for.end285, %if.then252, %if.then243, %if.then237, %if.then233, %if.end224, %if.then223, %if.then219, %if.then203, %if.then198, %if.then186, %if.then171, %if.then153, %if.then134, %if.then130, %if.then119, %if.then115, %if.then106, %if.then91, %if.then81, %if.then76, %if.then65, %if.then51, %if.then30, %if.then6, %if.then
  %223 = load i64, ptr %retval, align 8
  ret i64 %223
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_syslog(i32 noundef %type, ptr noundef %bufp, i32 noundef %len) #0 {
entry:
  %type.addr = alloca i32, align 4
  %bufp.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  store i32 %type, ptr %type.addr, align 4
  store ptr %bufp, ptr %bufp.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %1 = load ptr, ptr %bufp.addr, align 8
  %2 = load i32, ptr %len.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 103, i32 noundef %0, ptr noundef %1, i32 noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @setitimer(i32 noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @getitimer(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @fstat64(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @vhangup() #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_wait4(i32 noundef %pid, ptr noundef %status, i32 noundef %options, ptr noundef %rusage) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %status.addr = alloca ptr, align 8
  %options.addr = alloca i32, align 4
  %rusage.addr = alloca ptr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store ptr %status, ptr %status.addr, align 8
  store i32 %options, ptr %options.addr, align 4
  store ptr %rusage, ptr %rusage.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %pid.addr, align 4
  %4 = load ptr, ptr %status.addr, align 8
  %5 = load i32, ptr %options.addr, align 4
  %6 = load ptr, ptr %rusage.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 61, i32 noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef %6)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @swapoff(ptr noundef) #2

; Function Attrs: nounwind
declare i32 @sysinfo(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @stw_le_p(ptr noundef %ptr, i16 noundef zeroext %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i16, align 2
  store ptr %ptr, ptr %ptr.addr, align 8
  store i16 %v, ptr %v.addr, align 2
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i16, ptr %v.addr, align 2
  call void @stw_he_p(ptr noundef %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind
declare i32 @semget(i32 noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_semtimedop(i32 noundef %semid, i64 noundef %ptr, i32 noundef %nsops, i64 noundef %timeout, i1 noundef zeroext %time64) #0 {
entry:
  %retval = alloca i64, align 8
  %semid.addr = alloca i32, align 4
  %ptr.addr = alloca i64, align 8
  %nsops.addr = alloca i32, align 4
  %timeout.addr = alloca i64, align 8
  %time64.addr = alloca i8, align 1
  %sops = alloca ptr, align 8
  %ts = alloca %struct.timespec, align 8
  %pts = alloca ptr, align 8
  %ret = alloca i64, align 8
  store i32 %semid, ptr %semid.addr, align 4
  store i64 %ptr, ptr %ptr.addr, align 8
  store i32 %nsops, ptr %nsops.addr, align 4
  store i64 %timeout, ptr %timeout.addr, align 8
  %frombool = zext i1 %time64 to i8
  store i8 %frombool, ptr %time64.addr, align 1
  store ptr null, ptr %pts, align 8
  %0 = load i64, ptr %timeout.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  store ptr %ts, ptr %pts, align 8
  %1 = load i8, ptr %time64.addr, align 1
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %2 = load ptr, ptr %pts, align 8
  %3 = load i64, ptr %timeout.addr, align 8
  %call = call i64 @target_to_host_timespec64(ptr noundef %2, i64 noundef %3)
  %tobool3 = icmp ne i64 %call, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then2
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then2
  br label %if.end9

if.else:                                          ; preds = %if.then
  %4 = load ptr, ptr %pts, align 8
  %5 = load i64, ptr %timeout.addr, align 8
  %call5 = call i64 @target_to_host_timespec(ptr noundef %4, i64 noundef %5)
  %tobool6 = icmp ne i64 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.else
  store i64 -14, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.else
  br label %if.end9

if.end9:                                          ; preds = %if.end8, %if.end
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %entry
  %6 = load i32, ptr %nsops.addr, align 4
  %cmp = icmp ugt i32 %6, 500
  br i1 %cmp, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end10
  store i64 -7, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end10
  %7 = load i32, ptr %nsops.addr, align 4
  %conv = zext i32 %7 to i64
  %call13 = call noalias ptr @g_malloc_n(i64 noundef %conv, i64 noundef 6) #17
  store ptr %call13, ptr %sops, align 8
  %8 = load ptr, ptr %sops, align 8
  %9 = load i64, ptr %ptr.addr, align 8
  %10 = load i32, ptr %nsops.addr, align 4
  %call14 = call i64 @target_to_host_sembuf(ptr noundef %8, i64 noundef %9, i32 noundef %10)
  %tobool15 = icmp ne i64 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end12
  %11 = load ptr, ptr %sops, align 8
  call void @g_free(ptr noundef %11)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %if.end12
  store i64 -38, ptr %ret, align 8
  %12 = load i32, ptr %semid.addr, align 4
  %13 = load ptr, ptr %sops, align 8
  %14 = load i32, ptr %nsops.addr, align 4
  %15 = load ptr, ptr %pts, align 8
  %call18 = call i32 @safe_semtimedop(i32 noundef %12, ptr noundef %13, i32 noundef %14, ptr noundef %15)
  %conv19 = sext i32 %call18 to i64
  %call20 = call i64 @get_errno(i64 noundef %conv19)
  store i64 %call20, ptr %ret, align 8
  %16 = load ptr, ptr %sops, align 8
  call void @g_free(ptr noundef %16)
  %17 = load i64, ptr %ret, align 8
  store i64 %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end17, %if.then16, %if.then11, %if.then7, %if.then4
  %18 = load i64, ptr %retval, align 8
  ret i64 %18
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_semctl(i32 noundef %semid, i32 noundef %semnum, i32 noundef %cmd, i64 noundef %target_arg) #0 {
entry:
  %retval = alloca i64, align 8
  %semid.addr = alloca i32, align 4
  %semnum.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %target_arg.addr = alloca i64, align 8
  %target_su = alloca %union.target_semun, align 8
  %arg = alloca %union.semun, align 8
  %dsarg = alloca %struct.semid_ds, align 8
  %array = alloca ptr, align 8
  %seminfo = alloca %struct.seminfo, align 4
  %ret = alloca i64, align 8
  %err = alloca i64, align 8
  store i32 %semid, ptr %semid.addr, align 4
  store i32 %semnum, ptr %semnum.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %target_arg, ptr %target_arg.addr, align 8
  %0 = load i64, ptr %target_arg.addr, align 8
  store i64 %0, ptr %target_su, align 8
  store ptr null, ptr %array, align 8
  store i64 -22, ptr %ret, align 8
  %1 = load i32, ptr %cmd.addr, align 4
  %and = and i32 %1, 255
  store i32 %and, ptr %cmd.addr, align 4
  %2 = load i32, ptr %cmd.addr, align 4
  switch i32 %2, label %sw.epilog [
    i32 12, label %sw.bb
    i32 16, label %sw.bb
    i32 13, label %sw.bb4
    i32 17, label %sw.bb4
    i32 2, label %sw.bb14
    i32 1, label %sw.bb14
    i32 18, label %sw.bb14
    i32 3, label %sw.bb27
    i32 19, label %sw.bb27
    i32 0, label %sw.bb36
    i32 11, label %sw.bb36
    i32 14, label %sw.bb36
    i32 15, label %sw.bb36
  ]

sw.bb:                                            ; preds = %entry, %entry
  %3 = load i64, ptr %target_su, align 8
  %call = call i64 @tswapal(i64 noundef %3)
  store i64 %call, ptr %target_su, align 8
  %4 = load i32, ptr %target_su, align 8
  %call1 = call i32 @tswap32(i32 noundef %4)
  store i32 %call1, ptr %arg, align 8
  %5 = load i32, ptr %semid.addr, align 4
  %6 = load i32, ptr %semnum.addr, align 4
  %7 = load i32, ptr %cmd.addr, align 4
  %coerce.dive = getelementptr inbounds %union.semun, ptr %arg, i32 0, i32 0
  %8 = load ptr, ptr %coerce.dive, align 8
  %call2 = call i32 (i32, i32, i32, ...) @semctl(i32 noundef %5, i32 noundef %6, i32 noundef %7, ptr %8) #14
  %conv = sext i32 %call2 to i64
  %call3 = call i64 @get_errno(i64 noundef %conv)
  store i64 %call3, ptr %ret, align 8
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry, %entry
  %9 = load i32, ptr %semid.addr, align 4
  %10 = load i64, ptr %target_su, align 8
  %call5 = call i64 @target_to_host_semarray(i32 noundef %9, ptr noundef %array, i64 noundef %10)
  store i64 %call5, ptr %err, align 8
  %11 = load i64, ptr %err, align 8
  %tobool = icmp ne i64 %11, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb4
  %12 = load i64, ptr %err, align 8
  store i64 %12, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %sw.bb4
  %13 = load ptr, ptr %array, align 8
  store ptr %13, ptr %arg, align 8
  %14 = load i32, ptr %semid.addr, align 4
  %15 = load i32, ptr %semnum.addr, align 4
  %16 = load i32, ptr %cmd.addr, align 4
  %coerce.dive6 = getelementptr inbounds %union.semun, ptr %arg, i32 0, i32 0
  %17 = load ptr, ptr %coerce.dive6, align 8
  %call7 = call i32 (i32, i32, i32, ...) @semctl(i32 noundef %14, i32 noundef %15, i32 noundef %16, ptr %17) #14
  %conv8 = sext i32 %call7 to i64
  %call9 = call i64 @get_errno(i64 noundef %conv8)
  store i64 %call9, ptr %ret, align 8
  %18 = load i32, ptr %semid.addr, align 4
  %19 = load i64, ptr %target_su, align 8
  %call10 = call i64 @host_to_target_semarray(i32 noundef %18, i64 noundef %19, ptr noundef %array)
  store i64 %call10, ptr %err, align 8
  %20 = load i64, ptr %err, align 8
  %tobool11 = icmp ne i64 %20, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  %21 = load i64, ptr %err, align 8
  store i64 %21, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %if.end
  br label %sw.epilog

sw.bb14:                                          ; preds = %entry, %entry, %entry
  %22 = load i64, ptr %target_su, align 8
  %call15 = call i64 @target_to_host_semid_ds(ptr noundef %dsarg, i64 noundef %22)
  store i64 %call15, ptr %err, align 8
  %23 = load i64, ptr %err, align 8
  %tobool16 = icmp ne i64 %23, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %sw.bb14
  %24 = load i64, ptr %err, align 8
  store i64 %24, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %sw.bb14
  store ptr %dsarg, ptr %arg, align 8
  %25 = load i32, ptr %semid.addr, align 4
  %26 = load i32, ptr %semnum.addr, align 4
  %27 = load i32, ptr %cmd.addr, align 4
  %coerce.dive19 = getelementptr inbounds %union.semun, ptr %arg, i32 0, i32 0
  %28 = load ptr, ptr %coerce.dive19, align 8
  %call20 = call i32 (i32, i32, i32, ...) @semctl(i32 noundef %25, i32 noundef %26, i32 noundef %27, ptr %28) #14
  %conv21 = sext i32 %call20 to i64
  %call22 = call i64 @get_errno(i64 noundef %conv21)
  store i64 %call22, ptr %ret, align 8
  %29 = load i64, ptr %target_su, align 8
  %call23 = call i64 @host_to_target_semid_ds(i64 noundef %29, ptr noundef %dsarg)
  store i64 %call23, ptr %err, align 8
  %30 = load i64, ptr %err, align 8
  %tobool24 = icmp ne i64 %30, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end18
  %31 = load i64, ptr %err, align 8
  store i64 %31, ptr %retval, align 8
  br label %return

if.end26:                                         ; preds = %if.end18
  br label %sw.epilog

sw.bb27:                                          ; preds = %entry, %entry
  store ptr %seminfo, ptr %arg, align 8
  %32 = load i32, ptr %semid.addr, align 4
  %33 = load i32, ptr %semnum.addr, align 4
  %34 = load i32, ptr %cmd.addr, align 4
  %coerce.dive28 = getelementptr inbounds %union.semun, ptr %arg, i32 0, i32 0
  %35 = load ptr, ptr %coerce.dive28, align 8
  %call29 = call i32 (i32, i32, i32, ...) @semctl(i32 noundef %32, i32 noundef %33, i32 noundef %34, ptr %35) #14
  %conv30 = sext i32 %call29 to i64
  %call31 = call i64 @get_errno(i64 noundef %conv30)
  store i64 %call31, ptr %ret, align 8
  %36 = load i64, ptr %target_su, align 8
  %call32 = call i64 @host_to_target_seminfo(i64 noundef %36, ptr noundef %seminfo)
  store i64 %call32, ptr %err, align 8
  %37 = load i64, ptr %err, align 8
  %tobool33 = icmp ne i64 %37, 0
  br i1 %tobool33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %sw.bb27
  %38 = load i64, ptr %err, align 8
  store i64 %38, ptr %retval, align 8
  br label %return

if.end35:                                         ; preds = %sw.bb27
  br label %sw.epilog

sw.bb36:                                          ; preds = %entry, %entry, %entry, %entry
  %39 = load i32, ptr %semid.addr, align 4
  %40 = load i32, ptr %semnum.addr, align 4
  %41 = load i32, ptr %cmd.addr, align 4
  %call37 = call i32 (i32, i32, i32, ...) @semctl(i32 noundef %39, i32 noundef %40, i32 noundef %41, ptr noundef null) #14
  %conv38 = sext i32 %call37 to i64
  %call39 = call i64 @get_errno(i64 noundef %conv38)
  store i64 %call39, ptr %ret, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb36, %if.end35, %if.end26, %if.end13, %sw.bb, %entry
  %42 = load i64, ptr %ret, align 8
  store i64 %42, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %if.then34, %if.then25, %if.then17, %if.then12, %if.then
  %43 = load i64, ptr %retval, align 8
  ret i64 %43
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_msgctl(i32 noundef %msgid, i32 noundef %cmd, i64 noundef %ptr) #0 {
entry:
  %retval = alloca i64, align 8
  %msgid.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %ptr.addr = alloca i64, align 8
  %dsarg = alloca %struct.msqid_ds, align 8
  %msginfo = alloca %struct.msginfo, align 4
  %ret = alloca i64, align 8
  store i32 %msgid, ptr %msgid.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %ptr, ptr %ptr.addr, align 8
  store i64 -22, ptr %ret, align 8
  %0 = load i32, ptr %cmd.addr, align 4
  %and = and i32 %0, 255
  store i32 %and, ptr %cmd.addr, align 4
  %1 = load i32, ptr %cmd.addr, align 4
  switch i32 %1, label %sw.epilog [
    i32 2, label %sw.bb
    i32 1, label %sw.bb
    i32 11, label %sw.bb
    i32 0, label %sw.bb7
    i32 3, label %sw.bb11
    i32 12, label %sw.bb11
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  %2 = load i64, ptr %ptr.addr, align 8
  %call = call i64 @target_to_host_msqid_ds(ptr noundef %dsarg, i64 noundef %2)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %sw.bb
  %3 = load i32, ptr %msgid.addr, align 4
  %4 = load i32, ptr %cmd.addr, align 4
  %call1 = call i32 @msgctl(i32 noundef %3, i32 noundef %4, ptr noundef %dsarg) #14
  %conv = sext i32 %call1 to i64
  %call2 = call i64 @get_errno(i64 noundef %conv)
  store i64 %call2, ptr %ret, align 8
  %5 = load i64, ptr %ptr.addr, align 8
  %call3 = call i64 @host_to_target_msqid_ds(i64 noundef %5, ptr noundef %dsarg)
  %tobool4 = icmp ne i64 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  %6 = load i32, ptr %msgid.addr, align 4
  %7 = load i32, ptr %cmd.addr, align 4
  %call8 = call i32 @msgctl(i32 noundef %6, i32 noundef %7, ptr noundef null) #14
  %conv9 = sext i32 %call8 to i64
  %call10 = call i64 @get_errno(i64 noundef %conv9)
  store i64 %call10, ptr %ret, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %entry, %entry
  %8 = load i32, ptr %msgid.addr, align 4
  %9 = load i32, ptr %cmd.addr, align 4
  %call12 = call i32 @msgctl(i32 noundef %8, i32 noundef %9, ptr noundef %msginfo) #14
  %conv13 = sext i32 %call12 to i64
  %call14 = call i64 @get_errno(i64 noundef %conv13)
  store i64 %call14, ptr %ret, align 8
  %10 = load i64, ptr %ptr.addr, align 8
  %call15 = call i64 @host_to_target_msginfo(i64 noundef %10, ptr noundef %msginfo)
  %tobool16 = icmp ne i64 %call15, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %sw.bb11
  store i64 -14, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %sw.bb11
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end18, %sw.bb7, %if.end6, %entry
  %11 = load i64, ptr %ret, align 8
  store i64 %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %if.then17, %if.then5, %if.then
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

; Function Attrs: nounwind
declare i32 @msgget(i32 noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_msgrcv(i32 noundef %msqid, i64 noundef %msgp, i64 noundef %msgsz, i64 noundef %msgtyp, i32 noundef %msgflg) #0 {
entry:
  %retval = alloca i64, align 8
  %msqid.addr = alloca i32, align 4
  %msgp.addr = alloca i64, align 8
  %msgsz.addr = alloca i64, align 8
  %msgtyp.addr = alloca i64, align 8
  %msgflg.addr = alloca i32, align 4
  %target_mb = alloca ptr, align 8
  %target_mtext = alloca ptr, align 8
  %host_mb = alloca ptr, align 8
  %ret = alloca i64, align 8
  %target_mtext_addr = alloca i64, align 8
  store i32 %msqid, ptr %msqid.addr, align 4
  store i64 %msgp, ptr %msgp.addr, align 8
  store i64 %msgsz, ptr %msgsz.addr, align 8
  store i64 %msgtyp, ptr %msgtyp.addr, align 8
  store i32 %msgflg, ptr %msgflg.addr, align 4
  store i64 0, ptr %ret, align 8
  %0 = load i64, ptr %msgsz.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -22, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %msgp.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %1, i64 noundef 16, i1 noundef zeroext false)
  store ptr %call, ptr %target_mb, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  %2 = load i64, ptr %msgsz.addr, align 8
  %add = add i64 %2, 8
  %call3 = call noalias ptr @g_try_malloc(i64 noundef %add) #16
  store ptr %call3, ptr %host_mb, align 8
  %3 = load ptr, ptr %host_mb, align 8
  %tobool4 = icmp ne ptr %3, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end2
  store i64 -12, ptr %ret, align 8
  br label %end

if.end6:                                          ; preds = %if.end2
  store i64 -38, ptr %ret, align 8
  %4 = load i32, ptr %msqid.addr, align 4
  %5 = load ptr, ptr %host_mb, align 8
  %6 = load i64, ptr %msgsz.addr, align 8
  %7 = load i64, ptr %msgtyp.addr, align 8
  %8 = load i32, ptr %msgflg.addr, align 4
  %call7 = call i32 @safe_msgrcv(i32 noundef %4, ptr noundef %5, i64 noundef %6, i64 noundef %7, i32 noundef %8)
  %conv = sext i32 %call7 to i64
  %call8 = call i64 @get_errno(i64 noundef %conv)
  store i64 %call8, ptr %ret, align 8
  %9 = load i64, ptr %ret, align 8
  %cmp9 = icmp sgt i64 %9, 0
  br i1 %cmp9, label %if.then11, label %if.end19

if.then11:                                        ; preds = %if.end6
  %10 = load i64, ptr %msgp.addr, align 8
  %add12 = add i64 %10, 8
  store i64 %add12, ptr %target_mtext_addr, align 8
  %11 = load i64, ptr %target_mtext_addr, align 8
  %12 = load i64, ptr %ret, align 8
  %call13 = call ptr @lock_user(i32 noundef 3, i64 noundef %11, i64 noundef %12, i1 noundef zeroext false)
  store ptr %call13, ptr %target_mtext, align 8
  %13 = load ptr, ptr %target_mtext, align 8
  %tobool14 = icmp ne ptr %13, null
  br i1 %tobool14, label %if.end16, label %if.then15

if.then15:                                        ; preds = %if.then11
  store i64 -14, ptr %ret, align 8
  br label %end

if.end16:                                         ; preds = %if.then11
  %14 = load ptr, ptr %target_mb, align 8
  %mtext = getelementptr inbounds %struct.target_msgbuf, ptr %14, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1 x i8], ptr %mtext, i64 0, i64 0
  %15 = load ptr, ptr %host_mb, align 8
  %mtext17 = getelementptr inbounds %struct.msgbuf, ptr %15, i32 0, i32 1
  %arraydecay18 = getelementptr inbounds [1 x i8], ptr %mtext17, i64 0, i64 0
  %16 = load i64, ptr %ret, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 8 %arraydecay18, i64 %16, i1 false)
  %17 = load ptr, ptr %target_mtext, align 8
  %18 = load i64, ptr %target_mtext_addr, align 8
  %19 = load i64, ptr %ret, align 8
  call void @unlock_user(ptr noundef %17, i64 noundef %18, i64 noundef %19)
  br label %if.end19

if.end19:                                         ; preds = %if.end16, %if.end6
  %20 = load ptr, ptr %host_mb, align 8
  %mtype = getelementptr inbounds %struct.msgbuf, ptr %20, i32 0, i32 0
  %21 = load i64, ptr %mtype, align 8
  %call20 = call i64 @tswapal(i64 noundef %21)
  %22 = load ptr, ptr %target_mb, align 8
  %mtype21 = getelementptr inbounds %struct.target_msgbuf, ptr %22, i32 0, i32 0
  store i64 %call20, ptr %mtype21, align 8
  br label %end

end:                                              ; preds = %if.end19, %if.then15, %if.then5
  %23 = load ptr, ptr %target_mb, align 8
  %tobool22 = icmp ne ptr %23, null
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %end
  %24 = load ptr, ptr %target_mb, align 8
  %25 = load i64, ptr %msgp.addr, align 8
  call void @unlock_user(ptr noundef %24, i64 noundef %25, i64 noundef 16)
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %end
  %26 = load ptr, ptr %host_mb, align 8
  call void @g_free(ptr noundef %26)
  %27 = load i64, ptr %ret, align 8
  store i64 %27, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end24, %if.then1, %if.then
  %28 = load i64, ptr %retval, align 8
  ret i64 %28
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_msgsnd(i32 noundef %msqid, i64 noundef %msgp, i64 noundef %msgsz, i32 noundef %msgflg) #0 {
entry:
  %retval = alloca i64, align 8
  %msqid.addr = alloca i32, align 4
  %msgp.addr = alloca i64, align 8
  %msgsz.addr = alloca i64, align 8
  %msgflg.addr = alloca i32, align 4
  %target_mb = alloca ptr, align 8
  %host_mb = alloca ptr, align 8
  %ret = alloca i64, align 8
  store i32 %msqid, ptr %msqid.addr, align 4
  store i64 %msgp, ptr %msgp.addr, align 8
  store i64 %msgsz, ptr %msgsz.addr, align 8
  store i32 %msgflg, ptr %msgflg.addr, align 4
  store i64 0, ptr %ret, align 8
  %0 = load i64, ptr %msgsz.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -22, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %msgp.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %1, i64 noundef 16, i1 noundef zeroext false)
  store ptr %call, ptr %target_mb, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  %2 = load i64, ptr %msgsz.addr, align 8
  %add = add i64 %2, 8
  %call3 = call noalias ptr @g_try_malloc(i64 noundef %add) #16
  store ptr %call3, ptr %host_mb, align 8
  %3 = load ptr, ptr %host_mb, align 8
  %tobool4 = icmp ne ptr %3, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end2
  %4 = load ptr, ptr %target_mb, align 8
  %5 = load i64, ptr %msgp.addr, align 8
  call void @unlock_user(ptr noundef %4, i64 noundef %5, i64 noundef 0)
  store i64 -12, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end2
  %6 = load ptr, ptr %target_mb, align 8
  %mtype = getelementptr inbounds %struct.target_msgbuf, ptr %6, i32 0, i32 0
  %7 = load i64, ptr %mtype, align 8
  %call7 = call i64 @tswapal(i64 noundef %7)
  %8 = load ptr, ptr %host_mb, align 8
  %mtype8 = getelementptr inbounds %struct.msgbuf, ptr %8, i32 0, i32 0
  store i64 %call7, ptr %mtype8, align 8
  %9 = load ptr, ptr %host_mb, align 8
  %mtext = getelementptr inbounds %struct.msgbuf, ptr %9, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1 x i8], ptr %mtext, i64 0, i64 0
  %10 = load ptr, ptr %target_mb, align 8
  %mtext9 = getelementptr inbounds %struct.target_msgbuf, ptr %10, i32 0, i32 1
  %arraydecay10 = getelementptr inbounds [1 x i8], ptr %mtext9, i64 0, i64 0
  %11 = load i64, ptr %msgsz.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 8 %arraydecay10, i64 %11, i1 false)
  store i64 -38, ptr %ret, align 8
  %12 = load i32, ptr %msqid.addr, align 4
  %13 = load ptr, ptr %host_mb, align 8
  %14 = load i64, ptr %msgsz.addr, align 8
  %15 = load i32, ptr %msgflg.addr, align 4
  %call11 = call i32 @safe_msgsnd(i32 noundef %12, ptr noundef %13, i64 noundef %14, i32 noundef %15)
  %conv = sext i32 %call11 to i64
  %call12 = call i64 @get_errno(i64 noundef %conv)
  store i64 %call12, ptr %ret, align 8
  %16 = load ptr, ptr %host_mb, align 8
  call void @g_free(ptr noundef %16)
  %17 = load ptr, ptr %target_mb, align 8
  %18 = load i64, ptr %msgp.addr, align 8
  call void @unlock_user(ptr noundef %17, i64 noundef %18, i64 noundef 0)
  %19 = load i64, ptr %ret, align 8
  store i64 %19, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then1, %if.then
  %20 = load i64, ptr %retval, align 8
  ret i64 %20
}

; Function Attrs: nounwind
declare i32 @shmget(i32 noundef, i64 noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_shmctl(i32 noundef %shmid, i32 noundef %cmd, i64 noundef %buf) #0 {
entry:
  %retval = alloca i64, align 8
  %shmid.addr = alloca i32, align 4
  %cmd.addr = alloca i32, align 4
  %buf.addr = alloca i64, align 8
  %dsarg = alloca %struct.shmid_ds, align 8
  %shminfo = alloca %struct.shminfo, align 8
  %shm_info = alloca %struct.shm_info, align 8
  %ret = alloca i64, align 8
  store i32 %shmid, ptr %shmid.addr, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %buf, ptr %buf.addr, align 8
  store i64 -22, ptr %ret, align 8
  %0 = load i32, ptr %cmd.addr, align 4
  %and = and i32 %0, 255
  store i32 %and, ptr %cmd.addr, align 4
  %1 = load i32, ptr %cmd.addr, align 4
  switch i32 %1, label %sw.epilog [
    i32 2, label %sw.bb
    i32 1, label %sw.bb
    i32 13, label %sw.bb
    i32 3, label %sw.bb7
    i32 14, label %sw.bb15
    i32 0, label %sw.bb23
    i32 11, label %sw.bb23
    i32 12, label %sw.bb23
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  %2 = load i64, ptr %buf.addr, align 8
  %call = call i64 @target_to_host_shmid_ds(ptr noundef %dsarg, i64 noundef %2)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %sw.bb
  %3 = load i32, ptr %shmid.addr, align 4
  %4 = load i32, ptr %cmd.addr, align 4
  %call1 = call i32 @shmctl(i32 noundef %3, i32 noundef %4, ptr noundef %dsarg) #14
  %conv = sext i32 %call1 to i64
  %call2 = call i64 @get_errno(i64 noundef %conv)
  store i64 %call2, ptr %ret, align 8
  %5 = load i64, ptr %buf.addr, align 8
  %call3 = call i64 @host_to_target_shmid_ds(i64 noundef %5, ptr noundef %dsarg)
  %tobool4 = icmp ne i64 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  %6 = load i32, ptr %shmid.addr, align 4
  %7 = load i32, ptr %cmd.addr, align 4
  %call8 = call i32 @shmctl(i32 noundef %6, i32 noundef %7, ptr noundef %shminfo) #14
  %conv9 = sext i32 %call8 to i64
  %call10 = call i64 @get_errno(i64 noundef %conv9)
  store i64 %call10, ptr %ret, align 8
  %8 = load i64, ptr %buf.addr, align 8
  %call11 = call i64 @host_to_target_shminfo(i64 noundef %8, ptr noundef %shminfo)
  %tobool12 = icmp ne i64 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %sw.bb7
  store i64 -14, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %sw.bb7
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry
  %9 = load i32, ptr %shmid.addr, align 4
  %10 = load i32, ptr %cmd.addr, align 4
  %call16 = call i32 @shmctl(i32 noundef %9, i32 noundef %10, ptr noundef %shm_info) #14
  %conv17 = sext i32 %call16 to i64
  %call18 = call i64 @get_errno(i64 noundef %conv17)
  store i64 %call18, ptr %ret, align 8
  %11 = load i64, ptr %buf.addr, align 8
  %call19 = call i64 @host_to_target_shm_info(i64 noundef %11, ptr noundef %shm_info)
  %tobool20 = icmp ne i64 %call19, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %sw.bb15
  store i64 -14, ptr %retval, align 8
  br label %return

if.end22:                                         ; preds = %sw.bb15
  br label %sw.epilog

sw.bb23:                                          ; preds = %entry, %entry, %entry
  %12 = load i32, ptr %shmid.addr, align 4
  %13 = load i32, ptr %cmd.addr, align 4
  %call24 = call i32 @shmctl(i32 noundef %12, i32 noundef %13, ptr noundef null) #14
  %conv25 = sext i32 %call24 to i64
  %call26 = call i64 @get_errno(i64 noundef %conv25)
  store i64 %call26, ptr %ret, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb23, %if.end22, %if.end14, %if.end6, %entry
  %14 = load i64, ptr %ret, align 8
  store i64 %14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %if.then21, %if.then13, %if.then5, %if.then
  %15 = load i64, ptr %retval, align 8
  ret i64 %15
}

declare i64 @target_shmat(ptr noundef, i32 noundef, i64 noundef, i32 noundef) #3

declare i64 @target_shmdt(i64 noundef) #3

declare i32 @fsync(i32 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @do_fork(ptr noundef %env, i32 noundef %flags, i64 noundef %newsp, i64 noundef %parent_tidptr, i64 noundef %newtls, i64 noundef %child_tidptr) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %newsp.addr = alloca i64, align 8
  %parent_tidptr.addr = alloca i64, align 8
  %newtls.addr = alloca i64, align 8
  %child_tidptr.addr = alloca i64, align 8
  %cpu = alloca ptr, align 8
  %ret = alloca i32, align 4
  %ts = alloca ptr, align 8
  %new_cpu = alloca ptr, align 8
  %new_env = alloca ptr, align 8
  %sigmask = alloca %struct.__sigset_t, align 8
  %parent_ts = alloca ptr, align 8
  %info = alloca %struct.new_thread_info, align 8
  %attr = alloca %union.pthread_attr_t, align 8
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__gaddr108 = alloca i64, align 8
  %__hptr109 = alloca ptr, align 8
  %__ret110 = alloca i64, align 8
  %tmp119 = alloca i64, align 8
  %pid_fd = alloca i32, align 4
  %pid_child = alloca i32, align 4
  %__gaddr143 = alloca i64, align 8
  %__hptr144 = alloca ptr, align 8
  %__ret145 = alloca i64, align 8
  %tmp153 = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i64 %newsp, ptr %newsp.addr, align 8
  store i64 %parent_tidptr, ptr %parent_tidptr.addr, align 8
  store i64 %newtls, ptr %newtls.addr, align 8
  store i64 %child_tidptr, ptr %child_tidptr.addr, align 8
  %0 = load ptr, ptr %env.addr, align 8
  %call = call ptr @env_cpu(ptr noundef %0)
  store ptr %call, ptr %cpu, align 8
  %1 = load i32, ptr %flags.addr, align 4
  %and = and i32 %1, 2143289343
  store i32 %and, ptr %flags.addr, align 4
  %2 = load i32, ptr %flags.addr, align 4
  %and1 = and i32 %2, 16384
  %tobool = icmp ne i32 %and1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, ptr %flags.addr, align 4
  %and2 = and i32 %3, -16641
  store i32 %and2, ptr %flags.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i32, ptr %flags.addr, align 4
  %and3 = and i32 %4, 256
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.else73

if.then5:                                         ; preds = %if.end
  %5 = load ptr, ptr %cpu, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %5, i32 0, i32 39
  %6 = load ptr, ptr %opaque, align 16
  store ptr %6, ptr %parent_ts, align 8
  %7 = load i32, ptr %flags.addr, align 4
  %and6 = and i32 %7, 331520
  %cmp = icmp ne i32 %and6, 331520
  br i1 %cmp, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then5
  %8 = load i32, ptr %flags.addr, align 4
  %and7 = and i32 %8, 2122477568
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %lor.lhs.false, %if.then5
  store i32 -22, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %lor.lhs.false
  %call11 = call noalias ptr @g_malloc0_n(i64 noundef 1, i64 noundef 9200) #17
  store ptr %call11, ptr %ts, align 8
  %9 = load ptr, ptr %ts, align 8
  call void @init_task_state(ptr noundef %9)
  %call12 = call i32 @pthread_mutex_lock(ptr noundef @clone_lock) #14
  %10 = load ptr, ptr %cpu, align 8
  %tcg_cflags = getelementptr inbounds %struct.CPUState, ptr %10, i32 0, i32 53
  %11 = load i32, ptr %tcg_cflags, align 16
  %and13 = and i32 %11, 32768
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.end17, label %if.then15

if.then15:                                        ; preds = %if.end10
  %12 = load ptr, ptr %cpu, align 8
  %tcg_cflags16 = getelementptr inbounds %struct.CPUState, ptr %12, i32 0, i32 53
  %13 = load i32, ptr %tcg_cflags16, align 16
  %or = or i32 %13, 32768
  store i32 %or, ptr %tcg_cflags16, align 16
  %14 = load ptr, ptr %cpu, align 8
  call void @tb_flush(ptr noundef %14)
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end10
  %15 = load ptr, ptr %env.addr, align 8
  %call18 = call ptr @cpu_copy(ptr noundef %15)
  store ptr %call18, ptr %new_env, align 8
  %16 = load ptr, ptr %new_env, align 8
  %17 = load i64, ptr %newsp.addr, align 8
  %18 = load i32, ptr %flags.addr, align 4
  call void @cpu_clone_regs_child(ptr noundef %16, i64 noundef %17, i32 noundef %18)
  %19 = load ptr, ptr %env.addr, align 8
  %20 = load i32, ptr %flags.addr, align 4
  call void @cpu_clone_regs_parent(ptr noundef %19, i32 noundef %20)
  %21 = load ptr, ptr %new_env, align 8
  %call19 = call ptr @env_cpu(ptr noundef %21)
  store ptr %call19, ptr %new_cpu, align 8
  %22 = load ptr, ptr %ts, align 8
  %23 = load ptr, ptr %new_cpu, align 8
  %opaque20 = getelementptr inbounds %struct.CPUState, ptr %23, i32 0, i32 39
  store ptr %22, ptr %opaque20, align 16
  %24 = load ptr, ptr %parent_ts, align 8
  %bprm = getelementptr inbounds %struct.TaskState, ptr %24, i32 0, i32 8
  %25 = load ptr, ptr %bprm, align 8
  %26 = load ptr, ptr %ts, align 8
  %bprm21 = getelementptr inbounds %struct.TaskState, ptr %26, i32 0, i32 8
  store ptr %25, ptr %bprm21, align 8
  %27 = load ptr, ptr %parent_ts, align 8
  %info22 = getelementptr inbounds %struct.TaskState, ptr %27, i32 0, i32 7
  %28 = load ptr, ptr %info22, align 8
  %29 = load ptr, ptr %ts, align 8
  %info23 = getelementptr inbounds %struct.TaskState, ptr %29, i32 0, i32 7
  store ptr %28, ptr %info23, align 8
  %30 = load ptr, ptr %ts, align 8
  %signal_mask = getelementptr inbounds %struct.TaskState, ptr %30, i32 0, i32 11
  %31 = load ptr, ptr %parent_ts, align 8
  %signal_mask24 = getelementptr inbounds %struct.TaskState, ptr %31, i32 0, i32 11
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %signal_mask, ptr align 8 %signal_mask24, i64 128, i1 false)
  %32 = load i32, ptr %flags.addr, align 4
  %and25 = and i32 %32, 2097152
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %if.end17
  %33 = load i64, ptr %child_tidptr.addr, align 8
  %34 = load ptr, ptr %ts, align 8
  %child_tidptr28 = getelementptr inbounds %struct.TaskState, ptr %34, i32 0, i32 2
  store i64 %33, ptr %child_tidptr28, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.then27, %if.end17
  %35 = load i32, ptr %flags.addr, align 4
  %and30 = and i32 %35, 524288
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end29
  %36 = load ptr, ptr %new_env, align 8
  %37 = load i64, ptr %newtls.addr, align 8
  call void @cpu_set_tls(ptr noundef %36, i64 noundef %37)
  br label %if.end33

if.end33:                                         ; preds = %if.then32, %if.end29
  call void @llvm.memset.p0.i64(ptr align 8 %info, i8 0, i64 256, i1 false)
  %mutex = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 1
  %call34 = call i32 @pthread_mutex_init(ptr noundef %mutex, ptr noundef null) #14
  %mutex35 = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 1
  %call36 = call i32 @pthread_mutex_lock(ptr noundef %mutex35) #14
  %cond = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 2
  %call37 = call i32 @pthread_cond_init(ptr noundef %cond, ptr noundef null) #14
  %38 = load ptr, ptr %new_env, align 8
  %env38 = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 0
  store ptr %38, ptr %env38, align 8
  %39 = load i32, ptr %flags.addr, align 4
  %and39 = and i32 %39, 16777216
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then41, label %if.end43

if.then41:                                        ; preds = %if.end33
  %40 = load i64, ptr %child_tidptr.addr, align 8
  %child_tidptr42 = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 5
  store i64 %40, ptr %child_tidptr42, align 8
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %if.end33
  %41 = load i32, ptr %flags.addr, align 4
  %and44 = and i32 %41, 1048576
  %tobool45 = icmp ne i32 %and44, 0
  br i1 %tobool45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %if.end43
  %42 = load i64, ptr %parent_tidptr.addr, align 8
  %parent_tidptr47 = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 6
  store i64 %42, ptr %parent_tidptr47, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %if.end43
  %call49 = call i32 @pthread_attr_init(ptr noundef %attr) #14
  store i32 %call49, ptr %ret, align 4
  %call50 = call i32 @pthread_attr_setstacksize(ptr noundef %attr, i64 noundef 262144) #14
  store i32 %call50, ptr %ret, align 4
  %call51 = call i32 @pthread_attr_setdetachstate(ptr noundef %attr, i32 noundef 1) #14
  store i32 %call51, ptr %ret, align 4
  %call52 = call i32 @sigfillset(ptr noundef %sigmask) #14
  %sigmask53 = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 7
  %call54 = call i32 @sigprocmask(i32 noundef 0, ptr noundef %sigmask, ptr noundef %sigmask53) #14
  %call55 = call i64 @qemu_guest_random_seed_thread_part1()
  %43 = load ptr, ptr %cpu, align 8
  %random_seed = getelementptr inbounds %struct.CPUState, ptr %43, i32 0, i32 23
  store i64 %call55, ptr %random_seed, align 16
  %thread = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 3
  %call56 = call i32 @pthread_create(ptr noundef %thread, ptr noundef %attr, ptr noundef @clone_func, ptr noundef %info) #14
  store i32 %call56, ptr %ret, align 4
  %sigmask57 = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 7
  %call58 = call i32 @sigprocmask(i32 noundef 2, ptr noundef %sigmask57, ptr noundef null) #14
  %call59 = call i32 @pthread_attr_destroy(ptr noundef %attr) #14
  %44 = load i32, ptr %ret, align 4
  %cmp60 = icmp eq i32 %44, 0
  br i1 %cmp60, label %if.then61, label %if.else

if.then61:                                        ; preds = %if.end48
  %cond62 = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 2
  %mutex63 = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 1
  %call64 = call i32 @pthread_cond_wait(ptr noundef %cond62, ptr noundef %mutex63)
  %tid = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 4
  %45 = load i32, ptr %tid, align 8
  store i32 %45, ptr %ret, align 4
  br label %if.end65

if.else:                                          ; preds = %if.end48
  store i32 -1, ptr %ret, align 4
  br label %if.end65

if.end65:                                         ; preds = %if.else, %if.then61
  %mutex66 = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 1
  %call67 = call i32 @pthread_mutex_unlock(ptr noundef %mutex66) #14
  %cond68 = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 2
  %call69 = call i32 @pthread_cond_destroy(ptr noundef %cond68) #14
  %mutex70 = getelementptr inbounds %struct.new_thread_info, ptr %info, i32 0, i32 1
  %call71 = call i32 @pthread_mutex_destroy(ptr noundef %mutex70) #14
  %call72 = call i32 @pthread_mutex_unlock(ptr noundef @clone_lock) #14
  br label %if.end162

if.else73:                                        ; preds = %if.end
  %46 = load i32, ptr %flags.addr, align 4
  %and74 = and i32 %46, 2122837760
  %tobool75 = icmp ne i32 %and74, 0
  br i1 %tobool75, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.else73
  store i32 -22, ptr %retval, align 4
  br label %return

if.end77:                                         ; preds = %if.else73
  %47 = load i32, ptr %flags.addr, align 4
  %and78 = and i32 %47, 255
  %cmp79 = icmp ne i32 %and78, 17
  br i1 %cmp79, label %if.then80, label %if.end81

if.then80:                                        ; preds = %if.end77
  store i32 -22, ptr %retval, align 4
  br label %return

if.end81:                                         ; preds = %if.end77
  %48 = load i32, ptr %flags.addr, align 4
  %and82 = and i32 %48, 4096
  %tobool83 = icmp ne i32 %and82, 0
  br i1 %tobool83, label %land.lhs.true, label %if.end87

land.lhs.true:                                    ; preds = %if.end81
  %49 = load i32, ptr %flags.addr, align 4
  %and84 = and i32 %49, 1048576
  %tobool85 = icmp ne i32 %and84, 0
  br i1 %tobool85, label %if.then86, label %if.end87

if.then86:                                        ; preds = %land.lhs.true
  store i32 -22, ptr %retval, align 4
  br label %return

if.end87:                                         ; preds = %land.lhs.true, %if.end81
  %call88 = call i32 @block_signals()
  %tobool89 = icmp ne i32 %call88, 0
  br i1 %tobool89, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.end87
  store i32 -512, ptr %retval, align 4
  br label %return

if.end91:                                         ; preds = %if.end87
  call void @fork_start()
  %call92 = call i32 @fork() #14
  store i32 %call92, ptr %ret, align 4
  %50 = load i32, ptr %ret, align 4
  %cmp93 = icmp eq i32 %50, 0
  br i1 %cmp93, label %if.then94, label %if.else131

if.then94:                                        ; preds = %if.end91
  %51 = load ptr, ptr %env.addr, align 8
  %52 = load i64, ptr %newsp.addr, align 8
  %53 = load i32, ptr %flags.addr, align 4
  call void @cpu_clone_regs_child(ptr noundef %51, i64 noundef %52, i32 noundef %53)
  call void @fork_end(i32 noundef 1)
  %54 = load i32, ptr %flags.addr, align 4
  %and95 = and i32 %54, 16777216
  %tobool96 = icmp ne i32 %and95, 0
  br i1 %tobool96, label %if.then97, label %if.end104

if.then97:                                        ; preds = %if.then94
  %55 = load i64, ptr %child_tidptr.addr, align 8
  store i64 %55, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %56 = load i64, ptr %__gaddr, align 8
  %call98 = call ptr @lock_user(i32 noundef 3, i64 noundef %56, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call98, ptr %__hptr, align 8
  %tobool99 = icmp ne ptr %call98, null
  br i1 %tobool99, label %if.then100, label %if.else102

if.then100:                                       ; preds = %if.then97
  br label %do.body

do.body:                                          ; preds = %if.then100
  %57 = load ptr, ptr %__hptr, align 8
  %call101 = call i32 @sys_gettid()
  call void @stl_le_p(ptr noundef %57, i32 noundef %call101)
  br label %do.end

do.end:                                           ; preds = %do.body
  %58 = load ptr, ptr %__hptr, align 8
  %59 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %58, i64 noundef %59, i64 noundef 4)
  br label %if.end103

if.else102:                                       ; preds = %if.then97
  store i64 -14, ptr %__ret, align 8
  br label %if.end103

if.end103:                                        ; preds = %if.else102, %do.end
  %60 = load i64, ptr %__ret, align 8
  store i64 %60, ptr %tmp, align 8
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %if.then94
  %61 = load i32, ptr %flags.addr, align 4
  %and105 = and i32 %61, 1048576
  %tobool106 = icmp ne i32 %and105, 0
  br i1 %tobool106, label %if.then107, label %if.end120

if.then107:                                       ; preds = %if.end104
  %62 = load i64, ptr %parent_tidptr.addr, align 8
  store i64 %62, ptr %__gaddr108, align 8
  store i64 0, ptr %__ret110, align 8
  %63 = load i64, ptr %__gaddr108, align 8
  %call111 = call ptr @lock_user(i32 noundef 3, i64 noundef %63, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call111, ptr %__hptr109, align 8
  %tobool112 = icmp ne ptr %call111, null
  br i1 %tobool112, label %if.then113, label %if.else117

if.then113:                                       ; preds = %if.then107
  br label %do.body114

do.body114:                                       ; preds = %if.then113
  %64 = load ptr, ptr %__hptr109, align 8
  %call115 = call i32 @sys_gettid()
  call void @stl_le_p(ptr noundef %64, i32 noundef %call115)
  br label %do.end116

do.end116:                                        ; preds = %do.body114
  %65 = load ptr, ptr %__hptr109, align 8
  %66 = load i64, ptr %__gaddr108, align 8
  call void @unlock_user(ptr noundef %65, i64 noundef %66, i64 noundef 4)
  br label %if.end118

if.else117:                                       ; preds = %if.then107
  store i64 -14, ptr %__ret110, align 8
  br label %if.end118

if.end118:                                        ; preds = %if.else117, %do.end116
  %67 = load i64, ptr %__ret110, align 8
  store i64 %67, ptr %tmp119, align 8
  br label %if.end120

if.end120:                                        ; preds = %if.end118, %if.end104
  %68 = load ptr, ptr %cpu, align 8
  %opaque121 = getelementptr inbounds %struct.CPUState, ptr %68, i32 0, i32 39
  %69 = load ptr, ptr %opaque121, align 16
  store ptr %69, ptr %ts, align 8
  %70 = load i32, ptr %flags.addr, align 4
  %and122 = and i32 %70, 524288
  %tobool123 = icmp ne i32 %and122, 0
  br i1 %tobool123, label %if.then124, label %if.end125

if.then124:                                       ; preds = %if.end120
  %71 = load ptr, ptr %env.addr, align 8
  %72 = load i64, ptr %newtls.addr, align 8
  call void @cpu_set_tls(ptr noundef %71, i64 noundef %72)
  br label %if.end125

if.end125:                                        ; preds = %if.then124, %if.end120
  %73 = load i32, ptr %flags.addr, align 4
  %and126 = and i32 %73, 2097152
  %tobool127 = icmp ne i32 %and126, 0
  br i1 %tobool127, label %if.then128, label %if.end130

if.then128:                                       ; preds = %if.end125
  %74 = load i64, ptr %child_tidptr.addr, align 8
  %75 = load ptr, ptr %ts, align 8
  %child_tidptr129 = getelementptr inbounds %struct.TaskState, ptr %75, i32 0, i32 2
  store i64 %74, ptr %child_tidptr129, align 8
  br label %if.end130

if.end130:                                        ; preds = %if.then128, %if.end125
  br label %if.end155

if.else131:                                       ; preds = %if.end91
  %76 = load ptr, ptr %env.addr, align 8
  %77 = load i32, ptr %flags.addr, align 4
  call void @cpu_clone_regs_parent(ptr noundef %76, i32 noundef %77)
  %78 = load i32, ptr %flags.addr, align 4
  %and132 = and i32 %78, 4096
  %tobool133 = icmp ne i32 %and132, 0
  br i1 %tobool133, label %if.then134, label %if.end154

if.then134:                                       ; preds = %if.else131
  store i32 0, ptr %pid_fd, align 4
  %79 = load i32, ptr %ret, align 4
  store i32 %79, ptr %pid_child, align 4
  %80 = load i32, ptr %pid_child, align 4
  %call135 = call i32 @pidfd_open(i32 noundef %80, i32 noundef 0)
  store i32 %call135, ptr %pid_fd, align 4
  %81 = load i32, ptr %pid_fd, align 4
  %cmp136 = icmp sge i32 %81, 0
  br i1 %cmp136, label %if.then137, label %if.else141

if.then137:                                       ; preds = %if.then134
  %82 = load i32, ptr %pid_fd, align 4
  %83 = load i32, ptr %pid_fd, align 4
  %call138 = call i32 (i32, i32, ...) @fcntl64(i32 noundef %83, i32 noundef 3)
  %or139 = or i32 %call138, 1
  %call140 = call i32 (i32, i32, ...) @fcntl64(i32 noundef %82, i32 noundef 2, i32 noundef %or139)
  br label %if.end142

if.else141:                                       ; preds = %if.then134
  store i32 0, ptr %pid_fd, align 4
  br label %if.end142

if.end142:                                        ; preds = %if.else141, %if.then137
  %84 = load i64, ptr %parent_tidptr.addr, align 8
  store i64 %84, ptr %__gaddr143, align 8
  store i64 0, ptr %__ret145, align 8
  %85 = load i64, ptr %__gaddr143, align 8
  %call146 = call ptr @lock_user(i32 noundef 3, i64 noundef %85, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call146, ptr %__hptr144, align 8
  %tobool147 = icmp ne ptr %call146, null
  br i1 %tobool147, label %if.then148, label %if.else151

if.then148:                                       ; preds = %if.end142
  br label %do.body149

do.body149:                                       ; preds = %if.then148
  %86 = load ptr, ptr %__hptr144, align 8
  %87 = load i32, ptr %pid_fd, align 4
  call void @stl_le_p(ptr noundef %86, i32 noundef %87)
  br label %do.end150

do.end150:                                        ; preds = %do.body149
  %88 = load ptr, ptr %__hptr144, align 8
  %89 = load i64, ptr %__gaddr143, align 8
  call void @unlock_user(ptr noundef %88, i64 noundef %89, i64 noundef 4)
  br label %if.end152

if.else151:                                       ; preds = %if.end142
  store i64 -14, ptr %__ret145, align 8
  br label %if.end152

if.end152:                                        ; preds = %if.else151, %do.end150
  %90 = load i64, ptr %__ret145, align 8
  store i64 %90, ptr %tmp153, align 8
  br label %if.end154

if.end154:                                        ; preds = %if.end152, %if.else131
  call void @fork_end(i32 noundef 0)
  br label %if.end155

if.end155:                                        ; preds = %if.end154, %if.end130
  br label %do.body156

do.body156:                                       ; preds = %if.end155
  %91 = load ptr, ptr %cpu, align 8
  %call157 = call zeroext i1 @cpu_in_exclusive_context(ptr noundef %91)
  br i1 %call157, label %if.else159, label %if.then158

if.then158:                                       ; preds = %do.body156
  br label %if.end160

if.else159:                                       ; preds = %do.body156
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.579, i32 noundef 6706, ptr noundef @__func__.do_fork, ptr noundef @.str.638) #19
  unreachable

if.end160:                                        ; preds = %if.then158
  br label %do.end161

do.end161:                                        ; preds = %if.end160
  br label %if.end162

if.end162:                                        ; preds = %do.end161, %if.end65
  %92 = load i32, ptr %ret, align 4
  store i32 %92, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end162, %if.then90, %if.then86, %if.then80, %if.then76, %if.then9
  %93 = load i32, ptr %retval, align 4
  ret i32 %93
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @exit_group(i32 noundef %error_code) #0 {
entry:
  %error_code.addr = alloca i32, align 4
  store i32 %error_code, ptr %error_code.addr, align 4
  %0 = load i32, ptr %error_code.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 231, i32 noundef %0) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @setdomainname(ptr noundef, i64 noundef) #2

declare i32 @sys_uname(ptr noundef) #3

declare i64 @g_strlcpy(ptr noundef, ptr noundef, i64 noundef) #3

declare ptr @cpu_to_uname_machine(ptr noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_timex(ptr noundef %host_tx, i64 noundef %target_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %host_tx.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %target_tx = alloca ptr, align 8
  store ptr %host_tx, ptr %host_tx.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 208, i1 noundef zeroext true)
  store ptr %call, ptr %target_tx, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_tx, align 8
  %modes = getelementptr inbounds %struct.target_timex, ptr %1, i32 0, i32 0
  %call1 = call i32 @ldl_le_p(ptr noundef %modes)
  %2 = load ptr, ptr %host_tx.addr, align 8
  %modes2 = getelementptr inbounds %struct.timex, ptr %2, i32 0, i32 0
  store i32 %call1, ptr %modes2, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body3

do.body3:                                         ; preds = %do.end
  %3 = load ptr, ptr %target_tx, align 8
  %offset = getelementptr inbounds %struct.target_timex, ptr %3, i32 0, i32 1
  %call4 = call i64 @ldq_le_p(ptr noundef %offset)
  %4 = load ptr, ptr %host_tx.addr, align 8
  %offset5 = getelementptr inbounds %struct.timex, ptr %4, i32 0, i32 1
  store i64 %call4, ptr %offset5, align 8
  br label %do.end6

do.end6:                                          ; preds = %do.body3
  br label %do.body7

do.body7:                                         ; preds = %do.end6
  %5 = load ptr, ptr %target_tx, align 8
  %freq = getelementptr inbounds %struct.target_timex, ptr %5, i32 0, i32 2
  %call8 = call i64 @ldq_le_p(ptr noundef %freq)
  %6 = load ptr, ptr %host_tx.addr, align 8
  %freq9 = getelementptr inbounds %struct.timex, ptr %6, i32 0, i32 2
  store i64 %call8, ptr %freq9, align 8
  br label %do.end10

do.end10:                                         ; preds = %do.body7
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %7 = load ptr, ptr %target_tx, align 8
  %maxerror = getelementptr inbounds %struct.target_timex, ptr %7, i32 0, i32 3
  %call12 = call i64 @ldq_le_p(ptr noundef %maxerror)
  %8 = load ptr, ptr %host_tx.addr, align 8
  %maxerror13 = getelementptr inbounds %struct.timex, ptr %8, i32 0, i32 3
  store i64 %call12, ptr %maxerror13, align 8
  br label %do.end14

do.end14:                                         ; preds = %do.body11
  br label %do.body15

do.body15:                                        ; preds = %do.end14
  %9 = load ptr, ptr %target_tx, align 8
  %esterror = getelementptr inbounds %struct.target_timex, ptr %9, i32 0, i32 4
  %call16 = call i64 @ldq_le_p(ptr noundef %esterror)
  %10 = load ptr, ptr %host_tx.addr, align 8
  %esterror17 = getelementptr inbounds %struct.timex, ptr %10, i32 0, i32 4
  store i64 %call16, ptr %esterror17, align 8
  br label %do.end18

do.end18:                                         ; preds = %do.body15
  br label %do.body19

do.body19:                                        ; preds = %do.end18
  %11 = load ptr, ptr %target_tx, align 8
  %status = getelementptr inbounds %struct.target_timex, ptr %11, i32 0, i32 5
  %call20 = call i32 @ldl_le_p(ptr noundef %status)
  %12 = load ptr, ptr %host_tx.addr, align 8
  %status21 = getelementptr inbounds %struct.timex, ptr %12, i32 0, i32 5
  store i32 %call20, ptr %status21, align 8
  br label %do.end22

do.end22:                                         ; preds = %do.body19
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  %13 = load ptr, ptr %target_tx, align 8
  %constant = getelementptr inbounds %struct.target_timex, ptr %13, i32 0, i32 6
  %call24 = call i64 @ldq_le_p(ptr noundef %constant)
  %14 = load ptr, ptr %host_tx.addr, align 8
  %constant25 = getelementptr inbounds %struct.timex, ptr %14, i32 0, i32 6
  store i64 %call24, ptr %constant25, align 8
  br label %do.end26

do.end26:                                         ; preds = %do.body23
  br label %do.body27

do.body27:                                        ; preds = %do.end26
  %15 = load ptr, ptr %target_tx, align 8
  %precision = getelementptr inbounds %struct.target_timex, ptr %15, i32 0, i32 7
  %call28 = call i64 @ldq_le_p(ptr noundef %precision)
  %16 = load ptr, ptr %host_tx.addr, align 8
  %precision29 = getelementptr inbounds %struct.timex, ptr %16, i32 0, i32 7
  store i64 %call28, ptr %precision29, align 8
  br label %do.end30

do.end30:                                         ; preds = %do.body27
  br label %do.body31

do.body31:                                        ; preds = %do.end30
  %17 = load ptr, ptr %target_tx, align 8
  %tolerance = getelementptr inbounds %struct.target_timex, ptr %17, i32 0, i32 8
  %call32 = call i64 @ldq_le_p(ptr noundef %tolerance)
  %18 = load ptr, ptr %host_tx.addr, align 8
  %tolerance33 = getelementptr inbounds %struct.timex, ptr %18, i32 0, i32 8
  store i64 %call32, ptr %tolerance33, align 8
  br label %do.end34

do.end34:                                         ; preds = %do.body31
  br label %do.body35

do.body35:                                        ; preds = %do.end34
  %19 = load ptr, ptr %target_tx, align 8
  %time = getelementptr inbounds %struct.target_timex, ptr %19, i32 0, i32 9
  %tv_sec = getelementptr inbounds %struct.target_timeval, ptr %time, i32 0, i32 0
  %call36 = call i64 @ldq_le_p(ptr noundef %tv_sec)
  %20 = load ptr, ptr %host_tx.addr, align 8
  %time37 = getelementptr inbounds %struct.timex, ptr %20, i32 0, i32 9
  %tv_sec38 = getelementptr inbounds %struct.timeval, ptr %time37, i32 0, i32 0
  store i64 %call36, ptr %tv_sec38, align 8
  br label %do.end39

do.end39:                                         ; preds = %do.body35
  br label %do.body40

do.body40:                                        ; preds = %do.end39
  %21 = load ptr, ptr %target_tx, align 8
  %time41 = getelementptr inbounds %struct.target_timex, ptr %21, i32 0, i32 9
  %tv_usec = getelementptr inbounds %struct.target_timeval, ptr %time41, i32 0, i32 1
  %call42 = call i64 @ldq_le_p(ptr noundef %tv_usec)
  %22 = load ptr, ptr %host_tx.addr, align 8
  %time43 = getelementptr inbounds %struct.timex, ptr %22, i32 0, i32 9
  %tv_usec44 = getelementptr inbounds %struct.timeval, ptr %time43, i32 0, i32 1
  store i64 %call42, ptr %tv_usec44, align 8
  br label %do.end45

do.end45:                                         ; preds = %do.body40
  br label %do.body46

do.body46:                                        ; preds = %do.end45
  %23 = load ptr, ptr %target_tx, align 8
  %tick = getelementptr inbounds %struct.target_timex, ptr %23, i32 0, i32 10
  %call47 = call i64 @ldq_le_p(ptr noundef %tick)
  %24 = load ptr, ptr %host_tx.addr, align 8
  %tick48 = getelementptr inbounds %struct.timex, ptr %24, i32 0, i32 10
  store i64 %call47, ptr %tick48, align 8
  br label %do.end49

do.end49:                                         ; preds = %do.body46
  br label %do.body50

do.body50:                                        ; preds = %do.end49
  %25 = load ptr, ptr %target_tx, align 8
  %ppsfreq = getelementptr inbounds %struct.target_timex, ptr %25, i32 0, i32 11
  %call51 = call i64 @ldq_le_p(ptr noundef %ppsfreq)
  %26 = load ptr, ptr %host_tx.addr, align 8
  %ppsfreq52 = getelementptr inbounds %struct.timex, ptr %26, i32 0, i32 11
  store i64 %call51, ptr %ppsfreq52, align 8
  br label %do.end53

do.end53:                                         ; preds = %do.body50
  br label %do.body54

do.body54:                                        ; preds = %do.end53
  %27 = load ptr, ptr %target_tx, align 8
  %jitter = getelementptr inbounds %struct.target_timex, ptr %27, i32 0, i32 12
  %call55 = call i64 @ldq_le_p(ptr noundef %jitter)
  %28 = load ptr, ptr %host_tx.addr, align 8
  %jitter56 = getelementptr inbounds %struct.timex, ptr %28, i32 0, i32 12
  store i64 %call55, ptr %jitter56, align 8
  br label %do.end57

do.end57:                                         ; preds = %do.body54
  br label %do.body58

do.body58:                                        ; preds = %do.end57
  %29 = load ptr, ptr %target_tx, align 8
  %shift = getelementptr inbounds %struct.target_timex, ptr %29, i32 0, i32 13
  %call59 = call i32 @ldl_le_p(ptr noundef %shift)
  %30 = load ptr, ptr %host_tx.addr, align 8
  %shift60 = getelementptr inbounds %struct.timex, ptr %30, i32 0, i32 13
  store i32 %call59, ptr %shift60, align 8
  br label %do.end61

do.end61:                                         ; preds = %do.body58
  br label %do.body62

do.body62:                                        ; preds = %do.end61
  %31 = load ptr, ptr %target_tx, align 8
  %stabil = getelementptr inbounds %struct.target_timex, ptr %31, i32 0, i32 14
  %call63 = call i64 @ldq_le_p(ptr noundef %stabil)
  %32 = load ptr, ptr %host_tx.addr, align 8
  %stabil64 = getelementptr inbounds %struct.timex, ptr %32, i32 0, i32 14
  store i64 %call63, ptr %stabil64, align 8
  br label %do.end65

do.end65:                                         ; preds = %do.body62
  br label %do.body66

do.body66:                                        ; preds = %do.end65
  %33 = load ptr, ptr %target_tx, align 8
  %jitcnt = getelementptr inbounds %struct.target_timex, ptr %33, i32 0, i32 15
  %call67 = call i64 @ldq_le_p(ptr noundef %jitcnt)
  %34 = load ptr, ptr %host_tx.addr, align 8
  %jitcnt68 = getelementptr inbounds %struct.timex, ptr %34, i32 0, i32 15
  store i64 %call67, ptr %jitcnt68, align 8
  br label %do.end69

do.end69:                                         ; preds = %do.body66
  br label %do.body70

do.body70:                                        ; preds = %do.end69
  %35 = load ptr, ptr %target_tx, align 8
  %calcnt = getelementptr inbounds %struct.target_timex, ptr %35, i32 0, i32 16
  %call71 = call i64 @ldq_le_p(ptr noundef %calcnt)
  %36 = load ptr, ptr %host_tx.addr, align 8
  %calcnt72 = getelementptr inbounds %struct.timex, ptr %36, i32 0, i32 16
  store i64 %call71, ptr %calcnt72, align 8
  br label %do.end73

do.end73:                                         ; preds = %do.body70
  br label %do.body74

do.body74:                                        ; preds = %do.end73
  %37 = load ptr, ptr %target_tx, align 8
  %errcnt = getelementptr inbounds %struct.target_timex, ptr %37, i32 0, i32 17
  %call75 = call i64 @ldq_le_p(ptr noundef %errcnt)
  %38 = load ptr, ptr %host_tx.addr, align 8
  %errcnt76 = getelementptr inbounds %struct.timex, ptr %38, i32 0, i32 17
  store i64 %call75, ptr %errcnt76, align 8
  br label %do.end77

do.end77:                                         ; preds = %do.body74
  br label %do.body78

do.body78:                                        ; preds = %do.end77
  %39 = load ptr, ptr %target_tx, align 8
  %stbcnt = getelementptr inbounds %struct.target_timex, ptr %39, i32 0, i32 18
  %call79 = call i64 @ldq_le_p(ptr noundef %stbcnt)
  %40 = load ptr, ptr %host_tx.addr, align 8
  %stbcnt80 = getelementptr inbounds %struct.timex, ptr %40, i32 0, i32 18
  store i64 %call79, ptr %stbcnt80, align 8
  br label %do.end81

do.end81:                                         ; preds = %do.body78
  br label %do.body82

do.body82:                                        ; preds = %do.end81
  %41 = load ptr, ptr %target_tx, align 8
  %tai = getelementptr inbounds %struct.target_timex, ptr %41, i32 0, i32 19
  %call83 = call i32 @ldl_le_p(ptr noundef %tai)
  %42 = load ptr, ptr %host_tx.addr, align 8
  %tai84 = getelementptr inbounds %struct.timex, ptr %42, i32 0, i32 19
  store i32 %call83, ptr %tai84, align 8
  br label %do.end85

do.end85:                                         ; preds = %do.body82
  %43 = load ptr, ptr %target_tx, align 8
  %44 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %43, i64 noundef %44, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end85, %if.then
  %45 = load i64, ptr %retval, align 8
  ret i64 %45
}

; Function Attrs: nounwind
declare i32 @adjtimex(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_timex(i64 noundef %target_addr, ptr noundef %host_tx) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %host_tx.addr = alloca ptr, align 8
  %target_tx = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_tx, ptr %host_tx.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 208, i1 noundef zeroext false)
  store ptr %call, ptr %target_tx, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_tx, align 8
  %modes = getelementptr inbounds %struct.target_timex, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %host_tx.addr, align 8
  %modes1 = getelementptr inbounds %struct.timex, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %modes1, align 8
  call void @stl_le_p(ptr noundef %modes, i32 noundef %3)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %4 = load ptr, ptr %target_tx, align 8
  %offset = getelementptr inbounds %struct.target_timex, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %host_tx.addr, align 8
  %offset3 = getelementptr inbounds %struct.timex, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %offset3, align 8
  call void @stq_le_p(ptr noundef %offset, i64 noundef %6)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  br label %do.body5

do.body5:                                         ; preds = %do.end4
  %7 = load ptr, ptr %target_tx, align 8
  %freq = getelementptr inbounds %struct.target_timex, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %host_tx.addr, align 8
  %freq6 = getelementptr inbounds %struct.timex, ptr %8, i32 0, i32 2
  %9 = load i64, ptr %freq6, align 8
  call void @stq_le_p(ptr noundef %freq, i64 noundef %9)
  br label %do.end7

do.end7:                                          ; preds = %do.body5
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %10 = load ptr, ptr %target_tx, align 8
  %maxerror = getelementptr inbounds %struct.target_timex, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %host_tx.addr, align 8
  %maxerror9 = getelementptr inbounds %struct.timex, ptr %11, i32 0, i32 3
  %12 = load i64, ptr %maxerror9, align 8
  call void @stq_le_p(ptr noundef %maxerror, i64 noundef %12)
  br label %do.end10

do.end10:                                         ; preds = %do.body8
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %13 = load ptr, ptr %target_tx, align 8
  %esterror = getelementptr inbounds %struct.target_timex, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %host_tx.addr, align 8
  %esterror12 = getelementptr inbounds %struct.timex, ptr %14, i32 0, i32 4
  %15 = load i64, ptr %esterror12, align 8
  call void @stq_le_p(ptr noundef %esterror, i64 noundef %15)
  br label %do.end13

do.end13:                                         ; preds = %do.body11
  br label %do.body14

do.body14:                                        ; preds = %do.end13
  %16 = load ptr, ptr %target_tx, align 8
  %status = getelementptr inbounds %struct.target_timex, ptr %16, i32 0, i32 5
  %17 = load ptr, ptr %host_tx.addr, align 8
  %status15 = getelementptr inbounds %struct.timex, ptr %17, i32 0, i32 5
  %18 = load i32, ptr %status15, align 8
  call void @stl_le_p(ptr noundef %status, i32 noundef %18)
  br label %do.end16

do.end16:                                         ; preds = %do.body14
  br label %do.body17

do.body17:                                        ; preds = %do.end16
  %19 = load ptr, ptr %target_tx, align 8
  %constant = getelementptr inbounds %struct.target_timex, ptr %19, i32 0, i32 6
  %20 = load ptr, ptr %host_tx.addr, align 8
  %constant18 = getelementptr inbounds %struct.timex, ptr %20, i32 0, i32 6
  %21 = load i64, ptr %constant18, align 8
  call void @stq_le_p(ptr noundef %constant, i64 noundef %21)
  br label %do.end19

do.end19:                                         ; preds = %do.body17
  br label %do.body20

do.body20:                                        ; preds = %do.end19
  %22 = load ptr, ptr %target_tx, align 8
  %precision = getelementptr inbounds %struct.target_timex, ptr %22, i32 0, i32 7
  %23 = load ptr, ptr %host_tx.addr, align 8
  %precision21 = getelementptr inbounds %struct.timex, ptr %23, i32 0, i32 7
  %24 = load i64, ptr %precision21, align 8
  call void @stq_le_p(ptr noundef %precision, i64 noundef %24)
  br label %do.end22

do.end22:                                         ; preds = %do.body20
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  %25 = load ptr, ptr %target_tx, align 8
  %tolerance = getelementptr inbounds %struct.target_timex, ptr %25, i32 0, i32 8
  %26 = load ptr, ptr %host_tx.addr, align 8
  %tolerance24 = getelementptr inbounds %struct.timex, ptr %26, i32 0, i32 8
  %27 = load i64, ptr %tolerance24, align 8
  call void @stq_le_p(ptr noundef %tolerance, i64 noundef %27)
  br label %do.end25

do.end25:                                         ; preds = %do.body23
  br label %do.body26

do.body26:                                        ; preds = %do.end25
  %28 = load ptr, ptr %target_tx, align 8
  %time = getelementptr inbounds %struct.target_timex, ptr %28, i32 0, i32 9
  %tv_sec = getelementptr inbounds %struct.target_timeval, ptr %time, i32 0, i32 0
  %29 = load ptr, ptr %host_tx.addr, align 8
  %time27 = getelementptr inbounds %struct.timex, ptr %29, i32 0, i32 9
  %tv_sec28 = getelementptr inbounds %struct.timeval, ptr %time27, i32 0, i32 0
  %30 = load i64, ptr %tv_sec28, align 8
  call void @stq_le_p(ptr noundef %tv_sec, i64 noundef %30)
  br label %do.end29

do.end29:                                         ; preds = %do.body26
  br label %do.body30

do.body30:                                        ; preds = %do.end29
  %31 = load ptr, ptr %target_tx, align 8
  %time31 = getelementptr inbounds %struct.target_timex, ptr %31, i32 0, i32 9
  %tv_usec = getelementptr inbounds %struct.target_timeval, ptr %time31, i32 0, i32 1
  %32 = load ptr, ptr %host_tx.addr, align 8
  %time32 = getelementptr inbounds %struct.timex, ptr %32, i32 0, i32 9
  %tv_usec33 = getelementptr inbounds %struct.timeval, ptr %time32, i32 0, i32 1
  %33 = load i64, ptr %tv_usec33, align 8
  call void @stq_le_p(ptr noundef %tv_usec, i64 noundef %33)
  br label %do.end34

do.end34:                                         ; preds = %do.body30
  br label %do.body35

do.body35:                                        ; preds = %do.end34
  %34 = load ptr, ptr %target_tx, align 8
  %tick = getelementptr inbounds %struct.target_timex, ptr %34, i32 0, i32 10
  %35 = load ptr, ptr %host_tx.addr, align 8
  %tick36 = getelementptr inbounds %struct.timex, ptr %35, i32 0, i32 10
  %36 = load i64, ptr %tick36, align 8
  call void @stq_le_p(ptr noundef %tick, i64 noundef %36)
  br label %do.end37

do.end37:                                         ; preds = %do.body35
  br label %do.body38

do.body38:                                        ; preds = %do.end37
  %37 = load ptr, ptr %target_tx, align 8
  %ppsfreq = getelementptr inbounds %struct.target_timex, ptr %37, i32 0, i32 11
  %38 = load ptr, ptr %host_tx.addr, align 8
  %ppsfreq39 = getelementptr inbounds %struct.timex, ptr %38, i32 0, i32 11
  %39 = load i64, ptr %ppsfreq39, align 8
  call void @stq_le_p(ptr noundef %ppsfreq, i64 noundef %39)
  br label %do.end40

do.end40:                                         ; preds = %do.body38
  br label %do.body41

do.body41:                                        ; preds = %do.end40
  %40 = load ptr, ptr %target_tx, align 8
  %jitter = getelementptr inbounds %struct.target_timex, ptr %40, i32 0, i32 12
  %41 = load ptr, ptr %host_tx.addr, align 8
  %jitter42 = getelementptr inbounds %struct.timex, ptr %41, i32 0, i32 12
  %42 = load i64, ptr %jitter42, align 8
  call void @stq_le_p(ptr noundef %jitter, i64 noundef %42)
  br label %do.end43

do.end43:                                         ; preds = %do.body41
  br label %do.body44

do.body44:                                        ; preds = %do.end43
  %43 = load ptr, ptr %target_tx, align 8
  %shift = getelementptr inbounds %struct.target_timex, ptr %43, i32 0, i32 13
  %44 = load ptr, ptr %host_tx.addr, align 8
  %shift45 = getelementptr inbounds %struct.timex, ptr %44, i32 0, i32 13
  %45 = load i32, ptr %shift45, align 8
  call void @stl_le_p(ptr noundef %shift, i32 noundef %45)
  br label %do.end46

do.end46:                                         ; preds = %do.body44
  br label %do.body47

do.body47:                                        ; preds = %do.end46
  %46 = load ptr, ptr %target_tx, align 8
  %stabil = getelementptr inbounds %struct.target_timex, ptr %46, i32 0, i32 14
  %47 = load ptr, ptr %host_tx.addr, align 8
  %stabil48 = getelementptr inbounds %struct.timex, ptr %47, i32 0, i32 14
  %48 = load i64, ptr %stabil48, align 8
  call void @stq_le_p(ptr noundef %stabil, i64 noundef %48)
  br label %do.end49

do.end49:                                         ; preds = %do.body47
  br label %do.body50

do.body50:                                        ; preds = %do.end49
  %49 = load ptr, ptr %target_tx, align 8
  %jitcnt = getelementptr inbounds %struct.target_timex, ptr %49, i32 0, i32 15
  %50 = load ptr, ptr %host_tx.addr, align 8
  %jitcnt51 = getelementptr inbounds %struct.timex, ptr %50, i32 0, i32 15
  %51 = load i64, ptr %jitcnt51, align 8
  call void @stq_le_p(ptr noundef %jitcnt, i64 noundef %51)
  br label %do.end52

do.end52:                                         ; preds = %do.body50
  br label %do.body53

do.body53:                                        ; preds = %do.end52
  %52 = load ptr, ptr %target_tx, align 8
  %calcnt = getelementptr inbounds %struct.target_timex, ptr %52, i32 0, i32 16
  %53 = load ptr, ptr %host_tx.addr, align 8
  %calcnt54 = getelementptr inbounds %struct.timex, ptr %53, i32 0, i32 16
  %54 = load i64, ptr %calcnt54, align 8
  call void @stq_le_p(ptr noundef %calcnt, i64 noundef %54)
  br label %do.end55

do.end55:                                         ; preds = %do.body53
  br label %do.body56

do.body56:                                        ; preds = %do.end55
  %55 = load ptr, ptr %target_tx, align 8
  %errcnt = getelementptr inbounds %struct.target_timex, ptr %55, i32 0, i32 17
  %56 = load ptr, ptr %host_tx.addr, align 8
  %errcnt57 = getelementptr inbounds %struct.timex, ptr %56, i32 0, i32 17
  %57 = load i64, ptr %errcnt57, align 8
  call void @stq_le_p(ptr noundef %errcnt, i64 noundef %57)
  br label %do.end58

do.end58:                                         ; preds = %do.body56
  br label %do.body59

do.body59:                                        ; preds = %do.end58
  %58 = load ptr, ptr %target_tx, align 8
  %stbcnt = getelementptr inbounds %struct.target_timex, ptr %58, i32 0, i32 18
  %59 = load ptr, ptr %host_tx.addr, align 8
  %stbcnt60 = getelementptr inbounds %struct.timex, ptr %59, i32 0, i32 18
  %60 = load i64, ptr %stbcnt60, align 8
  call void @stq_le_p(ptr noundef %stbcnt, i64 noundef %60)
  br label %do.end61

do.end61:                                         ; preds = %do.body59
  br label %do.body62

do.body62:                                        ; preds = %do.end61
  %61 = load ptr, ptr %target_tx, align 8
  %tai = getelementptr inbounds %struct.target_timex, ptr %61, i32 0, i32 19
  %62 = load ptr, ptr %host_tx.addr, align 8
  %tai63 = getelementptr inbounds %struct.timex, ptr %62, i32 0, i32 19
  %63 = load i32, ptr %tai63, align 8
  call void @stl_le_p(ptr noundef %tai, i32 noundef %63)
  br label %do.end64

do.end64:                                         ; preds = %do.body62
  %64 = load ptr, ptr %target_tx, align 8
  %65 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %64, i64 noundef %65, i64 noundef 208)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end64, %if.then
  %66 = load i64, ptr %retval, align 8
  ret i64 %66
}

; Function Attrs: nounwind
declare i32 @clock_adjtime(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @getpgid(i32 noundef) #2

; Function Attrs: nounwind
declare i32 @fchdir(i32 noundef) #2

; Function Attrs: nounwind
declare i32 @personality(i64 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @do_getdents64(i64 noundef %dirfd, i64 noundef %arg2, i64 noundef %count) #0 {
entry:
  %retval = alloca i32, align 4
  %dirfd.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %hdirp = alloca ptr, align 8
  %tdirp = alloca ptr, align 8
  %hlen = alloca i32, align 4
  %hoff = alloca i32, align 4
  %toff = alloca i32, align 4
  %hreclen = alloca i32, align 4
  %treclen = alloca i32, align 4
  %prev_diroff = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %hde = alloca ptr, align 8
  %tde = alloca ptr, align 8
  %namelen = alloca i32, align 4
  store i64 %dirfd, ptr %dirfd.addr, align 8
  store i64 %arg2, ptr %arg2.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store ptr null, ptr %hdirp, align 8
  store i64 0, ptr %prev_diroff, align 8
  %0 = load i64, ptr %count.addr, align 8
  %call = call noalias ptr @g_try_malloc(i64 noundef %0) #16
  store ptr %call, ptr %hdirp, align 8
  %1 = load ptr, ptr %hdirp, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %dirfd.addr, align 8
  %conv = trunc i64 %2 to i32
  %3 = load ptr, ptr %hdirp, align 8
  %4 = load i64, ptr %count.addr, align 8
  %conv1 = trunc i64 %4 to i32
  %call2 = call i32 @sys_getdents64(i32 noundef %conv, ptr noundef %3, i32 noundef %conv1)
  %conv3 = sext i32 %call2 to i64
  %call4 = call i64 @get_errno(i64 noundef %conv3)
  %conv5 = trunc i64 %call4 to i32
  store i32 %conv5, ptr %hlen, align 4
  %5 = load i32, ptr %hlen, align 4
  %conv6 = sext i32 %5 to i64
  %call7 = call i32 @is_error(i64 noundef %conv6)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %6 = load i32, ptr %hlen, align 4
  store i32 %6, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end10:                                         ; preds = %if.end
  %7 = load i64, ptr %arg2.addr, align 8
  %8 = load i64, ptr %count.addr, align 8
  %call11 = call ptr @lock_user(i32 noundef 3, i64 noundef %7, i64 noundef %8, i1 noundef zeroext false)
  store ptr %call11, ptr %tdirp, align 8
  %9 = load ptr, ptr %tdirp, align 8
  %tobool12 = icmp ne ptr %9, null
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end10
  store i32 -14, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end14:                                         ; preds = %if.end10
  store i32 0, ptr %toff, align 4
  store i32 0, ptr %hoff, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end14
  %10 = load i32, ptr %hoff, align 4
  %11 = load i32, ptr %hlen, align 4
  %cmp = icmp slt i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load ptr, ptr %hdirp, align 8
  %13 = load i32, ptr %hoff, align 4
  %idx.ext = sext i32 %13 to i64
  %add.ptr = getelementptr i8, ptr %12, i64 %idx.ext
  store ptr %add.ptr, ptr %hde, align 8
  %14 = load ptr, ptr %tdirp, align 8
  %15 = load i32, ptr %toff, align 4
  %idx.ext16 = sext i32 %15 to i64
  %add.ptr17 = getelementptr i8, ptr %14, i64 %idx.ext16
  store ptr %add.ptr17, ptr %tde, align 8
  %16 = load ptr, ptr %hde, align 8
  %d_name = getelementptr inbounds %struct.linux_dirent64, ptr %16, i32 0, i32 4
  %arraydecay = getelementptr inbounds [0 x i8], ptr %d_name, i64 0, i64 0
  %call18 = call i64 @strlen(ptr noundef %arraydecay) #18
  %add = add i64 %call18, 1
  %conv19 = trunc i64 %add to i32
  store i32 %conv19, ptr %namelen, align 4
  %17 = load ptr, ptr %hde, align 8
  %d_reclen = getelementptr inbounds %struct.linux_dirent64, ptr %17, i32 0, i32 2
  %18 = load i16, ptr %d_reclen, align 8
  %conv20 = zext i16 %18 to i32
  store i32 %conv20, ptr %hreclen, align 4
  %19 = load i32, ptr %namelen, align 4
  %conv21 = sext i32 %19 to i64
  %add22 = add i64 19, %conv21
  %conv23 = trunc i64 %add22 to i32
  store i32 %conv23, ptr %treclen, align 4
  %20 = load i32, ptr %treclen, align 4
  %conv24 = sext i32 %20 to i64
  %add25 = add i64 %conv24, 8
  %sub = sub i64 %add25, 1
  %div = udiv i64 %sub, 8
  %mul = mul i64 %div, 8
  %conv26 = trunc i64 %mul to i32
  store i32 %conv26, ptr %treclen, align 4
  %21 = load i32, ptr %toff, align 4
  %22 = load i32, ptr %treclen, align 4
  %add27 = add i32 %21, %22
  %conv28 = sext i32 %add27 to i64
  %23 = load i64, ptr %count.addr, align 8
  %cmp29 = icmp sgt i64 %conv28, %23
  br i1 %cmp29, label %if.then31, label %if.end38

if.then31:                                        ; preds = %for.body
  %24 = load i32, ptr %toff, align 4
  %cmp32 = icmp eq i32 %24, 0
  br i1 %cmp32, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.then31
  store i32 -22, ptr %toff, align 4
  br label %for.end

if.end35:                                         ; preds = %if.then31
  %25 = load i64, ptr %dirfd.addr, align 8
  %conv36 = trunc i64 %25 to i32
  %26 = load i64, ptr %prev_diroff, align 8
  %call37 = call i64 @lseek64(i32 noundef %conv36, i64 noundef %26, i32 noundef 0) #14
  br label %for.end

if.end38:                                         ; preds = %for.body
  %27 = load ptr, ptr %hde, align 8
  %d_off = getelementptr inbounds %struct.linux_dirent64, ptr %27, i32 0, i32 1
  %28 = load i64, ptr %d_off, align 8
  store i64 %28, ptr %prev_diroff, align 8
  %29 = load ptr, ptr %hde, align 8
  %d_ino = getelementptr inbounds %struct.linux_dirent64, ptr %29, i32 0, i32 0
  %30 = load i64, ptr %d_ino, align 8
  %call39 = call i64 @tswap64(i64 noundef %30)
  %31 = load ptr, ptr %tde, align 8
  %d_ino40 = getelementptr inbounds %struct.target_dirent64, ptr %31, i32 0, i32 0
  store i64 %call39, ptr %d_ino40, align 8
  %32 = load ptr, ptr %hde, align 8
  %d_off41 = getelementptr inbounds %struct.linux_dirent64, ptr %32, i32 0, i32 1
  %33 = load i64, ptr %d_off41, align 8
  %call42 = call i64 @tswap64(i64 noundef %33)
  %34 = load ptr, ptr %tde, align 8
  %d_off43 = getelementptr inbounds %struct.target_dirent64, ptr %34, i32 0, i32 1
  store i64 %call42, ptr %d_off43, align 8
  %35 = load i32, ptr %treclen, align 4
  %conv44 = trunc i32 %35 to i16
  %call45 = call zeroext i16 @tswap16(i16 noundef zeroext %conv44)
  %36 = load ptr, ptr %tde, align 8
  %d_reclen46 = getelementptr inbounds %struct.target_dirent64, ptr %36, i32 0, i32 2
  store i16 %call45, ptr %d_reclen46, align 8
  %37 = load ptr, ptr %hde, align 8
  %d_type = getelementptr inbounds %struct.linux_dirent64, ptr %37, i32 0, i32 3
  %38 = load i8, ptr %d_type, align 2
  %39 = load ptr, ptr %tde, align 8
  %d_type47 = getelementptr inbounds %struct.target_dirent64, ptr %39, i32 0, i32 3
  store i8 %38, ptr %d_type47, align 2
  %40 = load ptr, ptr %tde, align 8
  %d_name48 = getelementptr inbounds %struct.target_dirent64, ptr %40, i32 0, i32 4
  %arraydecay49 = getelementptr inbounds [0 x i8], ptr %d_name48, i64 0, i64 0
  %41 = load ptr, ptr %hde, align 8
  %d_name50 = getelementptr inbounds %struct.linux_dirent64, ptr %41, i32 0, i32 4
  %arraydecay51 = getelementptr inbounds [0 x i8], ptr %d_name50, i64 0, i64 0
  %42 = load i32, ptr %namelen, align 4
  %conv52 = sext i32 %42 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %arraydecay49, ptr align 1 %arraydecay51, i64 %conv52, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end38
  %43 = load i32, ptr %hreclen, align 4
  %44 = load i32, ptr %hoff, align 4
  %add53 = add i32 %44, %43
  store i32 %add53, ptr %hoff, align 4
  %45 = load i32, ptr %treclen, align 4
  %46 = load i32, ptr %toff, align 4
  %add54 = add i32 %46, %45
  store i32 %add54, ptr %toff, align 4
  br label %for.cond, !llvm.loop !36

for.end:                                          ; preds = %if.end35, %if.then34, %for.cond
  %47 = load ptr, ptr %tdirp, align 8
  %48 = load i64, ptr %arg2.addr, align 8
  %49 = load i32, ptr %toff, align 4
  %conv55 = sext i32 %49 to i64
  call void @unlock_user(ptr noundef %47, i64 noundef %48, i64 noundef %conv55)
  %50 = load i32, ptr %toff, align 4
  store i32 %50, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then9, %if.then
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %hdirp)
  %51 = load i32, ptr %retval, align 4
  ret i32 %51
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_ppoll(i64 noundef %arg1, i64 noundef %arg2, i64 noundef %arg3, i64 noundef %arg4, i64 noundef %arg5, i1 noundef zeroext %ppoll, i1 noundef zeroext %time64) #0 {
entry:
  %retval = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  %arg4.addr = alloca i64, align 8
  %arg5.addr = alloca i64, align 8
  %ppoll.addr = alloca i8, align 1
  %time64.addr = alloca i8, align 1
  %target_pfd = alloca ptr, align 8
  %nfds = alloca i32, align 4
  %pfd = alloca ptr, align 8
  %i = alloca i32, align 4
  %ret = alloca i64, align 8
  %_timeout_ts = alloca %struct.timespec, align 8
  %timeout_ts = alloca ptr, align 8
  %set = alloca ptr, align 8
  %ts = alloca %struct.timespec, align 8
  %pts = alloca ptr, align 8
  store i64 %arg1, ptr %arg1.addr, align 8
  store i64 %arg2, ptr %arg2.addr, align 8
  store i64 %arg3, ptr %arg3.addr, align 8
  store i64 %arg4, ptr %arg4.addr, align 8
  store i64 %arg5, ptr %arg5.addr, align 8
  %frombool = zext i1 %ppoll to i8
  store i8 %frombool, ptr %ppoll.addr, align 1
  %frombool1 = zext i1 %time64 to i8
  store i8 %frombool1, ptr %time64.addr, align 1
  %0 = load i64, ptr %arg2.addr, align 8
  %conv = trunc i64 %0 to i32
  store i32 %conv, ptr %nfds, align 4
  store ptr null, ptr %pfd, align 8
  store ptr null, ptr %target_pfd, align 8
  %1 = load i32, ptr %nfds, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end23

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %nfds, align 4
  %conv2 = zext i32 %2 to i64
  %cmp = icmp ugt i64 %conv2, 268435455
  br i1 %cmp, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  store i64 -22, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %3 = load i64, ptr %arg1.addr, align 8
  %4 = load i32, ptr %nfds, align 4
  %conv5 = zext i32 %4 to i64
  %mul = mul i64 8, %conv5
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %3, i64 noundef %mul, i1 noundef zeroext true)
  store ptr %call, ptr %target_pfd, align 8
  %5 = load ptr, ptr %target_pfd, align 8
  %tobool6 = icmp ne ptr %5, null
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end
  %6 = load i32, ptr %nfds, align 4
  %conv9 = zext i32 %6 to i64
  %mul10 = mul i64 8, %conv9
  %7 = alloca i8, i64 %mul10, align 16
  store ptr %7, ptr %pfd, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end8
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %nfds, align 4
  %cmp11 = icmp ult i32 %8, %9
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %target_pfd, align 8
  %11 = load i32, ptr %i, align 4
  %idxprom = zext i32 %11 to i64
  %arrayidx = getelementptr %struct.target_pollfd, ptr %10, i64 %idxprom
  %fd = getelementptr inbounds %struct.target_pollfd, ptr %arrayidx, i32 0, i32 0
  %12 = load i32, ptr %fd, align 4
  %call13 = call i32 @tswap32(i32 noundef %12)
  %13 = load ptr, ptr %pfd, align 8
  %14 = load i32, ptr %i, align 4
  %idxprom14 = zext i32 %14 to i64
  %arrayidx15 = getelementptr %struct.pollfd, ptr %13, i64 %idxprom14
  %fd16 = getelementptr inbounds %struct.pollfd, ptr %arrayidx15, i32 0, i32 0
  store i32 %call13, ptr %fd16, align 4
  %15 = load ptr, ptr %target_pfd, align 8
  %16 = load i32, ptr %i, align 4
  %idxprom17 = zext i32 %16 to i64
  %arrayidx18 = getelementptr %struct.target_pollfd, ptr %15, i64 %idxprom17
  %events = getelementptr inbounds %struct.target_pollfd, ptr %arrayidx18, i32 0, i32 1
  %17 = load i16, ptr %events, align 4
  %call19 = call zeroext i16 @tswap16(i16 noundef zeroext %17)
  %18 = load ptr, ptr %pfd, align 8
  %19 = load i32, ptr %i, align 4
  %idxprom20 = zext i32 %19 to i64
  %arrayidx21 = getelementptr %struct.pollfd, ptr %18, i64 %idxprom20
  %events22 = getelementptr inbounds %struct.pollfd, ptr %arrayidx21, i32 0, i32 1
  store i16 %call19, ptr %events22, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !37

for.end:                                          ; preds = %for.cond
  br label %if.end23

if.end23:                                         ; preds = %for.end, %entry
  %21 = load i8, ptr %ppoll.addr, align 1
  %tobool24 = trunc i8 %21 to i1
  br i1 %tobool24, label %if.then25, label %if.else74

if.then25:                                        ; preds = %if.end23
  store ptr %_timeout_ts, ptr %timeout_ts, align 8
  store ptr null, ptr %set, align 8
  %22 = load i64, ptr %arg3.addr, align 8
  %tobool26 = icmp ne i64 %22, 0
  br i1 %tobool26, label %if.then27, label %if.else39

if.then27:                                        ; preds = %if.then25
  %23 = load i8, ptr %time64.addr, align 1
  %tobool28 = trunc i8 %23 to i1
  br i1 %tobool28, label %if.then29, label %if.else

if.then29:                                        ; preds = %if.then27
  %24 = load ptr, ptr %timeout_ts, align 8
  %25 = load i64, ptr %arg3.addr, align 8
  %call30 = call i64 @target_to_host_timespec64(ptr noundef %24, i64 noundef %25)
  %tobool31 = icmp ne i64 %call30, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.then29
  %26 = load ptr, ptr %target_pfd, align 8
  %27 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %26, i64 noundef %27, i64 noundef 0)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end33:                                         ; preds = %if.then29
  br label %if.end38

if.else:                                          ; preds = %if.then27
  %28 = load ptr, ptr %timeout_ts, align 8
  %29 = load i64, ptr %arg3.addr, align 8
  %call34 = call i64 @target_to_host_timespec(ptr noundef %28, i64 noundef %29)
  %tobool35 = icmp ne i64 %call34, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else
  %30 = load ptr, ptr %target_pfd, align 8
  %31 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %30, i64 noundef %31, i64 noundef 0)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end37:                                         ; preds = %if.else
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.end33
  br label %if.end40

if.else39:                                        ; preds = %if.then25
  store ptr null, ptr %timeout_ts, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.else39, %if.end38
  %32 = load i64, ptr %arg4.addr, align 8
  %tobool41 = icmp ne i64 %32, 0
  br i1 %tobool41, label %if.then42, label %if.end49

if.then42:                                        ; preds = %if.end40
  %33 = load i64, ptr %arg4.addr, align 8
  %34 = load i64, ptr %arg5.addr, align 8
  %call43 = call i32 @process_sigsuspend_mask(ptr noundef %set, i64 noundef %33, i64 noundef %34)
  %conv44 = sext i32 %call43 to i64
  store i64 %conv44, ptr %ret, align 8
  %35 = load i64, ptr %ret, align 8
  %cmp45 = icmp ne i64 %35, 0
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.then42
  %36 = load ptr, ptr %target_pfd, align 8
  %37 = load i64, ptr %arg1.addr, align 8
  call void @unlock_user(ptr noundef %36, i64 noundef %37, i64 noundef 0)
  %38 = load i64, ptr %ret, align 8
  store i64 %38, ptr %retval, align 8
  br label %return

if.end48:                                         ; preds = %if.then42
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.end40
  %39 = load ptr, ptr %pfd, align 8
  %40 = load i32, ptr %nfds, align 4
  %41 = load ptr, ptr %timeout_ts, align 8
  %42 = load ptr, ptr %set, align 8
  %call50 = call i32 @safe_ppoll(ptr noundef %39, i32 noundef %40, ptr noundef %41, ptr noundef %42, i64 noundef 8)
  %conv51 = sext i32 %call50 to i64
  %call52 = call i64 @get_errno(i64 noundef %conv51)
  store i64 %call52, ptr %ret, align 8
  %43 = load ptr, ptr %set, align 8
  %tobool53 = icmp ne ptr %43, null
  br i1 %tobool53, label %if.then54, label %if.end56

if.then54:                                        ; preds = %if.end49
  %44 = load i64, ptr %ret, align 8
  %conv55 = trunc i64 %44 to i32
  call void @finish_sigsuspend_mask(i32 noundef %conv55)
  br label %if.end56

if.end56:                                         ; preds = %if.then54, %if.end49
  %45 = load i64, ptr %ret, align 8
  %call57 = call i32 @is_error(i64 noundef %45)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.end73, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end56
  %46 = load i64, ptr %arg3.addr, align 8
  %tobool59 = icmp ne i64 %46, 0
  br i1 %tobool59, label %if.then60, label %if.end73

if.then60:                                        ; preds = %land.lhs.true
  %47 = load i8, ptr %time64.addr, align 1
  %tobool61 = trunc i8 %47 to i1
  br i1 %tobool61, label %if.then62, label %if.else67

if.then62:                                        ; preds = %if.then60
  %48 = load i64, ptr %arg3.addr, align 8
  %49 = load ptr, ptr %timeout_ts, align 8
  %call63 = call i64 @host_to_target_timespec64(i64 noundef %48, ptr noundef %49)
  %tobool64 = icmp ne i64 %call63, 0
  br i1 %tobool64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %if.then62
  store i64 -14, ptr %retval, align 8
  br label %return

if.end66:                                         ; preds = %if.then62
  br label %if.end72

if.else67:                                        ; preds = %if.then60
  %50 = load i64, ptr %arg3.addr, align 8
  %51 = load ptr, ptr %timeout_ts, align 8
  %call68 = call i64 @host_to_target_timespec(i64 noundef %50, ptr noundef %51)
  %tobool69 = icmp ne i64 %call68, 0
  br i1 %tobool69, label %if.then70, label %if.end71

if.then70:                                        ; preds = %if.else67
  store i64 -14, ptr %retval, align 8
  br label %return

if.end71:                                         ; preds = %if.else67
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %if.end66
  br label %if.end73

if.end73:                                         ; preds = %if.end72, %land.lhs.true, %if.end56
  br label %if.end84

if.else74:                                        ; preds = %if.end23
  %52 = load i64, ptr %arg3.addr, align 8
  %cmp75 = icmp sge i64 %52, 0
  br i1 %cmp75, label %if.then77, label %if.else79

if.then77:                                        ; preds = %if.else74
  %53 = load i64, ptr %arg3.addr, align 8
  %div = sdiv i64 %53, 1000
  %tv_sec = getelementptr inbounds %struct.timespec, ptr %ts, i32 0, i32 0
  store i64 %div, ptr %tv_sec, align 8
  %54 = load i64, ptr %arg3.addr, align 8
  %rem = srem i64 %54, 1000
  %mul78 = mul i64 %rem, 1000000
  %tv_nsec = getelementptr inbounds %struct.timespec, ptr %ts, i32 0, i32 1
  store i64 %mul78, ptr %tv_nsec, align 8
  store ptr %ts, ptr %pts, align 8
  br label %if.end80

if.else79:                                        ; preds = %if.else74
  store ptr null, ptr %pts, align 8
  br label %if.end80

if.end80:                                         ; preds = %if.else79, %if.then77
  %55 = load ptr, ptr %pfd, align 8
  %56 = load i32, ptr %nfds, align 4
  %57 = load ptr, ptr %pts, align 8
  %call81 = call i32 @safe_ppoll(ptr noundef %55, i32 noundef %56, ptr noundef %57, ptr noundef null, i64 noundef 0)
  %conv82 = sext i32 %call81 to i64
  %call83 = call i64 @get_errno(i64 noundef %conv82)
  store i64 %call83, ptr %ret, align 8
  br label %if.end84

if.end84:                                         ; preds = %if.end80, %if.end73
  %58 = load i64, ptr %ret, align 8
  %call85 = call i32 @is_error(i64 noundef %58)
  %tobool86 = icmp ne i32 %call85, 0
  br i1 %tobool86, label %if.end101, label %if.then87

if.then87:                                        ; preds = %if.end84
  store i32 0, ptr %i, align 4
  br label %for.cond88

for.cond88:                                       ; preds = %for.inc98, %if.then87
  %59 = load i32, ptr %i, align 4
  %60 = load i32, ptr %nfds, align 4
  %cmp89 = icmp ult i32 %59, %60
  br i1 %cmp89, label %for.body91, label %for.end100

for.body91:                                       ; preds = %for.cond88
  %61 = load ptr, ptr %pfd, align 8
  %62 = load i32, ptr %i, align 4
  %idxprom92 = zext i32 %62 to i64
  %arrayidx93 = getelementptr %struct.pollfd, ptr %61, i64 %idxprom92
  %revents = getelementptr inbounds %struct.pollfd, ptr %arrayidx93, i32 0, i32 2
  %63 = load i16, ptr %revents, align 2
  %call94 = call zeroext i16 @tswap16(i16 noundef zeroext %63)
  %64 = load ptr, ptr %target_pfd, align 8
  %65 = load i32, ptr %i, align 4
  %idxprom95 = zext i32 %65 to i64
  %arrayidx96 = getelementptr %struct.target_pollfd, ptr %64, i64 %idxprom95
  %revents97 = getelementptr inbounds %struct.target_pollfd, ptr %arrayidx96, i32 0, i32 2
  store i16 %call94, ptr %revents97, align 2
  br label %for.inc98

for.inc98:                                        ; preds = %for.body91
  %66 = load i32, ptr %i, align 4
  %inc99 = add i32 %66, 1
  store i32 %inc99, ptr %i, align 4
  br label %for.cond88, !llvm.loop !38

for.end100:                                       ; preds = %for.cond88
  br label %if.end101

if.end101:                                        ; preds = %for.end100, %if.end84
  %67 = load ptr, ptr %target_pfd, align 8
  %68 = load i64, ptr %arg1.addr, align 8
  %69 = load i32, ptr %nfds, align 4
  %conv102 = zext i32 %69 to i64
  %mul103 = mul i64 8, %conv102
  call void @unlock_user(ptr noundef %67, i64 noundef %68, i64 noundef %mul103)
  %70 = load i64, ptr %ret, align 8
  store i64 %70, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end101, %if.then70, %if.then65, %if.then47, %if.then36, %if.then32, %if.then7, %if.then4
  %71 = load i64, ptr %retval, align 8
  ret i64 %71
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_flock(i32 noundef %fd, i32 noundef %operation) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %operation.addr = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %operation, ptr %operation.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load i32, ptr %operation.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 73, i32 noundef %3, i32 noundef %4)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @lock_iovec(i32 noundef %type, i64 noundef %target_addr, i64 noundef %count, i32 noundef %copy) #0 {
entry:
  %retval = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %target_addr.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %copy.addr = alloca i32, align 4
  %target_vec = alloca ptr, align 8
  %vec = alloca ptr, align 8
  %total_len = alloca i64, align 8
  %max_len = alloca i64, align 8
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %bad_address = alloca i8, align 1
  %base = alloca i64, align 8
  %len = alloca i64, align 8
  store i32 %type, ptr %type.addr, align 4
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i32 %copy, ptr %copy.addr, align 4
  store i32 0, ptr %err, align 4
  store i8 0, ptr %bad_address, align 1
  %0 = load i64, ptr %count.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #13
  store i32 0, ptr %call, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %count.addr, align 8
  %cmp1 = icmp ugt i64 %1, 1024
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %call3 = call ptr @__errno_location() #13
  store i32 22, ptr %call3, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %2 = load i64, ptr %count.addr, align 8
  %call5 = call noalias ptr @g_try_malloc0_n(i64 noundef %2, i64 noundef 16) #17
  store ptr %call5, ptr %vec, align 8
  %3 = load ptr, ptr %vec, align 8
  %cmp6 = icmp eq ptr %3, null
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end4
  %call8 = call ptr @__errno_location() #13
  store i32 12, ptr %call8, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end4
  %4 = load i64, ptr %target_addr.addr, align 8
  %5 = load i64, ptr %count.addr, align 8
  %mul = mul i64 %5, 16
  %call10 = call ptr @lock_user(i32 noundef 1, i64 noundef %4, i64 noundef %mul, i1 noundef zeroext true)
  store ptr %call10, ptr %target_vec, align 8
  %6 = load ptr, ptr %target_vec, align 8
  %cmp11 = icmp eq ptr %6, null
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  store i32 14, ptr %err, align 4
  br label %fail2

if.end13:                                         ; preds = %if.end9
  store i64 2147479552, ptr %max_len, align 8
  store i64 0, ptr %total_len, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end13
  %7 = load i32, ptr %i, align 4
  %conv = sext i32 %7 to i64
  %8 = load i64, ptr %count.addr, align 8
  %cmp14 = icmp ult i64 %conv, %8
  br i1 %cmp14, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %target_vec, align 8
  %10 = load i32, ptr %i, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr %struct.target_iovec, ptr %9, i64 %idxprom
  %iov_base = getelementptr inbounds %struct.target_iovec, ptr %arrayidx, i32 0, i32 0
  %11 = load i64, ptr %iov_base, align 8
  %call16 = call i64 @tswapal(i64 noundef %11)
  store i64 %call16, ptr %base, align 8
  %12 = load ptr, ptr %target_vec, align 8
  %13 = load i32, ptr %i, align 4
  %idxprom17 = sext i32 %13 to i64
  %arrayidx18 = getelementptr %struct.target_iovec, ptr %12, i64 %idxprom17
  %iov_len = getelementptr inbounds %struct.target_iovec, ptr %arrayidx18, i32 0, i32 1
  %14 = load i64, ptr %iov_len, align 8
  %call19 = call i64 @tswapal(i64 noundef %14)
  store i64 %call19, ptr %len, align 8
  %15 = load i64, ptr %len, align 8
  %cmp20 = icmp slt i64 %15, 0
  br i1 %cmp20, label %if.then22, label %if.else

if.then22:                                        ; preds = %for.body
  store i32 22, ptr %err, align 4
  br label %fail

if.else:                                          ; preds = %for.body
  %16 = load i64, ptr %len, align 8
  %cmp23 = icmp eq i64 %16, 0
  br i1 %cmp23, label %if.then25, label %if.else29

if.then25:                                        ; preds = %if.else
  %17 = load ptr, ptr %vec, align 8
  %18 = load i32, ptr %i, align 4
  %idxprom26 = sext i32 %18 to i64
  %arrayidx27 = getelementptr %struct.iovec, ptr %17, i64 %idxprom26
  %iov_base28 = getelementptr inbounds %struct.iovec, ptr %arrayidx27, i32 0, i32 0
  store ptr null, ptr %iov_base28, align 8
  br label %if.end53

if.else29:                                        ; preds = %if.else
  %19 = load i32, ptr %type.addr, align 4
  %20 = load i64, ptr %base, align 8
  %21 = load i64, ptr %len, align 8
  %22 = load i32, ptr %copy.addr, align 4
  %tobool = icmp ne i32 %22, 0
  %call30 = call ptr @lock_user(i32 noundef %19, i64 noundef %20, i64 noundef %21, i1 noundef zeroext %tobool)
  %23 = load ptr, ptr %vec, align 8
  %24 = load i32, ptr %i, align 4
  %idxprom31 = sext i32 %24 to i64
  %arrayidx32 = getelementptr %struct.iovec, ptr %23, i64 %idxprom31
  %iov_base33 = getelementptr inbounds %struct.iovec, ptr %arrayidx32, i32 0, i32 0
  store ptr %call30, ptr %iov_base33, align 8
  %25 = load ptr, ptr %vec, align 8
  %26 = load i32, ptr %i, align 4
  %idxprom34 = sext i32 %26 to i64
  %arrayidx35 = getelementptr %struct.iovec, ptr %25, i64 %idxprom34
  %iov_base36 = getelementptr inbounds %struct.iovec, ptr %arrayidx35, i32 0, i32 0
  %27 = load ptr, ptr %iov_base36, align 8
  %tobool37 = icmp ne ptr %27, null
  br i1 %tobool37, label %if.end44, label %if.then38

if.then38:                                        ; preds = %if.else29
  %28 = load i32, ptr %i, align 4
  %cmp39 = icmp eq i32 %28, 0
  br i1 %cmp39, label %if.then41, label %if.else42

if.then41:                                        ; preds = %if.then38
  store i32 14, ptr %err, align 4
  br label %fail

if.else42:                                        ; preds = %if.then38
  store i8 1, ptr %bad_address, align 1
  br label %if.end43

if.end43:                                         ; preds = %if.else42
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.else29
  %29 = load i8, ptr %bad_address, align 1
  %tobool45 = trunc i8 %29 to i1
  br i1 %tobool45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.end44
  store i64 0, ptr %len, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %if.end44
  %30 = load i64, ptr %len, align 8
  %31 = load i64, ptr %max_len, align 8
  %32 = load i64, ptr %total_len, align 8
  %sub = sub i64 %31, %32
  %cmp48 = icmp ugt i64 %30, %sub
  br i1 %cmp48, label %if.then50, label %if.end52

if.then50:                                        ; preds = %if.end47
  %33 = load i64, ptr %max_len, align 8
  %34 = load i64, ptr %total_len, align 8
  %sub51 = sub i64 %33, %34
  store i64 %sub51, ptr %len, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.then50, %if.end47
  br label %if.end53

if.end53:                                         ; preds = %if.end52, %if.then25
  br label %if.end54

if.end54:                                         ; preds = %if.end53
  %35 = load i64, ptr %len, align 8
  %36 = load ptr, ptr %vec, align 8
  %37 = load i32, ptr %i, align 4
  %idxprom55 = sext i32 %37 to i64
  %arrayidx56 = getelementptr %struct.iovec, ptr %36, i64 %idxprom55
  %iov_len57 = getelementptr inbounds %struct.iovec, ptr %arrayidx56, i32 0, i32 1
  store i64 %35, ptr %iov_len57, align 8
  %38 = load i64, ptr %len, align 8
  %39 = load i64, ptr %total_len, align 8
  %add = add i64 %39, %38
  store i64 %add, ptr %total_len, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end54
  %40 = load i32, ptr %i, align 4
  %inc = add i32 %40, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !39

for.end:                                          ; preds = %for.cond
  %41 = load ptr, ptr %target_vec, align 8
  %42 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %41, i64 noundef %42, i64 noundef 0)
  %43 = load ptr, ptr %vec, align 8
  store ptr %43, ptr %retval, align 8
  br label %return

fail:                                             ; preds = %if.then41, %if.then22
  br label %while.cond

while.cond:                                       ; preds = %if.end74, %fail
  %44 = load i32, ptr %i, align 4
  %dec = add i32 %44, -1
  store i32 %dec, ptr %i, align 4
  %cmp58 = icmp sge i32 %dec, 0
  br i1 %cmp58, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %45 = load ptr, ptr %target_vec, align 8
  %46 = load i32, ptr %i, align 4
  %idxprom60 = sext i32 %46 to i64
  %arrayidx61 = getelementptr %struct.target_iovec, ptr %45, i64 %idxprom60
  %iov_len62 = getelementptr inbounds %struct.target_iovec, ptr %arrayidx61, i32 0, i32 1
  %47 = load i64, ptr %iov_len62, align 8
  %call63 = call i64 @tswapal(i64 noundef %47)
  %cmp64 = icmp ugt i64 %call63, 0
  br i1 %cmp64, label %if.then66, label %if.end74

if.then66:                                        ; preds = %while.body
  %48 = load ptr, ptr %vec, align 8
  %49 = load i32, ptr %i, align 4
  %idxprom67 = sext i32 %49 to i64
  %arrayidx68 = getelementptr %struct.iovec, ptr %48, i64 %idxprom67
  %iov_base69 = getelementptr inbounds %struct.iovec, ptr %arrayidx68, i32 0, i32 0
  %50 = load ptr, ptr %iov_base69, align 8
  %51 = load ptr, ptr %target_vec, align 8
  %52 = load i32, ptr %i, align 4
  %idxprom70 = sext i32 %52 to i64
  %arrayidx71 = getelementptr %struct.target_iovec, ptr %51, i64 %idxprom70
  %iov_base72 = getelementptr inbounds %struct.target_iovec, ptr %arrayidx71, i32 0, i32 0
  %53 = load i64, ptr %iov_base72, align 8
  %call73 = call i64 @tswapal(i64 noundef %53)
  call void @unlock_user(ptr noundef %50, i64 noundef %call73, i64 noundef 0)
  br label %if.end74

if.end74:                                         ; preds = %if.then66, %while.body
  br label %while.cond, !llvm.loop !40

while.end:                                        ; preds = %while.cond
  %54 = load ptr, ptr %target_vec, align 8
  %55 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %54, i64 noundef %55, i64 noundef 0)
  br label %fail2

fail2:                                            ; preds = %while.end, %if.then12
  %56 = load ptr, ptr %vec, align 8
  call void @g_free(ptr noundef %56)
  %57 = load i32, ptr %err, align 4
  %call75 = call ptr @__errno_location() #13
  store i32 %57, ptr %call75, align 4
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %fail2, %for.end, %if.then7, %if.then2, %if.then
  %58 = load ptr, ptr %retval, align 8
  ret ptr %58
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @safe_readv(i32 noundef %fd, ptr noundef %iov, i32 noundef %iovcnt) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %iov.addr = alloca ptr, align 8
  %iovcnt.addr = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %iov, ptr %iov.addr, align 8
  store i32 %iovcnt, ptr %iovcnt.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %iov.addr, align 8
  %5 = load i32, ptr %iovcnt.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 19, i32 noundef %3, ptr noundef %4, i32 noundef %5)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @unlock_iovec(ptr noundef %vec, i64 noundef %target_addr, i64 noundef %count, i32 noundef %copy) #0 {
entry:
  %vec.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %copy.addr = alloca i32, align 4
  %target_vec = alloca ptr, align 8
  %i = alloca i32, align 4
  %base = alloca i64, align 8
  %len = alloca i64, align 8
  store ptr %vec, ptr %vec.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i32 %copy, ptr %copy.addr, align 4
  %0 = load i64, ptr %target_addr.addr, align 8
  %1 = load i64, ptr %count.addr, align 8
  %mul = mul i64 %1, 16
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef %mul, i1 noundef zeroext true)
  store ptr %call, ptr %target_vec, align 8
  %2 = load ptr, ptr %target_vec, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then, label %if.end16

if.then:                                          ; preds = %entry
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %conv = sext i32 %3 to i64
  %4 = load i64, ptr %count.addr, align 8
  %cmp = icmp ult i64 %conv, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %target_vec, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr %struct.target_iovec, ptr %5, i64 %idxprom
  %iov_base = getelementptr inbounds %struct.target_iovec, ptr %arrayidx, i32 0, i32 0
  %7 = load i64, ptr %iov_base, align 8
  %call2 = call i64 @tswapal(i64 noundef %7)
  store i64 %call2, ptr %base, align 8
  %8 = load ptr, ptr %target_vec, align 8
  %9 = load i32, ptr %i, align 4
  %idxprom3 = sext i32 %9 to i64
  %arrayidx4 = getelementptr %struct.target_iovec, ptr %8, i64 %idxprom3
  %iov_len = getelementptr inbounds %struct.target_iovec, ptr %arrayidx4, i32 0, i32 1
  %10 = load i64, ptr %iov_len, align 8
  %call5 = call i64 @tswapal(i64 noundef %10)
  store i64 %call5, ptr %len, align 8
  %11 = load i64, ptr %len, align 8
  %cmp6 = icmp slt i64 %11, 0
  br i1 %cmp6, label %if.then8, label %if.end

if.then8:                                         ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  %12 = load ptr, ptr %vec.addr, align 8
  %13 = load i32, ptr %i, align 4
  %idxprom9 = sext i32 %13 to i64
  %arrayidx10 = getelementptr %struct.iovec, ptr %12, i64 %idxprom9
  %iov_base11 = getelementptr inbounds %struct.iovec, ptr %arrayidx10, i32 0, i32 0
  %14 = load ptr, ptr %iov_base11, align 8
  %15 = load i64, ptr %base, align 8
  %16 = load i32, ptr %copy.addr, align 4
  %tobool12 = icmp ne i32 %16, 0
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %17 = load ptr, ptr %vec.addr, align 8
  %18 = load i32, ptr %i, align 4
  %idxprom13 = sext i32 %18 to i64
  %arrayidx14 = getelementptr %struct.iovec, ptr %17, i64 %idxprom13
  %iov_len15 = getelementptr inbounds %struct.iovec, ptr %arrayidx14, i32 0, i32 1
  %19 = load i64, ptr %iov_len15, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %19, %cond.true ], [ 0, %cond.false ]
  call void @unlock_user(ptr noundef %14, i64 noundef %15, i64 noundef %cond)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %20 = load i32, ptr %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !41

for.end:                                          ; preds = %if.then8, %for.cond
  %21 = load ptr, ptr %target_vec, align 8
  %22 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %21, i64 noundef %22, i64 noundef 0)
  br label %if.end16

if.end16:                                         ; preds = %for.end, %entry
  %23 = load ptr, ptr %vec.addr, align 8
  call void @g_free(ptr noundef %23)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @safe_writev(i32 noundef %fd, ptr noundef %iov, i32 noundef %iovcnt) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %iov.addr = alloca ptr, align 8
  %iovcnt.addr = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %iov, ptr %iov.addr, align 8
  store i32 %iovcnt, ptr %iovcnt.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %iov.addr, align 8
  %5 = load i32, ptr %iovcnt.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 20, i32 noundef %3, ptr noundef %4, i32 noundef %5)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @target_to_host_low_high(i64 noundef %tlow, i64 noundef %thigh, ptr noundef %hlow, ptr noundef %hhigh) #0 {
entry:
  %tlow.addr = alloca i64, align 8
  %thigh.addr = alloca i64, align 8
  %hlow.addr = alloca ptr, align 8
  %hhigh.addr = alloca ptr, align 8
  %off = alloca i64, align 8
  store i64 %tlow, ptr %tlow.addr, align 8
  store i64 %thigh, ptr %thigh.addr, align 8
  store ptr %hlow, ptr %hlow.addr, align 8
  store ptr %hhigh, ptr %hhigh.addr, align 8
  %0 = load i64, ptr %tlow.addr, align 8
  %1 = load i64, ptr %thigh.addr, align 8
  %shl = shl i64 %1, 32
  %shl1 = shl i64 %shl, 32
  %or = or i64 %0, %shl1
  store i64 %or, ptr %off, align 8
  %2 = load i64, ptr %off, align 8
  %3 = load ptr, ptr %hlow.addr, align 8
  store i64 %2, ptr %3, align 8
  %4 = load i64, ptr %off, align 8
  %shr = lshr i64 %4, 32
  %shr2 = lshr i64 %shr, 32
  %5 = load ptr, ptr %hhigh.addr, align 8
  store i64 %shr2, ptr %5, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @safe_preadv(i32 noundef %fd, ptr noundef %iov, i32 noundef %iovcnt, i64 noundef %pos_l, i64 noundef %pos_h) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %iov.addr = alloca ptr, align 8
  %iovcnt.addr = alloca i32, align 4
  %pos_l.addr = alloca i64, align 8
  %pos_h.addr = alloca i64, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %iov, ptr %iov.addr, align 8
  store i32 %iovcnt, ptr %iovcnt.addr, align 4
  store i64 %pos_l, ptr %pos_l.addr, align 8
  store i64 %pos_h, ptr %pos_h.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %iov.addr, align 8
  %5 = load i32, ptr %iovcnt.addr, align 4
  %6 = load i64, ptr %pos_l.addr, align 8
  %7 = load i64, ptr %pos_h.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 295, i32 noundef %3, ptr noundef %4, i32 noundef %5, i64 noundef %6, i64 noundef %7)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @safe_pwritev(i32 noundef %fd, ptr noundef %iov, i32 noundef %iovcnt, i64 noundef %pos_l, i64 noundef %pos_h) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %iov.addr = alloca ptr, align 8
  %iovcnt.addr = alloca i32, align 4
  %pos_l.addr = alloca i64, align 8
  %pos_h.addr = alloca i64, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %iov, ptr %iov.addr, align 8
  store i32 %iovcnt, ptr %iovcnt.addr, align 4
  store i64 %pos_l, ptr %pos_l.addr, align 8
  store i64 %pos_h, ptr %pos_h.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %iov.addr, align 8
  %5 = load i32, ptr %iovcnt.addr, align 4
  %6 = load i64, ptr %pos_l.addr, align 8
  %7 = load i64, ptr %pos_h.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 296, i32 noundef %3, ptr noundef %4, i32 noundef %5, i64 noundef %6, i64 noundef %7)
  ret i64 %call
}

; Function Attrs: nounwind
declare i32 @getsid(i32 noundef) #2

declare i32 @fdatasync(i32 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_sched_getaffinity(i32 noundef %pid, i32 noundef %len, ptr noundef %user_mask_ptr) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  %user_mask_ptr.addr = alloca ptr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %len, ptr %len.addr, align 4
  store ptr %user_mask_ptr, ptr %user_mask_ptr.addr, align 8
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load i32, ptr %len.addr, align 4
  %2 = load ptr, ptr %user_mask_ptr.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 204, i32 noundef %0, i32 noundef %1, ptr noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @host_to_target_cpu_mask(ptr noundef %host_mask, i64 noundef %host_size, i64 noundef %target_addr, i64 noundef %target_size) #0 {
entry:
  %retval = alloca i32, align 4
  %host_mask.addr = alloca ptr, align 8
  %host_size.addr = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %target_size.addr = alloca i64, align 8
  %target_bits = alloca i32, align 4
  %host_bits = alloca i32, align 4
  %target_mask = alloca ptr, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %bit = alloca i32, align 4
  %val = alloca i64, align 8
  store ptr %host_mask, ptr %host_mask.addr, align 8
  store i64 %host_size, ptr %host_size.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i64 %target_size, ptr %target_size.addr, align 8
  store i32 64, ptr %target_bits, align 4
  store i32 64, ptr %host_bits, align 4
  %0 = load i64, ptr %host_size.addr, align 8
  %1 = load i64, ptr %target_size.addr, align 8
  %cmp = icmp uge i64 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.639, ptr noundef @.str.579, i32 noundef 8610, ptr noundef @__PRETTY_FUNCTION__.host_to_target_cpu_mask) #15
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load i64, ptr %target_addr.addr, align 8
  %3 = load i64, ptr %target_size.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %2, i64 noundef %3, i1 noundef zeroext false)
  store ptr %call, ptr %target_mask, align 8
  %4 = load ptr, ptr %target_mask, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  store i32 -14, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %if.end
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc18, %if.end2
  %5 = load i32, ptr %i, align 4
  %conv = zext i32 %5 to i64
  %6 = load i64, ptr %target_size.addr, align 8
  %div = udiv i64 %6, 8
  %cmp3 = icmp ult i64 %conv, %div
  br i1 %cmp3, label %for.body, label %for.end20

for.body:                                         ; preds = %for.cond
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %target_bits, align 4
  %mul = mul i32 %7, %8
  store i32 %mul, ptr %bit, align 4
  store i64 0, ptr %val, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond5

for.cond5:                                        ; preds = %for.inc, %for.body
  %9 = load i32, ptr %j, align 4
  %10 = load i32, ptr %target_bits, align 4
  %cmp6 = icmp ult i32 %9, %10
  br i1 %cmp6, label %for.body8, label %for.end

for.body8:                                        ; preds = %for.cond5
  %11 = load ptr, ptr %host_mask.addr, align 8
  %12 = load i32, ptr %bit, align 4
  %13 = load i32, ptr %host_bits, align 4
  %div9 = udiv i32 %12, %13
  %idxprom = zext i32 %div9 to i64
  %arrayidx = getelementptr i64, ptr %11, i64 %idxprom
  %14 = load i64, ptr %arrayidx, align 8
  %15 = load i32, ptr %bit, align 4
  %16 = load i32, ptr %host_bits, align 4
  %rem = urem i32 %15, %16
  %sh_prom = zext i32 %rem to i64
  %shl = shl i64 1, %sh_prom
  %and = and i64 %14, %shl
  %tobool10 = icmp ne i64 %and, 0
  br i1 %tobool10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %for.body8
  %17 = load i32, ptr %j, align 4
  %sh_prom12 = zext i32 %17 to i64
  %shl13 = shl i64 1, %sh_prom12
  %18 = load i64, ptr %val, align 8
  %or = or i64 %18, %shl13
  store i64 %or, ptr %val, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %for.body8
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %19 = load i32, ptr %j, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %j, align 4
  %20 = load i32, ptr %bit, align 4
  %inc15 = add i32 %20, 1
  store i32 %inc15, ptr %bit, align 4
  br label %for.cond5, !llvm.loop !42

for.end:                                          ; preds = %for.cond5
  br label %do.body

do.body:                                          ; preds = %for.end
  %21 = load ptr, ptr %target_mask, align 8
  %22 = load i32, ptr %i, align 4
  %idxprom16 = zext i32 %22 to i64
  %arrayidx17 = getelementptr i64, ptr %21, i64 %idxprom16
  %23 = load i64, ptr %val, align 8
  call void @stq_le_p(ptr noundef %arrayidx17, i64 noundef %23)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %for.inc18

for.inc18:                                        ; preds = %do.end
  %24 = load i32, ptr %i, align 4
  %inc19 = add i32 %24, 1
  store i32 %inc19, ptr %i, align 4
  br label %for.cond, !llvm.loop !43

for.end20:                                        ; preds = %for.cond
  %25 = load ptr, ptr %target_mask, align 8
  %26 = load i64, ptr %target_addr.addr, align 8
  %27 = load i64, ptr %target_size.addr, align 8
  call void @unlock_user(ptr noundef %25, i64 noundef %26, i64 noundef %27)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end20, %if.then1
  %28 = load i32, ptr %retval, align 4
  ret i32 %28
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @target_to_host_cpu_mask(ptr noundef %host_mask, i64 noundef %host_size, i64 noundef %target_addr, i64 noundef %target_size) #0 {
entry:
  %retval = alloca i32, align 4
  %host_mask.addr = alloca ptr, align 8
  %host_size.addr = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %target_size.addr = alloca i64, align 8
  %target_bits = alloca i32, align 4
  %host_bits = alloca i32, align 4
  %target_mask = alloca ptr, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %bit = alloca i32, align 4
  %val = alloca i64, align 8
  store ptr %host_mask, ptr %host_mask.addr, align 8
  store i64 %host_size, ptr %host_size.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i64 %target_size, ptr %target_size.addr, align 8
  store i32 64, ptr %target_bits, align 4
  store i32 64, ptr %host_bits, align 4
  %0 = load i64, ptr %host_size.addr, align 8
  %1 = load i64, ptr %target_size.addr, align 8
  %cmp = icmp uge i64 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.639, ptr noundef @.str.579, i32 noundef 8576, ptr noundef @__PRETTY_FUNCTION__.target_to_host_cpu_mask) #15
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load i64, ptr %target_addr.addr, align 8
  %3 = load i64, ptr %target_size.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %2, i64 noundef %3, i1 noundef zeroext true)
  store ptr %call, ptr %target_mask, align 8
  %4 = load ptr, ptr %target_mask, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  store i32 -14, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %if.end
  %5 = load ptr, ptr %host_mask.addr, align 8
  %6 = load i64, ptr %host_size.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %5, i8 0, i64 %6, i1 false)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %if.end2
  %7 = load i32, ptr %i, align 4
  %conv = zext i32 %7 to i64
  %8 = load i64, ptr %target_size.addr, align 8
  %div = udiv i64 %8, 8
  %cmp3 = icmp ult i64 %conv, %div
  br i1 %cmp3, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %target_bits, align 4
  %mul = mul i32 %9, %10
  store i32 %mul, ptr %bit, align 4
  br label %do.body

do.body:                                          ; preds = %for.body
  %11 = load ptr, ptr %target_mask, align 8
  %12 = load i32, ptr %i, align 4
  %idxprom = zext i32 %12 to i64
  %arrayidx = getelementptr i64, ptr %11, i64 %idxprom
  %call5 = call i64 @ldq_le_p(ptr noundef %arrayidx)
  store i64 %call5, ptr %val, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %j, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %do.end
  %13 = load i32, ptr %j, align 4
  %14 = load i32, ptr %target_bits, align 4
  %cmp7 = icmp ult i32 %13, %14
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %15 = load i64, ptr %val, align 8
  %16 = load i32, ptr %j, align 4
  %sh_prom = zext i32 %16 to i64
  %shl = shl i64 1, %sh_prom
  %and = and i64 %15, %shl
  %tobool10 = icmp ne i64 %and, 0
  br i1 %tobool10, label %if.then11, label %if.end17

if.then11:                                        ; preds = %for.body9
  %17 = load i32, ptr %bit, align 4
  %18 = load i32, ptr %host_bits, align 4
  %rem = urem i32 %17, %18
  %sh_prom12 = zext i32 %rem to i64
  %shl13 = shl i64 1, %sh_prom12
  %19 = load ptr, ptr %host_mask.addr, align 8
  %20 = load i32, ptr %bit, align 4
  %21 = load i32, ptr %host_bits, align 4
  %div14 = udiv i32 %20, %21
  %idxprom15 = zext i32 %div14 to i64
  %arrayidx16 = getelementptr i64, ptr %19, i64 %idxprom15
  %22 = load i64, ptr %arrayidx16, align 8
  %or = or i64 %22, %shl13
  store i64 %or, ptr %arrayidx16, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then11, %for.body9
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %23 = load i32, ptr %j, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %j, align 4
  %24 = load i32, ptr %bit, align 4
  %inc18 = add i32 %24, 1
  store i32 %inc18, ptr %bit, align 4
  br label %for.cond6, !llvm.loop !44

for.end:                                          ; preds = %for.cond6
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %25 = load i32, ptr %i, align 4
  %inc20 = add i32 %25, 1
  store i32 %inc20, ptr %i, align 4
  br label %for.cond, !llvm.loop !45

for.end21:                                        ; preds = %for.cond
  %26 = load ptr, ptr %target_mask, align 8
  %27 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %26, i64 noundef %27, i64 noundef 0)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end21, %if.then1
  %28 = load i32, ptr %retval, align 4
  ret i32 %28
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_sched_setaffinity(i32 noundef %pid, i32 noundef %len, ptr noundef %user_mask_ptr) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  %user_mask_ptr.addr = alloca ptr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %len, ptr %len.addr, align 4
  store ptr %user_mask_ptr, ptr %user_mask_ptr.addr, align 8
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load i32, ptr %len.addr, align 4
  %2 = load ptr, ptr %user_mask_ptr.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 203, i32 noundef %0, i32 noundef %1, ptr noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_getcpu(ptr noundef %cpu, ptr noundef %node, ptr noundef %tcache) #0 {
entry:
  %cpu.addr = alloca ptr, align 8
  %node.addr = alloca ptr, align 8
  %tcache.addr = alloca ptr, align 8
  store ptr %cpu, ptr %cpu.addr, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr %tcache, ptr %tcache.addr, align 8
  %0 = load ptr, ptr %cpu.addr, align 8
  %1 = load ptr, ptr %node.addr, align 8
  %2 = load ptr, ptr %tcache.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 309, ptr noundef %0, ptr noundef %1, ptr noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_sched_setparam(i32 noundef %pid, ptr noundef %param) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %param.addr = alloca ptr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store ptr %param, ptr %param.addr, align 8
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load ptr, ptr %param.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 142, i32 noundef %0, ptr noundef %1) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_sched_getparam(i32 noundef %pid, ptr noundef %param) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %param.addr = alloca ptr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store ptr %param, ptr %param.addr, align 8
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load ptr, ptr %param.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 143, i32 noundef %0, ptr noundef %1) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_sched_setscheduler(i32 noundef %pid, i32 noundef %policy, ptr noundef %param) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %policy.addr = alloca i32, align 4
  %param.addr = alloca ptr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %policy, ptr %policy.addr, align 4
  store ptr %param, ptr %param.addr, align 8
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load i32, ptr %policy.addr, align 4
  %2 = load ptr, ptr %param.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 144, i32 noundef %0, i32 noundef %1, ptr noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_sched_getscheduler(i32 noundef %pid) #0 {
entry:
  %pid.addr = alloca i32, align 4
  store i32 %pid, ptr %pid.addr, align 4
  %0 = load i32, ptr %pid.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 145, i32 noundef %0) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_sched_getattr(i32 noundef %pid, ptr noundef %attr, i32 noundef %size, i32 noundef %flags) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %attr.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  store i32 %pid, ptr %pid.addr, align 4
  store ptr %attr, ptr %attr.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load ptr, ptr %attr.addr, align 8
  %2 = load i32, ptr %size.addr, align 4
  %3 = load i32, ptr %flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 315, i32 noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef %3) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @check_zeroed_user(i64 noundef %addr, i64 noundef %ksize, i64 noundef %usize) #0 {
entry:
  %retval = alloca i32, align 4
  %addr.addr = alloca i64, align 8
  %ksize.addr = alloca i64, align 8
  %usize.addr = alloca i64, align 8
  %i = alloca i32, align 4
  %b = alloca i8, align 1
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %ksize, ptr %ksize.addr, align 8
  store i64 %usize, ptr %usize.addr, align 8
  %0 = load i64, ptr %usize.addr, align 8
  %1 = load i64, ptr %ksize.addr, align 8
  %cmp = icmp ule i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %ksize.addr, align 8
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, ptr %i, align 4
  %conv1 = sext i32 %3 to i64
  %4 = load i64, ptr %usize.addr, align 8
  %cmp2 = icmp ult i64 %conv1, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i64, ptr %addr.addr, align 8
  %6 = load i32, ptr %i, align 4
  %conv4 = sext i32 %6 to i64
  %add = add i64 %5, %conv4
  store i64 %add, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %7 = load i64, ptr %__gaddr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %7, i64 noundef 1, i1 noundef zeroext true)
  store ptr %call, ptr %__hptr, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.then5, label %if.else

if.then5:                                         ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %if.then5
  %8 = load ptr, ptr %__hptr, align 8
  %call6 = call i32 @ldub_p(ptr noundef %8)
  %conv7 = trunc i32 %call6 to i8
  store i8 %conv7, ptr %b, align 1
  br label %do.end

do.end:                                           ; preds = %do.body
  %9 = load ptr, ptr %__hptr, align 8
  %10 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %9, i64 noundef %10, i64 noundef 0)
  br label %if.end8

if.else:                                          ; preds = %for.body
  store i8 0, ptr %b, align 1
  store i64 -14, ptr %__ret, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.else, %do.end
  %11 = load i64, ptr %__ret, align 8
  store i64 %11, ptr %tmp, align 8
  %12 = load i64, ptr %tmp, align 8
  %tobool9 = icmp ne i64 %12, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end8
  store i32 -14, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end8
  %13 = load i8, ptr %b, align 1
  %conv12 = zext i8 %13 to i32
  %cmp13 = icmp ne i32 %conv12, 0
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end11
  store i32 0, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end11
  br label %for.inc

for.inc:                                          ; preds = %if.end16
  %14 = load i32, ptr %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !46

for.end:                                          ; preds = %for.cond
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then15, %if.then10, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_sched_setattr(i32 noundef %pid, ptr noundef %attr, i32 noundef %flags) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %attr.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store i32 %pid, ptr %pid.addr, align 4
  store ptr %attr, ptr %attr.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load ptr, ptr %attr.addr, align 8
  %2 = load i32, ptr %flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 314, i32 noundef %0, ptr noundef %1, i32 noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @sched_yield() #2

; Function Attrs: nounwind
declare i32 @sched_get_priority_max(i32 noundef) #2

; Function Attrs: nounwind
declare i32 @sched_get_priority_min(i32 noundef) #2

; Function Attrs: nounwind
declare i32 @sched_rr_get_interval(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_nanosleep(ptr noundef %req, ptr noundef %rem) #0 {
entry:
  %req.addr = alloca ptr, align 8
  %rem.addr = alloca ptr, align 8
  store ptr %req, ptr %req.addr, align 8
  store ptr %rem, ptr %rem.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load ptr, ptr %req.addr, align 8
  %4 = load ptr, ptr %rem.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 35, ptr noundef %3, ptr noundef %4)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_prctl(ptr noundef %env, i64 noundef %option, i64 noundef %arg2, i64 noundef %arg3, i64 noundef %arg4, i64 noundef %arg5) #0 {
entry:
  %retval = alloca i64, align 8
  %env.addr = alloca ptr, align 8
  %option.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  %arg4.addr = alloca i64, align 8
  %arg5.addr = alloca i64, align 8
  %ret = alloca i64, align 8
  %deathsig = alloca i32, align 4
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %name = alloca ptr, align 8
  %name24 = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  store i64 %option, ptr %option.addr, align 8
  store i64 %arg2, ptr %arg2.addr, align 8
  store i64 %arg3, ptr %arg3.addr, align 8
  store i64 %arg4, ptr %arg4.addr, align 8
  store i64 %arg5, ptr %arg5.addr, align 8
  %0 = load i64, ptr %option.addr, align 8
  switch i64 %0, label %sw.default [
    i64 2, label %sw.bb
    i64 1, label %sw.bb9
    i64 16, label %sw.bb15
    i64 15, label %sw.bb23
    i64 46, label %sw.bb32
    i64 45, label %sw.bb34
    i64 51, label %sw.bb36
    i64 50, label %sw.bb38
    i64 64, label %sw.bb40
    i64 63, label %sw.bb42
    i64 54, label %sw.bb44
    i64 55, label %sw.bb52
    i64 56, label %sw.bb61
    i64 5, label %sw.bb72
    i64 6, label %sw.bb74
    i64 47, label %sw.bb76
    i64 23, label %sw.bb76
    i64 24, label %sw.bb76
    i64 3, label %sw.bb76
    i64 4, label %sw.bb76
    i64 7, label %sw.bb76
    i64 8, label %sw.bb76
    i64 27, label %sw.bb76
    i64 28, label %sw.bb76
    i64 13, label %sw.bb76
    i64 14, label %sw.bb76
    i64 30, label %sw.bb76
    i64 29, label %sw.bb76
    i64 33, label %sw.bb76
    i64 34, label %sw.bb76
    i64 39, label %sw.bb76
    i64 38, label %sw.bb76
    i64 58, label %sw.bb76
    i64 57, label %sw.bb76
    i64 37, label %sw.bb81
    i64 36, label %sw.bb81
    i64 52, label %sw.bb81
    i64 53, label %sw.bb81
    i64 40, label %sw.bb81
    i64 11, label %sw.bb82
    i64 12, label %sw.bb82
    i64 19, label %sw.bb83
    i64 20, label %sw.bb83
    i64 9, label %sw.bb83
    i64 10, label %sw.bb83
    i64 35, label %sw.bb83
    i64 21, label %sw.bb83
    i64 22, label %sw.bb83
    i64 59, label %sw.bb83
    i64 42, label %sw.bb83
    i64 41, label %sw.bb83
    i64 25, label %sw.bb83
    i64 26, label %sw.bb83
  ]

sw.bb:                                            ; preds = %entry
  %1 = load i64, ptr %arg3.addr, align 8
  %2 = load i64, ptr %arg4.addr, align 8
  %3 = load i64, ptr %arg5.addr, align 8
  %call = call i32 (i32, ...) @prctl(i32 noundef 2, ptr noundef %deathsig, i64 noundef %1, i64 noundef %2, i64 noundef %3) #14
  %conv = sext i32 %call to i64
  %call1 = call i64 @get_errno(i64 noundef %conv)
  store i64 %call1, ptr %ret, align 8
  %4 = load i64, ptr %ret, align 8
  %call2 = call i32 @is_error(i64 noundef %4)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end8, label %land.lhs.true

land.lhs.true:                                    ; preds = %sw.bb
  %5 = load i64, ptr %arg2.addr, align 8
  store i64 %5, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %6 = load i64, ptr %__gaddr, align 8
  %call3 = call ptr @lock_user(i32 noundef 3, i64 noundef %6, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call3, ptr %__hptr, align 8
  %tobool4 = icmp ne ptr %call3, null
  br i1 %tobool4, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  br label %do.body

do.body:                                          ; preds = %if.then
  %7 = load ptr, ptr %__hptr, align 8
  %8 = load i32, ptr %deathsig, align 4
  %call5 = call i32 @host_to_target_signal(i32 noundef %8)
  call void @stl_le_p(ptr noundef %7, i32 noundef %call5)
  br label %do.end

do.end:                                           ; preds = %do.body
  %9 = load ptr, ptr %__hptr, align 8
  %10 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %9, i64 noundef %10, i64 noundef 4)
  br label %if.end

if.else:                                          ; preds = %land.lhs.true
  store i64 -14, ptr %__ret, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %11 = load i64, ptr %__ret, align 8
  store i64 %11, ptr %tmp, align 8
  %12 = load i64, ptr %tmp, align 8
  %tobool6 = icmp ne i64 %12, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end, %sw.bb
  %13 = load i64, ptr %ret, align 8
  store i64 %13, ptr %retval, align 8
  br label %return

sw.bb9:                                           ; preds = %entry
  %14 = load i64, ptr %arg2.addr, align 8
  %conv10 = trunc i64 %14 to i32
  %call11 = call i32 @target_to_host_signal(i32 noundef %conv10)
  %15 = load i64, ptr %arg3.addr, align 8
  %16 = load i64, ptr %arg4.addr, align 8
  %17 = load i64, ptr %arg5.addr, align 8
  %call12 = call i32 (i32, ...) @prctl(i32 noundef 1, i32 noundef %call11, i64 noundef %15, i64 noundef %16, i64 noundef %17) #14
  %conv13 = sext i32 %call12 to i64
  %call14 = call i64 @get_errno(i64 noundef %conv13)
  store i64 %call14, ptr %retval, align 8
  br label %return

sw.bb15:                                          ; preds = %entry
  %18 = load i64, ptr %arg2.addr, align 8
  %call16 = call ptr @lock_user(i32 noundef 3, i64 noundef %18, i64 noundef 16, i1 noundef zeroext true)
  store ptr %call16, ptr %name, align 8
  %19 = load ptr, ptr %name, align 8
  %tobool17 = icmp ne ptr %19, null
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %sw.bb15
  store i64 -14, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %sw.bb15
  %20 = load ptr, ptr %name, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = load i64, ptr %arg3.addr, align 8
  %23 = load i64, ptr %arg4.addr, align 8
  %24 = load i64, ptr %arg5.addr, align 8
  %call20 = call i32 (i32, ...) @prctl(i32 noundef 16, i64 noundef %21, i64 noundef %22, i64 noundef %23, i64 noundef %24) #14
  %conv21 = sext i32 %call20 to i64
  %call22 = call i64 @get_errno(i64 noundef %conv21)
  store i64 %call22, ptr %ret, align 8
  %25 = load ptr, ptr %name, align 8
  %26 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %25, i64 noundef %26, i64 noundef 16)
  %27 = load i64, ptr %ret, align 8
  store i64 %27, ptr %retval, align 8
  br label %return

sw.bb23:                                          ; preds = %entry
  %28 = load i64, ptr %arg2.addr, align 8
  %call25 = call ptr @lock_user(i32 noundef 1, i64 noundef %28, i64 noundef 16, i1 noundef zeroext true)
  store ptr %call25, ptr %name24, align 8
  %29 = load ptr, ptr %name24, align 8
  %tobool26 = icmp ne ptr %29, null
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %sw.bb23
  store i64 -14, ptr %retval, align 8
  br label %return

if.end28:                                         ; preds = %sw.bb23
  %30 = load ptr, ptr %name24, align 8
  %31 = ptrtoint ptr %30 to i64
  %32 = load i64, ptr %arg3.addr, align 8
  %33 = load i64, ptr %arg4.addr, align 8
  %34 = load i64, ptr %arg5.addr, align 8
  %call29 = call i32 (i32, ...) @prctl(i32 noundef 15, i64 noundef %31, i64 noundef %32, i64 noundef %33, i64 noundef %34) #14
  %conv30 = sext i32 %call29 to i64
  %call31 = call i64 @get_errno(i64 noundef %conv30)
  store i64 %call31, ptr %ret, align 8
  %35 = load ptr, ptr %name24, align 8
  %36 = load i64, ptr %arg2.addr, align 8
  call void @unlock_user(ptr noundef %35, i64 noundef %36, i64 noundef 0)
  %37 = load i64, ptr %ret, align 8
  store i64 %37, ptr %retval, align 8
  br label %return

sw.bb32:                                          ; preds = %entry
  %38 = load ptr, ptr %env.addr, align 8
  %call33 = call i64 @do_prctl_inval0(ptr noundef %38)
  store i64 %call33, ptr %retval, align 8
  br label %return

sw.bb34:                                          ; preds = %entry
  %39 = load ptr, ptr %env.addr, align 8
  %40 = load i64, ptr %arg2.addr, align 8
  %call35 = call i64 @do_prctl_inval1(ptr noundef %39, i64 noundef %40)
  store i64 %call35, ptr %retval, align 8
  br label %return

sw.bb36:                                          ; preds = %entry
  %41 = load ptr, ptr %env.addr, align 8
  %call37 = call i64 @do_prctl_inval0(ptr noundef %41)
  store i64 %call37, ptr %retval, align 8
  br label %return

sw.bb38:                                          ; preds = %entry
  %42 = load ptr, ptr %env.addr, align 8
  %43 = load i64, ptr %arg2.addr, align 8
  %call39 = call i64 @do_prctl_inval1(ptr noundef %42, i64 noundef %43)
  store i64 %call39, ptr %retval, align 8
  br label %return

sw.bb40:                                          ; preds = %entry
  %44 = load ptr, ptr %env.addr, align 8
  %call41 = call i64 @do_prctl_inval0(ptr noundef %44)
  store i64 %call41, ptr %retval, align 8
  br label %return

sw.bb42:                                          ; preds = %entry
  %45 = load ptr, ptr %env.addr, align 8
  %46 = load i64, ptr %arg2.addr, align 8
  %call43 = call i64 @do_prctl_inval1(ptr noundef %45, i64 noundef %46)
  store i64 %call43, ptr %retval, align 8
  br label %return

sw.bb44:                                          ; preds = %entry
  %47 = load i64, ptr %arg3.addr, align 8
  %tobool45 = icmp ne i64 %47, 0
  br i1 %tobool45, label %if.then49, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb44
  %48 = load i64, ptr %arg4.addr, align 8
  %tobool46 = icmp ne i64 %48, 0
  br i1 %tobool46, label %if.then49, label %lor.lhs.false47

lor.lhs.false47:                                  ; preds = %lor.lhs.false
  %49 = load i64, ptr %arg5.addr, align 8
  %tobool48 = icmp ne i64 %49, 0
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %lor.lhs.false47, %lor.lhs.false, %sw.bb44
  store i64 -22, ptr %retval, align 8
  br label %return

if.end50:                                         ; preds = %lor.lhs.false47
  %50 = load ptr, ptr %env.addr, align 8
  %51 = load i64, ptr %arg2.addr, align 8
  %call51 = call i64 @do_prctl_inval1(ptr noundef %50, i64 noundef %51)
  store i64 %call51, ptr %retval, align 8
  br label %return

sw.bb52:                                          ; preds = %entry
  %52 = load i64, ptr %arg3.addr, align 8
  %tobool53 = icmp ne i64 %52, 0
  br i1 %tobool53, label %if.then58, label %lor.lhs.false54

lor.lhs.false54:                                  ; preds = %sw.bb52
  %53 = load i64, ptr %arg4.addr, align 8
  %tobool55 = icmp ne i64 %53, 0
  br i1 %tobool55, label %if.then58, label %lor.lhs.false56

lor.lhs.false56:                                  ; preds = %lor.lhs.false54
  %54 = load i64, ptr %arg5.addr, align 8
  %tobool57 = icmp ne i64 %54, 0
  br i1 %tobool57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %lor.lhs.false56, %lor.lhs.false54, %sw.bb52
  store i64 -22, ptr %retval, align 8
  br label %return

if.end59:                                         ; preds = %lor.lhs.false56
  %55 = load ptr, ptr %env.addr, align 8
  %56 = load i64, ptr %arg2.addr, align 8
  %call60 = call i64 @do_prctl_inval1(ptr noundef %55, i64 noundef %56)
  store i64 %call60, ptr %retval, align 8
  br label %return

sw.bb61:                                          ; preds = %entry
  %57 = load i64, ptr %arg2.addr, align 8
  %tobool62 = icmp ne i64 %57, 0
  br i1 %tobool62, label %if.then69, label %lor.lhs.false63

lor.lhs.false63:                                  ; preds = %sw.bb61
  %58 = load i64, ptr %arg3.addr, align 8
  %tobool64 = icmp ne i64 %58, 0
  br i1 %tobool64, label %if.then69, label %lor.lhs.false65

lor.lhs.false65:                                  ; preds = %lor.lhs.false63
  %59 = load i64, ptr %arg4.addr, align 8
  %tobool66 = icmp ne i64 %59, 0
  br i1 %tobool66, label %if.then69, label %lor.lhs.false67

lor.lhs.false67:                                  ; preds = %lor.lhs.false65
  %60 = load i64, ptr %arg5.addr, align 8
  %tobool68 = icmp ne i64 %60, 0
  br i1 %tobool68, label %if.then69, label %if.end70

if.then69:                                        ; preds = %lor.lhs.false67, %lor.lhs.false65, %lor.lhs.false63, %sw.bb61
  store i64 -22, ptr %retval, align 8
  br label %return

if.end70:                                         ; preds = %lor.lhs.false67
  %61 = load ptr, ptr %env.addr, align 8
  %call71 = call i64 @do_prctl_inval0(ptr noundef %61)
  store i64 %call71, ptr %retval, align 8
  br label %return

sw.bb72:                                          ; preds = %entry
  %62 = load ptr, ptr %env.addr, align 8
  %63 = load i64, ptr %arg2.addr, align 8
  %call73 = call i64 @do_prctl_inval1(ptr noundef %62, i64 noundef %63)
  store i64 %call73, ptr %retval, align 8
  br label %return

sw.bb74:                                          ; preds = %entry
  %64 = load ptr, ptr %env.addr, align 8
  %65 = load i64, ptr %arg2.addr, align 8
  %call75 = call i64 @do_prctl_inval1(ptr noundef %64, i64 noundef %65)
  store i64 %call75, ptr %retval, align 8
  br label %return

sw.bb76:                                          ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  %66 = load i64, ptr %option.addr, align 8
  %conv77 = trunc i64 %66 to i32
  %67 = load i64, ptr %arg2.addr, align 8
  %68 = load i64, ptr %arg3.addr, align 8
  %69 = load i64, ptr %arg4.addr, align 8
  %70 = load i64, ptr %arg5.addr, align 8
  %call78 = call i32 (i32, ...) @prctl(i32 noundef %conv77, i64 noundef %67, i64 noundef %68, i64 noundef %69, i64 noundef %70) #14
  %conv79 = sext i32 %call78 to i64
  %call80 = call i64 @get_errno(i64 noundef %conv79)
  store i64 %call80, ptr %retval, align 8
  br label %return

sw.bb81:                                          ; preds = %entry, %entry, %entry, %entry, %entry
  store i64 -22, ptr %retval, align 8
  br label %return

sw.bb82:                                          ; preds = %entry, %entry
  store i64 -22, ptr %retval, align 8
  br label %return

sw.bb83:                                          ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i64 -22, ptr %retval, align 8
  br label %return

sw.default:                                       ; preds = %entry
  br label %do.body84

do.body84:                                        ; preds = %sw.default
  %call85 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 1024)
  %lnot = xor i1 %call85, true
  %lnot86 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot86 to i32
  %conv87 = sext i32 %lnot.ext to i64
  %tobool88 = icmp ne i64 %conv87, 0
  br i1 %tobool88, label %if.then89, label %if.end90

if.then89:                                        ; preds = %do.body84
  %71 = load i64, ptr %option.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.640, i64 noundef %71)
  br label %if.end90

if.end90:                                         ; preds = %if.then89, %do.body84
  br label %do.end91

do.end91:                                         ; preds = %if.end90
  store i64 -22, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end91, %sw.bb83, %sw.bb82, %sw.bb81, %sw.bb76, %sw.bb74, %sw.bb72, %if.end70, %if.then69, %if.end59, %if.then58, %if.end50, %if.then49, %sw.bb42, %sw.bb40, %sw.bb38, %sw.bb36, %sw.bb34, %sw.bb32, %if.end28, %if.then27, %if.end19, %if.then18, %sw.bb9, %if.end8, %if.then7
  %72 = load i64, ptr %retval, align 8
  ret i64 %72
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @regpairs_aligned(ptr noundef %cpu_env, i32 noundef %num) #0 {
entry:
  %cpu_env.addr = alloca ptr, align 8
  %num.addr = alloca i32, align 4
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i32 %num, ptr %num.addr, align 4
  ret i32 0
}

declare i64 @pread64(i32 noundef, ptr noundef, i64 noundef, i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_offset64(i64 noundef %word0, i64 noundef %word1) #0 {
entry:
  %word0.addr = alloca i64, align 8
  %word1.addr = alloca i64, align 8
  store i64 %word0, ptr %word0.addr, align 8
  store i64 %word1, ptr %word1.addr, align 8
  %0 = load i64, ptr %word0.addr, align 8
  ret i64 %0
}

declare i64 @pwrite64(i32 noundef, ptr noundef, i64 noundef, i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_getcwd1(ptr noundef %buf, i64 noundef %size) #0 {
entry:
  %buf.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load ptr, ptr %buf.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 79, ptr noundef %0, i64 noundef %1) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @capget(ptr noundef %header, ptr noundef %data) #0 {
entry:
  %header.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  store ptr %header, ptr %header.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  %0 = load ptr, ptr %header.addr, align 8
  %1 = load ptr, ptr %data.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 125, ptr noundef %0, ptr noundef %1) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @capset(ptr noundef %header, ptr noundef %data) #0 {
entry:
  %header.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  store ptr %header, ptr %header.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  %0 = load ptr, ptr %header.addr, align 8
  %1 = load ptr, ptr %data.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 126, ptr noundef %0, ptr noundef %1) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

declare i64 @do_sigaltstack(i64 noundef, i64 noundef, ptr noundef) #3

; Function Attrs: nounwind
declare i64 @sendfile64(i32 noundef, i32 noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i32 @fstatat64(i32 noundef, ptr noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_stat64(ptr noundef %cpu_env, i64 noundef %target_addr, ptr noundef %host_st) #0 {
entry:
  %retval = alloca i64, align 8
  %cpu_env.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %host_st.addr = alloca ptr, align 8
  %target_st = alloca ptr, align 8
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_st, ptr %host_st.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 128, i1 noundef zeroext false)
  store ptr %call, ptr %target_st, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %target_st, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %1, i8 0, i64 128, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.end
  %2 = load ptr, ptr %target_st, align 8
  %st_dev = getelementptr inbounds %struct.target_stat, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %host_st.addr, align 8
  %st_dev1 = getelementptr inbounds %struct.stat, ptr %3, i32 0, i32 0
  %4 = load i64, ptr %st_dev1, align 8
  call void @stq_le_p(ptr noundef %st_dev, i64 noundef %4)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %5 = load ptr, ptr %target_st, align 8
  %st_ino = getelementptr inbounds %struct.target_stat, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %host_st.addr, align 8
  %st_ino3 = getelementptr inbounds %struct.stat, ptr %6, i32 0, i32 1
  %7 = load i64, ptr %st_ino3, align 8
  call void @stq_le_p(ptr noundef %st_ino, i64 noundef %7)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  br label %do.body5

do.body5:                                         ; preds = %do.end4
  %8 = load ptr, ptr %target_st, align 8
  %st_mode = getelementptr inbounds %struct.target_stat, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %host_st.addr, align 8
  %st_mode6 = getelementptr inbounds %struct.stat, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %st_mode6, align 8
  call void @stl_le_p(ptr noundef %st_mode, i32 noundef %10)
  br label %do.end7

do.end7:                                          ; preds = %do.body5
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %11 = load ptr, ptr %target_st, align 8
  %st_nlink = getelementptr inbounds %struct.target_stat, ptr %11, i32 0, i32 3
  %12 = load ptr, ptr %host_st.addr, align 8
  %st_nlink9 = getelementptr inbounds %struct.stat, ptr %12, i32 0, i32 2
  %13 = load i64, ptr %st_nlink9, align 8
  %conv = trunc i64 %13 to i32
  call void @stl_le_p(ptr noundef %st_nlink, i32 noundef %conv)
  br label %do.end10

do.end10:                                         ; preds = %do.body8
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %14 = load ptr, ptr %target_st, align 8
  %st_uid = getelementptr inbounds %struct.target_stat, ptr %14, i32 0, i32 4
  %15 = load ptr, ptr %host_st.addr, align 8
  %st_uid12 = getelementptr inbounds %struct.stat, ptr %15, i32 0, i32 4
  %16 = load i32, ptr %st_uid12, align 4
  call void @stl_le_p(ptr noundef %st_uid, i32 noundef %16)
  br label %do.end13

do.end13:                                         ; preds = %do.body11
  br label %do.body14

do.body14:                                        ; preds = %do.end13
  %17 = load ptr, ptr %target_st, align 8
  %st_gid = getelementptr inbounds %struct.target_stat, ptr %17, i32 0, i32 5
  %18 = load ptr, ptr %host_st.addr, align 8
  %st_gid15 = getelementptr inbounds %struct.stat, ptr %18, i32 0, i32 5
  %19 = load i32, ptr %st_gid15, align 8
  call void @stl_le_p(ptr noundef %st_gid, i32 noundef %19)
  br label %do.end16

do.end16:                                         ; preds = %do.body14
  br label %do.body17

do.body17:                                        ; preds = %do.end16
  %20 = load ptr, ptr %target_st, align 8
  %st_rdev = getelementptr inbounds %struct.target_stat, ptr %20, i32 0, i32 6
  %21 = load ptr, ptr %host_st.addr, align 8
  %st_rdev18 = getelementptr inbounds %struct.stat, ptr %21, i32 0, i32 7
  %22 = load i64, ptr %st_rdev18, align 8
  call void @stq_le_p(ptr noundef %st_rdev, i64 noundef %22)
  br label %do.end19

do.end19:                                         ; preds = %do.body17
  br label %do.body20

do.body20:                                        ; preds = %do.end19
  %23 = load ptr, ptr %target_st, align 8
  %st_size = getelementptr inbounds %struct.target_stat, ptr %23, i32 0, i32 8
  %24 = load ptr, ptr %host_st.addr, align 8
  %st_size21 = getelementptr inbounds %struct.stat, ptr %24, i32 0, i32 8
  %25 = load i64, ptr %st_size21, align 8
  call void @stq_le_p(ptr noundef %st_size, i64 noundef %25)
  br label %do.end22

do.end22:                                         ; preds = %do.body20
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  %26 = load ptr, ptr %target_st, align 8
  %st_blksize = getelementptr inbounds %struct.target_stat, ptr %26, i32 0, i32 9
  %27 = load ptr, ptr %host_st.addr, align 8
  %st_blksize24 = getelementptr inbounds %struct.stat, ptr %27, i32 0, i32 9
  %28 = load i64, ptr %st_blksize24, align 8
  %conv25 = trunc i64 %28 to i32
  call void @stl_le_p(ptr noundef %st_blksize, i32 noundef %conv25)
  br label %do.end26

do.end26:                                         ; preds = %do.body23
  br label %do.body27

do.body27:                                        ; preds = %do.end26
  %29 = load ptr, ptr %target_st, align 8
  %st_blocks = getelementptr inbounds %struct.target_stat, ptr %29, i32 0, i32 11
  %30 = load ptr, ptr %host_st.addr, align 8
  %st_blocks28 = getelementptr inbounds %struct.stat, ptr %30, i32 0, i32 10
  %31 = load i64, ptr %st_blocks28, align 8
  call void @stq_le_p(ptr noundef %st_blocks, i64 noundef %31)
  br label %do.end29

do.end29:                                         ; preds = %do.body27
  br label %do.body30

do.body30:                                        ; preds = %do.end29
  %32 = load ptr, ptr %target_st, align 8
  %target_st_atime = getelementptr inbounds %struct.target_stat, ptr %32, i32 0, i32 12
  %33 = load ptr, ptr %host_st.addr, align 8
  %st_atim = getelementptr inbounds %struct.stat, ptr %33, i32 0, i32 11
  %tv_sec = getelementptr inbounds %struct.timespec, ptr %st_atim, i32 0, i32 0
  %34 = load i64, ptr %tv_sec, align 8
  call void @stq_le_p(ptr noundef %target_st_atime, i64 noundef %34)
  br label %do.end31

do.end31:                                         ; preds = %do.body30
  br label %do.body32

do.body32:                                        ; preds = %do.end31
  %35 = load ptr, ptr %target_st, align 8
  %target_st_mtime = getelementptr inbounds %struct.target_stat, ptr %35, i32 0, i32 14
  %36 = load ptr, ptr %host_st.addr, align 8
  %st_mtim = getelementptr inbounds %struct.stat, ptr %36, i32 0, i32 12
  %tv_sec33 = getelementptr inbounds %struct.timespec, ptr %st_mtim, i32 0, i32 0
  %37 = load i64, ptr %tv_sec33, align 8
  call void @stq_le_p(ptr noundef %target_st_mtime, i64 noundef %37)
  br label %do.end34

do.end34:                                         ; preds = %do.body32
  br label %do.body35

do.body35:                                        ; preds = %do.end34
  %38 = load ptr, ptr %target_st, align 8
  %target_st_ctime = getelementptr inbounds %struct.target_stat, ptr %38, i32 0, i32 16
  %39 = load ptr, ptr %host_st.addr, align 8
  %st_ctim = getelementptr inbounds %struct.stat, ptr %39, i32 0, i32 13
  %tv_sec36 = getelementptr inbounds %struct.timespec, ptr %st_ctim, i32 0, i32 0
  %40 = load i64, ptr %tv_sec36, align 8
  call void @stq_le_p(ptr noundef %target_st_ctime, i64 noundef %40)
  br label %do.end37

do.end37:                                         ; preds = %do.body35
  br label %do.body38

do.body38:                                        ; preds = %do.end37
  %41 = load ptr, ptr %target_st, align 8
  %target_st_atime_nsec = getelementptr inbounds %struct.target_stat, ptr %41, i32 0, i32 13
  %42 = load ptr, ptr %host_st.addr, align 8
  %st_atim39 = getelementptr inbounds %struct.stat, ptr %42, i32 0, i32 11
  %tv_nsec = getelementptr inbounds %struct.timespec, ptr %st_atim39, i32 0, i32 1
  %43 = load i64, ptr %tv_nsec, align 8
  call void @stq_le_p(ptr noundef %target_st_atime_nsec, i64 noundef %43)
  br label %do.end40

do.end40:                                         ; preds = %do.body38
  br label %do.body41

do.body41:                                        ; preds = %do.end40
  %44 = load ptr, ptr %target_st, align 8
  %target_st_mtime_nsec = getelementptr inbounds %struct.target_stat, ptr %44, i32 0, i32 15
  %45 = load ptr, ptr %host_st.addr, align 8
  %st_mtim42 = getelementptr inbounds %struct.stat, ptr %45, i32 0, i32 12
  %tv_nsec43 = getelementptr inbounds %struct.timespec, ptr %st_mtim42, i32 0, i32 1
  %46 = load i64, ptr %tv_nsec43, align 8
  call void @stq_le_p(ptr noundef %target_st_mtime_nsec, i64 noundef %46)
  br label %do.end44

do.end44:                                         ; preds = %do.body41
  br label %do.body45

do.body45:                                        ; preds = %do.end44
  %47 = load ptr, ptr %target_st, align 8
  %target_st_ctime_nsec = getelementptr inbounds %struct.target_stat, ptr %47, i32 0, i32 17
  %48 = load ptr, ptr %host_st.addr, align 8
  %st_ctim46 = getelementptr inbounds %struct.stat, ptr %48, i32 0, i32 13
  %tv_nsec47 = getelementptr inbounds %struct.timespec, ptr %st_ctim46, i32 0, i32 1
  %49 = load i64, ptr %tv_nsec47, align 8
  call void @stq_le_p(ptr noundef %target_st_ctime_nsec, i64 noundef %49)
  br label %do.end48

do.end48:                                         ; preds = %do.body45
  %50 = load ptr, ptr %target_st, align 8
  %51 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %50, i64 noundef %51, i64 noundef 128)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end48, %if.then
  %52 = load i64, ptr %retval, align 8
  ret i64 %52
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_statx(i32 noundef %dirfd, ptr noundef %pathname, i32 noundef %flags, i32 noundef %mask, ptr noundef %statxbuf) #0 {
entry:
  %dirfd.addr = alloca i32, align 4
  %pathname.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %mask.addr = alloca i32, align 4
  %statxbuf.addr = alloca ptr, align 8
  store i32 %dirfd, ptr %dirfd.addr, align 4
  store ptr %pathname, ptr %pathname.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %mask, ptr %mask.addr, align 4
  store ptr %statxbuf, ptr %statxbuf.addr, align 8
  %0 = load i32, ptr %dirfd.addr, align 4
  %1 = load ptr, ptr %pathname.addr, align 8
  %2 = load i32, ptr %flags.addr, align 4
  %3 = load i32, ptr %mask.addr, align 4
  %4 = load ptr, ptr %statxbuf.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 332, i32 noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef %3, ptr noundef %4) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_statx(ptr noundef %host_stx, i64 noundef %target_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %host_stx.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %target_stx = alloca ptr, align 8
  store ptr %host_stx, ptr %host_stx.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 256, i1 noundef zeroext false)
  store ptr %call, ptr %target_stx, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %target_stx, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %1, i8 0, i64 256, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.end
  %2 = load ptr, ptr %target_stx, align 8
  %stx_mask = getelementptr inbounds %struct.target_statx, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %host_stx.addr, align 8
  %stx_mask1 = getelementptr inbounds %struct.target_statx, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %stx_mask1, align 8
  call void @stl_le_p(ptr noundef %stx_mask, i32 noundef %4)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %5 = load ptr, ptr %target_stx, align 8
  %stx_blksize = getelementptr inbounds %struct.target_statx, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %host_stx.addr, align 8
  %stx_blksize3 = getelementptr inbounds %struct.target_statx, ptr %6, i32 0, i32 1
  %7 = load i32, ptr %stx_blksize3, align 4
  call void @stl_le_p(ptr noundef %stx_blksize, i32 noundef %7)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  br label %do.body5

do.body5:                                         ; preds = %do.end4
  %8 = load ptr, ptr %target_stx, align 8
  %stx_attributes = getelementptr inbounds %struct.target_statx, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %host_stx.addr, align 8
  %stx_attributes6 = getelementptr inbounds %struct.target_statx, ptr %9, i32 0, i32 2
  %10 = load i64, ptr %stx_attributes6, align 8
  call void @stq_le_p(ptr noundef %stx_attributes, i64 noundef %10)
  br label %do.end7

do.end7:                                          ; preds = %do.body5
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %11 = load ptr, ptr %target_stx, align 8
  %stx_nlink = getelementptr inbounds %struct.target_statx, ptr %11, i32 0, i32 3
  %12 = load ptr, ptr %host_stx.addr, align 8
  %stx_nlink9 = getelementptr inbounds %struct.target_statx, ptr %12, i32 0, i32 3
  %13 = load i32, ptr %stx_nlink9, align 8
  call void @stl_le_p(ptr noundef %stx_nlink, i32 noundef %13)
  br label %do.end10

do.end10:                                         ; preds = %do.body8
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %14 = load ptr, ptr %target_stx, align 8
  %stx_uid = getelementptr inbounds %struct.target_statx, ptr %14, i32 0, i32 4
  %15 = load ptr, ptr %host_stx.addr, align 8
  %stx_uid12 = getelementptr inbounds %struct.target_statx, ptr %15, i32 0, i32 4
  %16 = load i32, ptr %stx_uid12, align 4
  call void @stl_le_p(ptr noundef %stx_uid, i32 noundef %16)
  br label %do.end13

do.end13:                                         ; preds = %do.body11
  br label %do.body14

do.body14:                                        ; preds = %do.end13
  %17 = load ptr, ptr %target_stx, align 8
  %stx_gid = getelementptr inbounds %struct.target_statx, ptr %17, i32 0, i32 5
  %18 = load ptr, ptr %host_stx.addr, align 8
  %stx_gid15 = getelementptr inbounds %struct.target_statx, ptr %18, i32 0, i32 5
  %19 = load i32, ptr %stx_gid15, align 8
  call void @stl_le_p(ptr noundef %stx_gid, i32 noundef %19)
  br label %do.end16

do.end16:                                         ; preds = %do.body14
  br label %do.body17

do.body17:                                        ; preds = %do.end16
  %20 = load ptr, ptr %target_stx, align 8
  %stx_mode = getelementptr inbounds %struct.target_statx, ptr %20, i32 0, i32 6
  %21 = load ptr, ptr %host_stx.addr, align 8
  %stx_mode18 = getelementptr inbounds %struct.target_statx, ptr %21, i32 0, i32 6
  %22 = load i16, ptr %stx_mode18, align 4
  call void @stw_le_p(ptr noundef %stx_mode, i16 noundef zeroext %22)
  br label %do.end19

do.end19:                                         ; preds = %do.body17
  br label %do.body20

do.body20:                                        ; preds = %do.end19
  %23 = load ptr, ptr %target_stx, align 8
  %stx_ino = getelementptr inbounds %struct.target_statx, ptr %23, i32 0, i32 8
  %24 = load ptr, ptr %host_stx.addr, align 8
  %stx_ino21 = getelementptr inbounds %struct.target_statx, ptr %24, i32 0, i32 8
  %25 = load i64, ptr %stx_ino21, align 8
  call void @stq_le_p(ptr noundef %stx_ino, i64 noundef %25)
  br label %do.end22

do.end22:                                         ; preds = %do.body20
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  %26 = load ptr, ptr %target_stx, align 8
  %stx_size = getelementptr inbounds %struct.target_statx, ptr %26, i32 0, i32 9
  %27 = load ptr, ptr %host_stx.addr, align 8
  %stx_size24 = getelementptr inbounds %struct.target_statx, ptr %27, i32 0, i32 9
  %28 = load i64, ptr %stx_size24, align 8
  call void @stq_le_p(ptr noundef %stx_size, i64 noundef %28)
  br label %do.end25

do.end25:                                         ; preds = %do.body23
  br label %do.body26

do.body26:                                        ; preds = %do.end25
  %29 = load ptr, ptr %target_stx, align 8
  %stx_blocks = getelementptr inbounds %struct.target_statx, ptr %29, i32 0, i32 10
  %30 = load ptr, ptr %host_stx.addr, align 8
  %stx_blocks27 = getelementptr inbounds %struct.target_statx, ptr %30, i32 0, i32 10
  %31 = load i64, ptr %stx_blocks27, align 8
  call void @stq_le_p(ptr noundef %stx_blocks, i64 noundef %31)
  br label %do.end28

do.end28:                                         ; preds = %do.body26
  br label %do.body29

do.body29:                                        ; preds = %do.end28
  %32 = load ptr, ptr %target_stx, align 8
  %stx_attributes_mask = getelementptr inbounds %struct.target_statx, ptr %32, i32 0, i32 11
  %33 = load ptr, ptr %host_stx.addr, align 8
  %stx_attributes_mask30 = getelementptr inbounds %struct.target_statx, ptr %33, i32 0, i32 11
  %34 = load i64, ptr %stx_attributes_mask30, align 8
  call void @stq_le_p(ptr noundef %stx_attributes_mask, i64 noundef %34)
  br label %do.end31

do.end31:                                         ; preds = %do.body29
  br label %do.body32

do.body32:                                        ; preds = %do.end31
  %35 = load ptr, ptr %target_stx, align 8
  %stx_atime = getelementptr inbounds %struct.target_statx, ptr %35, i32 0, i32 12
  %tv_sec = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_atime, i32 0, i32 0
  %36 = load ptr, ptr %host_stx.addr, align 8
  %stx_atime33 = getelementptr inbounds %struct.target_statx, ptr %36, i32 0, i32 12
  %tv_sec34 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_atime33, i32 0, i32 0
  %37 = load i64, ptr %tv_sec34, align 8
  call void @stq_le_p(ptr noundef %tv_sec, i64 noundef %37)
  br label %do.end35

do.end35:                                         ; preds = %do.body32
  br label %do.body36

do.body36:                                        ; preds = %do.end35
  %38 = load ptr, ptr %target_stx, align 8
  %stx_atime37 = getelementptr inbounds %struct.target_statx, ptr %38, i32 0, i32 12
  %tv_nsec = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_atime37, i32 0, i32 1
  %39 = load ptr, ptr %host_stx.addr, align 8
  %stx_atime38 = getelementptr inbounds %struct.target_statx, ptr %39, i32 0, i32 12
  %tv_nsec39 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_atime38, i32 0, i32 1
  %40 = load i32, ptr %tv_nsec39, align 8
  call void @stl_le_p(ptr noundef %tv_nsec, i32 noundef %40)
  br label %do.end40

do.end40:                                         ; preds = %do.body36
  br label %do.body41

do.body41:                                        ; preds = %do.end40
  %41 = load ptr, ptr %target_stx, align 8
  %stx_btime = getelementptr inbounds %struct.target_statx, ptr %41, i32 0, i32 13
  %tv_sec42 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_btime, i32 0, i32 0
  %42 = load ptr, ptr %host_stx.addr, align 8
  %stx_btime43 = getelementptr inbounds %struct.target_statx, ptr %42, i32 0, i32 13
  %tv_sec44 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_btime43, i32 0, i32 0
  %43 = load i64, ptr %tv_sec44, align 8
  call void @stq_le_p(ptr noundef %tv_sec42, i64 noundef %43)
  br label %do.end45

do.end45:                                         ; preds = %do.body41
  br label %do.body46

do.body46:                                        ; preds = %do.end45
  %44 = load ptr, ptr %target_stx, align 8
  %stx_btime47 = getelementptr inbounds %struct.target_statx, ptr %44, i32 0, i32 13
  %tv_nsec48 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_btime47, i32 0, i32 1
  %45 = load ptr, ptr %host_stx.addr, align 8
  %stx_btime49 = getelementptr inbounds %struct.target_statx, ptr %45, i32 0, i32 13
  %tv_nsec50 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_btime49, i32 0, i32 1
  %46 = load i32, ptr %tv_nsec50, align 8
  call void @stl_le_p(ptr noundef %tv_nsec48, i32 noundef %46)
  br label %do.end51

do.end51:                                         ; preds = %do.body46
  br label %do.body52

do.body52:                                        ; preds = %do.end51
  %47 = load ptr, ptr %target_stx, align 8
  %stx_ctime = getelementptr inbounds %struct.target_statx, ptr %47, i32 0, i32 14
  %tv_sec53 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_ctime, i32 0, i32 0
  %48 = load ptr, ptr %host_stx.addr, align 8
  %stx_ctime54 = getelementptr inbounds %struct.target_statx, ptr %48, i32 0, i32 14
  %tv_sec55 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_ctime54, i32 0, i32 0
  %49 = load i64, ptr %tv_sec55, align 8
  call void @stq_le_p(ptr noundef %tv_sec53, i64 noundef %49)
  br label %do.end56

do.end56:                                         ; preds = %do.body52
  br label %do.body57

do.body57:                                        ; preds = %do.end56
  %50 = load ptr, ptr %target_stx, align 8
  %stx_ctime58 = getelementptr inbounds %struct.target_statx, ptr %50, i32 0, i32 14
  %tv_nsec59 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_ctime58, i32 0, i32 1
  %51 = load ptr, ptr %host_stx.addr, align 8
  %stx_ctime60 = getelementptr inbounds %struct.target_statx, ptr %51, i32 0, i32 14
  %tv_nsec61 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_ctime60, i32 0, i32 1
  %52 = load i32, ptr %tv_nsec61, align 8
  call void @stl_le_p(ptr noundef %tv_nsec59, i32 noundef %52)
  br label %do.end62

do.end62:                                         ; preds = %do.body57
  br label %do.body63

do.body63:                                        ; preds = %do.end62
  %53 = load ptr, ptr %target_stx, align 8
  %stx_mtime = getelementptr inbounds %struct.target_statx, ptr %53, i32 0, i32 15
  %tv_sec64 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_mtime, i32 0, i32 0
  %54 = load ptr, ptr %host_stx.addr, align 8
  %stx_mtime65 = getelementptr inbounds %struct.target_statx, ptr %54, i32 0, i32 15
  %tv_sec66 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_mtime65, i32 0, i32 0
  %55 = load i64, ptr %tv_sec66, align 8
  call void @stq_le_p(ptr noundef %tv_sec64, i64 noundef %55)
  br label %do.end67

do.end67:                                         ; preds = %do.body63
  br label %do.body68

do.body68:                                        ; preds = %do.end67
  %56 = load ptr, ptr %target_stx, align 8
  %stx_mtime69 = getelementptr inbounds %struct.target_statx, ptr %56, i32 0, i32 15
  %tv_nsec70 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_mtime69, i32 0, i32 1
  %57 = load ptr, ptr %host_stx.addr, align 8
  %stx_mtime71 = getelementptr inbounds %struct.target_statx, ptr %57, i32 0, i32 15
  %tv_nsec72 = getelementptr inbounds %struct.target_statx_timestamp, ptr %stx_mtime71, i32 0, i32 1
  %58 = load i32, ptr %tv_nsec72, align 8
  call void @stl_le_p(ptr noundef %tv_nsec70, i32 noundef %58)
  br label %do.end73

do.end73:                                         ; preds = %do.body68
  br label %do.body74

do.body74:                                        ; preds = %do.end73
  %59 = load ptr, ptr %target_stx, align 8
  %stx_rdev_major = getelementptr inbounds %struct.target_statx, ptr %59, i32 0, i32 16
  %60 = load ptr, ptr %host_stx.addr, align 8
  %stx_rdev_major75 = getelementptr inbounds %struct.target_statx, ptr %60, i32 0, i32 16
  %61 = load i32, ptr %stx_rdev_major75, align 8
  call void @stl_le_p(ptr noundef %stx_rdev_major, i32 noundef %61)
  br label %do.end76

do.end76:                                         ; preds = %do.body74
  br label %do.body77

do.body77:                                        ; preds = %do.end76
  %62 = load ptr, ptr %target_stx, align 8
  %stx_rdev_minor = getelementptr inbounds %struct.target_statx, ptr %62, i32 0, i32 17
  %63 = load ptr, ptr %host_stx.addr, align 8
  %stx_rdev_minor78 = getelementptr inbounds %struct.target_statx, ptr %63, i32 0, i32 17
  %64 = load i32, ptr %stx_rdev_minor78, align 4
  call void @stl_le_p(ptr noundef %stx_rdev_minor, i32 noundef %64)
  br label %do.end79

do.end79:                                         ; preds = %do.body77
  br label %do.body80

do.body80:                                        ; preds = %do.end79
  %65 = load ptr, ptr %target_stx, align 8
  %stx_dev_major = getelementptr inbounds %struct.target_statx, ptr %65, i32 0, i32 18
  %66 = load ptr, ptr %host_stx.addr, align 8
  %stx_dev_major81 = getelementptr inbounds %struct.target_statx, ptr %66, i32 0, i32 18
  %67 = load i32, ptr %stx_dev_major81, align 8
  call void @stl_le_p(ptr noundef %stx_dev_major, i32 noundef %67)
  br label %do.end82

do.end82:                                         ; preds = %do.body80
  br label %do.body83

do.body83:                                        ; preds = %do.end82
  %68 = load ptr, ptr %target_stx, align 8
  %stx_dev_minor = getelementptr inbounds %struct.target_statx, ptr %68, i32 0, i32 19
  %69 = load ptr, ptr %host_stx.addr, align 8
  %stx_dev_minor84 = getelementptr inbounds %struct.target_statx, ptr %69, i32 0, i32 19
  %70 = load i32, ptr %stx_dev_minor84, align 4
  call void @stl_le_p(ptr noundef %stx_dev_minor, i32 noundef %70)
  br label %do.end85

do.end85:                                         ; preds = %do.body83
  %71 = load ptr, ptr %target_stx, align 8
  %72 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %71, i64 noundef %72, i64 noundef 256)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end85, %if.then
  %73 = load i64, ptr %retval, align 8
  ret i64 %73
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @high2lowuid(i32 noundef %uid) #0 {
entry:
  %uid.addr = alloca i32, align 4
  store i32 %uid, ptr %uid.addr, align 4
  %0 = load i32, ptr %uid.addr, align 4
  ret i32 %0
}

; Function Attrs: nounwind
declare i32 @getuid() #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @high2lowgid(i32 noundef %gid) #0 {
entry:
  %gid.addr = alloca i32, align 4
  store i32 %gid, ptr %gid.addr, align 4
  %0 = load i32, ptr %gid.addr, align 4
  ret i32 %0
}

; Function Attrs: nounwind
declare i32 @getgid() #2

; Function Attrs: nounwind
declare i32 @geteuid() #2

; Function Attrs: nounwind
declare i32 @getegid() #2

; Function Attrs: nounwind
declare i32 @setreuid(i32 noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @low2highuid(i32 noundef %uid) #0 {
entry:
  %uid.addr = alloca i32, align 4
  store i32 %uid, ptr %uid.addr, align 4
  %0 = load i32, ptr %uid.addr, align 4
  ret i32 %0
}

; Function Attrs: nounwind
declare i32 @setregid(i32 noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @low2highgid(i32 noundef %gid) #0 {
entry:
  %gid.addr = alloca i32, align 4
  store i32 %gid, ptr %gid.addr, align 4
  %0 = load i32, ptr %gid.addr, align 4
  ret i32 %0
}

; Function Attrs: allocsize(0,1)
declare noalias ptr @g_try_malloc_n(i64 noundef, i64 noundef) #9

; Function Attrs: nounwind
declare i32 @getgroups(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tswapid(i32 noundef %id) #0 {
entry:
  %id.addr = alloca i32, align 4
  store i32 %id, ptr %id.addr, align 4
  %0 = load i32, ptr %id.addr, align 4
  %call = call i32 @tswap32(i32 noundef %0)
  ret i32 %call
}

; Function Attrs: nounwind
declare i32 @setgroups(i64 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @fchown(i32 noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @fchownat(i32 noundef, ptr noundef, i32 noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_setresuid(i32 noundef %ruid, i32 noundef %euid, i32 noundef %suid) #0 {
entry:
  %ruid.addr = alloca i32, align 4
  %euid.addr = alloca i32, align 4
  %suid.addr = alloca i32, align 4
  store i32 %ruid, ptr %ruid.addr, align 4
  store i32 %euid, ptr %euid.addr, align 4
  store i32 %suid, ptr %suid.addr, align 4
  %0 = load i32, ptr %ruid.addr, align 4
  %1 = load i32, ptr %euid.addr, align 4
  %2 = load i32, ptr %suid.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 117, i32 noundef %0, i32 noundef %1, i32 noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @getresuid(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_setresgid(i32 noundef %rgid, i32 noundef %egid, i32 noundef %sgid) #0 {
entry:
  %rgid.addr = alloca i32, align 4
  %egid.addr = alloca i32, align 4
  %sgid.addr = alloca i32, align 4
  store i32 %rgid, ptr %rgid.addr, align 4
  store i32 %egid, ptr %egid.addr, align 4
  store i32 %sgid, ptr %sgid.addr, align 4
  %0 = load i32, ptr %rgid.addr, align 4
  %1 = load i32, ptr %egid.addr, align 4
  %2 = load i32, ptr %sgid.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 119, i32 noundef %0, i32 noundef %1, i32 noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @getresgid(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_setuid(i32 noundef %uid) #0 {
entry:
  %uid.addr = alloca i32, align 4
  store i32 %uid, ptr %uid.addr, align 4
  %0 = load i32, ptr %uid.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 105, i32 noundef %0) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_setgid(i32 noundef %gid) #0 {
entry:
  %gid.addr = alloca i32, align 4
  store i32 %gid, ptr %gid.addr, align 4
  %0 = load i32, ptr %gid.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 106, i32 noundef %0) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @setfsuid(i32 noundef) #2

; Function Attrs: nounwind
declare i32 @setfsgid(i32 noundef) #2

; Function Attrs: nounwind
declare i32 @mincore(ptr noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @posix_fadvise64(i32 noundef, i64 noundef, i64 noundef, i32 noundef) #2

declare i64 @target_madvise(i64 noundef, i64 noundef, i32 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_gettid() #0 {
entry:
  %call = call i64 (i64, ...) @syscall(i64 noundef 186) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i64 @readahead(i32 noundef, i64 noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i64 @listxattr(ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i64 @llistxattr(ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i64 @flistxattr(i32 noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i32 @setxattr(ptr noundef, ptr noundef, ptr noundef, i64 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @lsetxattr(ptr noundef, ptr noundef, ptr noundef, i64 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @fsetxattr(i32 noundef, ptr noundef, ptr noundef, i64 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i64 @getxattr(ptr noundef, ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i64 @lgetxattr(ptr noundef, ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i64 @fgetxattr(i32 noundef, ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i32 @removexattr(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @lremovexattr(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @fremovexattr(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @clock_settime(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @clock_gettime(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @clock_getres(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_clock_nanosleep(i32 noundef %clock, i32 noundef %flags, ptr noundef %req, ptr noundef %rem) #0 {
entry:
  %clock.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %req.addr = alloca ptr, align 8
  %rem.addr = alloca ptr, align 8
  store i32 %clock, ptr %clock.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %req, ptr %req.addr, align 8
  store ptr %rem, ptr %rem.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %clock.addr, align 4
  %4 = load i32, ptr %flags.addr, align 4
  %5 = load ptr, ptr %req.addr, align 8
  %6 = load ptr, ptr %rem.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 230, i32 noundef %3, i32 noundef %4, ptr noundef %5, ptr noundef %6)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_tkill(i32 noundef %tid, i32 noundef %sig) #0 {
entry:
  %tid.addr = alloca i32, align 4
  %sig.addr = alloca i32, align 4
  store i32 %tid, ptr %tid.addr, align 4
  store i32 %sig, ptr %sig.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %tid.addr, align 4
  %4 = load i32, ptr %sig.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 200, i32 noundef %3, i32 noundef %4)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_tgkill(i32 noundef %tgid, i32 noundef %pid, i32 noundef %sig) #0 {
entry:
  %tgid.addr = alloca i32, align 4
  %pid.addr = alloca i32, align 4
  %sig.addr = alloca i32, align 4
  store i32 %tgid, ptr %tgid.addr, align 4
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %sig, ptr %sig.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %tgid.addr, align 4
  %4 = load i32, ptr %pid.addr, align 4
  %5 = load i32, ptr %sig.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 234, i32 noundef %3, i32 noundef %4, i32 noundef %5)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_utimensat(i32 noundef %dirfd, ptr noundef %pathname, ptr noundef %tsp, i32 noundef %flags) #0 {
entry:
  %dirfd.addr = alloca i32, align 4
  %pathname.addr = alloca ptr, align 8
  %tsp.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store i32 %dirfd, ptr %dirfd.addr, align 4
  store ptr %pathname, ptr %pathname.addr, align 8
  store ptr %tsp, ptr %tsp.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %dirfd.addr, align 4
  %1 = load ptr, ptr %pathname.addr, align 8
  %2 = load ptr, ptr %tsp.addr, align 8
  %3 = load i32, ptr %flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 280, i32 noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef %3) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @do_futex(ptr noundef %cpu, i1 noundef zeroext %time64, i64 noundef %uaddr, i32 noundef %op, i32 noundef %val, i64 noundef %timeout, i64 noundef %uaddr2, i32 noundef %val3) #0 {
entry:
  %retval = alloca i32, align 4
  %cpu.addr = alloca ptr, align 8
  %time64.addr = alloca i8, align 1
  %uaddr.addr = alloca i64, align 8
  %op.addr = alloca i32, align 4
  %val.addr = alloca i32, align 4
  %timeout.addr = alloca i64, align 8
  %uaddr2.addr = alloca i64, align 8
  %val3.addr = alloca i32, align 4
  %ts = alloca %struct.timespec, align 8
  %pts = alloca ptr, align 8
  %haddr2 = alloca ptr, align 8
  %base_op = alloca i32, align 4
  store ptr %cpu, ptr %cpu.addr, align 8
  %frombool = zext i1 %time64 to i8
  store i8 %frombool, ptr %time64.addr, align 1
  store i64 %uaddr, ptr %uaddr.addr, align 8
  store i32 %op, ptr %op.addr, align 4
  store i32 %val, ptr %val.addr, align 4
  store i64 %timeout, ptr %timeout.addr, align 8
  store i64 %uaddr2, ptr %uaddr2.addr, align 8
  store i32 %val3, ptr %val3.addr, align 4
  store ptr null, ptr %pts, align 8
  store ptr null, ptr %haddr2, align 8
  %0 = load i32, ptr %op.addr, align 4
  %and = and i32 %0, -385
  store i32 %and, ptr %base_op, align 4
  %1 = load i32, ptr %base_op, align 4
  switch i32 %1, label %sw.default [
    i32 0, label %sw.bb
    i32 9, label %sw.bb
    i32 11, label %sw.bb1
    i32 6, label %sw.bb4
    i32 13, label %sw.bb4
    i32 1, label %sw.bb5
    i32 10, label %sw.bb5
    i32 8, label %sw.bb5
    i32 7, label %sw.bb5
    i32 2, label %sw.bb6
    i32 4, label %sw.bb8
    i32 12, label %sw.bb8
    i32 3, label %sw.bb10
    i32 5, label %sw.bb10
  ]

sw.bb:                                            ; preds = %entry, %entry
  %2 = load i32, ptr %val.addr, align 4
  %call = call i32 @tswap32(i32 noundef %2)
  store i32 %call, ptr %val.addr, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %3 = load i32, ptr %val.addr, align 4
  %call2 = call i32 @tswap32(i32 noundef %3)
  store i32 %call2, ptr %val.addr, align 4
  %4 = load ptr, ptr %cpu.addr, align 8
  %5 = load i64, ptr %uaddr2.addr, align 8
  %call3 = call ptr @g2h(ptr noundef %4, i64 noundef %5)
  store ptr %call3, ptr %haddr2, align 8
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry, %entry
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry, %entry, %entry, %entry
  store i64 0, ptr %timeout.addr, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %6 = load i32, ptr %val.addr, align 4
  %call7 = call i32 @target_to_host_signal(i32 noundef %6)
  store i32 %call7, ptr %val.addr, align 4
  store i64 0, ptr %timeout.addr, align 8
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry, %entry
  %7 = load i32, ptr %val3.addr, align 4
  %call9 = call i32 @tswap32(i32 noundef %7)
  store i32 %call9, ptr %val3.addr, align 4
  br label %sw.bb10

sw.bb10:                                          ; preds = %sw.bb8, %entry, %entry
  %8 = load i64, ptr %timeout.addr, align 8
  %9 = inttoptr i64 %8 to ptr
  store ptr %9, ptr %pts, align 8
  store i64 0, ptr %timeout.addr, align 8
  %10 = load ptr, ptr %cpu.addr, align 8
  %11 = load i64, ptr %uaddr2.addr, align 8
  %call11 = call ptr @g2h(ptr noundef %10, i64 noundef %11)
  store ptr %call11, ptr %haddr2, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i32 -38, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb10, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb1, %sw.bb
  %12 = load i64, ptr %timeout.addr, align 8
  %tobool = icmp ne i64 %12, 0
  br i1 %tobool, label %if.then, label %if.end18

if.then:                                          ; preds = %sw.epilog
  store ptr %ts, ptr %pts, align 8
  %13 = load i8, ptr %time64.addr, align 1
  %tobool12 = trunc i8 %13 to i1
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %14 = load ptr, ptr %pts, align 8
  %15 = load i64, ptr %timeout.addr, align 8
  %call13 = call i64 @target_to_host_timespec64(ptr noundef %14, i64 noundef %15)
  %tobool14 = icmp ne i64 %call13, 0
  br i1 %tobool14, label %if.then17, label %if.end

cond.false:                                       ; preds = %if.then
  %16 = load ptr, ptr %pts, align 8
  %17 = load i64, ptr %timeout.addr, align 8
  %call15 = call i64 @target_to_host_timespec(ptr noundef %16, i64 noundef %17)
  %tobool16 = icmp ne i64 %call15, 0
  br i1 %tobool16, label %if.then17, label %if.end

if.then17:                                        ; preds = %cond.false, %cond.true
  store i32 -14, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.false, %cond.true
  br label %if.end18

if.end18:                                         ; preds = %if.end, %sw.epilog
  %18 = load ptr, ptr %cpu.addr, align 8
  %19 = load i64, ptr %uaddr.addr, align 8
  %call19 = call ptr @g2h(ptr noundef %18, i64 noundef %19)
  %20 = load i32, ptr %op.addr, align 4
  %21 = load i32, ptr %val.addr, align 4
  %22 = load ptr, ptr %pts, align 8
  %23 = load ptr, ptr %haddr2, align 8
  %24 = load i32, ptr %val3.addr, align 4
  %call20 = call i32 @do_safe_futex(ptr noundef %call19, i32 noundef %20, i32 noundef %21, ptr noundef %22, ptr noundef %23, i32 noundef %24)
  store i32 %call20, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then17, %sw.default
  %25 = load i32, ptr %retval, align 4
  ret i32 %25
}

; Function Attrs: nounwind
declare i32 @inotify_init1(i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @fd_trans_register(i32 noundef %fd, ptr noundef %trans) #0 {
entry:
  %x.addr.i = alloca ptr, align 8
  %lockable.addr.i = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %trans.addr = alloca ptr, align 8
  %qemu_lockable_auto3 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.QemuLockable, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %trans, ptr %trans.addr, align 8
  %object = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 0
  store ptr @target_fd_trans_lock, ptr %object, align 8
  %lock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 1
  store ptr @qemu_mutex_lock, ptr %lock, align 8
  %unlock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 2
  store ptr @qemu_mutex_unlock, ptr %unlock, align 8
  store ptr @target_fd_trans_lock, ptr %x.addr.i, align 8
  store ptr %.compoundliteral, ptr %lockable.addr.i, align 8
  %0 = load ptr, ptr %x.addr.i, align 8
  %tobool.i = icmp ne ptr %0, null
  br i1 %tobool.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %entry
  %1 = load ptr, ptr %lockable.addr.i, align 8
  br label %qemu_make_lockable.exit

cond.false.i:                                     ; preds = %entry
  br label %qemu_make_lockable.exit

qemu_make_lockable.exit:                          ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi ptr [ %1, %cond.true.i ], [ null, %cond.false.i ]
  %call1 = call ptr @qemu_lockable_auto_lock(ptr noundef %cond.i)
  store ptr %call1, ptr %qemu_lockable_auto3, align 8
  %2 = load i32, ptr %fd.addr, align 4
  %3 = load ptr, ptr %trans.addr, align 8
  call void @internal_fd_trans_register_unsafe(i32 noundef %2, ptr noundef %3)
  call void @glib_autoptr_cleanup_QemuLockable(ptr noundef %qemu_lockable_auto3)
  ret void
}

; Function Attrs: nounwind
declare i32 @inotify_add_watch(i32 noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @inotify_rm_watch(i32 noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_from_user_mq_attr(ptr noundef %attr, i64 noundef %target_mq_attr_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %attr.addr = alloca ptr, align 8
  %target_mq_attr_addr.addr = alloca i64, align 8
  %target_mq_attr = alloca ptr, align 8
  store ptr %attr, ptr %attr.addr, align 8
  store i64 %target_mq_attr_addr, ptr %target_mq_attr_addr.addr, align 8
  %0 = load i64, ptr %target_mq_attr_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 32, i1 noundef zeroext true)
  store ptr %call, ptr %target_mq_attr, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_mq_attr, align 8
  %mq_flags = getelementptr inbounds %struct.target_mq_attr, ptr %1, i32 0, i32 0
  %call1 = call i64 @ldq_le_p(ptr noundef %mq_flags)
  %2 = load ptr, ptr %attr.addr, align 8
  %mq_flags2 = getelementptr inbounds %struct.mq_attr, ptr %2, i32 0, i32 0
  store i64 %call1, ptr %mq_flags2, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body3

do.body3:                                         ; preds = %do.end
  %3 = load ptr, ptr %target_mq_attr, align 8
  %mq_maxmsg = getelementptr inbounds %struct.target_mq_attr, ptr %3, i32 0, i32 1
  %call4 = call i64 @ldq_le_p(ptr noundef %mq_maxmsg)
  %4 = load ptr, ptr %attr.addr, align 8
  %mq_maxmsg5 = getelementptr inbounds %struct.mq_attr, ptr %4, i32 0, i32 1
  store i64 %call4, ptr %mq_maxmsg5, align 8
  br label %do.end6

do.end6:                                          ; preds = %do.body3
  br label %do.body7

do.body7:                                         ; preds = %do.end6
  %5 = load ptr, ptr %target_mq_attr, align 8
  %mq_msgsize = getelementptr inbounds %struct.target_mq_attr, ptr %5, i32 0, i32 2
  %call8 = call i64 @ldq_le_p(ptr noundef %mq_msgsize)
  %6 = load ptr, ptr %attr.addr, align 8
  %mq_msgsize9 = getelementptr inbounds %struct.mq_attr, ptr %6, i32 0, i32 2
  store i64 %call8, ptr %mq_msgsize9, align 8
  br label %do.end10

do.end10:                                         ; preds = %do.body7
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %7 = load ptr, ptr %target_mq_attr, align 8
  %mq_curmsgs = getelementptr inbounds %struct.target_mq_attr, ptr %7, i32 0, i32 3
  %call12 = call i64 @ldq_le_p(ptr noundef %mq_curmsgs)
  %8 = load ptr, ptr %attr.addr, align 8
  %mq_curmsgs13 = getelementptr inbounds %struct.mq_attr, ptr %8, i32 0, i32 3
  store i64 %call12, ptr %mq_curmsgs13, align 8
  br label %do.end14

do.end14:                                         ; preds = %do.body11
  %9 = load ptr, ptr %target_mq_attr, align 8
  %10 = load i64, ptr %target_mq_attr_addr.addr, align 8
  call void @unlock_user(ptr noundef %9, i64 noundef %10, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end14, %if.then
  %11 = load i64, ptr %retval, align 8
  ret i64 %11
}

; Function Attrs: nounwind
declare i32 @mq_open(ptr noundef, i32 noundef, ...) #2

; Function Attrs: nounwind
declare i32 @mq_unlink(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_mq_timedsend(i32 noundef %mqdes, ptr noundef %msg_ptr, i64 noundef %len, i32 noundef %prio, ptr noundef %timeout) #0 {
entry:
  %mqdes.addr = alloca i32, align 4
  %msg_ptr.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %prio.addr = alloca i32, align 4
  %timeout.addr = alloca ptr, align 8
  store i32 %mqdes, ptr %mqdes.addr, align 4
  store ptr %msg_ptr, ptr %msg_ptr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 %prio, ptr %prio.addr, align 4
  store ptr %timeout, ptr %timeout.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %mqdes.addr, align 4
  %4 = load ptr, ptr %msg_ptr.addr, align 8
  %5 = load i64, ptr %len.addr, align 8
  %6 = load i32, ptr %prio.addr, align 4
  %7 = load ptr, ptr %timeout.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 242, i32 noundef %3, ptr noundef %4, i64 noundef %5, i32 noundef %6, ptr noundef %7)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_mq_timedreceive(i32 noundef %mqdes, ptr noundef %msg_ptr, i64 noundef %len, ptr noundef %prio, ptr noundef %timeout) #0 {
entry:
  %mqdes.addr = alloca i32, align 4
  %msg_ptr.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %prio.addr = alloca ptr, align 8
  %timeout.addr = alloca ptr, align 8
  store i32 %mqdes, ptr %mqdes.addr, align 4
  store ptr %msg_ptr, ptr %msg_ptr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr %prio, ptr %prio.addr, align 8
  store ptr %timeout, ptr %timeout.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %mqdes.addr, align 4
  %4 = load ptr, ptr %msg_ptr.addr, align 8
  %5 = load i64, ptr %len.addr, align 8
  %6 = load ptr, ptr %prio.addr, align 8
  %7 = load ptr, ptr %timeout.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 243, i32 noundef %3, ptr noundef %4, i64 noundef %5, ptr noundef %6, ptr noundef %7)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @mq_setattr(i32 noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @mq_getattr(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_to_user_mq_attr(i64 noundef %target_mq_attr_addr, ptr noundef %attr) #0 {
entry:
  %retval = alloca i64, align 8
  %target_mq_attr_addr.addr = alloca i64, align 8
  %attr.addr = alloca ptr, align 8
  %target_mq_attr = alloca ptr, align 8
  store i64 %target_mq_attr_addr, ptr %target_mq_attr_addr.addr, align 8
  store ptr %attr, ptr %attr.addr, align 8
  %0 = load i64, ptr %target_mq_attr_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 32, i1 noundef zeroext false)
  store ptr %call, ptr %target_mq_attr, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_mq_attr, align 8
  %mq_flags = getelementptr inbounds %struct.target_mq_attr, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %attr.addr, align 8
  %mq_flags1 = getelementptr inbounds %struct.mq_attr, ptr %2, i32 0, i32 0
  %3 = load i64, ptr %mq_flags1, align 8
  call void @stq_le_p(ptr noundef %mq_flags, i64 noundef %3)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %4 = load ptr, ptr %target_mq_attr, align 8
  %mq_maxmsg = getelementptr inbounds %struct.target_mq_attr, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %attr.addr, align 8
  %mq_maxmsg3 = getelementptr inbounds %struct.mq_attr, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %mq_maxmsg3, align 8
  call void @stq_le_p(ptr noundef %mq_maxmsg, i64 noundef %6)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  br label %do.body5

do.body5:                                         ; preds = %do.end4
  %7 = load ptr, ptr %target_mq_attr, align 8
  %mq_msgsize = getelementptr inbounds %struct.target_mq_attr, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %attr.addr, align 8
  %mq_msgsize6 = getelementptr inbounds %struct.mq_attr, ptr %8, i32 0, i32 2
  %9 = load i64, ptr %mq_msgsize6, align 8
  call void @stq_le_p(ptr noundef %mq_msgsize, i64 noundef %9)
  br label %do.end7

do.end7:                                          ; preds = %do.body5
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %10 = load ptr, ptr %target_mq_attr, align 8
  %mq_curmsgs = getelementptr inbounds %struct.target_mq_attr, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %attr.addr, align 8
  %mq_curmsgs9 = getelementptr inbounds %struct.mq_attr, ptr %11, i32 0, i32 3
  %12 = load i64, ptr %mq_curmsgs9, align 8
  call void @stq_le_p(ptr noundef %mq_curmsgs, i64 noundef %12)
  br label %do.end10

do.end10:                                         ; preds = %do.body8
  %13 = load ptr, ptr %target_mq_attr, align 8
  %14 = load i64, ptr %target_mq_attr_addr.addr, align 8
  call void @unlock_user(ptr noundef %13, i64 noundef %14, i64 noundef 32)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end10, %if.then
  %15 = load i64, ptr %retval, align 8
  ret i64 %15
}

declare i64 @tee(i32 noundef, i32 noundef, i64 noundef, i32 noundef) #3

declare i64 @splice(i32 noundef, ptr noundef, i32 noundef, ptr noundef, i64 noundef, i32 noundef) #3

declare i64 @vmsplice(i32 noundef, ptr noundef, i64 noundef, i32 noundef) #3

; Function Attrs: nounwind
declare i32 @eventfd(i32 noundef, i32 noundef) #2

declare i32 @fallocate64(i32 noundef, i32 noundef, i64 noundef, i64 noundef) #3

declare i32 @sync_file_range(i32 noundef, i64 noundef, i64 noundef, i32 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_signalfd4(i32 noundef %fd, i64 noundef %mask, i32 noundef %flags) #0 {
entry:
  %retval = alloca i64, align 8
  %fd.addr = alloca i32, align 4
  %mask.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %host_flags = alloca i32, align 4
  %target_mask = alloca ptr, align 8
  %host_mask = alloca %struct.__sigset_t, align 8
  %ret = alloca i64, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %mask, ptr %mask.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %and = and i32 %0, -526337
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -22, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %mask.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %1, i64 noundef 8, i1 noundef zeroext true)
  store ptr %call, ptr %target_mask, align 8
  %tobool1 = icmp ne ptr %call, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %2 = load ptr, ptr %target_mask, align 8
  call void @target_to_host_sigset(ptr noundef %host_mask, ptr noundef %2)
  %3 = load i32, ptr %flags.addr, align 4
  %call4 = call i32 @target_to_host_bitmask_len(i32 noundef %3, ptr noundef @fcntl_flags_tbl, i64 noundef 19)
  store i32 %call4, ptr %host_flags, align 4
  %4 = load i32, ptr %fd.addr, align 4
  %5 = load i32, ptr %host_flags, align 4
  %call5 = call i32 @signalfd(i32 noundef %4, ptr noundef %host_mask, i32 noundef %5) #14
  %conv = sext i32 %call5 to i64
  %call6 = call i64 @get_errno(i64 noundef %conv)
  store i64 %call6, ptr %ret, align 8
  %6 = load i64, ptr %ret, align 8
  %cmp = icmp sge i64 %6, 0
  br i1 %cmp, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end3
  %7 = load i64, ptr %ret, align 8
  %conv9 = trunc i64 %7 to i32
  call void @fd_trans_register(i32 noundef %conv9, ptr noundef @target_signalfd_trans)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end3
  %8 = load ptr, ptr %target_mask, align 8
  %9 = load i64, ptr %mask.addr, align 8
  call void @unlock_user(ptr noundef %8, i64 noundef %9, i64 noundef 0)
  %10 = load i64, ptr %ret, align 8
  store i64 %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.then2, %if.then
  %11 = load i64, ptr %retval, align 8
  ret i64 %11
}

; Function Attrs: nounwind
declare i32 @epoll_create1(i32 noundef) #2

; Function Attrs: nounwind
declare i32 @epoll_ctl(i32 noundef, i32 noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_epoll_pwait(i32 noundef %epfd, ptr noundef %events, i32 noundef %maxevents, i32 noundef %timeout, ptr noundef %sigmask, i64 noundef %sigsetsize) #0 {
entry:
  %epfd.addr = alloca i32, align 4
  %events.addr = alloca ptr, align 8
  %maxevents.addr = alloca i32, align 4
  %timeout.addr = alloca i32, align 4
  %sigmask.addr = alloca ptr, align 8
  %sigsetsize.addr = alloca i64, align 8
  store i32 %epfd, ptr %epfd.addr, align 4
  store ptr %events, ptr %events.addr, align 8
  store i32 %maxevents, ptr %maxevents.addr, align 4
  store i32 %timeout, ptr %timeout.addr, align 4
  store ptr %sigmask, ptr %sigmask.addr, align 8
  store i64 %sigsetsize, ptr %sigsetsize.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %epfd.addr, align 4
  %4 = load ptr, ptr %events.addr, align 8
  %5 = load i32, ptr %maxevents.addr, align 4
  %6 = load i32, ptr %timeout.addr, align 4
  %7 = load ptr, ptr %sigmask.addr, align 8
  %8 = load i64, ptr %sigsetsize.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 281, i32 noundef %3, ptr noundef %4, i32 noundef %5, i32 noundef %6, ptr noundef %7, i64 noundef %8)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_prlimit64(i32 noundef %pid, i32 noundef %resource, ptr noundef %new_limit, ptr noundef %old_limit) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %resource.addr = alloca i32, align 4
  %new_limit.addr = alloca ptr, align 8
  %old_limit.addr = alloca ptr, align 8
  store i32 %pid, ptr %pid.addr, align 4
  store i32 %resource, ptr %resource.addr, align 4
  store ptr %new_limit, ptr %new_limit.addr, align 8
  store ptr %old_limit, ptr %old_limit.addr, align 8
  %0 = load i32, ptr %pid.addr, align 4
  %1 = load i32, ptr %resource.addr, align 4
  %2 = load ptr, ptr %new_limit.addr, align 8
  %3 = load ptr, ptr %old_limit.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 302, i32 noundef %0, i32 noundef %1, ptr noundef %2, ptr noundef %3) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @next_free_host_timer() #0 {
entry:
  %retval = alloca i32, align 4
  %k = alloca i32, align 4
  %tmp = alloca i32, align 4
  %tmp2 = alloca i32, align 4
  %.atomictmp = alloca i32, align 4
  %atomic-temp = alloca i32, align 4
  store i32 0, ptr %k, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %k, align 4
  %conv = sext i32 %0 to i64
  %cmp = icmp ult i64 %conv, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %while.cond

while.cond:                                       ; preds = %do.end, %for.body
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.579, i32 noundef 531, ptr noundef @__func__.next_free_host_timer, ptr noundef null) #19
  unreachable

do.end:                                           ; No predecessors!
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %1 = load i32, ptr %k, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr i32, ptr @g_posix_timer_allocated, i64 %idx.ext
  store i32 1, ptr %.atomictmp, align 4
  %2 = load i32, ptr %.atomictmp, align 4
  %3 = atomicrmw xchg ptr %add.ptr, i32 %2 seq_cst, align 4
  store i32 %3, ptr %atomic-temp, align 4
  %4 = load i32, ptr %atomic-temp, align 4
  store i32 %4, ptr %tmp2, align 4
  %5 = load i32, ptr %tmp2, align 4
  store i32 %5, ptr %tmp, align 4
  %6 = load i32, ptr %tmp, align 4
  %cmp3 = icmp eq i32 %6, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  %7 = load i32, ptr %k, align 4
  store i32 %7, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %while.end
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32, ptr %k, align 4
  %inc = add i32 %8, 1
  store i32 %inc, ptr %k, align 4
  br label %for.cond, !llvm.loop !47

for.end:                                          ; preds = %for.cond
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_sigevent(ptr noundef %host_sevp, i64 noundef %target_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %host_sevp.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %target_sevp = alloca ptr, align 8
  store ptr %host_sevp, ptr %host_sevp.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 64, i1 noundef zeroext true)
  store ptr %call, ptr %target_sevp, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %target_sevp, align 8
  %sigev_value = getelementptr inbounds %struct.target_sigevent, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %sigev_value, align 8
  %call1 = call i64 @tswapal(i64 noundef %2)
  %3 = inttoptr i64 %call1 to ptr
  %4 = load ptr, ptr %host_sevp.addr, align 8
  %sigev_value2 = getelementptr inbounds %struct.sigevent, ptr %4, i32 0, i32 0
  store ptr %3, ptr %sigev_value2, align 8
  %5 = load ptr, ptr %target_sevp, align 8
  %sigev_signo = getelementptr inbounds %struct.target_sigevent, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %sigev_signo, align 8
  %call3 = call i32 @tswap32(i32 noundef %6)
  %call4 = call i32 @target_to_host_signal(i32 noundef %call3)
  %7 = load ptr, ptr %host_sevp.addr, align 8
  %sigev_signo5 = getelementptr inbounds %struct.sigevent, ptr %7, i32 0, i32 1
  store i32 %call4, ptr %sigev_signo5, align 8
  %8 = load ptr, ptr %target_sevp, align 8
  %sigev_notify = getelementptr inbounds %struct.target_sigevent, ptr %8, i32 0, i32 2
  %9 = load i32, ptr %sigev_notify, align 4
  %call6 = call i32 @tswap32(i32 noundef %9)
  %10 = load ptr, ptr %host_sevp.addr, align 8
  %sigev_notify7 = getelementptr inbounds %struct.sigevent, ptr %10, i32 0, i32 2
  store i32 %call6, ptr %sigev_notify7, align 4
  %11 = load ptr, ptr %target_sevp, align 8
  %_sigev_un = getelementptr inbounds %struct.target_sigevent, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %_sigev_un, align 8
  %call8 = call i32 @tswap32(i32 noundef %12)
  %13 = load ptr, ptr %host_sevp.addr, align 8
  %_sigev_un9 = getelementptr inbounds %struct.sigevent, ptr %13, i32 0, i32 3
  store i32 %call8, ptr %_sigev_un9, align 8
  %14 = load ptr, ptr %target_sevp, align 8
  %15 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %14, i64 noundef %15, i64 noundef 64)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %16 = load i64, ptr %retval, align 8
  ret i64 %16
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @free_host_timer_slot(i32 noundef %id) #0 {
entry:
  %id.addr = alloca i32, align 4
  %.atomictmp = alloca i32, align 4
  store i32 %id, ptr %id.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %do.end, %do.body
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body1

do.body1:                                         ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.579, i32 noundef 540, ptr noundef @__func__.free_host_timer_slot, ptr noundef null) #19
  unreachable

do.end:                                           ; No predecessors!
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %0 = load i32, ptr %id.addr, align 4
  %idx.ext = sext i32 %0 to i64
  %add.ptr = getelementptr i32, ptr @g_posix_timer_allocated, i64 %idx.ext
  store i32 0, ptr %.atomictmp, align 4
  %1 = load i32, ptr %.atomictmp, align 4
  store atomic i32 %1, ptr %add.ptr release, align 4
  br label %do.end2

do.end2:                                          ; preds = %while.end
  ret void
}

; Function Attrs: nounwind
declare i32 @timer_create(i32 noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @timer_delete(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @get_timer_id(i64 noundef %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %timerid = alloca i32, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load i64, ptr %arg.addr, align 8
  %conv = trunc i64 %0 to i32
  store i32 %conv, ptr %timerid, align 4
  %1 = load i32, ptr %timerid, align 4
  %and = and i32 %1, -65536
  %cmp = icmp ne i32 %and, 212795392
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -22, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %timerid, align 4
  %and2 = and i32 %2, 65535
  store i32 %and2, ptr %timerid, align 4
  %3 = load i32, ptr %timerid, align 4
  %conv3 = sext i32 %3 to i64
  %cmp4 = icmp uge i64 %conv3, 32
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i32 -22, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %4 = load i32, ptr %timerid, align 4
  store i32 %4, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_itimerspec(ptr noundef %host_its, i64 noundef %target_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %host_its.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  store ptr %host_its, ptr %host_its.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  %0 = load ptr, ptr %host_its.addr, align 8
  %it_interval = getelementptr inbounds %struct.itimerspec, ptr %0, i32 0, i32 0
  %1 = load i64, ptr %target_addr.addr, align 8
  %add = add i64 %1, 0
  %call = call i64 @target_to_host_timespec(ptr noundef %it_interval, i64 noundef %add)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %host_its.addr, align 8
  %it_value = getelementptr inbounds %struct.itimerspec, ptr %2, i32 0, i32 1
  %3 = load i64, ptr %target_addr.addr, align 8
  %add1 = add i64 %3, 16
  %call2 = call i64 @target_to_host_timespec(ptr noundef %it_value, i64 noundef %add1)
  %tobool3 = icmp ne i64 %call2, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i64, ptr %retval, align 8
  ret i64 %4
}

; Function Attrs: nounwind
declare i32 @timer_settime(ptr noundef, i32 noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_itimerspec(i64 noundef %target_addr, ptr noundef %host_its) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %host_its.addr = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_its, ptr %host_its.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %add = add i64 %0, 0
  %1 = load ptr, ptr %host_its.addr, align 8
  %it_interval = getelementptr inbounds %struct.itimerspec, ptr %1, i32 0, i32 0
  %call = call i64 @host_to_target_timespec(i64 noundef %add, ptr noundef %it_interval)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i64, ptr %target_addr.addr, align 8
  %add1 = add i64 %2, 16
  %3 = load ptr, ptr %host_its.addr, align 8
  %it_value = getelementptr inbounds %struct.itimerspec, ptr %3, i32 0, i32 1
  %call2 = call i64 @host_to_target_timespec(i64 noundef %add1, ptr noundef %it_value)
  %tobool3 = icmp ne i64 %call2, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i64, ptr %retval, align 8
  ret i64 %4
}

; Function Attrs: nounwind
declare i32 @timer_gettime(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @timer_getoverrun(ptr noundef) #2

; Function Attrs: nounwind
declare i32 @timerfd_create(i32 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @timerfd_gettime(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @timerfd_settime(i32 noundef, i32 noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ioprio_get(i32 noundef %which, i32 noundef %who) #0 {
entry:
  %which.addr = alloca i32, align 4
  %who.addr = alloca i32, align 4
  store i32 %which, ptr %which.addr, align 4
  store i32 %who, ptr %who.addr, align 4
  %0 = load i32, ptr %which.addr, align 4
  %1 = load i32, ptr %who.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 252, i32 noundef %0, i32 noundef %1) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ioprio_set(i32 noundef %which, i32 noundef %who, i32 noundef %ioprio) #0 {
entry:
  %which.addr = alloca i32, align 4
  %who.addr = alloca i32, align 4
  %ioprio.addr = alloca i32, align 4
  store i32 %which, ptr %which.addr, align 4
  store i32 %who, ptr %who.addr, align 4
  store i32 %ioprio, ptr %ioprio.addr, align 4
  %0 = load i32, ptr %which.addr, align 4
  %1 = load i32, ptr %who.addr, align 4
  %2 = load i32, ptr %ioprio.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 251, i32 noundef %0, i32 noundef %1, i32 noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @setns(i32 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @unshare(i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @kcmp(i32 noundef %pid1, i32 noundef %pid2, i32 noundef %type, i64 noundef %idx1, i64 noundef %idx2) #0 {
entry:
  %pid1.addr = alloca i32, align 4
  %pid2.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %idx1.addr = alloca i64, align 8
  %idx2.addr = alloca i64, align 8
  store i32 %pid1, ptr %pid1.addr, align 4
  store i32 %pid2, ptr %pid2.addr, align 4
  store i32 %type, ptr %type.addr, align 4
  store i64 %idx1, ptr %idx1.addr, align 8
  store i64 %idx2, ptr %idx2.addr, align 8
  %0 = load i32, ptr %pid1.addr, align 4
  %1 = load i32, ptr %pid2.addr, align 4
  %2 = load i32, ptr %type.addr, align 4
  %3 = load i64, ptr %idx1.addr, align 8
  %4 = load i64, ptr %idx2.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 312, i32 noundef %0, i32 noundef %1, i32 noundef %2, i64 noundef %3, i64 noundef %4) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @membarrier(i32 noundef %cmd, i32 noundef %flags) #0 {
entry:
  %cmd.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %cmd.addr, align 4
  %1 = load i32, ptr %flags.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 324, i32 noundef %0, i32 noundef %1) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @safe_copy_file_range(i32 noundef %infd, ptr noundef %pinoff, i32 noundef %outfd, ptr noundef %poutoff, i64 noundef %length, i32 noundef %flags) #0 {
entry:
  %infd.addr = alloca i32, align 4
  %pinoff.addr = alloca ptr, align 8
  %outfd.addr = alloca i32, align 4
  %poutoff.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i32 %infd, ptr %infd.addr, align 4
  store ptr %pinoff, ptr %pinoff.addr, align 8
  store i32 %outfd, ptr %outfd.addr, align 4
  store ptr %poutoff, ptr %poutoff.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %infd.addr, align 4
  %4 = load ptr, ptr %pinoff.addr, align 8
  %5 = load i32, ptr %outfd.addr, align 4
  %6 = load ptr, ptr %poutoff.addr, align 8
  %7 = load i64, ptr %length.addr, align 8
  %8 = load i32, ptr %flags.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 326, i32 noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef %6, i64 noundef %7, i32 noundef %8)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @pivot_root(ptr noundef %new_root, ptr noundef %put_old) #0 {
entry:
  %new_root.addr = alloca ptr, align 8
  %put_old.addr = alloca ptr, align 8
  store ptr %new_root, ptr %new_root.addr, align 8
  store ptr %put_old, ptr %put_old.addr, align 8
  %0 = load ptr, ptr %new_root.addr, align 8
  %1 = load ptr, ptr %put_old.addr, align 8
  %call = call i64 (i64, ...) @syscall(i64 noundef 155, ptr noundef %0, ptr noundef %1) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_riscv_hwprobe(ptr noundef %cpu_env, i64 noundef %arg1, i64 noundef %arg2, i64 noundef %arg3, i64 noundef %arg4, i64 noundef %arg5) #0 {
entry:
  %retval = alloca i64, align 8
  %cpu_env.addr = alloca ptr, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  %arg4.addr = alloca i64, align 8
  %arg5.addr = alloca i64, align 8
  %ret = alloca i32, align 4
  %host_pairs = alloca ptr, align 8
  store ptr %cpu_env, ptr %cpu_env.addr, align 8
  store i64 %arg1, ptr %arg1.addr, align 8
  store i64 %arg2, ptr %arg2.addr, align 8
  store i64 %arg3, ptr %arg3.addr, align 8
  store i64 %arg4, ptr %arg4.addr, align 8
  store i64 %arg5, ptr %arg5.addr, align 8
  %0 = load i64, ptr %arg5.addr, align 8
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -22, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %arg3.addr, align 8
  %cmp1 = icmp ne i64 %1, 0
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %2 = load i64, ptr %arg3.addr, align 8
  %3 = load i64, ptr %arg4.addr, align 8
  %call = call i32 @cpu_set_valid(i64 noundef %2, i64 noundef %3)
  store i32 %call, ptr %ret, align 4
  %4 = load i32, ptr %ret, align 4
  %cmp3 = icmp ne i32 %4, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then2
  %5 = load i32, ptr %ret, align 4
  %conv = sext i32 %5 to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.then2
  br label %if.end10

if.else:                                          ; preds = %if.end
  %6 = load i64, ptr %arg4.addr, align 8
  %cmp6 = icmp ne i64 %6, 0
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.else
  store i64 -22, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.else
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.end5
  %7 = load i64, ptr %arg2.addr, align 8
  %cmp11 = icmp eq i64 %7, 0
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end10
  %8 = load i64, ptr %arg1.addr, align 8
  %9 = load i64, ptr %arg2.addr, align 8
  %mul = mul i64 16, %9
  %call15 = call ptr @lock_user(i32 noundef 3, i64 noundef %8, i64 noundef %mul, i1 noundef zeroext false)
  store ptr %call15, ptr %host_pairs, align 8
  %10 = load ptr, ptr %host_pairs, align 8
  %cmp16 = icmp eq ptr %10, null
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end14
  store i64 -14, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %if.end14
  %11 = load ptr, ptr %cpu_env.addr, align 8
  %12 = load ptr, ptr %host_pairs, align 8
  %13 = load i64, ptr %arg2.addr, align 8
  call void @risc_hwprobe_fill_pairs(ptr noundef %11, ptr noundef %12, i64 noundef %13)
  %14 = load ptr, ptr %host_pairs, align 8
  %15 = load i64, ptr %arg1.addr, align 8
  %16 = load i64, ptr %arg2.addr, align 8
  %mul20 = mul i64 16, %16
  call void @unlock_user(ptr noundef %14, i64 noundef %15, i64 noundef %mul20)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then18, %if.then13, %if.then8, %if.then4, %if.then
  %17 = load i64, ptr %retval, align 8
  ret i64 %17
}

declare void @qemu_log(ptr noundef, ...) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_futex(ptr noundef %uaddr, i32 noundef %op, i32 noundef %val, ptr noundef %timeout, ptr noundef %uaddr2, i32 noundef %val3) #0 {
entry:
  %uaddr.addr = alloca ptr, align 8
  %op.addr = alloca i32, align 4
  %val.addr = alloca i32, align 4
  %timeout.addr = alloca ptr, align 8
  %uaddr2.addr = alloca ptr, align 8
  %val3.addr = alloca i32, align 4
  store ptr %uaddr, ptr %uaddr.addr, align 8
  store i32 %op, ptr %op.addr, align 4
  store i32 %val, ptr %val.addr, align 4
  store ptr %timeout, ptr %timeout.addr, align 8
  store ptr %uaddr2, ptr %uaddr2.addr, align 8
  store i32 %val3, ptr %val3.addr, align 4
  %0 = load ptr, ptr %uaddr.addr, align 8
  %1 = load i32, ptr %op.addr, align 4
  %2 = load i32, ptr %val.addr, align 4
  %3 = load ptr, ptr %timeout.addr, align 8
  %4 = load ptr, ptr %uaddr2.addr, align 8
  %5 = load i32, ptr %val3.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 202, ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i64 @syscall(i64 noundef, ...) #2

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @qemu_lockable_auto_lock(ptr noundef %x) #0 {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  call void @qemu_lockable_lock(ptr noundef %0)
  %1 = load ptr, ptr %x.addr, align 8
  ret ptr %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @qemu_mutex_lock(ptr noundef %mutex) #0 {
entry:
  %mutex.addr = alloca ptr, align 8
  %_f = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %atomic-temp = alloca ptr, align 8
  store ptr %mutex, ptr %mutex.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %do.end, %entry
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.630, i32 noundef 122, ptr noundef @__func__.qemu_mutex_lock, ptr noundef null) #19
  unreachable

do.end:                                           ; No predecessors!
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %0 = load atomic i64, ptr @qemu_mutex_lock_func monotonic, align 8
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load ptr, ptr %atomic-temp, align 8
  store ptr %1, ptr %tmp, align 8
  %2 = load ptr, ptr %tmp, align 8
  store ptr %2, ptr %_f, align 8
  %3 = load ptr, ptr %_f, align 8
  %4 = load ptr, ptr %mutex.addr, align 8
  call void %3(ptr noundef %4, ptr noundef @.str.630, i32 noundef 122)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @qemu_mutex_unlock(ptr noundef %mutex) #0 {
entry:
  %mutex.addr = alloca ptr, align 8
  store ptr %mutex, ptr %mutex.addr, align 8
  %0 = load ptr, ptr %mutex.addr, align 8
  call void @qemu_mutex_unlock_impl(ptr noundef %0, ptr noundef @.str.630, i32 noundef 132)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_cleanup_QemuLockable(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %1 = load ptr, ptr %0, align 8
  call void @glib_autoptr_clear_QemuLockable(ptr noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @qemu_lockable_lock(ptr noundef %x) #0 {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %lock = getelementptr inbounds %struct.QemuLockable, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %lock, align 8
  %2 = load ptr, ptr %x.addr, align 8
  %object = getelementptr inbounds %struct.QemuLockable, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %object, align 8
  call void %1(ptr noundef %3)
  ret void
}

declare void @qemu_mutex_unlock_impl(ptr noundef, ptr noundef, i32 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_clear_QemuLockable(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %_ptr.addr, align 8
  call void @qemu_lockable_auto_unlock(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @qemu_lockable_auto_unlock(ptr noundef %x) #0 {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %x.addr, align 8
  call void @qemu_lockable_unlock(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @qemu_lockable_unlock(ptr noundef %x) #0 {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %unlock = getelementptr inbounds %struct.QemuLockable, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %unlock, align 8
  %2 = load ptr, ptr %x.addr, align 8
  %object = getelementptr inbounds %struct.QemuLockable, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %object, align 8
  call void %1(ptr noundef %3)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @internal_fd_trans_unregister_unsafe(i32 noundef %fd) #0 {
entry:
  %fd.addr = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %fd.addr, align 4
  %2 = load i32, ptr @target_fd_max, align 4
  %cmp1 = icmp ult i32 %1, %2
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %3 = load ptr, ptr @target_fd_trans, align 8
  %4 = load i32, ptr %fd.addr, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr ptr, ptr %3, i64 %idxprom
  store ptr null, ptr %arrayidx, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind
declare i32 @name_to_handle_at(i32 noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) #2

; Function Attrs: allocsize(1)
declare ptr @g_memdup(ptr noundef, i32 noundef) #12

declare i32 @open_by_handle_at(i32 noundef, ptr noundef, i32 noundef) #3

; Function Attrs: allocsize(0,1)
declare noalias ptr @g_malloc0_n(i64 noundef, i64 noundef) #9

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_execveat(i32 noundef %dirfd, ptr noundef %filename, ptr noundef %argv, ptr noundef %envp, i32 noundef %flags) #0 {
entry:
  %dirfd.addr = alloca i32, align 4
  %filename.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %envp.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store i32 %dirfd, ptr %dirfd.addr, align 4
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store ptr %envp, ptr %envp.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %dirfd.addr, align 4
  %4 = load ptr, ptr %filename.addr, align 8
  %5 = load ptr, ptr %argv.addr, align 8
  %6 = load ptr, ptr %envp.addr, align 8
  %7 = load i32, ptr %flags.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 322, i32 noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef %6, i32 noundef %7)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_execve(ptr noundef %filename, ptr noundef %argv, ptr noundef %envp) #0 {
entry:
  %filename.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %envp.addr = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store ptr %envp, ptr %envp.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load ptr, ptr %filename.addr, align 8
  %4 = load ptr, ptr %argv.addr, align 8
  %5 = load ptr, ptr %envp.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 59, ptr noundef %3, ptr noundef %4, ptr noundef %5)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @internal_fd_trans_register_unsafe(i32 noundef %fd, ptr noundef %trans) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %trans.addr = alloca ptr, align 8
  %oldmax = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %trans, ptr %trans.addr, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load i32, ptr @target_fd_max, align 4
  %cmp = icmp uge i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr @target_fd_max, align 4
  store i32 %2, ptr %oldmax, align 4
  %3 = load i32, ptr %fd.addr, align 4
  %shr = ashr i32 %3, 6
  %add = add i32 %shr, 1
  %shl = shl i32 %add, 6
  store i32 %shl, ptr @target_fd_max, align 4
  %4 = load ptr, ptr @target_fd_trans, align 8
  %5 = load i32, ptr @target_fd_max, align 4
  %conv = zext i32 %5 to i64
  %call = call ptr @g_realloc_n(ptr noundef %4, i64 noundef %conv, i64 noundef 8)
  store ptr %call, ptr @target_fd_trans, align 8
  %6 = load ptr, ptr @target_fd_trans, align 8
  %7 = load i32, ptr %oldmax, align 4
  %idx.ext = zext i32 %7 to i64
  %add.ptr = getelementptr ptr, ptr %6, i64 %idx.ext
  %8 = load i32, ptr @target_fd_max, align 4
  %9 = load i32, ptr %oldmax, align 4
  %sub = sub i32 %8, %9
  %conv1 = zext i32 %sub to i64
  %mul = mul i64 %conv1, 8
  call void @llvm.memset.p0.i64(ptr align 1 %add.ptr, i8 0, i64 %mul, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = load ptr, ptr %trans.addr, align 8
  %11 = load ptr, ptr @target_fd_trans, align 8
  %12 = load i32, ptr %fd.addr, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr ptr, ptr %11, i64 %idxprom
  store ptr %10, ptr %arrayidx, align 8
  ret void
}

declare ptr @g_realloc_n(ptr noundef, i64 noundef, i64 noundef) #3

; Function Attrs: nounwind
declare i32 @pipe2(ptr noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @target_to_host_fcntl_cmd(i32 noundef %cmd) #0 {
entry:
  %cmd.addr = alloca i32, align 4
  %ret = alloca i32, align 4
  store i32 %cmd, ptr %cmd.addr, align 4
  %0 = load i32, ptr %cmd.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb
    i32 2, label %sw.bb
    i32 3, label %sw.bb
    i32 4, label %sw.bb
    i32 36, label %sw.bb
    i32 37, label %sw.bb
    i32 38, label %sw.bb
    i32 5, label %sw.bb1
    i32 6, label %sw.bb2
    i32 7, label %sw.bb3
    i32 9, label %sw.bb4
    i32 8, label %sw.bb5
    i32 11, label %sw.bb6
    i32 10, label %sw.bb7
    i32 1024, label %sw.bb8
    i32 1025, label %sw.bb9
    i32 1030, label %sw.bb10
    i32 1026, label %sw.bb11
    i32 16, label %sw.bb12
    i32 15, label %sw.bb13
    i32 1031, label %sw.bb14
    i32 1032, label %sw.bb15
    i32 1033, label %sw.bb16
    i32 1034, label %sw.bb17
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  %1 = load i32, ptr %cmd.addr, align 4
  store i32 %1, ptr %ret, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  store i32 5, ptr %ret, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  store i32 6, ptr %ret, align 4
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  store i32 7, ptr %ret, align 4
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  store i32 9, ptr %ret, align 4
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  store i32 8, ptr %ret, align 4
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  store i32 11, ptr %ret, align 4
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  store i32 10, ptr %ret, align 4
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  store i32 1024, ptr %ret, align 4
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  store i32 1025, ptr %ret, align 4
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry
  store i32 1030, ptr %ret, align 4
  br label %sw.epilog

sw.bb11:                                          ; preds = %entry
  store i32 1026, ptr %ret, align 4
  br label %sw.epilog

sw.bb12:                                          ; preds = %entry
  store i32 16, ptr %ret, align 4
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  store i32 15, ptr %ret, align 4
  br label %sw.epilog

sw.bb14:                                          ; preds = %entry
  store i32 1031, ptr %ret, align 4
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry
  store i32 1032, ptr %ret, align 4
  br label %sw.epilog

sw.bb16:                                          ; preds = %entry
  store i32 1033, ptr %ret, align 4
  br label %sw.epilog

sw.bb17:                                          ; preds = %entry
  store i32 1034, ptr %ret, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i32 -22, ptr %ret, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb17, %sw.bb16, %sw.bb15, %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %2 = load i32, ptr %ret, align 4
  ret i32 %2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_from_user_flock(ptr noundef %fl, i64 noundef %target_flock_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %fl.addr = alloca ptr, align 8
  %target_flock_addr.addr = alloca i64, align 8
  %target_fl = alloca ptr, align 8
  %l_type = alloca i32, align 4
  store ptr %fl, ptr %fl.addr, align 8
  store i64 %target_flock_addr, ptr %target_flock_addr.addr, align 8
  %0 = load i64, ptr %target_flock_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 32, i1 noundef zeroext true)
  store ptr %call, ptr %target_fl, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_fl, align 8
  %l_type1 = getelementptr inbounds %struct.target_flock, ptr %1, i32 0, i32 0
  %call2 = call i32 @lduw_le_p(ptr noundef %l_type1)
  %conv = trunc i32 %call2 to i16
  %conv3 = sext i16 %conv to i32
  store i32 %conv3, ptr %l_type, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  %2 = load i32, ptr %l_type, align 4
  %call4 = call i32 @target_to_host_flock(i32 noundef %2)
  store i32 %call4, ptr %l_type, align 4
  %3 = load i32, ptr %l_type, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %if.then6, label %if.end8

if.then6:                                         ; preds = %do.end
  %4 = load i32, ptr %l_type, align 4
  %conv7 = sext i32 %4 to i64
  store i64 %conv7, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %do.end
  %5 = load i32, ptr %l_type, align 4
  %conv9 = trunc i32 %5 to i16
  %6 = load ptr, ptr %fl.addr, align 8
  %l_type10 = getelementptr inbounds %struct.flock64, ptr %6, i32 0, i32 0
  store i16 %conv9, ptr %l_type10, align 8
  br label %do.body11

do.body11:                                        ; preds = %if.end8
  %7 = load ptr, ptr %target_fl, align 8
  %l_whence = getelementptr inbounds %struct.target_flock, ptr %7, i32 0, i32 1
  %call12 = call i32 @lduw_le_p(ptr noundef %l_whence)
  %conv13 = trunc i32 %call12 to i16
  %8 = load ptr, ptr %fl.addr, align 8
  %l_whence14 = getelementptr inbounds %struct.flock64, ptr %8, i32 0, i32 1
  store i16 %conv13, ptr %l_whence14, align 2
  br label %do.end15

do.end15:                                         ; preds = %do.body11
  br label %do.body16

do.body16:                                        ; preds = %do.end15
  %9 = load ptr, ptr %target_fl, align 8
  %l_start = getelementptr inbounds %struct.target_flock, ptr %9, i32 0, i32 2
  %call17 = call i64 @ldq_le_p(ptr noundef %l_start)
  %10 = load ptr, ptr %fl.addr, align 8
  %l_start18 = getelementptr inbounds %struct.flock64, ptr %10, i32 0, i32 2
  store i64 %call17, ptr %l_start18, align 8
  br label %do.end19

do.end19:                                         ; preds = %do.body16
  br label %do.body20

do.body20:                                        ; preds = %do.end19
  %11 = load ptr, ptr %target_fl, align 8
  %l_len = getelementptr inbounds %struct.target_flock, ptr %11, i32 0, i32 3
  %call21 = call i64 @ldq_le_p(ptr noundef %l_len)
  %12 = load ptr, ptr %fl.addr, align 8
  %l_len22 = getelementptr inbounds %struct.flock64, ptr %12, i32 0, i32 3
  store i64 %call21, ptr %l_len22, align 8
  br label %do.end23

do.end23:                                         ; preds = %do.body20
  br label %do.body24

do.body24:                                        ; preds = %do.end23
  %13 = load ptr, ptr %target_fl, align 8
  %l_pid = getelementptr inbounds %struct.target_flock, ptr %13, i32 0, i32 4
  %call25 = call i32 @ldl_le_p(ptr noundef %l_pid)
  %14 = load ptr, ptr %fl.addr, align 8
  %l_pid26 = getelementptr inbounds %struct.flock64, ptr %14, i32 0, i32 4
  store i32 %call25, ptr %l_pid26, align 8
  br label %do.end27

do.end27:                                         ; preds = %do.body24
  %15 = load ptr, ptr %target_fl, align 8
  %16 = load i64, ptr %target_flock_addr.addr, align 8
  call void @unlock_user(ptr noundef %15, i64 noundef %16, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end27, %if.then6, %if.then
  %17 = load i64, ptr %retval, align 8
  ret i64 %17
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_to_user_flock(i64 noundef %target_flock_addr, ptr noundef %fl) #0 {
entry:
  %retval = alloca i64, align 8
  %target_flock_addr.addr = alloca i64, align 8
  %fl.addr = alloca ptr, align 8
  %target_fl = alloca ptr, align 8
  %l_type = alloca i16, align 2
  store i64 %target_flock_addr, ptr %target_flock_addr.addr, align 8
  store ptr %fl, ptr %fl.addr, align 8
  %0 = load i64, ptr %target_flock_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 32, i1 noundef zeroext false)
  store ptr %call, ptr %target_fl, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %fl.addr, align 8
  %l_type1 = getelementptr inbounds %struct.flock64, ptr %1, i32 0, i32 0
  %2 = load i16, ptr %l_type1, align 8
  %conv = sext i16 %2 to i32
  %call2 = call i32 @host_to_target_flock(i32 noundef %conv)
  %conv3 = trunc i32 %call2 to i16
  store i16 %conv3, ptr %l_type, align 2
  br label %do.body

do.body:                                          ; preds = %if.end
  %3 = load ptr, ptr %target_fl, align 8
  %l_type4 = getelementptr inbounds %struct.target_flock, ptr %3, i32 0, i32 0
  %4 = load i16, ptr %l_type, align 2
  call void @stw_le_p(ptr noundef %l_type4, i16 noundef zeroext %4)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body5

do.body5:                                         ; preds = %do.end
  %5 = load ptr, ptr %target_fl, align 8
  %l_whence = getelementptr inbounds %struct.target_flock, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %fl.addr, align 8
  %l_whence6 = getelementptr inbounds %struct.flock64, ptr %6, i32 0, i32 1
  %7 = load i16, ptr %l_whence6, align 2
  call void @stw_le_p(ptr noundef %l_whence, i16 noundef zeroext %7)
  br label %do.end7

do.end7:                                          ; preds = %do.body5
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %8 = load ptr, ptr %target_fl, align 8
  %l_start = getelementptr inbounds %struct.target_flock, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %fl.addr, align 8
  %l_start9 = getelementptr inbounds %struct.flock64, ptr %9, i32 0, i32 2
  %10 = load i64, ptr %l_start9, align 8
  call void @stq_le_p(ptr noundef %l_start, i64 noundef %10)
  br label %do.end10

do.end10:                                         ; preds = %do.body8
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %11 = load ptr, ptr %target_fl, align 8
  %l_len = getelementptr inbounds %struct.target_flock, ptr %11, i32 0, i32 3
  %12 = load ptr, ptr %fl.addr, align 8
  %l_len12 = getelementptr inbounds %struct.flock64, ptr %12, i32 0, i32 3
  %13 = load i64, ptr %l_len12, align 8
  call void @stq_le_p(ptr noundef %l_len, i64 noundef %13)
  br label %do.end13

do.end13:                                         ; preds = %do.body11
  br label %do.body14

do.body14:                                        ; preds = %do.end13
  %14 = load ptr, ptr %target_fl, align 8
  %l_pid = getelementptr inbounds %struct.target_flock, ptr %14, i32 0, i32 4
  %15 = load ptr, ptr %fl.addr, align 8
  %l_pid15 = getelementptr inbounds %struct.flock64, ptr %15, i32 0, i32 4
  %16 = load i32, ptr %l_pid15, align 8
  call void @stl_le_p(ptr noundef %l_pid, i32 noundef %16)
  br label %do.end16

do.end16:                                         ; preds = %do.body14
  %17 = load ptr, ptr %target_fl, align 8
  %18 = load i64, ptr %target_flock_addr.addr, align 8
  call void @unlock_user(ptr noundef %17, i64 noundef %18, i64 noundef 32)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end16, %if.then
  %19 = load i64, ptr %retval, align 8
  ret i64 %19
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_from_user_flock64(ptr noundef %fl, i64 noundef %target_flock_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %fl.addr = alloca ptr, align 8
  %target_flock_addr.addr = alloca i64, align 8
  %target_fl = alloca ptr, align 8
  %l_type = alloca i32, align 4
  store ptr %fl, ptr %fl.addr, align 8
  store i64 %target_flock_addr, ptr %target_flock_addr.addr, align 8
  %0 = load i64, ptr %target_flock_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 32, i1 noundef zeroext true)
  store ptr %call, ptr %target_fl, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_fl, align 8
  %l_type1 = getelementptr inbounds %struct.target_flock64, ptr %1, i32 0, i32 0
  %call2 = call i32 @lduw_le_p(ptr noundef %l_type1)
  %conv = trunc i32 %call2 to i16
  %conv3 = sext i16 %conv to i32
  store i32 %conv3, ptr %l_type, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  %2 = load i32, ptr %l_type, align 4
  %call4 = call i32 @target_to_host_flock(i32 noundef %2)
  store i32 %call4, ptr %l_type, align 4
  %3 = load i32, ptr %l_type, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %if.then6, label %if.end8

if.then6:                                         ; preds = %do.end
  %4 = load i32, ptr %l_type, align 4
  %conv7 = sext i32 %4 to i64
  store i64 %conv7, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %do.end
  %5 = load i32, ptr %l_type, align 4
  %conv9 = trunc i32 %5 to i16
  %6 = load ptr, ptr %fl.addr, align 8
  %l_type10 = getelementptr inbounds %struct.flock64, ptr %6, i32 0, i32 0
  store i16 %conv9, ptr %l_type10, align 8
  br label %do.body11

do.body11:                                        ; preds = %if.end8
  %7 = load ptr, ptr %target_fl, align 8
  %l_whence = getelementptr inbounds %struct.target_flock64, ptr %7, i32 0, i32 1
  %call12 = call i32 @lduw_le_p(ptr noundef %l_whence)
  %conv13 = trunc i32 %call12 to i16
  %8 = load ptr, ptr %fl.addr, align 8
  %l_whence14 = getelementptr inbounds %struct.flock64, ptr %8, i32 0, i32 1
  store i16 %conv13, ptr %l_whence14, align 2
  br label %do.end15

do.end15:                                         ; preds = %do.body11
  br label %do.body16

do.body16:                                        ; preds = %do.end15
  %9 = load ptr, ptr %target_fl, align 8
  %l_start = getelementptr inbounds %struct.target_flock64, ptr %9, i32 0, i32 2
  %call17 = call i64 @ldq_le_p(ptr noundef %l_start)
  %10 = load ptr, ptr %fl.addr, align 8
  %l_start18 = getelementptr inbounds %struct.flock64, ptr %10, i32 0, i32 2
  store i64 %call17, ptr %l_start18, align 8
  br label %do.end19

do.end19:                                         ; preds = %do.body16
  br label %do.body20

do.body20:                                        ; preds = %do.end19
  %11 = load ptr, ptr %target_fl, align 8
  %l_len = getelementptr inbounds %struct.target_flock64, ptr %11, i32 0, i32 3
  %call21 = call i64 @ldq_le_p(ptr noundef %l_len)
  %12 = load ptr, ptr %fl.addr, align 8
  %l_len22 = getelementptr inbounds %struct.flock64, ptr %12, i32 0, i32 3
  store i64 %call21, ptr %l_len22, align 8
  br label %do.end23

do.end23:                                         ; preds = %do.body20
  br label %do.body24

do.body24:                                        ; preds = %do.end23
  %13 = load ptr, ptr %target_fl, align 8
  %l_pid = getelementptr inbounds %struct.target_flock64, ptr %13, i32 0, i32 4
  %call25 = call i32 @ldl_le_p(ptr noundef %l_pid)
  %14 = load ptr, ptr %fl.addr, align 8
  %l_pid26 = getelementptr inbounds %struct.flock64, ptr %14, i32 0, i32 4
  store i32 %call25, ptr %l_pid26, align 8
  br label %do.end27

do.end27:                                         ; preds = %do.body24
  %15 = load ptr, ptr %target_fl, align 8
  %16 = load i64, ptr %target_flock_addr.addr, align 8
  call void @unlock_user(ptr noundef %15, i64 noundef %16, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end27, %if.then6, %if.then
  %17 = load i64, ptr %retval, align 8
  ret i64 %17
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_to_user_flock64(i64 noundef %target_flock_addr, ptr noundef %fl) #0 {
entry:
  %retval = alloca i64, align 8
  %target_flock_addr.addr = alloca i64, align 8
  %fl.addr = alloca ptr, align 8
  %target_fl = alloca ptr, align 8
  %l_type = alloca i16, align 2
  store i64 %target_flock_addr, ptr %target_flock_addr.addr, align 8
  store ptr %fl, ptr %fl.addr, align 8
  %0 = load i64, ptr %target_flock_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 32, i1 noundef zeroext false)
  store ptr %call, ptr %target_fl, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %fl.addr, align 8
  %l_type1 = getelementptr inbounds %struct.flock64, ptr %1, i32 0, i32 0
  %2 = load i16, ptr %l_type1, align 8
  %conv = sext i16 %2 to i32
  %call2 = call i32 @host_to_target_flock(i32 noundef %conv)
  %conv3 = trunc i32 %call2 to i16
  store i16 %conv3, ptr %l_type, align 2
  br label %do.body

do.body:                                          ; preds = %if.end
  %3 = load ptr, ptr %target_fl, align 8
  %l_type4 = getelementptr inbounds %struct.target_flock64, ptr %3, i32 0, i32 0
  %4 = load i16, ptr %l_type, align 2
  call void @stw_le_p(ptr noundef %l_type4, i16 noundef zeroext %4)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body5

do.body5:                                         ; preds = %do.end
  %5 = load ptr, ptr %target_fl, align 8
  %l_whence = getelementptr inbounds %struct.target_flock64, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %fl.addr, align 8
  %l_whence6 = getelementptr inbounds %struct.flock64, ptr %6, i32 0, i32 1
  %7 = load i16, ptr %l_whence6, align 2
  call void @stw_le_p(ptr noundef %l_whence, i16 noundef zeroext %7)
  br label %do.end7

do.end7:                                          ; preds = %do.body5
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %8 = load ptr, ptr %target_fl, align 8
  %l_start = getelementptr inbounds %struct.target_flock64, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %fl.addr, align 8
  %l_start9 = getelementptr inbounds %struct.flock64, ptr %9, i32 0, i32 2
  %10 = load i64, ptr %l_start9, align 8
  call void @stq_le_p(ptr noundef %l_start, i64 noundef %10)
  br label %do.end10

do.end10:                                         ; preds = %do.body8
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %11 = load ptr, ptr %target_fl, align 8
  %l_len = getelementptr inbounds %struct.target_flock64, ptr %11, i32 0, i32 3
  %12 = load ptr, ptr %fl.addr, align 8
  %l_len12 = getelementptr inbounds %struct.flock64, ptr %12, i32 0, i32 3
  %13 = load i64, ptr %l_len12, align 8
  call void @stq_le_p(ptr noundef %l_len, i64 noundef %13)
  br label %do.end13

do.end13:                                         ; preds = %do.body11
  br label %do.body14

do.body14:                                        ; preds = %do.end13
  %14 = load ptr, ptr %target_fl, align 8
  %l_pid = getelementptr inbounds %struct.target_flock64, ptr %14, i32 0, i32 4
  %15 = load ptr, ptr %fl.addr, align 8
  %l_pid15 = getelementptr inbounds %struct.flock64, ptr %15, i32 0, i32 4
  %16 = load i32, ptr %l_pid15, align 8
  call void @stl_le_p(ptr noundef %l_pid, i32 noundef %16)
  br label %do.end16

do.end16:                                         ; preds = %do.body14
  %17 = load ptr, ptr %target_fl, align 8
  %18 = load i64, ptr %target_flock_addr.addr, align 8
  call void @unlock_user(ptr noundef %17, i64 noundef %18, i64 noundef 32)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end16, %if.then
  %19 = load i64, ptr %retval, align 8
  ret i64 %19
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @lduw_le_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %call = call i32 @lduw_he_p(ptr noundef %0)
  %conv = trunc i32 %call to i16
  %conv1 = zext i16 %conv to i32
  ret i32 %conv1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @target_to_host_flock(i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %type.addr = alloca i32, align 4
  store i32 %type, ptr %type.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  switch i32 %0, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb2:                                           ; preds = %entry
  store i32 2, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %entry
  store i32 -22, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb2, %sw.bb1, %sw.bb
  %1 = load i32, ptr %retval, align 4
  ret i32 %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @lduw_he_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %r = alloca i16, align 2
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %r, ptr align 1 %0, i64 2, i1 false)
  %1 = load i16, ptr %r, align 2
  %conv = zext i16 %1 to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @host_to_target_flock(i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %type.addr = alloca i32, align 4
  store i32 %type, ptr %type.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  switch i32 %0, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb2:                                           ; preds = %entry
  store i32 2, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %entry
  %1 = load i32, ptr %type.addr, align 4
  store i32 %1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb2, %sw.bb1, %sw.bb
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_from_user_fdset_ptr(ptr noundef %fds, ptr noundef %fds_ptr, i64 noundef %target_fds_addr, i32 noundef %n) #0 {
entry:
  %retval = alloca i64, align 8
  %fds.addr = alloca ptr, align 8
  %fds_ptr.addr = alloca ptr, align 8
  %target_fds_addr.addr = alloca i64, align 8
  %n.addr = alloca i32, align 4
  store ptr %fds, ptr %fds.addr, align 8
  store ptr %fds_ptr, ptr %fds_ptr.addr, align 8
  store i64 %target_fds_addr, ptr %target_fds_addr.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load i64, ptr %target_fds_addr.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %fds.addr, align 8
  %2 = load i64, ptr %target_fds_addr.addr, align 8
  %3 = load i32, ptr %n.addr, align 4
  %call = call i64 @copy_from_user_fdset(ptr noundef %1, i64 noundef %2, i32 noundef %3)
  %tobool1 = icmp ne i64 %call, 0
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %4 = load ptr, ptr %fds.addr, align 8
  %5 = load ptr, ptr %fds_ptr.addr, align 8
  store ptr %4, ptr %5, align 8
  br label %if.end3

if.else:                                          ; preds = %entry
  %6 = load ptr, ptr %fds_ptr.addr, align 8
  store ptr null, ptr %6, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.else, %if.end
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2
  %7 = load i64, ptr %retval, align 8
  ret i64 %7
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_timespec64(ptr noundef %host_ts, i64 noundef %target_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %host_ts.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %target_ts = alloca ptr, align 8
  store ptr %host_ts, ptr %host_ts.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 16, i1 noundef zeroext true)
  store ptr %call, ptr %target_ts, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_ts, align 8
  %tv_sec = getelementptr inbounds %struct.target__kernel_timespec, ptr %1, i32 0, i32 0
  %call1 = call i64 @ldq_le_p(ptr noundef %tv_sec)
  %2 = load ptr, ptr %host_ts.addr, align 8
  %tv_sec2 = getelementptr inbounds %struct.timespec, ptr %2, i32 0, i32 0
  store i64 %call1, ptr %tv_sec2, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body3

do.body3:                                         ; preds = %do.end
  %3 = load ptr, ptr %target_ts, align 8
  %tv_nsec = getelementptr inbounds %struct.target__kernel_timespec, ptr %3, i32 0, i32 1
  %call4 = call i64 @ldq_le_p(ptr noundef %tv_nsec)
  %4 = load ptr, ptr %host_ts.addr, align 8
  %tv_nsec5 = getelementptr inbounds %struct.timespec, ptr %4, i32 0, i32 1
  store i64 %call4, ptr %tv_nsec5, align 8
  br label %do.end6

do.end6:                                          ; preds = %do.body3
  %5 = load ptr, ptr %host_ts.addr, align 8
  %tv_nsec7 = getelementptr inbounds %struct.timespec, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %tv_nsec7, align 8
  %7 = load ptr, ptr %host_ts.addr, align 8
  %tv_nsec8 = getelementptr inbounds %struct.timespec, ptr %7, i32 0, i32 1
  store i64 %6, ptr %tv_nsec8, align 8
  %8 = load ptr, ptr %target_ts, align 8
  %9 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %8, i64 noundef %9, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end6, %if.then
  %10 = load i64, ptr %retval, align 8
  ret i64 %10
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_pselect6(i32 noundef %nfds, ptr noundef %readfds, ptr noundef %writefds, ptr noundef %exceptfds, ptr noundef %timeout, ptr noundef %sig) #0 {
entry:
  %nfds.addr = alloca i32, align 4
  %readfds.addr = alloca ptr, align 8
  %writefds.addr = alloca ptr, align 8
  %exceptfds.addr = alloca ptr, align 8
  %timeout.addr = alloca ptr, align 8
  %sig.addr = alloca ptr, align 8
  store i32 %nfds, ptr %nfds.addr, align 4
  store ptr %readfds, ptr %readfds.addr, align 8
  store ptr %writefds, ptr %writefds.addr, align 8
  store ptr %exceptfds, ptr %exceptfds.addr, align 8
  store ptr %timeout, ptr %timeout.addr, align 8
  store ptr %sig, ptr %sig.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %nfds.addr, align 4
  %4 = load ptr, ptr %readfds.addr, align 8
  %5 = load ptr, ptr %writefds.addr, align 8
  %6 = load ptr, ptr %exceptfds.addr, align 8
  %7 = load ptr, ptr %timeout.addr, align 8
  %8 = load ptr, ptr %sig.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 270, i32 noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %8)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_to_user_fdset(i64 noundef %target_fds_addr, ptr noundef %fds, i32 noundef %n) #0 {
entry:
  %retval = alloca i64, align 8
  %target_fds_addr.addr = alloca i64, align 8
  %fds.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %nw = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %v = alloca i64, align 8
  %target_fds = alloca ptr, align 8
  store i64 %target_fds_addr, ptr %target_fds_addr.addr, align 8
  store ptr %fds, ptr %fds.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %add = add i32 %0, 64
  %sub = sub i32 %add, 1
  %div = sdiv i32 %sub, 64
  store i32 %div, ptr %nw, align 4
  %1 = load i64, ptr %target_fds_addr.addr, align 8
  %2 = load i32, ptr %nw, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 8, %conv
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %1, i64 noundef %mul, i1 noundef zeroext false)
  store ptr %call, ptr %target_fds, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %k, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc17, %if.end
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %nw, align 4
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end19

for.body:                                         ; preds = %for.cond
  store i64 0, ptr %v, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %5 = load i32, ptr %j, align 4
  %cmp3 = icmp slt i32 %5, 64
  br i1 %cmp3, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond2
  %6 = load ptr, ptr %fds.addr, align 8
  %fds_bits = getelementptr inbounds %struct.fd_set, ptr %6, i32 0, i32 0
  %7 = load i32, ptr %k, align 4
  %div6 = sdiv i32 %7, 64
  %idxprom = sext i32 %div6 to i64
  %arrayidx = getelementptr [16 x i64], ptr %fds_bits, i64 0, i64 %idxprom
  %8 = load i64, ptr %arrayidx, align 8
  %9 = load i32, ptr %k, align 4
  %rem = srem i32 %9, 64
  %sh_prom = zext i32 %rem to i64
  %shl = shl i64 1, %sh_prom
  %and = and i64 %8, %shl
  %cmp7 = icmp ne i64 %and, 0
  %conv8 = zext i1 %cmp7 to i32
  %cmp9 = icmp ne i32 %conv8, 0
  %conv10 = zext i1 %cmp9 to i32
  %conv11 = sext i32 %conv10 to i64
  %10 = load i32, ptr %j, align 4
  %sh_prom12 = zext i32 %10 to i64
  %shl13 = shl i64 %conv11, %sh_prom12
  %11 = load i64, ptr %v, align 8
  %or = or i64 %11, %shl13
  store i64 %or, ptr %v, align 8
  %12 = load i32, ptr %k, align 4
  %inc = add i32 %12, 1
  store i32 %inc, ptr %k, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body5
  %13 = load i32, ptr %j, align 4
  %inc14 = add i32 %13, 1
  store i32 %inc14, ptr %j, align 4
  br label %for.cond2, !llvm.loop !48

for.end:                                          ; preds = %for.cond2
  br label %do.body

do.body:                                          ; preds = %for.end
  %14 = load ptr, ptr %target_fds, align 8
  %15 = load i32, ptr %i, align 4
  %idxprom15 = sext i32 %15 to i64
  %arrayidx16 = getelementptr i64, ptr %14, i64 %idxprom15
  %16 = load i64, ptr %v, align 8
  call void @stq_le_p(ptr noundef %arrayidx16, i64 noundef %16)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %for.inc17

for.inc17:                                        ; preds = %do.end
  %17 = load i32, ptr %i, align 4
  %inc18 = add i32 %17, 1
  store i32 %inc18, ptr %i, align 4
  br label %for.cond, !llvm.loop !49

for.end19:                                        ; preds = %for.cond
  %18 = load ptr, ptr %target_fds, align 8
  %19 = load i64, ptr %target_fds_addr.addr, align 8
  %20 = load i32, ptr %nw, align 4
  %conv20 = sext i32 %20 to i64
  %mul21 = mul i64 8, %conv20
  call void @unlock_user(ptr noundef %18, i64 noundef %19, i64 noundef %mul21)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end19, %if.then
  %21 = load i64, ptr %retval, align 8
  ret i64 %21
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @copy_from_user_fdset(ptr noundef %fds, i64 noundef %target_fds_addr, i32 noundef %n) #0 {
entry:
  %retval = alloca i64, align 8
  %fds.addr = alloca ptr, align 8
  %target_fds_addr.addr = alloca i64, align 8
  %n.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %nw = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %b = alloca i64, align 8
  %target_fds = alloca ptr, align 8
  %__i = alloca i32, align 4
  %__arr = alloca ptr, align 8
  store ptr %fds, ptr %fds.addr, align 8
  store i64 %target_fds_addr, ptr %target_fds_addr.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %add = add i32 %0, 64
  %sub = sub i32 %add, 1
  %div = sdiv i32 %sub, 64
  store i32 %div, ptr %nw, align 4
  %1 = load i64, ptr %target_fds_addr.addr, align 8
  %2 = load i32, ptr %nw, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 8, %conv
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %1, i64 noundef %mul, i1 noundef zeroext true)
  store ptr %call, ptr %target_fds, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %3 = load ptr, ptr %fds.addr, align 8
  store ptr %3, ptr %__arr, align 8
  store i32 0, ptr %__i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body
  %4 = load i32, ptr %__i, align 4
  %conv1 = zext i32 %4 to i64
  %cmp = icmp ult i64 %conv1, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %__arr, align 8
  %fds_bits = getelementptr inbounds %struct.fd_set, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %__i, align 4
  %idxprom = zext i32 %6 to i64
  %arrayidx = getelementptr [16 x i64], ptr %fds_bits, i64 0, i64 %idxprom
  store i64 0, ptr %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %__i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, ptr %__i, align 4
  br label %for.cond, !llvm.loop !50

for.end:                                          ; preds = %for.cond
  br label %do.end

do.end:                                           ; preds = %for.end
  store i32 0, ptr %k, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc28, %do.end
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %nw, align 4
  %cmp4 = icmp slt i32 %8, %9
  br i1 %cmp4, label %for.body6, label %for.end30

for.body6:                                        ; preds = %for.cond3
  br label %do.body7

do.body7:                                         ; preds = %for.body6
  %10 = load ptr, ptr %target_fds, align 8
  %11 = load i32, ptr %i, align 4
  %idxprom8 = sext i32 %11 to i64
  %arrayidx9 = getelementptr i64, ptr %10, i64 %idxprom8
  %call10 = call i64 @ldq_le_p(ptr noundef %arrayidx9)
  store i64 %call10, ptr %b, align 8
  br label %do.end11

do.end11:                                         ; preds = %do.body7
  store i32 0, ptr %j, align 4
  br label %for.cond12

for.cond12:                                       ; preds = %for.inc25, %do.end11
  %12 = load i32, ptr %j, align 4
  %cmp13 = icmp slt i32 %12, 64
  br i1 %cmp13, label %for.body15, label %for.end27

for.body15:                                       ; preds = %for.cond12
  %13 = load i64, ptr %b, align 8
  %14 = load i32, ptr %j, align 4
  %sh_prom = zext i32 %14 to i64
  %shr = lshr i64 %13, %sh_prom
  %and = and i64 %shr, 1
  %tobool16 = icmp ne i64 %and, 0
  br i1 %tobool16, label %if.then17, label %if.end23

if.then17:                                        ; preds = %for.body15
  %15 = load i32, ptr %k, align 4
  %rem = srem i32 %15, 64
  %sh_prom18 = zext i32 %rem to i64
  %shl = shl i64 1, %sh_prom18
  %16 = load ptr, ptr %fds.addr, align 8
  %fds_bits19 = getelementptr inbounds %struct.fd_set, ptr %16, i32 0, i32 0
  %17 = load i32, ptr %k, align 4
  %div20 = sdiv i32 %17, 64
  %idxprom21 = sext i32 %div20 to i64
  %arrayidx22 = getelementptr [16 x i64], ptr %fds_bits19, i64 0, i64 %idxprom21
  %18 = load i64, ptr %arrayidx22, align 8
  %or = or i64 %18, %shl
  store i64 %or, ptr %arrayidx22, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then17, %for.body15
  %19 = load i32, ptr %k, align 4
  %inc24 = add i32 %19, 1
  store i32 %inc24, ptr %k, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %if.end23
  %20 = load i32, ptr %j, align 4
  %inc26 = add i32 %20, 1
  store i32 %inc26, ptr %j, align 4
  br label %for.cond12, !llvm.loop !51

for.end27:                                        ; preds = %for.cond12
  br label %for.inc28

for.inc28:                                        ; preds = %for.end27
  %21 = load i32, ptr %i, align 4
  %inc29 = add i32 %21, 1
  store i32 %inc29, ptr %i, align 4
  br label %for.cond3, !llvm.loop !52

for.end30:                                        ; preds = %for.cond3
  %22 = load ptr, ptr %target_fds, align 8
  %23 = load i64, ptr %target_fds_addr.addr, align 8
  call void @unlock_user(ptr noundef %22, i64 noundef %23, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end30, %if.then
  %24 = load i64, ptr %retval, align 8
  ret i64 %24
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_accept4(i32 noundef %fd, ptr noundef %addr, ptr noundef %len, i32 noundef %flags) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %addr.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %addr, ptr %addr.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %addr.addr, align 8
  %5 = load ptr, ptr %len.addr, align 8
  %6 = load i32, ptr %flags.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 288, i32 noundef %3, ptr noundef %4, ptr noundef %5, i32 noundef %6)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @access_ok(ptr noundef %cpu, i32 noundef %type, i64 noundef %addr, i64 noundef %size) #0 {
entry:
  %cpu.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %addr.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  store ptr %cpu, ptr %cpu.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i32, ptr %type.addr, align 4
  %1 = load ptr, ptr %cpu.addr, align 8
  %2 = load i64, ptr %addr.addr, align 8
  %call = call i64 @cpu_untagged_addr(ptr noundef %1, i64 noundef %2)
  %3 = load i64, ptr %size.addr, align 8
  %call1 = call zeroext i1 @access_ok_untagged(i32 noundef %0, i64 noundef %call, i64 noundef %3)
  ret i1 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_sockaddr(i64 noundef %target_addr, ptr noundef %addr, i32 noundef %len) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %addr.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %target_saddr = alloca ptr, align 8
  %target_nl = alloca ptr, align 8
  %target_ll = alloca ptr, align 8
  %target_in6 = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  %0 = load i32, ptr %len.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %addr.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  br label %if.end2

if.else:                                          ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.633, ptr noundef @.str.579, i32 noundef 1707, ptr noundef @__PRETTY_FUNCTION__.host_to_target_sockaddr) #15
  unreachable

if.end2:                                          ; preds = %if.then1
  %2 = load i64, ptr %target_addr.addr, align 8
  %3 = load i32, ptr %len.addr, align 4
  %conv = zext i32 %3 to i64
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %2, i64 noundef %conv, i1 noundef zeroext false)
  store ptr %call, ptr %target_saddr, align 8
  %4 = load ptr, ptr %target_saddr, align 8
  %tobool3 = icmp ne ptr %4, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end2
  store i64 -14, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end2
  %5 = load ptr, ptr %target_saddr, align 8
  %6 = load ptr, ptr %addr.addr, align 8
  %7 = load i32, ptr %len.addr, align 4
  %conv6 = zext i32 %7 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %5, ptr align 2 %6, i64 %conv6, i1 false)
  %8 = load i32, ptr %len.addr, align 4
  %conv7 = zext i32 %8 to i64
  %cmp8 = icmp uge i64 %conv7, 2
  br i1 %cmp8, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.end5
  %9 = load ptr, ptr %addr.addr, align 8
  %sa_family = getelementptr inbounds %struct.sockaddr, ptr %9, i32 0, i32 0
  %10 = load i16, ptr %sa_family, align 2
  %call11 = call zeroext i16 @tswap16(i16 noundef zeroext %10)
  %11 = load ptr, ptr %target_saddr, align 8
  %sa_family12 = getelementptr inbounds %struct.target_sockaddr, ptr %11, i32 0, i32 0
  store i16 %call11, ptr %sa_family12, align 2
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %if.end5
  %12 = load ptr, ptr %addr.addr, align 8
  %sa_family14 = getelementptr inbounds %struct.sockaddr, ptr %12, i32 0, i32 0
  %13 = load i16, ptr %sa_family14, align 2
  %conv15 = zext i16 %13 to i32
  %cmp16 = icmp eq i32 %conv15, 16
  br i1 %cmp16, label %land.lhs.true, label %if.else26

land.lhs.true:                                    ; preds = %if.end13
  %14 = load i32, ptr %len.addr, align 4
  %conv18 = zext i32 %14 to i64
  %cmp19 = icmp uge i64 %conv18, 12
  br i1 %cmp19, label %if.then21, label %if.else26

if.then21:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %target_saddr, align 8
  store ptr %15, ptr %target_nl, align 8
  %16 = load ptr, ptr %target_nl, align 8
  %nl_pid = getelementptr inbounds %struct.target_sockaddr_nl, ptr %16, i32 0, i32 2
  %17 = load i32, ptr %nl_pid, align 4
  %call22 = call i32 @tswap32(i32 noundef %17)
  %18 = load ptr, ptr %target_nl, align 8
  %nl_pid23 = getelementptr inbounds %struct.target_sockaddr_nl, ptr %18, i32 0, i32 2
  store i32 %call22, ptr %nl_pid23, align 4
  %19 = load ptr, ptr %target_nl, align 8
  %nl_groups = getelementptr inbounds %struct.target_sockaddr_nl, ptr %19, i32 0, i32 3
  %20 = load i32, ptr %nl_groups, align 4
  %call24 = call i32 @tswap32(i32 noundef %20)
  %21 = load ptr, ptr %target_nl, align 8
  %nl_groups25 = getelementptr inbounds %struct.target_sockaddr_nl, ptr %21, i32 0, i32 3
  store i32 %call24, ptr %nl_groups25, align 4
  br label %if.end52

if.else26:                                        ; preds = %land.lhs.true, %if.end13
  %22 = load ptr, ptr %addr.addr, align 8
  %sa_family27 = getelementptr inbounds %struct.sockaddr, ptr %22, i32 0, i32 0
  %23 = load i16, ptr %sa_family27, align 2
  %conv28 = zext i16 %23 to i32
  %cmp29 = icmp eq i32 %conv28, 17
  br i1 %cmp29, label %if.then31, label %if.else36

if.then31:                                        ; preds = %if.else26
  %24 = load ptr, ptr %target_saddr, align 8
  store ptr %24, ptr %target_ll, align 8
  %25 = load ptr, ptr %target_ll, align 8
  %sll_ifindex = getelementptr inbounds %struct.sockaddr_ll, ptr %25, i32 0, i32 2
  %26 = load i32, ptr %sll_ifindex, align 4
  %call32 = call i32 @tswap32(i32 noundef %26)
  %27 = load ptr, ptr %target_ll, align 8
  %sll_ifindex33 = getelementptr inbounds %struct.sockaddr_ll, ptr %27, i32 0, i32 2
  store i32 %call32, ptr %sll_ifindex33, align 4
  %28 = load ptr, ptr %target_ll, align 8
  %sll_hatype = getelementptr inbounds %struct.sockaddr_ll, ptr %28, i32 0, i32 3
  %29 = load i16, ptr %sll_hatype, align 4
  %call34 = call zeroext i16 @tswap16(i16 noundef zeroext %29)
  %30 = load ptr, ptr %target_ll, align 8
  %sll_hatype35 = getelementptr inbounds %struct.sockaddr_ll, ptr %30, i32 0, i32 3
  store i16 %call34, ptr %sll_hatype35, align 4
  br label %if.end51

if.else36:                                        ; preds = %if.else26
  %31 = load ptr, ptr %addr.addr, align 8
  %sa_family37 = getelementptr inbounds %struct.sockaddr, ptr %31, i32 0, i32 0
  %32 = load i16, ptr %sa_family37, align 2
  %conv38 = zext i16 %32 to i32
  %cmp39 = icmp eq i32 %conv38, 10
  br i1 %cmp39, label %land.lhs.true41, label %if.end50

land.lhs.true41:                                  ; preds = %if.else36
  %33 = load i32, ptr %len.addr, align 4
  %conv42 = zext i32 %33 to i64
  %cmp43 = icmp uge i64 %conv42, 28
  br i1 %cmp43, label %if.then45, label %if.end50

if.then45:                                        ; preds = %land.lhs.true41
  %34 = load ptr, ptr %target_saddr, align 8
  store ptr %34, ptr %target_in6, align 8
  %35 = load ptr, ptr %target_in6, align 8
  %sin6_scope_id = getelementptr inbounds %struct.target_sockaddr_in6, ptr %35, i32 0, i32 4
  %36 = load i32, ptr %sin6_scope_id, align 4
  %conv46 = trunc i32 %36 to i16
  %call47 = call zeroext i16 @tswap16(i16 noundef zeroext %conv46)
  %conv48 = zext i16 %call47 to i32
  %37 = load ptr, ptr %target_in6, align 8
  %sin6_scope_id49 = getelementptr inbounds %struct.target_sockaddr_in6, ptr %37, i32 0, i32 4
  store i32 %conv48, ptr %sin6_scope_id49, align 4
  br label %if.end50

if.end50:                                         ; preds = %if.then45, %land.lhs.true41, %if.else36
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.then31
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %if.then21
  %38 = load ptr, ptr %target_saddr, align 8
  %39 = load i64, ptr %target_addr.addr, align 8
  %40 = load i32, ptr %len.addr, align 4
  %conv53 = zext i32 %40 to i64
  call void @unlock_user(ptr noundef %38, i64 noundef %39, i64 noundef %conv53)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end52, %if.then4, %if.then
  %41 = load i64, ptr %retval, align 8
  ret i64 %41
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @access_ok_untagged(i32 noundef %type, i64 noundef %addr, i64 noundef %size) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  %addr.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  store i32 %type, ptr %type.addr, align 4
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %addr.addr, align 8
  %call = call zeroext i1 @guest_addr_valid_untagged(i64 noundef %1)
  br i1 %call, label %if.end, label %if.then

cond.false:                                       ; preds = %entry
  %2 = load i64, ptr %addr.addr, align 8
  %3 = load i64, ptr %size.addr, align 8
  %call1 = call zeroext i1 @guest_range_valid_untagged(i64 noundef %2, i64 noundef %3)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %cond.false, %cond.true
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %cond.false, %cond.true
  %4 = load i64, ptr %addr.addr, align 8
  %5 = load i64, ptr %size.addr, align 8
  %6 = load i32, ptr %type.addr, align 4
  %call2 = call zeroext i1 @page_check_range(i64 noundef %4, i64 noundef %5, i32 noundef %6)
  store i1 %call2, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, ptr %retval, align 1
  ret i1 %7
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @guest_addr_valid_untagged(i64 noundef %x) #0 {
entry:
  %x.addr = alloca i64, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load i64, ptr %x.addr, align 8
  %1 = load i64, ptr @reserved_va, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %1, %cond.true ], [ -1, %cond.false ]
  %cmp = icmp ule i64 %0, %cond
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @guest_range_valid_untagged(i64 noundef %start, i64 noundef %len) #0 {
entry:
  %start.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  store i64 %start, ptr %start.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i64, ptr %len.addr, align 8
  %sub = sub i64 %0, 1
  %1 = load i64, ptr @reserved_va, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %1, %cond.true ], [ -1, %cond.false ]
  %cmp = icmp ule i64 %sub, %cond
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.end
  %2 = load i64, ptr %start.addr, align 8
  %3 = load i64, ptr @reserved_va, align 8
  %tobool1 = icmp ne i64 %3, 0
  br i1 %tobool1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %land.rhs
  br label %cond.end4

cond.false3:                                      ; preds = %land.rhs
  br label %cond.end4

cond.end4:                                        ; preds = %cond.false3, %cond.true2
  %cond5 = phi i64 [ %3, %cond.true2 ], [ -1, %cond.false3 ]
  %4 = load i64, ptr %len.addr, align 8
  %sub6 = sub i64 %cond5, %4
  %add = add i64 %sub6, 1
  %cmp7 = icmp ule i64 %2, %add
  br label %land.end

land.end:                                         ; preds = %cond.end4, %cond.end
  %5 = phi i1 [ false, %cond.end ], [ %cmp7, %cond.end4 ]
  ret i1 %5
}

declare zeroext i1 @page_check_range(i64 noundef, i64 noundef, i32 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_sockaddr(i32 noundef %fd, ptr noundef %addr, i64 noundef %target_addr, i32 noundef %len) #0 {
entry:
  %retval = alloca i64, align 8
  %fd.addr = alloca i32, align 4
  %addr.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %len.addr = alloca i32, align 4
  %unix_maxlen = alloca i32, align 4
  %sa_family = alloca i16, align 2
  %target_saddr = alloca ptr, align 8
  %cp = alloca ptr, align 8
  %nladdr = alloca ptr, align 8
  %lladdr = alloca ptr, align 8
  %in6addr = alloca ptr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store i32 110, ptr %unix_maxlen, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %call = call ptr @fd_trans_target_to_host_addr(i32 noundef %0)
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %fd.addr, align 4
  %call1 = call ptr @fd_trans_target_to_host_addr(i32 noundef %1)
  %2 = load ptr, ptr %addr.addr, align 8
  %3 = load i64, ptr %target_addr.addr, align 8
  %4 = load i32, ptr %len.addr, align 4
  %call2 = call i64 %call1(ptr noundef %2, i64 noundef %3, i32 noundef %4)
  store i64 %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, ptr %target_addr.addr, align 8
  %6 = load i32, ptr %len.addr, align 4
  %conv = zext i32 %6 to i64
  %call3 = call ptr @lock_user(i32 noundef 1, i64 noundef %5, i64 noundef %conv, i1 noundef zeroext true)
  store ptr %call3, ptr %target_saddr, align 8
  %7 = load ptr, ptr %target_saddr, align 8
  %tobool4 = icmp ne ptr %7, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %8 = load ptr, ptr %target_saddr, align 8
  %sa_family7 = getelementptr inbounds %struct.target_sockaddr, ptr %8, i32 0, i32 0
  %9 = load i16, ptr %sa_family7, align 2
  %call8 = call zeroext i16 @tswap16(i16 noundef zeroext %9)
  store i16 %call8, ptr %sa_family, align 2
  %10 = load i16, ptr %sa_family, align 2
  %conv9 = zext i16 %10 to i32
  %cmp = icmp eq i32 %conv9, 1
  br i1 %cmp, label %if.then11, label %if.end30

if.then11:                                        ; preds = %if.end6
  %11 = load i32, ptr %len.addr, align 4
  %cmp12 = icmp ult i32 %11, 110
  br i1 %cmp12, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %if.then11
  %12 = load i32, ptr %len.addr, align 4
  %cmp14 = icmp ugt i32 %12, 0
  br i1 %cmp14, label %if.then16, label %if.end25

if.then16:                                        ; preds = %land.lhs.true
  %13 = load ptr, ptr %target_saddr, align 8
  store ptr %13, ptr %cp, align 8
  %14 = load ptr, ptr %cp, align 8
  %15 = load i32, ptr %len.addr, align 4
  %sub = sub i32 %15, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr i8, ptr %14, i64 %idxprom
  %16 = load i8, ptr %arrayidx, align 1
  %conv17 = sext i8 %16 to i32
  %tobool18 = icmp ne i32 %conv17, 0
  br i1 %tobool18, label %land.lhs.true19, label %if.end24

land.lhs.true19:                                  ; preds = %if.then16
  %17 = load ptr, ptr %cp, align 8
  %18 = load i32, ptr %len.addr, align 4
  %idxprom20 = zext i32 %18 to i64
  %arrayidx21 = getelementptr i8, ptr %17, i64 %idxprom20
  %19 = load i8, ptr %arrayidx21, align 1
  %tobool22 = icmp ne i8 %19, 0
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %land.lhs.true19
  %20 = load i32, ptr %len.addr, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %len.addr, align 4
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %land.lhs.true19, %if.then16
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %land.lhs.true, %if.then11
  %21 = load i32, ptr %len.addr, align 4
  %cmp26 = icmp ugt i32 %21, 110
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end25
  store i32 110, ptr %len.addr, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end25
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %if.end6
  %22 = load ptr, ptr %addr.addr, align 8
  %23 = load ptr, ptr %target_saddr, align 8
  %24 = load i32, ptr %len.addr, align 4
  %conv31 = zext i32 %24 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %22, ptr align 2 %23, i64 %conv31, i1 false)
  %25 = load i16, ptr %sa_family, align 2
  %26 = load ptr, ptr %addr.addr, align 8
  %sa_family32 = getelementptr inbounds %struct.sockaddr, ptr %26, i32 0, i32 0
  store i16 %25, ptr %sa_family32, align 2
  %27 = load i16, ptr %sa_family, align 2
  %conv33 = zext i16 %27 to i32
  %cmp34 = icmp eq i32 %conv33, 16
  br i1 %cmp34, label %if.then36, label %if.else

if.then36:                                        ; preds = %if.end30
  %28 = load ptr, ptr %addr.addr, align 8
  store ptr %28, ptr %nladdr, align 8
  %29 = load ptr, ptr %nladdr, align 8
  %nl_pid = getelementptr inbounds %struct.sockaddr_nl, ptr %29, i32 0, i32 2
  %30 = load i32, ptr %nl_pid, align 4
  %call37 = call i32 @tswap32(i32 noundef %30)
  %31 = load ptr, ptr %nladdr, align 8
  %nl_pid38 = getelementptr inbounds %struct.sockaddr_nl, ptr %31, i32 0, i32 2
  store i32 %call37, ptr %nl_pid38, align 4
  %32 = load ptr, ptr %nladdr, align 8
  %nl_groups = getelementptr inbounds %struct.sockaddr_nl, ptr %32, i32 0, i32 3
  %33 = load i32, ptr %nl_groups, align 4
  %call39 = call i32 @tswap32(i32 noundef %33)
  %34 = load ptr, ptr %nladdr, align 8
  %nl_groups40 = getelementptr inbounds %struct.sockaddr_nl, ptr %34, i32 0, i32 3
  store i32 %call39, ptr %nl_groups40, align 4
  br label %if.end58

if.else:                                          ; preds = %if.end30
  %35 = load i16, ptr %sa_family, align 2
  %conv41 = zext i16 %35 to i32
  %cmp42 = icmp eq i32 %conv41, 17
  br i1 %cmp42, label %if.then44, label %if.else49

if.then44:                                        ; preds = %if.else
  %36 = load ptr, ptr %addr.addr, align 8
  store ptr %36, ptr %lladdr, align 8
  %37 = load ptr, ptr %lladdr, align 8
  %sll_ifindex = getelementptr inbounds %struct.target_sockaddr_ll, ptr %37, i32 0, i32 2
  %38 = load i32, ptr %sll_ifindex, align 4
  %call45 = call i32 @tswap32(i32 noundef %38)
  %39 = load ptr, ptr %lladdr, align 8
  %sll_ifindex46 = getelementptr inbounds %struct.target_sockaddr_ll, ptr %39, i32 0, i32 2
  store i32 %call45, ptr %sll_ifindex46, align 4
  %40 = load ptr, ptr %lladdr, align 8
  %sll_hatype = getelementptr inbounds %struct.target_sockaddr_ll, ptr %40, i32 0, i32 3
  %41 = load i16, ptr %sll_hatype, align 4
  %call47 = call zeroext i16 @tswap16(i16 noundef zeroext %41)
  %42 = load ptr, ptr %lladdr, align 8
  %sll_hatype48 = getelementptr inbounds %struct.target_sockaddr_ll, ptr %42, i32 0, i32 3
  store i16 %call47, ptr %sll_hatype48, align 4
  br label %if.end57

if.else49:                                        ; preds = %if.else
  %43 = load i16, ptr %sa_family, align 2
  %conv50 = zext i16 %43 to i32
  %cmp51 = icmp eq i32 %conv50, 10
  br i1 %cmp51, label %if.then53, label %if.end56

if.then53:                                        ; preds = %if.else49
  %44 = load ptr, ptr %addr.addr, align 8
  store ptr %44, ptr %in6addr, align 8
  %45 = load ptr, ptr %in6addr, align 8
  %sin6_scope_id = getelementptr inbounds %struct.sockaddr_in6, ptr %45, i32 0, i32 4
  %46 = load i32, ptr %sin6_scope_id, align 4
  %call54 = call i32 @tswap32(i32 noundef %46)
  %47 = load ptr, ptr %in6addr, align 8
  %sin6_scope_id55 = getelementptr inbounds %struct.sockaddr_in6, ptr %47, i32 0, i32 4
  store i32 %call54, ptr %sin6_scope_id55, align 4
  br label %if.end56

if.end56:                                         ; preds = %if.then53, %if.else49
  br label %if.end57

if.end57:                                         ; preds = %if.end56, %if.then44
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.then36
  %48 = load ptr, ptr %target_saddr, align 8
  %49 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %48, i64 noundef %49, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end58, %if.then5, %if.then
  %50 = load i64, ptr %retval, align 8
  ret i64 %50
}

; Function Attrs: nounwind
declare i32 @bind(i32 noundef, ptr, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @fd_trans_target_to_host_addr(i32 noundef %fd) #0 {
entry:
  %x.addr.i = alloca ptr, align 8
  %lockable.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %qemu_lockable_auto2 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.QemuLockable, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %object = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 0
  store ptr @target_fd_trans_lock, ptr %object, align 8
  %lock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 1
  store ptr @qemu_mutex_lock, ptr %lock, align 8
  %unlock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 2
  store ptr @qemu_mutex_unlock, ptr %unlock, align 8
  store ptr @target_fd_trans_lock, ptr %x.addr.i, align 8
  store ptr %.compoundliteral, ptr %lockable.addr.i, align 8
  %1 = load ptr, ptr %x.addr.i, align 8
  %tobool.i = icmp ne ptr %1, null
  br i1 %tobool.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %if.end
  %2 = load ptr, ptr %lockable.addr.i, align 8
  br label %qemu_make_lockable.exit

cond.false.i:                                     ; preds = %if.end
  br label %qemu_make_lockable.exit

qemu_make_lockable.exit:                          ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi ptr [ %2, %cond.true.i ], [ null, %cond.false.i ]
  %call1 = call ptr @qemu_lockable_auto_lock(ptr noundef %cond.i)
  store ptr %call1, ptr %qemu_lockable_auto2, align 8
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load i32, ptr @target_fd_max, align 4
  %cmp2 = icmp ult i32 %3, %4
  br i1 %cmp2, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %qemu_make_lockable.exit
  %5 = load ptr, ptr @target_fd_trans, align 8
  %6 = load i32, ptr %fd.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr ptr, ptr %5, i64 %idxprom
  %7 = load ptr, ptr %arrayidx, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %if.then3, label %if.end6

if.then3:                                         ; preds = %land.lhs.true
  %8 = load ptr, ptr @target_fd_trans, align 8
  %9 = load i32, ptr %fd.addr, align 4
  %idxprom4 = sext i32 %9 to i64
  %arrayidx5 = getelementptr ptr, ptr %8, i64 %idxprom4
  %10 = load ptr, ptr %arrayidx5, align 8
  %target_to_host_addr = getelementptr inbounds %struct.TargetFdTrans, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %target_to_host_addr, align 8
  store ptr %11, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end6:                                          ; preds = %land.lhs.true, %qemu_make_lockable.exit
  store ptr null, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.then3
  call void @glib_autoptr_cleanup_QemuLockable(ptr noundef %qemu_lockable_auto2)
  br label %return

return:                                           ; preds = %cleanup, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_connect(i32 noundef %fd, ptr noundef %addr, i32 noundef %addrlen) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %addr.addr = alloca ptr, align 8
  %addrlen.addr = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %addr, ptr %addr.addr, align 8
  store i32 %addrlen, ptr %addrlen.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %addr.addr, align 8
  %5 = load i32, ptr %addrlen.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 42, i32 noundef %3, ptr noundef %4, i32 noundef %5)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @getpeername(i32 noundef, ptr, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @getsockname(i32 noundef, ptr, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @getsockopt(i32 noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @host_to_target_sock_type(i32 noundef %host_type) #0 {
entry:
  %host_type.addr = alloca i32, align 4
  %target_type = alloca i32, align 4
  store i32 %host_type, ptr %host_type.addr, align 4
  %0 = load i32, ptr %host_type.addr, align 4
  %and = and i32 %0, 15
  switch i32 %and, label %sw.default [
    i32 2, label %sw.bb
    i32 1, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  store i32 2, ptr %target_type, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  store i32 1, ptr %target_type, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %1 = load i32, ptr %host_type.addr, align 4
  %and2 = and i32 %1, 15
  store i32 %and2, ptr %target_type, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb1, %sw.bb
  %2 = load i32, ptr %host_type.addr, align 4
  %and3 = and i32 %2, 524288
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.epilog
  %3 = load i32, ptr %target_type, align 4
  %or = or i32 %3, 524288
  store i32 %or, ptr %target_type, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.epilog
  %4 = load i32, ptr %host_type.addr, align 4
  %and4 = and i32 %4, 2048
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %5 = load i32, ptr %target_type, align 4
  %or7 = or i32 %5, 2048
  store i32 %or7, ptr %target_type, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %6 = load i32, ptr %target_type, align 4
  ret i32 %6
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stb_p(ptr noundef %ptr, i8 noundef zeroext %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i8, align 1
  store ptr %ptr, ptr %ptr.addr, align 8
  store i8 %v, ptr %v.addr, align 1
  %0 = load i8, ptr %v.addr, align 1
  %1 = load ptr, ptr %ptr.addr, align 8
  store i8 %0, ptr %1, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @safe_recvfrom(i32 noundef %fd, ptr noundef %buf, i64 noundef %len, i32 noundef %flags, ptr noundef %addr, ptr noundef %addrlen) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %addr.addr = alloca ptr, align 8
  %addrlen.addr = alloca ptr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %addr, ptr %addr.addr, align 8
  store ptr %addrlen, ptr %addrlen.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %buf.addr, align 8
  %5 = load i64, ptr %len.addr, align 8
  %6 = load i32, ptr %flags.addr, align 4
  %7 = load ptr, ptr %addr.addr, align 8
  %8 = load ptr, ptr %addrlen.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 45, i32 noundef %3, ptr noundef %4, i64 noundef %5, i32 noundef %6, ptr noundef %7, ptr noundef %8)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_sendrecvmsg_locked(i32 noundef %fd, ptr noundef %msgp, i32 noundef %flags, i32 noundef %send) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %msgp.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %send.addr = alloca i32, align 4
  %ret = alloca i64, align 8
  %len = alloca i64, align 8
  %msg = alloca %struct.msghdr, align 8
  %count = alloca i64, align 8
  %vec = alloca ptr, align 8
  %target_vec = alloca i64, align 8
  %host_msg = alloca ptr, align 8
  %_a8 = alloca i64, align 8
  %_b9 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %msgp, ptr %msgp.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %send, ptr %send.addr, align 4
  %0 = load ptr, ptr %msgp.addr, align 8
  %msg_name = getelementptr inbounds %struct.target_msghdr, ptr %0, i32 0, i32 0
  %1 = load i64, ptr %msg_name, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.else15

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %msgp.addr, align 8
  %msg_namelen = getelementptr inbounds %struct.target_msghdr, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %msg_namelen, align 8
  %call = call i32 @tswap32(i32 noundef %3)
  %msg_namelen1 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 1
  store i32 %call, ptr %msg_namelen1, align 8
  %msg_namelen2 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 1
  %4 = load i32, ptr %msg_namelen2, align 8
  %add = add i32 %4, 1
  %conv = zext i32 %add to i64
  %5 = alloca i8, i64 %conv, align 16
  %msg_name3 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 0
  store ptr %5, ptr %msg_name3, align 8
  %6 = load i32, ptr %fd.addr, align 4
  %msg_name4 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 0
  %7 = load ptr, ptr %msg_name4, align 8
  %8 = load ptr, ptr %msgp.addr, align 8
  %msg_name5 = getelementptr inbounds %struct.target_msghdr, ptr %8, i32 0, i32 0
  %9 = load i64, ptr %msg_name5, align 8
  %call6 = call i64 @tswapal(i64 noundef %9)
  %msg_namelen7 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 1
  %10 = load i32, ptr %msg_namelen7, align 8
  %call8 = call i64 @target_to_host_sockaddr(i32 noundef %6, ptr noundef %7, i64 noundef %call6, i32 noundef %10)
  store i64 %call8, ptr %ret, align 8
  %11 = load i64, ptr %ret, align 8
  %cmp = icmp eq i64 %11, -14
  br i1 %cmp, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then
  %msg_name11 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 0
  store ptr inttoptr (i64 -1 to ptr), ptr %msg_name11, align 8
  br label %if.end14

if.else:                                          ; preds = %if.then
  %12 = load i64, ptr %ret, align 8
  %tobool12 = icmp ne i64 %12, 0
  br i1 %tobool12, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.else
  br label %out2

if.end:                                           ; preds = %if.else
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then10
  br label %if.end18

if.else15:                                        ; preds = %entry
  %msg_name16 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 0
  store ptr null, ptr %msg_name16, align 8
  %msg_namelen17 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 1
  store i32 0, ptr %msg_namelen17, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.else15, %if.end14
  %13 = load ptr, ptr %msgp.addr, align 8
  %msg_controllen = getelementptr inbounds %struct.target_msghdr, ptr %13, i32 0, i32 5
  %14 = load i64, ptr %msg_controllen, align 8
  %call19 = call i64 @tswapal(i64 noundef %14)
  %mul = mul i64 2, %call19
  %msg_controllen20 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 5
  store i64 %mul, ptr %msg_controllen20, align 8
  %msg_controllen21 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 5
  %15 = load i64, ptr %msg_controllen21, align 8
  %16 = alloca i8, i64 %15, align 16
  %msg_control = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 4
  store ptr %16, ptr %msg_control, align 8
  %msg_control22 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 4
  %17 = load ptr, ptr %msg_control22, align 8
  %msg_controllen23 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 5
  %18 = load i64, ptr %msg_controllen23, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %17, i8 0, i64 %18, i1 false)
  %19 = load ptr, ptr %msgp.addr, align 8
  %msg_flags = getelementptr inbounds %struct.target_msghdr, ptr %19, i32 0, i32 6
  %20 = load i32, ptr %msg_flags, align 8
  %call24 = call i32 @tswap32(i32 noundef %20)
  %msg_flags25 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 6
  store i32 %call24, ptr %msg_flags25, align 8
  %21 = load ptr, ptr %msgp.addr, align 8
  %msg_iovlen = getelementptr inbounds %struct.target_msghdr, ptr %21, i32 0, i32 3
  %22 = load i64, ptr %msg_iovlen, align 8
  %call26 = call i64 @tswapal(i64 noundef %22)
  store i64 %call26, ptr %count, align 8
  %23 = load ptr, ptr %msgp.addr, align 8
  %msg_iov = getelementptr inbounds %struct.target_msghdr, ptr %23, i32 0, i32 2
  %24 = load i64, ptr %msg_iov, align 8
  %call27 = call i64 @tswapal(i64 noundef %24)
  store i64 %call27, ptr %target_vec, align 8
  %25 = load i64, ptr %count, align 8
  %cmp28 = icmp ugt i64 %25, 1024
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end18
  store i64 -90, ptr %ret, align 8
  br label %out2

if.end31:                                         ; preds = %if.end18
  %26 = load i32, ptr %send.addr, align 4
  %tobool32 = icmp ne i32 %26, 0
  %cond = select i1 %tobool32, i32 1, i32 3
  %27 = load i64, ptr %target_vec, align 8
  %28 = load i64, ptr %count, align 8
  %29 = load i32, ptr %send.addr, align 4
  %call33 = call ptr @lock_iovec(i32 noundef %cond, i64 noundef %27, i64 noundef %28, i32 noundef %29)
  store ptr %call33, ptr %vec, align 8
  %30 = load ptr, ptr %vec, align 8
  %cmp34 = icmp eq ptr %30, null
  br i1 %cmp34, label %if.then36, label %if.end44

if.then36:                                        ; preds = %if.end31
  %call37 = call ptr @__errno_location() #13
  %31 = load i32, ptr %call37, align 4
  %call38 = call i32 @host_to_target_errno(i32 noundef %31)
  %sub = sub i32 0, %call38
  %conv39 = sext i32 %sub to i64
  store i64 %conv39, ptr %ret, align 8
  %32 = load i32, ptr %send.addr, align 4
  %tobool40 = icmp ne i32 %32, 0
  br i1 %tobool40, label %lor.lhs.false, label %if.then42

lor.lhs.false:                                    ; preds = %if.then36
  %33 = load i64, ptr %ret, align 8
  %tobool41 = icmp ne i64 %33, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %lor.lhs.false, %if.then36
  br label %out2

if.end43:                                         ; preds = %lor.lhs.false
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.end31
  %34 = load i64, ptr %count, align 8
  %msg_iovlen45 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 3
  store i64 %34, ptr %msg_iovlen45, align 8
  %35 = load ptr, ptr %vec, align 8
  %msg_iov46 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 2
  store ptr %35, ptr %msg_iov46, align 8
  %36 = load i32, ptr %send.addr, align 4
  %tobool47 = icmp ne i32 %36, 0
  br i1 %tobool47, label %if.then48, label %if.else78

if.then48:                                        ; preds = %if.end44
  %37 = load i32, ptr %fd.addr, align 4
  %call49 = call ptr @fd_trans_target_to_host_data(i32 noundef %37)
  %tobool50 = icmp ne ptr %call49, null
  br i1 %tobool50, label %if.then51, label %if.else69

if.then51:                                        ; preds = %if.then48
  %msg_iov52 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 2
  %38 = load ptr, ptr %msg_iov52, align 8
  %iov_len = getelementptr inbounds %struct.iovec, ptr %38, i32 0, i32 1
  %39 = load i64, ptr %iov_len, align 8
  %call53 = call noalias ptr @g_malloc(i64 noundef %39) #16
  store ptr %call53, ptr %host_msg, align 8
  %40 = load ptr, ptr %host_msg, align 8
  %msg_iov54 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 2
  %41 = load ptr, ptr %msg_iov54, align 8
  %iov_base = getelementptr inbounds %struct.iovec, ptr %41, i32 0, i32 0
  %42 = load ptr, ptr %iov_base, align 8
  %msg_iov55 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 2
  %43 = load ptr, ptr %msg_iov55, align 8
  %iov_len56 = getelementptr inbounds %struct.iovec, ptr %43, i32 0, i32 1
  %44 = load i64, ptr %iov_len56, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %40, ptr align 1 %42, i64 %44, i1 false)
  %45 = load i32, ptr %fd.addr, align 4
  %call57 = call ptr @fd_trans_target_to_host_data(i32 noundef %45)
  %46 = load ptr, ptr %host_msg, align 8
  %msg_iov58 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 2
  %47 = load ptr, ptr %msg_iov58, align 8
  %iov_len59 = getelementptr inbounds %struct.iovec, ptr %47, i32 0, i32 1
  %48 = load i64, ptr %iov_len59, align 8
  %call60 = call i64 %call57(ptr noundef %46, i64 noundef %48)
  store i64 %call60, ptr %ret, align 8
  %49 = load i64, ptr %ret, align 8
  %cmp61 = icmp sge i64 %49, 0
  br i1 %cmp61, label %if.then63, label %if.end68

if.then63:                                        ; preds = %if.then51
  %50 = load ptr, ptr %host_msg, align 8
  %msg_iov64 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 2
  %51 = load ptr, ptr %msg_iov64, align 8
  %iov_base65 = getelementptr inbounds %struct.iovec, ptr %51, i32 0, i32 0
  store ptr %50, ptr %iov_base65, align 8
  %52 = load i32, ptr %fd.addr, align 4
  %53 = load i32, ptr %flags.addr, align 4
  %call66 = call i64 @safe_sendmsg(i32 noundef %52, ptr noundef %msg, i32 noundef %53)
  %call67 = call i64 @get_errno(i64 noundef %call66)
  store i64 %call67, ptr %ret, align 8
  br label %if.end68

if.end68:                                         ; preds = %if.then63, %if.then51
  %54 = load ptr, ptr %host_msg, align 8
  call void @g_free(ptr noundef %54)
  br label %if.end77

if.else69:                                        ; preds = %if.then48
  %55 = load ptr, ptr %msgp.addr, align 8
  %call70 = call i64 @target_to_host_cmsg(ptr noundef %msg, ptr noundef %55)
  store i64 %call70, ptr %ret, align 8
  %56 = load i64, ptr %ret, align 8
  %cmp71 = icmp eq i64 %56, 0
  br i1 %cmp71, label %if.then73, label %if.end76

if.then73:                                        ; preds = %if.else69
  %57 = load i32, ptr %fd.addr, align 4
  %58 = load i32, ptr %flags.addr, align 4
  %call74 = call i64 @safe_sendmsg(i32 noundef %57, ptr noundef %msg, i32 noundef %58)
  %call75 = call i64 @get_errno(i64 noundef %call74)
  store i64 %call75, ptr %ret, align 8
  br label %if.end76

if.end76:                                         ; preds = %if.then73, %if.else69
  br label %if.end77

if.end77:                                         ; preds = %if.end76, %if.end68
  br label %if.end129

if.else78:                                        ; preds = %if.end44
  %59 = load i32, ptr %fd.addr, align 4
  %60 = load i32, ptr %flags.addr, align 4
  %call79 = call i64 @safe_recvmsg(i32 noundef %59, ptr noundef %msg, i32 noundef %60)
  %call80 = call i64 @get_errno(i64 noundef %call79)
  store i64 %call80, ptr %ret, align 8
  %61 = load i64, ptr %ret, align 8
  %call81 = call i32 @is_error(i64 noundef %61)
  %tobool82 = icmp ne i32 %call81, 0
  br i1 %tobool82, label %if.end128, label %if.then83

if.then83:                                        ; preds = %if.else78
  %62 = load i64, ptr %ret, align 8
  store i64 %62, ptr %len, align 8
  %63 = load i32, ptr %fd.addr, align 4
  %call84 = call ptr @fd_trans_host_to_target_data(i32 noundef %63)
  %tobool85 = icmp ne ptr %call84, null
  br i1 %tobool85, label %if.then86, label %if.end96

if.then86:                                        ; preds = %if.then83
  %64 = load i32, ptr %fd.addr, align 4
  %call87 = call ptr @fd_trans_host_to_target_data(i32 noundef %64)
  %msg_iov88 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 2
  %65 = load ptr, ptr %msg_iov88, align 8
  %iov_base89 = getelementptr inbounds %struct.iovec, ptr %65, i32 0, i32 0
  %66 = load ptr, ptr %iov_base89, align 8
  %msg_iov90 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 2
  %67 = load ptr, ptr %msg_iov90, align 8
  %iov_len91 = getelementptr inbounds %struct.iovec, ptr %67, i32 0, i32 1
  %68 = load i64, ptr %iov_len91, align 8
  store i64 %68, ptr %_a8, align 8
  %69 = load i64, ptr %len, align 8
  store i64 %69, ptr %_b9, align 8
  %70 = load i64, ptr %_a8, align 8
  %71 = load i64, ptr %_b9, align 8
  %cmp92 = icmp ult i64 %70, %71
  br i1 %cmp92, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then86
  %72 = load i64, ptr %_a8, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then86
  %73 = load i64, ptr %_b9, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond94 = phi i64 [ %72, %cond.true ], [ %73, %cond.false ]
  store i64 %cond94, ptr %tmp, align 8
  %74 = load i64, ptr %tmp, align 8
  %call95 = call i64 %call87(ptr noundef %66, i64 noundef %74)
  store i64 %call95, ptr %ret, align 8
  br label %if.end96

if.end96:                                         ; preds = %cond.end, %if.then83
  %75 = load i64, ptr %ret, align 8
  %call97 = call i32 @is_error(i64 noundef %75)
  %tobool98 = icmp ne i32 %call97, 0
  br i1 %tobool98, label %if.end101, label %if.then99

if.then99:                                        ; preds = %if.end96
  %76 = load ptr, ptr %msgp.addr, align 8
  %call100 = call i64 @host_to_target_cmsg(ptr noundef %76, ptr noundef %msg)
  store i64 %call100, ptr %ret, align 8
  br label %if.end101

if.end101:                                        ; preds = %if.then99, %if.end96
  %77 = load i64, ptr %ret, align 8
  %call102 = call i32 @is_error(i64 noundef %77)
  %tobool103 = icmp ne i32 %call102, 0
  br i1 %tobool103, label %if.end127, label %if.then104

if.then104:                                       ; preds = %if.end101
  %msg_namelen105 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 1
  %78 = load i32, ptr %msg_namelen105, align 8
  %call106 = call i32 @tswap32(i32 noundef %78)
  %79 = load ptr, ptr %msgp.addr, align 8
  %msg_namelen107 = getelementptr inbounds %struct.target_msghdr, ptr %79, i32 0, i32 1
  store i32 %call106, ptr %msg_namelen107, align 8
  %msg_flags108 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 6
  %80 = load i32, ptr %msg_flags108, align 8
  %call109 = call i32 @tswap32(i32 noundef %80)
  %81 = load ptr, ptr %msgp.addr, align 8
  %msg_flags110 = getelementptr inbounds %struct.target_msghdr, ptr %81, i32 0, i32 6
  store i32 %call109, ptr %msg_flags110, align 8
  %msg_name111 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 0
  %82 = load ptr, ptr %msg_name111, align 8
  %cmp112 = icmp ne ptr %82, null
  br i1 %cmp112, label %land.lhs.true, label %if.end126

land.lhs.true:                                    ; preds = %if.then104
  %msg_name114 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 0
  %83 = load ptr, ptr %msg_name114, align 8
  %cmp115 = icmp ne ptr %83, inttoptr (i64 -1 to ptr)
  br i1 %cmp115, label %if.then117, label %if.end126

if.then117:                                       ; preds = %land.lhs.true
  %84 = load ptr, ptr %msgp.addr, align 8
  %msg_name118 = getelementptr inbounds %struct.target_msghdr, ptr %84, i32 0, i32 0
  %85 = load i64, ptr %msg_name118, align 8
  %call119 = call i64 @tswapal(i64 noundef %85)
  %msg_name120 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 0
  %86 = load ptr, ptr %msg_name120, align 8
  %msg_namelen121 = getelementptr inbounds %struct.msghdr, ptr %msg, i32 0, i32 1
  %87 = load i32, ptr %msg_namelen121, align 8
  %call122 = call i64 @host_to_target_sockaddr(i64 noundef %call119, ptr noundef %86, i32 noundef %87)
  store i64 %call122, ptr %ret, align 8
  %88 = load i64, ptr %ret, align 8
  %tobool123 = icmp ne i64 %88, 0
  br i1 %tobool123, label %if.then124, label %if.end125

if.then124:                                       ; preds = %if.then117
  br label %out

if.end125:                                        ; preds = %if.then117
  br label %if.end126

if.end126:                                        ; preds = %if.end125, %land.lhs.true, %if.then104
  %89 = load i64, ptr %len, align 8
  store i64 %89, ptr %ret, align 8
  br label %if.end127

if.end127:                                        ; preds = %if.end126, %if.end101
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.else78
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.end77
  br label %out

out:                                              ; preds = %if.end129, %if.then124
  %90 = load ptr, ptr %vec, align 8
  %tobool130 = icmp ne ptr %90, null
  br i1 %tobool130, label %if.then131, label %if.end133

if.then131:                                       ; preds = %out
  %91 = load ptr, ptr %vec, align 8
  %92 = load i64, ptr %target_vec, align 8
  %93 = load i64, ptr %count, align 8
  %94 = load i32, ptr %send.addr, align 4
  %tobool132 = icmp ne i32 %94, 0
  %lnot = xor i1 %tobool132, true
  %lnot.ext = zext i1 %lnot to i32
  call void @unlock_iovec(ptr noundef %91, i64 noundef %92, i64 noundef %93, i32 noundef %lnot.ext)
  br label %if.end133

if.end133:                                        ; preds = %if.then131, %out
  br label %out2

out2:                                             ; preds = %if.end133, %if.then42, %if.then30, %if.then13
  %95 = load i64, ptr %ret, align 8
  ret i64 %95
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @safe_sendmsg(i32 noundef %fd, ptr noundef %msg, i32 noundef %flags) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %msg.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %msg, ptr %msg.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %msg.addr, align 8
  %5 = load i32, ptr %flags.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 46, i32 noundef %3, ptr noundef %4, i32 noundef %5)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_cmsg(ptr noundef %msgh, ptr noundef %target_msgh) #0 {
entry:
  %retval = alloca i64, align 8
  %msgh.addr = alloca ptr, align 8
  %target_msgh.addr = alloca ptr, align 8
  %cmsg = alloca ptr, align 8
  %msg_controllen1 = alloca i64, align 8
  %target_cmsg_addr = alloca i64, align 8
  %target_cmsg = alloca ptr, align 8
  %target_cmsg_start = alloca ptr, align 8
  %space = alloca i32, align 4
  %data = alloca ptr, align 8
  %target_data = alloca ptr, align 8
  %len = alloca i32, align 4
  %fd = alloca ptr, align 8
  %target_fd = alloca ptr, align 8
  %i = alloca i32, align 4
  %numfds = alloca i32, align 4
  %cred = alloca ptr, align 8
  %target_cred = alloca ptr, align 8
  %dst = alloca ptr, align 8
  store ptr %msgh, ptr %msgh.addr, align 8
  store ptr %target_msgh, ptr %target_msgh.addr, align 8
  %0 = load ptr, ptr %msgh.addr, align 8
  %msg_controllen = getelementptr inbounds %struct.msghdr, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %msg_controllen, align 8
  %cmp = icmp uge i64 %1, 16
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %msgh.addr, align 8
  %msg_control = getelementptr inbounds %struct.msghdr, ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %msg_control, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %3, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %cmsg, align 8
  store i32 0, ptr %space, align 4
  %4 = load ptr, ptr %target_msgh.addr, align 8
  %msg_controllen2 = getelementptr inbounds %struct.target_msghdr, ptr %4, i32 0, i32 5
  %5 = load i64, ptr %msg_controllen2, align 8
  %call = call i64 @tswapal(i64 noundef %5)
  store i64 %call, ptr %msg_controllen1, align 8
  %6 = load i64, ptr %msg_controllen1, align 8
  %cmp3 = icmp ult i64 %6, 16
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  br label %the_end

if.end:                                           ; preds = %cond.end
  %7 = load ptr, ptr %target_msgh.addr, align 8
  %msg_control4 = getelementptr inbounds %struct.target_msghdr, ptr %7, i32 0, i32 4
  %8 = load i64, ptr %msg_control4, align 8
  %call5 = call i64 @tswapal(i64 noundef %8)
  store i64 %call5, ptr %target_cmsg_addr, align 8
  %9 = load i64, ptr %target_cmsg_addr, align 8
  %10 = load i64, ptr %msg_controllen1, align 8
  %call6 = call ptr @lock_user(i32 noundef 1, i64 noundef %9, i64 noundef %10, i1 noundef zeroext true)
  store ptr %call6, ptr %target_cmsg, align 8
  %11 = load ptr, ptr %target_cmsg, align 8
  store ptr %11, ptr %target_cmsg_start, align 8
  %12 = load ptr, ptr %target_cmsg, align 8
  %tobool = icmp ne ptr %12, null
  br i1 %tobool, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end121, %if.end8
  %13 = load ptr, ptr %cmsg, align 8
  %tobool9 = icmp ne ptr %13, null
  br i1 %tobool9, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %14 = load ptr, ptr %target_cmsg, align 8
  %tobool10 = icmp ne ptr %14, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %15 = phi i1 [ false, %while.cond ], [ %tobool10, %land.rhs ]
  br i1 %15, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %16 = load ptr, ptr %cmsg, align 8
  %__cmsg_data = getelementptr inbounds %struct.cmsghdr, ptr %16, i32 0, i32 3
  %arraydecay = getelementptr inbounds [0 x i8], ptr %__cmsg_data, i64 0, i64 0
  store ptr %arraydecay, ptr %data, align 8
  %17 = load ptr, ptr %target_cmsg, align 8
  %add.ptr = getelementptr %struct.target_cmsghdr, ptr %17, i64 1
  store ptr %add.ptr, ptr %target_data, align 8
  %18 = load ptr, ptr %target_cmsg, align 8
  %cmsg_len = getelementptr inbounds %struct.target_cmsghdr, ptr %18, i32 0, i32 0
  %19 = load i64, ptr %cmsg_len, align 8
  %call11 = call i64 @tswapal(i64 noundef %19)
  %sub = sub i64 %call11, 16
  %conv = trunc i64 %sub to i32
  store i32 %conv, ptr %len, align 4
  %20 = load i32, ptr %len, align 4
  %conv12 = sext i32 %20 to i64
  %add = add i64 %conv12, 8
  %sub13 = sub i64 %add, 1
  %and = and i64 %sub13, -8
  %add14 = add i64 %and, 16
  %21 = load i32, ptr %space, align 4
  %conv15 = zext i32 %21 to i64
  %add16 = add i64 %conv15, %add14
  %conv17 = trunc i64 %add16 to i32
  store i32 %conv17, ptr %space, align 4
  %22 = load i32, ptr %space, align 4
  %conv18 = zext i32 %22 to i64
  %23 = load ptr, ptr %msgh.addr, align 8
  %msg_controllen19 = getelementptr inbounds %struct.msghdr, ptr %23, i32 0, i32 5
  %24 = load i64, ptr %msg_controllen19, align 8
  %cmp20 = icmp ugt i64 %conv18, %24
  br i1 %cmp20, label %if.then22, label %if.end39

if.then22:                                        ; preds = %while.body
  %25 = load i32, ptr %len, align 4
  %conv23 = sext i32 %25 to i64
  %add24 = add i64 %conv23, 8
  %sub25 = sub i64 %add24, 1
  %and26 = and i64 %sub25, -8
  %add27 = add i64 %and26, 16
  %26 = load i32, ptr %space, align 4
  %conv28 = zext i32 %26 to i64
  %sub29 = sub i64 %conv28, %add27
  %conv30 = trunc i64 %sub29 to i32
  store i32 %conv30, ptr %space, align 4
  br label %do.body

do.body:                                          ; preds = %if.then22
  %call31 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 1024)
  %lnot = xor i1 %call31, true
  %lnot32 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot32 to i32
  %conv33 = sext i32 %lnot.ext to i64
  %tobool34 = icmp ne i64 %conv33, 0
  br i1 %tobool34, label %if.then35, label %if.end38

if.then35:                                        ; preds = %do.body
  %27 = load ptr, ptr %target_cmsg, align 8
  %cmsg_level = getelementptr inbounds %struct.target_cmsghdr, ptr %27, i32 0, i32 1
  %28 = load i32, ptr %cmsg_level, align 8
  %call36 = call i32 @tswap32(i32 noundef %28)
  %29 = load ptr, ptr %target_cmsg, align 8
  %cmsg_type = getelementptr inbounds %struct.target_cmsghdr, ptr %29, i32 0, i32 2
  %30 = load i32, ptr %cmsg_type, align 4
  %call37 = call i32 @tswap32(i32 noundef %30)
  call void (ptr, ...) @qemu_log(ptr noundef @.str.635, i32 noundef %call36, i32 noundef %call37)
  br label %if.end38

if.end38:                                         ; preds = %if.then35, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end38
  br label %while.end

if.end39:                                         ; preds = %while.body
  %31 = load ptr, ptr %target_cmsg, align 8
  %cmsg_level40 = getelementptr inbounds %struct.target_cmsghdr, ptr %31, i32 0, i32 1
  %32 = load i32, ptr %cmsg_level40, align 8
  %call41 = call i32 @tswap32(i32 noundef %32)
  %cmp42 = icmp eq i32 %call41, 1
  br i1 %cmp42, label %if.then44, label %if.else

if.then44:                                        ; preds = %if.end39
  %33 = load ptr, ptr %cmsg, align 8
  %cmsg_level45 = getelementptr inbounds %struct.cmsghdr, ptr %33, i32 0, i32 1
  store i32 1, ptr %cmsg_level45, align 8
  br label %if.end49

if.else:                                          ; preds = %if.end39
  %34 = load ptr, ptr %target_cmsg, align 8
  %cmsg_level46 = getelementptr inbounds %struct.target_cmsghdr, ptr %34, i32 0, i32 1
  %35 = load i32, ptr %cmsg_level46, align 8
  %call47 = call i32 @tswap32(i32 noundef %35)
  %36 = load ptr, ptr %cmsg, align 8
  %cmsg_level48 = getelementptr inbounds %struct.cmsghdr, ptr %36, i32 0, i32 1
  store i32 %call47, ptr %cmsg_level48, align 8
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then44
  %37 = load ptr, ptr %target_cmsg, align 8
  %cmsg_type50 = getelementptr inbounds %struct.target_cmsghdr, ptr %37, i32 0, i32 2
  %38 = load i32, ptr %cmsg_type50, align 4
  %call51 = call i32 @tswap32(i32 noundef %38)
  %39 = load ptr, ptr %cmsg, align 8
  %cmsg_type52 = getelementptr inbounds %struct.cmsghdr, ptr %39, i32 0, i32 2
  store i32 %call51, ptr %cmsg_type52, align 4
  %40 = load i32, ptr %len, align 4
  %conv53 = sext i32 %40 to i64
  %add54 = add i64 16, %conv53
  %41 = load ptr, ptr %cmsg, align 8
  %cmsg_len55 = getelementptr inbounds %struct.cmsghdr, ptr %41, i32 0, i32 0
  store i64 %add54, ptr %cmsg_len55, align 8
  %42 = load ptr, ptr %cmsg, align 8
  %cmsg_level56 = getelementptr inbounds %struct.cmsghdr, ptr %42, i32 0, i32 1
  %43 = load i32, ptr %cmsg_level56, align 8
  %cmp57 = icmp eq i32 %43, 1
  br i1 %cmp57, label %land.lhs.true, label %if.else71

land.lhs.true:                                    ; preds = %if.end49
  %44 = load ptr, ptr %cmsg, align 8
  %cmsg_type59 = getelementptr inbounds %struct.cmsghdr, ptr %44, i32 0, i32 2
  %45 = load i32, ptr %cmsg_type59, align 4
  %cmp60 = icmp eq i32 %45, 1
  br i1 %cmp60, label %if.then62, label %if.else71

if.then62:                                        ; preds = %land.lhs.true
  %46 = load ptr, ptr %data, align 8
  store ptr %46, ptr %fd, align 8
  %47 = load ptr, ptr %target_data, align 8
  store ptr %47, ptr %target_fd, align 8
  %48 = load i32, ptr %len, align 4
  %conv63 = sext i32 %48 to i64
  %div = udiv i64 %conv63, 4
  %conv64 = trunc i64 %div to i32
  store i32 %conv64, ptr %numfds, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then62
  %49 = load i32, ptr %i, align 4
  %50 = load i32, ptr %numfds, align 4
  %cmp65 = icmp slt i32 %49, %50
  br i1 %cmp65, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body67

do.body67:                                        ; preds = %for.body
  %51 = load ptr, ptr %target_fd, align 8
  %52 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %52 to i64
  %add.ptr68 = getelementptr i32, ptr %51, i64 %idx.ext
  %call69 = call i32 @ldl_le_p(ptr noundef %add.ptr68)
  %53 = load ptr, ptr %fd, align 8
  %54 = load i32, ptr %i, align 4
  %idxprom = sext i32 %54 to i64
  %arrayidx = getelementptr i32, ptr %53, i64 %idxprom
  store i32 %call69, ptr %arrayidx, align 4
  br label %do.end70

do.end70:                                         ; preds = %do.body67
  br label %for.inc

for.inc:                                          ; preds = %do.end70
  %55 = load i32, ptr %i, align 4
  %inc = add i32 %55, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !53

for.end:                                          ; preds = %for.cond
  br label %if.end121

if.else71:                                        ; preds = %land.lhs.true, %if.end49
  %56 = load ptr, ptr %cmsg, align 8
  %cmsg_level72 = getelementptr inbounds %struct.cmsghdr, ptr %56, i32 0, i32 1
  %57 = load i32, ptr %cmsg_level72, align 8
  %cmp73 = icmp eq i32 %57, 1
  br i1 %cmp73, label %land.lhs.true75, label %if.else92

land.lhs.true75:                                  ; preds = %if.else71
  %58 = load ptr, ptr %cmsg, align 8
  %cmsg_type76 = getelementptr inbounds %struct.cmsghdr, ptr %58, i32 0, i32 2
  %59 = load i32, ptr %cmsg_type76, align 4
  %cmp77 = icmp eq i32 %59, 2
  br i1 %cmp77, label %if.then79, label %if.else92

if.then79:                                        ; preds = %land.lhs.true75
  %60 = load ptr, ptr %data, align 8
  store ptr %60, ptr %cred, align 8
  %61 = load ptr, ptr %target_data, align 8
  store ptr %61, ptr %target_cred, align 8
  br label %do.body80

do.body80:                                        ; preds = %if.then79
  %62 = load ptr, ptr %target_cred, align 8
  %pid = getelementptr inbounds %struct.target_ucred, ptr %62, i32 0, i32 0
  %call81 = call i32 @ldl_le_p(ptr noundef %pid)
  %63 = load ptr, ptr %cred, align 8
  %pid82 = getelementptr inbounds %struct.ucred, ptr %63, i32 0, i32 0
  store i32 %call81, ptr %pid82, align 4
  br label %do.end83

do.end83:                                         ; preds = %do.body80
  br label %do.body84

do.body84:                                        ; preds = %do.end83
  %64 = load ptr, ptr %target_cred, align 8
  %uid = getelementptr inbounds %struct.target_ucred, ptr %64, i32 0, i32 1
  %call85 = call i32 @ldl_le_p(ptr noundef %uid)
  %65 = load ptr, ptr %cred, align 8
  %uid86 = getelementptr inbounds %struct.ucred, ptr %65, i32 0, i32 1
  store i32 %call85, ptr %uid86, align 4
  br label %do.end87

do.end87:                                         ; preds = %do.body84
  br label %do.body88

do.body88:                                        ; preds = %do.end87
  %66 = load ptr, ptr %target_cred, align 8
  %gid = getelementptr inbounds %struct.target_ucred, ptr %66, i32 0, i32 2
  %call89 = call i32 @ldl_le_p(ptr noundef %gid)
  %67 = load ptr, ptr %cred, align 8
  %gid90 = getelementptr inbounds %struct.ucred, ptr %67, i32 0, i32 2
  store i32 %call89, ptr %gid90, align 4
  br label %do.end91

do.end91:                                         ; preds = %do.body88
  br label %if.end120

if.else92:                                        ; preds = %land.lhs.true75, %if.else71
  %68 = load ptr, ptr %cmsg, align 8
  %cmsg_level93 = getelementptr inbounds %struct.cmsghdr, ptr %68, i32 0, i32 1
  %69 = load i32, ptr %cmsg_level93, align 8
  %cmp94 = icmp eq i32 %69, 279
  br i1 %cmp94, label %if.then96, label %if.else104

if.then96:                                        ; preds = %if.else92
  %70 = load ptr, ptr %data, align 8
  store ptr %70, ptr %dst, align 8
  %71 = load ptr, ptr %dst, align 8
  %72 = load ptr, ptr %target_data, align 8
  %73 = load i32, ptr %len, align 4
  %conv97 = sext i32 %73 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %71, ptr align 1 %72, i64 %conv97, i1 false)
  %74 = load i32, ptr %len, align 4
  %conv98 = sext i32 %74 to i64
  %cmp99 = icmp uge i64 %conv98, 4
  br i1 %cmp99, label %if.then101, label %if.end103

if.then101:                                       ; preds = %if.then96
  %75 = load ptr, ptr %dst, align 8
  %76 = load i32, ptr %75, align 4
  %call102 = call i32 @tswap32(i32 noundef %76)
  %77 = load ptr, ptr %dst, align 8
  store i32 %call102, ptr %77, align 4
  br label %if.end103

if.end103:                                        ; preds = %if.then101, %if.then96
  br label %if.end119

if.else104:                                       ; preds = %if.else92
  br label %do.body105

do.body105:                                       ; preds = %if.else104
  %call106 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 1024)
  %lnot107 = xor i1 %call106, true
  %lnot109 = xor i1 %lnot107, true
  %lnot.ext110 = zext i1 %lnot109 to i32
  %conv111 = sext i32 %lnot.ext110 to i64
  %tobool112 = icmp ne i64 %conv111, 0
  br i1 %tobool112, label %if.then113, label %if.end116

if.then113:                                       ; preds = %do.body105
  %78 = load ptr, ptr %cmsg, align 8
  %cmsg_level114 = getelementptr inbounds %struct.cmsghdr, ptr %78, i32 0, i32 1
  %79 = load i32, ptr %cmsg_level114, align 8
  %80 = load ptr, ptr %cmsg, align 8
  %cmsg_type115 = getelementptr inbounds %struct.cmsghdr, ptr %80, i32 0, i32 2
  %81 = load i32, ptr %cmsg_type115, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.636, i32 noundef %79, i32 noundef %81)
  br label %if.end116

if.end116:                                        ; preds = %if.then113, %do.body105
  br label %do.end117

do.end117:                                        ; preds = %if.end116
  %82 = load ptr, ptr %data, align 8
  %83 = load ptr, ptr %target_data, align 8
  %84 = load i32, ptr %len, align 4
  %conv118 = sext i32 %84 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %82, ptr align 1 %83, i64 %conv118, i1 false)
  br label %if.end119

if.end119:                                        ; preds = %do.end117, %if.end103
  br label %if.end120

if.end120:                                        ; preds = %if.end119, %do.end91
  br label %if.end121

if.end121:                                        ; preds = %if.end120, %for.end
  %85 = load ptr, ptr %msgh.addr, align 8
  %86 = load ptr, ptr %cmsg, align 8
  %call122 = call ptr @__cmsg_nxthdr(ptr noundef %85, ptr noundef %86) #14
  store ptr %call122, ptr %cmsg, align 8
  %87 = load ptr, ptr %target_msgh.addr, align 8
  %88 = load ptr, ptr %target_cmsg, align 8
  %89 = load ptr, ptr %target_cmsg_start, align 8
  %call123 = call ptr @__target_cmsg_nxthdr(ptr noundef %87, ptr noundef %88, ptr noundef %89)
  store ptr %call123, ptr %target_cmsg, align 8
  br label %while.cond, !llvm.loop !54

while.end:                                        ; preds = %do.end, %land.end
  %90 = load ptr, ptr %target_cmsg, align 8
  %91 = load i64, ptr %target_cmsg_addr, align 8
  call void @unlock_user(ptr noundef %90, i64 noundef %91, i64 noundef 0)
  br label %the_end

the_end:                                          ; preds = %while.end, %if.then
  %92 = load i32, ptr %space, align 4
  %conv124 = zext i32 %92 to i64
  %93 = load ptr, ptr %msgh.addr, align 8
  %msg_controllen125 = getelementptr inbounds %struct.msghdr, ptr %93, i32 0, i32 5
  store i64 %conv124, ptr %msg_controllen125, align 8
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %the_end, %if.then7
  %94 = load i64, ptr %retval, align 8
  ret i64 %94
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @safe_recvmsg(i32 noundef %fd, ptr noundef %msg, i32 noundef %flags) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %msg.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %msg, ptr %msg.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %msg.addr, align 8
  %5 = load i32, ptr %flags.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 47, i32 noundef %3, ptr noundef %4, i32 noundef %5)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_cmsg(ptr noundef %target_msgh, ptr noundef %msgh) #0 {
entry:
  %retval = alloca i64, align 8
  %target_msgh.addr = alloca ptr, align 8
  %msgh.addr = alloca ptr, align 8
  %cmsg = alloca ptr, align 8
  %msg_controllen1 = alloca i64, align 8
  %target_cmsg_addr = alloca i64, align 8
  %target_cmsg = alloca ptr, align 8
  %target_cmsg_start = alloca ptr, align 8
  %space = alloca i32, align 4
  %data = alloca ptr, align 8
  %target_data = alloca ptr, align 8
  %len = alloca i32, align 4
  %tgt_len = alloca i32, align 4
  %tgt_space = alloca i32, align 4
  %fd = alloca ptr, align 8
  %target_fd = alloca ptr, align 8
  %i = alloca i32, align 4
  %numfds = alloca i32, align 4
  %tv = alloca ptr, align 8
  %target_tv = alloca ptr, align 8
  %cred = alloca ptr, align 8
  %target_cred = alloca ptr, align 8
  %v = alloca ptr, align 8
  %t_int = alloca ptr, align 8
  %errh = alloca ptr, align 8
  %target_errh = alloca ptr, align 8
  %v142 = alloca ptr, align 8
  %t_int143 = alloca ptr, align 8
  %errh156 = alloca ptr, align 8
  %target_errh157 = alloca ptr, align 8
  %_a6 = alloca i32, align 4
  %_b7 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store ptr %target_msgh, ptr %target_msgh.addr, align 8
  store ptr %msgh, ptr %msgh.addr, align 8
  %0 = load ptr, ptr %msgh.addr, align 8
  %msg_controllen = getelementptr inbounds %struct.msghdr, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %msg_controllen, align 8
  %cmp = icmp uge i64 %1, 16
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %msgh.addr, align 8
  %msg_control = getelementptr inbounds %struct.msghdr, ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %msg_control, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %3, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %cmsg, align 8
  store i32 0, ptr %space, align 4
  %4 = load ptr, ptr %target_msgh.addr, align 8
  %msg_controllen2 = getelementptr inbounds %struct.target_msghdr, ptr %4, i32 0, i32 5
  %5 = load i64, ptr %msg_controllen2, align 8
  %call = call i64 @tswapal(i64 noundef %5)
  store i64 %call, ptr %msg_controllen1, align 8
  %6 = load i64, ptr %msg_controllen1, align 8
  %cmp3 = icmp ult i64 %6, 16
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  br label %the_end

if.end:                                           ; preds = %cond.end
  %7 = load ptr, ptr %target_msgh.addr, align 8
  %msg_control4 = getelementptr inbounds %struct.target_msghdr, ptr %7, i32 0, i32 4
  %8 = load i64, ptr %msg_control4, align 8
  %call5 = call i64 @tswapal(i64 noundef %8)
  store i64 %call5, ptr %target_cmsg_addr, align 8
  %9 = load i64, ptr %target_cmsg_addr, align 8
  %10 = load i64, ptr %msg_controllen1, align 8
  %call6 = call ptr @lock_user(i32 noundef 3, i64 noundef %9, i64 noundef %10, i1 noundef zeroext false)
  store ptr %call6, ptr %target_cmsg, align 8
  %11 = load ptr, ptr %target_cmsg, align 8
  store ptr %11, ptr %target_cmsg_start, align 8
  %12 = load ptr, ptr %target_cmsg, align 8
  %tobool = icmp ne ptr %12, null
  br i1 %tobool, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end253, %if.end8
  %13 = load ptr, ptr %cmsg, align 8
  %tobool9 = icmp ne ptr %13, null
  br i1 %tobool9, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %14 = load ptr, ptr %target_cmsg, align 8
  %tobool10 = icmp ne ptr %14, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %15 = phi i1 [ false, %while.cond ], [ %tobool10, %land.rhs ]
  br i1 %15, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %16 = load ptr, ptr %cmsg, align 8
  %__cmsg_data = getelementptr inbounds %struct.cmsghdr, ptr %16, i32 0, i32 3
  %arraydecay = getelementptr inbounds [0 x i8], ptr %__cmsg_data, i64 0, i64 0
  store ptr %arraydecay, ptr %data, align 8
  %17 = load ptr, ptr %target_cmsg, align 8
  %add.ptr = getelementptr %struct.target_cmsghdr, ptr %17, i64 1
  store ptr %add.ptr, ptr %target_data, align 8
  %18 = load ptr, ptr %cmsg, align 8
  %cmsg_len = getelementptr inbounds %struct.cmsghdr, ptr %18, i32 0, i32 0
  %19 = load i64, ptr %cmsg_len, align 8
  %sub = sub i64 %19, 16
  %conv = trunc i64 %sub to i32
  store i32 %conv, ptr %len, align 4
  %20 = load i64, ptr %msg_controllen1, align 8
  %cmp11 = icmp ult i64 %20, 16
  br i1 %cmp11, label %if.then13, label %if.end15

if.then13:                                        ; preds = %while.body
  %call14 = call i32 @tswap32(i32 noundef 8)
  %21 = load ptr, ptr %target_msgh.addr, align 8
  %msg_flags = getelementptr inbounds %struct.target_msghdr, ptr %21, i32 0, i32 6
  %22 = load i32, ptr %msg_flags, align 8
  %or = or i32 %22, %call14
  store i32 %or, ptr %msg_flags, align 8
  br label %while.end

if.end15:                                         ; preds = %while.body
  %23 = load ptr, ptr %cmsg, align 8
  %cmsg_level = getelementptr inbounds %struct.cmsghdr, ptr %23, i32 0, i32 1
  %24 = load i32, ptr %cmsg_level, align 8
  %cmp16 = icmp eq i32 %24, 1
  br i1 %cmp16, label %if.then18, label %if.else

if.then18:                                        ; preds = %if.end15
  %call19 = call i32 @tswap32(i32 noundef 1)
  %25 = load ptr, ptr %target_cmsg, align 8
  %cmsg_level20 = getelementptr inbounds %struct.target_cmsghdr, ptr %25, i32 0, i32 1
  store i32 %call19, ptr %cmsg_level20, align 8
  br label %if.end24

if.else:                                          ; preds = %if.end15
  %26 = load ptr, ptr %cmsg, align 8
  %cmsg_level21 = getelementptr inbounds %struct.cmsghdr, ptr %26, i32 0, i32 1
  %27 = load i32, ptr %cmsg_level21, align 8
  %call22 = call i32 @tswap32(i32 noundef %27)
  %28 = load ptr, ptr %target_cmsg, align 8
  %cmsg_level23 = getelementptr inbounds %struct.target_cmsghdr, ptr %28, i32 0, i32 1
  store i32 %call22, ptr %cmsg_level23, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.else, %if.then18
  %29 = load ptr, ptr %cmsg, align 8
  %cmsg_type = getelementptr inbounds %struct.cmsghdr, ptr %29, i32 0, i32 2
  %30 = load i32, ptr %cmsg_type, align 4
  %call25 = call i32 @tswap32(i32 noundef %30)
  %31 = load ptr, ptr %target_cmsg, align 8
  %cmsg_type26 = getelementptr inbounds %struct.target_cmsghdr, ptr %31, i32 0, i32 2
  store i32 %call25, ptr %cmsg_type26, align 4
  %32 = load i32, ptr %len, align 4
  store i32 %32, ptr %tgt_len, align 4
  %33 = load ptr, ptr %cmsg, align 8
  %cmsg_level27 = getelementptr inbounds %struct.cmsghdr, ptr %33, i32 0, i32 1
  %34 = load i32, ptr %cmsg_level27, align 8
  switch i32 %34, label %sw.default30 [
    i32 1, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.end24
  %35 = load ptr, ptr %cmsg, align 8
  %cmsg_type28 = getelementptr inbounds %struct.cmsghdr, ptr %35, i32 0, i32 2
  %36 = load i32, ptr %cmsg_type28, align 4
  switch i32 %36, label %sw.default [
    i32 29, label %sw.bb29
  ]

sw.bb29:                                          ; preds = %sw.bb
  store i32 16, ptr %tgt_len, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %sw.bb
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb29
  br label %sw.epilog31

sw.default30:                                     ; preds = %if.end24
  br label %sw.epilog31

sw.epilog31:                                      ; preds = %sw.default30, %sw.epilog
  %37 = load i64, ptr %msg_controllen1, align 8
  %38 = load i32, ptr %tgt_len, align 4
  %conv32 = sext i32 %38 to i64
  %add = add i64 16, %conv32
  %cmp33 = icmp ult i64 %37, %add
  br i1 %cmp33, label %if.then35, label %if.end41

if.then35:                                        ; preds = %sw.epilog31
  %call36 = call i32 @tswap32(i32 noundef 8)
  %39 = load ptr, ptr %target_msgh.addr, align 8
  %msg_flags37 = getelementptr inbounds %struct.target_msghdr, ptr %39, i32 0, i32 6
  %40 = load i32, ptr %msg_flags37, align 8
  %or38 = or i32 %40, %call36
  store i32 %or38, ptr %msg_flags37, align 8
  %41 = load i64, ptr %msg_controllen1, align 8
  %sub39 = sub i64 %41, 16
  %conv40 = trunc i64 %sub39 to i32
  store i32 %conv40, ptr %tgt_len, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.then35, %sw.epilog31
  %42 = load ptr, ptr %cmsg, align 8
  %cmsg_level42 = getelementptr inbounds %struct.cmsghdr, ptr %42, i32 0, i32 1
  %43 = load i32, ptr %cmsg_level42, align 8
  switch i32 %43, label %sw.default212 [
    i32 1, label %sw.bb43
    i32 0, label %sw.bb78
    i32 41, label %sw.bb139
  ]

sw.bb43:                                          ; preds = %if.end41
  %44 = load ptr, ptr %cmsg, align 8
  %cmsg_type44 = getelementptr inbounds %struct.cmsghdr, ptr %44, i32 0, i32 2
  %45 = load i32, ptr %cmsg_type44, align 4
  switch i32 %45, label %sw.default76 [
    i32 1, label %sw.bb45
    i32 29, label %sw.bb51
    i32 2, label %sw.bb66
  ]

sw.bb45:                                          ; preds = %sw.bb43
  %46 = load ptr, ptr %data, align 8
  store ptr %46, ptr %fd, align 8
  %47 = load ptr, ptr %target_data, align 8
  store ptr %47, ptr %target_fd, align 8
  %48 = load i32, ptr %tgt_len, align 4
  %conv46 = sext i32 %48 to i64
  %div = udiv i64 %conv46, 4
  %conv47 = trunc i64 %div to i32
  store i32 %conv47, ptr %numfds, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb45
  %49 = load i32, ptr %i, align 4
  %50 = load i32, ptr %numfds, align 4
  %cmp48 = icmp slt i32 %49, %50
  br i1 %cmp48, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.body
  %51 = load ptr, ptr %target_fd, align 8
  %52 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %52 to i64
  %add.ptr50 = getelementptr i32, ptr %51, i64 %idx.ext
  %53 = load ptr, ptr %fd, align 8
  %54 = load i32, ptr %i, align 4
  %idxprom = sext i32 %54 to i64
  %arrayidx = getelementptr i32, ptr %53, i64 %idxprom
  %55 = load i32, ptr %arrayidx, align 4
  call void @stl_le_p(ptr noundef %add.ptr50, i32 noundef %55)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %56 = load i32, ptr %i, align 4
  %inc = add i32 %56, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !55

for.end:                                          ; preds = %for.cond
  br label %sw.epilog77

sw.bb51:                                          ; preds = %sw.bb43
  %57 = load ptr, ptr %data, align 8
  store ptr %57, ptr %tv, align 8
  %58 = load ptr, ptr %target_data, align 8
  store ptr %58, ptr %target_tv, align 8
  %59 = load i32, ptr %len, align 4
  %conv52 = sext i32 %59 to i64
  %cmp53 = icmp ne i64 %conv52, 16
  br i1 %cmp53, label %if.then58, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb51
  %60 = load i32, ptr %tgt_len, align 4
  %conv55 = sext i32 %60 to i64
  %cmp56 = icmp ne i64 %conv55, 16
  br i1 %cmp56, label %if.then58, label %if.end59

if.then58:                                        ; preds = %lor.lhs.false, %sw.bb51
  br label %unimplemented

if.end59:                                         ; preds = %lor.lhs.false
  br label %do.body60

do.body60:                                        ; preds = %if.end59
  %61 = load ptr, ptr %target_tv, align 8
  %tv_sec = getelementptr inbounds %struct.target_timeval, ptr %61, i32 0, i32 0
  %62 = load ptr, ptr %tv, align 8
  %tv_sec61 = getelementptr inbounds %struct.timeval, ptr %62, i32 0, i32 0
  %63 = load i64, ptr %tv_sec61, align 8
  call void @stq_le_p(ptr noundef %tv_sec, i64 noundef %63)
  br label %do.end62

do.end62:                                         ; preds = %do.body60
  br label %do.body63

do.body63:                                        ; preds = %do.end62
  %64 = load ptr, ptr %target_tv, align 8
  %tv_usec = getelementptr inbounds %struct.target_timeval, ptr %64, i32 0, i32 1
  %65 = load ptr, ptr %tv, align 8
  %tv_usec64 = getelementptr inbounds %struct.timeval, ptr %65, i32 0, i32 1
  %66 = load i64, ptr %tv_usec64, align 8
  call void @stq_le_p(ptr noundef %tv_usec, i64 noundef %66)
  br label %do.end65

do.end65:                                         ; preds = %do.body63
  br label %sw.epilog77

sw.bb66:                                          ; preds = %sw.bb43
  %67 = load ptr, ptr %data, align 8
  store ptr %67, ptr %cred, align 8
  %68 = load ptr, ptr %target_data, align 8
  store ptr %68, ptr %target_cred, align 8
  br label %do.body67

do.body67:                                        ; preds = %sw.bb66
  %69 = load ptr, ptr %target_cred, align 8
  %pid = getelementptr inbounds %struct.target_ucred, ptr %69, i32 0, i32 0
  %70 = load ptr, ptr %cred, align 8
  %pid68 = getelementptr inbounds %struct.ucred, ptr %70, i32 0, i32 0
  %71 = load i32, ptr %pid68, align 4
  call void @stl_le_p(ptr noundef %pid, i32 noundef %71)
  br label %do.end69

do.end69:                                         ; preds = %do.body67
  br label %do.body70

do.body70:                                        ; preds = %do.end69
  %72 = load ptr, ptr %target_cred, align 8
  %uid = getelementptr inbounds %struct.target_ucred, ptr %72, i32 0, i32 1
  %73 = load ptr, ptr %cred, align 8
  %uid71 = getelementptr inbounds %struct.ucred, ptr %73, i32 0, i32 1
  %74 = load i32, ptr %uid71, align 4
  call void @stl_le_p(ptr noundef %uid, i32 noundef %74)
  br label %do.end72

do.end72:                                         ; preds = %do.body70
  br label %do.body73

do.body73:                                        ; preds = %do.end72
  %75 = load ptr, ptr %target_cred, align 8
  %gid = getelementptr inbounds %struct.target_ucred, ptr %75, i32 0, i32 2
  %76 = load ptr, ptr %cred, align 8
  %gid74 = getelementptr inbounds %struct.ucred, ptr %76, i32 0, i32 2
  %77 = load i32, ptr %gid74, align 4
  call void @stl_le_p(ptr noundef %gid, i32 noundef %77)
  br label %do.end75

do.end75:                                         ; preds = %do.body73
  br label %sw.epilog77

sw.default76:                                     ; preds = %sw.bb43
  br label %unimplemented

sw.epilog77:                                      ; preds = %do.end75, %do.end65, %for.end
  br label %sw.epilog238

sw.bb78:                                          ; preds = %if.end41
  %78 = load ptr, ptr %cmsg, align 8
  %cmsg_type79 = getelementptr inbounds %struct.cmsghdr, ptr %78, i32 0, i32 2
  %79 = load i32, ptr %cmsg_type79, align 4
  switch i32 %79, label %sw.default137 [
    i32 2, label %sw.bb80
    i32 11, label %sw.bb92
  ]

sw.bb80:                                          ; preds = %sw.bb78
  %80 = load ptr, ptr %data, align 8
  store ptr %80, ptr %v, align 8
  %81 = load ptr, ptr %target_data, align 8
  store ptr %81, ptr %t_int, align 8
  %82 = load i32, ptr %len, align 4
  %conv81 = sext i32 %82 to i64
  %cmp82 = icmp ne i64 %conv81, 4
  br i1 %cmp82, label %if.then88, label %lor.lhs.false84

lor.lhs.false84:                                  ; preds = %sw.bb80
  %83 = load i32, ptr %tgt_len, align 4
  %conv85 = sext i32 %83 to i64
  %cmp86 = icmp ne i64 %conv85, 4
  br i1 %cmp86, label %if.then88, label %if.end89

if.then88:                                        ; preds = %lor.lhs.false84, %sw.bb80
  br label %unimplemented

if.end89:                                         ; preds = %lor.lhs.false84
  br label %do.body90

do.body90:                                        ; preds = %if.end89
  %84 = load ptr, ptr %t_int, align 8
  %85 = load ptr, ptr %v, align 8
  %86 = load i32, ptr %85, align 4
  call void @stl_le_p(ptr noundef %84, i32 noundef %86)
  br label %do.end91

do.end91:                                         ; preds = %do.body90
  br label %sw.epilog138

sw.bb92:                                          ; preds = %sw.bb78
  %87 = load ptr, ptr %data, align 8
  store ptr %87, ptr %errh, align 8
  %88 = load ptr, ptr %target_data, align 8
  store ptr %88, ptr %target_errh, align 8
  %89 = load i32, ptr %len, align 4
  %conv93 = sext i32 %89 to i64
  %cmp94 = icmp ne i64 %conv93, 32
  br i1 %cmp94, label %if.then100, label %lor.lhs.false96

lor.lhs.false96:                                  ; preds = %sw.bb92
  %90 = load i32, ptr %tgt_len, align 4
  %conv97 = sext i32 %90 to i64
  %cmp98 = icmp ne i64 %conv97, 32
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %lor.lhs.false96, %sw.bb92
  br label %unimplemented

if.end101:                                        ; preds = %lor.lhs.false96
  br label %do.body102

do.body102:                                       ; preds = %if.end101
  %91 = load ptr, ptr %target_errh, align 8
  %ee = getelementptr inbounds %struct.errhdr_t, ptr %91, i32 0, i32 0
  %ee_errno = getelementptr inbounds %struct.sock_extended_err, ptr %ee, i32 0, i32 0
  %92 = load ptr, ptr %errh, align 8
  %ee103 = getelementptr inbounds %struct.errhdr_t, ptr %92, i32 0, i32 0
  %ee_errno104 = getelementptr inbounds %struct.sock_extended_err, ptr %ee103, i32 0, i32 0
  %93 = load i32, ptr %ee_errno104, align 4
  call void @stl_le_p(ptr noundef %ee_errno, i32 noundef %93)
  br label %do.end105

do.end105:                                        ; preds = %do.body102
  br label %do.body106

do.body106:                                       ; preds = %do.end105
  %94 = load ptr, ptr %target_errh, align 8
  %ee107 = getelementptr inbounds %struct.errhdr_t, ptr %94, i32 0, i32 0
  %ee_origin = getelementptr inbounds %struct.sock_extended_err, ptr %ee107, i32 0, i32 1
  %95 = load ptr, ptr %errh, align 8
  %ee108 = getelementptr inbounds %struct.errhdr_t, ptr %95, i32 0, i32 0
  %ee_origin109 = getelementptr inbounds %struct.sock_extended_err, ptr %ee108, i32 0, i32 1
  %96 = load i8, ptr %ee_origin109, align 4
  call void @stb_p(ptr noundef %ee_origin, i8 noundef zeroext %96)
  br label %do.end110

do.end110:                                        ; preds = %do.body106
  br label %do.body111

do.body111:                                       ; preds = %do.end110
  %97 = load ptr, ptr %target_errh, align 8
  %ee112 = getelementptr inbounds %struct.errhdr_t, ptr %97, i32 0, i32 0
  %ee_type = getelementptr inbounds %struct.sock_extended_err, ptr %ee112, i32 0, i32 2
  %98 = load ptr, ptr %errh, align 8
  %ee113 = getelementptr inbounds %struct.errhdr_t, ptr %98, i32 0, i32 0
  %ee_type114 = getelementptr inbounds %struct.sock_extended_err, ptr %ee113, i32 0, i32 2
  %99 = load i8, ptr %ee_type114, align 1
  call void @stb_p(ptr noundef %ee_type, i8 noundef zeroext %99)
  br label %do.end115

do.end115:                                        ; preds = %do.body111
  br label %do.body116

do.body116:                                       ; preds = %do.end115
  %100 = load ptr, ptr %target_errh, align 8
  %ee117 = getelementptr inbounds %struct.errhdr_t, ptr %100, i32 0, i32 0
  %ee_code = getelementptr inbounds %struct.sock_extended_err, ptr %ee117, i32 0, i32 3
  %101 = load ptr, ptr %errh, align 8
  %ee118 = getelementptr inbounds %struct.errhdr_t, ptr %101, i32 0, i32 0
  %ee_code119 = getelementptr inbounds %struct.sock_extended_err, ptr %ee118, i32 0, i32 3
  %102 = load i8, ptr %ee_code119, align 2
  call void @stb_p(ptr noundef %ee_code, i8 noundef zeroext %102)
  br label %do.end120

do.end120:                                        ; preds = %do.body116
  br label %do.body121

do.body121:                                       ; preds = %do.end120
  %103 = load ptr, ptr %target_errh, align 8
  %ee122 = getelementptr inbounds %struct.errhdr_t, ptr %103, i32 0, i32 0
  %ee_pad = getelementptr inbounds %struct.sock_extended_err, ptr %ee122, i32 0, i32 4
  %104 = load ptr, ptr %errh, align 8
  %ee123 = getelementptr inbounds %struct.errhdr_t, ptr %104, i32 0, i32 0
  %ee_pad124 = getelementptr inbounds %struct.sock_extended_err, ptr %ee123, i32 0, i32 4
  %105 = load i8, ptr %ee_pad124, align 1
  call void @stb_p(ptr noundef %ee_pad, i8 noundef zeroext %105)
  br label %do.end125

do.end125:                                        ; preds = %do.body121
  br label %do.body126

do.body126:                                       ; preds = %do.end125
  %106 = load ptr, ptr %target_errh, align 8
  %ee127 = getelementptr inbounds %struct.errhdr_t, ptr %106, i32 0, i32 0
  %ee_info = getelementptr inbounds %struct.sock_extended_err, ptr %ee127, i32 0, i32 5
  %107 = load ptr, ptr %errh, align 8
  %ee128 = getelementptr inbounds %struct.errhdr_t, ptr %107, i32 0, i32 0
  %ee_info129 = getelementptr inbounds %struct.sock_extended_err, ptr %ee128, i32 0, i32 5
  %108 = load i32, ptr %ee_info129, align 4
  call void @stl_le_p(ptr noundef %ee_info, i32 noundef %108)
  br label %do.end130

do.end130:                                        ; preds = %do.body126
  br label %do.body131

do.body131:                                       ; preds = %do.end130
  %109 = load ptr, ptr %target_errh, align 8
  %ee132 = getelementptr inbounds %struct.errhdr_t, ptr %109, i32 0, i32 0
  %110 = getelementptr inbounds %struct.sock_extended_err, ptr %ee132, i32 0, i32 6
  %111 = load ptr, ptr %errh, align 8
  %ee133 = getelementptr inbounds %struct.errhdr_t, ptr %111, i32 0, i32 0
  %112 = getelementptr inbounds %struct.sock_extended_err, ptr %ee133, i32 0, i32 6
  %113 = load i32, ptr %112, align 4
  call void @stl_le_p(ptr noundef %110, i32 noundef %113)
  br label %do.end134

do.end134:                                        ; preds = %do.body131
  %114 = load ptr, ptr %target_errh, align 8
  %offender = getelementptr inbounds %struct.errhdr_t, ptr %114, i32 0, i32 1
  %115 = ptrtoint ptr %offender to i64
  %116 = load ptr, ptr %errh, align 8
  %offender135 = getelementptr inbounds %struct.errhdr_t, ptr %116, i32 0, i32 1
  %call136 = call i64 @host_to_target_sockaddr(i64 noundef %115, ptr noundef %offender135, i32 noundef 16)
  br label %sw.epilog138

sw.default137:                                    ; preds = %sw.bb78
  br label %unimplemented

sw.epilog138:                                     ; preds = %do.end134, %do.end91
  br label %sw.epilog238

sw.bb139:                                         ; preds = %if.end41
  %117 = load ptr, ptr %cmsg, align 8
  %cmsg_type140 = getelementptr inbounds %struct.cmsghdr, ptr %117, i32 0, i32 2
  %118 = load i32, ptr %cmsg_type140, align 4
  switch i32 %118, label %sw.default210 [
    i32 52, label %sw.bb141
    i32 25, label %sw.bb155
  ]

sw.bb141:                                         ; preds = %sw.bb139
  %119 = load ptr, ptr %data, align 8
  store ptr %119, ptr %v142, align 8
  %120 = load ptr, ptr %target_data, align 8
  store ptr %120, ptr %t_int143, align 8
  %121 = load i32, ptr %len, align 4
  %conv144 = sext i32 %121 to i64
  %cmp145 = icmp ne i64 %conv144, 4
  br i1 %cmp145, label %if.then151, label %lor.lhs.false147

lor.lhs.false147:                                 ; preds = %sw.bb141
  %122 = load i32, ptr %tgt_len, align 4
  %conv148 = sext i32 %122 to i64
  %cmp149 = icmp ne i64 %conv148, 4
  br i1 %cmp149, label %if.then151, label %if.end152

if.then151:                                       ; preds = %lor.lhs.false147, %sw.bb141
  br label %unimplemented

if.end152:                                        ; preds = %lor.lhs.false147
  br label %do.body153

do.body153:                                       ; preds = %if.end152
  %123 = load ptr, ptr %t_int143, align 8
  %124 = load ptr, ptr %v142, align 8
  %125 = load i32, ptr %124, align 4
  call void @stl_le_p(ptr noundef %123, i32 noundef %125)
  br label %do.end154

do.end154:                                        ; preds = %do.body153
  br label %sw.epilog211

sw.bb155:                                         ; preds = %sw.bb139
  %126 = load ptr, ptr %data, align 8
  store ptr %126, ptr %errh156, align 8
  %127 = load ptr, ptr %target_data, align 8
  store ptr %127, ptr %target_errh157, align 8
  %128 = load i32, ptr %len, align 4
  %conv158 = sext i32 %128 to i64
  %cmp159 = icmp ne i64 %conv158, 44
  br i1 %cmp159, label %if.then165, label %lor.lhs.false161

lor.lhs.false161:                                 ; preds = %sw.bb155
  %129 = load i32, ptr %tgt_len, align 4
  %conv162 = sext i32 %129 to i64
  %cmp163 = icmp ne i64 %conv162, 44
  br i1 %cmp163, label %if.then165, label %if.end166

if.then165:                                       ; preds = %lor.lhs.false161, %sw.bb155
  br label %unimplemented

if.end166:                                        ; preds = %lor.lhs.false161
  br label %do.body167

do.body167:                                       ; preds = %if.end166
  %130 = load ptr, ptr %target_errh157, align 8
  %ee168 = getelementptr inbounds %struct.errhdr6_t, ptr %130, i32 0, i32 0
  %ee_errno169 = getelementptr inbounds %struct.sock_extended_err, ptr %ee168, i32 0, i32 0
  %131 = load ptr, ptr %errh156, align 8
  %ee170 = getelementptr inbounds %struct.errhdr6_t, ptr %131, i32 0, i32 0
  %ee_errno171 = getelementptr inbounds %struct.sock_extended_err, ptr %ee170, i32 0, i32 0
  %132 = load i32, ptr %ee_errno171, align 4
  call void @stl_le_p(ptr noundef %ee_errno169, i32 noundef %132)
  br label %do.end172

do.end172:                                        ; preds = %do.body167
  br label %do.body173

do.body173:                                       ; preds = %do.end172
  %133 = load ptr, ptr %target_errh157, align 8
  %ee174 = getelementptr inbounds %struct.errhdr6_t, ptr %133, i32 0, i32 0
  %ee_origin175 = getelementptr inbounds %struct.sock_extended_err, ptr %ee174, i32 0, i32 1
  %134 = load ptr, ptr %errh156, align 8
  %ee176 = getelementptr inbounds %struct.errhdr6_t, ptr %134, i32 0, i32 0
  %ee_origin177 = getelementptr inbounds %struct.sock_extended_err, ptr %ee176, i32 0, i32 1
  %135 = load i8, ptr %ee_origin177, align 4
  call void @stb_p(ptr noundef %ee_origin175, i8 noundef zeroext %135)
  br label %do.end178

do.end178:                                        ; preds = %do.body173
  br label %do.body179

do.body179:                                       ; preds = %do.end178
  %136 = load ptr, ptr %target_errh157, align 8
  %ee180 = getelementptr inbounds %struct.errhdr6_t, ptr %136, i32 0, i32 0
  %ee_type181 = getelementptr inbounds %struct.sock_extended_err, ptr %ee180, i32 0, i32 2
  %137 = load ptr, ptr %errh156, align 8
  %ee182 = getelementptr inbounds %struct.errhdr6_t, ptr %137, i32 0, i32 0
  %ee_type183 = getelementptr inbounds %struct.sock_extended_err, ptr %ee182, i32 0, i32 2
  %138 = load i8, ptr %ee_type183, align 1
  call void @stb_p(ptr noundef %ee_type181, i8 noundef zeroext %138)
  br label %do.end184

do.end184:                                        ; preds = %do.body179
  br label %do.body185

do.body185:                                       ; preds = %do.end184
  %139 = load ptr, ptr %target_errh157, align 8
  %ee186 = getelementptr inbounds %struct.errhdr6_t, ptr %139, i32 0, i32 0
  %ee_code187 = getelementptr inbounds %struct.sock_extended_err, ptr %ee186, i32 0, i32 3
  %140 = load ptr, ptr %errh156, align 8
  %ee188 = getelementptr inbounds %struct.errhdr6_t, ptr %140, i32 0, i32 0
  %ee_code189 = getelementptr inbounds %struct.sock_extended_err, ptr %ee188, i32 0, i32 3
  %141 = load i8, ptr %ee_code189, align 2
  call void @stb_p(ptr noundef %ee_code187, i8 noundef zeroext %141)
  br label %do.end190

do.end190:                                        ; preds = %do.body185
  br label %do.body191

do.body191:                                       ; preds = %do.end190
  %142 = load ptr, ptr %target_errh157, align 8
  %ee192 = getelementptr inbounds %struct.errhdr6_t, ptr %142, i32 0, i32 0
  %ee_pad193 = getelementptr inbounds %struct.sock_extended_err, ptr %ee192, i32 0, i32 4
  %143 = load ptr, ptr %errh156, align 8
  %ee194 = getelementptr inbounds %struct.errhdr6_t, ptr %143, i32 0, i32 0
  %ee_pad195 = getelementptr inbounds %struct.sock_extended_err, ptr %ee194, i32 0, i32 4
  %144 = load i8, ptr %ee_pad195, align 1
  call void @stb_p(ptr noundef %ee_pad193, i8 noundef zeroext %144)
  br label %do.end196

do.end196:                                        ; preds = %do.body191
  br label %do.body197

do.body197:                                       ; preds = %do.end196
  %145 = load ptr, ptr %target_errh157, align 8
  %ee198 = getelementptr inbounds %struct.errhdr6_t, ptr %145, i32 0, i32 0
  %ee_info199 = getelementptr inbounds %struct.sock_extended_err, ptr %ee198, i32 0, i32 5
  %146 = load ptr, ptr %errh156, align 8
  %ee200 = getelementptr inbounds %struct.errhdr6_t, ptr %146, i32 0, i32 0
  %ee_info201 = getelementptr inbounds %struct.sock_extended_err, ptr %ee200, i32 0, i32 5
  %147 = load i32, ptr %ee_info201, align 4
  call void @stl_le_p(ptr noundef %ee_info199, i32 noundef %147)
  br label %do.end202

do.end202:                                        ; preds = %do.body197
  br label %do.body203

do.body203:                                       ; preds = %do.end202
  %148 = load ptr, ptr %target_errh157, align 8
  %ee204 = getelementptr inbounds %struct.errhdr6_t, ptr %148, i32 0, i32 0
  %149 = getelementptr inbounds %struct.sock_extended_err, ptr %ee204, i32 0, i32 6
  %150 = load ptr, ptr %errh156, align 8
  %ee205 = getelementptr inbounds %struct.errhdr6_t, ptr %150, i32 0, i32 0
  %151 = getelementptr inbounds %struct.sock_extended_err, ptr %ee205, i32 0, i32 6
  %152 = load i32, ptr %151, align 4
  call void @stl_le_p(ptr noundef %149, i32 noundef %152)
  br label %do.end206

do.end206:                                        ; preds = %do.body203
  %153 = load ptr, ptr %target_errh157, align 8
  %offender207 = getelementptr inbounds %struct.errhdr6_t, ptr %153, i32 0, i32 1
  %154 = ptrtoint ptr %offender207 to i64
  %155 = load ptr, ptr %errh156, align 8
  %offender208 = getelementptr inbounds %struct.errhdr6_t, ptr %155, i32 0, i32 1
  %call209 = call i64 @host_to_target_sockaddr(i64 noundef %154, ptr noundef %offender208, i32 noundef 28)
  br label %sw.epilog211

sw.default210:                                    ; preds = %sw.bb139
  br label %unimplemented

sw.epilog211:                                     ; preds = %do.end206, %do.end154
  br label %sw.epilog238

sw.default212:                                    ; preds = %if.end41
  br label %unimplemented

unimplemented:                                    ; preds = %sw.default212, %sw.default210, %if.then165, %if.then151, %sw.default137, %if.then100, %if.then88, %sw.default76, %if.then58
  br label %do.body213

do.body213:                                       ; preds = %unimplemented
  %call214 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 1024)
  %lnot = xor i1 %call214, true
  %lnot215 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot215 to i32
  %conv216 = sext i32 %lnot.ext to i64
  %tobool217 = icmp ne i64 %conv216, 0
  br i1 %tobool217, label %if.then218, label %if.end221

if.then218:                                       ; preds = %do.body213
  %156 = load ptr, ptr %cmsg, align 8
  %cmsg_level219 = getelementptr inbounds %struct.cmsghdr, ptr %156, i32 0, i32 1
  %157 = load i32, ptr %cmsg_level219, align 8
  %158 = load ptr, ptr %cmsg, align 8
  %cmsg_type220 = getelementptr inbounds %struct.cmsghdr, ptr %158, i32 0, i32 2
  %159 = load i32, ptr %cmsg_type220, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.636, i32 noundef %157, i32 noundef %159)
  br label %if.end221

if.end221:                                        ; preds = %if.then218, %do.body213
  br label %do.end222

do.end222:                                        ; preds = %if.end221
  %160 = load ptr, ptr %target_data, align 8
  %161 = load ptr, ptr %data, align 8
  %162 = load i32, ptr %len, align 4
  store i32 %162, ptr %_a6, align 4
  %163 = load i32, ptr %tgt_len, align 4
  store i32 %163, ptr %_b7, align 4
  %164 = load i32, ptr %_a6, align 4
  %165 = load i32, ptr %_b7, align 4
  %cmp223 = icmp slt i32 %164, %165
  br i1 %cmp223, label %cond.true225, label %cond.false226

cond.true225:                                     ; preds = %do.end222
  %166 = load i32, ptr %_a6, align 4
  br label %cond.end227

cond.false226:                                    ; preds = %do.end222
  %167 = load i32, ptr %_b7, align 4
  br label %cond.end227

cond.end227:                                      ; preds = %cond.false226, %cond.true225
  %cond228 = phi i32 [ %166, %cond.true225 ], [ %167, %cond.false226 ]
  store i32 %cond228, ptr %tmp, align 4
  %168 = load i32, ptr %tmp, align 4
  %conv229 = sext i32 %168 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %160, ptr align 1 %161, i64 %conv229, i1 false)
  %169 = load i32, ptr %tgt_len, align 4
  %170 = load i32, ptr %len, align 4
  %cmp230 = icmp sgt i32 %169, %170
  br i1 %cmp230, label %if.then232, label %if.end237

if.then232:                                       ; preds = %cond.end227
  %171 = load ptr, ptr %target_data, align 8
  %172 = load i32, ptr %len, align 4
  %idx.ext233 = sext i32 %172 to i64
  %add.ptr234 = getelementptr i8, ptr %171, i64 %idx.ext233
  %173 = load i32, ptr %tgt_len, align 4
  %174 = load i32, ptr %len, align 4
  %sub235 = sub i32 %173, %174
  %conv236 = sext i32 %sub235 to i64
  call void @llvm.memset.p0.i64(ptr align 1 %add.ptr234, i8 0, i64 %conv236, i1 false)
  br label %if.end237

if.end237:                                        ; preds = %if.then232, %cond.end227
  br label %sw.epilog238

sw.epilog238:                                     ; preds = %if.end237, %sw.epilog211, %sw.epilog138, %sw.epilog77
  %175 = load i32, ptr %tgt_len, align 4
  %conv239 = sext i32 %175 to i64
  %add240 = add i64 16, %conv239
  %call241 = call i64 @tswapal(i64 noundef %add240)
  %176 = load ptr, ptr %target_cmsg, align 8
  %cmsg_len242 = getelementptr inbounds %struct.target_cmsghdr, ptr %176, i32 0, i32 0
  store i64 %call241, ptr %cmsg_len242, align 8
  %177 = load i32, ptr %tgt_len, align 4
  %conv243 = sext i32 %177 to i64
  %add244 = add i64 %conv243, 8
  %sub245 = sub i64 %add244, 1
  %and = and i64 %sub245, -8
  %add246 = add i64 16, %and
  %conv247 = trunc i64 %add246 to i32
  store i32 %conv247, ptr %tgt_space, align 4
  %178 = load i64, ptr %msg_controllen1, align 8
  %179 = load i32, ptr %tgt_space, align 4
  %conv248 = sext i32 %179 to i64
  %cmp249 = icmp slt i64 %178, %conv248
  br i1 %cmp249, label %if.then251, label %if.end253

if.then251:                                       ; preds = %sw.epilog238
  %180 = load i64, ptr %msg_controllen1, align 8
  %conv252 = trunc i64 %180 to i32
  store i32 %conv252, ptr %tgt_space, align 4
  br label %if.end253

if.end253:                                        ; preds = %if.then251, %sw.epilog238
  %181 = load i32, ptr %tgt_space, align 4
  %conv254 = sext i32 %181 to i64
  %182 = load i64, ptr %msg_controllen1, align 8
  %sub255 = sub i64 %182, %conv254
  store i64 %sub255, ptr %msg_controllen1, align 8
  %183 = load i32, ptr %tgt_space, align 4
  %184 = load i32, ptr %space, align 4
  %add256 = add i32 %184, %183
  store i32 %add256, ptr %space, align 4
  %185 = load ptr, ptr %msgh.addr, align 8
  %186 = load ptr, ptr %cmsg, align 8
  %call257 = call ptr @__cmsg_nxthdr(ptr noundef %185, ptr noundef %186) #14
  store ptr %call257, ptr %cmsg, align 8
  %187 = load ptr, ptr %target_msgh.addr, align 8
  %188 = load ptr, ptr %target_cmsg, align 8
  %189 = load ptr, ptr %target_cmsg_start, align 8
  %call258 = call ptr @__target_cmsg_nxthdr(ptr noundef %187, ptr noundef %188, ptr noundef %189)
  store ptr %call258, ptr %target_cmsg, align 8
  br label %while.cond, !llvm.loop !56

while.end:                                        ; preds = %if.then13, %land.end
  %190 = load ptr, ptr %target_cmsg, align 8
  %191 = load i64, ptr %target_cmsg_addr, align 8
  %192 = load i32, ptr %space, align 4
  %conv259 = zext i32 %192 to i64
  call void @unlock_user(ptr noundef %190, i64 noundef %191, i64 noundef %conv259)
  br label %the_end

the_end:                                          ; preds = %while.end, %if.then
  %193 = load i32, ptr %space, align 4
  %conv260 = zext i32 %193 to i64
  %call261 = call i64 @tswapal(i64 noundef %conv260)
  %194 = load ptr, ptr %target_msgh.addr, align 8
  %msg_controllen262 = getelementptr inbounds %struct.target_msghdr, ptr %194, i32 0, i32 5
  store i64 %call261, ptr %msg_controllen262, align 8
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %the_end, %if.then7
  %195 = load i64, ptr %retval, align 8
  ret i64 %195
}

; Function Attrs: nounwind
declare ptr @__cmsg_nxthdr(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @__target_cmsg_nxthdr(ptr noundef %__mhdr, ptr noundef %__cmsg, ptr noundef %__cmsg_start) #0 {
entry:
  %retval = alloca ptr, align 8
  %__mhdr.addr = alloca ptr, align 8
  %__cmsg.addr = alloca ptr, align 8
  %__cmsg_start.addr = alloca ptr, align 8
  %__ptr = alloca ptr, align 8
  store ptr %__mhdr, ptr %__mhdr.addr, align 8
  store ptr %__cmsg, ptr %__cmsg.addr, align 8
  store ptr %__cmsg_start, ptr %__cmsg_start.addr, align 8
  %0 = load ptr, ptr %__cmsg.addr, align 8
  %1 = load ptr, ptr %__cmsg.addr, align 8
  %cmsg_len = getelementptr inbounds %struct.target_cmsghdr, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %cmsg_len, align 8
  %call = call i64 @tswapal(i64 noundef %2)
  %add = add i64 %call, 8
  %sub = sub i64 %add, 1
  %and = and i64 %sub, -8
  %add.ptr = getelementptr i8, ptr %0, i64 %and
  store ptr %add.ptr, ptr %__ptr, align 8
  %3 = load ptr, ptr %__ptr, align 8
  %add.ptr1 = getelementptr %struct.target_cmsghdr, ptr %3, i64 1
  %4 = load ptr, ptr %__cmsg_start.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %add.ptr1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %5 = load ptr, ptr %__mhdr.addr, align 8
  %msg_controllen = getelementptr inbounds %struct.target_msghdr, ptr %5, i32 0, i32 5
  %6 = load i64, ptr %msg_controllen, align 8
  %call2 = call i64 @tswapal(i64 noundef %6)
  %cmp = icmp ugt i64 %sub.ptr.sub, %call2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %7 = load ptr, ptr %__ptr, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @safe_sendto(i32 noundef %fd, ptr noundef %buf, i64 noundef %len, i32 noundef %flags, ptr noundef %addr, i32 noundef %addrlen) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %addr.addr = alloca ptr, align 8
  %addrlen.addr = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %addr, ptr %addr.addr, align 8
  store i32 %addrlen, ptr %addrlen.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %buf.addr, align 8
  %5 = load i64, ptr %len.addr, align 8
  %6 = load i32, ptr %flags.addr, align 4
  %7 = load ptr, ptr %addr.addr, align 8
  %8 = load i32, ptr %addrlen.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 44, i32 noundef %3, ptr noundef %4, i64 noundef %5, i32 noundef %6, ptr noundef %7, i32 noundef %8)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @target_to_host_sock_type(ptr noundef %type) #0 {
entry:
  %type.addr = alloca ptr, align 8
  %host_type = alloca i32, align 4
  %target_type = alloca i32, align 4
  store ptr %type, ptr %type.addr, align 8
  store i32 0, ptr %host_type, align 4
  %0 = load ptr, ptr %type.addr, align 8
  %1 = load i32, ptr %0, align 4
  store i32 %1, ptr %target_type, align 4
  %2 = load i32, ptr %target_type, align 4
  %and = and i32 %2, 15
  switch i32 %and, label %sw.default [
    i32 2, label %sw.bb
    i32 1, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  store i32 2, ptr %host_type, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  store i32 1, ptr %host_type, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %3 = load i32, ptr %target_type, align 4
  %and2 = and i32 %3, 15
  store i32 %and2, ptr %host_type, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb1, %sw.bb
  %4 = load i32, ptr %target_type, align 4
  %and3 = and i32 %4, 524288
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.epilog
  %5 = load i32, ptr %host_type, align 4
  %or = or i32 %5, 524288
  store i32 %or, ptr %host_type, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.epilog
  %6 = load i32, ptr %target_type, align 4
  %and4 = and i32 %6, 2048
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %7 = load i32, ptr %host_type, align 4
  %or7 = or i32 %7, 2048
  store i32 %or7, ptr %host_type, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %8 = load i32, ptr %host_type, align 4
  %9 = load ptr, ptr %type.addr, align 8
  store i32 %8, ptr %9, align 4
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @socket(i32 noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sock_flags_fixup(i32 noundef %fd, i32 noundef %target_type) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %target_type.addr = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %target_type, ptr %target_type.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  ret i32 %0
}

; Function Attrs: nounwind
declare i32 @socketpair(i32 noundef, i32 noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @setsockopt(i32 noundef, i32 noundef, i32 noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ldub_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i8, ptr %0, align 1
  %conv = zext i8 %1 to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_ip_mreq(ptr noundef %mreqn, i64 noundef %target_addr, i32 noundef %len) #0 {
entry:
  %retval = alloca i64, align 8
  %mreqn.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %len.addr = alloca i32, align 4
  %target_smreqn = alloca ptr, align 8
  store ptr %mreqn, ptr %mreqn.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  %0 = load i64, ptr %target_addr.addr, align 8
  %1 = load i32, ptr %len.addr, align 4
  %conv = zext i32 %1 to i64
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef %conv, i1 noundef zeroext true)
  store ptr %call, ptr %target_smreqn, align 8
  %2 = load ptr, ptr %target_smreqn, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %target_smreqn, align 8
  %imr_multiaddr = getelementptr inbounds %struct.target_ip_mreqn, ptr %3, i32 0, i32 0
  %s_addr = getelementptr inbounds %struct.target_in_addr, ptr %imr_multiaddr, i32 0, i32 0
  %4 = load i32, ptr %s_addr, align 8
  %5 = load ptr, ptr %mreqn.addr, align 8
  %imr_multiaddr1 = getelementptr inbounds %struct.ip_mreqn, ptr %5, i32 0, i32 0
  %s_addr2 = getelementptr inbounds %struct.in_addr, ptr %imr_multiaddr1, i32 0, i32 0
  store i32 %4, ptr %s_addr2, align 4
  %6 = load ptr, ptr %target_smreqn, align 8
  %imr_address = getelementptr inbounds %struct.target_ip_mreqn, ptr %6, i32 0, i32 1
  %s_addr3 = getelementptr inbounds %struct.target_in_addr, ptr %imr_address, i32 0, i32 0
  %7 = load i32, ptr %s_addr3, align 4
  %8 = load ptr, ptr %mreqn.addr, align 8
  %imr_address4 = getelementptr inbounds %struct.ip_mreqn, ptr %8, i32 0, i32 1
  %s_addr5 = getelementptr inbounds %struct.in_addr, ptr %imr_address4, i32 0, i32 0
  store i32 %7, ptr %s_addr5, align 4
  %9 = load i32, ptr %len.addr, align 4
  %conv6 = zext i32 %9 to i64
  %cmp = icmp eq i64 %conv6, 16
  br i1 %cmp, label %if.then8, label %if.end12

if.then8:                                         ; preds = %if.end
  %10 = load ptr, ptr %target_smreqn, align 8
  %imr_ifindex = getelementptr inbounds %struct.target_ip_mreqn, ptr %10, i32 0, i32 2
  %11 = load i64, ptr %imr_ifindex, align 8
  %call9 = call i64 @tswapal(i64 noundef %11)
  %conv10 = trunc i64 %call9 to i32
  %12 = load ptr, ptr %mreqn.addr, align 8
  %imr_ifindex11 = getelementptr inbounds %struct.ip_mreqn, ptr %12, i32 0, i32 2
  store i32 %conv10, ptr %imr_ifindex11, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then8, %if.end
  %13 = load ptr, ptr %target_smreqn, align 8
  %14 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %13, i64 noundef %14, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then
  %15 = load i64, ptr %retval, align 8
  ret i64 %15
}

declare i32 @copy_from_user(ptr noundef, i64 noundef, i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal void @stw_he_p(ptr noundef %ptr, i16 noundef zeroext %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i16, align 2
  store ptr %ptr, ptr %ptr.addr, align 8
  store i16 %v, ptr %v.addr, align 2
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %0, ptr align 2 %v.addr, i64 2, i1 false)
  ret void
}

; Function Attrs: allocsize(0,1)
declare noalias ptr @g_malloc_n(i64 noundef, i64 noundef) #9

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_sembuf(ptr noundef %host_sembuf, i64 noundef %target_addr, i32 noundef %nsops) #0 {
entry:
  %retval = alloca i64, align 8
  %host_sembuf.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %nsops.addr = alloca i32, align 4
  %target_sembuf = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %host_sembuf, ptr %host_sembuf.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store i32 %nsops, ptr %nsops.addr, align 4
  %0 = load i64, ptr %target_addr.addr, align 8
  %1 = load i32, ptr %nsops.addr, align 4
  %conv = zext i32 %1 to i64
  %mul = mul i64 %conv, 6
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef %mul, i1 noundef zeroext true)
  store ptr %call, ptr %target_sembuf, align 8
  %2 = load ptr, ptr %target_sembuf, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %nsops.addr, align 4
  %cmp = icmp ult i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load ptr, ptr %target_sembuf, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr %struct.target_sembuf, ptr %5, i64 %idxprom
  %sem_num = getelementptr inbounds %struct.target_sembuf, ptr %arrayidx, i32 0, i32 0
  %call2 = call i32 @lduw_le_p(ptr noundef %sem_num)
  %conv3 = trunc i32 %call2 to i16
  %7 = load ptr, ptr %host_sembuf.addr, align 8
  %8 = load i32, ptr %i, align 4
  %idxprom4 = sext i32 %8 to i64
  %arrayidx5 = getelementptr %struct.sembuf, ptr %7, i64 %idxprom4
  %sem_num6 = getelementptr inbounds %struct.sembuf, ptr %arrayidx5, i32 0, i32 0
  store i16 %conv3, ptr %sem_num6, align 2
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body7

do.body7:                                         ; preds = %do.end
  %9 = load ptr, ptr %target_sembuf, align 8
  %10 = load i32, ptr %i, align 4
  %idxprom8 = sext i32 %10 to i64
  %arrayidx9 = getelementptr %struct.target_sembuf, ptr %9, i64 %idxprom8
  %sem_op = getelementptr inbounds %struct.target_sembuf, ptr %arrayidx9, i32 0, i32 1
  %call10 = call i32 @lduw_le_p(ptr noundef %sem_op)
  %conv11 = trunc i32 %call10 to i16
  %11 = load ptr, ptr %host_sembuf.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idxprom12 = sext i32 %12 to i64
  %arrayidx13 = getelementptr %struct.sembuf, ptr %11, i64 %idxprom12
  %sem_op14 = getelementptr inbounds %struct.sembuf, ptr %arrayidx13, i32 0, i32 1
  store i16 %conv11, ptr %sem_op14, align 2
  br label %do.end15

do.end15:                                         ; preds = %do.body7
  br label %do.body16

do.body16:                                        ; preds = %do.end15
  %13 = load ptr, ptr %target_sembuf, align 8
  %14 = load i32, ptr %i, align 4
  %idxprom17 = sext i32 %14 to i64
  %arrayidx18 = getelementptr %struct.target_sembuf, ptr %13, i64 %idxprom17
  %sem_flg = getelementptr inbounds %struct.target_sembuf, ptr %arrayidx18, i32 0, i32 2
  %call19 = call i32 @lduw_le_p(ptr noundef %sem_flg)
  %conv20 = trunc i32 %call19 to i16
  %15 = load ptr, ptr %host_sembuf.addr, align 8
  %16 = load i32, ptr %i, align 4
  %idxprom21 = sext i32 %16 to i64
  %arrayidx22 = getelementptr %struct.sembuf, ptr %15, i64 %idxprom21
  %sem_flg23 = getelementptr inbounds %struct.sembuf, ptr %arrayidx22, i32 0, i32 2
  store i16 %conv20, ptr %sem_flg23, align 2
  br label %do.end24

do.end24:                                         ; preds = %do.body16
  br label %for.inc

for.inc:                                          ; preds = %do.end24
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !57

for.end:                                          ; preds = %for.cond
  %18 = load ptr, ptr %target_sembuf, align 8
  %19 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %18, i64 noundef %19, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  %20 = load i64, ptr %retval, align 8
  ret i64 %20
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_semtimedop(i32 noundef %semid, ptr noundef %tsops, i32 noundef %nsops, ptr noundef %timeout) #0 {
entry:
  %semid.addr = alloca i32, align 4
  %tsops.addr = alloca ptr, align 8
  %nsops.addr = alloca i32, align 4
  %timeout.addr = alloca ptr, align 8
  store i32 %semid, ptr %semid.addr, align 4
  store ptr %tsops, ptr %tsops.addr, align 8
  store i32 %nsops, ptr %nsops.addr, align 4
  store ptr %timeout, ptr %timeout.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %semid.addr, align 4
  %4 = load ptr, ptr %tsops.addr, align 8
  %5 = load i32, ptr %nsops.addr, align 4
  %6 = load ptr, ptr %timeout.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 220, i32 noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef %6)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @semctl(i32 noundef, i32 noundef, i32 noundef, ...) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_semarray(i32 noundef %semid, ptr noundef %host_array, i64 noundef %target_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %semid.addr = alloca i32, align 4
  %host_array.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %nsems = alloca i32, align 4
  %array = alloca ptr, align 8
  %semun = alloca %union.semun, align 8
  %semid_ds = alloca %struct.semid_ds, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  store i32 %semid, ptr %semid.addr, align 4
  store ptr %host_array, ptr %host_array.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %semid_ds, ptr %semun, align 8
  %0 = load i32, ptr %semid.addr, align 4
  %coerce.dive = getelementptr inbounds %union.semun, ptr %semun, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive, align 8
  %call = call i32 (i32, i32, i32, ...) @semctl(i32 noundef %0, i32 noundef 0, i32 noundef 2, ptr %1) #14
  store i32 %call, ptr %ret, align 4
  %2 = load i32, ptr %ret, align 4
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, ptr %ret, align 4
  %conv = sext i32 %3 to i64
  %call1 = call i64 @get_errno(i64 noundef %conv)
  store i64 %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %sem_nsems = getelementptr inbounds %struct.semid_ds, ptr %semid_ds, i32 0, i32 5
  %4 = load i64, ptr %sem_nsems, align 8
  %conv2 = trunc i64 %4 to i32
  store i32 %conv2, ptr %nsems, align 4
  %5 = load i32, ptr %nsems, align 4
  %conv3 = sext i32 %5 to i64
  %call4 = call noalias ptr @g_try_malloc_n(i64 noundef %conv3, i64 noundef 2) #17
  %6 = load ptr, ptr %host_array.addr, align 8
  store ptr %call4, ptr %6, align 8
  %7 = load ptr, ptr %host_array.addr, align 8
  %8 = load ptr, ptr %7, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  store i64 -12, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %9 = load i64, ptr %target_addr.addr, align 8
  %10 = load i32, ptr %nsems, align 4
  %conv7 = sext i32 %10 to i64
  %mul = mul i64 %conv7, 2
  %call8 = call ptr @lock_user(i32 noundef 1, i64 noundef %9, i64 noundef %mul, i1 noundef zeroext true)
  store ptr %call8, ptr %array, align 8
  %11 = load ptr, ptr %array, align 8
  %tobool9 = icmp ne ptr %11, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end6
  %12 = load ptr, ptr %host_array.addr, align 8
  %13 = load ptr, ptr %12, align 8
  call void @g_free(ptr noundef %13)
  store i64 -14, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end6
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end11
  %14 = load i32, ptr %i, align 4
  %15 = load i32, ptr %nsems, align 4
  %cmp12 = icmp slt i32 %14, %15
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.body
  %16 = load ptr, ptr %array, align 8
  %17 = load i32, ptr %i, align 4
  %idxprom = sext i32 %17 to i64
  %arrayidx = getelementptr i16, ptr %16, i64 %idxprom
  %call14 = call i32 @lduw_le_p(ptr noundef %arrayidx)
  %conv15 = trunc i32 %call14 to i16
  %18 = load ptr, ptr %host_array.addr, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = load i32, ptr %i, align 4
  %idxprom16 = sext i32 %20 to i64
  %arrayidx17 = getelementptr i16, ptr %19, i64 %idxprom16
  store i16 %conv15, ptr %arrayidx17, align 2
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !58

for.end:                                          ; preds = %for.cond
  %22 = load ptr, ptr %array, align 8
  %23 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %22, i64 noundef %23, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then10, %if.then5, %if.then
  %24 = load i64, ptr %retval, align 8
  ret i64 %24
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_semarray(i32 noundef %semid, i64 noundef %target_addr, ptr noundef %host_array) #0 {
entry:
  %retval = alloca i64, align 8
  %semid.addr = alloca i32, align 4
  %target_addr.addr = alloca i64, align 8
  %host_array.addr = alloca ptr, align 8
  %nsems = alloca i32, align 4
  %array = alloca ptr, align 8
  %semun = alloca %union.semun, align 8
  %semid_ds = alloca %struct.semid_ds, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  store i32 %semid, ptr %semid.addr, align 4
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_array, ptr %host_array.addr, align 8
  store ptr %semid_ds, ptr %semun, align 8
  %0 = load i32, ptr %semid.addr, align 4
  %coerce.dive = getelementptr inbounds %union.semun, ptr %semun, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive, align 8
  %call = call i32 (i32, i32, i32, ...) @semctl(i32 noundef %0, i32 noundef 0, i32 noundef 2, ptr %1) #14
  store i32 %call, ptr %ret, align 4
  %2 = load i32, ptr %ret, align 4
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, ptr %ret, align 4
  %conv = sext i32 %3 to i64
  %call1 = call i64 @get_errno(i64 noundef %conv)
  store i64 %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %sem_nsems = getelementptr inbounds %struct.semid_ds, ptr %semid_ds, i32 0, i32 5
  %4 = load i64, ptr %sem_nsems, align 8
  %conv2 = trunc i64 %4 to i32
  store i32 %conv2, ptr %nsems, align 4
  %5 = load i64, ptr %target_addr.addr, align 8
  %6 = load i32, ptr %nsems, align 4
  %conv3 = sext i32 %6 to i64
  %mul = mul i64 %conv3, 2
  %call4 = call ptr @lock_user(i32 noundef 3, i64 noundef %5, i64 noundef %mul, i1 noundef zeroext false)
  store ptr %call4, ptr %array, align 8
  %7 = load ptr, ptr %array, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %nsems, align 4
  %cmp7 = icmp slt i32 %8, %9
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.body
  %10 = load ptr, ptr %array, align 8
  %11 = load i32, ptr %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr i16, ptr %10, i64 %idxprom
  %12 = load ptr, ptr %host_array.addr, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = load i32, ptr %i, align 4
  %idxprom9 = sext i32 %14 to i64
  %arrayidx10 = getelementptr i16, ptr %13, i64 %idxprom9
  %15 = load i16, ptr %arrayidx10, align 2
  call void @stw_le_p(ptr noundef %arrayidx, i16 noundef zeroext %15)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %16 = load i32, ptr %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !59

for.end:                                          ; preds = %for.cond
  %17 = load ptr, ptr %host_array.addr, align 8
  %18 = load ptr, ptr %17, align 8
  call void @g_free(ptr noundef %18)
  %19 = load ptr, ptr %array, align 8
  %20 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %19, i64 noundef %20, i64 noundef 1)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then5, %if.then
  %21 = load i64, ptr %retval, align 8
  ret i64 %21
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_semid_ds(ptr noundef %host_sd, i64 noundef %target_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %host_sd.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %target_sd = alloca ptr, align 8
  store ptr %host_sd, ptr %host_sd.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 88, i1 noundef zeroext true)
  store ptr %call, ptr %target_sd, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %host_sd.addr, align 8
  %sem_perm = getelementptr inbounds %struct.semid_ds, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %target_addr.addr, align 8
  %call1 = call i64 @target_to_host_ipc_perm(ptr noundef %sem_perm, i64 noundef %2)
  %tobool2 = icmp ne i64 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %3 = load ptr, ptr %target_sd, align 8
  %sem_nsems = getelementptr inbounds %struct.target_semid64_ds, ptr %3, i32 0, i32 3
  %4 = load i64, ptr %sem_nsems, align 8
  %call5 = call i64 @tswapal(i64 noundef %4)
  %5 = load ptr, ptr %host_sd.addr, align 8
  %sem_nsems6 = getelementptr inbounds %struct.semid_ds, ptr %5, i32 0, i32 5
  store i64 %call5, ptr %sem_nsems6, align 8
  %6 = load ptr, ptr %target_sd, align 8
  %sem_otime = getelementptr inbounds %struct.target_semid64_ds, ptr %6, i32 0, i32 1
  %7 = load i64, ptr %sem_otime, align 8
  %call7 = call i64 @tswapal(i64 noundef %7)
  %8 = load ptr, ptr %host_sd.addr, align 8
  %sem_otime8 = getelementptr inbounds %struct.semid_ds, ptr %8, i32 0, i32 1
  store i64 %call7, ptr %sem_otime8, align 8
  %9 = load ptr, ptr %target_sd, align 8
  %sem_ctime = getelementptr inbounds %struct.target_semid64_ds, ptr %9, i32 0, i32 2
  %10 = load i64, ptr %sem_ctime, align 8
  %call9 = call i64 @tswapal(i64 noundef %10)
  %11 = load ptr, ptr %host_sd.addr, align 8
  %sem_ctime10 = getelementptr inbounds %struct.semid_ds, ptr %11, i32 0, i32 3
  store i64 %call9, ptr %sem_ctime10, align 8
  %12 = load ptr, ptr %target_sd, align 8
  %13 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %12, i64 noundef %13, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %14 = load i64, ptr %retval, align 8
  ret i64 %14
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_semid_ds(i64 noundef %target_addr, ptr noundef %host_sd) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %host_sd.addr = alloca ptr, align 8
  %target_sd = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_sd, ptr %host_sd.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 88, i1 noundef zeroext false)
  store ptr %call, ptr %target_sd, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %target_addr.addr, align 8
  %2 = load ptr, ptr %host_sd.addr, align 8
  %sem_perm = getelementptr inbounds %struct.semid_ds, ptr %2, i32 0, i32 0
  %call1 = call i64 @host_to_target_ipc_perm(i64 noundef %1, ptr noundef %sem_perm)
  %tobool2 = icmp ne i64 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %3 = load ptr, ptr %host_sd.addr, align 8
  %sem_nsems = getelementptr inbounds %struct.semid_ds, ptr %3, i32 0, i32 5
  %4 = load i64, ptr %sem_nsems, align 8
  %call5 = call i64 @tswapal(i64 noundef %4)
  %5 = load ptr, ptr %target_sd, align 8
  %sem_nsems6 = getelementptr inbounds %struct.target_semid64_ds, ptr %5, i32 0, i32 3
  store i64 %call5, ptr %sem_nsems6, align 8
  %6 = load ptr, ptr %host_sd.addr, align 8
  %sem_otime = getelementptr inbounds %struct.semid_ds, ptr %6, i32 0, i32 1
  %7 = load i64, ptr %sem_otime, align 8
  %call7 = call i64 @tswapal(i64 noundef %7)
  %8 = load ptr, ptr %target_sd, align 8
  %sem_otime8 = getelementptr inbounds %struct.target_semid64_ds, ptr %8, i32 0, i32 1
  store i64 %call7, ptr %sem_otime8, align 8
  %9 = load ptr, ptr %host_sd.addr, align 8
  %sem_ctime = getelementptr inbounds %struct.semid_ds, ptr %9, i32 0, i32 3
  %10 = load i64, ptr %sem_ctime, align 8
  %call9 = call i64 @tswapal(i64 noundef %10)
  %11 = load ptr, ptr %target_sd, align 8
  %sem_ctime10 = getelementptr inbounds %struct.target_semid64_ds, ptr %11, i32 0, i32 2
  store i64 %call9, ptr %sem_ctime10, align 8
  %12 = load ptr, ptr %target_sd, align 8
  %13 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %12, i64 noundef %13, i64 noundef 88)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %14 = load i64, ptr %retval, align 8
  ret i64 %14
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_seminfo(i64 noundef %target_addr, ptr noundef %host_seminfo) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %host_seminfo.addr = alloca ptr, align 8
  %target_seminfo = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_seminfo, ptr %host_seminfo.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 40, i1 noundef zeroext false)
  store ptr %call, ptr %target_seminfo, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_seminfo, align 8
  %semmap = getelementptr inbounds %struct.target_seminfo, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %host_seminfo.addr, align 8
  %semmap1 = getelementptr inbounds %struct.seminfo, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %semmap1, align 4
  call void @stl_le_p(ptr noundef %semmap, i32 noundef %3)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %4 = load ptr, ptr %target_seminfo, align 8
  %semmni = getelementptr inbounds %struct.target_seminfo, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %host_seminfo.addr, align 8
  %semmni3 = getelementptr inbounds %struct.seminfo, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %semmni3, align 4
  call void @stl_le_p(ptr noundef %semmni, i32 noundef %6)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  br label %do.body5

do.body5:                                         ; preds = %do.end4
  %7 = load ptr, ptr %target_seminfo, align 8
  %semmns = getelementptr inbounds %struct.target_seminfo, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %host_seminfo.addr, align 8
  %semmns6 = getelementptr inbounds %struct.seminfo, ptr %8, i32 0, i32 2
  %9 = load i32, ptr %semmns6, align 4
  call void @stl_le_p(ptr noundef %semmns, i32 noundef %9)
  br label %do.end7

do.end7:                                          ; preds = %do.body5
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %10 = load ptr, ptr %target_seminfo, align 8
  %semmnu = getelementptr inbounds %struct.target_seminfo, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %host_seminfo.addr, align 8
  %semmnu9 = getelementptr inbounds %struct.seminfo, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %semmnu9, align 4
  call void @stl_le_p(ptr noundef %semmnu, i32 noundef %12)
  br label %do.end10

do.end10:                                         ; preds = %do.body8
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %13 = load ptr, ptr %target_seminfo, align 8
  %semmsl = getelementptr inbounds %struct.target_seminfo, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %host_seminfo.addr, align 8
  %semmsl12 = getelementptr inbounds %struct.seminfo, ptr %14, i32 0, i32 4
  %15 = load i32, ptr %semmsl12, align 4
  call void @stl_le_p(ptr noundef %semmsl, i32 noundef %15)
  br label %do.end13

do.end13:                                         ; preds = %do.body11
  br label %do.body14

do.body14:                                        ; preds = %do.end13
  %16 = load ptr, ptr %target_seminfo, align 8
  %semopm = getelementptr inbounds %struct.target_seminfo, ptr %16, i32 0, i32 5
  %17 = load ptr, ptr %host_seminfo.addr, align 8
  %semopm15 = getelementptr inbounds %struct.seminfo, ptr %17, i32 0, i32 5
  %18 = load i32, ptr %semopm15, align 4
  call void @stl_le_p(ptr noundef %semopm, i32 noundef %18)
  br label %do.end16

do.end16:                                         ; preds = %do.body14
  br label %do.body17

do.body17:                                        ; preds = %do.end16
  %19 = load ptr, ptr %target_seminfo, align 8
  %semume = getelementptr inbounds %struct.target_seminfo, ptr %19, i32 0, i32 6
  %20 = load ptr, ptr %host_seminfo.addr, align 8
  %semume18 = getelementptr inbounds %struct.seminfo, ptr %20, i32 0, i32 6
  %21 = load i32, ptr %semume18, align 4
  call void @stl_le_p(ptr noundef %semume, i32 noundef %21)
  br label %do.end19

do.end19:                                         ; preds = %do.body17
  br label %do.body20

do.body20:                                        ; preds = %do.end19
  %22 = load ptr, ptr %target_seminfo, align 8
  %semusz = getelementptr inbounds %struct.target_seminfo, ptr %22, i32 0, i32 7
  %23 = load ptr, ptr %host_seminfo.addr, align 8
  %semusz21 = getelementptr inbounds %struct.seminfo, ptr %23, i32 0, i32 7
  %24 = load i32, ptr %semusz21, align 4
  call void @stl_le_p(ptr noundef %semusz, i32 noundef %24)
  br label %do.end22

do.end22:                                         ; preds = %do.body20
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  %25 = load ptr, ptr %target_seminfo, align 8
  %semvmx = getelementptr inbounds %struct.target_seminfo, ptr %25, i32 0, i32 8
  %26 = load ptr, ptr %host_seminfo.addr, align 8
  %semvmx24 = getelementptr inbounds %struct.seminfo, ptr %26, i32 0, i32 8
  %27 = load i32, ptr %semvmx24, align 4
  call void @stl_le_p(ptr noundef %semvmx, i32 noundef %27)
  br label %do.end25

do.end25:                                         ; preds = %do.body23
  br label %do.body26

do.body26:                                        ; preds = %do.end25
  %28 = load ptr, ptr %target_seminfo, align 8
  %semaem = getelementptr inbounds %struct.target_seminfo, ptr %28, i32 0, i32 9
  %29 = load ptr, ptr %host_seminfo.addr, align 8
  %semaem27 = getelementptr inbounds %struct.seminfo, ptr %29, i32 0, i32 9
  %30 = load i32, ptr %semaem27, align 4
  call void @stl_le_p(ptr noundef %semaem, i32 noundef %30)
  br label %do.end28

do.end28:                                         ; preds = %do.body26
  %31 = load ptr, ptr %target_seminfo, align 8
  %32 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %31, i64 noundef %32, i64 noundef 40)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end28, %if.then
  %33 = load i64, ptr %retval, align 8
  ret i64 %33
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_ipc_perm(ptr noundef %host_ip, i64 noundef %target_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %host_ip.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %target_ip = alloca ptr, align 8
  %target_sd = alloca ptr, align 8
  store ptr %host_ip, ptr %host_ip.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 88, i1 noundef zeroext true)
  store ptr %call, ptr %target_sd, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %target_sd, align 8
  %sem_perm = getelementptr inbounds %struct.target_semid64_ds, ptr %1, i32 0, i32 0
  store ptr %sem_perm, ptr %target_ip, align 8
  %2 = load ptr, ptr %target_ip, align 8
  %__key = getelementptr inbounds %struct.target_ipc_perm, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %__key, align 8
  %call1 = call i32 @tswap32(i32 noundef %3)
  %4 = load ptr, ptr %host_ip.addr, align 8
  %__key2 = getelementptr inbounds %struct.ipc_perm, ptr %4, i32 0, i32 0
  store i32 %call1, ptr %__key2, align 8
  %5 = load ptr, ptr %target_ip, align 8
  %uid = getelementptr inbounds %struct.target_ipc_perm, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %uid, align 4
  %call3 = call i32 @tswap32(i32 noundef %6)
  %7 = load ptr, ptr %host_ip.addr, align 8
  %uid4 = getelementptr inbounds %struct.ipc_perm, ptr %7, i32 0, i32 1
  store i32 %call3, ptr %uid4, align 4
  %8 = load ptr, ptr %target_ip, align 8
  %gid = getelementptr inbounds %struct.target_ipc_perm, ptr %8, i32 0, i32 2
  %9 = load i32, ptr %gid, align 8
  %call5 = call i32 @tswap32(i32 noundef %9)
  %10 = load ptr, ptr %host_ip.addr, align 8
  %gid6 = getelementptr inbounds %struct.ipc_perm, ptr %10, i32 0, i32 2
  store i32 %call5, ptr %gid6, align 8
  %11 = load ptr, ptr %target_ip, align 8
  %cuid = getelementptr inbounds %struct.target_ipc_perm, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %cuid, align 4
  %call7 = call i32 @tswap32(i32 noundef %12)
  %13 = load ptr, ptr %host_ip.addr, align 8
  %cuid8 = getelementptr inbounds %struct.ipc_perm, ptr %13, i32 0, i32 3
  store i32 %call7, ptr %cuid8, align 4
  %14 = load ptr, ptr %target_ip, align 8
  %cgid = getelementptr inbounds %struct.target_ipc_perm, ptr %14, i32 0, i32 4
  %15 = load i32, ptr %cgid, align 8
  %call9 = call i32 @tswap32(i32 noundef %15)
  %16 = load ptr, ptr %host_ip.addr, align 8
  %cgid10 = getelementptr inbounds %struct.ipc_perm, ptr %16, i32 0, i32 4
  store i32 %call9, ptr %cgid10, align 8
  %17 = load ptr, ptr %target_ip, align 8
  %mode = getelementptr inbounds %struct.target_ipc_perm, ptr %17, i32 0, i32 5
  %18 = load i16, ptr %mode, align 4
  %call11 = call zeroext i16 @tswap16(i16 noundef zeroext %18)
  %conv = zext i16 %call11 to i32
  %19 = load ptr, ptr %host_ip.addr, align 8
  %mode12 = getelementptr inbounds %struct.ipc_perm, ptr %19, i32 0, i32 5
  store i32 %conv, ptr %mode12, align 4
  %20 = load ptr, ptr %target_ip, align 8
  %__seq = getelementptr inbounds %struct.target_ipc_perm, ptr %20, i32 0, i32 7
  %21 = load i16, ptr %__seq, align 8
  %call13 = call zeroext i16 @tswap16(i16 noundef zeroext %21)
  %22 = load ptr, ptr %host_ip.addr, align 8
  %__seq14 = getelementptr inbounds %struct.ipc_perm, ptr %22, i32 0, i32 6
  store i16 %call13, ptr %__seq14, align 8
  %23 = load ptr, ptr %target_sd, align 8
  %24 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %23, i64 noundef %24, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %25 = load i64, ptr %retval, align 8
  ret i64 %25
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_ipc_perm(i64 noundef %target_addr, ptr noundef %host_ip) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %host_ip.addr = alloca ptr, align 8
  %target_ip = alloca ptr, align 8
  %target_sd = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_ip, ptr %host_ip.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 88, i1 noundef zeroext false)
  store ptr %call, ptr %target_sd, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %target_sd, align 8
  %sem_perm = getelementptr inbounds %struct.target_semid64_ds, ptr %1, i32 0, i32 0
  store ptr %sem_perm, ptr %target_ip, align 8
  %2 = load ptr, ptr %host_ip.addr, align 8
  %__key = getelementptr inbounds %struct.ipc_perm, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %__key, align 8
  %call1 = call i32 @tswap32(i32 noundef %3)
  %4 = load ptr, ptr %target_ip, align 8
  %__key2 = getelementptr inbounds %struct.target_ipc_perm, ptr %4, i32 0, i32 0
  store i32 %call1, ptr %__key2, align 8
  %5 = load ptr, ptr %host_ip.addr, align 8
  %uid = getelementptr inbounds %struct.ipc_perm, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %uid, align 4
  %call3 = call i32 @tswap32(i32 noundef %6)
  %7 = load ptr, ptr %target_ip, align 8
  %uid4 = getelementptr inbounds %struct.target_ipc_perm, ptr %7, i32 0, i32 1
  store i32 %call3, ptr %uid4, align 4
  %8 = load ptr, ptr %host_ip.addr, align 8
  %gid = getelementptr inbounds %struct.ipc_perm, ptr %8, i32 0, i32 2
  %9 = load i32, ptr %gid, align 8
  %call5 = call i32 @tswap32(i32 noundef %9)
  %10 = load ptr, ptr %target_ip, align 8
  %gid6 = getelementptr inbounds %struct.target_ipc_perm, ptr %10, i32 0, i32 2
  store i32 %call5, ptr %gid6, align 8
  %11 = load ptr, ptr %host_ip.addr, align 8
  %cuid = getelementptr inbounds %struct.ipc_perm, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %cuid, align 4
  %call7 = call i32 @tswap32(i32 noundef %12)
  %13 = load ptr, ptr %target_ip, align 8
  %cuid8 = getelementptr inbounds %struct.target_ipc_perm, ptr %13, i32 0, i32 3
  store i32 %call7, ptr %cuid8, align 4
  %14 = load ptr, ptr %host_ip.addr, align 8
  %cgid = getelementptr inbounds %struct.ipc_perm, ptr %14, i32 0, i32 4
  %15 = load i32, ptr %cgid, align 8
  %call9 = call i32 @tswap32(i32 noundef %15)
  %16 = load ptr, ptr %target_ip, align 8
  %cgid10 = getelementptr inbounds %struct.target_ipc_perm, ptr %16, i32 0, i32 4
  store i32 %call9, ptr %cgid10, align 8
  %17 = load ptr, ptr %host_ip.addr, align 8
  %mode = getelementptr inbounds %struct.ipc_perm, ptr %17, i32 0, i32 5
  %18 = load i32, ptr %mode, align 4
  %conv = trunc i32 %18 to i16
  %call11 = call zeroext i16 @tswap16(i16 noundef zeroext %conv)
  %19 = load ptr, ptr %target_ip, align 8
  %mode12 = getelementptr inbounds %struct.target_ipc_perm, ptr %19, i32 0, i32 5
  store i16 %call11, ptr %mode12, align 4
  %20 = load ptr, ptr %host_ip.addr, align 8
  %__seq = getelementptr inbounds %struct.ipc_perm, ptr %20, i32 0, i32 6
  %21 = load i16, ptr %__seq, align 8
  %call13 = call zeroext i16 @tswap16(i16 noundef zeroext %21)
  %22 = load ptr, ptr %target_ip, align 8
  %__seq14 = getelementptr inbounds %struct.target_ipc_perm, ptr %22, i32 0, i32 7
  store i16 %call13, ptr %__seq14, align 8
  %23 = load ptr, ptr %target_sd, align 8
  %24 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %23, i64 noundef %24, i64 noundef 88)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %25 = load i64, ptr %retval, align 8
  ret i64 %25
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_msqid_ds(ptr noundef %host_md, i64 noundef %target_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %host_md.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %target_md = alloca ptr, align 8
  store ptr %host_md, ptr %host_md.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 128, i1 noundef zeroext true)
  store ptr %call, ptr %target_md, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %host_md.addr, align 8
  %msg_perm = getelementptr inbounds %struct.msqid_ds, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %target_addr.addr, align 8
  %call1 = call i64 @target_to_host_ipc_perm(ptr noundef %msg_perm, i64 noundef %2)
  %tobool2 = icmp ne i64 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %3 = load ptr, ptr %target_md, align 8
  %msg_stime = getelementptr inbounds %struct.target_msqid_ds, ptr %3, i32 0, i32 1
  %4 = load i64, ptr %msg_stime, align 8
  %call5 = call i64 @tswapal(i64 noundef %4)
  %5 = load ptr, ptr %host_md.addr, align 8
  %msg_stime6 = getelementptr inbounds %struct.msqid_ds, ptr %5, i32 0, i32 1
  store i64 %call5, ptr %msg_stime6, align 8
  %6 = load ptr, ptr %target_md, align 8
  %msg_rtime = getelementptr inbounds %struct.target_msqid_ds, ptr %6, i32 0, i32 2
  %7 = load i64, ptr %msg_rtime, align 8
  %call7 = call i64 @tswapal(i64 noundef %7)
  %8 = load ptr, ptr %host_md.addr, align 8
  %msg_rtime8 = getelementptr inbounds %struct.msqid_ds, ptr %8, i32 0, i32 2
  store i64 %call7, ptr %msg_rtime8, align 8
  %9 = load ptr, ptr %target_md, align 8
  %msg_ctime = getelementptr inbounds %struct.target_msqid_ds, ptr %9, i32 0, i32 3
  %10 = load i64, ptr %msg_ctime, align 8
  %call9 = call i64 @tswapal(i64 noundef %10)
  %11 = load ptr, ptr %host_md.addr, align 8
  %msg_ctime10 = getelementptr inbounds %struct.msqid_ds, ptr %11, i32 0, i32 3
  store i64 %call9, ptr %msg_ctime10, align 8
  %12 = load ptr, ptr %target_md, align 8
  %__msg_cbytes = getelementptr inbounds %struct.target_msqid_ds, ptr %12, i32 0, i32 4
  %13 = load i64, ptr %__msg_cbytes, align 8
  %call11 = call i64 @tswapal(i64 noundef %13)
  %14 = load ptr, ptr %host_md.addr, align 8
  %__msg_cbytes12 = getelementptr inbounds %struct.msqid_ds, ptr %14, i32 0, i32 4
  store i64 %call11, ptr %__msg_cbytes12, align 8
  %15 = load ptr, ptr %target_md, align 8
  %msg_qnum = getelementptr inbounds %struct.target_msqid_ds, ptr %15, i32 0, i32 5
  %16 = load i64, ptr %msg_qnum, align 8
  %call13 = call i64 @tswapal(i64 noundef %16)
  %17 = load ptr, ptr %host_md.addr, align 8
  %msg_qnum14 = getelementptr inbounds %struct.msqid_ds, ptr %17, i32 0, i32 5
  store i64 %call13, ptr %msg_qnum14, align 8
  %18 = load ptr, ptr %target_md, align 8
  %msg_qbytes = getelementptr inbounds %struct.target_msqid_ds, ptr %18, i32 0, i32 6
  %19 = load i64, ptr %msg_qbytes, align 8
  %call15 = call i64 @tswapal(i64 noundef %19)
  %20 = load ptr, ptr %host_md.addr, align 8
  %msg_qbytes16 = getelementptr inbounds %struct.msqid_ds, ptr %20, i32 0, i32 6
  store i64 %call15, ptr %msg_qbytes16, align 8
  %21 = load ptr, ptr %target_md, align 8
  %msg_lspid = getelementptr inbounds %struct.target_msqid_ds, ptr %21, i32 0, i32 7
  %22 = load i64, ptr %msg_lspid, align 8
  %call17 = call i64 @tswapal(i64 noundef %22)
  %conv = trunc i64 %call17 to i32
  %23 = load ptr, ptr %host_md.addr, align 8
  %msg_lspid18 = getelementptr inbounds %struct.msqid_ds, ptr %23, i32 0, i32 7
  store i32 %conv, ptr %msg_lspid18, align 8
  %24 = load ptr, ptr %target_md, align 8
  %msg_lrpid = getelementptr inbounds %struct.target_msqid_ds, ptr %24, i32 0, i32 8
  %25 = load i64, ptr %msg_lrpid, align 8
  %call19 = call i64 @tswapal(i64 noundef %25)
  %conv20 = trunc i64 %call19 to i32
  %26 = load ptr, ptr %host_md.addr, align 8
  %msg_lrpid21 = getelementptr inbounds %struct.msqid_ds, ptr %26, i32 0, i32 8
  store i32 %conv20, ptr %msg_lrpid21, align 4
  %27 = load ptr, ptr %target_md, align 8
  %28 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %27, i64 noundef %28, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %29 = load i64, ptr %retval, align 8
  ret i64 %29
}

; Function Attrs: nounwind
declare i32 @msgctl(i32 noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_msqid_ds(i64 noundef %target_addr, ptr noundef %host_md) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %host_md.addr = alloca ptr, align 8
  %target_md = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_md, ptr %host_md.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 128, i1 noundef zeroext false)
  store ptr %call, ptr %target_md, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %target_addr.addr, align 8
  %2 = load ptr, ptr %host_md.addr, align 8
  %msg_perm = getelementptr inbounds %struct.msqid_ds, ptr %2, i32 0, i32 0
  %call1 = call i64 @host_to_target_ipc_perm(i64 noundef %1, ptr noundef %msg_perm)
  %tobool2 = icmp ne i64 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %3 = load ptr, ptr %host_md.addr, align 8
  %msg_stime = getelementptr inbounds %struct.msqid_ds, ptr %3, i32 0, i32 1
  %4 = load i64, ptr %msg_stime, align 8
  %call5 = call i64 @tswapal(i64 noundef %4)
  %5 = load ptr, ptr %target_md, align 8
  %msg_stime6 = getelementptr inbounds %struct.target_msqid_ds, ptr %5, i32 0, i32 1
  store i64 %call5, ptr %msg_stime6, align 8
  %6 = load ptr, ptr %host_md.addr, align 8
  %msg_rtime = getelementptr inbounds %struct.msqid_ds, ptr %6, i32 0, i32 2
  %7 = load i64, ptr %msg_rtime, align 8
  %call7 = call i64 @tswapal(i64 noundef %7)
  %8 = load ptr, ptr %target_md, align 8
  %msg_rtime8 = getelementptr inbounds %struct.target_msqid_ds, ptr %8, i32 0, i32 2
  store i64 %call7, ptr %msg_rtime8, align 8
  %9 = load ptr, ptr %host_md.addr, align 8
  %msg_ctime = getelementptr inbounds %struct.msqid_ds, ptr %9, i32 0, i32 3
  %10 = load i64, ptr %msg_ctime, align 8
  %call9 = call i64 @tswapal(i64 noundef %10)
  %11 = load ptr, ptr %target_md, align 8
  %msg_ctime10 = getelementptr inbounds %struct.target_msqid_ds, ptr %11, i32 0, i32 3
  store i64 %call9, ptr %msg_ctime10, align 8
  %12 = load ptr, ptr %host_md.addr, align 8
  %__msg_cbytes = getelementptr inbounds %struct.msqid_ds, ptr %12, i32 0, i32 4
  %13 = load i64, ptr %__msg_cbytes, align 8
  %call11 = call i64 @tswapal(i64 noundef %13)
  %14 = load ptr, ptr %target_md, align 8
  %__msg_cbytes12 = getelementptr inbounds %struct.target_msqid_ds, ptr %14, i32 0, i32 4
  store i64 %call11, ptr %__msg_cbytes12, align 8
  %15 = load ptr, ptr %host_md.addr, align 8
  %msg_qnum = getelementptr inbounds %struct.msqid_ds, ptr %15, i32 0, i32 5
  %16 = load i64, ptr %msg_qnum, align 8
  %call13 = call i64 @tswapal(i64 noundef %16)
  %17 = load ptr, ptr %target_md, align 8
  %msg_qnum14 = getelementptr inbounds %struct.target_msqid_ds, ptr %17, i32 0, i32 5
  store i64 %call13, ptr %msg_qnum14, align 8
  %18 = load ptr, ptr %host_md.addr, align 8
  %msg_qbytes = getelementptr inbounds %struct.msqid_ds, ptr %18, i32 0, i32 6
  %19 = load i64, ptr %msg_qbytes, align 8
  %call15 = call i64 @tswapal(i64 noundef %19)
  %20 = load ptr, ptr %target_md, align 8
  %msg_qbytes16 = getelementptr inbounds %struct.target_msqid_ds, ptr %20, i32 0, i32 6
  store i64 %call15, ptr %msg_qbytes16, align 8
  %21 = load ptr, ptr %host_md.addr, align 8
  %msg_lspid = getelementptr inbounds %struct.msqid_ds, ptr %21, i32 0, i32 7
  %22 = load i32, ptr %msg_lspid, align 8
  %conv = sext i32 %22 to i64
  %call17 = call i64 @tswapal(i64 noundef %conv)
  %23 = load ptr, ptr %target_md, align 8
  %msg_lspid18 = getelementptr inbounds %struct.target_msqid_ds, ptr %23, i32 0, i32 7
  store i64 %call17, ptr %msg_lspid18, align 8
  %24 = load ptr, ptr %host_md.addr, align 8
  %msg_lrpid = getelementptr inbounds %struct.msqid_ds, ptr %24, i32 0, i32 8
  %25 = load i32, ptr %msg_lrpid, align 4
  %conv19 = sext i32 %25 to i64
  %call20 = call i64 @tswapal(i64 noundef %conv19)
  %26 = load ptr, ptr %target_md, align 8
  %msg_lrpid21 = getelementptr inbounds %struct.target_msqid_ds, ptr %26, i32 0, i32 8
  store i64 %call20, ptr %msg_lrpid21, align 8
  %27 = load ptr, ptr %target_md, align 8
  %28 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %27, i64 noundef %28, i64 noundef 128)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %29 = load i64, ptr %retval, align 8
  ret i64 %29
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_msginfo(i64 noundef %target_addr, ptr noundef %host_msginfo) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %host_msginfo.addr = alloca ptr, align 8
  %target_msginfo = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_msginfo, ptr %host_msginfo.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 32, i1 noundef zeroext false)
  store ptr %call, ptr %target_msginfo, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_msginfo, align 8
  %msgpool = getelementptr inbounds %struct.target_msginfo, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %host_msginfo.addr, align 8
  %msgpool1 = getelementptr inbounds %struct.msginfo, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %msgpool1, align 4
  call void @stl_le_p(ptr noundef %msgpool, i32 noundef %3)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %4 = load ptr, ptr %target_msginfo, align 8
  %msgmap = getelementptr inbounds %struct.target_msginfo, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %host_msginfo.addr, align 8
  %msgmap3 = getelementptr inbounds %struct.msginfo, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %msgmap3, align 4
  call void @stl_le_p(ptr noundef %msgmap, i32 noundef %6)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  br label %do.body5

do.body5:                                         ; preds = %do.end4
  %7 = load ptr, ptr %target_msginfo, align 8
  %msgmax = getelementptr inbounds %struct.target_msginfo, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %host_msginfo.addr, align 8
  %msgmax6 = getelementptr inbounds %struct.msginfo, ptr %8, i32 0, i32 2
  %9 = load i32, ptr %msgmax6, align 4
  call void @stl_le_p(ptr noundef %msgmax, i32 noundef %9)
  br label %do.end7

do.end7:                                          ; preds = %do.body5
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %10 = load ptr, ptr %target_msginfo, align 8
  %msgmnb = getelementptr inbounds %struct.target_msginfo, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %host_msginfo.addr, align 8
  %msgmnb9 = getelementptr inbounds %struct.msginfo, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %msgmnb9, align 4
  call void @stl_le_p(ptr noundef %msgmnb, i32 noundef %12)
  br label %do.end10

do.end10:                                         ; preds = %do.body8
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %13 = load ptr, ptr %target_msginfo, align 8
  %msgmni = getelementptr inbounds %struct.target_msginfo, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %host_msginfo.addr, align 8
  %msgmni12 = getelementptr inbounds %struct.msginfo, ptr %14, i32 0, i32 4
  %15 = load i32, ptr %msgmni12, align 4
  call void @stl_le_p(ptr noundef %msgmni, i32 noundef %15)
  br label %do.end13

do.end13:                                         ; preds = %do.body11
  br label %do.body14

do.body14:                                        ; preds = %do.end13
  %16 = load ptr, ptr %target_msginfo, align 8
  %msgssz = getelementptr inbounds %struct.target_msginfo, ptr %16, i32 0, i32 5
  %17 = load ptr, ptr %host_msginfo.addr, align 8
  %msgssz15 = getelementptr inbounds %struct.msginfo, ptr %17, i32 0, i32 5
  %18 = load i32, ptr %msgssz15, align 4
  call void @stl_le_p(ptr noundef %msgssz, i32 noundef %18)
  br label %do.end16

do.end16:                                         ; preds = %do.body14
  br label %do.body17

do.body17:                                        ; preds = %do.end16
  %19 = load ptr, ptr %target_msginfo, align 8
  %msgtql = getelementptr inbounds %struct.target_msginfo, ptr %19, i32 0, i32 6
  %20 = load ptr, ptr %host_msginfo.addr, align 8
  %msgtql18 = getelementptr inbounds %struct.msginfo, ptr %20, i32 0, i32 6
  %21 = load i32, ptr %msgtql18, align 4
  call void @stl_le_p(ptr noundef %msgtql, i32 noundef %21)
  br label %do.end19

do.end19:                                         ; preds = %do.body17
  br label %do.body20

do.body20:                                        ; preds = %do.end19
  %22 = load ptr, ptr %target_msginfo, align 8
  %msgseg = getelementptr inbounds %struct.target_msginfo, ptr %22, i32 0, i32 7
  %23 = load ptr, ptr %host_msginfo.addr, align 8
  %msgseg21 = getelementptr inbounds %struct.msginfo, ptr %23, i32 0, i32 7
  %24 = load i16, ptr %msgseg21, align 4
  call void @stw_le_p(ptr noundef %msgseg, i16 noundef zeroext %24)
  br label %do.end22

do.end22:                                         ; preds = %do.body20
  %25 = load ptr, ptr %target_msginfo, align 8
  %26 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %25, i64 noundef %26, i64 noundef 32)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end22, %if.then
  %27 = load i64, ptr %retval, align 8
  ret i64 %27
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_msgrcv(i32 noundef %msgid, ptr noundef %msgp, i64 noundef %sz, i64 noundef %msgtype, i32 noundef %flags) #0 {
entry:
  %msgid.addr = alloca i32, align 4
  %msgp.addr = alloca ptr, align 8
  %sz.addr = alloca i64, align 8
  %msgtype.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i32 %msgid, ptr %msgid.addr, align 4
  store ptr %msgp, ptr %msgp.addr, align 8
  store i64 %sz, ptr %sz.addr, align 8
  store i64 %msgtype, ptr %msgtype.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %msgid.addr, align 4
  %4 = load ptr, ptr %msgp.addr, align 8
  %5 = load i64, ptr %sz.addr, align 8
  %6 = load i64, ptr %msgtype.addr, align 8
  %7 = load i32, ptr %flags.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 70, i32 noundef %3, ptr noundef %4, i64 noundef %5, i64 noundef %6, i32 noundef %7)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_msgsnd(i32 noundef %msgid, ptr noundef %msgp, i64 noundef %sz, i32 noundef %flags) #0 {
entry:
  %msgid.addr = alloca i32, align 4
  %msgp.addr = alloca ptr, align 8
  %sz.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i32 %msgid, ptr %msgid.addr, align 4
  store ptr %msgp, ptr %msgp.addr, align 8
  store i64 %sz, ptr %sz.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load i32, ptr %msgid.addr, align 4
  %4 = load ptr, ptr %msgp.addr, align 8
  %5 = load i64, ptr %sz.addr, align 8
  %6 = load i32, ptr %flags.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 69, i32 noundef %3, ptr noundef %4, i64 noundef %5, i32 noundef %6)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @target_to_host_shmid_ds(ptr noundef %host_sd, i64 noundef %target_addr) #0 {
entry:
  %retval = alloca i64, align 8
  %host_sd.addr = alloca ptr, align 8
  %target_addr.addr = alloca i64, align 8
  %target_sd = alloca ptr, align 8
  store ptr %host_sd, ptr %host_sd.addr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 1, i64 noundef %0, i64 noundef 112, i1 noundef zeroext true)
  store ptr %call, ptr %target_sd, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %host_sd.addr, align 8
  %shm_perm = getelementptr inbounds %struct.shmid_ds, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %target_addr.addr, align 8
  %call1 = call i64 @target_to_host_ipc_perm(ptr noundef %shm_perm, i64 noundef %2)
  %tobool2 = icmp ne i64 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.end4
  %3 = load ptr, ptr %target_sd, align 8
  %shm_segsz = getelementptr inbounds %struct.target_shmid_ds, ptr %3, i32 0, i32 1
  %call5 = call i64 @ldq_le_p(ptr noundef %shm_segsz)
  %4 = load ptr, ptr %host_sd.addr, align 8
  %shm_segsz6 = getelementptr inbounds %struct.shmid_ds, ptr %4, i32 0, i32 1
  store i64 %call5, ptr %shm_segsz6, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body7

do.body7:                                         ; preds = %do.end
  %5 = load ptr, ptr %target_sd, align 8
  %shm_atime = getelementptr inbounds %struct.target_shmid_ds, ptr %5, i32 0, i32 2
  %call8 = call i64 @ldq_le_p(ptr noundef %shm_atime)
  %6 = load ptr, ptr %host_sd.addr, align 8
  %shm_atime9 = getelementptr inbounds %struct.shmid_ds, ptr %6, i32 0, i32 2
  store i64 %call8, ptr %shm_atime9, align 8
  br label %do.end10

do.end10:                                         ; preds = %do.body7
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %7 = load ptr, ptr %target_sd, align 8
  %shm_dtime = getelementptr inbounds %struct.target_shmid_ds, ptr %7, i32 0, i32 3
  %call12 = call i64 @ldq_le_p(ptr noundef %shm_dtime)
  %8 = load ptr, ptr %host_sd.addr, align 8
  %shm_dtime13 = getelementptr inbounds %struct.shmid_ds, ptr %8, i32 0, i32 3
  store i64 %call12, ptr %shm_dtime13, align 8
  br label %do.end14

do.end14:                                         ; preds = %do.body11
  br label %do.body15

do.body15:                                        ; preds = %do.end14
  %9 = load ptr, ptr %target_sd, align 8
  %shm_ctime = getelementptr inbounds %struct.target_shmid_ds, ptr %9, i32 0, i32 4
  %call16 = call i64 @ldq_le_p(ptr noundef %shm_ctime)
  %10 = load ptr, ptr %host_sd.addr, align 8
  %shm_ctime17 = getelementptr inbounds %struct.shmid_ds, ptr %10, i32 0, i32 4
  store i64 %call16, ptr %shm_ctime17, align 8
  br label %do.end18

do.end18:                                         ; preds = %do.body15
  br label %do.body19

do.body19:                                        ; preds = %do.end18
  %11 = load ptr, ptr %target_sd, align 8
  %shm_cpid = getelementptr inbounds %struct.target_shmid_ds, ptr %11, i32 0, i32 5
  %call20 = call i32 @ldl_le_p(ptr noundef %shm_cpid)
  %12 = load ptr, ptr %host_sd.addr, align 8
  %shm_cpid21 = getelementptr inbounds %struct.shmid_ds, ptr %12, i32 0, i32 5
  store i32 %call20, ptr %shm_cpid21, align 8
  br label %do.end22

do.end22:                                         ; preds = %do.body19
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  %13 = load ptr, ptr %target_sd, align 8
  %shm_lpid = getelementptr inbounds %struct.target_shmid_ds, ptr %13, i32 0, i32 6
  %call24 = call i32 @ldl_le_p(ptr noundef %shm_lpid)
  %14 = load ptr, ptr %host_sd.addr, align 8
  %shm_lpid25 = getelementptr inbounds %struct.shmid_ds, ptr %14, i32 0, i32 6
  store i32 %call24, ptr %shm_lpid25, align 4
  br label %do.end26

do.end26:                                         ; preds = %do.body23
  br label %do.body27

do.body27:                                        ; preds = %do.end26
  %15 = load ptr, ptr %target_sd, align 8
  %shm_nattch = getelementptr inbounds %struct.target_shmid_ds, ptr %15, i32 0, i32 7
  %call28 = call i64 @ldq_le_p(ptr noundef %shm_nattch)
  %16 = load ptr, ptr %host_sd.addr, align 8
  %shm_nattch29 = getelementptr inbounds %struct.shmid_ds, ptr %16, i32 0, i32 7
  store i64 %call28, ptr %shm_nattch29, align 8
  br label %do.end30

do.end30:                                         ; preds = %do.body27
  %17 = load ptr, ptr %target_sd, align 8
  %18 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %17, i64 noundef %18, i64 noundef 0)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end30, %if.then3, %if.then
  %19 = load i64, ptr %retval, align 8
  ret i64 %19
}

; Function Attrs: nounwind
declare i32 @shmctl(i32 noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_shmid_ds(i64 noundef %target_addr, ptr noundef %host_sd) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %host_sd.addr = alloca ptr, align 8
  %target_sd = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_sd, ptr %host_sd.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 112, i1 noundef zeroext false)
  store ptr %call, ptr %target_sd, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %target_addr.addr, align 8
  %2 = load ptr, ptr %host_sd.addr, align 8
  %shm_perm = getelementptr inbounds %struct.shmid_ds, ptr %2, i32 0, i32 0
  %call1 = call i64 @host_to_target_ipc_perm(i64 noundef %1, ptr noundef %shm_perm)
  %tobool2 = icmp ne i64 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i64 -14, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.end4
  %3 = load ptr, ptr %target_sd, align 8
  %shm_segsz = getelementptr inbounds %struct.target_shmid_ds, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %host_sd.addr, align 8
  %shm_segsz5 = getelementptr inbounds %struct.shmid_ds, ptr %4, i32 0, i32 1
  %5 = load i64, ptr %shm_segsz5, align 8
  call void @stq_le_p(ptr noundef %shm_segsz, i64 noundef %5)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body6

do.body6:                                         ; preds = %do.end
  %6 = load ptr, ptr %target_sd, align 8
  %shm_atime = getelementptr inbounds %struct.target_shmid_ds, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %host_sd.addr, align 8
  %shm_atime7 = getelementptr inbounds %struct.shmid_ds, ptr %7, i32 0, i32 2
  %8 = load i64, ptr %shm_atime7, align 8
  call void @stq_le_p(ptr noundef %shm_atime, i64 noundef %8)
  br label %do.end8

do.end8:                                          ; preds = %do.body6
  br label %do.body9

do.body9:                                         ; preds = %do.end8
  %9 = load ptr, ptr %target_sd, align 8
  %shm_dtime = getelementptr inbounds %struct.target_shmid_ds, ptr %9, i32 0, i32 3
  %10 = load ptr, ptr %host_sd.addr, align 8
  %shm_dtime10 = getelementptr inbounds %struct.shmid_ds, ptr %10, i32 0, i32 3
  %11 = load i64, ptr %shm_dtime10, align 8
  call void @stq_le_p(ptr noundef %shm_dtime, i64 noundef %11)
  br label %do.end11

do.end11:                                         ; preds = %do.body9
  br label %do.body12

do.body12:                                        ; preds = %do.end11
  %12 = load ptr, ptr %target_sd, align 8
  %shm_ctime = getelementptr inbounds %struct.target_shmid_ds, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %host_sd.addr, align 8
  %shm_ctime13 = getelementptr inbounds %struct.shmid_ds, ptr %13, i32 0, i32 4
  %14 = load i64, ptr %shm_ctime13, align 8
  call void @stq_le_p(ptr noundef %shm_ctime, i64 noundef %14)
  br label %do.end14

do.end14:                                         ; preds = %do.body12
  br label %do.body15

do.body15:                                        ; preds = %do.end14
  %15 = load ptr, ptr %target_sd, align 8
  %shm_cpid = getelementptr inbounds %struct.target_shmid_ds, ptr %15, i32 0, i32 5
  %16 = load ptr, ptr %host_sd.addr, align 8
  %shm_cpid16 = getelementptr inbounds %struct.shmid_ds, ptr %16, i32 0, i32 5
  %17 = load i32, ptr %shm_cpid16, align 8
  call void @stl_le_p(ptr noundef %shm_cpid, i32 noundef %17)
  br label %do.end17

do.end17:                                         ; preds = %do.body15
  br label %do.body18

do.body18:                                        ; preds = %do.end17
  %18 = load ptr, ptr %target_sd, align 8
  %shm_lpid = getelementptr inbounds %struct.target_shmid_ds, ptr %18, i32 0, i32 6
  %19 = load ptr, ptr %host_sd.addr, align 8
  %shm_lpid19 = getelementptr inbounds %struct.shmid_ds, ptr %19, i32 0, i32 6
  %20 = load i32, ptr %shm_lpid19, align 4
  call void @stl_le_p(ptr noundef %shm_lpid, i32 noundef %20)
  br label %do.end20

do.end20:                                         ; preds = %do.body18
  br label %do.body21

do.body21:                                        ; preds = %do.end20
  %21 = load ptr, ptr %target_sd, align 8
  %shm_nattch = getelementptr inbounds %struct.target_shmid_ds, ptr %21, i32 0, i32 7
  %22 = load ptr, ptr %host_sd.addr, align 8
  %shm_nattch22 = getelementptr inbounds %struct.shmid_ds, ptr %22, i32 0, i32 7
  %23 = load i64, ptr %shm_nattch22, align 8
  call void @stq_le_p(ptr noundef %shm_nattch, i64 noundef %23)
  br label %do.end23

do.end23:                                         ; preds = %do.body21
  %24 = load ptr, ptr %target_sd, align 8
  %25 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %24, i64 noundef %25, i64 noundef 112)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end23, %if.then3, %if.then
  %26 = load i64, ptr %retval, align 8
  ret i64 %26
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_shminfo(i64 noundef %target_addr, ptr noundef %host_shminfo) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %host_shminfo.addr = alloca ptr, align 8
  %target_shminfo = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_shminfo, ptr %host_shminfo.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 40, i1 noundef zeroext false)
  store ptr %call, ptr %target_shminfo, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_shminfo, align 8
  %shmmax = getelementptr inbounds %struct.target_shminfo, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %host_shminfo.addr, align 8
  %shmmax1 = getelementptr inbounds %struct.shminfo, ptr %2, i32 0, i32 0
  %3 = load i64, ptr %shmmax1, align 8
  call void @stq_le_p(ptr noundef %shmmax, i64 noundef %3)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %4 = load ptr, ptr %target_shminfo, align 8
  %shmmin = getelementptr inbounds %struct.target_shminfo, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %host_shminfo.addr, align 8
  %shmmin3 = getelementptr inbounds %struct.shminfo, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %shmmin3, align 8
  call void @stq_le_p(ptr noundef %shmmin, i64 noundef %6)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  br label %do.body5

do.body5:                                         ; preds = %do.end4
  %7 = load ptr, ptr %target_shminfo, align 8
  %shmmni = getelementptr inbounds %struct.target_shminfo, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %host_shminfo.addr, align 8
  %shmmni6 = getelementptr inbounds %struct.shminfo, ptr %8, i32 0, i32 2
  %9 = load i64, ptr %shmmni6, align 8
  call void @stq_le_p(ptr noundef %shmmni, i64 noundef %9)
  br label %do.end7

do.end7:                                          ; preds = %do.body5
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %10 = load ptr, ptr %target_shminfo, align 8
  %shmseg = getelementptr inbounds %struct.target_shminfo, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %host_shminfo.addr, align 8
  %shmseg9 = getelementptr inbounds %struct.shminfo, ptr %11, i32 0, i32 3
  %12 = load i64, ptr %shmseg9, align 8
  call void @stq_le_p(ptr noundef %shmseg, i64 noundef %12)
  br label %do.end10

do.end10:                                         ; preds = %do.body8
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %13 = load ptr, ptr %target_shminfo, align 8
  %shmall = getelementptr inbounds %struct.target_shminfo, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %host_shminfo.addr, align 8
  %shmall12 = getelementptr inbounds %struct.shminfo, ptr %14, i32 0, i32 4
  %15 = load i64, ptr %shmall12, align 8
  call void @stq_le_p(ptr noundef %shmall, i64 noundef %15)
  br label %do.end13

do.end13:                                         ; preds = %do.body11
  %16 = load ptr, ptr %target_shminfo, align 8
  %17 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %16, i64 noundef %17, i64 noundef 40)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end13, %if.then
  %18 = load i64, ptr %retval, align 8
  ret i64 %18
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @host_to_target_shm_info(i64 noundef %target_addr, ptr noundef %host_shm_info) #0 {
entry:
  %retval = alloca i64, align 8
  %target_addr.addr = alloca i64, align 8
  %host_shm_info.addr = alloca ptr, align 8
  %target_shm_info = alloca ptr, align 8
  store i64 %target_addr, ptr %target_addr.addr, align 8
  store ptr %host_shm_info, ptr %host_shm_info.addr, align 8
  %0 = load i64, ptr %target_addr.addr, align 8
  %call = call ptr @lock_user(i32 noundef 3, i64 noundef %0, i64 noundef 48, i1 noundef zeroext false)
  store ptr %call, ptr %target_shm_info, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load ptr, ptr %target_shm_info, align 8
  %used_ids = getelementptr inbounds %struct.target_shm_info, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %host_shm_info.addr, align 8
  %used_ids1 = getelementptr inbounds %struct.shm_info, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %used_ids1, align 8
  call void @stl_le_p(ptr noundef %used_ids, i32 noundef %3)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %4 = load ptr, ptr %target_shm_info, align 8
  %shm_tot = getelementptr inbounds %struct.target_shm_info, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %host_shm_info.addr, align 8
  %shm_tot3 = getelementptr inbounds %struct.shm_info, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %shm_tot3, align 8
  call void @stq_le_p(ptr noundef %shm_tot, i64 noundef %6)
  br label %do.end4

do.end4:                                          ; preds = %do.body2
  br label %do.body5

do.body5:                                         ; preds = %do.end4
  %7 = load ptr, ptr %target_shm_info, align 8
  %shm_rss = getelementptr inbounds %struct.target_shm_info, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %host_shm_info.addr, align 8
  %shm_rss6 = getelementptr inbounds %struct.shm_info, ptr %8, i32 0, i32 2
  %9 = load i64, ptr %shm_rss6, align 8
  call void @stq_le_p(ptr noundef %shm_rss, i64 noundef %9)
  br label %do.end7

do.end7:                                          ; preds = %do.body5
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %10 = load ptr, ptr %target_shm_info, align 8
  %shm_swp = getelementptr inbounds %struct.target_shm_info, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %host_shm_info.addr, align 8
  %shm_swp9 = getelementptr inbounds %struct.shm_info, ptr %11, i32 0, i32 3
  %12 = load i64, ptr %shm_swp9, align 8
  call void @stq_le_p(ptr noundef %shm_swp, i64 noundef %12)
  br label %do.end10

do.end10:                                         ; preds = %do.body8
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %13 = load ptr, ptr %target_shm_info, align 8
  %swap_attempts = getelementptr inbounds %struct.target_shm_info, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %host_shm_info.addr, align 8
  %swap_attempts12 = getelementptr inbounds %struct.shm_info, ptr %14, i32 0, i32 4
  %15 = load i64, ptr %swap_attempts12, align 8
  call void @stq_le_p(ptr noundef %swap_attempts, i64 noundef %15)
  br label %do.end13

do.end13:                                         ; preds = %do.body11
  br label %do.body14

do.body14:                                        ; preds = %do.end13
  %16 = load ptr, ptr %target_shm_info, align 8
  %swap_successes = getelementptr inbounds %struct.target_shm_info, ptr %16, i32 0, i32 5
  %17 = load ptr, ptr %host_shm_info.addr, align 8
  %swap_successes15 = getelementptr inbounds %struct.shm_info, ptr %17, i32 0, i32 5
  %18 = load i64, ptr %swap_successes15, align 8
  call void @stq_le_p(ptr noundef %swap_successes, i64 noundef %18)
  br label %do.end16

do.end16:                                         ; preds = %do.body14
  %19 = load ptr, ptr %target_shm_info, align 8
  %20 = load i64, ptr %target_addr.addr, align 8
  call void @unlock_user(ptr noundef %19, i64 noundef %20, i64 noundef 48)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end16, %if.then
  %21 = load i64, ptr %retval, align 8
  ret i64 %21
}

declare void @init_task_state(ptr noundef) #3

declare void @tb_flush(ptr noundef) #3

declare ptr @cpu_copy(ptr noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal void @cpu_clone_regs_child(ptr noundef %env, i64 noundef %newsp, i32 noundef %flags) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %newsp.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store ptr %env, ptr %env.addr, align 8
  store i64 %newsp, ptr %newsp.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i64, ptr %newsp.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %newsp.addr, align 8
  %2 = load ptr, ptr %env.addr, align 8
  %gpr = getelementptr inbounds %struct.CPUArchState, ptr %2, i32 0, i32 0
  %arrayidx = getelementptr [32 x i64], ptr %gpr, i64 0, i64 2
  store i64 %1, ptr %arrayidx, align 16
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %env.addr, align 8
  %gpr1 = getelementptr inbounds %struct.CPUArchState, ptr %3, i32 0, i32 0
  %arrayidx2 = getelementptr [32 x i64], ptr %gpr1, i64 0, i64 10
  store i64 0, ptr %arrayidx2, align 16
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @cpu_clone_regs_parent(ptr noundef %env, i32 noundef %flags) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store ptr %env, ptr %env.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @cpu_set_tls(ptr noundef %env, i64 noundef %newtls) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %newtls.addr = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i64 %newtls, ptr %newtls.addr, align 8
  %0 = load i64, ptr %newtls.addr, align 8
  %1 = load ptr, ptr %env.addr, align 8
  %gpr = getelementptr inbounds %struct.CPUArchState, ptr %1, i32 0, i32 0
  %arrayidx = getelementptr [32 x i64], ptr %gpr, i64 0, i64 4
  store i64 %0, ptr %arrayidx, align 16
  ret void
}

; Function Attrs: nounwind
declare i32 @pthread_mutex_init(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @pthread_cond_init(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @pthread_attr_init(ptr noundef) #2

; Function Attrs: nounwind
declare i32 @pthread_attr_setstacksize(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i32 @pthread_attr_setdetachstate(ptr noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i32 @sigfillset(ptr noundef) #2

; Function Attrs: nounwind
declare i32 @sigprocmask(i32 noundef, ptr noundef, ptr noundef) #2

declare i64 @qemu_guest_random_seed_thread_part1() #3

; Function Attrs: nounwind
declare i32 @pthread_create(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @clone_func(ptr noundef %arg) #0 {
entry:
  %arg.addr = alloca ptr, align 8
  %info = alloca ptr, align 8
  %env = alloca ptr, align 8
  %cpu = alloca ptr, align 8
  %ts = alloca ptr, align 8
  %__gaddr = alloca i64, align 8
  %__hptr = alloca ptr, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__gaddr11 = alloca i64, align 8
  %__hptr13 = alloca ptr, align 8
  %__ret14 = alloca i64, align 8
  %tmp23 = alloca i64, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  store ptr %0, ptr %info, align 8
  call void @rcu_register_thread()
  call void @tcg_register_thread()
  %1 = load ptr, ptr %info, align 8
  %env1 = getelementptr inbounds %struct.new_thread_info, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %env1, align 8
  store ptr %2, ptr %env, align 8
  %3 = load ptr, ptr %env, align 8
  %call = call ptr @env_cpu(ptr noundef %3)
  store ptr %call, ptr %cpu, align 8
  %4 = load ptr, ptr %cpu, align 8
  %5 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  store ptr %4, ptr %5, align 8
  %6 = load ptr, ptr %cpu, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %6, i32 0, i32 39
  %7 = load ptr, ptr %opaque, align 16
  store ptr %7, ptr %ts, align 8
  %call2 = call i32 @sys_gettid()
  %8 = load ptr, ptr %info, align 8
  %tid = getelementptr inbounds %struct.new_thread_info, ptr %8, i32 0, i32 4
  store i32 %call2, ptr %tid, align 8
  %9 = load ptr, ptr %ts, align 8
  call void @task_settid(ptr noundef %9)
  %10 = load ptr, ptr %info, align 8
  %child_tidptr = getelementptr inbounds %struct.new_thread_info, ptr %10, i32 0, i32 5
  %11 = load i64, ptr %child_tidptr, align 8
  %tobool = icmp ne i64 %11, 0
  br i1 %tobool, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %12 = load ptr, ptr %info, align 8
  %child_tidptr3 = getelementptr inbounds %struct.new_thread_info, ptr %12, i32 0, i32 5
  %13 = load i64, ptr %child_tidptr3, align 8
  store i64 %13, ptr %__gaddr, align 8
  store i64 0, ptr %__ret, align 8
  %14 = load i64, ptr %__gaddr, align 8
  %call4 = call ptr @lock_user(i32 noundef 3, i64 noundef %14, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call4, ptr %__hptr, align 8
  %tobool5 = icmp ne ptr %call4, null
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then6
  %15 = load ptr, ptr %__hptr, align 8
  %16 = load ptr, ptr %info, align 8
  %tid7 = getelementptr inbounds %struct.new_thread_info, ptr %16, i32 0, i32 4
  %17 = load i32, ptr %tid7, align 8
  call void @stl_le_p(ptr noundef %15, i32 noundef %17)
  br label %do.end

do.end:                                           ; preds = %do.body
  %18 = load ptr, ptr %__hptr, align 8
  %19 = load i64, ptr %__gaddr, align 8
  call void @unlock_user(ptr noundef %18, i64 noundef %19, i64 noundef 4)
  br label %if.end

if.else:                                          ; preds = %if.then
  store i64 -14, ptr %__ret, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %do.end
  %20 = load i64, ptr %__ret, align 8
  store i64 %20, ptr %tmp, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.end, %entry
  %21 = load ptr, ptr %info, align 8
  %parent_tidptr = getelementptr inbounds %struct.new_thread_info, ptr %21, i32 0, i32 6
  %22 = load i64, ptr %parent_tidptr, align 8
  %tobool9 = icmp ne i64 %22, 0
  br i1 %tobool9, label %if.then10, label %if.end24

if.then10:                                        ; preds = %if.end8
  %23 = load ptr, ptr %info, align 8
  %parent_tidptr12 = getelementptr inbounds %struct.new_thread_info, ptr %23, i32 0, i32 6
  %24 = load i64, ptr %parent_tidptr12, align 8
  store i64 %24, ptr %__gaddr11, align 8
  store i64 0, ptr %__ret14, align 8
  %25 = load i64, ptr %__gaddr11, align 8
  %call15 = call ptr @lock_user(i32 noundef 3, i64 noundef %25, i64 noundef 4, i1 noundef zeroext false)
  store ptr %call15, ptr %__hptr13, align 8
  %tobool16 = icmp ne ptr %call15, null
  br i1 %tobool16, label %if.then17, label %if.else21

if.then17:                                        ; preds = %if.then10
  br label %do.body18

do.body18:                                        ; preds = %if.then17
  %26 = load ptr, ptr %__hptr13, align 8
  %27 = load ptr, ptr %info, align 8
  %tid19 = getelementptr inbounds %struct.new_thread_info, ptr %27, i32 0, i32 4
  %28 = load i32, ptr %tid19, align 8
  call void @stl_le_p(ptr noundef %26, i32 noundef %28)
  br label %do.end20

do.end20:                                         ; preds = %do.body18
  %29 = load ptr, ptr %__hptr13, align 8
  %30 = load i64, ptr %__gaddr11, align 8
  call void @unlock_user(ptr noundef %29, i64 noundef %30, i64 noundef 4)
  br label %if.end22

if.else21:                                        ; preds = %if.then10
  store i64 -14, ptr %__ret14, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else21, %do.end20
  %31 = load i64, ptr %__ret14, align 8
  store i64 %31, ptr %tmp23, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.end22, %if.end8
  %32 = load ptr, ptr %cpu, align 8
  %random_seed = getelementptr inbounds %struct.CPUState, ptr %32, i32 0, i32 23
  %33 = load i64, ptr %random_seed, align 16
  call void @qemu_guest_random_seed_thread_part2(i64 noundef %33)
  %34 = load ptr, ptr %info, align 8
  %sigmask = getelementptr inbounds %struct.new_thread_info, ptr %34, i32 0, i32 7
  %call25 = call i32 @sigprocmask(i32 noundef 2, ptr noundef %sigmask, ptr noundef null) #14
  %35 = load ptr, ptr %info, align 8
  %mutex = getelementptr inbounds %struct.new_thread_info, ptr %35, i32 0, i32 1
  %call26 = call i32 @pthread_mutex_lock(ptr noundef %mutex) #14
  %36 = load ptr, ptr %info, align 8
  %cond = getelementptr inbounds %struct.new_thread_info, ptr %36, i32 0, i32 2
  %call27 = call i32 @pthread_cond_broadcast(ptr noundef %cond) #14
  %37 = load ptr, ptr %info, align 8
  %mutex28 = getelementptr inbounds %struct.new_thread_info, ptr %37, i32 0, i32 1
  %call29 = call i32 @pthread_mutex_unlock(ptr noundef %mutex28) #14
  %call30 = call i32 @pthread_mutex_lock(ptr noundef @clone_lock) #14
  %call31 = call i32 @pthread_mutex_unlock(ptr noundef @clone_lock) #14
  %38 = load ptr, ptr %env, align 8
  call void @cpu_loop(ptr noundef %38) #19
  unreachable
}

; Function Attrs: nounwind
declare i32 @pthread_attr_destroy(ptr noundef) #2

declare i32 @pthread_cond_wait(ptr noundef, ptr noundef) #3

; Function Attrs: nounwind
declare i32 @pthread_cond_destroy(ptr noundef) #2

; Function Attrs: nounwind
declare i32 @pthread_mutex_destroy(ptr noundef) #2

declare void @fork_start() #3

; Function Attrs: nounwind
declare i32 @fork() #2

declare void @fork_end(i32 noundef) #3

declare i32 @fcntl64(i32 noundef, i32 noundef, ...) #3

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @cpu_in_exclusive_context(ptr noundef %cpu) #0 {
entry:
  %cpu.addr = alloca ptr, align 8
  store ptr %cpu, ptr %cpu.addr, align 8
  %0 = load ptr, ptr %cpu.addr, align 8
  %exclusive_context_count = getelementptr inbounds %struct.CPUState, ptr %0, i32 0, i32 17
  %1 = load i32, ptr %exclusive_context_count, align 16
  %tobool = icmp ne i32 %1, 0
  ret i1 %tobool
}

declare void @rcu_register_thread() #3

declare void @tcg_register_thread() #3

declare void @task_settid(ptr noundef) #3

declare void @qemu_guest_random_seed_thread_part2(i64 noundef) #3

; Function Attrs: nounwind
declare i32 @pthread_cond_broadcast(ptr noundef) #2

; Function Attrs: noreturn
declare void @cpu_loop(ptr noundef) #11

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @sys_getdents64(i32 noundef %fd, ptr noundef %dirp, i32 noundef %count) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %dirp.addr = alloca ptr, align 8
  %count.addr = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %dirp, ptr %dirp.addr, align 8
  store i32 %count, ptr %count.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %1 = load ptr, ptr %dirp.addr, align 8
  %2 = load i32, ptr %count.addr, align 4
  %call = call i64 (i64, ...) @syscall(i64 noundef 217, i32 noundef %0, ptr noundef %1, i32 noundef %2) #14
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_ppoll(ptr noundef %ufds, i32 noundef %nfds, ptr noundef %tsp, ptr noundef %sigmask, i64 noundef %sigsetsize) #0 {
entry:
  %ufds.addr = alloca ptr, align 8
  %nfds.addr = alloca i32, align 4
  %tsp.addr = alloca ptr, align 8
  %sigmask.addr = alloca ptr, align 8
  %sigsetsize.addr = alloca i64, align 8
  store ptr %ufds, ptr %ufds.addr, align 8
  store i32 %nfds, ptr %nfds.addr, align 4
  store ptr %tsp, ptr %tsp.addr, align 8
  store ptr %sigmask, ptr %sigmask.addr, align 8
  store i64 %sigsetsize, ptr %sigsetsize.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load ptr, ptr %ufds.addr, align 8
  %4 = load i32, ptr %nfds.addr, align 4
  %5 = load ptr, ptr %tsp.addr, align 8
  %6 = load ptr, ptr %sigmask.addr, align 8
  %7 = load i64, ptr %sigsetsize.addr, align 8
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 271, ptr noundef %3, i32 noundef %4, ptr noundef %5, ptr noundef %6, i64 noundef %7)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @prctl(i32 noundef, ...) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_prctl_inval0(ptr noundef %env) #0 {
entry:
  %env.addr = alloca ptr, align 8
  store ptr %env, ptr %env.addr, align 8
  ret i64 -22
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @do_prctl_inval1(ptr noundef %env, i64 noundef %arg2) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %arg2.addr = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i64 %arg2, ptr %arg2.addr, align 8
  ret i64 -22
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @do_safe_futex(ptr noundef %uaddr, i32 noundef %op, i32 noundef %val, ptr noundef %timeout, ptr noundef %uaddr2, i32 noundef %val3) #0 {
entry:
  %uaddr.addr = alloca ptr, align 8
  %op.addr = alloca i32, align 4
  %val.addr = alloca i32, align 4
  %timeout.addr = alloca ptr, align 8
  %uaddr2.addr = alloca ptr, align 8
  %val3.addr = alloca i32, align 4
  store ptr %uaddr, ptr %uaddr.addr, align 8
  store i32 %op, ptr %op.addr, align 4
  store i32 %val, ptr %val.addr, align 4
  store ptr %timeout, ptr %timeout.addr, align 8
  store ptr %uaddr2, ptr %uaddr2.addr, align 8
  store i32 %val3, ptr %val3.addr, align 4
  %0 = load ptr, ptr %uaddr.addr, align 8
  %1 = load i32, ptr %op.addr, align 4
  %2 = load i32, ptr %val.addr, align 4
  %3 = load ptr, ptr %timeout.addr, align 8
  %4 = load ptr, ptr %uaddr2.addr, align 8
  %5 = load i32, ptr %val3.addr, align 4
  %call = call i32 @safe_futex(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  %conv = sext i32 %call to i64
  %call1 = call i64 @get_errno(i64 noundef %conv)
  %conv2 = trunc i64 %call1 to i32
  ret i32 %conv2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @safe_futex(ptr noundef %uaddr, i32 noundef %op, i32 noundef %val, ptr noundef %timeout, ptr noundef %uaddr2, i32 noundef %val3) #0 {
entry:
  %uaddr.addr = alloca ptr, align 8
  %op.addr = alloca i32, align 4
  %val.addr = alloca i32, align 4
  %timeout.addr = alloca ptr, align 8
  %uaddr2.addr = alloca ptr, align 8
  %val3.addr = alloca i32, align 4
  store ptr %uaddr, ptr %uaddr.addr, align 8
  store i32 %op, ptr %op.addr, align 4
  store i32 %val, ptr %val.addr, align 4
  store ptr %timeout, ptr %timeout.addr, align 8
  store ptr %uaddr2, ptr %uaddr2.addr, align 8
  store i32 %val3, ptr %val3.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @thread_cpu)
  %1 = load ptr, ptr %0, align 8
  %opaque = getelementptr inbounds %struct.CPUState, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %opaque, align 16
  %signal_pending = getelementptr inbounds %struct.TaskState, ptr %2, i32 0, i32 14
  %3 = load ptr, ptr %uaddr.addr, align 8
  %4 = load i32, ptr %op.addr, align 4
  %5 = load i32, ptr %val.addr, align 4
  %6 = load ptr, ptr %timeout.addr, align 8
  %7 = load ptr, ptr %uaddr2.addr, align 8
  %8 = load i32, ptr %val3.addr, align 4
  %call = call i64 (ptr, i64, ...) @safe_syscall_base(ptr noundef %signal_pending, i64 noundef 202, ptr noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6, ptr noundef %7, i32 noundef %8)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind
declare i32 @signalfd(i32 noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @cpu_set_valid(i64 noundef %arg3, i64 noundef %arg4) #0 {
entry:
  %retval = alloca i32, align 4
  %arg3.addr = alloca i64, align 8
  %arg4.addr = alloca i64, align 8
  %ret = alloca i32, align 4
  %i = alloca i32, align 4
  %tmp = alloca i32, align 4
  %host_mask_size = alloca i64, align 8
  %target_mask_size = alloca i64, align 8
  %host_mask = alloca ptr, align 8
  store i64 %arg3, ptr %arg3.addr, align 8
  store i64 %arg4, ptr %arg4.addr, align 8
  store i32 64, ptr %tmp, align 4
  %0 = load i64, ptr %arg3.addr, align 8
  %1 = load i32, ptr %tmp, align 4
  %conv = sext i32 %1 to i64
  %add = add i64 %0, %conv
  %sub = sub i64 %add, 1
  %2 = load i32, ptr %tmp, align 4
  %conv1 = sext i32 %2 to i64
  %div = sdiv i64 %sub, %conv1
  %mul = mul i64 %div, 8
  store i64 %mul, ptr %target_mask_size, align 8
  %3 = load i64, ptr %target_mask_size, align 8
  %add2 = add i64 %3, 7
  %and = and i64 %add2, -8
  store i64 %and, ptr %host_mask_size, align 8
  %4 = load i64, ptr %host_mask_size, align 8
  %5 = alloca i8, i64 %4, align 16
  store ptr %5, ptr %host_mask, align 8
  %6 = load ptr, ptr %host_mask, align 8
  %7 = load i64, ptr %host_mask_size, align 8
  %8 = load i64, ptr %arg4.addr, align 8
  %9 = load i64, ptr %target_mask_size, align 8
  %call = call i32 @target_to_host_cpu_mask(ptr noundef %6, i64 noundef %7, i64 noundef %8, i64 noundef %9)
  store i32 %call, ptr %ret, align 4
  %10 = load i32, ptr %ret, align 4
  %cmp = icmp ne i32 %10, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load i32, ptr %ret, align 4
  store i32 %11, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %12 = load i32, ptr %i, align 4
  %conv4 = sext i32 %12 to i64
  %13 = load i64, ptr %host_mask_size, align 8
  %div5 = udiv i64 %13, 8
  %cmp6 = icmp ult i64 %conv4, %div5
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load ptr, ptr %host_mask, align 8
  %15 = load i32, ptr %i, align 4
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr i64, ptr %14, i64 %idxprom
  %16 = load i64, ptr %arrayidx, align 8
  %cmp8 = icmp ne i64 %16, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %for.body
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end11
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !60

for.end:                                          ; preds = %for.cond
  store i32 -22, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then10, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @risc_hwprobe_fill_pairs(ptr noundef %env, ptr noundef %pair, i64 noundef %pair_count) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %pair.addr = alloca ptr, align 8
  %pair_count.addr = alloca i64, align 8
  %cfg = alloca ptr, align 8
  %key = alloca i64, align 8
  %value = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store ptr %pair, ptr %pair.addr, align 8
  store i64 %pair_count, ptr %pair_count.addr, align 8
  %0 = load ptr, ptr %env.addr, align 8
  %call = call ptr @riscv_cpu_cfg(ptr noundef %0)
  store ptr %call, ptr %cfg, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %pair_count.addr, align 8
  %cmp = icmp ugt i64 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.body
  %2 = load ptr, ptr %pair.addr, align 8
  %value1 = getelementptr inbounds %struct.riscv_hwprobe, ptr %2, i32 0, i32 1
  call void @stq_le_p(ptr noundef %value1, i64 noundef 0)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %3 = load ptr, ptr %pair.addr, align 8
  %key3 = getelementptr inbounds %struct.riscv_hwprobe, ptr %3, i32 0, i32 0
  %call4 = call i64 @ldq_le_p(ptr noundef %key3)
  store i64 %call4, ptr %key, align 8
  br label %do.end5

do.end5:                                          ; preds = %do.body2
  %4 = load i64, ptr %key, align 8
  switch i64 %4, label %sw.default [
    i64 0, label %sw.bb
    i64 1, label %sw.bb9
    i64 2, label %sw.bb13
    i64 3, label %sw.bb17
    i64 4, label %sw.bb27
    i64 5, label %sw.bb63
    i64 6, label %sw.bb67
  ]

sw.bb:                                            ; preds = %do.end5
  br label %do.body6

do.body6:                                         ; preds = %sw.bb
  %5 = load ptr, ptr %pair.addr, align 8
  %value7 = getelementptr inbounds %struct.riscv_hwprobe, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %cfg, align 8
  %mvendorid = getelementptr inbounds %struct.RISCVCPUConfig, ptr %6, i32 0, i32 78
  %7 = load i32, ptr %mvendorid, align 8
  %conv = zext i32 %7 to i64
  call void @stq_le_p(ptr noundef %value7, i64 noundef %conv)
  br label %do.end8

do.end8:                                          ; preds = %do.body6
  br label %sw.epilog

sw.bb9:                                           ; preds = %do.end5
  br label %do.body10

do.body10:                                        ; preds = %sw.bb9
  %8 = load ptr, ptr %pair.addr, align 8
  %value11 = getelementptr inbounds %struct.riscv_hwprobe, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %cfg, align 8
  %marchid = getelementptr inbounds %struct.RISCVCPUConfig, ptr %9, i32 0, i32 79
  %10 = load i64, ptr %marchid, align 8
  call void @stq_le_p(ptr noundef %value11, i64 noundef %10)
  br label %do.end12

do.end12:                                         ; preds = %do.body10
  br label %sw.epilog

sw.bb13:                                          ; preds = %do.end5
  br label %do.body14

do.body14:                                        ; preds = %sw.bb13
  %11 = load ptr, ptr %pair.addr, align 8
  %value15 = getelementptr inbounds %struct.riscv_hwprobe, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %cfg, align 8
  %mimpid = getelementptr inbounds %struct.RISCVCPUConfig, ptr %12, i32 0, i32 80
  %13 = load i64, ptr %mimpid, align 8
  call void @stq_le_p(ptr noundef %value15, i64 noundef %13)
  br label %do.end16

do.end16:                                         ; preds = %do.body14
  br label %sw.epilog

sw.bb17:                                          ; preds = %do.end5
  %14 = load ptr, ptr %env.addr, align 8
  %call18 = call i32 @riscv_has_ext(ptr noundef %14, i64 noundef 256)
  %tobool = icmp ne i32 %call18, 0
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %sw.bb17
  %15 = load ptr, ptr %env.addr, align 8
  %call19 = call i32 @riscv_has_ext(ptr noundef %15, i64 noundef 4096)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %16 = load ptr, ptr %env.addr, align 8
  %call21 = call i32 @riscv_has_ext(ptr noundef %16, i64 noundef 1)
  %tobool22 = icmp ne i32 %call21, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %sw.bb17
  %17 = phi i1 [ false, %land.lhs.true ], [ false, %sw.bb17 ], [ %tobool22, %land.rhs ]
  %cond = select i1 %17, i32 1, i32 0
  %conv23 = sext i32 %cond to i64
  store i64 %conv23, ptr %value, align 8
  br label %do.body24

do.body24:                                        ; preds = %land.end
  %18 = load ptr, ptr %pair.addr, align 8
  %value25 = getelementptr inbounds %struct.riscv_hwprobe, ptr %18, i32 0, i32 1
  %19 = load i64, ptr %value, align 8
  call void @stq_le_p(ptr noundef %value25, i64 noundef %19)
  br label %do.end26

do.end26:                                         ; preds = %do.body24
  br label %sw.epilog

sw.bb27:                                          ; preds = %do.end5
  %20 = load ptr, ptr %env.addr, align 8
  %call28 = call i32 @riscv_has_ext(ptr noundef %20, i64 noundef 32)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %land.rhs30, label %land.end33

land.rhs30:                                       ; preds = %sw.bb27
  %21 = load ptr, ptr %env.addr, align 8
  %call31 = call i32 @riscv_has_ext(ptr noundef %21, i64 noundef 8)
  %tobool32 = icmp ne i32 %call31, 0
  br label %land.end33

land.end33:                                       ; preds = %land.rhs30, %sw.bb27
  %22 = phi i1 [ false, %sw.bb27 ], [ %tobool32, %land.rhs30 ]
  %cond34 = select i1 %22, i32 1, i32 0
  %conv35 = sext i32 %cond34 to i64
  store i64 %conv35, ptr %value, align 8
  %23 = load ptr, ptr %env.addr, align 8
  %call36 = call i32 @riscv_has_ext(ptr noundef %23, i64 noundef 4)
  %tobool37 = icmp ne i32 %call36, 0
  %cond38 = select i1 %tobool37, i32 2, i32 0
  %conv39 = sext i32 %cond38 to i64
  %24 = load i64, ptr %value, align 8
  %or = or i64 %24, %conv39
  store i64 %or, ptr %value, align 8
  %25 = load ptr, ptr %env.addr, align 8
  %call40 = call i32 @riscv_has_ext(ptr noundef %25, i64 noundef 2097152)
  %tobool41 = icmp ne i32 %call40, 0
  %cond42 = select i1 %tobool41, i32 4, i32 0
  %conv43 = sext i32 %cond42 to i64
  %26 = load i64, ptr %value, align 8
  %or44 = or i64 %26, %conv43
  store i64 %or44, ptr %value, align 8
  %27 = load ptr, ptr %cfg, align 8
  %ext_zba = getelementptr inbounds %struct.RISCVCPUConfig, ptr %27, i32 0, i32 0
  %28 = load i8, ptr %ext_zba, align 8
  %tobool45 = trunc i8 %28 to i1
  %cond47 = select i1 %tobool45, i32 8, i32 0
  %conv48 = sext i32 %cond47 to i64
  %29 = load i64, ptr %value, align 8
  %or49 = or i64 %29, %conv48
  store i64 %or49, ptr %value, align 8
  %30 = load ptr, ptr %cfg, align 8
  %ext_zbb = getelementptr inbounds %struct.RISCVCPUConfig, ptr %30, i32 0, i32 1
  %31 = load i8, ptr %ext_zbb, align 1
  %tobool50 = trunc i8 %31 to i1
  %cond52 = select i1 %tobool50, i32 16, i32 0
  %conv53 = sext i32 %cond52 to i64
  %32 = load i64, ptr %value, align 8
  %or54 = or i64 %32, %conv53
  store i64 %or54, ptr %value, align 8
  %33 = load ptr, ptr %cfg, align 8
  %ext_zbs = getelementptr inbounds %struct.RISCVCPUConfig, ptr %33, i32 0, i32 6
  %34 = load i8, ptr %ext_zbs, align 2
  %tobool55 = trunc i8 %34 to i1
  %cond57 = select i1 %tobool55, i32 32, i32 0
  %conv58 = sext i32 %cond57 to i64
  %35 = load i64, ptr %value, align 8
  %or59 = or i64 %35, %conv58
  store i64 %or59, ptr %value, align 8
  br label %do.body60

do.body60:                                        ; preds = %land.end33
  %36 = load ptr, ptr %pair.addr, align 8
  %value61 = getelementptr inbounds %struct.riscv_hwprobe, ptr %36, i32 0, i32 1
  %37 = load i64, ptr %value, align 8
  call void @stq_le_p(ptr noundef %value61, i64 noundef %37)
  br label %do.end62

do.end62:                                         ; preds = %do.body60
  br label %sw.epilog

sw.bb63:                                          ; preds = %do.end5
  br label %do.body64

do.body64:                                        ; preds = %sw.bb63
  %38 = load ptr, ptr %pair.addr, align 8
  %value65 = getelementptr inbounds %struct.riscv_hwprobe, ptr %38, i32 0, i32 1
  call void @stq_le_p(ptr noundef %value65, i64 noundef 3)
  br label %do.end66

do.end66:                                         ; preds = %do.body64
  br label %sw.epilog

sw.bb67:                                          ; preds = %do.end5
  %39 = load ptr, ptr %cfg, align 8
  %ext_zicboz = getelementptr inbounds %struct.RISCVCPUConfig, ptr %39, i32 0, i32 28
  %40 = load i8, ptr %ext_zicboz, align 4
  %tobool68 = trunc i8 %40 to i1
  br i1 %tobool68, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb67
  %41 = load ptr, ptr %cfg, align 8
  %cboz_blocksize = getelementptr inbounds %struct.RISCVCPUConfig, ptr %41, i32 0, i32 101
  %42 = load i16, ptr %cboz_blocksize, align 2
  %conv70 = zext i16 %42 to i32
  br label %cond.end

cond.false:                                       ; preds = %sw.bb67
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond71 = phi i32 [ %conv70, %cond.true ], [ 0, %cond.false ]
  %conv72 = sext i32 %cond71 to i64
  store i64 %conv72, ptr %value, align 8
  br label %do.body73

do.body73:                                        ; preds = %cond.end
  %43 = load ptr, ptr %pair.addr, align 8
  %value74 = getelementptr inbounds %struct.riscv_hwprobe, ptr %43, i32 0, i32 1
  %44 = load i64, ptr %value, align 8
  call void @stq_le_p(ptr noundef %value74, i64 noundef %44)
  br label %do.end75

do.end75:                                         ; preds = %do.body73
  br label %sw.epilog

sw.default:                                       ; preds = %do.end5
  br label %do.body76

do.body76:                                        ; preds = %sw.default
  %45 = load ptr, ptr %pair.addr, align 8
  %key77 = getelementptr inbounds %struct.riscv_hwprobe, ptr %45, i32 0, i32 0
  call void @stq_le_p(ptr noundef %key77, i64 noundef -1)
  br label %do.end78

do.end78:                                         ; preds = %do.body76
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end78, %do.end75, %do.end66, %do.end62, %do.end26, %do.end16, %do.end12, %do.end8
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %46 = load i64, ptr %pair_count.addr, align 8
  %dec = add i64 %46, -1
  store i64 %dec, ptr %pair_count.addr, align 8
  %47 = load ptr, ptr %pair.addr, align 8
  %incdec.ptr = getelementptr %struct.riscv_hwprobe, ptr %47, i32 1
  store ptr %incdec.ptr, ptr %pair.addr, align 8
  br label %for.cond, !llvm.loop !61

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @riscv_has_ext(ptr noundef %env, i64 noundef %ext) #0 {
entry:
  %env.addr = alloca ptr, align 8
  %ext.addr = alloca i64, align 8
  store ptr %env, ptr %env.addr, align 8
  store i64 %ext, ptr %ext.addr, align 8
  %0 = load ptr, ptr %env.addr, align 8
  %misa_ext = getelementptr inbounds %struct.CPUArchState, ptr %0, i32 0, i32 23
  %1 = load i32, ptr %misa_ext, align 8
  %conv = zext i32 %1 to i64
  %2 = load i64, ptr %ext.addr, align 8
  %and = and i64 %conv, %2
  %cmp = icmp ne i64 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare void @qemu_plugin_vcpu_syscall_ret(ptr noundef, i64 noundef, i64 noundef) #3

attributes #0 = { nounwind sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #7 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #8 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { allocsize(0,1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #11 = { noreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { allocsize(1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { nounwind willreturn memory(none) }
attributes #14 = { nounwind }
attributes #15 = { noreturn nounwind }
attributes #16 = { allocsize(0) }
attributes #17 = { allocsize(0,1) }
attributes #18 = { nounwind willreturn memory(read) }
attributes #19 = { noreturn }
attributes #20 = { allocsize(1) }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = !{i64 2153888625}
!19 = !{i64 2153888729}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
