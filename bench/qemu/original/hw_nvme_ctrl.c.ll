target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.TypeInfo = type { ptr, ptr, i64, i64, ptr, ptr, ptr, i8, i64, ptr, ptr, ptr, ptr }
%struct.InterfaceInfo = type { ptr }
%struct.Property = type { ptr, ptr, i64, i8, i64, i8, %union.anon.33, i32, ptr, i32, ptr }
%union.anon.33 = type { i64 }
%struct.VMStateDescription = type { ptr, i8, i8, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.MemoryRegionOps = type { ptr, ptr, ptr, ptr, i32, %struct.anon.34, %struct.anon.35 }
%struct.anon.34 = type { i32, i32, i8, ptr }
%struct.anon.35 = type { i32, i32, i8 }
%struct.AIOCBInfo = type { ptr, i64 }
%struct.anon.45 = type { i8, [3 x i8] }
%struct.anon.50 = type { i8, [3 x i8] }
%struct.anon.51 = type { i8, [3 x i8] }
%struct.PropertyInfo = type { ptr, ptr, ptr, i8, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.NvmeCmd = type { i8, i8, i16, i32, i64, i64, %union.NvmeCmdDptr, i32, i32, i32, i32, i32, i32 }
%union.NvmeCmdDptr = type { %struct.anon }
%struct.anon = type { i64, i64 }
%struct.NvmeCtrl = type { %struct.PCIDevice, %struct.MemoryRegion, %struct.MemoryRegion, %struct.NvmeBar, %struct.NvmeParams, %struct.NvmeBus, i16, i8, i32, i16, i16, i32, i8, i32, i32, i64, i64, i64, i16, i8, i32, i32, i64, i64, i8, %struct.anon.20, %struct.anon.21, i8, ptr, %union.anon.22, i32, i32, [5 x i64], ptr, %struct.NvmeNamespace, [257 x ptr], ptr, ptr, %struct.NvmeSQueue, %struct.NvmeCQueue, %struct.NvmeIdCtrl, %struct.anon.28, %struct.NvmePriCtrlCap, %struct.NvmeSecCtrlList, %struct.anon.30 }
%struct.PCIDevice = type { %struct.DeviceState, i8, i8, ptr, ptr, ptr, ptr, ptr, i32, %struct.PCIReqIDCache, [64 x i8], [7 x %struct.PCIIORegion], %struct.AddressSpace, %struct.MemoryRegion, %struct.MemoryRegion, ptr, ptr, [3 x ptr], i8, i8, i32, i8, i32, ptr, ptr, ptr, ptr, ptr, ptr, %struct.MemoryRegion, %struct.MemoryRegion, %struct.MemoryRegion, ptr, i8, i32, i8, %struct.PCIExpressDevice, ptr, ptr, i32, i8, %struct.MemoryRegion, i32, ptr, ptr, ptr, ptr, ptr, i32 }
%struct.DeviceState = type { %struct.Object, ptr, ptr, i8, i8, i64, ptr, i32, i8, ptr, %struct.NamedGPIOListHead, %struct.NamedClockListHead, %struct.BusStateHead, i32, i32, i32, %struct.ResettableState, ptr, %struct.MemReentrancyGuard }
%struct.Object = type { ptr, ptr, ptr, i32, ptr }
%struct.NamedGPIOListHead = type { ptr }
%struct.NamedClockListHead = type { ptr }
%struct.BusStateHead = type { ptr }
%struct.ResettableState = type { i32, i8, i8 }
%struct.MemReentrancyGuard = type { i8 }
%struct.PCIReqIDCache = type { ptr, i32 }
%struct.PCIIORegion = type { i64, i64, i8, ptr, ptr }
%struct.AddressSpace = type { %struct.rcu_head, ptr, ptr, ptr, i32, i32, ptr, %union.anon.15, %union.anon.16 }
%struct.rcu_head = type { ptr, ptr }
%union.anon.15 = type { %struct.QTailQLink }
%struct.QTailQLink = type { ptr, ptr }
%union.anon.16 = type { %struct.QTailQLink }
%struct.PCIExpressDevice = type { i8, i8, i8, i16, %struct.PCIEAERLog, i16, i16, i16, %struct.PCIESriovPF, %struct.PCIESriovVF }
%struct.PCIEAERLog = type { i16, i16, ptr }
%struct.PCIESriovPF = type { i16, [7 x i8], ptr, ptr }
%struct.PCIESriovVF = type { ptr, i16 }
%struct.MemoryRegion = type { %struct.Object, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, ptr, ptr, ptr, ptr, ptr, ptr, i32, i128, i64, ptr, i64, i8, i8, i8, i8, i8, ptr, i64, i32, %union.anon.17, %union.anon.18, %union.anon.19, ptr, i32, ptr, ptr, i8 }
%union.anon.17 = type { %struct.QTailQLink }
%union.anon.18 = type { %struct.QTailQLink }
%union.anon.19 = type { %struct.QTailQLink }
%struct.NvmeBar = type { i64, i32, i32, i32, i32, [4 x i8], i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, [3492 x i8], i32, i32, i32, i32, i32, i32, i32, [484 x i8] }
%struct.NvmeParams = type { ptr, i32, i32, i16, i32, i8, i32, i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i8, i8 }
%struct.NvmeBus = type { %struct.BusState }
%struct.BusState = type { %struct.Object, ptr, ptr, ptr, i32, i8, i8, i32, %union.BusChildHead, %struct.BusStateEntry, %struct.ResettableState }
%union.BusChildHead = type { %struct.QTailQLink }
%struct.BusStateEntry = type { ptr, ptr }
%struct.anon.20 = type { %struct.MemoryRegion, ptr, i8, i64 }
%struct.anon.21 = type { ptr, i8, i64 }
%union.anon.22 = type { %struct.QTailQLink }
%struct.NvmeNamespace = type { %struct.DeviceState, %struct.BlockConf, i32, i64, i64, %struct.NvmeIdNs, %struct.NvmeIdNsNvm, %struct.NvmeLBAF, i32, i64, ptr, i8, i16, i32, i8, %struct.anon.4, %union.anon.5, ptr, ptr, %union.anon.6, %union.anon.7, %union.anon.8, %union.anon.9, i32, i64, i64, i32, ptr, i32, i32, %struct.NvmeNamespaceParams, ptr, ptr, %struct.anon.13, %struct.anon.14 }
%struct.BlockConf = type { ptr, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i32, i32, i32, i32 }
%struct.NvmeIdNs = type { i64, i64, i64, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16, i16, i16, i16, i16, [16 x i8], i16, i16, i16, i16, i16, i16, i32, i8, [18 x i8], i8, i16, i16, [16 x i8], i64, [64 x %struct.NvmeLBAF], [3712 x i8] }
%struct.NvmeIdNsNvm = type { i64, i8, [3 x i8], [64 x i32], [3828 x i8] }
%struct.NvmeLBAF = type { i16, i8, i8 }
%struct.anon.4 = type { i16, i16, i32 }
%union.anon.5 = type { %struct.QTailQLink }
%union.anon.6 = type { %struct.QTailQLink }
%union.anon.7 = type { %struct.QTailQLink }
%union.anon.8 = type { %struct.QTailQLink }
%union.anon.9 = type { %struct.QTailQLink }
%struct.NvmeNamespaceParams = type { i8, i8, i32, %struct.QemuUUID, i64, i8, i16, i8, i8, i8, i8, i16, i32, i8, i8, i8, i64, i64, i32, i32, i32, i32, i64, i64, %struct.anon.12 }
%struct.QemuUUID = type { %union.anon.10 }
%union.anon.10 = type { %struct.anon.11 }
%struct.anon.11 = type { i32, i16, i16, i8, i8, [6 x i8] }
%struct.anon.12 = type { ptr }
%struct.anon.13 = type { i32 }
%struct.anon.14 = type { i16, ptr }
%struct.NvmeSQueue = type { ptr, i16, i16, i32, i32, i32, i64, i64, i64, ptr, %struct.EventNotifier, i8, ptr, %union.anon.23, %union.anon.24, %union.anon.25 }
%struct.EventNotifier = type { i32, i32, i8 }
%union.anon.23 = type { %struct.QTailQLink }
%union.anon.24 = type { %struct.QTailQLink }
%union.anon.25 = type { %struct.QTailQLink }
%struct.NvmeCQueue = type { ptr, i8, i16, i16, i32, i32, i32, i32, i64, i64, i64, ptr, %struct.EventNotifier, i8, %union.anon.26, %union.anon.27 }
%union.anon.26 = type { %struct.QTailQLink }
%union.anon.27 = type { %struct.QTailQLink }
%struct.NvmeIdCtrl = type { i16, i16, [20 x i8], [40 x i8], [8 x i8], i8, [3 x i8], i8, i8, i16, i32, i32, i32, i32, i32, [11 x i8], i8, [16 x i8], [128 x i8], i16, i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16, i32, i32, [16 x i8], [16 x i8], i32, i16, i8, i8, i16, i16, i16, i16, i32, [6 x i8], i16, i16, [170 x i8], i8, i8, i16, i32, i16, i16, i8, i8, i16, i16, i8, i8, i16, i16, i32, [228 x i8], [256 x i8], [1024 x i8], [32 x %struct.NvmePSD], [1024 x i8] }
%struct.NvmePSD = type { i16, i16, i32, i32, i8, i8, i8, i8, [16 x i8] }
%struct.anon.28 = type { %struct.anon.29, i32, %struct.NvmeHostBehaviorSupport }
%struct.anon.29 = type { i16, i16 }
%struct.NvmeHostBehaviorSupport = type { i8, i8, i8, [509 x i8] }
%struct.NvmePriCtrlCap = type { i16, i16, i8, [27 x i8], i32, i32, i16, i16, i16, i16, [16 x i8], i32, i32, i16, i16, i16, i16, [4016 x i8] }
%struct.NvmeSecCtrlList = type { i8, [31 x i8], [127 x %struct.NvmeSecCtrlEntry] }
%struct.NvmeSecCtrlEntry = type { i16, i16, i8, [3 x i8], i16, i16, i16, [18 x i8] }
%struct.anon.30 = type { i16, i16 }
%struct.NvmeSglDescriptor = type { i64, i32, [3 x i8], i8 }
%struct.NvmeRequest = type { ptr, ptr, ptr, i16, ptr, %struct.NvmeCqe, %struct.NvmeCmd, %struct.BlockAcctCookie, %struct.NvmeSg, %union.anon.3 }
%struct.NvmeCqe = type { i32, i32, i16, i16, i16, i16 }
%struct.BlockAcctCookie = type { i64, i64, i32 }
%struct.NvmeSg = type { i32, %union.anon }
%union.anon = type { %struct.QEMUSGList }
%struct.QEMUSGList = type { ptr, i32, i32, i64, ptr, ptr }
%union.anon.3 = type { %struct.QTailQLink }
%struct.NvmeRwCmd = type { i8, i8, i16, i32, i32, i32, i64, %union.NvmeCmdDptr, i64, i16, i16, i8, i8, i16, i32, i16, i16 }
%struct.ScatterGatherEntry = type { i64, i64 }
%struct.QEMUIOVector = type { ptr, i32, %union.anon.0 }
%union.anon.0 = type { %struct.anon.1 }
%struct.anon.1 = type { i32, %struct.iovec }
%struct.iovec = type { ptr, i64 }
%struct.MemTxAttrs = type { i32 }
%struct.NvmeZone = type { %struct.NvmeZoneDescr, i64, %union.anon.31 }
%struct.NvmeZoneDescr = type { i8, i8, i8, [5 x i8], i64, i64, i64, [32 x i8] }
%union.anon.31 = type { %struct.QTailQLink }
%struct.timeval = type { i64, i64 }
%struct.HostMemoryBackend = type { %struct.Object, i64, i8, i8, i8, i8, i8, i8, i8, i32, ptr, [3 x i64], i32, %struct.MemoryRegion }
%struct.PCIDeviceClass = type { %struct.DeviceClass, ptr, ptr, ptr, ptr, i16, i16, i8, i16, i16, i16, ptr }
%struct.DeviceClass = type { %struct.ObjectClass, [1 x i64], ptr, ptr, ptr, i8, i8, ptr, ptr, ptr, ptr, ptr }
%struct.ObjectClass = type { ptr, ptr, [4 x ptr], [4 x ptr], ptr, ptr }
%struct.NvmeAerResult = type { i8, i8, i8, i8 }
%struct.NvmeAsyncEvent = type { %union.anon.32, %struct.NvmeAerResult }
%union.anon.32 = type { %struct.QTailQLink }
%struct.ErrorPropagator = type { ptr, ptr }
%struct.NvmeSubsystem = type { %struct.DeviceState, %struct.NvmeBus, [256 x i8], ptr, [256 x ptr], [257 x ptr], %struct.NvmeEnduranceGroup, %struct.anon.42 }
%struct.NvmeEnduranceGroup = type { i8, %struct.anon.36 }
%struct.anon.36 = type { %struct.NvmeFdpEventBuffer, %struct.NvmeFdpEventBuffer, i16, i16, i8, i64, i64, i64, i64, i8, ptr }
%struct.NvmeFdpEventBuffer = type { [63 x %struct.NvmeFdpEvent], i32, i32, i32 }
%struct.NvmeFdpEvent = type <{ i8, i8, i16, i64, i32, [2 x i64], i16, i8, [5 x i8], [3 x i64] }>
%struct.anon.42 = type { ptr, %struct.anon.43 }
%struct.anon.43 = type { i8, i64, i16, i32 }
%struct.NvmeFlushAIOCB = type { %struct.BlockAIOCB, ptr, ptr, i32, ptr, i32, i8 }
%struct.BlockAIOCB = type { ptr, ptr, ptr, ptr, i32 }
%struct.nvme_compare_ctx = type { %struct.anon.38, %struct.anon.39 }
%struct.anon.38 = type { %struct.QEMUIOVector, ptr }
%struct.anon.39 = type { %struct.QEMUIOVector, ptr }
%struct.NvmeDsmCmd = type { i8, i8, i16, i32, [2 x i64], %union.NvmeCmdDptr, i32, i32, [4 x i32] }
%struct.NvmeDSMAIOCB = type { %struct.BlockAIOCB, ptr, ptr, i32, ptr, i32, i32 }
%struct.NvmeBounceContext = type { ptr, %struct.anon.40, %struct.anon.40 }
%struct.anon.40 = type { %struct.QEMUIOVector, ptr }
%struct.anon.2 = type { [12 x i8], i64 }
%struct.NvmeCopyCmd = type { i8, i8, i16, i32, i32, i32, [2 x i32], %union.NvmeCmdDptr, i64, i8, [3 x i8], i16, i16, i32, i16, i16 }
%struct.NvmeCopyAIOCB = type { %struct.BlockAIOCB, ptr, ptr, i32, ptr, i32, i32, i32, ptr, %struct.QEMUIOVector, %struct.anon.41, i64, i64, ptr }
%struct.anon.41 = type { %struct.BlockAcctCookie, %struct.BlockAcctCookie }
%struct.NvmeZoneSendCmd = type { i8, i8, i16, i32, [4 x i32], %union.NvmeCmdDptr, i64, i32, i8, i8, [2 x i8], [2 x i32] }
%struct.NvmeZoneResetAIOCB = type { %struct.BlockAIOCB, ptr, ptr, i32, i8, i32, ptr }
%struct.NvmeZoneReportHeader = type { i64, [56 x i8] }
%struct.NvmeZonedResult = type { i64 }
%struct.NvmeRuHandle = type { i8, i8, i64, i8, i64, ptr }
%struct.NvmeReclaimUnit = type { i64 }
%union.nvme_timestamp = type { %struct.anon.37 }
%struct.anon.37 = type { i64 }
%struct.NvmeDsmRange = type { i32, i32, i64 }
%struct.NvmeCopySourceRangeFormat0 = type { [8 x i8], i64, i16, [6 x i8], i32, i16, i16 }
%struct.NvmeCopySourceRangeFormat1 = type { [8 x i8], i64, i16, [8 x i8], [10 x i8], i16, i16 }
%struct.NvmeIdNsZoned = type { i16, i16, i32, i32, i32, i32, [24 x i8], i32, i16, i16, i8, [2763 x i8], [16 x %struct.NvmeLBAFE], [768 x i8], [256 x i8] }
%struct.NvmeLBAFE = type { i64, i8, [7 x i8] }
%struct.NvmeRuhStatus = type { [14 x i8], i16 }
%struct.NvmeRuhStatusDescr = type { i16, i16, i32, i64, [16 x i8] }
%struct.NvmeDeleteQ = type { i8, i8, i16, [9 x i32], i16, i16, [5 x i32] }
%struct.NvmeCreateSq = type { i8, i8, i16, [5 x i32], i64, i64, i16, i16, i16, i16, [4 x i32] }
%struct.NvmeCreateCq = type { i8, i8, i16, [5 x i32], i64, i64, i16, i16, i16, i16, [4 x i32] }
%struct.NvmeIdentify = type { i8, i8, i16, i32, [2 x i64], i64, i64, i8, i8, i16, i16, i8, i8, [4 x i32] }
%struct.NvmeFormatAIOCB = type { %struct.BlockAIOCB, ptr, ptr, i32, ptr, i32, i8, i64, i8, i8, i8, i8 }
%struct.NvmeDirectiveIdentify = type { i8, [31 x i8], i8, [31 x i8], i8, [31 x i8], [4000 x i8] }
%struct.NvmeErrorLog = type { i64, i16, i16, i16, i16, i64, i32, i8, [35 x i8] }
%struct.nvme_stats = type { i64, i64, i64, i64 }
%struct.NvmeSmartLog = type <{ i8, i16, i8, i8, i8, [26 x i8], [2 x i64], [2 x i64], [2 x i64], [2 x i64], [2 x i64], [2 x i64], [2 x i64], [2 x i64], [2 x i64], [2 x i64], [320 x i8] }>
%struct.NvmeFwSlotInfoLog = type { i8, [7 x i8], [8 x i8], [8 x i8], [8 x i8], [8 x i8], [8 x i8], [8 x i8], [8 x i8], [448 x i8] }
%struct.NvmeEffectsLog = type { [256 x i32], [256 x i32], [2048 x i8] }
%struct.NvmeEndGrpLog = type { i8, [2 x i8], i8, i8, i8, [26 x i8], [2 x i64], [2 x i64], [2 x i64], [2 x i64], [2 x i64], [2 x i64], [2 x i64], [2 x i64], [352 x i8] }
%struct.anon.46 = type { i8, [3 x i8] }
%struct.NvmeFdpConfsHdr = type { i16, i8, i8, i32, [8 x i8] }
%struct.NvmeFdpDescrHdr = type { i16, i8, i8, i32, i16, i16, i32, i64, i32, [36 x i8] }
%struct.NvmeRuhDescr = type { i8, [3 x i8] }
%struct.NvmeRuhuLog = type { i16, [6 x i8] }
%struct.NvmeRuhuDescr = type { i8, [7 x i8] }
%struct.NvmeFdpStatsLog = type { [2 x i64], [2 x i64], [2 x i64], [16 x i8] }
%struct.NvmeFdpEventsLog = type { i32, [60 x i8] }
%struct.BlockAcctStats = type { %struct.QemuMutex, [6 x i64], [6 x i64], [6 x i64], [6 x i64], [6 x i64], [6 x i64], i64, %struct.anon.44, i8, i8, [6 x %struct.BlockLatencyHistogram] }
%struct.QemuMutex = type { %union.pthread_mutex_t, i8 }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { ptr, ptr }
%struct.anon.44 = type { ptr }
%struct.BlockLatencyHistogram = type { i32, ptr, ptr }
%struct.NvmeIdCtrlNvm = type { i8, i8, i8, i8, i32, i64, [4080 x i8] }
%struct.NvmeIdCtrlZoned = type { i8, [4095 x i8] }
%struct.anon.47 = type { %struct.NvmeIdNsDescr, [16 x i8] }
%struct.NvmeIdNsDescr = type { i8, i8, [2 x i8] }
%struct.anon.48 = type <{ %struct.NvmeIdNsDescr, i64 }>
%struct.anon.49 = type { %struct.NvmeIdNsDescr, i8 }
%struct.NvmeFdpEventDescr = type { i8, i8 }

@.str = private unnamed_addr constant [36 x i8] c"nsid && nsid <= NVME_MAX_NAMESPACES\00", align 1
@.str.1 = private unnamed_addr constant [23 x i8] c"../qemu/hw/nvme/ctrl.c\00", align 1
@__PRETTY_FUNCTION__.nvme_attach_ns = private unnamed_addr constant [49 x i8] c"void nvme_attach_ns(NvmeCtrl *, NvmeNamespace *)\00", align 1
@trace_events_enabled_count = external global i32, align 4
@_TRACE_PCI_NVME_MAP_PRP_DSTATE = external global i16, align 2
@message_with_timestamp = external global i8, align 1
@.str.2 = private unnamed_addr constant [86 x i8] c"%d@%zu.%06zu:pci_nvme_map_prp trans_len %lu len %u prp1 0x%lx prp2 0x%lx num_prps %d\0A\00", align 1
@.str.3 = private unnamed_addr constant [73 x i8] c"pci_nvme_map_prp trans_len %lu len %u prp1 0x%lx prp2 0x%lx num_prps %d\0A\00", align 1
@qemu_loglevel = external global i32, align 4
@.str.4 = private unnamed_addr constant [7 x i8] c"device\00", align 1
@.str.5 = private unnamed_addr constant [101 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/hw/qdev-core.h\00", align 1
@__func__.DEVICE = private unnamed_addr constant [7 x i8] c"DEVICE\00", align 1
@.str.6 = private unnamed_addr constant [11 x i8] c"pci-device\00", align 1
@.str.7 = private unnamed_addr constant [106 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/hw/pci/pci_device.h\00", align 1
@__func__.PCI_DEVICE = private unnamed_addr constant [11 x i8] c"PCI_DEVICE\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"r == a\00", align 1
@.str.9 = private unnamed_addr constant [100 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qemu/int128.h\00", align 1
@__PRETTY_FUNCTION__.int128_get64 = private unnamed_addr constant [30 x i8] c"uint64_t int128_get64(Int128)\00", align 1
@.str.10 = private unnamed_addr constant [69 x i8] c"pci_nvme_ub_too_many_mappings in %s: number of mappings exceed 1024\0A\00", align 1
@__func__.nvme_map_addr = private unnamed_addr constant [14 x i8] c"nvme_map_addr\00", align 1
@_TRACE_PCI_NVME_MAP_ADDR_DSTATE = external global i16, align 2
@.str.11 = private unnamed_addr constant [51 x i8] c"%d@%zu.%06zu:pci_nvme_map_addr addr 0x%lx len %lu\0A\00", align 1
@.str.12 = private unnamed_addr constant [38 x i8] c"pci_nvme_map_addr addr 0x%lx len %lu\0A\00", align 1
@_TRACE_PCI_NVME_MAP_ADDR_CMB_DSTATE = external global i16, align 2
@.str.13 = private unnamed_addr constant [55 x i8] c"%d@%zu.%06zu:pci_nvme_map_addr_cmb addr 0x%lx len %lu\0A\00", align 1
@.str.14 = private unnamed_addr constant [42 x i8] c"pci_nvme_map_addr_cmb addr 0x%lx len %lu\0A\00", align 1
@_TRACE_PCI_NVME_UB_TOO_MANY_MAPPINGS_DSTATE = external global i16, align 2
@.str.15 = private unnamed_addr constant [70 x i8] c"%d@%zu.%06zu:pci_nvme_ub_too_many_mappings too many prp/sgl mappings\0A\00", align 1
@.str.16 = private unnamed_addr constant [57 x i8] c"pci_nvme_ub_too_many_mappings too many prp/sgl mappings\0A\00", align 1
@_TRACE_PCI_NVME_ERR_ADDR_READ_DSTATE = external global i16, align 2
@.str.17 = private unnamed_addr constant [48 x i8] c"%d@%zu.%06zu:pci_nvme_err_addr_read addr 0x%lx\0A\00", align 1
@.str.18 = private unnamed_addr constant [35 x i8] c"pci_nvme_err_addr_read addr 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT_DSTATE = external global i16, align 2
@.str.19 = private unnamed_addr constant [89 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_prplist_ent PRP list entry is not page aligned: 0x%lx\0A\00", align 1
@.str.20 = private unnamed_addr constant [76 x i8] c"pci_nvme_err_invalid_prplist_ent PRP list entry is not page aligned: 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN_DSTATE = external global i16, align 2
@.str.21 = private unnamed_addr constant [78 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_prp2_align PRP2 is not page aligned: 0x%lx\0A\00", align 1
@.str.22 = private unnamed_addr constant [65 x i8] c"pci_nvme_err_invalid_prp2_align PRP2 is not page aligned: 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_MAP_SGL_DSTATE = external global i16, align 2
@.str.23 = private unnamed_addr constant [49 x i8] c"%d@%zu.%06zu:pci_nvme_map_sgl type 0x%x len %lu\0A\00", align 1
@.str.24 = private unnamed_addr constant [36 x i8] c"pci_nvme_map_sgl type 0x%x len %lu\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH_DSTATE = external global i16, align 2
@.str.25 = private unnamed_addr constant [65 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_sgl_excess_length residual %u\0A\00", align 1
@.str.26 = private unnamed_addr constant [52 x i8] c"pci_nvme_err_invalid_sgl_excess_length residual %u\0A\00", align 1
@.str.27 = private unnamed_addr constant [26 x i8] c"sg->flags & NVME_SG_ALLOC\00", align 1
@__PRETTY_FUNCTION__.nvme_tx_interleaved = private unnamed_addr constant [117 x i8] c"uint16_t nvme_tx_interleaved(NvmeCtrl *, NvmeSg *, uint8_t *, uint32_t, uint32_t, int32_t, int64_t, NvmeTxDirection)\00", align 1
@__PRETTY_FUNCTION__.nvme_tx = private unnamed_addr constant [74 x i8] c"uint16_t nvme_tx(NvmeCtrl *, NvmeSg *, void *, uint32_t, NvmeTxDirection)\00", align 1
@__const.nvme_tx.attrs = private unnamed_addr constant { i8, i8, i8, i8 } { i8 1, i8 0, i8 0, i8 0 }, align 4
@_TRACE_PCI_NVME_ERR_INVALID_DMA_DSTATE = external global i16, align 2
@.str.28 = private unnamed_addr constant [78 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_dma PRP/SGL is too small for transfer size\0A\00", align 1
@.str.29 = private unnamed_addr constant [65 x i8] c"pci_nvme_err_invalid_dma PRP/SGL is too small for transfer size\0A\00", align 1
@_TRACE_PCI_NVME_RW_COMPLETE_CB_DSTATE = external global i16, align 2
@.str.30 = private unnamed_addr constant [54 x i8] c"%d@%zu.%06zu:pci_nvme_rw_complete_cb cid %u blk '%s'\0A\00", align 1
@.str.31 = private unnamed_addr constant [41 x i8] c"pci_nvme_rw_complete_cb cid %u blk '%s'\0A\00", align 1
@__func__.nvme_aio_err = private unnamed_addr constant [13 x i8] c"nvme_aio_err\00", align 1
@.str.32 = private unnamed_addr constant [11 x i8] c"aio failed\00", align 1
@_TRACE_PCI_NVME_ERR_AIO_DSTATE = external global i16, align 2
@.str.33 = private unnamed_addr constant [59 x i8] c"%d@%zu.%06zu:pci_nvme_err_aio cid %u err '%s' status 0x%x\0A\00", align 1
@.str.34 = private unnamed_addr constant [46 x i8] c"pci_nvme_err_aio cid %u err '%s' status 0x%x\0A\00", align 1
@.str.35 = private unnamed_addr constant [5 x i8] c"zone\00", align 1
@__PRETTY_FUNCTION__.nvme_finalize_zoned_write = private unnamed_addr constant [63 x i8] c"void nvme_finalize_zoned_write(NvmeNamespace *, NvmeRequest *)\00", align 1
@_TRACE_PCI_NVME_ZONED_ZRWA_IMPLICIT_FLUSH_DSTATE = external global i16, align 2
@.str.36 = private unnamed_addr constant [68 x i8] c"%d@%zu.%06zu:pci_nvme_zoned_zrwa_implicit_flush zslba 0x%lx nlb %u\0A\00", align 1
@.str.37 = private unnamed_addr constant [55 x i8] c"pci_nvme_zoned_zrwa_implicit_flush zslba 0x%lx nlb %u\0A\00", align 1
@.str.38 = private unnamed_addr constant [22 x i8] c"ns->nr_open_zones > 0\00", align 1
@.str.39 = private unnamed_addr constant [23 x i8] c"../qemu/hw/nvme/nvme.h\00", align 1
@__PRETTY_FUNCTION__.nvme_aor_dec_open = private unnamed_addr constant [40 x i8] c"void nvme_aor_dec_open(NvmeNamespace *)\00", align 1
@.str.40 = private unnamed_addr constant [23 x i8] c"ns->nr_open_zones >= 0\00", align 1
@.str.41 = private unnamed_addr constant [24 x i8] c"ns->nr_active_zones > 0\00", align 1
@__PRETTY_FUNCTION__.nvme_aor_dec_active = private unnamed_addr constant [42 x i8] c"void nvme_aor_dec_active(NvmeNamespace *)\00", align 1
@.str.42 = private unnamed_addr constant [41 x i8] c"ns->nr_active_zones >= ns->nr_open_zones\00", align 1
@.str.43 = private unnamed_addr constant [25 x i8] c"ns->nr_active_zones >= 0\00", align 1
@.str.44 = private unnamed_addr constant [26 x i8] c"cq->cqid == req->sq->cqid\00", align 1
@__PRETTY_FUNCTION__.nvme_enqueue_req_completion = private unnamed_addr constant [62 x i8] c"void nvme_enqueue_req_completion(NvmeCQueue *, NvmeRequest *)\00", align 1
@_TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION_DSTATE = external global i16, align 2
@.str.45 = private unnamed_addr constant [91 x i8] c"%d@%zu.%06zu:pci_nvme_enqueue_req_completion cid %u cqid %u dw0 0x%x dw1 0x%x status 0x%x\0A\00", align 1
@.str.46 = private unnamed_addr constant [78 x i8] c"pci_nvme_enqueue_req_completion cid %u cqid %u dw0 0x%x dw1 0x%x status 0x%x\0A\00", align 1
@_TRACE_PCI_NVME_ERR_REQ_STATUS_DSTATE = external global i16, align 2
@.str.47 = private unnamed_addr constant [74 x i8] c"%d@%zu.%06zu:pci_nvme_err_req_status cid %u nsid %u status 0x%x opc 0x%x\0A\00", align 1
@.str.48 = private unnamed_addr constant [61 x i8] c"pci_nvme_err_req_status cid %u nsid %u status 0x%x opc 0x%x\0A\00", align 1
@nvme_info = internal constant %struct.TypeInfo { ptr @.str.49, ptr @.str.6, i64 31872, i64 0, ptr @nvme_instance_init, ptr null, ptr null, i8 0, i64 0, ptr @nvme_class_init, ptr null, ptr null, ptr @.compoundliteral }, align 8
@nvme_bus_info = internal constant %struct.TypeInfo { ptr @.str.69, ptr @.str.522, i64 120, i64 0, ptr null, ptr null, ptr null, i8 0, i64 0, ptr null, ptr null, ptr null, ptr null }, align 8
@.str.49 = private unnamed_addr constant [5 x i8] c"nvme\00", align 1
@.str.50 = private unnamed_addr constant [19 x i8] c"pci-express-device\00", align 1
@.compoundliteral = internal global [2 x %struct.InterfaceInfo] [%struct.InterfaceInfo { ptr @.str.50 }, %struct.InterfaceInfo zeroinitializer], align 8
@__func__.nvme_instance_init = private unnamed_addr constant [19 x i8] c"nvme_instance_init\00", align 1
@.str.51 = private unnamed_addr constant [10 x i8] c"bootindex\00", align 1
@.str.52 = private unnamed_addr constant [15 x i8] c"/namespace@1,0\00", align 1
@.str.53 = private unnamed_addr constant [23 x i8] c"smart_critical_warning\00", align 1
@.str.54 = private unnamed_addr constant [6 x i8] c"uint8\00", align 1
@__func__.nvme_get_smart_warning = private unnamed_addr constant [23 x i8] c"nvme_get_smart_warning\00", align 1
@__func__.nvme_set_smart_warning = private unnamed_addr constant [23 x i8] c"nvme_set_smart_warning\00", align 1
@.str.55 = private unnamed_addr constant [46 x i8] c"unsupported smart critical warning bits: 0x%x\00", align 1
@_TRACE_PCI_NVME_ENQUEUE_EVENT_DSTATE = external global i16, align 2
@.str.56 = private unnamed_addr constant [66 x i8] c"%d@%zu.%06zu:pci_nvme_enqueue_event type 0x%x info 0x%x lid 0x%x\0A\00", align 1
@.str.57 = private unnamed_addr constant [53 x i8] c"pci_nvme_enqueue_event type 0x%x info 0x%x lid 0x%x\0A\00", align 1
@_TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE_DSTATE = external global i16, align 2
@.str.58 = private unnamed_addr constant [55 x i8] c"%d@%zu.%06zu:pci_nvme_enqueue_event_noqueue queued %d\0A\00", align 1
@.str.59 = private unnamed_addr constant [42 x i8] c"pci_nvme_enqueue_event_noqueue queued %d\0A\00", align 1
@_TRACE_PCI_NVME_PROCESS_AERS_DSTATE = external global i16, align 2
@.str.60 = private unnamed_addr constant [46 x i8] c"%d@%zu.%06zu:pci_nvme_process_aers queued %d\0A\00", align 1
@.str.61 = private unnamed_addr constant [33 x i8] c"pci_nvme_process_aers queued %d\0A\00", align 1
@_TRACE_PCI_NVME_NO_OUTSTANDING_AERS_DSTATE = external global i16, align 2
@.str.62 = private unnamed_addr constant [79 x i8] c"%d@%zu.%06zu:pci_nvme_no_outstanding_aers ignoring event; no outstanding AERs\0A\00", align 1
@.str.63 = private unnamed_addr constant [66 x i8] c"pci_nvme_no_outstanding_aers ignoring event; no outstanding AERs\0A\00", align 1
@_TRACE_PCI_NVME_AER_MASKED_DSTATE = external global i16, align 2
@.str.64 = private unnamed_addr constant [54 x i8] c"%d@%zu.%06zu:pci_nvme_aer_masked type 0x%x mask 0x%x\0A\00", align 1
@.str.65 = private unnamed_addr constant [41 x i8] c"pci_nvme_aer_masked type 0x%x mask 0x%x\0A\00", align 1
@_TRACE_PCI_NVME_AER_POST_CQE_DSTATE = external global i16, align 2
@.str.66 = private unnamed_addr constant [65 x i8] c"%d@%zu.%06zu:pci_nvme_aer_post_cqe type 0x%x info 0x%x lid 0x%x\0A\00", align 1
@.str.67 = private unnamed_addr constant [52 x i8] c"pci_nvme_aer_post_cqe type 0x%x info 0x%x lid 0x%x\0A\00", align 1
@.str.68 = private unnamed_addr constant [28 x i8] c"Non-Volatile Memory Express\00", align 1
@nvme_props = internal global [33 x %struct.Property] [%struct.Property { ptr @.str.486, ptr @qdev_prop_drive, i64 8096, i8 0, i64 0, i8 0, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.487, ptr @qdev_prop_on_off_auto, i64 8104, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.488, ptr @qdev_prop_blocksize, i64 8112, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.489, ptr @qdev_prop_blocksize, i64 8108, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.490, ptr @qdev_prop_size32, i64 8116, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.491, ptr @qdev_prop_size32, i64 8120, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.492, ptr @qdev_prop_size32, i64 8128, i8 0, i64 0, i8 1, %union.anon.33 { i64 4294967295 }, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.493, ptr @qdev_prop_on_off_auto, i64 8156, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.494, ptr @qdev_prop_bool, i64 8160, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.495, ptr @qdev_prop_on_off_auto, i64 8164, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.496, ptr @qdev_prop_on_off_auto, i64 8168, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.497, ptr @qdev_prop_link, i64 7824, i8 0, i64 0, i8 0, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr @.str.498 }, %struct.Property { ptr @.str.499, ptr @qdev_prop_link, i64 7928, i8 0, i64 0, i8 0, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr @.str.500 }, %struct.Property { ptr @.str.501, ptr @qdev_prop_string, i64 7248, i8 0, i64 0, i8 0, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.502, ptr @qdev_prop_uint32, i64 7268, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.503, ptr @qdev_prop_uint32, i64 7256, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.504, ptr @qdev_prop_uint32, i64 7260, i8 0, i64 0, i8 1, %union.anon.33 { i64 64 }, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.505, ptr @qdev_prop_uint16, i64 7264, i8 0, i64 0, i8 1, %union.anon.33 { i64 65 }, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.506, ptr @qdev_prop_uint8, i64 7272, i8 0, i64 0, i8 1, %union.anon.33 { i64 3 }, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.507, ptr @qdev_prop_uint32, i64 7276, i8 0, i64 0, i8 1, %union.anon.33 { i64 64 }, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.508, ptr @qdev_prop_uint8, i64 7280, i8 0, i64 0, i8 1, %union.anon.33 { i64 7 }, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.509, ptr @qdev_prop_uint8, i64 7281, i8 0, i64 0, i8 1, %union.anon.33 { i64 7 }, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.510, ptr @qdev_prop_bool, i64 7282, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.511, ptr @qdev_prop_bool, i64 7285, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.512, ptr @qdev_prop_bool, i64 7286, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.513, ptr @qdev_prop_uint8, i64 7283, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.514, ptr @qdev_prop_bool, i64 7284, i8 0, i64 0, i8 1, %union.anon.33 { i64 1 }, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.515, ptr @qdev_prop_uint8, i64 7287, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.516, ptr @qdev_prop_uint16, i64 7288, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.517, ptr @qdev_prop_uint16, i64 7290, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.518, ptr @qdev_prop_uint8, i64 7293, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property { ptr @.str.519, ptr @qdev_prop_uint8, i64 7292, i8 0, i64 0, i8 1, %union.anon.33 zeroinitializer, i32 0, ptr null, i32 0, ptr null }, %struct.Property zeroinitializer], align 16
@nvme_vmstate = internal constant %struct.VMStateDescription { ptr @.str.49, i8 1, i8 0, i32 0, i32 0, i32 0, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null }, align 8
@__func__.DEVICE_CLASS = private unnamed_addr constant [13 x i8] c"DEVICE_CLASS\00", align 1
@__func__.PCI_DEVICE_CLASS = private unnamed_addr constant [17 x i8] c"PCI_DEVICE_CLASS\00", align 1
@__func__.nvme_realize = private unnamed_addr constant [13 x i8] c"nvme_realize\00", align 1
@.str.69 = private unnamed_addr constant [9 x i8] c"nvme-bus\00", align 1
@.str.70 = private unnamed_addr constant [58 x i8] c"num_queues is deprecated; please use max_ioqpairs instead\00", align 1
@__func__.nvme_check_params = private unnamed_addr constant [18 x i8] c"nvme_check_params\00", align 1
@.str.71 = private unnamed_addr constant [74 x i8] c"subsystem support is unavailable with legacy namespace ('drive' property)\00", align 1
@.str.72 = private unnamed_addr constant [38 x i8] c"max_ioqpairs must be between 1 and %d\00", align 1
@.str.73 = private unnamed_addr constant [36 x i8] c"msix_qsize must be between 1 and %d\00", align 1
@.str.74 = private unnamed_addr constant [24 x i8] c"serial property not set\00", align 1
@.str.75 = private unnamed_addr constant [34 x i8] c"can't use already busy memdev: %s\00", align 1
@.str.76 = private unnamed_addr constant [48 x i8] c"pmr backend size needs to be power of 2 in size\00", align 1
@.str.77 = private unnamed_addr constant [100 x i8] c"zoned.zasl (Zone Append Size Limit) must be less than or equal to mdts (Maximum Data Transfer Size)\00", align 1
@.str.78 = private unnamed_addr constant [21 x i8] c"vsl must be non-zero\00", align 1
@.str.79 = private unnamed_addr constant [44 x i8] c"subsystem is required for the use of SR-IOV\00", align 1
@.str.80 = private unnamed_addr constant [39 x i8] c"sriov_max_vfs must be between 0 and %d\00", align 1
@.str.81 = private unnamed_addr constant [33 x i8] c"CMB is not supported with SR-IOV\00", align 1
@.str.82 = private unnamed_addr constant [33 x i8] c"PMR is not supported with SR-IOV\00", align 1
@.str.83 = private unnamed_addr constant [79 x i8] c"both sriov_vq_flexible and sriov_vi_flexible must be set for the use of SR-IOV\00", align 1
@.str.84 = private unnamed_addr constant [74 x i8] c"sriov_vq_flexible must be greater than or equal to %d (sriov_max_vfs * 2)\00", align 1
@.str.85 = private unnamed_addr constant [70 x i8] c"(max_ioqpairs - sriov_vq_flexible) must be greater than or equal to 2\00", align 1
@.str.86 = private unnamed_addr constant [70 x i8] c"sriov_vi_flexible must be greater than or equal to %d (sriov_max_vfs)\00", align 1
@.str.87 = private unnamed_addr constant [68 x i8] c"(msix_qsize - sriov_vi_flexible) must be greater than or equal to 1\00", align 1
@.str.88 = private unnamed_addr constant [97 x i8] c"sriov_max_vi_per_vf must meet: (sriov_max_vi_per_vf - 1) %% %d == 0 and sriov_max_vi_per_vf >= 1\00", align 1
@.str.89 = private unnamed_addr constant [97 x i8] c"sriov_max_vq_per_vf must meet: (sriov_max_vq_per_vf - 1) %% %d == 0 and sriov_max_vq_per_vf >= 2\00", align 1
@__func__.nvme_sctrl = private unnamed_addr constant [11 x i8] c"nvme_sctrl\00", align 1
@error_fatal = external global ptr, align 8
@.str.90 = private unnamed_addr constant [10 x i8] c"nvme-bar0\00", align 1
@nvme_mmio_ops = internal constant %struct.MemoryRegionOps { ptr @nvme_mmio_read, ptr @nvme_mmio_write, ptr null, ptr null, i32 2, %struct.anon.34 zeroinitializer, %struct.anon.35 { i32 2, i32 8, i8 0 } }, align 8
@.str.91 = private unnamed_addr constant [83 x i8] c"pci_nvme_ub_mmiord_misaligned32 in %s: MMIO read not 32-bit aligned, offset=0x%lx\0A\00", align 1
@__func__.nvme_mmio_read = private unnamed_addr constant [15 x i8] c"nvme_mmio_read\00", align 1
@.str.92 = private unnamed_addr constant [81 x i8] c"pci_nvme_ub_mmiord_toosmall in %s: MMIO read smaller than 32-bits, offset=0x%lx\0A\00", align 1
@.str.93 = private unnamed_addr constant [97 x i8] c"pci_nvme_ub_mmiord_invalid_ofs in %s: MMIO read beyond last register, offset=0x%lx, returning 0\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_READ_DSTATE = external global i16, align 2
@.str.94 = private unnamed_addr constant [52 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_read addr 0x%lx size %d\0A\00", align 1
@.str.95 = private unnamed_addr constant [39 x i8] c"pci_nvme_mmio_read addr 0x%lx size %d\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32_DSTATE = external global i16, align 2
@.str.96 = private unnamed_addr constant [89 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiord_misaligned32 MMIO read not 32-bit aligned, offset=0x%lx\0A\00", align 1
@.str.97 = private unnamed_addr constant [76 x i8] c"pci_nvme_ub_mmiord_misaligned32 MMIO read not 32-bit aligned, offset=0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIORD_TOOSMALL_DSTATE = external global i16, align 2
@.str.98 = private unnamed_addr constant [87 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiord_toosmall MMIO read smaller than 32-bits, offset=0x%lx\0A\00", align 1
@.str.99 = private unnamed_addr constant [74 x i8] c"pci_nvme_ub_mmiord_toosmall MMIO read smaller than 32-bits, offset=0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS_DSTATE = external global i16, align 2
@.str.100 = private unnamed_addr constant [103 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiord_invalid_ofs MMIO read beyond last register, offset=0x%lx, returning 0\0A\00", align 1
@.str.101 = private unnamed_addr constant [90 x i8] c"pci_nvme_ub_mmiord_invalid_ofs MMIO read beyond last register, offset=0x%lx, returning 0\0A\00", align 1
@_TRACE_PCI_NVME_ERR_IGNORED_MMIO_VF_OFFLINE_DSTATE = external global i16, align 2
@.str.102 = private unnamed_addr constant [70 x i8] c"%d@%zu.%06zu:pci_nvme_err_ignored_mmio_vf_offline addr 0x%lx size %d\0A\00", align 1
@.str.103 = private unnamed_addr constant [57 x i8] c"pci_nvme_err_ignored_mmio_vf_offline addr 0x%lx size %d\0A\00", align 1
@.str.104 = private unnamed_addr constant [99 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qemu/bswap.h\00", align 1
@__func__.ldn_le_p = private unnamed_addr constant [9 x i8] c"ldn_le_p\00", align 1
@_TRACE_PCI_NVME_MMIO_WRITE_DSTATE = external global i16, align 2
@.str.105 = private unnamed_addr constant [64 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_write addr 0x%lx data 0x%lx size %d\0A\00", align 1
@.str.106 = private unnamed_addr constant [51 x i8] c"pci_nvme_mmio_write addr 0x%lx data 0x%lx size %d\0A\00", align 1
@.str.107 = private unnamed_addr constant [84 x i8] c"pci_nvme_ub_mmiowr_misaligned32 in %s: MMIO write not 32-bit aligned, offset=0x%lx\0A\00", align 1
@__func__.nvme_write_bar = private unnamed_addr constant [15 x i8] c"nvme_write_bar\00", align 1
@.str.108 = private unnamed_addr constant [91 x i8] c"pci_nvme_ub_mmiowr_toosmall in %s: MMIO write smaller than 32-bits, offset=0x%lx, size=%u\0A\00", align 1
@.str.109 = private unnamed_addr constant [106 x i8] c"pci_nvme_ub_mmiowr_intmask_with_msix in %s: undefined access to interrupt mask set when MSI-X is enabled\0A\00", align 1
@.str.110 = private unnamed_addr constant [106 x i8] c"pci_nvme_ub_mmiowr_intmask_with_msix in %s: undefined access to interrupt mask clr when MSI-X is enabled\0A\00", align 1
@.str.111 = private unnamed_addr constant [117 x i8] c"pci_nvme_ub_mmiowr_ssreset_w1c_unsupported in %s: attempted to W1C CSTS.NSSRO but CAP.NSSRS is zero (not supported)\0A\00", align 1
@.str.112 = private unnamed_addr constant [89 x i8] c"pci_nvme_ub_mmiowr_ro_csts in %s: attempted to set a read only bit of controller status\0A\00", align 1
@.str.113 = private unnamed_addr constant [104 x i8] c"pci_nvme_ub_mmiowr_cmbloc_reserved in %s: invalid write to reserved CMBLOC when CMBSZ is zero, ignored\0A\00", align 1
@.str.114 = private unnamed_addr constant [84 x i8] c"pci_nvme_ub_mmiowr_cmbsz_readonly in %s: invalid write to read only CMBSZ, ignored\0A\00", align 1
@.str.115 = private unnamed_addr constant [85 x i8] c"pci_nvme_ub_mmiowr_pmrcap_readonly in %s: invalid write to PMRCAP register, ignored\0A\00", align 1
@.str.116 = private unnamed_addr constant [85 x i8] c"pci_nvme_ub_mmiowr_pmrsts_readonly in %s: invalid write to PMRSTS register, ignored\0A\00", align 1
@.str.117 = private unnamed_addr constant [85 x i8] c"pci_nvme_ub_mmiowr_pmrebs_readonly in %s: invalid write to PMREBS register, ignored\0A\00", align 1
@.str.118 = private unnamed_addr constant [87 x i8] c"pci_nvme_ub_mmiowr_pmrswtp_readonly in %s: invalid write to PMRSWTP register, ignored\0A\00", align 1
@.str.119 = private unnamed_addr constant [78 x i8] c"pci_nvme_ub_mmiowr_invalid in %s: invalid MMIO write, offset=0x%lx, data=%lx\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32_DSTATE = external global i16, align 2
@.str.120 = private unnamed_addr constant [90 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_misaligned32 MMIO write not 32-bit aligned, offset=0x%lx\0A\00", align 1
@.str.121 = private unnamed_addr constant [77 x i8] c"pci_nvme_ub_mmiowr_misaligned32 MMIO write not 32-bit aligned, offset=0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL_DSTATE = external global i16, align 2
@.str.122 = private unnamed_addr constant [97 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_toosmall MMIO write smaller than 32 bits, offset=0x%lx, size=%u\0A\00", align 1
@.str.123 = private unnamed_addr constant [84 x i8] c"pci_nvme_ub_mmiowr_toosmall MMIO write smaller than 32 bits, offset=0x%lx, size=%u\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_DSTATE = external global i16, align 2
@.str.124 = private unnamed_addr constant [112 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_intmask_with_msix undefined access to interrupt mask set when MSI-X is enabled\0A\00", align 1
@.str.125 = private unnamed_addr constant [99 x i8] c"pci_nvme_ub_mmiowr_intmask_with_msix undefined access to interrupt mask set when MSI-X is enabled\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_INTM_SET_DSTATE = external global i16, align 2
@.str.126 = private unnamed_addr constant [96 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_intm_set wrote MMIO, interrupt mask set, data=0x%lx, new_mask=0x%lx\0A\00", align 1
@.str.127 = private unnamed_addr constant [83 x i8] c"pci_nvme_mmio_intm_set wrote MMIO, interrupt mask set, data=0x%lx, new_mask=0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_INTM_CLR_DSTATE = external global i16, align 2
@.str.128 = private unnamed_addr constant [96 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_intm_clr wrote MMIO, interrupt mask clr, data=0x%lx, new_mask=0x%lx\0A\00", align 1
@.str.129 = private unnamed_addr constant [83 x i8] c"pci_nvme_mmio_intm_clr wrote MMIO, interrupt mask clr, data=0x%lx, new_mask=0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_CFG_DSTATE = external global i16, align 2
@.str.130 = private unnamed_addr constant [75 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_cfg wrote MMIO, config controller config=0x%lx\0A\00", align 1
@.str.131 = private unnamed_addr constant [62 x i8] c"pci_nvme_mmio_cfg wrote MMIO, config controller config=0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_SHUTDOWN_SET_DSTATE = external global i16, align 2
@.str.132 = private unnamed_addr constant [58 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_shutdown_set shutdown bit set\0A\00", align 1
@.str.133 = private unnamed_addr constant [45 x i8] c"pci_nvme_mmio_shutdown_set shutdown bit set\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED_DSTATE = external global i16, align 2
@.str.134 = private unnamed_addr constant [66 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_shutdown_cleared shutdown bit cleared\0A\00", align 1
@.str.135 = private unnamed_addr constant [53 x i8] c"pci_nvme_mmio_shutdown_cleared shutdown bit cleared\0A\00", align 1
@_TRACE_PCI_NVME_ERR_STARTFAIL_VIRT_STATE_DSTATE = external global i16, align 2
@.str.136 = private unnamed_addr constant [102 x i8] c"%d@%zu.%06zu:pci_nvme_err_startfail_virt_state nvme_start_ctrl failed due to ctrl state: vi=%u vq=%u\0A\00", align 1
@.str.137 = private unnamed_addr constant [89 x i8] c"pci_nvme_err_startfail_virt_state nvme_start_ctrl failed due to ctrl state: vi=%u vq=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_STARTFAIL_CQ_DSTATE = external global i16, align 2
@.str.138 = private unnamed_addr constant [109 x i8] c"%d@%zu.%06zu:pci_nvme_err_startfail_cq nvme_start_ctrl failed because there are non-admin completion queues\0A\00", align 1
@.str.139 = private unnamed_addr constant [96 x i8] c"pci_nvme_err_startfail_cq nvme_start_ctrl failed because there are non-admin completion queues\0A\00", align 1
@_TRACE_PCI_NVME_ERR_STARTFAIL_SQ_DSTATE = external global i16, align 2
@.str.140 = private unnamed_addr constant [109 x i8] c"%d@%zu.%06zu:pci_nvme_err_startfail_sq nvme_start_ctrl failed because there are non-admin submission queues\0A\00", align 1
@.str.141 = private unnamed_addr constant [96 x i8] c"pci_nvme_err_startfail_sq nvme_start_ctrl failed because there are non-admin submission queues\0A\00", align 1
@_TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_DSTATE = external global i16, align 2
@.str.142 = private unnamed_addr constant [139 x i8] c"%d@%zu.%06zu:pci_nvme_err_startfail_asq_misaligned nvme_start_ctrl failed because the admin submission queue address is misaligned: 0x%lx\0A\00", align 1
@.str.143 = private unnamed_addr constant [126 x i8] c"pci_nvme_err_startfail_asq_misaligned nvme_start_ctrl failed because the admin submission queue address is misaligned: 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_DSTATE = external global i16, align 2
@.str.144 = private unnamed_addr constant [139 x i8] c"%d@%zu.%06zu:pci_nvme_err_startfail_acq_misaligned nvme_start_ctrl failed because the admin completion queue address is misaligned: 0x%lx\0A\00", align 1
@.str.145 = private unnamed_addr constant [126 x i8] c"pci_nvme_err_startfail_acq_misaligned nvme_start_ctrl failed because the admin completion queue address is misaligned: 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_STARTFAIL_CSS_DSTATE = external global i16, align 2
@.str.146 = private unnamed_addr constant [104 x i8] c"%d@%zu.%06zu:pci_nvme_err_startfail_css nvme_start_ctrl failed because invalid command set selected:%u\0A\00", align 1
@.str.147 = private unnamed_addr constant [91 x i8] c"pci_nvme_err_startfail_css nvme_start_ctrl failed because invalid command set selected:%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_DSTATE = external global i16, align 2
@.str.148 = private unnamed_addr constant [131 x i8] c"%d@%zu.%06zu:pci_nvme_err_startfail_page_too_small nvme_start_ctrl failed because the page size is too small: log2size=%u, min=%u\0A\00", align 1
@.str.149 = private unnamed_addr constant [118 x i8] c"pci_nvme_err_startfail_page_too_small nvme_start_ctrl failed because the page size is too small: log2size=%u, min=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_DSTATE = external global i16, align 2
@.str.150 = private unnamed_addr constant [131 x i8] c"%d@%zu.%06zu:pci_nvme_err_startfail_page_too_large nvme_start_ctrl failed because the page size is too large: log2size=%u, max=%u\0A\00", align 1
@.str.151 = private unnamed_addr constant [118 x i8] c"pci_nvme_err_startfail_page_too_large nvme_start_ctrl failed because the page size is too large: log2size=%u, max=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_DSTATE = external global i16, align 2
@.str.152 = private unnamed_addr constant [123 x i8] c"%d@%zu.%06zu:pci_nvme_err_startfail_asqent_sz_zero nvme_start_ctrl failed because the admin submission queue size is zero\0A\00", align 1
@.str.153 = private unnamed_addr constant [110 x i8] c"pci_nvme_err_startfail_asqent_sz_zero nvme_start_ctrl failed because the admin submission queue size is zero\0A\00", align 1
@_TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_DSTATE = external global i16, align 2
@.str.154 = private unnamed_addr constant [123 x i8] c"%d@%zu.%06zu:pci_nvme_err_startfail_acqent_sz_zero nvme_start_ctrl failed because the admin completion queue size is zero\0A\00", align 1
@.str.155 = private unnamed_addr constant [110 x i8] c"pci_nvme_err_startfail_acqent_sz_zero nvme_start_ctrl failed because the admin completion queue size is zero\0A\00", align 1
@.str.156 = private unnamed_addr constant [15 x i8] c"nvme_post_cqes\00", align 1
@_TRACE_PCI_NVME_UPDATE_CQ_HEAD_DSTATE = external global i16, align 2
@.str.157 = private unnamed_addr constant [58 x i8] c"%d@%zu.%06zu:pci_nvme_update_cq_head cqid %u new_head %u\0A\00", align 1
@.str.158 = private unnamed_addr constant [45 x i8] c"pci_nvme_update_cq_head cqid %u new_head %u\0A\00", align 1
@.str.159 = private unnamed_addr constant [16 x i8] c"cq->vector < 32\00", align 1
@__PRETTY_FUNCTION__.nvme_irq_deassert = private unnamed_addr constant [49 x i8] c"void nvme_irq_deassert(NvmeCtrl *, NvmeCQueue *)\00", align 1
@_TRACE_PCI_NVME_UPDATE_CQ_EVENTIDX_DSTATE = external global i16, align 2
@.str.160 = private unnamed_addr constant [66 x i8] c"%d@%zu.%06zu:pci_nvme_update_cq_eventidx cqid %u new_eventidx %u\0A\00", align 1
@.str.161 = private unnamed_addr constant [53 x i8] c"pci_nvme_update_cq_eventidx cqid %u new_eventidx %u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_ADDR_WRITE_DSTATE = external global i16, align 2
@.str.162 = private unnamed_addr constant [49 x i8] c"%d@%zu.%06zu:pci_nvme_err_addr_write addr 0x%lx\0A\00", align 1
@.str.163 = private unnamed_addr constant [36 x i8] c"pci_nvme_err_addr_write addr 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_CFS_DSTATE = external global i16, align 2
@.str.164 = private unnamed_addr constant [55 x i8] c"%d@%zu.%06zu:pci_nvme_err_cfs controller fatal status\0A\00", align 1
@.str.165 = private unnamed_addr constant [42 x i8] c"pci_nvme_err_cfs controller fatal status\0A\00", align 1
@__PRETTY_FUNCTION__.nvme_irq_assert = private unnamed_addr constant [47 x i8] c"void nvme_irq_assert(NvmeCtrl *, NvmeCQueue *)\00", align 1
@_TRACE_PCI_NVME_IRQ_MSIX_DSTATE = external global i16, align 2
@.str.166 = private unnamed_addr constant [60 x i8] c"%d@%zu.%06zu:pci_nvme_irq_msix raising MSI-X IRQ vector %u\0A\00", align 1
@.str.167 = private unnamed_addr constant [47 x i8] c"pci_nvme_irq_msix raising MSI-X IRQ vector %u\0A\00", align 1
@_TRACE_PCI_NVME_IRQ_PIN_DSTATE = external global i16, align 2
@.str.168 = private unnamed_addr constant [47 x i8] c"%d@%zu.%06zu:pci_nvme_irq_pin pulsing IRQ pin\0A\00", align 1
@.str.169 = private unnamed_addr constant [34 x i8] c"pci_nvme_irq_pin pulsing IRQ pin\0A\00", align 1
@_TRACE_PCI_NVME_IRQ_MASKED_DSTATE = external global i16, align 2
@.str.170 = private unnamed_addr constant [48 x i8] c"%d@%zu.%06zu:pci_nvme_irq_masked IRQ is masked\0A\00", align 1
@.str.171 = private unnamed_addr constant [35 x i8] c"pci_nvme_irq_masked IRQ is masked\0A\00", align 1
@.str.172 = private unnamed_addr constant [16 x i8] c"nvme_process_sq\00", align 1
@.str.173 = private unnamed_addr constant [12 x i8] c"n->cq[cqid]\00", align 1
@__PRETTY_FUNCTION__.nvme_init_sq = private unnamed_addr constant [84 x i8] c"void nvme_init_sq(NvmeSQueue *, NvmeCtrl *, uint64_t, uint16_t, uint16_t, uint16_t)\00", align 1
@_TRACE_PCI_NVME_UPDATE_SQ_TAIL_DSTATE = external global i16, align 2
@.str.174 = private unnamed_addr constant [58 x i8] c"%d@%zu.%06zu:pci_nvme_update_sq_tail sqid %u new_tail %u\0A\00", align 1
@.str.175 = private unnamed_addr constant [45 x i8] c"pci_nvme_update_sq_tail sqid %u new_tail %u\0A\00", align 1
@.str.176 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@__PRETTY_FUNCTION__.nvme_io_cmd = private unnamed_addr constant [48 x i8] c"uint16_t nvme_io_cmd(NvmeCtrl *, NvmeRequest *)\00", align 1
@_TRACE_PCI_NVME_IO_CMD_DSTATE = external global i16, align 2
@.str.177 = private unnamed_addr constant [76 x i8] c"%d@%zu.%06zu:pci_nvme_io_cmd cid %u nsid 0x%x sqid %u opc 0x%x opname '%s'\0A\00", align 1
@.str.178 = private unnamed_addr constant [63 x i8] c"pci_nvme_io_cmd cid %u nsid 0x%x sqid %u opc 0x%x opname '%s'\0A\00", align 1
@.str.179 = private unnamed_addr constant [19 x i8] c"NVME_NVM_CMD_FLUSH\00", align 1
@.str.180 = private unnamed_addr constant [19 x i8] c"NVME_NVM_CMD_WRITE\00", align 1
@.str.181 = private unnamed_addr constant [18 x i8] c"NVME_NVM_CMD_READ\00", align 1
@.str.182 = private unnamed_addr constant [21 x i8] c"NVME_NVM_CMD_COMPARE\00", align 1
@.str.183 = private unnamed_addr constant [26 x i8] c"NVME_NVM_CMD_WRITE_ZEROES\00", align 1
@.str.184 = private unnamed_addr constant [17 x i8] c"NVME_NVM_CMD_DSM\00", align 1
@.str.185 = private unnamed_addr constant [20 x i8] c"NVME_NVM_CMD_VERIFY\00", align 1
@.str.186 = private unnamed_addr constant [18 x i8] c"NVME_NVM_CMD_COPY\00", align 1
@.str.187 = private unnamed_addr constant [25 x i8] c"NVME_ZONED_CMD_MGMT_SEND\00", align 1
@.str.188 = private unnamed_addr constant [25 x i8] c"NVME_ZONED_CMD_MGMT_RECV\00", align 1
@.str.189 = private unnamed_addr constant [27 x i8] c"NVME_ZONED_CMD_ZONE_APPEND\00", align 1
@.str.190 = private unnamed_addr constant [21 x i8] c"NVME_NVM_CMD_UNKNOWN\00", align 1
@nvme_flush_aiocb_info = internal constant %struct.AIOCBInfo { ptr @nvme_flush_cancel, i64 80 }, align 8
@_TRACE_PCI_NVME_MISC_CB_DSTATE = external global i16, align 2
@.str.191 = private unnamed_addr constant [38 x i8] c"%d@%zu.%06zu:pci_nvme_misc_cb cid %u\0A\00", align 1
@.str.192 = private unnamed_addr constant [25 x i8] c"pci_nvme_misc_cb cid %u\0A\00", align 1
@_TRACE_PCI_NVME_FLUSH_NS_DSTATE = external global i16, align 2
@.str.193 = private unnamed_addr constant [42 x i8] c"%d@%zu.%06zu:pci_nvme_flush_ns nsid 0x%x\0A\00", align 1
@.str.194 = private unnamed_addr constant [29 x i8] c"pci_nvme_flush_ns nsid 0x%x\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_OPC_DSTATE = external global i16, align 2
@.str.195 = private unnamed_addr constant [59 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_opc invalid opcode 0x%x\0A\00", align 1
@.str.196 = private unnamed_addr constant [46 x i8] c"pci_nvme_err_invalid_opc invalid opcode 0x%x\0A\00", align 1
@__PRETTY_FUNCTION__.nvme_do_write = private unnamed_addr constant [64 x i8] c"uint16_t nvme_do_write(NvmeCtrl *, NvmeRequest *, _Bool, _Bool)\00", align 1
@_TRACE_PCI_NVME_WRITE_DSTATE = external global i16, align 2
@.str.197 = private unnamed_addr constant [83 x i8] c"%d@%zu.%06zu:pci_nvme_write cid %u opname '%s' nsid %u nlb %u count %lu lba 0x%lx\0A\00", align 1
@.str.198 = private unnamed_addr constant [70 x i8] c"pci_nvme_write cid %u opname '%s' nsid %u nlb %u count %lu lba 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_MDTS_DSTATE = external global i16, align 2
@.str.199 = private unnamed_addr constant [40 x i8] c"%d@%zu.%06zu:pci_nvme_err_mdts len %zu\0A\00", align 1
@.str.200 = private unnamed_addr constant [27 x i8] c"pci_nvme_err_mdts len %zu\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE_DSTATE = external global i16, align 2
@.str.201 = private unnamed_addr constant [85 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_lba_range Invalid LBA start=%lu len=%lu limit=%lu\0A\00", align 1
@.str.202 = private unnamed_addr constant [72 x i8] c"pci_nvme_err_invalid_lba_range Invalid LBA start=%lu len=%lu limit=%lu\0A\00", align 1
@_TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START_DSTATE = external global i16, align 2
@.str.203 = private unnamed_addr constant [83 x i8] c"%d@%zu.%06zu:pci_nvme_err_append_not_at_start appending at slba=%lu, but zone=%lu\0A\00", align 1
@.str.204 = private unnamed_addr constant [70 x i8] c"pci_nvme_err_append_not_at_start appending at slba=%lu, but zone=%lu\0A\00", align 1
@_TRACE_PCI_NVME_ERR_ZASL_DSTATE = external global i16, align 2
@.str.205 = private unnamed_addr constant [40 x i8] c"%d@%zu.%06zu:pci_nvme_err_zasl len %zu\0A\00", align 1
@.str.206 = private unnamed_addr constant [27 x i8] c"pci_nvme_err_zasl len %zu\0A\00", align 1
@__PRETTY_FUNCTION__.nvme_check_zone_state_for_write = private unnamed_addr constant [53 x i8] c"uint16_t nvme_check_zone_state_for_write(NvmeZone *)\00", align 1
@_TRACE_PCI_NVME_ERR_ZONE_IS_FULL_DSTATE = external global i16, align 2
@.str.207 = private unnamed_addr constant [52 x i8] c"%d@%zu.%06zu:pci_nvme_err_zone_is_full zslba 0x%lx\0A\00", align 1
@.str.208 = private unnamed_addr constant [39 x i8] c"pci_nvme_err_zone_is_full zslba 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE_DSTATE = external global i16, align 2
@.str.209 = private unnamed_addr constant [55 x i8] c"%d@%zu.%06zu:pci_nvme_err_zone_is_offline zslba 0x%lx\0A\00", align 1
@.str.210 = private unnamed_addr constant [42 x i8] c"pci_nvme_err_zone_is_offline zslba 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY_DSTATE = external global i16, align 2
@.str.211 = private unnamed_addr constant [57 x i8] c"%d@%zu.%06zu:pci_nvme_err_zone_is_read_only zslba 0x%lx\0A\00", align 1
@.str.212 = private unnamed_addr constant [44 x i8] c"pci_nvme_err_zone_is_read_only zslba 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE_DSTATE = external global i16, align 2
@.str.213 = private unnamed_addr constant [65 x i8] c"%d@%zu.%06zu:pci_nvme_err_zone_invalid_write lba 0x%lx wp 0x%lx\0A\00", align 1
@.str.214 = private unnamed_addr constant [52 x i8] c"pci_nvme_err_zone_invalid_write lba 0x%lx wp 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP_DSTATE = external global i16, align 2
@.str.215 = private unnamed_addr constant [85 x i8] c"%d@%zu.%06zu:pci_nvme_err_write_not_at_wp writing at slba=%lu, zone=%lu, but wp=%lu\0A\00", align 1
@.str.216 = private unnamed_addr constant [72 x i8] c"pci_nvme_err_write_not_at_wp writing at slba=%lu, zone=%lu, but wp=%lu\0A\00", align 1
@_TRACE_PCI_NVME_ERR_ZONE_BOUNDARY_DSTATE = external global i16, align 2
@.str.217 = private unnamed_addr constant [69 x i8] c"%d@%zu.%06zu:pci_nvme_err_zone_boundary lba 0x%lx nlb %u zcap 0x%lx\0A\00", align 1
@.str.218 = private unnamed_addr constant [56 x i8] c"pci_nvme_err_zone_boundary lba 0x%lx nlb %u zcap 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES_DSTATE = external global i16, align 2
@.str.219 = private unnamed_addr constant [79 x i8] c"%d@%zu.%06zu:pci_nvme_err_insuff_active_res max_active=%u zone limit exceeded\0A\00", align 1
@.str.220 = private unnamed_addr constant [66 x i8] c"pci_nvme_err_insuff_active_res max_active=%u zone limit exceeded\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES_DSTATE = external global i16, align 2
@.str.221 = private unnamed_addr constant [75 x i8] c"%d@%zu.%06zu:pci_nvme_err_insuff_open_res max_open=%u zone limit exceeded\0A\00", align 1
@.str.222 = private unnamed_addr constant [62 x i8] c"pci_nvme_err_insuff_open_res max_open=%u zone limit exceeded\0A\00", align 1
@__PRETTY_FUNCTION__.nvme_aor_inc_active = private unnamed_addr constant [42 x i8] c"void nvme_aor_inc_active(NvmeNamespace *)\00", align 1
@.str.223 = private unnamed_addr constant [51 x i8] c"ns->nr_active_zones <= ns->params.max_active_zones\00", align 1
@__PRETTY_FUNCTION__.nvme_aor_inc_open = private unnamed_addr constant [40 x i8] c"void nvme_aor_inc_open(NvmeNamespace *)\00", align 1
@.str.224 = private unnamed_addr constant [47 x i8] c"ns->nr_open_zones <= ns->params.max_open_zones\00", align 1
@nvme_fdp_evf_shifts = internal constant <{ [130 x i8], [125 x i8] }> <{ [130 x i8] c"\00\01\02\03\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00 !", [125 x i8] zeroinitializer }>, align 16
@_TRACE_PCI_NVME_GETFEAT_TIMESTAMP_DSTATE = external global i16, align 2
@.str.226 = private unnamed_addr constant [71 x i8] c"%d@%zu.%06zu:pci_nvme_getfeat_timestamp get feature timestamp = 0x%lx\0A\00", align 1
@.str.227 = private unnamed_addr constant [58 x i8] c"pci_nvme_getfeat_timestamp get feature timestamp = 0x%lx\0A\00", align 1
@__PRETTY_FUNCTION__.nvme_sg_split = private unnamed_addr constant [66 x i8] c"void nvme_sg_split(NvmeSg *, NvmeNamespace *, NvmeSg *, NvmeSg *)\00", align 1
@.str.228 = private unnamed_addr constant [30 x i8] c"req->sg.flags & NVME_SG_ALLOC\00", align 1
@__PRETTY_FUNCTION__.nvme_blk_write = private unnamed_addr constant [93 x i8] c"void nvme_blk_write(BlockBackend *, int64_t, uint32_t, BlockCompletionFunc *, NvmeRequest *)\00", align 1
@_TRACE_PCI_NVME_RW_CB_DSTATE = external global i16, align 2
@.str.229 = private unnamed_addr constant [45 x i8] c"%d@%zu.%06zu:pci_nvme_rw_cb cid %u blk '%s'\0A\00", align 1
@.str.230 = private unnamed_addr constant [32 x i8] c"pci_nvme_rw_cb cid %u blk '%s'\0A\00", align 1
@__PRETTY_FUNCTION__.nvme_blk_read = private unnamed_addr constant [92 x i8] c"void nvme_blk_read(BlockBackend *, int64_t, uint32_t, BlockCompletionFunc *, NvmeRequest *)\00", align 1
@_TRACE_PCI_NVME_READ_DSTATE = external global i16, align 2
@.str.231 = private unnamed_addr constant [70 x i8] c"%d@%zu.%06zu:pci_nvme_read cid %u nsid %u nlb %u count %lu lba 0x%lx\0A\00", align 1
@.str.232 = private unnamed_addr constant [57 x i8] c"pci_nvme_read cid %u nsid %u nlb %u count %lu lba 0x%lx\0A\00", align 1
@__PRETTY_FUNCTION__.nvme_check_zone_read = private unnamed_addr constant [67 x i8] c"uint16_t nvme_check_zone_read(NvmeNamespace *, uint64_t, uint32_t)\00", align 1
@__PRETTY_FUNCTION__.nvme_check_zone_state_for_read = private unnamed_addr constant [52 x i8] c"uint16_t nvme_check_zone_state_for_read(NvmeZone *)\00", align 1
@_TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK_DSTATE = external global i16, align 2
@.str.233 = private unnamed_addr constant [74 x i8] c"%d@%zu.%06zu:pci_nvme_err_zone_read_not_ok slba=%lu, nlb=%u, status=0x%x\0A\00", align 1
@.str.234 = private unnamed_addr constant [61 x i8] c"pci_nvme_err_zone_read_not_ok slba=%lu, nlb=%u, status=0x%x\0A\00", align 1
@__func__.nvme_check_dulbe = private unnamed_addr constant [17 x i8] c"nvme_check_dulbe\00", align 1
@.str.235 = private unnamed_addr constant [27 x i8] c"unable to get block status\00", align 1
@_TRACE_PCI_NVME_BLOCK_STATUS_DSTATE = external global i16, align 2
@.str.236 = private unnamed_addr constant [85 x i8] c"%d@%zu.%06zu:pci_nvme_block_status offset %ld bytes %ld pnum %ld ret 0x%x zeroed %d\0A\00", align 1
@.str.237 = private unnamed_addr constant [72 x i8] c"pci_nvme_block_status offset %ld bytes %ld pnum %ld ret 0x%x zeroed %d\0A\00", align 1
@_TRACE_PCI_NVME_COMPARE_DSTATE = external global i16, align 2
@.str.238 = private unnamed_addr constant [64 x i8] c"%d@%zu.%06zu:pci_nvme_compare cid %u nsid %u slba 0x%lx nlb %u\0A\00", align 1
@.str.239 = private unnamed_addr constant [51 x i8] c"pci_nvme_compare cid %u nsid %u slba 0x%lx nlb %u\0A\00", align 1
@_TRACE_PCI_NVME_COMPARE_DATA_CB_DSTATE = external global i16, align 2
@.str.240 = private unnamed_addr constant [46 x i8] c"%d@%zu.%06zu:pci_nvme_compare_data_cb cid %u\0A\00", align 1
@.str.241 = private unnamed_addr constant [33 x i8] c"pci_nvme_compare_data_cb cid %u\0A\00", align 1
@_TRACE_PCI_NVME_COMPARE_MDATA_CB_DSTATE = external global i16, align 2
@.str.242 = private unnamed_addr constant [47 x i8] c"%d@%zu.%06zu:pci_nvme_compare_mdata_cb cid %u\0A\00", align 1
@.str.243 = private unnamed_addr constant [34 x i8] c"pci_nvme_compare_mdata_cb cid %u\0A\00", align 1
@nvme_dsm_aiocb_info = internal constant %struct.AIOCBInfo { ptr @nvme_dsm_cancel, i64 80 }, align 8
@_TRACE_PCI_NVME_DSM_DSTATE = external global i16, align 2
@.str.244 = private unnamed_addr constant [43 x i8] c"%d@%zu.%06zu:pci_nvme_dsm nr %u attr 0x%x\0A\00", align 1
@.str.245 = private unnamed_addr constant [30 x i8] c"pci_nvme_dsm nr %u attr 0x%x\0A\00", align 1
@.str.246 = private unnamed_addr constant [22 x i8] c"iocb->idx == iocb->nr\00", align 1
@__PRETTY_FUNCTION__.nvme_dsm_cancel = private unnamed_addr constant [35 x i8] c"void nvme_dsm_cancel(BlockAIOCB *)\00", align 1
@_TRACE_PCI_NVME_DSM_DEALLOCATE_DSTATE = external global i16, align 2
@.str.247 = private unnamed_addr constant [54 x i8] c"%d@%zu.%06zu:pci_nvme_dsm_deallocate slba %lu nlb %u\0A\00", align 1
@.str.248 = private unnamed_addr constant [41 x i8] c"pci_nvme_dsm_deallocate slba %lu nlb %u\0A\00", align 1
@_TRACE_PCI_NVME_DSM_SINGLE_RANGE_LIMIT_EXCEEDED_DSTATE = external global i16, align 2
@.str.249 = private unnamed_addr constant [71 x i8] c"%d@%zu.%06zu:pci_nvme_dsm_single_range_limit_exceeded nlb %u dmrsl %u\0A\00", align 1
@.str.250 = private unnamed_addr constant [58 x i8] c"pci_nvme_dsm_single_range_limit_exceeded nlb %u dmrsl %u\0A\00", align 1
@_TRACE_PCI_NVME_VERIFY_DSTATE = external global i16, align 2
@.str.251 = private unnamed_addr constant [63 x i8] c"%d@%zu.%06zu:pci_nvme_verify cid %u nsid %u slba 0x%lx nlb %u\0A\00", align 1
@.str.252 = private unnamed_addr constant [50 x i8] c"pci_nvme_verify cid %u nsid %u slba 0x%lx nlb %u\0A\00", align 1
@_TRACE_PCI_NVME_VERIFY_MDATA_IN_CB_DSTATE = external global i16, align 2
@.str.253 = private unnamed_addr constant [58 x i8] c"%d@%zu.%06zu:pci_nvme_verify_mdata_in_cb cid %u blk '%s'\0A\00", align 1
@.str.254 = private unnamed_addr constant [45 x i8] c"pci_nvme_verify_mdata_in_cb cid %u blk '%s'\0A\00", align 1
@_TRACE_PCI_NVME_VERIFY_CB_DSTATE = external global i16, align 2
@.str.255 = private unnamed_addr constant [89 x i8] c"%d@%zu.%06zu:pci_nvme_verify_cb cid %u prinfo 0x%x apptag 0x%x appmask 0x%x reftag 0x%x\0A\00", align 1
@.str.256 = private unnamed_addr constant [76 x i8] c"pci_nvme_verify_cb cid %u prinfo 0x%x apptag 0x%x appmask 0x%x reftag 0x%x\0A\00", align 1
@nvme_copy_aiocb_info = internal constant %struct.AIOCBInfo { ptr @nvme_copy_cancel, i64 208 }, align 8
@_TRACE_PCI_NVME_COPY_DSTATE = external global i16, align 2
@.str.257 = private unnamed_addr constant [61 x i8] c"%d@%zu.%06zu:pci_nvme_copy cid %u nsid %u nr %u format 0x%x\0A\00", align 1
@.str.258 = private unnamed_addr constant [48 x i8] c"pci_nvme_copy cid %u nsid %u nr %u format 0x%x\0A\00", align 1
@_TRACE_PCI_NVME_ERR_COPY_INVALID_FORMAT_DSTATE = external global i16, align 2
@.str.259 = private unnamed_addr constant [59 x i8] c"%d@%zu.%06zu:pci_nvme_err_copy_invalid_format format 0x%x\0A\00", align 1
@.str.260 = private unnamed_addr constant [46 x i8] c"pci_nvme_err_copy_invalid_format format 0x%x\0A\00", align 1
@_TRACE_PCI_NVME_COPY_SOURCE_RANGE_DSTATE = external global i16, align 2
@.str.261 = private unnamed_addr constant [59 x i8] c"%d@%zu.%06zu:pci_nvme_copy_source_range slba 0x%lx nlb %u\0A\00", align 1
@.str.262 = private unnamed_addr constant [46 x i8] c"pci_nvme_copy_source_range slba 0x%lx nlb %u\0A\00", align 1
@_TRACE_PCI_NVME_COPY_OUT_DSTATE = external global i16, align 2
@.str.263 = private unnamed_addr constant [50 x i8] c"%d@%zu.%06zu:pci_nvme_copy_out slba 0x%lx nlb %u\0A\00", align 1
@.str.264 = private unnamed_addr constant [37 x i8] c"pci_nvme_copy_out slba 0x%lx nlb %u\0A\00", align 1
@nvme_zone_reset_aiocb_info = internal constant %struct.AIOCBInfo { ptr @nvme_zone_reset_cancel, i64 80 }, align 8
@.str.265 = private unnamed_addr constant [26 x i8] c"*zone_idx < ns->num_zones\00", align 1
@__PRETTY_FUNCTION__.nvme_get_mgmt_zone_slba_idx = private unnamed_addr constant [89 x i8] c"uint16_t nvme_get_mgmt_zone_slba_idx(NvmeNamespace *, NvmeCmd *, uint64_t *, uint32_t *)\00", align 1
@_TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD_DSTATE = external global i16, align 2
@.str.266 = private unnamed_addr constant [94 x i8] c"%d@%zu.%06zu:pci_nvme_err_unaligned_zone_cmd unaligned zone op 0x%x, got slba=%lu, zslba=%lu\0A\00", align 1
@.str.267 = private unnamed_addr constant [81 x i8] c"pci_nvme_err_unaligned_zone_cmd unaligned zone op 0x%x, got slba=%lu, zslba=%lu\0A\00", align 1
@_TRACE_PCI_NVME_OPEN_ZONE_DSTATE = external global i16, align 2
@.str.268 = private unnamed_addr constant [69 x i8] c"%d@%zu.%06zu:pci_nvme_open_zone open zone, slba=%lu, idx=%u, all=%i\0A\00", align 1
@.str.269 = private unnamed_addr constant [56 x i8] c"pci_nvme_open_zone open zone, slba=%lu, idx=%u, all=%i\0A\00", align 1
@_TRACE_PCI_NVME_CLOSE_ZONE_DSTATE = external global i16, align 2
@.str.270 = private unnamed_addr constant [71 x i8] c"%d@%zu.%06zu:pci_nvme_close_zone close zone, slba=%lu, idx=%u, all=%i\0A\00", align 1
@.str.271 = private unnamed_addr constant [58 x i8] c"pci_nvme_close_zone close zone, slba=%lu, idx=%u, all=%i\0A\00", align 1
@_TRACE_PCI_NVME_FINISH_ZONE_DSTATE = external global i16, align 2
@.str.272 = private unnamed_addr constant [73 x i8] c"%d@%zu.%06zu:pci_nvme_finish_zone finish zone, slba=%lu, idx=%u, all=%i\0A\00", align 1
@.str.273 = private unnamed_addr constant [60 x i8] c"pci_nvme_finish_zone finish zone, slba=%lu, idx=%u, all=%i\0A\00", align 1
@_TRACE_PCI_NVME_RESET_ZONE_DSTATE = external global i16, align 2
@.str.274 = private unnamed_addr constant [71 x i8] c"%d@%zu.%06zu:pci_nvme_reset_zone reset zone, slba=%lu, idx=%u, all=%i\0A\00", align 1
@.str.275 = private unnamed_addr constant [58 x i8] c"pci_nvme_reset_zone reset zone, slba=%lu, idx=%u, all=%i\0A\00", align 1
@_TRACE_PCI_NVME_ZNS_ZONE_RESET_DSTATE = external global i16, align 2
@.str.276 = private unnamed_addr constant [50 x i8] c"%d@%zu.%06zu:pci_nvme_zns_zone_reset zslba 0x%lx\0A\00", align 1
@.str.277 = private unnamed_addr constant [37 x i8] c"pci_nvme_zns_zone_reset zslba 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_OFFLINE_ZONE_DSTATE = external global i16, align 2
@.str.278 = private unnamed_addr constant [75 x i8] c"%d@%zu.%06zu:pci_nvme_offline_zone offline zone, slba=%lu, idx=%u, all=%i\0A\00", align 1
@.str.279 = private unnamed_addr constant [62 x i8] c"pci_nvme_offline_zone offline zone, slba=%lu, idx=%u, all=%i\0A\00", align 1
@_TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION_DSTATE = external global i16, align 2
@.str.280 = private unnamed_addr constant [96 x i8] c"%d@%zu.%06zu:pci_nvme_set_descriptor_extension set zone descriptor extension, slba=%lu, idx=%u\0A\00", align 1
@.str.281 = private unnamed_addr constant [83 x i8] c"pci_nvme_set_descriptor_extension set zone descriptor extension, slba=%lu, idx=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR_DSTATE = external global i16, align 2
@.str.282 = private unnamed_addr constant [97 x i8] c"%d@%zu.%06zu:pci_nvme_err_zd_extension_map_error can't map descriptor extension for zone_idx=%u\0A\00", align 1
@.str.283 = private unnamed_addr constant [84 x i8] c"pci_nvme_err_zd_extension_map_error can't map descriptor extension for zone_idx=%u\0A\00", align 1
@_TRACE_PCI_NVME_ZD_EXTENSION_SET_DSTATE = external global i16, align 2
@.str.284 = private unnamed_addr constant [81 x i8] c"%d@%zu.%06zu:pci_nvme_zd_extension_set set descriptor extension for zone_idx=%u\0A\00", align 1
@.str.285 = private unnamed_addr constant [68 x i8] c"pci_nvme_zd_extension_set set descriptor extension for zone_idx=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION_DSTATE = external global i16, align 2
@.str.286 = private unnamed_addr constant [59 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_mgmt_action action=0x%x\0A\00", align 1
@.str.287 = private unnamed_addr constant [46 x i8] c"pci_nvme_err_invalid_mgmt_action action=0x%x\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION_DSTATE = external global i16, align 2
@.str.288 = private unnamed_addr constant [91 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_zone_state_transition action=0x%x, slba=%lu, attrs=0x%x\0A\00", align 1
@.str.289 = private unnamed_addr constant [78 x i8] c"pci_nvme_err_invalid_zone_state_transition action=0x%x, slba=%lu, attrs=0x%x\0A\00", align 1
@__PRETTY_FUNCTION__.nvme_admin_cmd = private unnamed_addr constant [51 x i8] c"uint16_t nvme_admin_cmd(NvmeCtrl *, NvmeRequest *)\00", align 1
@_TRACE_PCI_NVME_ADMIN_CMD_DSTATE = external global i16, align 2
@.str.290 = private unnamed_addr constant [69 x i8] c"%d@%zu.%06zu:pci_nvme_admin_cmd cid %u sqid %u opc 0x%x opname '%s'\0A\00", align 1
@.str.291 = private unnamed_addr constant [56 x i8] c"pci_nvme_admin_cmd cid %u sqid %u opc 0x%x opname '%s'\0A\00", align 1
@.str.292 = private unnamed_addr constant [23 x i8] c"NVME_ADM_CMD_DELETE_SQ\00", align 1
@.str.293 = private unnamed_addr constant [23 x i8] c"NVME_ADM_CMD_CREATE_SQ\00", align 1
@.str.294 = private unnamed_addr constant [26 x i8] c"NVME_ADM_CMD_GET_LOG_PAGE\00", align 1
@.str.295 = private unnamed_addr constant [23 x i8] c"NVME_ADM_CMD_DELETE_CQ\00", align 1
@.str.296 = private unnamed_addr constant [23 x i8] c"NVME_ADM_CMD_CREATE_CQ\00", align 1
@.str.297 = private unnamed_addr constant [22 x i8] c"NVME_ADM_CMD_IDENTIFY\00", align 1
@.str.298 = private unnamed_addr constant [19 x i8] c"NVME_ADM_CMD_ABORT\00", align 1
@.str.299 = private unnamed_addr constant [26 x i8] c"NVME_ADM_CMD_SET_FEATURES\00", align 1
@.str.300 = private unnamed_addr constant [26 x i8] c"NVME_ADM_CMD_GET_FEATURES\00", align 1
@.str.301 = private unnamed_addr constant [26 x i8] c"NVME_ADM_CMD_ASYNC_EV_REQ\00", align 1
@.str.302 = private unnamed_addr constant [27 x i8] c"NVME_ADM_CMD_NS_ATTACHMENT\00", align 1
@.str.303 = private unnamed_addr constant [28 x i8] c"NVME_ADM_CMD_DIRECTIVE_SEND\00", align 1
@.str.304 = private unnamed_addr constant [24 x i8] c"NVME_ADM_CMD_VIRT_MNGMT\00", align 1
@.str.305 = private unnamed_addr constant [28 x i8] c"NVME_ADM_CMD_DIRECTIVE_RECV\00", align 1
@.str.306 = private unnamed_addr constant [26 x i8] c"NVME_ADM_CMD_DBBUF_CONFIG\00", align 1
@.str.307 = private unnamed_addr constant [24 x i8] c"NVME_ADM_CMD_FORMAT_NVM\00", align 1
@.str.308 = private unnamed_addr constant [21 x i8] c"NVME_ADM_CMD_UNKNOWN\00", align 1
@nvme_cse_acs = internal constant <{ [129 x i32], [127 x i32] }> <{ [129 x i32] [i32 1, i32 1, i32 1, i32 0, i32 1, i32 1, i32 1, i32 0, i32 1, i32 1, i32 1, i32 0, i32 1, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 9, i32 0, i32 0, i32 0, i32 1, i32 1, i32 0, i32 1, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 1, i32 0, i32 0, i32 0, i32 3], [127 x i32] zeroinitializer }>, align 16
@_TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC_DSTATE = external global i16, align 2
@.str.310 = private unnamed_addr constant [71 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_admin_opc invalid admin opcode 0x%x\0A\00", align 1
@.str.311 = private unnamed_addr constant [58 x i8] c"pci_nvme_err_invalid_admin_opc invalid admin opcode 0x%x\0A\00", align 1
@.str.312 = private unnamed_addr constant [9 x i8] c"r->aiocb\00", align 1
@__PRETTY_FUNCTION__.nvme_del_sq = private unnamed_addr constant [48 x i8] c"uint16_t nvme_del_sq(NvmeCtrl *, NvmeRequest *)\00", align 1
@.str.313 = private unnamed_addr constant [32 x i8] c"QTAILQ_EMPTY(&sq->out_req_list)\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_DEL_SQ_DSTATE = external global i16, align 2
@.str.314 = private unnamed_addr constant [84 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_del_sq invalid submission queue deletion, sid=%u\0A\00", align 1
@.str.315 = private unnamed_addr constant [71 x i8] c"pci_nvme_err_invalid_del_sq invalid submission queue deletion, sid=%u\0A\00", align 1
@_TRACE_PCI_NVME_DEL_SQ_DSTATE = external global i16, align 2
@.str.316 = private unnamed_addr constant [64 x i8] c"%d@%zu.%06zu:pci_nvme_del_sq deleting submission queue sqid=%u\0A\00", align 1
@.str.317 = private unnamed_addr constant [51 x i8] c"pci_nvme_del_sq deleting submission queue sqid=%u\0A\00", align 1
@_TRACE_PCI_NVME_CREATE_SQ_DSTATE = external global i16, align 2
@.str.318 = private unnamed_addr constant [108 x i8] c"%d@%zu.%06zu:pci_nvme_create_sq create submission queue, addr=0x%lx, sqid=%u, cqid=%u, qsize=%u, qflags=%u\0A\00", align 1
@.str.319 = private unnamed_addr constant [95 x i8] c"pci_nvme_create_sq create submission queue, addr=0x%lx, sqid=%u, cqid=%u, qsize=%u, qflags=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID_DSTATE = external global i16, align 2
@.str.320 = private unnamed_addr constant [100 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_cqid failed creating submission queue, invalid cqid=%u\0A\00", align 1
@.str.321 = private unnamed_addr constant [87 x i8] c"pci_nvme_err_invalid_create_sq_cqid failed creating submission queue, invalid cqid=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID_DSTATE = external global i16, align 2
@.str.322 = private unnamed_addr constant [100 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_sqid failed creating submission queue, invalid sqid=%u\0A\00", align 1
@.str.323 = private unnamed_addr constant [87 x i8] c"pci_nvme_err_invalid_create_sq_sqid failed creating submission queue, invalid sqid=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE_DSTATE = external global i16, align 2
@.str.324 = private unnamed_addr constant [101 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_size failed creating submission queue, invalid qsize=%u\0A\00", align 1
@.str.325 = private unnamed_addr constant [88 x i8] c"pci_nvme_err_invalid_create_sq_size failed creating submission queue, invalid qsize=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR_DSTATE = external global i16, align 2
@.str.326 = private unnamed_addr constant [95 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_addr failed creating submission queue, addr=0x%lx\0A\00", align 1
@.str.327 = private unnamed_addr constant [82 x i8] c"pci_nvme_err_invalid_create_sq_addr failed creating submission queue, addr=0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_DSTATE = external global i16, align 2
@.str.328 = private unnamed_addr constant [96 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_qflags failed creating submission queue, qflags=%u\0A\00", align 1
@.str.329 = private unnamed_addr constant [83 x i8] c"pci_nvme_err_invalid_create_sq_qflags failed creating submission queue, qflags=%u\0A\00", align 1
@_TRACE_PCI_NVME_GET_LOG_DSTATE = external global i16, align 2
@.str.330 = private unnamed_addr constant [80 x i8] c"%d@%zu.%06zu:pci_nvme_get_log cid %u lid 0x%x lsp 0x%x rae 0x%x len %u off %lu\0A\00", align 1
@.str.331 = private unnamed_addr constant [67 x i8] c"pci_nvme_get_log cid %u lid 0x%x lsp 0x%x rae 0x%x len %u off %lu\0A\00", align 1
@.str.332 = private unnamed_addr constant [4 x i8] c"1.0\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET_DSTATE = external global i16, align 2
@.str.333 = private unnamed_addr constant [75 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_log_page_offset must be <= %lu, got %lu\0A\00", align 1
@.str.334 = private unnamed_addr constant [62 x i8] c"pci_nvme_err_invalid_log_page_offset must be <= %lu, got %lu\0A\00", align 1
@nvme_cse_iocs_nvm = internal constant <{ [30 x i32], [226 x i32] }> <{ [30 x i32] [i32 3, i32 3, i32 1, i32 0, i32 0, i32 1, i32 0, i32 0, i32 3, i32 3, i32 0, i32 0, i32 1, i32 0, i32 0, i32 0, i32 0, i32 0, i32 1, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 3, i32 0, i32 0, i32 0, i32 3], [226 x i32] zeroinitializer }>, align 16
@nvme_cse_iocs_zoned = internal constant <{ [126 x i32], [130 x i32] }> <{ [126 x i32] [i32 3, i32 3, i32 1, i32 0, i32 0, i32 1, i32 0, i32 0, i32 3, i32 3, i32 0, i32 0, i32 1, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 3, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 3, i32 1, i32 0, i32 0, i32 3], [130 x i32] zeroinitializer }>, align 16
@__const.nvme_fdp_confs._v = private unnamed_addr constant %struct.anon.45 { i8 1, [3 x i8] undef }, align 4
@.str.337 = private unnamed_addr constant [49 x i8] c"start >= 0 && length > 0 && length <= 32 - start\00", align 1
@.str.338 = private unnamed_addr constant [100 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qemu/bitops.h\00", align 1
@__PRETTY_FUNCTION__.deposit32 = private unnamed_addr constant [49 x i8] c"uint32_t deposit32(uint32_t, int, int, uint32_t)\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_DSTATE = external global i16, align 2
@.str.339 = private unnamed_addr constant [60 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_log_page cid %u lid 0x%x\0A\00", align 1
@.str.340 = private unnamed_addr constant [47 x i8] c"pci_nvme_err_invalid_log_page cid %u lid 0x%x\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID_DSTATE = external global i16, align 2
@.str.341 = private unnamed_addr constant [89 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_del_cq_cqid failed deleting completion queue, cqid=%u\0A\00", align 1
@.str.342 = private unnamed_addr constant [76 x i8] c"pci_nvme_err_invalid_del_cq_cqid failed deleting completion queue, cqid=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_DSTATE = external global i16, align 2
@.str.343 = private unnamed_addr constant [110 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_del_cq_notempty failed deleting completion queue, it is not empty, cqid=%u\0A\00", align 1
@.str.344 = private unnamed_addr constant [97 x i8] c"pci_nvme_err_invalid_del_cq_notempty failed deleting completion queue, it is not empty, cqid=%u\0A\00", align 1
@_TRACE_PCI_NVME_DEL_CQ_DSTATE = external global i16, align 2
@.str.345 = private unnamed_addr constant [64 x i8] c"%d@%zu.%06zu:pci_nvme_del_cq deleted completion queue, cqid=%u\0A\00", align 1
@.str.346 = private unnamed_addr constant [51 x i8] c"pci_nvme_del_cq deleted completion queue, cqid=%u\0A\00", align 1
@_TRACE_PCI_NVME_CREATE_CQ_DSTATE = external global i16, align 2
@.str.347 = private unnamed_addr constant [118 x i8] c"%d@%zu.%06zu:pci_nvme_create_cq create completion queue, addr=0x%lx, cqid=%u, vector=%u, qsize=%u, qflags=%u, ien=%d\0A\00", align 1
@.str.348 = private unnamed_addr constant [105 x i8] c"pci_nvme_create_cq create completion queue, addr=0x%lx, cqid=%u, vector=%u, qsize=%u, qflags=%u, ien=%d\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ENTRY_SIZE_DSTATE = external global i16, align 2
@.str.349 = private unnamed_addr constant [76 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_entry_size iosqes %u iocqes %u\0A\00", align 1
@.str.350 = private unnamed_addr constant [63 x i8] c"pci_nvme_err_invalid_create_cq_entry_size iosqes %u iocqes %u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID_DSTATE = external global i16, align 2
@.str.351 = private unnamed_addr constant [92 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_cqid failed creating completion queue, cqid=%u\0A\00", align 1
@.str.352 = private unnamed_addr constant [79 x i8] c"pci_nvme_err_invalid_create_cq_cqid failed creating completion queue, cqid=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE_DSTATE = external global i16, align 2
@.str.353 = private unnamed_addr constant [92 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_size failed creating completion queue, size=%u\0A\00", align 1
@.str.354 = private unnamed_addr constant [79 x i8] c"pci_nvme_err_invalid_create_cq_size failed creating completion queue, size=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR_DSTATE = external global i16, align 2
@.str.355 = private unnamed_addr constant [95 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_addr failed creating completion queue, addr=0x%lx\0A\00", align 1
@.str.356 = private unnamed_addr constant [82 x i8] c"pci_nvme_err_invalid_create_cq_addr failed creating completion queue, addr=0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR_DSTATE = external global i16, align 2
@.str.357 = private unnamed_addr constant [96 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_vector failed creating completion queue, vector=%u\0A\00", align 1
@.str.358 = private unnamed_addr constant [83 x i8] c"pci_nvme_err_invalid_create_cq_vector failed creating completion queue, vector=%u\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_DSTATE = external global i16, align 2
@.str.359 = private unnamed_addr constant [96 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_qflags failed creating completion queue, qflags=%u\0A\00", align 1
@.str.360 = private unnamed_addr constant [83 x i8] c"pci_nvme_err_invalid_create_cq_qflags failed creating completion queue, qflags=%u\0A\00", align 1
@_TRACE_PCI_NVME_IDENTIFY_DSTATE = external global i16, align 2
@.str.361 = private unnamed_addr constant [67 x i8] c"%d@%zu.%06zu:pci_nvme_identify cid %u cns 0x%x ctrlid %u csi 0x%x\0A\00", align 1
@.str.362 = private unnamed_addr constant [54 x i8] c"pci_nvme_identify cid %u cns 0x%x ctrlid %u csi 0x%x\0A\00", align 1
@_TRACE_PCI_NVME_IDENTIFY_NS_DSTATE = external global i16, align 2
@.str.363 = private unnamed_addr constant [43 x i8] c"%d@%zu.%06zu:pci_nvme_identify_ns nsid %u\0A\00", align 1
@.str.364 = private unnamed_addr constant [30 x i8] c"pci_nvme_identify_ns nsid %u\0A\00", align 1
@_TRACE_PCI_NVME_IDENTIFY_CTRL_LIST_DSTATE = external global i16, align 2
@.str.365 = private unnamed_addr constant [60 x i8] c"%d@%zu.%06zu:pci_nvme_identify_ctrl_list cns 0x%x cntid %u\0A\00", align 1
@.str.366 = private unnamed_addr constant [47 x i8] c"pci_nvme_identify_ctrl_list cns 0x%x cntid %u\0A\00", align 1
@_TRACE_PCI_NVME_IDENTIFY_PRI_CTRL_CAP_DSTATE = external global i16, align 2
@.str.367 = private unnamed_addr constant [96 x i8] c"%d@%zu.%06zu:pci_nvme_identify_pri_ctrl_cap identify primary controller capabilities cntlid=%u\0A\00", align 1
@.str.368 = private unnamed_addr constant [83 x i8] c"pci_nvme_identify_pri_ctrl_cap identify primary controller capabilities cntlid=%u\0A\00", align 1
@_TRACE_PCI_NVME_IDENTIFY_SEC_CTRL_LIST_DSTATE = external global i16, align 2
@.str.369 = private unnamed_addr constant [102 x i8] c"%d@%zu.%06zu:pci_nvme_identify_sec_ctrl_list identify secondary controller list cntlid=%u numcntl=%u\0A\00", align 1
@.str.370 = private unnamed_addr constant [89 x i8] c"pci_nvme_identify_sec_ctrl_list identify secondary controller list cntlid=%u numcntl=%u\0A\00", align 1
@_TRACE_PCI_NVME_IDENTIFY_NS_CSI_DSTATE = external global i16, align 2
@.str.371 = private unnamed_addr constant [57 x i8] c"%d@%zu.%06zu:pci_nvme_identify_ns_csi nsid=%u, csi=0x%x\0A\00", align 1
@.str.372 = private unnamed_addr constant [44 x i8] c"pci_nvme_identify_ns_csi nsid=%u, csi=0x%x\0A\00", align 1
@_TRACE_PCI_NVME_IDENTIFY_CTRL_DSTATE = external global i16, align 2
@.str.373 = private unnamed_addr constant [57 x i8] c"%d@%zu.%06zu:pci_nvme_identify_ctrl identify controller\0A\00", align 1
@.str.374 = private unnamed_addr constant [44 x i8] c"pci_nvme_identify_ctrl identify controller\0A\00", align 1
@_TRACE_PCI_NVME_IDENTIFY_CTRL_CSI_DSTATE = external global i16, align 2
@.str.375 = private unnamed_addr constant [71 x i8] c"%d@%zu.%06zu:pci_nvme_identify_ctrl_csi identify controller, csi=0x%x\0A\00", align 1
@.str.376 = private unnamed_addr constant [58 x i8] c"pci_nvme_identify_ctrl_csi identify controller, csi=0x%x\0A\00", align 1
@nvme_identify_nslist.data_len = internal constant i32 4096, align 4
@_TRACE_PCI_NVME_IDENTIFY_NSLIST_DSTATE = external global i16, align 2
@.str.377 = private unnamed_addr constant [47 x i8] c"%d@%zu.%06zu:pci_nvme_identify_nslist nsid %u\0A\00", align 1
@.str.378 = private unnamed_addr constant [34 x i8] c"pci_nvme_identify_nslist nsid %u\0A\00", align 1
@nvme_identify_nslist_csi.data_len = internal constant i32 4096, align 4
@_TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI_DSTATE = external global i16, align 2
@.str.379 = private unnamed_addr constant [61 x i8] c"%d@%zu.%06zu:pci_nvme_identify_nslist_csi nsid=%u, csi=0x%x\0A\00", align 1
@.str.380 = private unnamed_addr constant [48 x i8] c"pci_nvme_identify_nslist_csi nsid=%u, csi=0x%x\0A\00", align 1
@_TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST_DSTATE = external global i16, align 2
@.str.381 = private unnamed_addr constant [54 x i8] c"%d@%zu.%06zu:pci_nvme_identify_ns_descr_list nsid %u\0A\00", align 1
@.str.382 = private unnamed_addr constant [41 x i8] c"pci_nvme_identify_ns_descr_list nsid %u\0A\00", align 1
@nvme_identify_cmd_set.data_len = internal constant i32 4096, align 4
@_TRACE_PCI_NVME_IDENTIFY_CMD_SET_DSTATE = external global i16, align 2
@.str.383 = private unnamed_addr constant [65 x i8] c"%d@%zu.%06zu:pci_nvme_identify_cmd_set identify i/o command set\0A\00", align 1
@.str.384 = private unnamed_addr constant [52 x i8] c"pci_nvme_identify_cmd_set identify i/o command set\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS_DSTATE = external global i16, align 2
@.str.385 = private unnamed_addr constant [75 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_identify_cns identify, invalid cns=0x%x\0A\00", align 1
@.str.386 = private unnamed_addr constant [62 x i8] c"pci_nvme_err_invalid_identify_cns identify, invalid cns=0x%x\0A\00", align 1
@.str.387 = private unnamed_addr constant [3 x i8] c"ns\00", align 1
@__PRETTY_FUNCTION__.nvme_set_feature = private unnamed_addr constant [53 x i8] c"uint16_t nvme_set_feature(NvmeCtrl *, NvmeRequest *)\00", align 1
@_TRACE_PCI_NVME_SETFEAT_DSTATE = external global i16, align 2
@.str.388 = private unnamed_addr constant [78 x i8] c"%d@%zu.%06zu:pci_nvme_setfeat cid %u nsid 0x%x fid 0x%x save 0x%x cdw11 0x%x\0A\00", align 1
@.str.389 = private unnamed_addr constant [65 x i8] c"pci_nvme_setfeat cid %u nsid 0x%x fid 0x%x save 0x%x cdw11 0x%x\0A\00", align 1
@nvme_feature_cap = internal constant <{ [31 x i32], [225 x i32] }> <{ [31 x i32] [i32 0, i32 0, i32 0, i32 0, i32 4, i32 6, i32 4, i32 4, i32 0, i32 0, i32 0, i32 4, i32 0, i32 0, i32 4, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 4, i32 0, i32 0, i32 4, i32 0, i32 0, i32 0, i32 4, i32 6], [225 x i32] zeroinitializer }>, align 16
@nvme_feature_support = internal constant <{ [31 x i8], [225 x i8] }> <{ [31 x i8] c"\00\01\01\00\01\01\01\01\01\01\01\01\00\00\01\00\00\00\00\00\00\00\01\00\00\01\00\00\00\01\01", [225 x i8] zeroinitializer }>, align 16
@_TRACE_PCI_NVME_SETFEAT_NUMQ_DSTATE = external global i16, align 2
@.str.392 = private unnamed_addr constant [111 x i8] c"%d@%zu.%06zu:pci_nvme_setfeat_numq requested cq_count=%d sq_count=%d, responding with cq_count=%d sq_count=%d\0A\00", align 1
@.str.393 = private unnamed_addr constant [98 x i8] c"pci_nvme_setfeat_numq requested cq_count=%d sq_count=%d, responding with cq_count=%d sq_count=%d\0A\00", align 1
@_TRACE_PCI_NVME_ERR_INVALID_IOCSCI_DSTATE = external global i16, align 2
@.str.394 = private unnamed_addr constant [87 x i8] c"%d@%zu.%06zu:pci_nvme_err_invalid_iocsci unsupported command set combination index %u\0A\00", align 1
@.str.395 = private unnamed_addr constant [74 x i8] c"pci_nvme_err_invalid_iocsci unsupported command set combination index %u\0A\00", align 1
@__PRETTY_FUNCTION__.nvme_set_feature_fdp_events = private unnamed_addr constant [81 x i8] c"uint16_t nvme_set_feature_fdp_events(NvmeCtrl *, NvmeNamespace *, NvmeRequest *)\00", align 1
@nvme_get_feature.nvme_feature_default = internal constant <{ i32, i32, [254 x i32] }> <{ i32 0, i32 7, [254 x i32] zeroinitializer }>, align 16
@.str.396 = private unnamed_addr constant [8 x i8] c"enabled\00", align 1
@.str.397 = private unnamed_addr constant [9 x i8] c"disabled\00", align 1
@_TRACE_PCI_NVME_GETFEAT_DSTATE = external global i16, align 2
@.str.398 = private unnamed_addr constant [77 x i8] c"%d@%zu.%06zu:pci_nvme_getfeat cid %u nsid 0x%x fid 0x%x sel 0x%x cdw11 0x%x\0A\00", align 1
@.str.399 = private unnamed_addr constant [64 x i8] c"pci_nvme_getfeat cid %u nsid 0x%x fid 0x%x sel 0x%x cdw11 0x%x\0A\00", align 1
@_TRACE_PCI_NVME_GETFEAT_VWCACHE_DSTATE = external global i16, align 2
@.str.400 = private unnamed_addr constant [83 x i8] c"%d@%zu.%06zu:pci_nvme_getfeat_vwcache get feature volatile write cache, result=%s\0A\00", align 1
@.str.401 = private unnamed_addr constant [70 x i8] c"pci_nvme_getfeat_vwcache get feature volatile write cache, result=%s\0A\00", align 1
@__const.nvme_get_feature_fdp._v = private unnamed_addr constant %struct.anon.50 { i8 1, [3 x i8] undef }, align 4
@__const.nvme_get_feature_fdp._v.402 = private unnamed_addr constant %struct.anon.51 { i8 0, [3 x i8] undef }, align 4
@.str.403 = private unnamed_addr constant [4 x i8] c"ruh\00", align 1
@__PRETTY_FUNCTION__.nvme_get_feature_fdp_events = private unnamed_addr constant [93 x i8] c"uint16_t nvme_get_feature_fdp_events(NvmeCtrl *, NvmeNamespace *, NvmeRequest *, uint32_t *)\00", align 1
@_TRACE_PCI_NVME_GETFEAT_NUMQ_DSTATE = external global i16, align 2
@.str.404 = private unnamed_addr constant [76 x i8] c"%d@%zu.%06zu:pci_nvme_getfeat_numq get feature number of queues, result=%d\0A\00", align 1
@.str.405 = private unnamed_addr constant [63 x i8] c"pci_nvme_getfeat_numq get feature number of queues, result=%d\0A\00", align 1
@_TRACE_PCI_NVME_AER_DSTATE = external global i16, align 2
@.str.406 = private unnamed_addr constant [34 x i8] c"%d@%zu.%06zu:pci_nvme_aer cid %u\0A\00", align 1
@.str.407 = private unnamed_addr constant [21 x i8] c"pci_nvme_aer cid %u\0A\00", align 1
@_TRACE_PCI_NVME_AER_AERL_EXCEEDED_DSTATE = external global i16, align 2
@.str.408 = private unnamed_addr constant [55 x i8] c"%d@%zu.%06zu:pci_nvme_aer_aerl_exceeded aerl exceeded\0A\00", align 1
@.str.409 = private unnamed_addr constant [42 x i8] c"pci_nvme_aer_aerl_exceeded aerl exceeded\0A\00", align 1
@_TRACE_PCI_NVME_NS_ATTACHMENT_DSTATE = external global i16, align 2
@.str.410 = private unnamed_addr constant [54 x i8] c"%d@%zu.%06zu:pci_nvme_ns_attachment cid %u, sel=0x%x\0A\00", align 1
@.str.411 = private unnamed_addr constant [41 x i8] c"pci_nvme_ns_attachment cid %u, sel=0x%x\0A\00", align 1
@nvme_cse_iocs_none = internal constant [256 x i32] zeroinitializer, align 16
@.str.412 = private unnamed_addr constant [3 x i8] c"VI\00", align 1
@.str.413 = private unnamed_addr constant [3 x i8] c"VQ\00", align 1
@_TRACE_PCI_NVME_VIRT_MNGMT_DSTATE = external global i16, align 2
@.str.414 = private unnamed_addr constant [71 x i8] c"%d@%zu.%06zu:pci_nvme_virt_mngmt cid %u, act=0x%x, ctrlid=%u %s nr=%u\0A\00", align 1
@.str.415 = private unnamed_addr constant [58 x i8] c"pci_nvme_virt_mngmt cid %u, act=0x%x, ctrlid=%u %s nr=%u\0A\00", align 1
@__func__.nvme_virt_set_state = private unnamed_addr constant [20 x i8] c"nvme_virt_set_state\00", align 1
@_TRACE_PCI_NVME_DBBUF_CONFIG_DSTATE = external global i16, align 2
@.str.416 = private unnamed_addr constant [66 x i8] c"%d@%zu.%06zu:pci_nvme_dbbuf_config dbs_addr=0x%lx eis_addr=0x%lx\0A\00", align 1
@.str.417 = private unnamed_addr constant [53 x i8] c"pci_nvme_dbbuf_config dbs_addr=0x%lx eis_addr=0x%lx\0A\00", align 1
@nvme_format_aiocb_info = internal constant %struct.AIOCBInfo { ptr @nvme_format_cancel, i64 96 }, align 8
@__PRETTY_FUNCTION__.nvme_format_ns_cb = private unnamed_addr constant [36 x i8] c"void nvme_format_ns_cb(void *, int)\00", align 1
@_TRACE_PCI_NVME_FORMAT_SET_DSTATE = external global i16, align 2
@.str.418 = private unnamed_addr constant [71 x i8] c"%d@%zu.%06zu:pci_nvme_format_set nsid %u lbaf %u mset %u pi %u pil %u\0A\00", align 1
@.str.419 = private unnamed_addr constant [58 x i8] c"pci_nvme_format_set nsid %u lbaf %u mset %u pi %u pil %u\0A\00", align 1
@_TRACE_PCI_NVME_UPDATE_SQ_EVENTIDX_DSTATE = external global i16, align 2
@.str.420 = private unnamed_addr constant [66 x i8] c"%d@%zu.%06zu:pci_nvme_update_sq_eventidx sqid %u new_eventidx %u\0A\00", align 1
@.str.421 = private unnamed_addr constant [53 x i8] c"pci_nvme_update_sq_eventidx sqid %u new_eventidx %u\0A\00", align 1
@_TRACE_PCI_NVME_SETFEAT_TIMESTAMP_DSTATE = external global i16, align 2
@.str.422 = private unnamed_addr constant [71 x i8] c"%d@%zu.%06zu:pci_nvme_setfeat_timestamp set feature timestamp = 0x%lx\0A\00", align 1
@.str.423 = private unnamed_addr constant [58 x i8] c"pci_nvme_setfeat_timestamp set feature timestamp = 0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_ERR_STARTFAIL_DSTATE = external global i16, align 2
@.str.424 = private unnamed_addr constant [74 x i8] c"%d@%zu.%06zu:pci_nvme_err_startfail setting controller enable bit failed\0A\00", align 1
@.str.425 = private unnamed_addr constant [61 x i8] c"pci_nvme_err_startfail setting controller enable bit failed\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_START_SUCCESS_DSTATE = external global i16, align 2
@.str.426 = private unnamed_addr constant [82 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_start_success setting controller enable bit succeeded\0A\00", align 1
@.str.427 = private unnamed_addr constant [69 x i8] c"pci_nvme_mmio_start_success setting controller enable bit succeeded\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_STOPPED_DSTATE = external global i16, align 2
@.str.428 = private unnamed_addr constant [66 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_stopped cleared controller enable bit\0A\00", align 1
@.str.429 = private unnamed_addr constant [53 x i8] c"pci_nvme_mmio_stopped cleared controller enable bit\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_DSTATE = external global i16, align 2
@.str.430 = private unnamed_addr constant [123 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_ssreset_w1c_unsupported attempted to W1C CSTS.NSSRO but CAP.NSSRS is zero (not supported)\0A\00", align 1
@.str.431 = private unnamed_addr constant [110 x i8] c"pci_nvme_ub_mmiowr_ssreset_w1c_unsupported attempted to W1C CSTS.NSSRO but CAP.NSSRS is zero (not supported)\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS_DSTATE = external global i16, align 2
@.str.432 = private unnamed_addr constant [95 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_ro_csts attempted to set a read only bit of controller status\0A\00", align 1
@.str.433 = private unnamed_addr constant [82 x i8] c"pci_nvme_ub_mmiowr_ro_csts attempted to set a read only bit of controller status\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_DSTATE = external global i16, align 2
@.str.434 = private unnamed_addr constant [121 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_ssreset_unsupported attempted NVM subsystem reset but CAP.NSSRS is zero (not supported)\0A\00", align 1
@.str.435 = private unnamed_addr constant [108 x i8] c"pci_nvme_ub_mmiowr_ssreset_unsupported attempted NVM subsystem reset but CAP.NSSRS is zero (not supported)\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_AQATTR_DSTATE = external global i16, align 2
@.str.436 = private unnamed_addr constant [76 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_aqattr wrote MMIO, admin queue attributes=0x%lx\0A\00", align 1
@.str.437 = private unnamed_addr constant [63 x i8] c"pci_nvme_mmio_aqattr wrote MMIO, admin queue attributes=0x%lx\0A\00", align 1
@__func__.stn_le_p = private unnamed_addr constant [9 x i8] c"stn_le_p\00", align 1
@_TRACE_PCI_NVME_MMIO_ASQADDR_DSTATE = external global i16, align 2
@.str.438 = private unnamed_addr constant [85 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_asqaddr wrote MMIO, admin submission queue address=0x%lx\0A\00", align 1
@.str.439 = private unnamed_addr constant [72 x i8] c"pci_nvme_mmio_asqaddr wrote MMIO, admin submission queue address=0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_ASQADDR_HI_DSTATE = external global i16, align 2
@.str.440 = private unnamed_addr constant [109 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_asqaddr_hi wrote MMIO, admin submission queue high half=0x%lx, new_address=0x%lx\0A\00", align 1
@.str.441 = private unnamed_addr constant [96 x i8] c"pci_nvme_mmio_asqaddr_hi wrote MMIO, admin submission queue high half=0x%lx, new_address=0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_ACQADDR_DSTATE = external global i16, align 2
@.str.442 = private unnamed_addr constant [85 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_acqaddr wrote MMIO, admin completion queue address=0x%lx\0A\00", align 1
@.str.443 = private unnamed_addr constant [72 x i8] c"pci_nvme_mmio_acqaddr wrote MMIO, admin completion queue address=0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_ACQADDR_HI_DSTATE = external global i16, align 2
@.str.444 = private unnamed_addr constant [109 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_acqaddr_hi wrote MMIO, admin completion queue high half=0x%lx, new_address=0x%lx\0A\00", align 1
@.str.445 = private unnamed_addr constant [96 x i8] c"pci_nvme_mmio_acqaddr_hi wrote MMIO, admin completion queue high half=0x%lx, new_address=0x%lx\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED_DSTATE = external global i16, align 2
@.str.446 = private unnamed_addr constant [110 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_cmbloc_reserved invalid write to reserved CMBLOC when CMBSZ is zero, ignored\0A\00", align 1
@.str.447 = private unnamed_addr constant [97 x i8] c"pci_nvme_ub_mmiowr_cmbloc_reserved invalid write to reserved CMBLOC when CMBSZ is zero, ignored\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY_DSTATE = external global i16, align 2
@.str.448 = private unnamed_addr constant [90 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_cmbsz_readonly invalid write to read only CMBSZ, ignored\0A\00", align 1
@.str.449 = private unnamed_addr constant [77 x i8] c"pci_nvme_ub_mmiowr_cmbsz_readonly invalid write to read only CMBSZ, ignored\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY_DSTATE = external global i16, align 2
@.str.450 = private unnamed_addr constant [92 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrcap_readonly invalid write to read only PMRCAP, ignored\0A\00", align 1
@.str.451 = private unnamed_addr constant [79 x i8] c"pci_nvme_ub_mmiowr_pmrcap_readonly invalid write to read only PMRCAP, ignored\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY_DSTATE = external global i16, align 2
@.str.452 = private unnamed_addr constant [92 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrsts_readonly invalid write to read only PMRSTS, ignored\0A\00", align 1
@.str.453 = private unnamed_addr constant [79 x i8] c"pci_nvme_ub_mmiowr_pmrsts_readonly invalid write to read only PMRSTS, ignored\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY_DSTATE = external global i16, align 2
@.str.454 = private unnamed_addr constant [92 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrebs_readonly invalid write to read only PMREBS, ignored\0A\00", align 1
@.str.455 = private unnamed_addr constant [79 x i8] c"pci_nvme_ub_mmiowr_pmrebs_readonly invalid write to read only PMREBS, ignored\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY_DSTATE = external global i16, align 2
@.str.456 = private unnamed_addr constant [94 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrswtp_readonly invalid write to read only PMRSWTP, ignored\0A\00", align 1
@.str.457 = private unnamed_addr constant [81 x i8] c"pci_nvme_ub_mmiowr_pmrswtp_readonly invalid write to read only PMRSWTP, ignored\0A\00", align 1
@_TRACE_PCI_NVME_UB_MMIOWR_INVALID_DSTATE = external global i16, align 2
@.str.458 = private unnamed_addr constant [86 x i8] c"%d@%zu.%06zu:pci_nvme_ub_mmiowr_invalid invalid MMIO write, offset=0x%lx, data=0x%lx\0A\00", align 1
@.str.459 = private unnamed_addr constant [73 x i8] c"pci_nvme_ub_mmiowr_invalid invalid MMIO write, offset=0x%lx, data=0x%lx\0A\00", align 1
@.str.460 = private unnamed_addr constant [95 x i8] c"pci_nvme_ub_db_wr_misaligned in %s: doorbell write not 32-bit aligned, offset=0x%lx, ignoring\0A\00", align 1
@__func__.nvme_process_db = private unnamed_addr constant [16 x i8] c"nvme_process_db\00", align 1
@.str.461 = private unnamed_addr constant [110 x i8] c"pci_nvme_ub_db_wr_invalid_cq in %s: completion queue doorbell write for nonexistent queue, sqid=%u, ignoring\0A\00", align 1
@.str.462 = private unnamed_addr constant [129 x i8] c"pci_nvme_ub_db_wr_invalid_cqhead in %s: completion queue doorbell write value beyond queue size, sqid=%u, new_head=%u, ignoring\0A\00", align 1
@.str.463 = private unnamed_addr constant [110 x i8] c"pci_nvme_ub_db_wr_invalid_sq in %s: submission queue doorbell write for nonexistent queue, sqid=%u, ignoring\0A\00", align 1
@.str.464 = private unnamed_addr constant [129 x i8] c"pci_nvme_ub_db_wr_invalid_sqtail in %s: submission queue doorbell write value beyond queue size, sqid=%u, new_tail=%u, ignoring\0A\00", align 1
@_TRACE_PCI_NVME_UB_DB_WR_MISALIGNED_DSTATE = external global i16, align 2
@.str.465 = private unnamed_addr constant [101 x i8] c"%d@%zu.%06zu:pci_nvme_ub_db_wr_misaligned doorbell write not 32-bit aligned, offset=0x%lx, ignoring\0A\00", align 1
@.str.466 = private unnamed_addr constant [88 x i8] c"pci_nvme_ub_db_wr_misaligned doorbell write not 32-bit aligned, offset=0x%lx, ignoring\0A\00", align 1
@_TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ_DSTATE = external global i16, align 2
@.str.467 = private unnamed_addr constant [116 x i8] c"%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_cq completion queue doorbell write for nonexistent queue, cqid=%u, ignoring\0A\00", align 1
@.str.468 = private unnamed_addr constant [103 x i8] c"pci_nvme_ub_db_wr_invalid_cq completion queue doorbell write for nonexistent queue, cqid=%u, ignoring\0A\00", align 1
@_TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD_DSTATE = external global i16, align 2
@.str.469 = private unnamed_addr constant [135 x i8] c"%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_cqhead completion queue doorbell write value beyond queue size, cqid=%u, new_head=%u, ignoring\0A\00", align 1
@.str.470 = private unnamed_addr constant [122 x i8] c"pci_nvme_ub_db_wr_invalid_cqhead completion queue doorbell write value beyond queue size, cqid=%u, new_head=%u, ignoring\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_DOORBELL_CQ_DSTATE = external global i16, align 2
@.str.471 = private unnamed_addr constant [60 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_doorbell_cq cqid %u new_head %u\0A\00", align 1
@.str.472 = private unnamed_addr constant [47 x i8] c"pci_nvme_mmio_doorbell_cq cqid %u new_head %u\0A\00", align 1
@_TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ_DSTATE = external global i16, align 2
@.str.473 = private unnamed_addr constant [116 x i8] c"%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_sq submission queue doorbell write for nonexistent queue, sqid=%u, ignoring\0A\00", align 1
@.str.474 = private unnamed_addr constant [103 x i8] c"pci_nvme_ub_db_wr_invalid_sq submission queue doorbell write for nonexistent queue, sqid=%u, ignoring\0A\00", align 1
@_TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL_DSTATE = external global i16, align 2
@.str.475 = private unnamed_addr constant [135 x i8] c"%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_sqtail submission queue doorbell write value beyond queue size, sqid=%u, new_head=%u, ignoring\0A\00", align 1
@.str.476 = private unnamed_addr constant [122 x i8] c"pci_nvme_ub_db_wr_invalid_sqtail submission queue doorbell write value beyond queue size, sqid=%u, new_head=%u, ignoring\0A\00", align 1
@_TRACE_PCI_NVME_MMIO_DOORBELL_SQ_DSTATE = external global i16, align 2
@.str.477 = private unnamed_addr constant [60 x i8] c"%d@%zu.%06zu:pci_nvme_mmio_doorbell_sq sqid %u new_tail %u\0A\00", align 1
@.str.478 = private unnamed_addr constant [47 x i8] c"pci_nvme_mmio_doorbell_sq sqid %u new_tail %u\0A\00", align 1
@.str.479 = private unnamed_addr constant [57 x i8] c"table_size > 0 && table_size <= pci_dev->msix_entries_nr\00", align 1
@__PRETTY_FUNCTION__.nvme_update_msixcap_ts = private unnamed_addr constant [51 x i8] c"void nvme_update_msixcap_ts(PCIDevice *, uint32_t)\00", align 1
@.str.480 = private unnamed_addr constant [5 x i8] c"mask\00", align 1
@.str.481 = private unnamed_addr constant [99 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/hw/pci/pci.h\00", align 1
@__PRETTY_FUNCTION__.pci_set_word_by_mask = private unnamed_addr constant [57 x i8] c"void pci_set_word_by_mask(uint8_t *, uint16_t, uint16_t)\00", align 1
@nvme_cmb_ops = internal constant %struct.MemoryRegionOps { ptr @nvme_cmb_read, ptr @nvme_cmb_write, ptr null, ptr null, i32 2, %struct.anon.34 zeroinitializer, %struct.anon.35 { i32 1, i32 8, i8 0 } }, align 8
@.str.482 = private unnamed_addr constant [9 x i8] c"nvme-cmb\00", align 1
@.str.483 = private unnamed_addr constant [15 x i8] c"QEMU NVMe Ctrl\00", align 1
@.str.484 = private unnamed_addr constant [7 x i8] c"8.1.94\00", align 1
@.str.485 = private unnamed_addr constant [24 x i8] c"nqn.2019-08.org.qemu:%s\00", align 1
@__func__.nvme_sriov_pre_write_ctrl = private unnamed_addr constant [26 x i8] c"nvme_sriov_pre_write_ctrl\00", align 1
@__func__.nvme_exit = private unnamed_addr constant [10 x i8] c"nvme_exit\00", align 1
@.str.486 = private unnamed_addr constant [6 x i8] c"drive\00", align 1
@qdev_prop_drive = external constant %struct.PropertyInfo, align 8
@.str.487 = private unnamed_addr constant [17 x i8] c"backend_defaults\00", align 1
@qdev_prop_on_off_auto = external constant %struct.PropertyInfo, align 8
@.str.488 = private unnamed_addr constant [19 x i8] c"logical_block_size\00", align 1
@qdev_prop_blocksize = external constant %struct.PropertyInfo, align 8
@.str.489 = private unnamed_addr constant [20 x i8] c"physical_block_size\00", align 1
@.str.490 = private unnamed_addr constant [12 x i8] c"min_io_size\00", align 1
@qdev_prop_size32 = external constant %struct.PropertyInfo, align 8
@.str.491 = private unnamed_addr constant [12 x i8] c"opt_io_size\00", align 1
@.str.492 = private unnamed_addr constant [20 x i8] c"discard_granularity\00", align 1
@.str.493 = private unnamed_addr constant [12 x i8] c"write-cache\00", align 1
@.str.494 = private unnamed_addr constant [9 x i8] c"share-rw\00", align 1
@qdev_prop_bool = external constant %struct.PropertyInfo, align 8
@.str.495 = private unnamed_addr constant [16 x i8] c"account-invalid\00", align 1
@.str.496 = private unnamed_addr constant [15 x i8] c"account-failed\00", align 1
@.str.497 = private unnamed_addr constant [7 x i8] c"pmrdev\00", align 1
@qdev_prop_link = external constant %struct.PropertyInfo, align 8
@.str.498 = private unnamed_addr constant [15 x i8] c"memory-backend\00", align 1
@.str.499 = private unnamed_addr constant [7 x i8] c"subsys\00", align 1
@.str.500 = private unnamed_addr constant [12 x i8] c"nvme-subsys\00", align 1
@.str.501 = private unnamed_addr constant [7 x i8] c"serial\00", align 1
@qdev_prop_string = external constant %struct.PropertyInfo, align 8
@.str.502 = private unnamed_addr constant [12 x i8] c"cmb_size_mb\00", align 1
@qdev_prop_uint32 = external constant %struct.PropertyInfo, align 8
@.str.503 = private unnamed_addr constant [11 x i8] c"num_queues\00", align 1
@.str.504 = private unnamed_addr constant [13 x i8] c"max_ioqpairs\00", align 1
@.str.505 = private unnamed_addr constant [11 x i8] c"msix_qsize\00", align 1
@qdev_prop_uint16 = external constant %struct.PropertyInfo, align 8
@.str.506 = private unnamed_addr constant [5 x i8] c"aerl\00", align 1
@qdev_prop_uint8 = external constant %struct.PropertyInfo, align 8
@.str.507 = private unnamed_addr constant [15 x i8] c"aer_max_queued\00", align 1
@.str.508 = private unnamed_addr constant [5 x i8] c"mdts\00", align 1
@.str.509 = private unnamed_addr constant [4 x i8] c"vsl\00", align 1
@.str.510 = private unnamed_addr constant [13 x i8] c"use-intel-id\00", align 1
@.str.511 = private unnamed_addr constant [11 x i8] c"legacy-cmb\00", align 1
@.str.512 = private unnamed_addr constant [10 x i8] c"ioeventfd\00", align 1
@.str.513 = private unnamed_addr constant [11 x i8] c"zoned.zasl\00", align 1
@.str.514 = private unnamed_addr constant [22 x i8] c"zoned.auto_transition\00", align 1
@.str.515 = private unnamed_addr constant [14 x i8] c"sriov_max_vfs\00", align 1
@.str.516 = private unnamed_addr constant [18 x i8] c"sriov_vq_flexible\00", align 1
@.str.517 = private unnamed_addr constant [18 x i8] c"sriov_vi_flexible\00", align 1
@.str.518 = private unnamed_addr constant [20 x i8] c"sriov_max_vi_per_vf\00", align 1
@.str.519 = private unnamed_addr constant [20 x i8] c"sriov_max_vq_per_vf\00", align 1
@__func__.nvme_pci_reset = private unnamed_addr constant [15 x i8] c"nvme_pci_reset\00", align 1
@_TRACE_PCI_NVME_PCI_RESET_DSTATE = external global i16, align 2
@.str.520 = private unnamed_addr constant [58 x i8] c"%d@%zu.%06zu:pci_nvme_pci_reset PCI Function Level Reset\0A\00", align 1
@.str.521 = private unnamed_addr constant [45 x i8] c"pci_nvme_pci_reset PCI Function Level Reset\0A\00", align 1
@.str.522 = private unnamed_addr constant [4 x i8] c"bus\00", align 1
@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 65535, ptr @do_qemu_init_nvme_register_types, ptr null }]
@.str.523 = private unnamed_addr constant [16 x i8] c"no_coroutine_fn\00", section "llvm.metadata"
@.str.524 = private unnamed_addr constant [103 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/block-io.h\00", section "llvm.metadata"
@.str.525 = private unnamed_addr constant [19 x i8] c"coroutine_mixed_fn\00", section "llvm.metadata"
@.str.526 = private unnamed_addr constant [112 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/sysemu/block-backend-io.h\00", section "llvm.metadata"
@llvm.global.annotations = appending global [4 x { ptr, ptr, ptr, i32, ptr }] [{ ptr, ptr, ptr, i32, ptr } { ptr @bdrv_block_status, ptr @.str.523, ptr @.str.524, i32 135, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_block_status, ptr @.str.525, ptr @.str.524, i32 135, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_flush, ptr @.str.523, ptr @.str.526, i32 215, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_flush, ptr @.str.525, ptr @.str.526, i32 215, ptr null }], section "llvm.metadata"

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @nvme_map_dptr(ptr noundef %n, ptr noundef %sg, i64 noundef %len, ptr noundef %cmd) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %sg.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %cmd.addr = alloca ptr, align 8
  %prp1 = alloca i64, align 8
  %prp2 = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %sg, ptr %sg.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  %0 = load ptr, ptr %cmd.addr, align 8
  %flags = getelementptr inbounds %struct.NvmeCmd, ptr %0, i32 0, i32 1
  %1 = load i8, ptr %flags, align 1
  %conv = zext i8 %1 to i32
  %shr = ashr i32 %conv, 6
  %and = and i32 %shr, 3
  switch i32 %and, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb7
    i32 2, label %sw.bb7
  ]

sw.bb:                                            ; preds = %entry
  %2 = load ptr, ptr %cmd.addr, align 8
  %dptr = getelementptr inbounds %struct.NvmeCmd, ptr %2, i32 0, i32 6
  %prp11 = getelementptr inbounds %struct.anon, ptr %dptr, i32 0, i32 0
  %3 = load i64, ptr %prp11, align 1
  %call = call i64 @le64_to_cpu(i64 noundef %3)
  store i64 %call, ptr %prp1, align 8
  %4 = load ptr, ptr %cmd.addr, align 8
  %dptr2 = getelementptr inbounds %struct.NvmeCmd, ptr %4, i32 0, i32 6
  %prp23 = getelementptr inbounds %struct.anon, ptr %dptr2, i32 0, i32 1
  %5 = load i64, ptr %prp23, align 1
  %call4 = call i64 @le64_to_cpu(i64 noundef %5)
  store i64 %call4, ptr %prp2, align 8
  %6 = load ptr, ptr %n.addr, align 8
  %7 = load ptr, ptr %sg.addr, align 8
  %8 = load i64, ptr %prp1, align 8
  %9 = load i64, ptr %prp2, align 8
  %10 = load i64, ptr %len.addr, align 8
  %conv5 = trunc i64 %10 to i32
  %call6 = call zeroext i16 @nvme_map_prp(ptr noundef %6, ptr noundef %7, i64 noundef %8, i64 noundef %9, i32 noundef %conv5)
  store i16 %call6, ptr %retval, align 2
  br label %return

sw.bb7:                                           ; preds = %entry, %entry
  %11 = load ptr, ptr %n.addr, align 8
  %12 = load ptr, ptr %sg.addr, align 8
  %13 = load ptr, ptr %cmd.addr, align 8
  %dptr8 = getelementptr inbounds %struct.NvmeCmd, ptr %13, i32 0, i32 6
  %14 = load i64, ptr %len.addr, align 8
  %15 = load ptr, ptr %cmd.addr, align 8
  %16 = getelementptr inbounds { i64, i64 }, ptr %dptr8, i32 0, i32 0
  %17 = load i64, ptr %16, align 1
  %18 = getelementptr inbounds { i64, i64 }, ptr %dptr8, i32 0, i32 1
  %19 = load i64, ptr %18, align 1
  %call9 = call zeroext i16 @nvme_map_sgl(ptr noundef %11, ptr noundef %12, i64 %17, i64 %19, i64 noundef %14, ptr noundef %15)
  store i16 %call9, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %entry
  store i16 2, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.default, %sw.bb7, %sw.bb
  %20 = load i16, ptr %retval, align 2
  ret i16 %20
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @le64_to_cpu(i64 noundef %v) #0 {
entry:
  %v.addr = alloca i64, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load i64, ptr %v.addr, align 8
  ret i64 %0
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_map_prp(ptr noundef %n, ptr noundef %sg, i64 noundef %prp1, i64 noundef %prp2, i32 noundef %len) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %sg.addr = alloca ptr, align 8
  %prp1.addr = alloca i64, align 8
  %prp2.addr = alloca i64, align 8
  %len.addr = alloca i32, align 4
  %trans_len = alloca i64, align 8
  %_a9 = alloca i64, align 8
  %_b10 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %num_prps = alloca i32, align 4
  %status = alloca i16, align 2
  %ret = alloca i32, align 4
  %prp_list = alloca ptr, align 8
  %nents = alloca i32, align 4
  %prp_trans = alloca i32, align 4
  %i = alloca i32, align 4
  %_a11 = alloca i32, align 4
  %_b12 = alloca i32, align 4
  %tmp28 = alloca i32, align 4
  %prp_ent = alloca i64, align 8
  %_a13 = alloca i32, align 4
  %_b14 = alloca i32, align 4
  %tmp69 = alloca i32, align 4
  %_a15 = alloca i32, align 4
  %_b16 = alloca i32, align 4
  %tmp101 = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %sg, ptr %sg.addr, align 8
  store i64 %prp1, ptr %prp1.addr, align 8
  store i64 %prp2, ptr %prp2.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  %0 = load ptr, ptr %n.addr, align 8
  %page_size = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 8
  %1 = load i32, ptr %page_size, align 4
  %conv = zext i32 %1 to i64
  %2 = load i64, ptr %prp1.addr, align 8
  %3 = load ptr, ptr %n.addr, align 8
  %page_size1 = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 8
  %4 = load i32, ptr %page_size1, align 4
  %conv2 = zext i32 %4 to i64
  %rem = urem i64 %2, %conv2
  %sub = sub i64 %conv, %rem
  store i64 %sub, ptr %trans_len, align 8
  %5 = load i32, ptr %len.addr, align 4
  %conv3 = zext i32 %5 to i64
  store i64 %conv3, ptr %_a9, align 8
  %6 = load i64, ptr %trans_len, align 8
  store i64 %6, ptr %_b10, align 8
  %7 = load i64, ptr %_a9, align 8
  %8 = load i64, ptr %_b10, align 8
  %cmp = icmp ult i64 %7, %8
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %9 = load i64, ptr %_a9, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %10 = load i64, ptr %_b10, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %9, %cond.true ], [ %10, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %11 = load i64, ptr %tmp, align 8
  store i64 %11, ptr %trans_len, align 8
  %12 = load i32, ptr %len.addr, align 4
  %13 = load ptr, ptr %n.addr, align 8
  %page_bits = getelementptr inbounds %struct.NvmeCtrl, ptr %13, i32 0, i32 9
  %14 = load i16, ptr %page_bits, align 16
  %conv5 = zext i16 %14 to i32
  %shr = lshr i32 %12, %conv5
  %add = add i32 %shr, 1
  store i32 %add, ptr %num_prps, align 4
  %15 = load i64, ptr %trans_len, align 8
  %16 = load i32, ptr %len.addr, align 4
  %17 = load i64, ptr %prp1.addr, align 8
  %18 = load i64, ptr %prp2.addr, align 8
  %19 = load i32, ptr %num_prps, align 4
  call void @trace_pci_nvme_map_prp(i64 noundef %15, i32 noundef %16, i64 noundef %17, i64 noundef %18, i32 noundef %19)
  %20 = load ptr, ptr %n.addr, align 8
  %21 = load ptr, ptr %sg.addr, align 8
  %22 = load ptr, ptr %n.addr, align 8
  %23 = load i64, ptr %prp1.addr, align 8
  %call = call zeroext i1 @nvme_addr_is_dma(ptr noundef %22, i64 noundef %23)
  call void @nvme_sg_init(ptr noundef %20, ptr noundef %21, i1 noundef zeroext %call)
  %24 = load ptr, ptr %n.addr, align 8
  %25 = load ptr, ptr %sg.addr, align 8
  %26 = load i64, ptr %prp1.addr, align 8
  %27 = load i64, ptr %trans_len, align 8
  %call6 = call zeroext i16 @nvme_map_addr(ptr noundef %24, ptr noundef %25, i64 noundef %26, i64 noundef %27)
  store i16 %call6, ptr %status, align 2
  %28 = load i16, ptr %status, align 2
  %tobool = icmp ne i16 %28, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  br label %unmap

if.end:                                           ; preds = %cond.end
  %29 = load i64, ptr %trans_len, align 8
  %30 = load i32, ptr %len.addr, align 4
  %conv7 = zext i32 %30 to i64
  %sub8 = sub i64 %conv7, %29
  %conv9 = trunc i64 %sub8 to i32
  store i32 %conv9, ptr %len.addr, align 4
  %31 = load i32, ptr %len.addr, align 4
  %tobool10 = icmp ne i32 %31, 0
  br i1 %tobool10, label %if.then11, label %if.end135

if.then11:                                        ; preds = %if.end
  %32 = load i32, ptr %len.addr, align 4
  %33 = load ptr, ptr %n.addr, align 8
  %page_size12 = getelementptr inbounds %struct.NvmeCtrl, ptr %33, i32 0, i32 8
  %34 = load i32, ptr %page_size12, align 4
  %cmp13 = icmp ugt i32 %32, %34
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.then11
  %35 = load ptr, ptr %n.addr, align 8
  %max_prp_ents = getelementptr inbounds %struct.NvmeCtrl, ptr %35, i32 0, i32 10
  %36 = load i16, ptr %max_prp_ents, align 2
  %conv16 = zext i16 %36 to i64
  %call17 = call noalias ptr @g_malloc_n(i64 noundef %conv16, i64 noundef 8) #11
  store ptr %call17, ptr %prp_list, align 8
  store i32 0, ptr %i, align 4
  %37 = load ptr, ptr %n.addr, align 8
  %page_size18 = getelementptr inbounds %struct.NvmeCtrl, ptr %37, i32 0, i32 8
  %38 = load i32, ptr %page_size18, align 4
  %conv19 = zext i32 %38 to i64
  %39 = load i64, ptr %prp2.addr, align 8
  %40 = load ptr, ptr %n.addr, align 8
  %page_size20 = getelementptr inbounds %struct.NvmeCtrl, ptr %40, i32 0, i32 8
  %41 = load i32, ptr %page_size20, align 4
  %sub21 = sub i32 %41, 1
  %conv22 = zext i32 %sub21 to i64
  %and = and i64 %39, %conv22
  %sub23 = sub i64 %conv19, %and
  %shr24 = lshr i64 %sub23, 3
  %conv25 = trunc i64 %shr24 to i32
  store i32 %conv25, ptr %nents, align 4
  %42 = load ptr, ptr %n.addr, align 8
  %max_prp_ents26 = getelementptr inbounds %struct.NvmeCtrl, ptr %42, i32 0, i32 10
  %43 = load i16, ptr %max_prp_ents26, align 2
  %conv27 = zext i16 %43 to i32
  store i32 %conv27, ptr %_a11, align 4
  %44 = load i32, ptr %nents, align 4
  store i32 %44, ptr %_b12, align 4
  %45 = load i32, ptr %_a11, align 4
  %46 = load i32, ptr %_b12, align 4
  %cmp29 = icmp ult i32 %45, %46
  br i1 %cmp29, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %if.then15
  %47 = load i32, ptr %_a11, align 4
  br label %cond.end33

cond.false32:                                     ; preds = %if.then15
  %48 = load i32, ptr %_b12, align 4
  br label %cond.end33

cond.end33:                                       ; preds = %cond.false32, %cond.true31
  %cond34 = phi i32 [ %47, %cond.true31 ], [ %48, %cond.false32 ]
  store i32 %cond34, ptr %tmp28, align 4
  %49 = load i32, ptr %tmp28, align 4
  %conv35 = zext i32 %49 to i64
  %mul = mul i64 %conv35, 8
  %conv36 = trunc i64 %mul to i32
  store i32 %conv36, ptr %prp_trans, align 4
  %50 = load ptr, ptr %n.addr, align 8
  %51 = load i64, ptr %prp2.addr, align 8
  %52 = load ptr, ptr %prp_list, align 8
  %53 = load i32, ptr %prp_trans, align 4
  %call37 = call i32 @nvme_addr_read(ptr noundef %50, i64 noundef %51, ptr noundef %52, i32 noundef %53)
  store i32 %call37, ptr %ret, align 4
  %54 = load i32, ptr %ret, align 4
  %tobool38 = icmp ne i32 %54, 0
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %cond.end33
  %55 = load i64, ptr %prp2.addr, align 8
  call void @trace_pci_nvme_err_addr_read(i64 noundef %55)
  store i16 4, ptr %status, align 2
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end40:                                         ; preds = %cond.end33
  br label %while.cond

while.cond:                                       ; preds = %if.end112, %if.end40
  %56 = load i32, ptr %len.addr, align 4
  %cmp41 = icmp ne i32 %56, 0
  br i1 %cmp41, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %57 = load ptr, ptr %prp_list, align 8
  %58 = load i32, ptr %i, align 4
  %idxprom = sext i32 %58 to i64
  %arrayidx = getelementptr i64, ptr %57, i64 %idxprom
  %59 = load i64, ptr %arrayidx, align 8
  %call43 = call i64 @le64_to_cpu(i64 noundef %59)
  store i64 %call43, ptr %prp_ent, align 8
  %60 = load i32, ptr %i, align 4
  %61 = load i32, ptr %nents, align 4
  %sub44 = sub i32 %61, 1
  %cmp45 = icmp eq i32 %60, %sub44
  br i1 %cmp45, label %land.lhs.true, label %if.end86

land.lhs.true:                                    ; preds = %while.body
  %62 = load i32, ptr %len.addr, align 4
  %63 = load ptr, ptr %n.addr, align 8
  %page_size47 = getelementptr inbounds %struct.NvmeCtrl, ptr %63, i32 0, i32 8
  %64 = load i32, ptr %page_size47, align 4
  %cmp48 = icmp ugt i32 %62, %64
  br i1 %cmp48, label %if.then50, label %if.end86

if.then50:                                        ; preds = %land.lhs.true
  %65 = load i64, ptr %prp_ent, align 8
  %66 = load ptr, ptr %n.addr, align 8
  %page_size51 = getelementptr inbounds %struct.NvmeCtrl, ptr %66, i32 0, i32 8
  %67 = load i32, ptr %page_size51, align 4
  %sub52 = sub i32 %67, 1
  %conv53 = zext i32 %sub52 to i64
  %and54 = and i64 %65, %conv53
  %tobool55 = icmp ne i64 %and54, 0
  %lnot = xor i1 %tobool55, true
  %lnot56 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot56 to i32
  %conv57 = sext i32 %lnot.ext to i64
  %tobool58 = icmp ne i64 %conv57, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.then50
  %68 = load i64, ptr %prp_ent, align 8
  call void @trace_pci_nvme_err_invalid_prplist_ent(i64 noundef %68)
  store i16 16403, ptr %status, align 2
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end60:                                         ; preds = %if.then50
  store i32 0, ptr %i, align 4
  %69 = load i32, ptr %len.addr, align 4
  %70 = load ptr, ptr %n.addr, align 8
  %page_size61 = getelementptr inbounds %struct.NvmeCtrl, ptr %70, i32 0, i32 8
  %71 = load i32, ptr %page_size61, align 4
  %add62 = add i32 %69, %71
  %sub63 = sub i32 %add62, 1
  %72 = load ptr, ptr %n.addr, align 8
  %page_bits64 = getelementptr inbounds %struct.NvmeCtrl, ptr %72, i32 0, i32 9
  %73 = load i16, ptr %page_bits64, align 16
  %conv65 = zext i16 %73 to i32
  %shr66 = lshr i32 %sub63, %conv65
  store i32 %shr66, ptr %nents, align 4
  %74 = load i32, ptr %nents, align 4
  store i32 %74, ptr %_a13, align 4
  %75 = load ptr, ptr %n.addr, align 8
  %max_prp_ents67 = getelementptr inbounds %struct.NvmeCtrl, ptr %75, i32 0, i32 10
  %76 = load i16, ptr %max_prp_ents67, align 2
  %conv68 = zext i16 %76 to i32
  store i32 %conv68, ptr %_b14, align 4
  %77 = load i32, ptr %_a13, align 4
  %78 = load i32, ptr %_b14, align 4
  %cmp70 = icmp ult i32 %77, %78
  br i1 %cmp70, label %cond.true72, label %cond.false73

cond.true72:                                      ; preds = %if.end60
  %79 = load i32, ptr %_a13, align 4
  br label %cond.end74

cond.false73:                                     ; preds = %if.end60
  %80 = load i32, ptr %_b14, align 4
  br label %cond.end74

cond.end74:                                       ; preds = %cond.false73, %cond.true72
  %cond75 = phi i32 [ %79, %cond.true72 ], [ %80, %cond.false73 ]
  store i32 %cond75, ptr %tmp69, align 4
  %81 = load i32, ptr %tmp69, align 4
  store i32 %81, ptr %nents, align 4
  %82 = load i32, ptr %nents, align 4
  %conv76 = zext i32 %82 to i64
  %mul77 = mul i64 %conv76, 8
  %conv78 = trunc i64 %mul77 to i32
  store i32 %conv78, ptr %prp_trans, align 4
  %83 = load ptr, ptr %n.addr, align 8
  %84 = load i64, ptr %prp_ent, align 8
  %85 = load ptr, ptr %prp_list, align 8
  %86 = load i32, ptr %prp_trans, align 4
  %call79 = call i32 @nvme_addr_read(ptr noundef %83, i64 noundef %84, ptr noundef %85, i32 noundef %86)
  store i32 %call79, ptr %ret, align 4
  %87 = load i32, ptr %ret, align 4
  %tobool80 = icmp ne i32 %87, 0
  br i1 %tobool80, label %if.then81, label %if.end82

if.then81:                                        ; preds = %cond.end74
  %88 = load i64, ptr %prp_ent, align 8
  call void @trace_pci_nvme_err_addr_read(i64 noundef %88)
  store i16 4, ptr %status, align 2
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end82:                                         ; preds = %cond.end74
  %89 = load ptr, ptr %prp_list, align 8
  %90 = load i32, ptr %i, align 4
  %idxprom83 = sext i32 %90 to i64
  %arrayidx84 = getelementptr i64, ptr %89, i64 %idxprom83
  %91 = load i64, ptr %arrayidx84, align 8
  %call85 = call i64 @le64_to_cpu(i64 noundef %91)
  store i64 %call85, ptr %prp_ent, align 8
  br label %if.end86

if.end86:                                         ; preds = %if.end82, %land.lhs.true, %while.body
  %92 = load i64, ptr %prp_ent, align 8
  %93 = load ptr, ptr %n.addr, align 8
  %page_size87 = getelementptr inbounds %struct.NvmeCtrl, ptr %93, i32 0, i32 8
  %94 = load i32, ptr %page_size87, align 4
  %sub88 = sub i32 %94, 1
  %conv89 = zext i32 %sub88 to i64
  %and90 = and i64 %92, %conv89
  %tobool91 = icmp ne i64 %and90, 0
  %lnot92 = xor i1 %tobool91, true
  %lnot94 = xor i1 %lnot92, true
  %lnot.ext95 = zext i1 %lnot94 to i32
  %conv96 = sext i32 %lnot.ext95 to i64
  %tobool97 = icmp ne i64 %conv96, 0
  br i1 %tobool97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %if.end86
  %95 = load i64, ptr %prp_ent, align 8
  call void @trace_pci_nvme_err_invalid_prplist_ent(i64 noundef %95)
  store i16 16403, ptr %status, align 2
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end99:                                         ; preds = %if.end86
  %96 = load i32, ptr %len.addr, align 4
  store i32 %96, ptr %_a15, align 4
  %97 = load ptr, ptr %n.addr, align 8
  %page_size100 = getelementptr inbounds %struct.NvmeCtrl, ptr %97, i32 0, i32 8
  %98 = load i32, ptr %page_size100, align 4
  store i32 %98, ptr %_b16, align 4
  %99 = load i32, ptr %_a15, align 4
  %100 = load i32, ptr %_b16, align 4
  %cmp102 = icmp ult i32 %99, %100
  br i1 %cmp102, label %cond.true104, label %cond.false105

cond.true104:                                     ; preds = %if.end99
  %101 = load i32, ptr %_a15, align 4
  br label %cond.end106

cond.false105:                                    ; preds = %if.end99
  %102 = load i32, ptr %_b16, align 4
  br label %cond.end106

cond.end106:                                      ; preds = %cond.false105, %cond.true104
  %cond107 = phi i32 [ %101, %cond.true104 ], [ %102, %cond.false105 ]
  store i32 %cond107, ptr %tmp101, align 4
  %103 = load i32, ptr %tmp101, align 4
  %conv108 = zext i32 %103 to i64
  store i64 %conv108, ptr %trans_len, align 8
  %104 = load ptr, ptr %n.addr, align 8
  %105 = load ptr, ptr %sg.addr, align 8
  %106 = load i64, ptr %prp_ent, align 8
  %107 = load i64, ptr %trans_len, align 8
  %call109 = call zeroext i16 @nvme_map_addr(ptr noundef %104, ptr noundef %105, i64 noundef %106, i64 noundef %107)
  store i16 %call109, ptr %status, align 2
  %108 = load i16, ptr %status, align 2
  %tobool110 = icmp ne i16 %108, 0
  br i1 %tobool110, label %if.then111, label %if.end112

if.then111:                                       ; preds = %cond.end106
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end112:                                        ; preds = %cond.end106
  %109 = load i64, ptr %trans_len, align 8
  %110 = load i32, ptr %len.addr, align 4
  %conv113 = zext i32 %110 to i64
  %sub114 = sub i64 %conv113, %109
  %conv115 = trunc i64 %sub114 to i32
  store i32 %conv115, ptr %len.addr, align 4
  %111 = load i32, ptr %i, align 4
  %inc = add i32 %111, 1
  store i32 %inc, ptr %i, align 4
  br label %while.cond, !llvm.loop !5

while.end:                                        ; preds = %while.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %while.end, %if.then111, %if.then98, %if.then81, %if.then59, %if.then39
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %prp_list)
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 2, label %unmap
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %if.end134

if.else:                                          ; preds = %if.then11
  %112 = load i64, ptr %prp2.addr, align 8
  %113 = load ptr, ptr %n.addr, align 8
  %page_size116 = getelementptr inbounds %struct.NvmeCtrl, ptr %113, i32 0, i32 8
  %114 = load i32, ptr %page_size116, align 4
  %sub117 = sub i32 %114, 1
  %conv118 = zext i32 %sub117 to i64
  %and119 = and i64 %112, %conv118
  %tobool120 = icmp ne i64 %and119, 0
  %lnot121 = xor i1 %tobool120, true
  %lnot123 = xor i1 %lnot121, true
  %lnot.ext124 = zext i1 %lnot123 to i32
  %conv125 = sext i32 %lnot.ext124 to i64
  %tobool126 = icmp ne i64 %conv125, 0
  br i1 %tobool126, label %if.then127, label %if.end128

if.then127:                                       ; preds = %if.else
  %115 = load i64, ptr %prp2.addr, align 8
  call void @trace_pci_nvme_err_invalid_prp2_align(i64 noundef %115)
  store i16 16403, ptr %status, align 2
  br label %unmap

if.end128:                                        ; preds = %if.else
  %116 = load ptr, ptr %n.addr, align 8
  %117 = load ptr, ptr %sg.addr, align 8
  %118 = load i64, ptr %prp2.addr, align 8
  %119 = load i32, ptr %len.addr, align 4
  %conv129 = zext i32 %119 to i64
  %call130 = call zeroext i16 @nvme_map_addr(ptr noundef %116, ptr noundef %117, i64 noundef %118, i64 noundef %conv129)
  store i16 %call130, ptr %status, align 2
  %120 = load i16, ptr %status, align 2
  %tobool131 = icmp ne i16 %120, 0
  br i1 %tobool131, label %if.then132, label %if.end133

if.then132:                                       ; preds = %if.end128
  br label %unmap

if.end133:                                        ; preds = %if.end128
  br label %if.end134

if.end134:                                        ; preds = %if.end133, %cleanup.cont
  br label %if.end135

if.end135:                                        ; preds = %if.end134, %if.end
  store i16 0, ptr %retval, align 2
  br label %return

unmap:                                            ; preds = %if.then132, %if.then127, %cleanup, %if.then
  %121 = load ptr, ptr %sg.addr, align 8
  call void @nvme_sg_unmap(ptr noundef %121)
  %122 = load i16, ptr %status, align 2
  store i16 %122, ptr %retval, align 2
  br label %return

return:                                           ; preds = %unmap, %if.end135
  %123 = load i16, ptr %retval, align 2
  ret i16 %123

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_map_sgl(ptr noundef %n, ptr noundef %sg, i64 %sgl.coerce0, i64 %sgl.coerce1, i64 noundef %len, ptr noundef %cmd) #0 {
entry:
  %retval = alloca i16, align 2
  %sgl = alloca %struct.NvmeSglDescriptor, align 1
  %n.addr = alloca ptr, align 8
  %sg.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %cmd.addr = alloca ptr, align 8
  %segment = alloca [256 x %struct.NvmeSglDescriptor], align 16
  %sgld = alloca ptr, align 8
  %last_sgld = alloca ptr, align 8
  %nsgld = alloca i64, align 8
  %seg_len = alloca i32, align 4
  %status = alloca i16, align 2
  %addr = alloca i64, align 8
  %ret = alloca i32, align 4
  %0 = getelementptr inbounds { i64, i64 }, ptr %sgl, i32 0, i32 0
  store i64 %sgl.coerce0, ptr %0, align 1
  %1 = getelementptr inbounds { i64, i64 }, ptr %sgl, i32 0, i32 1
  store i64 %sgl.coerce1, ptr %1, align 1
  store ptr %n, ptr %n.addr, align 8
  store ptr %sg, ptr %sg.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  store ptr %sgl, ptr %sgld, align 8
  %addr1 = getelementptr inbounds %struct.NvmeSglDescriptor, ptr %sgl, i32 0, i32 0
  %2 = load i64, ptr %addr1, align 1
  %call = call i64 @le64_to_cpu(i64 noundef %2)
  store i64 %call, ptr %addr, align 8
  %type = getelementptr inbounds %struct.NvmeSglDescriptor, ptr %sgl, i32 0, i32 3
  %3 = load i8, ptr %type, align 1
  %conv = zext i8 %3 to i32
  %shr = ashr i32 %conv, 4
  %and = and i32 %shr, 15
  %conv2 = trunc i32 %and to i8
  %4 = load i64, ptr %len.addr, align 8
  call void @trace_pci_nvme_map_sgl(i8 noundef zeroext %conv2, i64 noundef %4)
  %5 = load ptr, ptr %n.addr, align 8
  %6 = load ptr, ptr %sg.addr, align 8
  %7 = load ptr, ptr %n.addr, align 8
  %8 = load i64, ptr %addr, align 8
  %call3 = call zeroext i1 @nvme_addr_is_dma(ptr noundef %7, i64 noundef %8)
  call void @nvme_sg_init(ptr noundef %5, ptr noundef %6, i1 noundef zeroext %call3)
  %type4 = getelementptr inbounds %struct.NvmeSglDescriptor, ptr %sgl, i32 0, i32 3
  %9 = load i8, ptr %type4, align 1
  %conv5 = zext i8 %9 to i32
  %shr6 = ashr i32 %conv5, 4
  %and7 = and i32 %shr6, 15
  %cmp = icmp eq i32 %and7, 0
  br i1 %cmp, label %if.then, label %if.end11

if.then:                                          ; preds = %entry
  %10 = load ptr, ptr %n.addr, align 8
  %11 = load ptr, ptr %sg.addr, align 8
  %12 = load ptr, ptr %sgld, align 8
  %13 = load ptr, ptr %cmd.addr, align 8
  %call9 = call zeroext i16 @nvme_map_sgl_data(ptr noundef %10, ptr noundef %11, ptr noundef %12, i64 noundef 1, ptr noundef %len.addr, ptr noundef %13)
  store i16 %call9, ptr %status, align 2
  %14 = load i16, ptr %status, align 2
  %tobool = icmp ne i16 %14, 0
  br i1 %tobool, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  br label %unmap

if.end:                                           ; preds = %if.then
  br label %out

if.end11:                                         ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %if.end76, %if.end11
  %15 = load ptr, ptr %sgld, align 8
  %type12 = getelementptr inbounds %struct.NvmeSglDescriptor, ptr %15, i32 0, i32 3
  %16 = load i8, ptr %type12, align 1
  %conv13 = zext i8 %16 to i32
  %shr14 = ashr i32 %conv13, 4
  %and15 = and i32 %shr14, 15
  switch i32 %and15, label %sw.default [
    i32 2, label %sw.bb
    i32 3, label %sw.bb
  ]

sw.bb:                                            ; preds = %for.cond, %for.cond
  br label %sw.epilog

sw.default:                                       ; preds = %for.cond
  store i16 16397, ptr %retval, align 2
  br label %return

sw.epilog:                                        ; preds = %sw.bb
  %17 = load ptr, ptr %sgld, align 8
  %len16 = getelementptr inbounds %struct.NvmeSglDescriptor, ptr %17, i32 0, i32 1
  %18 = load i32, ptr %len16, align 1
  %call17 = call i32 @le32_to_cpu(i32 noundef %18)
  store i32 %call17, ptr %seg_len, align 4
  %19 = load i32, ptr %seg_len, align 4
  %tobool18 = icmp ne i32 %19, 0
  br i1 %tobool18, label %lor.lhs.false, label %if.then21

lor.lhs.false:                                    ; preds = %sw.epilog
  %20 = load i32, ptr %seg_len, align 4
  %and19 = and i32 %20, 15
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %lor.lhs.false, %sw.epilog
  store i16 16397, ptr %retval, align 2
  br label %return

if.end22:                                         ; preds = %lor.lhs.false
  %21 = load i64, ptr %addr, align 8
  %sub = sub i64 -1, %21
  %22 = load i32, ptr %seg_len, align 4
  %conv23 = zext i32 %22 to i64
  %cmp24 = icmp ult i64 %sub, %conv23
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end22
  store i16 16399, ptr %retval, align 2
  br label %return

if.end27:                                         ; preds = %if.end22
  %23 = load i32, ptr %seg_len, align 4
  %conv28 = zext i32 %23 to i64
  %div = udiv i64 %conv28, 16
  store i64 %div, ptr %nsgld, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end39, %if.end27
  %24 = load i64, ptr %nsgld, align 8
  %cmp29 = icmp ugt i64 %24, 256
  br i1 %cmp29, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %25 = load ptr, ptr %n.addr, align 8
  %26 = load i64, ptr %addr, align 8
  %arraydecay = getelementptr inbounds [256 x %struct.NvmeSglDescriptor], ptr %segment, i64 0, i64 0
  %call31 = call i32 @nvme_addr_read(ptr noundef %25, i64 noundef %26, ptr noundef %arraydecay, i32 noundef 4096)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %while.body
  %27 = load i64, ptr %addr, align 8
  call void @trace_pci_nvme_err_addr_read(i64 noundef %27)
  store i16 4, ptr %status, align 2
  br label %unmap

if.end34:                                         ; preds = %while.body
  %28 = load ptr, ptr %n.addr, align 8
  %29 = load ptr, ptr %sg.addr, align 8
  %arraydecay35 = getelementptr inbounds [256 x %struct.NvmeSglDescriptor], ptr %segment, i64 0, i64 0
  %30 = load ptr, ptr %cmd.addr, align 8
  %call36 = call zeroext i16 @nvme_map_sgl_data(ptr noundef %28, ptr noundef %29, ptr noundef %arraydecay35, i64 noundef 256, ptr noundef %len.addr, ptr noundef %30)
  store i16 %call36, ptr %status, align 2
  %31 = load i16, ptr %status, align 2
  %tobool37 = icmp ne i16 %31, 0
  br i1 %tobool37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end34
  br label %unmap

if.end39:                                         ; preds = %if.end34
  %32 = load i64, ptr %nsgld, align 8
  %sub40 = sub i64 %32, 256
  store i64 %sub40, ptr %nsgld, align 8
  %33 = load i64, ptr %addr, align 8
  %add = add i64 %33, 4096
  store i64 %add, ptr %addr, align 8
  br label %while.cond, !llvm.loop !7

while.end:                                        ; preds = %while.cond
  %34 = load ptr, ptr %n.addr, align 8
  %35 = load i64, ptr %addr, align 8
  %arraydecay41 = getelementptr inbounds [256 x %struct.NvmeSglDescriptor], ptr %segment, i64 0, i64 0
  %36 = load i64, ptr %nsgld, align 8
  %mul = mul i64 %36, 16
  %conv42 = trunc i64 %mul to i32
  %call43 = call i32 @nvme_addr_read(ptr noundef %34, i64 noundef %35, ptr noundef %arraydecay41, i32 noundef %conv42)
  store i32 %call43, ptr %ret, align 4
  %37 = load i32, ptr %ret, align 4
  %tobool44 = icmp ne i32 %37, 0
  br i1 %tobool44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %while.end
  %38 = load i64, ptr %addr, align 8
  call void @trace_pci_nvme_err_addr_read(i64 noundef %38)
  store i16 4, ptr %status, align 2
  br label %unmap

if.end46:                                         ; preds = %while.end
  %39 = load i64, ptr %nsgld, align 8
  %sub47 = sub i64 %39, 1
  %arrayidx = getelementptr [256 x %struct.NvmeSglDescriptor], ptr %segment, i64 0, i64 %sub47
  store ptr %arrayidx, ptr %last_sgld, align 8
  %40 = load ptr, ptr %last_sgld, align 8
  %type48 = getelementptr inbounds %struct.NvmeSglDescriptor, ptr %40, i32 0, i32 3
  %41 = load i8, ptr %type48, align 1
  %conv49 = zext i8 %41 to i32
  %shr50 = ashr i32 %conv49, 4
  %and51 = and i32 %shr50, 15
  %cmp52 = icmp eq i32 %and51, 0
  br i1 %cmp52, label %if.then54, label %if.end60

if.then54:                                        ; preds = %if.end46
  %42 = load ptr, ptr %n.addr, align 8
  %43 = load ptr, ptr %sg.addr, align 8
  %arraydecay55 = getelementptr inbounds [256 x %struct.NvmeSglDescriptor], ptr %segment, i64 0, i64 0
  %44 = load i64, ptr %nsgld, align 8
  %45 = load ptr, ptr %cmd.addr, align 8
  %call56 = call zeroext i16 @nvme_map_sgl_data(ptr noundef %42, ptr noundef %43, ptr noundef %arraydecay55, i64 noundef %44, ptr noundef %len.addr, ptr noundef %45)
  store i16 %call56, ptr %status, align 2
  %46 = load i16, ptr %status, align 2
  %tobool57 = icmp ne i16 %46, 0
  br i1 %tobool57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %if.then54
  br label %unmap

if.end59:                                         ; preds = %if.then54
  br label %out

if.end60:                                         ; preds = %if.end46
  %47 = load ptr, ptr %sgld, align 8
  %type61 = getelementptr inbounds %struct.NvmeSglDescriptor, ptr %47, i32 0, i32 3
  %48 = load i8, ptr %type61, align 1
  %conv62 = zext i8 %48 to i32
  %shr63 = ashr i32 %conv62, 4
  %and64 = and i32 %shr63, 15
  %cmp65 = icmp eq i32 %and64, 3
  br i1 %cmp65, label %if.then67, label %if.end68

if.then67:                                        ; preds = %if.end60
  store i16 16397, ptr %status, align 2
  br label %unmap

if.end68:                                         ; preds = %if.end60
  %49 = load ptr, ptr %last_sgld, align 8
  store ptr %49, ptr %sgld, align 8
  %50 = load ptr, ptr %sgld, align 8
  %addr69 = getelementptr inbounds %struct.NvmeSglDescriptor, ptr %50, i32 0, i32 0
  %51 = load i64, ptr %addr69, align 1
  %call70 = call i64 @le64_to_cpu(i64 noundef %51)
  store i64 %call70, ptr %addr, align 8
  %52 = load ptr, ptr %n.addr, align 8
  %53 = load ptr, ptr %sg.addr, align 8
  %arraydecay71 = getelementptr inbounds [256 x %struct.NvmeSglDescriptor], ptr %segment, i64 0, i64 0
  %54 = load i64, ptr %nsgld, align 8
  %sub72 = sub i64 %54, 1
  %55 = load ptr, ptr %cmd.addr, align 8
  %call73 = call zeroext i16 @nvme_map_sgl_data(ptr noundef %52, ptr noundef %53, ptr noundef %arraydecay71, i64 noundef %sub72, ptr noundef %len.addr, ptr noundef %55)
  store i16 %call73, ptr %status, align 2
  %56 = load i16, ptr %status, align 2
  %tobool74 = icmp ne i16 %56, 0
  br i1 %tobool74, label %if.then75, label %if.end76

if.then75:                                        ; preds = %if.end68
  br label %unmap

if.end76:                                         ; preds = %if.end68
  br label %for.cond

out:                                              ; preds = %if.end59, %if.end
  %57 = load i64, ptr %len.addr, align 8
  %tobool77 = icmp ne i64 %57, 0
  br i1 %tobool77, label %if.then78, label %if.end79

if.then78:                                        ; preds = %out
  store i16 16399, ptr %status, align 2
  br label %unmap

if.end79:                                         ; preds = %out
  store i16 0, ptr %retval, align 2
  br label %return

unmap:                                            ; preds = %if.then78, %if.then75, %if.then67, %if.then58, %if.then45, %if.then38, %if.then33, %if.then10
  %58 = load ptr, ptr %sg.addr, align 8
  call void @nvme_sg_unmap(ptr noundef %58)
  %59 = load i16, ptr %status, align 2
  store i16 %59, ptr %retval, align 2
  br label %return

return:                                           ; preds = %unmap, %if.end79, %if.then26, %if.then21, %sw.default
  %60 = load i16, ptr %retval, align 2
  ret i16 %60
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @nvme_bounce_data(ptr noundef %n, ptr noundef %ptr, i32 noundef %len, i32 noundef %dir, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %dir.addr = alloca i32, align 4
  %req.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %rw = alloca ptr, align 8
  %pi = alloca i8, align 1
  %pract = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store i32 %dir, ptr %dir.addr, align 4
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %ns1, align 8
  store ptr %1, ptr %ns, align 8
  %2 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %3 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 5
  %dps = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 8
  %4 = load i8, ptr %dps, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 7
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %frombool = zext i1 %lnot2 to i8
  store i8 %frombool, ptr %pi, align 1
  %5 = load ptr, ptr %rw, align 8
  %control = getelementptr inbounds %struct.NvmeRwCmd, ptr %5, i32 0, i32 10
  %6 = load i16, ptr %control, align 1
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %6)
  %conv3 = zext i16 %call to i32
  %and4 = and i32 %conv3, 8192
  %tobool5 = icmp ne i32 %and4, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot7 = xor i1 %lnot6, true
  %frombool8 = zext i1 %lnot7 to i8
  store i8 %frombool8, ptr %pract, align 1
  %7 = load ptr, ptr %ns, align 8
  %call9 = call zeroext i1 @nvme_ns_ext(ptr noundef %7)
  br i1 %call9, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %8 = load i8, ptr %pi, align 1
  %tobool11 = trunc i8 %8 to i1
  br i1 %tobool11, label %land.lhs.true13, label %if.then

land.lhs.true13:                                  ; preds = %land.lhs.true
  %9 = load i8, ptr %pract, align 1
  %tobool14 = trunc i8 %9 to i1
  br i1 %tobool14, label %land.lhs.true16, label %if.then

land.lhs.true16:                                  ; preds = %land.lhs.true13
  %10 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %10, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %11 = load i16, ptr %ms, align 8
  %conv17 = zext i16 %11 to i64
  %12 = load ptr, ptr %ns, align 8
  %call18 = call i64 @nvme_pi_tuple_size(ptr noundef %12)
  %cmp = icmp eq i64 %conv17, %call18
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true16, %land.lhs.true13, %land.lhs.true
  %13 = load ptr, ptr %n.addr, align 8
  %14 = load ptr, ptr %req.addr, align 8
  %sg = getelementptr inbounds %struct.NvmeRequest, ptr %14, i32 0, i32 8
  %15 = load ptr, ptr %ptr.addr, align 8
  %16 = load i32, ptr %len.addr, align 4
  %17 = load ptr, ptr %ns, align 8
  %lbasz = getelementptr inbounds %struct.NvmeNamespace, ptr %17, i32 0, i32 9
  %18 = load i64, ptr %lbasz, align 8
  %conv20 = trunc i64 %18 to i32
  %19 = load ptr, ptr %ns, align 8
  %lbaf21 = getelementptr inbounds %struct.NvmeNamespace, ptr %19, i32 0, i32 7
  %ms22 = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf21, i32 0, i32 0
  %20 = load i16, ptr %ms22, align 8
  %conv23 = zext i16 %20 to i32
  %21 = load i32, ptr %dir.addr, align 4
  %call24 = call zeroext i16 @nvme_tx_interleaved(ptr noundef %13, ptr noundef %sg, ptr noundef %15, i32 noundef %16, i32 noundef %conv20, i32 noundef %conv23, i64 noundef 0, i32 noundef %21)
  store i16 %call24, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %land.lhs.true16, %entry
  %22 = load ptr, ptr %n.addr, align 8
  %23 = load ptr, ptr %req.addr, align 8
  %sg25 = getelementptr inbounds %struct.NvmeRequest, ptr %23, i32 0, i32 8
  %24 = load ptr, ptr %ptr.addr, align 8
  %25 = load i32, ptr %len.addr, align 4
  %26 = load i32, ptr %dir.addr, align 4
  %call26 = call zeroext i16 @nvme_tx(ptr noundef %22, ptr noundef %sg25, ptr noundef %24, i32 noundef %25, i32 noundef %26)
  store i16 %call26, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end, %if.then
  %27 = load i16, ptr %retval, align 2
  ret i16 %27
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @le16_to_cpu(i16 noundef zeroext %v) #0 {
entry:
  %v.addr = alloca i16, align 2
  store i16 %v, ptr %v.addr, align 2
  %0 = load i16, ptr %v.addr, align 2
  ret i16 %0
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_ns_ext(ptr noundef %ns) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 5
  %flbas = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 5
  %1 = load i8, ptr %flbas, align 2
  %conv = zext i8 %1 to i32
  %shr = ashr i32 %conv, 4
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  ret i1 %lnot1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @nvme_pi_tuple_size(ptr noundef %ns) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %pif = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 14
  %1 = load i8, ptr %pif, align 8
  %conv = zext i8 %1 to i32
  %tobool = icmp ne i32 %conv, 0
  %cond = select i1 %tobool, i32 16, i32 8
  %conv1 = sext i32 %cond to i64
  ret i64 %conv1
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_tx_interleaved(ptr noundef %n, ptr noundef %sg, ptr noundef %ptr, i32 noundef %len, i32 noundef %bytes, i32 noundef %skip_bytes, i64 noundef %offset, i32 noundef %dir) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %sg.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %bytes.addr = alloca i32, align 4
  %skip_bytes.addr = alloca i32, align 4
  %offset.addr = alloca i64, align 8
  %dir.addr = alloca i32, align 4
  %addr = alloca i64, align 8
  %trans_len = alloca i32, align 4
  %count = alloca i32, align 4
  %dma = alloca i8, align 1
  %sge_len = alloca i64, align 8
  %sg_idx = alloca i32, align 4
  %ret = alloca i32, align 4
  %_a19 = alloca i32, align 4
  %_b20 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %_a21 = alloca i64, align 8
  %_b22 = alloca i64, align 8
  %tmp23 = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %sg, ptr %sg.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store i32 %bytes, ptr %bytes.addr, align 4
  store i32 %skip_bytes, ptr %skip_bytes.addr, align 4
  store i64 %offset, ptr %offset.addr, align 8
  store i32 %dir, ptr %dir.addr, align 4
  %0 = load i32, ptr %bytes.addr, align 4
  store i32 %0, ptr %count, align 4
  %1 = load ptr, ptr %sg.addr, align 8
  %flags = getelementptr inbounds %struct.NvmeSg, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %flags, align 8
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %dma, align 1
  store i32 0, ptr %sg_idx, align 4
  %3 = load ptr, ptr %sg.addr, align 8
  %flags1 = getelementptr inbounds %struct.NvmeSg, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %flags1, align 8
  %and2 = and i32 %4, 1
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.27, ptr noundef @.str.1, i32 noundef 1292, ptr noundef @__PRETTY_FUNCTION__.nvme_tx_interleaved) #12
  unreachable

if.end:                                           ; preds = %if.then
  br label %while.cond

while.cond:                                       ; preds = %if.end60, %if.then14, %if.then10, %if.end
  %5 = load i32, ptr %len.addr, align 4
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load i8, ptr %dma, align 1
  %tobool5 = trunc i8 %6 to i1
  br i1 %tobool5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body
  %7 = load ptr, ptr %sg.addr, align 8
  %8 = getelementptr inbounds %struct.NvmeSg, ptr %7, i32 0, i32 1
  %sg6 = getelementptr inbounds %struct.QEMUSGList, ptr %8, i32 0, i32 0
  %9 = load ptr, ptr %sg6, align 8
  %10 = load i32, ptr %sg_idx, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr %struct.ScatterGatherEntry, ptr %9, i64 %idxprom
  %len7 = getelementptr inbounds %struct.ScatterGatherEntry, ptr %arrayidx, i32 0, i32 1
  %11 = load i64, ptr %len7, align 8
  br label %cond.end

cond.false:                                       ; preds = %while.body
  %12 = load ptr, ptr %sg.addr, align 8
  %13 = getelementptr inbounds %struct.NvmeSg, ptr %12, i32 0, i32 1
  %iov = getelementptr inbounds %struct.QEMUIOVector, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %iov, align 8
  %15 = load i32, ptr %sg_idx, align 4
  %idxprom8 = sext i32 %15 to i64
  %arrayidx9 = getelementptr %struct.iovec, ptr %14, i64 %idxprom8
  %iov_len = getelementptr inbounds %struct.iovec, ptr %arrayidx9, i32 0, i32 1
  %16 = load i64, ptr %iov_len, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ %16, %cond.false ]
  store i64 %cond, ptr %sge_len, align 8
  %17 = load i64, ptr %sge_len, align 8
  %18 = load i64, ptr %offset.addr, align 8
  %sub = sub i64 %17, %18
  %cmp = icmp slt i64 %sub, 0
  br i1 %cmp, label %if.then10, label %if.end12

if.then10:                                        ; preds = %cond.end
  %19 = load i64, ptr %sge_len, align 8
  %20 = load i64, ptr %offset.addr, align 8
  %sub11 = sub i64 %20, %19
  store i64 %sub11, ptr %offset.addr, align 8
  %21 = load i32, ptr %sg_idx, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %sg_idx, align 4
  br label %while.cond, !llvm.loop !8

if.end12:                                         ; preds = %cond.end
  %22 = load i64, ptr %sge_len, align 8
  %23 = load i64, ptr %offset.addr, align 8
  %cmp13 = icmp eq i64 %22, %23
  br i1 %cmp13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  store i64 0, ptr %offset.addr, align 8
  %24 = load i32, ptr %sg_idx, align 4
  %inc15 = add i32 %24, 1
  store i32 %inc15, ptr %sg_idx, align 4
  br label %while.cond, !llvm.loop !8

if.end16:                                         ; preds = %if.end12
  %25 = load i32, ptr %len.addr, align 4
  store i32 %25, ptr %_a19, align 4
  %26 = load i32, ptr %count, align 4
  store i32 %26, ptr %_b20, align 4
  %27 = load i32, ptr %_a19, align 4
  %28 = load i32, ptr %_b20, align 4
  %cmp17 = icmp ult i32 %27, %28
  br i1 %cmp17, label %cond.true18, label %cond.false19

cond.true18:                                      ; preds = %if.end16
  %29 = load i32, ptr %_a19, align 4
  br label %cond.end20

cond.false19:                                     ; preds = %if.end16
  %30 = load i32, ptr %_b20, align 4
  br label %cond.end20

cond.end20:                                       ; preds = %cond.false19, %cond.true18
  %cond21 = phi i32 [ %29, %cond.true18 ], [ %30, %cond.false19 ]
  store i32 %cond21, ptr %tmp, align 4
  %31 = load i32, ptr %tmp, align 4
  store i32 %31, ptr %trans_len, align 4
  %32 = load i32, ptr %trans_len, align 4
  %conv = zext i32 %32 to i64
  store i64 %conv, ptr %_a21, align 8
  %33 = load i64, ptr %sge_len, align 8
  %34 = load i64, ptr %offset.addr, align 8
  %sub22 = sub i64 %33, %34
  store i64 %sub22, ptr %_b22, align 8
  %35 = load i64, ptr %_a21, align 8
  %36 = load i64, ptr %_b22, align 8
  %cmp24 = icmp slt i64 %35, %36
  br i1 %cmp24, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.end20
  %37 = load i64, ptr %_a21, align 8
  br label %cond.end28

cond.false27:                                     ; preds = %cond.end20
  %38 = load i64, ptr %_b22, align 8
  br label %cond.end28

cond.end28:                                       ; preds = %cond.false27, %cond.true26
  %cond29 = phi i64 [ %37, %cond.true26 ], [ %38, %cond.false27 ]
  store i64 %cond29, ptr %tmp23, align 8
  %39 = load i64, ptr %tmp23, align 8
  %conv30 = trunc i64 %39 to i32
  store i32 %conv30, ptr %trans_len, align 4
  %40 = load i8, ptr %dma, align 1
  %tobool31 = trunc i8 %40 to i1
  br i1 %tobool31, label %if.then32, label %if.else36

if.then32:                                        ; preds = %cond.end28
  %41 = load ptr, ptr %sg.addr, align 8
  %42 = getelementptr inbounds %struct.NvmeSg, ptr %41, i32 0, i32 1
  %sg33 = getelementptr inbounds %struct.QEMUSGList, ptr %42, i32 0, i32 0
  %43 = load ptr, ptr %sg33, align 8
  %44 = load i32, ptr %sg_idx, align 4
  %idxprom34 = sext i32 %44 to i64
  %arrayidx35 = getelementptr %struct.ScatterGatherEntry, ptr %43, i64 %idxprom34
  %base = getelementptr inbounds %struct.ScatterGatherEntry, ptr %arrayidx35, i32 0, i32 0
  %45 = load i64, ptr %base, align 8
  %46 = load i64, ptr %offset.addr, align 8
  %add = add i64 %45, %46
  store i64 %add, ptr %addr, align 8
  br label %if.end41

if.else36:                                        ; preds = %cond.end28
  %47 = load ptr, ptr %sg.addr, align 8
  %48 = getelementptr inbounds %struct.NvmeSg, ptr %47, i32 0, i32 1
  %iov37 = getelementptr inbounds %struct.QEMUIOVector, ptr %48, i32 0, i32 0
  %49 = load ptr, ptr %iov37, align 8
  %50 = load i32, ptr %sg_idx, align 4
  %idxprom38 = sext i32 %50 to i64
  %arrayidx39 = getelementptr %struct.iovec, ptr %49, i64 %idxprom38
  %iov_base = getelementptr inbounds %struct.iovec, ptr %arrayidx39, i32 0, i32 0
  %51 = load ptr, ptr %iov_base, align 8
  %52 = ptrtoint ptr %51 to i64
  %53 = load i64, ptr %offset.addr, align 8
  %add40 = add i64 %52, %53
  store i64 %add40, ptr %addr, align 8
  br label %if.end41

if.end41:                                         ; preds = %if.else36, %if.then32
  %54 = load i32, ptr %dir.addr, align 4
  %cmp42 = icmp eq i32 %54, 0
  br i1 %cmp42, label %if.then44, label %if.else45

if.then44:                                        ; preds = %if.end41
  %55 = load ptr, ptr %n.addr, align 8
  %56 = load i64, ptr %addr, align 8
  %57 = load ptr, ptr %ptr.addr, align 8
  %58 = load i32, ptr %trans_len, align 4
  %call = call i32 @nvme_addr_read(ptr noundef %55, i64 noundef %56, ptr noundef %57, i32 noundef %58)
  store i32 %call, ptr %ret, align 4
  br label %if.end47

if.else45:                                        ; preds = %if.end41
  %59 = load ptr, ptr %n.addr, align 8
  %60 = load i64, ptr %addr, align 8
  %61 = load ptr, ptr %ptr.addr, align 8
  %62 = load i32, ptr %trans_len, align 4
  %call46 = call i32 @nvme_addr_write(ptr noundef %59, i64 noundef %60, ptr noundef %61, i32 noundef %62)
  store i32 %call46, ptr %ret, align 4
  br label %if.end47

if.end47:                                         ; preds = %if.else45, %if.then44
  %63 = load i32, ptr %ret, align 4
  %tobool48 = icmp ne i32 %63, 0
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end47
  store i16 4, ptr %retval, align 2
  br label %return

if.end50:                                         ; preds = %if.end47
  %64 = load i32, ptr %trans_len, align 4
  %65 = load ptr, ptr %ptr.addr, align 8
  %idx.ext = zext i32 %64 to i64
  %add.ptr = getelementptr i8, ptr %65, i64 %idx.ext
  store ptr %add.ptr, ptr %ptr.addr, align 8
  %66 = load i32, ptr %trans_len, align 4
  %67 = load i32, ptr %len.addr, align 4
  %sub51 = sub i32 %67, %66
  store i32 %sub51, ptr %len.addr, align 4
  %68 = load i32, ptr %trans_len, align 4
  %69 = load i32, ptr %count, align 4
  %sub52 = sub i32 %69, %68
  store i32 %sub52, ptr %count, align 4
  %70 = load i32, ptr %trans_len, align 4
  %conv53 = zext i32 %70 to i64
  %71 = load i64, ptr %offset.addr, align 8
  %add54 = add i64 %71, %conv53
  store i64 %add54, ptr %offset.addr, align 8
  %72 = load i32, ptr %count, align 4
  %cmp55 = icmp eq i32 %72, 0
  br i1 %cmp55, label %if.then57, label %if.end60

if.then57:                                        ; preds = %if.end50
  %73 = load i32, ptr %bytes.addr, align 4
  store i32 %73, ptr %count, align 4
  %74 = load i32, ptr %skip_bytes.addr, align 4
  %conv58 = sext i32 %74 to i64
  %75 = load i64, ptr %offset.addr, align 8
  %add59 = add i64 %75, %conv58
  store i64 %add59, ptr %offset.addr, align 8
  br label %if.end60

if.end60:                                         ; preds = %if.then57, %if.end50
  br label %while.cond, !llvm.loop !8

while.end:                                        ; preds = %while.cond
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %while.end, %if.then49
  %76 = load i16, ptr %retval, align 2
  ret i16 %76
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_tx(ptr noundef %n, ptr noundef %sg, ptr noundef %ptr, i32 noundef %len, i32 noundef %dir) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %sg.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %dir.addr = alloca i32, align 4
  %attrs = alloca %struct.MemTxAttrs, align 4
  %residual = alloca i64, align 8
  %bytes = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %sg, ptr %sg.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store i32 %dir, ptr %dir.addr, align 4
  %0 = load ptr, ptr %sg.addr, align 8
  %flags = getelementptr inbounds %struct.NvmeSg, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.27, ptr noundef @.str.1, i32 noundef 1345, ptr noundef @__PRETTY_FUNCTION__.nvme_tx) #12
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load ptr, ptr %sg.addr, align 8
  %flags1 = getelementptr inbounds %struct.NvmeSg, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %flags1, align 8
  %and2 = and i32 %3, 2
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.else17

if.then4:                                         ; preds = %if.end
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %attrs, ptr align 4 @__const.nvme_tx.attrs, i64 4, i1 false)
  %4 = load i32, ptr %dir.addr, align 4
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.then4
  %5 = load ptr, ptr %ptr.addr, align 8
  %6 = load i32, ptr %len.addr, align 4
  %conv = zext i32 %6 to i64
  %7 = load ptr, ptr %sg.addr, align 8
  %8 = getelementptr inbounds %struct.NvmeSg, ptr %7, i32 0, i32 1
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  %9 = load i32, ptr %coerce.dive, align 4
  %call = call i32 @dma_buf_write(ptr noundef %5, i64 noundef %conv, ptr noundef %residual, ptr noundef %8, i32 %9)
  br label %if.end10

if.else6:                                         ; preds = %if.then4
  %10 = load ptr, ptr %ptr.addr, align 8
  %11 = load i32, ptr %len.addr, align 4
  %conv7 = zext i32 %11 to i64
  %12 = load ptr, ptr %sg.addr, align 8
  %13 = getelementptr inbounds %struct.NvmeSg, ptr %12, i32 0, i32 1
  %coerce.dive8 = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  %14 = load i32, ptr %coerce.dive8, align 4
  %call9 = call i32 @dma_buf_read(ptr noundef %10, i64 noundef %conv7, ptr noundef %residual, ptr noundef %13, i32 %14)
  br label %if.end10

if.end10:                                         ; preds = %if.else6, %if.then5
  %15 = load i64, ptr %residual, align 8
  %tobool11 = icmp ne i64 %15, 0
  %lnot = xor i1 %tobool11, true
  %lnot12 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot12 to i32
  %conv13 = sext i32 %lnot.ext to i64
  %tobool14 = icmp ne i64 %conv13, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end10
  call void @trace_pci_nvme_err_invalid_dma()
  store i16 16386, ptr %retval, align 2
  br label %return

if.end16:                                         ; preds = %if.end10
  br label %if.end38

if.else17:                                        ; preds = %if.end
  %16 = load i32, ptr %dir.addr, align 4
  %cmp18 = icmp eq i32 %16, 0
  br i1 %cmp18, label %if.then20, label %if.else23

if.then20:                                        ; preds = %if.else17
  %17 = load ptr, ptr %sg.addr, align 8
  %18 = getelementptr inbounds %struct.NvmeSg, ptr %17, i32 0, i32 1
  %19 = load ptr, ptr %ptr.addr, align 8
  %20 = load i32, ptr %len.addr, align 4
  %conv21 = zext i32 %20 to i64
  %call22 = call i64 @qemu_iovec_to_buf(ptr noundef %18, i64 noundef 0, ptr noundef %19, i64 noundef %conv21)
  store i64 %call22, ptr %bytes, align 8
  br label %if.end26

if.else23:                                        ; preds = %if.else17
  %21 = load ptr, ptr %sg.addr, align 8
  %22 = getelementptr inbounds %struct.NvmeSg, ptr %21, i32 0, i32 1
  %23 = load ptr, ptr %ptr.addr, align 8
  %24 = load i32, ptr %len.addr, align 4
  %conv24 = zext i32 %24 to i64
  %call25 = call i64 @qemu_iovec_from_buf(ptr noundef %22, i64 noundef 0, ptr noundef %23, i64 noundef %conv24)
  store i64 %call25, ptr %bytes, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.else23, %if.then20
  %25 = load i64, ptr %bytes, align 8
  %26 = load i32, ptr %len.addr, align 4
  %conv27 = zext i32 %26 to i64
  %cmp28 = icmp ne i64 %25, %conv27
  %lnot30 = xor i1 %cmp28, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %tobool35 = icmp ne i64 %conv34, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end26
  call void @trace_pci_nvme_err_invalid_dma()
  store i16 16386, ptr %retval, align 2
  br label %return

if.end37:                                         ; preds = %if.end26
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.end16
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end38, %if.then36, %if.then15
  %27 = load i16, ptr %retval, align 2
  ret i16 %27
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @nvme_bounce_mdata(ptr noundef %n, ptr noundef %ptr, i32 noundef %len, i32 noundef %dir, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %dir.addr = alloca i32, align 4
  %req.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %status = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store i32 %dir, ptr %dir.addr, align 4
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %ns1, align 8
  store ptr %1, ptr %ns, align 8
  %2 = load ptr, ptr %ns, align 8
  %call = call zeroext i1 @nvme_ns_ext(ptr noundef %2)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %4 = load ptr, ptr %req.addr, align 8
  %sg = getelementptr inbounds %struct.NvmeRequest, ptr %4, i32 0, i32 8
  %5 = load ptr, ptr %ptr.addr, align 8
  %6 = load i32, ptr %len.addr, align 4
  %7 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %7, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %8 = load i16, ptr %ms, align 8
  %conv = zext i16 %8 to i32
  %9 = load ptr, ptr %ns, align 8
  %lbasz = getelementptr inbounds %struct.NvmeNamespace, ptr %9, i32 0, i32 9
  %10 = load i64, ptr %lbasz, align 8
  %conv2 = trunc i64 %10 to i32
  %11 = load ptr, ptr %ns, align 8
  %lbasz3 = getelementptr inbounds %struct.NvmeNamespace, ptr %11, i32 0, i32 9
  %12 = load i64, ptr %lbasz3, align 8
  %13 = load i32, ptr %dir.addr, align 4
  %call4 = call zeroext i16 @nvme_tx_interleaved(ptr noundef %3, ptr noundef %sg, ptr noundef %5, i32 noundef %6, i32 noundef %conv, i32 noundef %conv2, i64 noundef %12, i32 noundef %13)
  store i16 %call4, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %14 = load ptr, ptr %req.addr, align 8
  %sg5 = getelementptr inbounds %struct.NvmeRequest, ptr %14, i32 0, i32 8
  call void @nvme_sg_unmap(ptr noundef %sg5)
  %15 = load ptr, ptr %n.addr, align 8
  %16 = load ptr, ptr %req.addr, align 8
  %sg6 = getelementptr inbounds %struct.NvmeRequest, ptr %16, i32 0, i32 8
  %17 = load i32, ptr %len.addr, align 4
  %conv7 = zext i32 %17 to i64
  %18 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %18, i32 0, i32 6
  %call8 = call zeroext i16 @nvme_map_mptr(ptr noundef %15, ptr noundef %sg6, i64 noundef %conv7, ptr noundef %cmd)
  store i16 %call8, ptr %status, align 2
  %19 = load i16, ptr %status, align 2
  %tobool = icmp ne i16 %19, 0
  br i1 %tobool, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %20 = load i16, ptr %status, align 2
  store i16 %20, ptr %retval, align 2
  br label %return

if.end10:                                         ; preds = %if.end
  %21 = load ptr, ptr %n.addr, align 8
  %22 = load ptr, ptr %req.addr, align 8
  %sg11 = getelementptr inbounds %struct.NvmeRequest, ptr %22, i32 0, i32 8
  %23 = load ptr, ptr %ptr.addr, align 8
  %24 = load i32, ptr %len.addr, align 4
  %25 = load i32, ptr %dir.addr, align 4
  %call12 = call zeroext i16 @nvme_tx(ptr noundef %21, ptr noundef %sg11, ptr noundef %23, i32 noundef %24, i32 noundef %25)
  store i16 %call12, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end10, %if.then9, %if.then
  %26 = load i16, ptr %retval, align 2
  ret i16 %26
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_sg_unmap(ptr noundef %sg) #0 {
entry:
  %sg.addr = alloca ptr, align 8
  store ptr %sg, ptr %sg.addr, align 8
  %0 = load ptr, ptr %sg.addr, align 8
  %flags = getelementptr inbounds %struct.NvmeSg, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %sg.addr, align 8
  %flags1 = getelementptr inbounds %struct.NvmeSg, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %flags1, align 8
  %and2 = and i32 %3, 2
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %4 = load ptr, ptr %sg.addr, align 8
  %5 = getelementptr inbounds %struct.NvmeSg, ptr %4, i32 0, i32 1
  call void @qemu_sglist_destroy(ptr noundef %5)
  br label %if.end5

if.else:                                          ; preds = %if.end
  %6 = load ptr, ptr %sg.addr, align 8
  %7 = getelementptr inbounds %struct.NvmeSg, ptr %6, i32 0, i32 1
  call void @qemu_iovec_destroy(ptr noundef %7)
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then4
  %8 = load ptr, ptr %sg.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %8, i8 0, i64 48, i1 false)
  br label %return

return:                                           ; preds = %if.end5, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_map_mptr(ptr noundef %n, ptr noundef %sg, i64 noundef %len, ptr noundef %cmd) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %sg.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %cmd.addr = alloca ptr, align 8
  %psdt = alloca i32, align 4
  %mptr = alloca i64, align 8
  %status = alloca i16, align 2
  %sgl = alloca %struct.NvmeSglDescriptor, align 1
  store ptr %n, ptr %n.addr, align 8
  store ptr %sg, ptr %sg.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  %0 = load ptr, ptr %cmd.addr, align 8
  %flags = getelementptr inbounds %struct.NvmeCmd, ptr %0, i32 0, i32 1
  %1 = load i8, ptr %flags, align 1
  %conv = zext i8 %1 to i32
  %shr = ashr i32 %conv, 6
  %and = and i32 %shr, 3
  store i32 %and, ptr %psdt, align 4
  %2 = load ptr, ptr %cmd.addr, align 8
  %mptr1 = getelementptr inbounds %struct.NvmeCmd, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %mptr1, align 1
  %call = call i64 @le64_to_cpu(i64 noundef %3)
  store i64 %call, ptr %mptr, align 8
  %4 = load i32, ptr %psdt, align 4
  %cmp = icmp eq i32 %4, 2
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %n.addr, align 8
  %6 = load i64, ptr %mptr, align 8
  %call3 = call i32 @nvme_addr_read(ptr noundef %5, i64 noundef %6, ptr noundef %sgl, i32 noundef 16)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  store i16 4, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %if.then
  %7 = load ptr, ptr %n.addr, align 8
  %8 = load ptr, ptr %sg.addr, align 8
  %9 = load i64, ptr %len.addr, align 8
  %10 = load ptr, ptr %cmd.addr, align 8
  %11 = getelementptr inbounds { i64, i64 }, ptr %sgl, i32 0, i32 0
  %12 = load i64, ptr %11, align 1
  %13 = getelementptr inbounds { i64, i64 }, ptr %sgl, i32 0, i32 1
  %14 = load i64, ptr %13, align 1
  %call5 = call zeroext i16 @nvme_map_sgl(ptr noundef %7, ptr noundef %8, i64 %12, i64 %14, i64 noundef %9, ptr noundef %10)
  store i16 %call5, ptr %status, align 2
  %15 = load i16, ptr %status, align 2
  %conv6 = zext i16 %15 to i32
  %tobool7 = icmp ne i32 %conv6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %if.end
  %16 = load i16, ptr %status, align 2
  %conv8 = zext i16 %16 to i32
  %and9 = and i32 %conv8, 2047
  %cmp10 = icmp eq i32 %and9, 15
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %land.lhs.true
  store i16 16400, ptr %status, align 2
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %land.lhs.true, %if.end
  %17 = load i16, ptr %status, align 2
  store i16 %17, ptr %retval, align 2
  br label %return

if.end14:                                         ; preds = %entry
  %18 = load ptr, ptr %n.addr, align 8
  %19 = load ptr, ptr %sg.addr, align 8
  %20 = load ptr, ptr %n.addr, align 8
  %21 = load i64, ptr %mptr, align 8
  %call15 = call zeroext i1 @nvme_addr_is_dma(ptr noundef %20, i64 noundef %21)
  call void @nvme_sg_init(ptr noundef %18, ptr noundef %19, i1 noundef zeroext %call15)
  %22 = load ptr, ptr %n.addr, align 8
  %23 = load ptr, ptr %sg.addr, align 8
  %24 = load i64, ptr %mptr, align 8
  %25 = load i64, ptr %len.addr, align 8
  %call16 = call zeroext i16 @nvme_map_addr(ptr noundef %22, ptr noundef %23, i64 noundef %24, i64 noundef %25)
  store i16 %call16, ptr %status, align 2
  %26 = load i16, ptr %status, align 2
  %tobool17 = icmp ne i16 %26, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end14
  %27 = load ptr, ptr %sg.addr, align 8
  call void @nvme_sg_unmap(ptr noundef %27)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end14
  %28 = load i16, ptr %status, align 2
  store i16 %28, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end19, %if.end13, %if.then4
  %29 = load i16, ptr %retval, align 2
  ret i16 %29
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @nvme_rw_complete_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %blk = alloca ptr, align 8
  %acct = alloca ptr, align 8
  %stats = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %req, align 8
  %1 = load ptr, ptr %req, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %ns1, align 8
  store ptr %2, ptr %ns, align 8
  %3 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 1
  %blk2 = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %4 = load ptr, ptr %blk2, align 8
  store ptr %4, ptr %blk, align 8
  %5 = load ptr, ptr %req, align 8
  %acct3 = getelementptr inbounds %struct.NvmeRequest, ptr %5, i32 0, i32 7
  store ptr %acct3, ptr %acct, align 8
  %6 = load ptr, ptr %blk, align 8
  %call = call ptr @blk_get_stats(ptr noundef %6)
  store ptr %call, ptr %stats, align 8
  %7 = load ptr, ptr %req, align 8
  %call4 = call zeroext i16 @nvme_cid(ptr noundef %7)
  %8 = load ptr, ptr %blk, align 8
  %call5 = call ptr @blk_name(ptr noundef %8)
  call void @trace_pci_nvme_rw_complete_cb(i16 noundef zeroext %call4, ptr noundef %call5)
  %9 = load i32, ptr %ret.addr, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %10 = load ptr, ptr %stats, align 8
  %11 = load ptr, ptr %acct, align 8
  call void @block_acct_failed(ptr noundef %10, ptr noundef %11)
  %12 = load ptr, ptr %req, align 8
  %13 = load i32, ptr %ret.addr, align 4
  call void @nvme_aio_err(ptr noundef %12, i32 noundef %13)
  br label %if.end

if.else:                                          ; preds = %entry
  %14 = load ptr, ptr %stats, align 8
  %15 = load ptr, ptr %acct, align 8
  call void @block_acct_done(ptr noundef %14, ptr noundef %15)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %16 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %16, i32 0, i32 30
  %zoned = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 14
  %17 = load i8, ptr %zoned, align 1
  %tobool6 = trunc i8 %17 to i1
  br i1 %tobool6, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %if.end
  %18 = load ptr, ptr %req, align 8
  %call7 = call zeroext i1 @nvme_is_write(ptr noundef %18)
  br i1 %call7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %land.lhs.true
  %19 = load ptr, ptr %ns, align 8
  %20 = load ptr, ptr %req, align 8
  call void @nvme_finalize_zoned_write(ptr noundef %19, ptr noundef %20)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %land.lhs.true, %if.end
  %21 = load ptr, ptr %req, align 8
  %call10 = call ptr @nvme_cq(ptr noundef %21)
  %22 = load ptr, ptr %req, align 8
  call void @nvme_enqueue_req_completion(ptr noundef %call10, ptr noundef %22)
  ret void
}

declare ptr @blk_get_stats(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_rw_complete_cb(i16 noundef zeroext %cid, ptr noundef %blkname) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %blkname.addr = alloca ptr, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store ptr %blkname, ptr %blkname.addr, align 8
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load ptr, ptr %blkname.addr, align 8
  call void @_nocheck__trace_pci_nvme_rw_complete_cb(i16 noundef zeroext %0, ptr noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_cid(ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %req.addr = alloca ptr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 -1, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %req.addr, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 5
  %cid = getelementptr inbounds %struct.NvmeCqe, ptr %cqe, i32 0, i32 4
  %2 = load i16, ptr %cid, align 4
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %2)
  store i16 %call, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i16, ptr %retval, align 2
  ret i16 %3
}

declare ptr @blk_name(ptr noundef) #1

declare void @block_acct_failed(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_aio_err(ptr noundef %req, i32 noundef %ret) #0 {
entry:
  %req.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %status = alloca i16, align 2
  %local_err = alloca ptr, align 8
  store ptr %req, ptr %req.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  store i16 0, ptr %status, align 2
  store ptr null, ptr %local_err, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  %opcode = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 0
  %1 = load i8, ptr %opcode, align 8
  %conv = zext i8 %1 to i32
  switch i32 %conv, label %sw.default [
    i32 2, label %sw.bb
    i32 0, label %sw.bb1
    i32 1, label %sw.bb1
    i32 8, label %sw.bb1
    i32 125, label %sw.bb1
    i32 25, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  store i16 641, ptr %status, align 2
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry, %entry, %entry, %entry, %entry
  store i16 640, ptr %status, align 2
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i16 6, ptr %status, align 2
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb1, %sw.bb
  %2 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_cid(ptr noundef %2)
  %3 = load i32, ptr %ret.addr, align 4
  %sub = sub i32 0, %3
  %call2 = call ptr @strerror(i32 noundef %sub) #13
  %4 = load i16, ptr %status, align 2
  call void @trace_pci_nvme_err_aio(i16 noundef zeroext %call, ptr noundef %call2, i16 noundef zeroext %4)
  %5 = load i32, ptr %ret.addr, align 4
  %sub3 = sub i32 0, %5
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %local_err, ptr noundef @.str.1, i32 noundef 1764, ptr noundef @__func__.nvme_aio_err, i32 noundef %sub3, ptr noundef @.str.32)
  %6 = load ptr, ptr %local_err, align 8
  call void @error_report_err(ptr noundef %6)
  %7 = load ptr, ptr %req.addr, align 8
  %status4 = getelementptr inbounds %struct.NvmeRequest, ptr %7, i32 0, i32 3
  %8 = load i16, ptr %status4, align 8
  %conv5 = zext i16 %8 to i32
  %tobool = icmp ne i32 %conv5, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %sw.epilog
  %9 = load i16, ptr %status, align 2
  %conv6 = zext i16 %9 to i32
  %cmp = icmp ne i32 %conv6, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %return

if.end:                                           ; preds = %land.lhs.true, %sw.epilog
  %10 = load i16, ptr %status, align 2
  %11 = load ptr, ptr %req.addr, align 8
  %status8 = getelementptr inbounds %struct.NvmeRequest, ptr %11, i32 0, i32 3
  store i16 %10, ptr %status8, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare void @block_acct_done(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_is_write(ptr noundef %req) #0 {
entry:
  %req.addr = alloca ptr, align 8
  %rw = alloca ptr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %1 = load ptr, ptr %rw, align 8
  %opcode = getelementptr inbounds %struct.NvmeRwCmd, ptr %1, i32 0, i32 0
  %2 = load i8, ptr %opcode, align 1
  %conv = zext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 1
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load ptr, ptr %rw, align 8
  %opcode2 = getelementptr inbounds %struct.NvmeRwCmd, ptr %3, i32 0, i32 0
  %4 = load i8, ptr %opcode2, align 1
  %conv3 = zext i8 %4 to i32
  %cmp4 = icmp eq i32 %conv3, 125
  br i1 %cmp4, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %5 = load ptr, ptr %rw, align 8
  %opcode6 = getelementptr inbounds %struct.NvmeRwCmd, ptr %5, i32 0, i32 0
  %6 = load i8, ptr %opcode6, align 1
  %conv7 = zext i8 %6 to i32
  %cmp8 = icmp eq i32 %conv7, 8
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %7 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp8, %lor.rhs ]
  ret i1 %7
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_finalize_zoned_write(ptr noundef %ns, ptr noundef %req) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %rw = alloca ptr, align 8
  %zone = alloca ptr, align 8
  %slba = alloca i64, align 8
  %nlb = alloca i32, align 4
  %ezrwa = alloca i64, align 8
  %elba = alloca i64, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %1 = load ptr, ptr %rw, align 8
  %slba1 = getelementptr inbounds %struct.NvmeRwCmd, ptr %1, i32 0, i32 8
  %2 = load i64, ptr %slba1, align 1
  %call = call i64 @le64_to_cpu(i64 noundef %2)
  store i64 %call, ptr %slba, align 8
  %3 = load ptr, ptr %rw, align 8
  %nlb2 = getelementptr inbounds %struct.NvmeRwCmd, ptr %3, i32 0, i32 9
  %4 = load i16, ptr %nlb2, align 1
  %call3 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %4)
  %conv = zext i16 %call3 to i32
  %add = add i32 %conv, 1
  store i32 %add, ptr %nlb, align 4
  %5 = load ptr, ptr %ns.addr, align 8
  %6 = load i64, ptr %slba, align 8
  %call4 = call ptr @nvme_get_zone_by_slba(ptr noundef %5, i64 noundef %6)
  store ptr %call4, ptr %zone, align 8
  %7 = load ptr, ptr %zone, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.35, ptr noundef @.str.1, i32 noundef 2108, ptr noundef @__PRETTY_FUNCTION__.nvme_finalize_zoned_write) #12
  unreachable

if.end:                                           ; preds = %if.then
  %8 = load ptr, ptr %zone, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %8, i32 0, i32 0
  %za = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 2
  %9 = load i8, ptr %za, align 2
  %conv5 = zext i8 %9 to i32
  %and = and i32 %conv5, 8
  %tobool6 = icmp ne i32 %and, 0
  br i1 %tobool6, label %if.then7, label %if.end18

if.then7:                                         ; preds = %if.end
  %10 = load ptr, ptr %zone, align 8
  %w_ptr = getelementptr inbounds %struct.NvmeZone, ptr %10, i32 0, i32 1
  %11 = load i64, ptr %w_ptr, align 8
  %12 = load ptr, ptr %ns.addr, align 8
  %zns = getelementptr inbounds %struct.NvmeNamespace, ptr %12, i32 0, i32 15
  %zrwas = getelementptr inbounds %struct.anon.4, ptr %zns, i32 0, i32 0
  %13 = load i16, ptr %zrwas, align 4
  %conv8 = zext i16 %13 to i64
  %add9 = add i64 %11, %conv8
  %sub = sub i64 %add9, 1
  store i64 %sub, ptr %ezrwa, align 8
  %14 = load i64, ptr %slba, align 8
  %15 = load i32, ptr %nlb, align 4
  %conv10 = zext i32 %15 to i64
  %add11 = add i64 %14, %conv10
  %sub12 = sub i64 %add11, 1
  store i64 %sub12, ptr %elba, align 8
  %16 = load i64, ptr %elba, align 8
  %17 = load i64, ptr %ezrwa, align 8
  %cmp = icmp ugt i64 %16, %17
  br i1 %cmp, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.then7
  %18 = load ptr, ptr %ns.addr, align 8
  %19 = load ptr, ptr %zone, align 8
  %20 = load i64, ptr %elba, align 8
  %21 = load i64, ptr %ezrwa, align 8
  %sub15 = sub i64 %20, %21
  %conv16 = trunc i64 %sub15 to i32
  call void @nvme_zoned_zrwa_implicit_flush(ptr noundef %18, ptr noundef %19, i32 noundef %conv16)
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.then7
  br label %return

if.end18:                                         ; preds = %if.end
  %22 = load ptr, ptr %ns.addr, align 8
  %23 = load ptr, ptr %zone, align 8
  %24 = load i32, ptr %nlb, align 4
  call void @nvme_advance_zone_wp(ptr noundef %22, ptr noundef %23, i32 noundef %24)
  br label %return

return:                                           ; preds = %if.end18, %if.end17
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_enqueue_req_completion(ptr noundef %cq, ptr noundef %req) #0 {
entry:
  %cq.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  store ptr %cq, ptr %cq.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %cq.addr, align 8
  %cqid = getelementptr inbounds %struct.NvmeCQueue, ptr %0, i32 0, i32 2
  %1 = load i16, ptr %cqid, align 2
  %conv = zext i16 %1 to i32
  %2 = load ptr, ptr %req.addr, align 8
  %sq = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %sq, align 8
  %cqid1 = getelementptr inbounds %struct.NvmeSQueue, ptr %3, i32 0, i32 2
  %4 = load i16, ptr %cqid1, align 2
  %conv2 = zext i16 %4 to i32
  %cmp = icmp eq i32 %conv, %conv2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.44, ptr noundef @.str.1, i32 noundef 1535, ptr noundef @__PRETTY_FUNCTION__.nvme_enqueue_req_completion) #12
  unreachable

if.end:                                           ; preds = %if.then
  %5 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_cid(ptr noundef %5)
  %6 = load ptr, ptr %cq.addr, align 8
  %cqid4 = getelementptr inbounds %struct.NvmeCQueue, ptr %6, i32 0, i32 2
  %7 = load i16, ptr %cqid4, align 2
  %8 = load ptr, ptr %req.addr, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %8, i32 0, i32 5
  %result = getelementptr inbounds %struct.NvmeCqe, ptr %cqe, i32 0, i32 0
  %9 = load i32, ptr %result, align 8
  %call5 = call i32 @le32_to_cpu(i32 noundef %9)
  %10 = load ptr, ptr %req.addr, align 8
  %cqe6 = getelementptr inbounds %struct.NvmeRequest, ptr %10, i32 0, i32 5
  %dw1 = getelementptr inbounds %struct.NvmeCqe, ptr %cqe6, i32 0, i32 1
  %11 = load i32, ptr %dw1, align 4
  %call7 = call i32 @le32_to_cpu(i32 noundef %11)
  %12 = load ptr, ptr %req.addr, align 8
  %status = getelementptr inbounds %struct.NvmeRequest, ptr %12, i32 0, i32 3
  %13 = load i16, ptr %status, align 8
  call void @trace_pci_nvme_enqueue_req_completion(i16 noundef zeroext %call, i16 noundef zeroext %7, i32 noundef %call5, i32 noundef %call7, i16 noundef zeroext %13)
  %14 = load ptr, ptr %req.addr, align 8
  %status8 = getelementptr inbounds %struct.NvmeRequest, ptr %14, i32 0, i32 3
  %15 = load i16, ptr %status8, align 8
  %tobool = icmp ne i16 %15, 0
  br i1 %tobool, label %if.then9, label %if.end13

if.then9:                                         ; preds = %if.end
  %16 = load ptr, ptr %req.addr, align 8
  %call10 = call zeroext i16 @nvme_cid(ptr noundef %16)
  %17 = load ptr, ptr %req.addr, align 8
  %ns = getelementptr inbounds %struct.NvmeRequest, ptr %17, i32 0, i32 1
  %18 = load ptr, ptr %ns, align 8
  %call11 = call i32 @nvme_nsid(ptr noundef %18)
  %19 = load ptr, ptr %req.addr, align 8
  %status12 = getelementptr inbounds %struct.NvmeRequest, ptr %19, i32 0, i32 3
  %20 = load i16, ptr %status12, align 8
  %21 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %21, i32 0, i32 6
  %opcode = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 0
  %22 = load i8, ptr %opcode, align 8
  call void @trace_pci_nvme_err_req_status(i16 noundef zeroext %call10, i32 noundef %call11, i16 noundef zeroext %20, i8 noundef zeroext %22)
  br label %if.end13

if.end13:                                         ; preds = %if.then9, %if.end
  br label %do.body

do.body:                                          ; preds = %if.end13
  %23 = load ptr, ptr %req.addr, align 8
  %entry14 = getelementptr inbounds %struct.NvmeRequest, ptr %23, i32 0, i32 9
  %24 = load ptr, ptr %entry14, align 8
  %cmp15 = icmp ne ptr %24, null
  br i1 %cmp15, label %if.then17, label %if.else22

if.then17:                                        ; preds = %do.body
  %25 = load ptr, ptr %req.addr, align 8
  %entry18 = getelementptr inbounds %struct.NvmeRequest, ptr %25, i32 0, i32 9
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %entry18, i32 0, i32 1
  %26 = load ptr, ptr %tql_prev, align 8
  %27 = load ptr, ptr %req.addr, align 8
  %entry19 = getelementptr inbounds %struct.NvmeRequest, ptr %27, i32 0, i32 9
  %28 = load ptr, ptr %entry19, align 8
  %entry20 = getelementptr inbounds %struct.NvmeRequest, ptr %28, i32 0, i32 9
  %tql_prev21 = getelementptr inbounds %struct.QTailQLink, ptr %entry20, i32 0, i32 1
  store ptr %26, ptr %tql_prev21, align 8
  br label %if.end27

if.else22:                                        ; preds = %do.body
  %29 = load ptr, ptr %req.addr, align 8
  %entry23 = getelementptr inbounds %struct.NvmeRequest, ptr %29, i32 0, i32 9
  %tql_prev24 = getelementptr inbounds %struct.QTailQLink, ptr %entry23, i32 0, i32 1
  %30 = load ptr, ptr %tql_prev24, align 8
  %31 = load ptr, ptr %req.addr, align 8
  %sq25 = getelementptr inbounds %struct.NvmeRequest, ptr %31, i32 0, i32 0
  %32 = load ptr, ptr %sq25, align 8
  %out_req_list = getelementptr inbounds %struct.NvmeSQueue, ptr %32, i32 0, i32 14
  %tql_prev26 = getelementptr inbounds %struct.QTailQLink, ptr %out_req_list, i32 0, i32 1
  store ptr %30, ptr %tql_prev26, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.else22, %if.then17
  %33 = load ptr, ptr %req.addr, align 8
  %entry28 = getelementptr inbounds %struct.NvmeRequest, ptr %33, i32 0, i32 9
  %34 = load ptr, ptr %entry28, align 8
  %35 = load ptr, ptr %req.addr, align 8
  %entry29 = getelementptr inbounds %struct.NvmeRequest, ptr %35, i32 0, i32 9
  %tql_prev30 = getelementptr inbounds %struct.QTailQLink, ptr %entry29, i32 0, i32 1
  %36 = load ptr, ptr %tql_prev30, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %36, i32 0, i32 0
  store ptr %34, ptr %tql_next, align 8
  %37 = load ptr, ptr %req.addr, align 8
  %entry31 = getelementptr inbounds %struct.NvmeRequest, ptr %37, i32 0, i32 9
  %tql_prev32 = getelementptr inbounds %struct.QTailQLink, ptr %entry31, i32 0, i32 1
  store ptr null, ptr %tql_prev32, align 8
  %38 = load ptr, ptr %req.addr, align 8
  %entry33 = getelementptr inbounds %struct.NvmeRequest, ptr %38, i32 0, i32 9
  %tql_next34 = getelementptr inbounds %struct.QTailQLink, ptr %entry33, i32 0, i32 0
  store ptr null, ptr %tql_next34, align 8
  %39 = load ptr, ptr %req.addr, align 8
  %entry35 = getelementptr inbounds %struct.NvmeRequest, ptr %39, i32 0, i32 9
  store ptr null, ptr %entry35, align 8
  br label %do.end

do.end:                                           ; preds = %if.end27
  br label %do.body36

do.body36:                                        ; preds = %do.end
  %40 = load ptr, ptr %req.addr, align 8
  %entry37 = getelementptr inbounds %struct.NvmeRequest, ptr %40, i32 0, i32 9
  store ptr null, ptr %entry37, align 8
  %41 = load ptr, ptr %cq.addr, align 8
  %req_list = getelementptr inbounds %struct.NvmeCQueue, ptr %41, i32 0, i32 15
  %tql_prev38 = getelementptr inbounds %struct.QTailQLink, ptr %req_list, i32 0, i32 1
  %42 = load ptr, ptr %tql_prev38, align 8
  %43 = load ptr, ptr %req.addr, align 8
  %entry39 = getelementptr inbounds %struct.NvmeRequest, ptr %43, i32 0, i32 9
  %tql_prev40 = getelementptr inbounds %struct.QTailQLink, ptr %entry39, i32 0, i32 1
  store ptr %42, ptr %tql_prev40, align 8
  %44 = load ptr, ptr %req.addr, align 8
  %45 = load ptr, ptr %cq.addr, align 8
  %req_list41 = getelementptr inbounds %struct.NvmeCQueue, ptr %45, i32 0, i32 15
  %tql_prev42 = getelementptr inbounds %struct.QTailQLink, ptr %req_list41, i32 0, i32 1
  %46 = load ptr, ptr %tql_prev42, align 8
  %tql_next43 = getelementptr inbounds %struct.QTailQLink, ptr %46, i32 0, i32 0
  store ptr %44, ptr %tql_next43, align 8
  %47 = load ptr, ptr %req.addr, align 8
  %entry44 = getelementptr inbounds %struct.NvmeRequest, ptr %47, i32 0, i32 9
  %48 = load ptr, ptr %cq.addr, align 8
  %req_list45 = getelementptr inbounds %struct.NvmeCQueue, ptr %48, i32 0, i32 15
  %tql_prev46 = getelementptr inbounds %struct.QTailQLink, ptr %req_list45, i32 0, i32 1
  store ptr %entry44, ptr %tql_prev46, align 8
  br label %do.end47

do.end47:                                         ; preds = %do.body36
  %49 = load ptr, ptr %cq.addr, align 8
  %bh = getelementptr inbounds %struct.NvmeCQueue, ptr %49, i32 0, i32 11
  %50 = load ptr, ptr %bh, align 8
  call void @qemu_bh_schedule(ptr noundef %50)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_cq(ptr noundef %req) #0 {
entry:
  %req.addr = alloca ptr, align 8
  %sq = alloca ptr, align 8
  %n = alloca ptr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %sq1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %sq1, align 8
  store ptr %1, ptr %sq, align 8
  %2 = load ptr, ptr %sq, align 8
  %ctrl = getelementptr inbounds %struct.NvmeSQueue, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %ctrl, align 8
  store ptr %3, ptr %n, align 8
  %4 = load ptr, ptr %n, align 8
  %cq = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 37
  %5 = load ptr, ptr %cq, align 8
  %6 = load ptr, ptr %sq, align 8
  %cqid = getelementptr inbounds %struct.NvmeSQueue, ptr %6, i32 0, i32 2
  %7 = load i16, ptr %cqid, align 2
  %idxprom = zext i16 %7 to i64
  %arrayidx = getelementptr ptr, ptr %5, i64 %idxprom
  %8 = load ptr, ptr %arrayidx, align 8
  ret ptr %8
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @nvme_attach_ns(ptr noundef %n, ptr noundef %ns) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %ns.addr = alloca ptr, align 8
  %nsid = alloca i32, align 4
  %_a61 = alloca i64, align 8
  %_b62 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 30
  %nsid1 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 2
  %1 = load i32, ptr %nsid1, align 4
  store i32 %1, ptr %nsid, align 4
  %2 = load i32, ptr %nsid, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %3 = load i32, ptr %nsid, align 4
  %cmp = icmp ule i32 %3, 256
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  call void @__assert_fail(ptr noundef @.str, ptr noundef @.str.1, i32 noundef 8293, ptr noundef @__PRETTY_FUNCTION__.nvme_attach_ns) #12
  unreachable

if.end:                                           ; preds = %if.then
  %4 = load ptr, ptr %ns.addr, align 8
  %5 = load ptr, ptr %n.addr, align 8
  %namespaces = getelementptr inbounds %struct.NvmeCtrl, ptr %5, i32 0, i32 35
  %6 = load i32, ptr %nsid, align 4
  %idxprom = zext i32 %6 to i64
  %arrayidx = getelementptr [257 x ptr], ptr %namespaces, i64 0, i64 %idxprom
  store ptr %4, ptr %arrayidx, align 8
  %7 = load ptr, ptr %ns.addr, align 8
  %attached = getelementptr inbounds %struct.NvmeNamespace, ptr %7, i32 0, i32 13
  %8 = load i32, ptr %attached, align 4
  %inc = add i32 %8, 1
  store i32 %inc, ptr %attached, align 4
  %9 = load ptr, ptr %n.addr, align 8
  %dmrsl = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 31
  %10 = load i32, ptr %dmrsl, align 4
  %conv = zext i32 %10 to i64
  store i64 %conv, ptr %_a61, align 8
  %11 = load ptr, ptr %ns.addr, align 8
  %call = call i64 @nvme_l2b(ptr noundef %11, i64 noundef 1)
  %div = udiv i64 2147483136, %call
  store i64 %div, ptr %_b62, align 8
  %12 = load i64, ptr %_a61, align 8
  %cmp2 = icmp eq i64 %12, 0
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %13 = load i64, ptr %_b62, align 8
  br label %cond.end10

cond.false:                                       ; preds = %if.end
  %14 = load i64, ptr %_b62, align 8
  %cmp4 = icmp eq i64 %14, 0
  br i1 %cmp4, label %cond.true8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.false
  %15 = load i64, ptr %_b62, align 8
  %16 = load i64, ptr %_a61, align 8
  %cmp6 = icmp ugt i64 %15, %16
  br i1 %cmp6, label %cond.true8, label %cond.false9

cond.true8:                                       ; preds = %lor.lhs.false, %cond.false
  %17 = load i64, ptr %_a61, align 8
  br label %cond.end

cond.false9:                                      ; preds = %lor.lhs.false
  %18 = load i64, ptr %_b62, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false9, %cond.true8
  %cond = phi i64 [ %17, %cond.true8 ], [ %18, %cond.false9 ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end, %cond.true
  %cond11 = phi i64 [ %13, %cond.true ], [ %cond, %cond.end ]
  store i64 %cond11, ptr %tmp, align 8
  %19 = load i64, ptr %tmp, align 8
  %conv12 = trunc i64 %19 to i32
  %20 = load ptr, ptr %n.addr, align 8
  %dmrsl13 = getelementptr inbounds %struct.NvmeCtrl, ptr %20, i32 0, i32 31
  store i32 %conv12, ptr %dmrsl13, align 4
  ret void
}

; Function Attrs: noreturn nounwind
declare void @__assert_fail(ptr noundef, ptr noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @nvme_l2b(ptr noundef %ns, i64 noundef %lba) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %lba.addr = alloca i64, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store i64 %lba, ptr %lba.addr, align 8
  %0 = load i64, ptr %lba.addr, align 8
  %1 = load ptr, ptr %ns.addr, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %1, i32 0, i32 7
  %ds = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 1
  %2 = load i8, ptr %ds, align 2
  %conv = zext i8 %2 to i32
  %sh_prom = zext i32 %conv to i64
  %shl = shl i64 %0, %sh_prom
  ret i64 %shl
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @do_qemu_init_nvme_register_types() #0 {
entry:
  call void @register_module_init(ptr noundef @nvme_register_types, i32 noundef 3)
  ret void
}

declare void @register_module_init(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_register_types() #0 {
entry:
  %call = call ptr @type_register_static(ptr noundef @nvme_info)
  %call1 = call ptr @type_register_static(ptr noundef @nvme_bus_info)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_map_prp(i64 noundef %trans_len, i32 noundef %len, i64 noundef %prp1, i64 noundef %prp2, i32 noundef %num_prps) #0 {
entry:
  %trans_len.addr = alloca i64, align 8
  %len.addr = alloca i32, align 4
  %prp1.addr = alloca i64, align 8
  %prp2.addr = alloca i64, align 8
  %num_prps.addr = alloca i32, align 4
  store i64 %trans_len, ptr %trans_len.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store i64 %prp1, ptr %prp1.addr, align 8
  store i64 %prp2, ptr %prp2.addr, align 8
  store i32 %num_prps, ptr %num_prps.addr, align 4
  %0 = load i64, ptr %trans_len.addr, align 8
  %1 = load i32, ptr %len.addr, align 4
  %2 = load i64, ptr %prp1.addr, align 8
  %3 = load i64, ptr %prp2.addr, align 8
  %4 = load i32, ptr %num_prps.addr, align 4
  call void @_nocheck__trace_pci_nvme_map_prp(i64 noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i32 noundef %4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_sg_init(ptr noundef %n, ptr noundef %sg, i1 noundef zeroext %dma) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %sg.addr = alloca ptr, align 8
  %dma.addr = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store ptr %sg, ptr %sg.addr, align 8
  %frombool = zext i1 %dma to i8
  store i8 %frombool, ptr %dma.addr, align 1
  %0 = load i8, ptr %dma.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %sg.addr, align 8
  %2 = getelementptr inbounds %struct.NvmeSg, ptr %1, i32 0, i32 1
  %3 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %3)
  call void @pci_dma_sglist_init(ptr noundef %2, ptr noundef %call, i32 noundef 0)
  %4 = load ptr, ptr %sg.addr, align 8
  %flags = getelementptr inbounds %struct.NvmeSg, ptr %4, i32 0, i32 0
  store i32 2, ptr %flags, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load ptr, ptr %sg.addr, align 8
  %6 = getelementptr inbounds %struct.NvmeSg, ptr %5, i32 0, i32 1
  call void @qemu_iovec_init(ptr noundef %6, i32 noundef 0)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %7 = load ptr, ptr %sg.addr, align 8
  %flags1 = getelementptr inbounds %struct.NvmeSg, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %flags1, align 8
  %or = or i32 %8, 1
  store i32 %or, ptr %flags1, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_addr_is_dma(ptr noundef %n, i64 noundef %addr) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load i64, ptr %addr.addr, align 8
  %call = call zeroext i1 @nvme_addr_is_cmb(ptr noundef %0, i64 noundef %1)
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load ptr, ptr %n.addr, align 8
  %3 = load i64, ptr %addr.addr, align 8
  %call1 = call zeroext i1 @nvme_addr_is_pmr(ptr noundef %2, i64 noundef %3)
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %call1, %lor.rhs ]
  %lnot = xor i1 %4, true
  ret i1 %lnot
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_map_addr(ptr noundef %n, ptr noundef %sg, i64 noundef %addr, i64 noundef %len) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %sg.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %cmb = alloca i8, align 1
  %pmr = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store ptr %sg, ptr %sg.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i8 0, ptr %cmb, align 1
  store i8 0, ptr %pmr, align 1
  %0 = load i64, ptr %len.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 0, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %addr.addr, align 8
  %2 = load i64, ptr %len.addr, align 8
  call void @trace_pci_nvme_map_addr(i64 noundef %1, i64 noundef %2)
  %3 = load ptr, ptr %n.addr, align 8
  %4 = load i64, ptr %addr.addr, align 8
  %call = call zeroext i1 @nvme_addr_is_iomem(ptr noundef %3, i64 noundef %4)
  br i1 %call, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  store i16 4, ptr %retval, align 2
  br label %return

if.end2:                                          ; preds = %if.end
  %5 = load ptr, ptr %n.addr, align 8
  %6 = load i64, ptr %addr.addr, align 8
  %call3 = call zeroext i1 @nvme_addr_is_cmb(ptr noundef %5, i64 noundef %6)
  br i1 %call3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end2
  store i8 1, ptr %cmb, align 1
  br label %if.end8

if.else:                                          ; preds = %if.end2
  %7 = load ptr, ptr %n.addr, align 8
  %8 = load i64, ptr %addr.addr, align 8
  %call5 = call zeroext i1 @nvme_addr_is_pmr(ptr noundef %7, i64 noundef %8)
  br i1 %call5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.else
  store i8 1, ptr %pmr, align 1
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.else
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %if.then4
  %9 = load i8, ptr %cmb, align 1
  %tobool9 = trunc i8 %9 to i1
  br i1 %tobool9, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end8
  %10 = load i8, ptr %pmr, align 1
  %tobool10 = trunc i8 %10 to i1
  br i1 %tobool10, label %if.then11, label %if.end22

if.then11:                                        ; preds = %lor.lhs.false, %if.end8
  %11 = load ptr, ptr %sg.addr, align 8
  %flags = getelementptr inbounds %struct.NvmeSg, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %flags, align 8
  %and = and i32 %12, 2
  %tobool12 = icmp ne i32 %and, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.then11
  store i16 16402, ptr %retval, align 2
  br label %return

if.end14:                                         ; preds = %if.then11
  %13 = load ptr, ptr %sg.addr, align 8
  %14 = getelementptr inbounds %struct.NvmeSg, ptr %13, i32 0, i32 1
  %niov = getelementptr inbounds %struct.QEMUIOVector, ptr %14, i32 0, i32 1
  %15 = load i32, ptr %niov, align 8
  %add = add i32 %15, 1
  %cmp = icmp sgt i32 %add, 1024
  br i1 %cmp, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end14
  br label %max_mappings_exceeded

if.end16:                                         ; preds = %if.end14
  %16 = load i8, ptr %cmb, align 1
  %tobool17 = trunc i8 %16 to i1
  br i1 %tobool17, label %if.then18, label %if.else20

if.then18:                                        ; preds = %if.end16
  %17 = load ptr, ptr %n.addr, align 8
  %18 = load ptr, ptr %sg.addr, align 8
  %19 = getelementptr inbounds %struct.NvmeSg, ptr %18, i32 0, i32 1
  %20 = load i64, ptr %addr.addr, align 8
  %21 = load i64, ptr %len.addr, align 8
  %call19 = call zeroext i16 @nvme_map_addr_cmb(ptr noundef %17, ptr noundef %19, i64 noundef %20, i64 noundef %21)
  store i16 %call19, ptr %retval, align 2
  br label %return

if.else20:                                        ; preds = %if.end16
  %22 = load ptr, ptr %n.addr, align 8
  %23 = load ptr, ptr %sg.addr, align 8
  %24 = getelementptr inbounds %struct.NvmeSg, ptr %23, i32 0, i32 1
  %25 = load i64, ptr %addr.addr, align 8
  %26 = load i64, ptr %len.addr, align 8
  %call21 = call zeroext i16 @nvme_map_addr_pmr(ptr noundef %22, ptr noundef %24, i64 noundef %25, i64 noundef %26)
  store i16 %call21, ptr %retval, align 2
  br label %return

if.end22:                                         ; preds = %lor.lhs.false
  %27 = load ptr, ptr %sg.addr, align 8
  %flags23 = getelementptr inbounds %struct.NvmeSg, ptr %27, i32 0, i32 0
  %28 = load i32, ptr %flags23, align 8
  %and24 = and i32 %28, 2
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %if.end22
  store i16 16402, ptr %retval, align 2
  br label %return

if.end27:                                         ; preds = %if.end22
  %29 = load ptr, ptr %sg.addr, align 8
  %30 = getelementptr inbounds %struct.NvmeSg, ptr %29, i32 0, i32 1
  %nsg = getelementptr inbounds %struct.QEMUSGList, ptr %30, i32 0, i32 1
  %31 = load i32, ptr %nsg, align 8
  %add28 = add i32 %31, 1
  %cmp29 = icmp sgt i32 %add28, 1024
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end27
  br label %max_mappings_exceeded

if.end31:                                         ; preds = %if.end27
  %32 = load ptr, ptr %sg.addr, align 8
  %33 = getelementptr inbounds %struct.NvmeSg, ptr %32, i32 0, i32 1
  %34 = load i64, ptr %addr.addr, align 8
  %35 = load i64, ptr %len.addr, align 8
  call void @qemu_sglist_add(ptr noundef %33, i64 noundef %34, i64 noundef %35)
  store i16 0, ptr %retval, align 2
  br label %return

max_mappings_exceeded:                            ; preds = %if.then30, %if.then15
  br label %do.body

do.body:                                          ; preds = %max_mappings_exceeded
  call void @trace_pci_nvme_ub_too_many_mappings()
  br label %do.body32

do.body32:                                        ; preds = %do.body
  %call33 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot = xor i1 %call33, true
  %lnot34 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot34 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool35 = icmp ne i64 %conv, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %do.body32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.10, ptr noundef @__func__.nvme_map_addr)
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %do.body32
  br label %do.end

do.end:                                           ; preds = %if.end37
  br label %do.end38

do.end38:                                         ; preds = %do.end
  store i16 16390, ptr %retval, align 2
  br label %return

return:                                           ; preds = %do.end38, %if.end31, %if.then26, %if.else20, %if.then18, %if.then13, %if.then1, %if.then
  %36 = load i16, ptr %retval, align 2
  ret i16 %36
}

; Function Attrs: allocsize(0,1)
declare noalias ptr @g_malloc_n(i64 noundef, i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal void @g_autoptr_cleanup_generic_gfree(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %pp = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %pp, align 8
  %1 = load ptr, ptr %pp, align 8
  %2 = load ptr, ptr %1, align 8
  call void @g_free(ptr noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_addr_read(ptr noundef %n, i64 noundef %addr, ptr noundef %buf, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %n.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %buf.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  %hi = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i64, ptr %addr.addr, align 8
  %1 = load i32, ptr %size.addr, align 4
  %conv = sext i32 %1 to i64
  %add = add i64 %0, %conv
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %hi, align 8
  %2 = load i64, ptr %hi, align 8
  %3 = load i64, ptr %addr.addr, align 8
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 3
  %cmbsz = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 12
  %5 = load i32, ptr %cmbsz, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %if.end
  %6 = load ptr, ptr %n.addr, align 8
  %7 = load i64, ptr %addr.addr, align 8
  %call = call zeroext i1 @nvme_addr_is_cmb(ptr noundef %6, i64 noundef %7)
  br i1 %call, label %land.lhs.true3, label %if.end9

land.lhs.true3:                                   ; preds = %land.lhs.true
  %8 = load ptr, ptr %n.addr, align 8
  %9 = load i64, ptr %hi, align 8
  %call4 = call zeroext i1 @nvme_addr_is_cmb(ptr noundef %8, i64 noundef %9)
  br i1 %call4, label %if.then6, label %if.end9

if.then6:                                         ; preds = %land.lhs.true3
  %10 = load ptr, ptr %buf.addr, align 8
  %11 = load ptr, ptr %n.addr, align 8
  %12 = load i64, ptr %addr.addr, align 8
  %call7 = call ptr @nvme_addr_to_cmb(ptr noundef %11, i64 noundef %12)
  %13 = load i32, ptr %size.addr, align 4
  %conv8 = sext i32 %13 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %10, ptr align 1 %call7, i64 %conv8, i1 false)
  store i32 0, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %land.lhs.true3, %land.lhs.true, %if.end
  %14 = load ptr, ptr %n.addr, align 8
  %15 = load i64, ptr %addr.addr, align 8
  %call10 = call zeroext i1 @nvme_addr_is_pmr(ptr noundef %14, i64 noundef %15)
  br i1 %call10, label %land.lhs.true12, label %if.end18

land.lhs.true12:                                  ; preds = %if.end9
  %16 = load ptr, ptr %n.addr, align 8
  %17 = load i64, ptr %hi, align 8
  %call13 = call zeroext i1 @nvme_addr_is_pmr(ptr noundef %16, i64 noundef %17)
  br i1 %call13, label %if.then15, label %if.end18

if.then15:                                        ; preds = %land.lhs.true12
  %18 = load ptr, ptr %buf.addr, align 8
  %19 = load ptr, ptr %n.addr, align 8
  %20 = load i64, ptr %addr.addr, align 8
  %call16 = call ptr @nvme_addr_to_pmr(ptr noundef %19, i64 noundef %20)
  %21 = load i32, ptr %size.addr, align 4
  %conv17 = sext i32 %21 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %18, ptr align 1 %call16, i64 %conv17, i1 false)
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %land.lhs.true12, %if.end9
  %22 = load ptr, ptr %n.addr, align 8
  %call19 = call ptr @PCI_DEVICE(ptr noundef %22)
  %23 = load i64, ptr %addr.addr, align 8
  %24 = load ptr, ptr %buf.addr, align 8
  %25 = load i32, ptr %size.addr, align 4
  %conv20 = sext i32 %25 to i64
  %call21 = call i32 @pci_dma_read(ptr noundef %call19, i64 noundef %23, ptr noundef %24, i64 noundef %conv20)
  store i32 %call21, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then15, %if.then6, %if.then
  %26 = load i32, ptr %retval, align 4
  ret i32 %26
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_addr_read(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i64, ptr %addr.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_addr_read(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_prplist_ent(i64 noundef %prplist) #0 {
entry:
  %prplist.addr = alloca i64, align 8
  store i64 %prplist, ptr %prplist.addr, align 8
  %0 = load i64, ptr %prplist.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_invalid_prplist_ent(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_prp2_align(i64 noundef %prp2) #0 {
entry:
  %prp2.addr = alloca i64, align 8
  store i64 %prp2, ptr %prp2.addr, align 8
  %0 = load i64, ptr %prp2.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_invalid_prp2_align(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_map_prp(i64 noundef %trans_len, i32 noundef %len, i64 noundef %prp1, i64 noundef %prp2, i32 noundef %num_prps) #0 {
entry:
  %trans_len.addr = alloca i64, align 8
  %len.addr = alloca i32, align 4
  %prp1.addr = alloca i64, align 8
  %prp2.addr = alloca i64, align 8
  %num_prps.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %trans_len, ptr %trans_len.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store i64 %prp1, ptr %prp1.addr, align 8
  store i64 %prp2, ptr %prp2.addr, align 8
  store i32 %num_prps, ptr %num_prps.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MAP_PRP_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %trans_len.addr, align 8
  %6 = load i32, ptr %len.addr, align 4
  %7 = load i64, ptr %prp1.addr, align 8
  %8 = load i64, ptr %prp2.addr, align 8
  %9 = load i32, ptr %num_prps.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.2, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6, i64 noundef %7, i64 noundef %8, i32 noundef %9)
  br label %if.end

if.else:                                          ; preds = %if.then
  %10 = load i64, ptr %trans_len.addr, align 8
  %11 = load i32, ptr %len.addr, align 4
  %12 = load i64, ptr %prp1.addr, align 8
  %13 = load i64, ptr %prp2.addr, align 8
  %14 = load i32, ptr %num_prps.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.3, i64 noundef %10, i32 noundef %11, i64 noundef %12, i64 noundef %13, i32 noundef %14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @qemu_loglevel_mask(i32 noundef %mask) #0 {
entry:
  %mask.addr = alloca i32, align 4
  store i32 %mask, ptr %mask.addr, align 4
  %0 = load i32, ptr @qemu_loglevel, align 4
  %1 = load i32, ptr %mask.addr, align 4
  %and = and i32 %0, %1
  %cmp = icmp ne i32 %and, 0
  ret i1 %cmp
}

; Function Attrs: nounwind
declare i32 @gettimeofday(ptr noundef, ptr noundef) #4

declare void @qemu_log(ptr noundef, ...) #1

declare i32 @qemu_get_thread_id() #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @pci_dma_sglist_init(ptr noundef %qsg, ptr noundef %dev, i32 noundef %alloc_hint) #0 {
entry:
  %qsg.addr = alloca ptr, align 8
  %dev.addr = alloca ptr, align 8
  %alloc_hint.addr = alloca i32, align 4
  store ptr %qsg, ptr %qsg.addr, align 8
  store ptr %dev, ptr %dev.addr, align 8
  store i32 %alloc_hint, ptr %alloc_hint.addr, align 4
  %0 = load ptr, ptr %qsg.addr, align 8
  %1 = load ptr, ptr %dev.addr, align 8
  %call = call ptr @DEVICE(ptr noundef %1)
  %2 = load i32, ptr %alloc_hint.addr, align 4
  %3 = load ptr, ptr %dev.addr, align 8
  %call1 = call ptr @pci_get_address_space(ptr noundef %3)
  call void @qemu_sglist_init(ptr noundef %0, ptr noundef %call, i32 noundef %2, ptr noundef %call1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @PCI_DEVICE(ptr noundef %obj) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %call = call ptr @object_dynamic_cast_assert(ptr noundef %0, ptr noundef @.str.6, ptr noundef @.str.7, i32 noundef 10, ptr noundef @__func__.PCI_DEVICE)
  ret ptr %call
}

declare void @qemu_iovec_init(ptr noundef, i32 noundef) #1

declare void @qemu_sglist_init(ptr noundef, ptr noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @DEVICE(ptr noundef %obj) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %call = call ptr @object_dynamic_cast_assert(ptr noundef %0, ptr noundef @.str.4, ptr noundef @.str.5, i32 noundef 77, ptr noundef @__func__.DEVICE)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @pci_get_address_space(ptr noundef %dev) #0 {
entry:
  %dev.addr = alloca ptr, align 8
  store ptr %dev, ptr %dev.addr, align 8
  %0 = load ptr, ptr %dev.addr, align 8
  %bus_master_as = getelementptr inbounds %struct.PCIDevice, ptr %0, i32 0, i32 12
  ret ptr %bus_master_as
}

declare ptr @object_dynamic_cast_assert(ptr noundef, ptr noundef, ptr noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_addr_is_cmb(ptr noundef %n, i64 noundef %addr) #0 {
entry:
  %retval = alloca i1, align 1
  %n.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %hi = alloca i64, align 8
  %lo = alloca i64, align 8
  %coerce = alloca i128, align 16
  store ptr %n, ptr %n.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %cmb = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 25
  %cmse = getelementptr inbounds %struct.anon.20, ptr %cmb, i32 0, i32 2
  %1 = load i8, ptr %cmse, align 8
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 4
  %legacy_cmb = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 12
  %3 = load i8, ptr %legacy_cmb, align 1
  %tobool1 = trunc i8 %3 to i1
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %4 = load ptr, ptr %n.addr, align 8
  %cmb2 = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 25
  %mem = getelementptr inbounds %struct.anon.20, ptr %cmb2, i32 0, i32 0
  %addr3 = getelementptr inbounds %struct.MemoryRegion, ptr %mem, i32 0, i32 19
  %5 = load i64, ptr %addr3, align 16
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %6 = load ptr, ptr %n.addr, align 8
  %cmb4 = getelementptr inbounds %struct.NvmeCtrl, ptr %6, i32 0, i32 25
  %cba = getelementptr inbounds %struct.anon.20, ptr %cmb4, i32 0, i32 3
  %7 = load i64, ptr %cba, align 16
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %7, %cond.false ]
  store i64 %cond, ptr %lo, align 8
  %8 = load i64, ptr %lo, align 8
  %9 = load ptr, ptr %n.addr, align 8
  %cmb5 = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 25
  %mem6 = getelementptr inbounds %struct.anon.20, ptr %cmb5, i32 0, i32 0
  %size = getelementptr inbounds %struct.MemoryRegion, ptr %mem6, i32 0, i32 18
  %10 = load i128, ptr %size, align 16
  store i128 %10, ptr %coerce, align 16
  %11 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 0
  %12 = load i64, ptr %11, align 16
  %13 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 1
  %14 = load i64, ptr %13, align 8
  %call = call i64 @int128_get64(i64 noundef %12, i64 noundef %14)
  %add = add i64 %8, %call
  store i64 %add, ptr %hi, align 8
  %15 = load i64, ptr %addr.addr, align 8
  %16 = load i64, ptr %lo, align 8
  %cmp = icmp uge i64 %15, %16
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.end
  %17 = load i64, ptr %addr.addr, align 8
  %18 = load i64, ptr %hi, align 8
  %cmp7 = icmp ult i64 %17, %18
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.end
  %19 = phi i1 [ false, %cond.end ], [ %cmp7, %land.rhs ]
  store i1 %19, ptr %retval, align 1
  br label %return

return:                                           ; preds = %land.end, %if.then
  %20 = load i1, ptr %retval, align 1
  ret i1 %20
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_addr_is_pmr(ptr noundef %n, i64 noundef %addr) #0 {
entry:
  %retval = alloca i1, align 1
  %n.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %hi = alloca i64, align 8
  %coerce = alloca i128, align 16
  store ptr %n, ptr %n.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %pmr = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 26
  %cmse = getelementptr inbounds %struct.anon.21, ptr %pmr, i32 0, i32 1
  %1 = load i8, ptr %cmse, align 8
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %n.addr, align 8
  %pmr1 = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 26
  %cba = getelementptr inbounds %struct.anon.21, ptr %pmr1, i32 0, i32 2
  %3 = load i64, ptr %cba, align 16
  %4 = load ptr, ptr %n.addr, align 8
  %pmr2 = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 26
  %dev = getelementptr inbounds %struct.anon.21, ptr %pmr2, i32 0, i32 0
  %5 = load ptr, ptr %dev, align 16
  %mr = getelementptr inbounds %struct.HostMemoryBackend, ptr %5, i32 0, i32 13
  %size = getelementptr inbounds %struct.MemoryRegion, ptr %mr, i32 0, i32 18
  %6 = load i128, ptr %size, align 16
  store i128 %6, ptr %coerce, align 16
  %7 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 0
  %8 = load i64, ptr %7, align 16
  %9 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 1
  %10 = load i64, ptr %9, align 8
  %call = call i64 @int128_get64(i64 noundef %8, i64 noundef %10)
  %add = add i64 %3, %call
  store i64 %add, ptr %hi, align 8
  %11 = load i64, ptr %addr.addr, align 8
  %12 = load ptr, ptr %n.addr, align 8
  %pmr3 = getelementptr inbounds %struct.NvmeCtrl, ptr %12, i32 0, i32 26
  %cba4 = getelementptr inbounds %struct.anon.21, ptr %pmr3, i32 0, i32 2
  %13 = load i64, ptr %cba4, align 16
  %cmp = icmp uge i64 %11, %13
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %14 = load i64, ptr %addr.addr, align 8
  %15 = load i64, ptr %hi, align 8
  %cmp5 = icmp ult i64 %14, %15
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %16 = phi i1 [ false, %if.end ], [ %cmp5, %land.rhs ]
  store i1 %16, ptr %retval, align 1
  br label %return

return:                                           ; preds = %land.end, %if.then
  %17 = load i1, ptr %retval, align 1
  ret i1 %17
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @int128_get64(i64 noundef %a.coerce0, i64 noundef %a.coerce1) #0 {
entry:
  %a = alloca i128, align 16
  %a.addr = alloca i128, align 16
  %r = alloca i64, align 8
  %0 = getelementptr inbounds { i64, i64 }, ptr %a, i32 0, i32 0
  store i64 %a.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %a, i32 0, i32 1
  store i64 %a.coerce1, ptr %1, align 8
  %a1 = load i128, ptr %a, align 16
  store i128 %a1, ptr %a.addr, align 16
  %2 = load i128, ptr %a.addr, align 16
  %conv = trunc i128 %2 to i64
  store i64 %conv, ptr %r, align 8
  %3 = load i64, ptr %r, align 8
  %conv2 = zext i64 %3 to i128
  %4 = load i128, ptr %a.addr, align 16
  %cmp = icmp eq i128 %conv2, %4
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.8, ptr noundef @.str.9, i32 noundef 33, ptr noundef @__PRETTY_FUNCTION__.int128_get64) #12
  unreachable

if.end:                                           ; preds = %if.then
  %5 = load i64, ptr %r, align 8
  ret i64 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_map_addr(i64 noundef %addr, i64 noundef %len) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i64, ptr %addr.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  call void @_nocheck__trace_pci_nvme_map_addr(i64 noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_addr_is_iomem(ptr noundef %n, i64 noundef %addr) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %hi = alloca i64, align 8
  %lo = alloca i64, align 8
  %coerce = alloca i128, align 16
  store ptr %n, ptr %n.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %bar0 = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 1
  %addr1 = getelementptr inbounds %struct.MemoryRegion, ptr %bar0, i32 0, i32 19
  %1 = load i64, ptr %addr1, align 16
  store i64 %1, ptr %lo, align 8
  %2 = load i64, ptr %lo, align 8
  %3 = load ptr, ptr %n.addr, align 8
  %bar02 = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 1
  %size = getelementptr inbounds %struct.MemoryRegion, ptr %bar02, i32 0, i32 18
  %4 = load i128, ptr %size, align 16
  store i128 %4, ptr %coerce, align 16
  %5 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 0
  %6 = load i64, ptr %5, align 16
  %7 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 1
  %8 = load i64, ptr %7, align 8
  %call = call i64 @int128_get64(i64 noundef %6, i64 noundef %8)
  %add = add i64 %2, %call
  store i64 %add, ptr %hi, align 8
  %9 = load i64, ptr %addr.addr, align 8
  %10 = load i64, ptr %lo, align 8
  %cmp = icmp uge i64 %9, %10
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %11 = load i64, ptr %addr.addr, align 8
  %12 = load i64, ptr %hi, align 8
  %cmp3 = icmp ult i64 %11, %12
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %13 = phi i1 [ false, %entry ], [ %cmp3, %land.rhs ]
  ret i1 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_map_addr_cmb(ptr noundef %n, ptr noundef %iov, i64 noundef %addr, i64 noundef %len) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %iov.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %iov, ptr %iov.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i64, ptr %len.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 0, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %addr.addr, align 8
  %2 = load i64, ptr %len.addr, align 8
  call void @trace_pci_nvme_map_addr_cmb(i64 noundef %1, i64 noundef %2)
  %3 = load ptr, ptr %n.addr, align 8
  %4 = load i64, ptr %addr.addr, align 8
  %call = call zeroext i1 @nvme_addr_is_cmb(ptr noundef %3, i64 noundef %4)
  br i1 %call, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %5 = load ptr, ptr %n.addr, align 8
  %6 = load i64, ptr %addr.addr, align 8
  %7 = load i64, ptr %len.addr, align 8
  %add = add i64 %6, %7
  %sub = sub i64 %add, 1
  %call1 = call zeroext i1 @nvme_addr_is_cmb(ptr noundef %5, i64 noundef %sub)
  br i1 %call1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  store i16 4, ptr %retval, align 2
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %8 = load ptr, ptr %iov.addr, align 8
  %9 = load ptr, ptr %n.addr, align 8
  %10 = load i64, ptr %addr.addr, align 8
  %call4 = call ptr @nvme_addr_to_cmb(ptr noundef %9, i64 noundef %10)
  %11 = load i64, ptr %len.addr, align 8
  call void @qemu_iovec_add(ptr noundef %8, ptr noundef %call4, i64 noundef %11)
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %12 = load i16, ptr %retval, align 2
  ret i16 %12
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_map_addr_pmr(ptr noundef %n, ptr noundef %iov, i64 noundef %addr, i64 noundef %len) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %iov.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %iov, ptr %iov.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i64, ptr %len.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 0, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %n.addr, align 8
  %2 = load i64, ptr %addr.addr, align 8
  %call = call zeroext i1 @nvme_addr_is_pmr(ptr noundef %1, i64 noundef %2)
  br i1 %call, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %3 = load ptr, ptr %n.addr, align 8
  %4 = load i64, ptr %addr.addr, align 8
  %5 = load i64, ptr %len.addr, align 8
  %add = add i64 %4, %5
  %sub = sub i64 %add, 1
  %call1 = call zeroext i1 @nvme_addr_is_pmr(ptr noundef %3, i64 noundef %sub)
  br i1 %call1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  store i16 4, ptr %retval, align 2
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %6 = load ptr, ptr %iov.addr, align 8
  %7 = load ptr, ptr %n.addr, align 8
  %8 = load i64, ptr %addr.addr, align 8
  %call4 = call ptr @nvme_addr_to_pmr(ptr noundef %7, i64 noundef %8)
  %9 = load i64, ptr %len.addr, align 8
  call void @qemu_iovec_add(ptr noundef %6, ptr noundef %call4, i64 noundef %9)
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %10 = load i16, ptr %retval, align 2
  ret i16 %10
}

declare void @qemu_sglist_add(ptr noundef, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_too_many_mappings() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_ub_too_many_mappings()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_map_addr(i64 noundef %addr, i64 noundef %len) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MAP_ADDR_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  %6 = load i64, ptr %len.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.11, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %addr.addr, align 8
  %8 = load i64, ptr %len.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.12, i64 noundef %7, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_map_addr_cmb(i64 noundef %addr, i64 noundef %len) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i64, ptr %addr.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  call void @_nocheck__trace_pci_nvme_map_addr_cmb(i64 noundef %0, i64 noundef %1)
  ret void
}

declare void @qemu_iovec_add(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_addr_to_cmb(ptr noundef %n, i64 noundef %addr) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %base = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 4
  %legacy_cmb = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 12
  %1 = load i8, ptr %legacy_cmb, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %n.addr, align 8
  %cmb = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 25
  %mem = getelementptr inbounds %struct.anon.20, ptr %cmb, i32 0, i32 0
  %addr1 = getelementptr inbounds %struct.MemoryRegion, ptr %mem, i32 0, i32 19
  %3 = load i64, ptr %addr1, align 16
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load ptr, ptr %n.addr, align 8
  %cmb2 = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 25
  %cba = getelementptr inbounds %struct.anon.20, ptr %cmb2, i32 0, i32 3
  %5 = load i64, ptr %cba, align 16
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %3, %cond.true ], [ %5, %cond.false ]
  store i64 %cond, ptr %base, align 8
  %6 = load ptr, ptr %n.addr, align 8
  %cmb3 = getelementptr inbounds %struct.NvmeCtrl, ptr %6, i32 0, i32 25
  %buf = getelementptr inbounds %struct.anon.20, ptr %cmb3, i32 0, i32 1
  %7 = load ptr, ptr %buf, align 16
  %8 = load i64, ptr %addr.addr, align 8
  %9 = load i64, ptr %base, align 8
  %sub = sub i64 %8, %9
  %arrayidx = getelementptr i8, ptr %7, i64 %sub
  ret ptr %arrayidx
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_map_addr_cmb(i64 noundef %addr, i64 noundef %len) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MAP_ADDR_CMB_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  %6 = load i64, ptr %len.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.13, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %addr.addr, align 8
  %8 = load i64, ptr %len.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.14, i64 noundef %7, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_addr_to_pmr(ptr noundef %n, i64 noundef %addr) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %pmr = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 26
  %dev = getelementptr inbounds %struct.anon.21, ptr %pmr, i32 0, i32 0
  %1 = load ptr, ptr %dev, align 16
  %mr = getelementptr inbounds %struct.HostMemoryBackend, ptr %1, i32 0, i32 13
  %call = call ptr @memory_region_get_ram_ptr(ptr noundef %mr)
  %2 = load i64, ptr %addr.addr, align 8
  %3 = load ptr, ptr %n.addr, align 8
  %pmr1 = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 26
  %cba = getelementptr inbounds %struct.anon.21, ptr %pmr1, i32 0, i32 2
  %4 = load i64, ptr %cba, align 16
  %sub = sub i64 %2, %4
  %add.ptr = getelementptr i8, ptr %call, i64 %sub
  ret ptr %add.ptr
}

declare ptr @memory_region_get_ram_ptr(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_too_many_mappings() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_TOO_MANY_MAPPINGS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.15, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.16)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

declare void @g_free(ptr noundef) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #5

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @pci_dma_read(ptr noundef %dev, i64 noundef %addr, ptr noundef %buf, i64 noundef %len) #0 {
entry:
  %dev.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %.compoundliteral = alloca %struct.MemTxAttrs, align 4
  store ptr %dev, ptr %dev.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %dev.addr, align 8
  %1 = load i64, ptr %addr.addr, align 8
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load i64, ptr %len.addr, align 8
  %bf.load = load i32, ptr %.compoundliteral, align 4
  %bf.clear = and i32 %bf.load, -2
  %bf.set = or i32 %bf.clear, 1
  store i32 %bf.set, ptr %.compoundliteral, align 4
  %bf.load1 = load i32, ptr %.compoundliteral, align 4
  %bf.clear2 = and i32 %bf.load1, -3
  %bf.set3 = or i32 %bf.clear2, 0
  store i32 %bf.set3, ptr %.compoundliteral, align 4
  %bf.load4 = load i32, ptr %.compoundliteral, align 4
  %bf.clear5 = and i32 %bf.load4, -13
  %bf.set6 = or i32 %bf.clear5, 0
  store i32 %bf.set6, ptr %.compoundliteral, align 4
  %bf.load7 = load i32, ptr %.compoundliteral, align 4
  %bf.clear8 = and i32 %bf.load7, -17
  %bf.set9 = or i32 %bf.clear8, 0
  store i32 %bf.set9, ptr %.compoundliteral, align 4
  %bf.load10 = load i32, ptr %.compoundliteral, align 4
  %bf.clear11 = and i32 %bf.load10, -33
  %bf.set12 = or i32 %bf.clear11, 0
  store i32 %bf.set12, ptr %.compoundliteral, align 4
  %bf.load13 = load i32, ptr %.compoundliteral, align 4
  %bf.clear14 = and i32 %bf.load13, -4194241
  %bf.set15 = or i32 %bf.clear14, 0
  store i32 %bf.set15, ptr %.compoundliteral, align 4
  %bf.load16 = load i32, ptr %.compoundliteral, align 4
  %bf.clear17 = and i32 %bf.load16, -4194305
  %bf.set18 = or i32 %bf.clear17, 0
  store i32 %bf.set18, ptr %.compoundliteral, align 4
  %bf.load19 = load i32, ptr %.compoundliteral, align 4
  %bf.clear20 = and i32 %bf.load19, -8388609
  %bf.set21 = or i32 %bf.clear20, 0
  store i32 %bf.set21, ptr %.compoundliteral, align 4
  %bf.load22 = load i32, ptr %.compoundliteral, align 4
  %bf.clear23 = and i32 %bf.load22, -16777217
  %bf.set24 = or i32 %bf.clear23, 0
  store i32 %bf.set24, ptr %.compoundliteral, align 4
  %bf.load25 = load i32, ptr %.compoundliteral, align 4
  %bf.clear26 = and i32 %bf.load25, -33554433
  %bf.set27 = or i32 %bf.clear26, 0
  store i32 %bf.set27, ptr %.compoundliteral, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %.compoundliteral, i32 0, i32 0
  %4 = load i32, ptr %coerce.dive, align 4
  %call = call i32 @pci_dma_rw(ptr noundef %0, i64 noundef %1, ptr noundef %2, i64 noundef %3, i32 noundef 0, i32 %4)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @pci_dma_rw(ptr noundef %dev, i64 noundef %addr, ptr noundef %buf, i64 noundef %len, i32 noundef %dir, i32 %attrs.coerce) #0 {
entry:
  %attrs = alloca %struct.MemTxAttrs, align 4
  %dev.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %dir.addr = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  store i32 %attrs.coerce, ptr %coerce.dive, align 4
  store ptr %dev, ptr %dev.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 %dir, ptr %dir.addr, align 4
  %0 = load ptr, ptr %dev.addr, align 8
  %call = call ptr @pci_get_address_space(ptr noundef %0)
  %1 = load i64, ptr %addr.addr, align 8
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load i64, ptr %len.addr, align 8
  %4 = load i32, ptr %dir.addr, align 4
  %coerce.dive1 = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  %5 = load i32, ptr %coerce.dive1, align 4
  %call2 = call i32 @dma_memory_rw(ptr noundef %call, i64 noundef %1, ptr noundef %2, i64 noundef %3, i32 noundef %4, i32 %5)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @dma_memory_rw(ptr noundef %as, i64 noundef %addr, ptr noundef %buf, i64 noundef %len, i32 noundef %dir, i32 %attrs.coerce) #0 {
entry:
  %attrs = alloca %struct.MemTxAttrs, align 4
  %as.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %dir.addr = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  store i32 %attrs.coerce, ptr %coerce.dive, align 4
  store ptr %as, ptr %as.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 %dir, ptr %dir.addr, align 4
  %0 = load ptr, ptr %as.addr, align 8
  %1 = load i32, ptr %dir.addr, align 4
  call void @dma_barrier(ptr noundef %0, i32 noundef %1)
  %2 = load ptr, ptr %as.addr, align 8
  %3 = load i64, ptr %addr.addr, align 8
  %4 = load ptr, ptr %buf.addr, align 8
  %5 = load i64, ptr %len.addr, align 8
  %6 = load i32, ptr %dir.addr, align 4
  %coerce.dive1 = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  %7 = load i32, ptr %coerce.dive1, align 4
  %call = call i32 @dma_memory_rw_relaxed(ptr noundef %2, i64 noundef %3, ptr noundef %4, i64 noundef %5, i32 noundef %6, i32 %7)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @dma_barrier(ptr noundef %as, i32 noundef %dir) #0 {
entry:
  %as.addr = alloca ptr, align 8
  %dir.addr = alloca i32, align 4
  store ptr %as, ptr %as.addr, align 8
  store i32 %dir, ptr %dir.addr, align 4
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !9
  fence seq_cst
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @dma_memory_rw_relaxed(ptr noundef %as, i64 noundef %addr, ptr noundef %buf, i64 noundef %len, i32 noundef %dir, i32 %attrs.coerce) #0 {
entry:
  %attrs = alloca %struct.MemTxAttrs, align 4
  %as.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %dir.addr = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  store i32 %attrs.coerce, ptr %coerce.dive, align 4
  store ptr %as, ptr %as.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 %dir, ptr %dir.addr, align 4
  %0 = load ptr, ptr %as.addr, align 8
  %1 = load i64, ptr %addr.addr, align 8
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load i64, ptr %len.addr, align 8
  %4 = load i32, ptr %dir.addr, align 4
  %cmp = icmp eq i32 %4, 1
  %coerce.dive1 = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  %5 = load i32, ptr %coerce.dive1, align 4
  %call = call i32 @address_space_rw(ptr noundef %0, i64 noundef %1, i32 %5, ptr noundef %2, i64 noundef %3, i1 noundef zeroext %cmp)
  ret i32 %call
}

declare i32 @address_space_rw(ptr noundef, i64 noundef, i32, ptr noundef, i64 noundef, i1 noundef zeroext) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_addr_read(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_ADDR_READ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.17, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.18, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_prplist_ent(i64 noundef %prplist) #0 {
entry:
  %prplist.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %prplist, ptr %prplist.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %prplist.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.19, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %prplist.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.20, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_prp2_align(i64 noundef %prp2) #0 {
entry:
  %prp2.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %prp2, ptr %prp2.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %prp2.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.21, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %prp2.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.22, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_map_sgl(i8 noundef zeroext %typ, i64 noundef %len) #0 {
entry:
  %typ.addr = alloca i8, align 1
  %len.addr = alloca i64, align 8
  store i8 %typ, ptr %typ.addr, align 1
  store i64 %len, ptr %len.addr, align 8
  %0 = load i8, ptr %typ.addr, align 1
  %1 = load i64, ptr %len.addr, align 8
  call void @_nocheck__trace_pci_nvme_map_sgl(i8 noundef zeroext %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_map_sgl_data(ptr noundef %n, ptr noundef %sg, ptr noundef %segment, i64 noundef %nsgld, ptr noundef %len, ptr noundef %cmd) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %sg.addr = alloca ptr, align 8
  %segment.addr = alloca ptr, align 8
  %nsgld.addr = alloca i64, align 8
  %len.addr = alloca ptr, align 8
  %cmd.addr = alloca ptr, align 8
  %addr = alloca i64, align 8
  %trans_len = alloca i64, align 8
  %dlen = alloca i32, align 4
  %status = alloca i16, align 2
  %i = alloca i32, align 4
  %type = alloca i8, align 1
  %sgls = alloca i32, align 4
  %_a17 = alloca i64, align 8
  %_b18 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %sg, ptr %sg.addr, align 8
  store ptr %segment, ptr %segment.addr, align 8
  store i64 %nsgld, ptr %nsgld.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %conv = sext i32 %0 to i64
  %1 = load i64, ptr %nsgld.addr, align 8
  %cmp = icmp ult i64 %conv, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %segment.addr, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr %struct.NvmeSglDescriptor, ptr %2, i64 %idxprom
  %type2 = getelementptr inbounds %struct.NvmeSglDescriptor, ptr %arrayidx, i32 0, i32 3
  %4 = load i8, ptr %type2, align 1
  %conv3 = zext i8 %4 to i32
  %shr = ashr i32 %conv3, 4
  %and = and i32 %shr, 15
  %conv4 = trunc i32 %and to i8
  store i8 %conv4, ptr %type, align 1
  %5 = load i8, ptr %type, align 1
  %conv5 = zext i8 %5 to i32
  switch i32 %conv5, label %sw.default [
    i32 0, label %sw.bb
    i32 2, label %sw.bb6
    i32 3, label %sw.bb6
  ]

sw.bb:                                            ; preds = %for.body
  br label %sw.epilog

sw.bb6:                                           ; preds = %for.body, %for.body
  store i16 16398, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %for.body
  store i16 16401, ptr %retval, align 2
  br label %return

sw.epilog:                                        ; preds = %sw.bb
  %6 = load ptr, ptr %segment.addr, align 8
  %7 = load i32, ptr %i, align 4
  %idxprom7 = sext i32 %7 to i64
  %arrayidx8 = getelementptr %struct.NvmeSglDescriptor, ptr %6, i64 %idxprom7
  %len9 = getelementptr inbounds %struct.NvmeSglDescriptor, ptr %arrayidx8, i32 0, i32 1
  %8 = load i32, ptr %len9, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %8)
  store i32 %call, ptr %dlen, align 4
  %9 = load i32, ptr %dlen, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %sw.epilog
  br label %for.inc

if.end:                                           ; preds = %sw.epilog
  %10 = load ptr, ptr %len.addr, align 8
  %11 = load i64, ptr %10, align 8
  %cmp10 = icmp eq i64 %11, 0
  br i1 %cmp10, label %if.then12, label %if.end19

if.then12:                                        ; preds = %if.end
  %12 = load ptr, ptr %n.addr, align 8
  %id_ctrl = getelementptr inbounds %struct.NvmeCtrl, ptr %12, i32 0, i32 40
  %sgls13 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %id_ctrl, i32 0, i32 62
  %13 = load i32, ptr %sgls13, align 8
  %call14 = call i32 @le32_to_cpu(i32 noundef %13)
  store i32 %call14, ptr %sgls, align 4
  %14 = load i32, ptr %sgls, align 4
  %and15 = and i32 %14, 262144
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then12
  br label %for.end

if.end18:                                         ; preds = %if.then12
  %15 = load i32, ptr %dlen, align 4
  call void @trace_pci_nvme_err_invalid_sgl_excess_length(i32 noundef %15)
  store i16 16399, ptr %retval, align 2
  br label %return

if.end19:                                         ; preds = %if.end
  %16 = load ptr, ptr %len.addr, align 8
  %17 = load i64, ptr %16, align 8
  store i64 %17, ptr %_a17, align 8
  %18 = load i32, ptr %dlen, align 4
  %conv20 = zext i32 %18 to i64
  store i64 %conv20, ptr %_b18, align 8
  %19 = load i64, ptr %_a17, align 8
  %20 = load i64, ptr %_b18, align 8
  %cmp21 = icmp ult i64 %19, %20
  br i1 %cmp21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end19
  %21 = load i64, ptr %_a17, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end19
  %22 = load i64, ptr %_b18, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %21, %cond.true ], [ %22, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %23 = load i64, ptr %tmp, align 8
  store i64 %23, ptr %trans_len, align 8
  %24 = load ptr, ptr %segment.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idxprom23 = sext i32 %25 to i64
  %arrayidx24 = getelementptr %struct.NvmeSglDescriptor, ptr %24, i64 %idxprom23
  %addr25 = getelementptr inbounds %struct.NvmeSglDescriptor, ptr %arrayidx24, i32 0, i32 0
  %26 = load i64, ptr %addr25, align 1
  %call26 = call i64 @le64_to_cpu(i64 noundef %26)
  store i64 %call26, ptr %addr, align 8
  %27 = load i64, ptr %addr, align 8
  %sub = sub i64 -1, %27
  %28 = load i32, ptr %dlen, align 4
  %conv27 = zext i32 %28 to i64
  %cmp28 = icmp ult i64 %sub, %conv27
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %cond.end
  store i16 16399, ptr %retval, align 2
  br label %return

if.end31:                                         ; preds = %cond.end
  %29 = load ptr, ptr %n.addr, align 8
  %30 = load ptr, ptr %sg.addr, align 8
  %31 = load i64, ptr %addr, align 8
  %32 = load i64, ptr %trans_len, align 8
  %call32 = call zeroext i16 @nvme_map_addr(ptr noundef %29, ptr noundef %30, i64 noundef %31, i64 noundef %32)
  store i16 %call32, ptr %status, align 2
  %33 = load i16, ptr %status, align 2
  %tobool33 = icmp ne i16 %33, 0
  br i1 %tobool33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end31
  %34 = load i16, ptr %status, align 2
  store i16 %34, ptr %retval, align 2
  br label %return

if.end35:                                         ; preds = %if.end31
  %35 = load i64, ptr %trans_len, align 8
  %36 = load ptr, ptr %len.addr, align 8
  %37 = load i64, ptr %36, align 8
  %sub36 = sub i64 %37, %35
  store i64 %sub36, ptr %36, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end35, %if.then
  %38 = load i32, ptr %i, align 4
  %inc = add i32 %38, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %if.then17, %for.cond
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %for.end, %if.then34, %if.then30, %if.end18, %sw.default, %sw.bb6
  %39 = load i16, ptr %retval, align 2
  ret i16 %39
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @le32_to_cpu(i32 noundef %v) #0 {
entry:
  %v.addr = alloca i32, align 4
  store i32 %v, ptr %v.addr, align 4
  %0 = load i32, ptr %v.addr, align 4
  ret i32 %0
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_map_sgl(i8 noundef zeroext %typ, i64 noundef %len) #0 {
entry:
  %typ.addr = alloca i8, align 1
  %len.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i8 %typ, ptr %typ.addr, align 1
  store i64 %len, ptr %len.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MAP_SGL_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %typ.addr, align 1
  %conv11 = zext i8 %5 to i32
  %6 = load i64, ptr %len.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.23, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i64 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i8, ptr %typ.addr, align 1
  %conv12 = zext i8 %7 to i32
  %8 = load i64, ptr %len.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.24, i32 noundef %conv12, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_sgl_excess_length(i32 noundef %residual) #0 {
entry:
  %residual.addr = alloca i32, align 4
  store i32 %residual, ptr %residual.addr, align 4
  %0 = load i32, ptr %residual.addr, align 4
  call void @_nocheck__trace_pci_nvme_err_invalid_sgl_excess_length(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_sgl_excess_length(i32 noundef %residual) #0 {
entry:
  %residual.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %residual, ptr %residual.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %residual.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.25, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %residual.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.26, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_addr_write(ptr noundef %n, i64 noundef %addr, ptr noundef %buf, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %n.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %buf.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  %hi = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i64, ptr %addr.addr, align 8
  %1 = load i32, ptr %size.addr, align 4
  %conv = sext i32 %1 to i64
  %add = add i64 %0, %conv
  %sub = sub i64 %add, 1
  store i64 %sub, ptr %hi, align 8
  %2 = load i64, ptr %hi, align 8
  %3 = load i64, ptr %addr.addr, align 8
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 3
  %cmbsz = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 12
  %5 = load i32, ptr %cmbsz, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %if.end
  %6 = load ptr, ptr %n.addr, align 8
  %7 = load i64, ptr %addr.addr, align 8
  %call = call zeroext i1 @nvme_addr_is_cmb(ptr noundef %6, i64 noundef %7)
  br i1 %call, label %land.lhs.true3, label %if.end9

land.lhs.true3:                                   ; preds = %land.lhs.true
  %8 = load ptr, ptr %n.addr, align 8
  %9 = load i64, ptr %hi, align 8
  %call4 = call zeroext i1 @nvme_addr_is_cmb(ptr noundef %8, i64 noundef %9)
  br i1 %call4, label %if.then6, label %if.end9

if.then6:                                         ; preds = %land.lhs.true3
  %10 = load ptr, ptr %n.addr, align 8
  %11 = load i64, ptr %addr.addr, align 8
  %call7 = call ptr @nvme_addr_to_cmb(ptr noundef %10, i64 noundef %11)
  %12 = load ptr, ptr %buf.addr, align 8
  %13 = load i32, ptr %size.addr, align 4
  %conv8 = sext i32 %13 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %call7, ptr align 1 %12, i64 %conv8, i1 false)
  store i32 0, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %land.lhs.true3, %land.lhs.true, %if.end
  %14 = load ptr, ptr %n.addr, align 8
  %15 = load i64, ptr %addr.addr, align 8
  %call10 = call zeroext i1 @nvme_addr_is_pmr(ptr noundef %14, i64 noundef %15)
  br i1 %call10, label %land.lhs.true12, label %if.end18

land.lhs.true12:                                  ; preds = %if.end9
  %16 = load ptr, ptr %n.addr, align 8
  %17 = load i64, ptr %hi, align 8
  %call13 = call zeroext i1 @nvme_addr_is_pmr(ptr noundef %16, i64 noundef %17)
  br i1 %call13, label %if.then15, label %if.end18

if.then15:                                        ; preds = %land.lhs.true12
  %18 = load ptr, ptr %n.addr, align 8
  %19 = load i64, ptr %addr.addr, align 8
  %call16 = call ptr @nvme_addr_to_pmr(ptr noundef %18, i64 noundef %19)
  %20 = load ptr, ptr %buf.addr, align 8
  %21 = load i32, ptr %size.addr, align 4
  %conv17 = sext i32 %21 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %call16, ptr align 1 %20, i64 %conv17, i1 false)
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %land.lhs.true12, %if.end9
  %22 = load ptr, ptr %n.addr, align 8
  %call19 = call ptr @PCI_DEVICE(ptr noundef %22)
  %23 = load i64, ptr %addr.addr, align 8
  %24 = load ptr, ptr %buf.addr, align 8
  %25 = load i32, ptr %size.addr, align 4
  %conv20 = sext i32 %25 to i64
  %call21 = call i32 @pci_dma_write(ptr noundef %call19, i64 noundef %23, ptr noundef %24, i64 noundef %conv20)
  store i32 %call21, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then15, %if.then6, %if.then
  %26 = load i32, ptr %retval, align 4
  ret i32 %26
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @pci_dma_write(ptr noundef %dev, i64 noundef %addr, ptr noundef %buf, i64 noundef %len) #0 {
entry:
  %dev.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %.compoundliteral = alloca %struct.MemTxAttrs, align 4
  store ptr %dev, ptr %dev.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %dev.addr, align 8
  %1 = load i64, ptr %addr.addr, align 8
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load i64, ptr %len.addr, align 8
  %bf.load = load i32, ptr %.compoundliteral, align 4
  %bf.clear = and i32 %bf.load, -2
  %bf.set = or i32 %bf.clear, 1
  store i32 %bf.set, ptr %.compoundliteral, align 4
  %bf.load1 = load i32, ptr %.compoundliteral, align 4
  %bf.clear2 = and i32 %bf.load1, -3
  %bf.set3 = or i32 %bf.clear2, 0
  store i32 %bf.set3, ptr %.compoundliteral, align 4
  %bf.load4 = load i32, ptr %.compoundliteral, align 4
  %bf.clear5 = and i32 %bf.load4, -13
  %bf.set6 = or i32 %bf.clear5, 0
  store i32 %bf.set6, ptr %.compoundliteral, align 4
  %bf.load7 = load i32, ptr %.compoundliteral, align 4
  %bf.clear8 = and i32 %bf.load7, -17
  %bf.set9 = or i32 %bf.clear8, 0
  store i32 %bf.set9, ptr %.compoundliteral, align 4
  %bf.load10 = load i32, ptr %.compoundliteral, align 4
  %bf.clear11 = and i32 %bf.load10, -33
  %bf.set12 = or i32 %bf.clear11, 0
  store i32 %bf.set12, ptr %.compoundliteral, align 4
  %bf.load13 = load i32, ptr %.compoundliteral, align 4
  %bf.clear14 = and i32 %bf.load13, -4194241
  %bf.set15 = or i32 %bf.clear14, 0
  store i32 %bf.set15, ptr %.compoundliteral, align 4
  %bf.load16 = load i32, ptr %.compoundliteral, align 4
  %bf.clear17 = and i32 %bf.load16, -4194305
  %bf.set18 = or i32 %bf.clear17, 0
  store i32 %bf.set18, ptr %.compoundliteral, align 4
  %bf.load19 = load i32, ptr %.compoundliteral, align 4
  %bf.clear20 = and i32 %bf.load19, -8388609
  %bf.set21 = or i32 %bf.clear20, 0
  store i32 %bf.set21, ptr %.compoundliteral, align 4
  %bf.load22 = load i32, ptr %.compoundliteral, align 4
  %bf.clear23 = and i32 %bf.load22, -16777217
  %bf.set24 = or i32 %bf.clear23, 0
  store i32 %bf.set24, ptr %.compoundliteral, align 4
  %bf.load25 = load i32, ptr %.compoundliteral, align 4
  %bf.clear26 = and i32 %bf.load25, -33554433
  %bf.set27 = or i32 %bf.clear26, 0
  store i32 %bf.set27, ptr %.compoundliteral, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %.compoundliteral, i32 0, i32 0
  %4 = load i32, ptr %coerce.dive, align 4
  %call = call i32 @pci_dma_rw(ptr noundef %0, i64 noundef %1, ptr noundef %2, i64 noundef %3, i32 noundef 1, i32 %4)
  ret i32 %call
}

declare i32 @dma_buf_write(ptr noundef, i64 noundef, ptr noundef, ptr noundef, i32) #1

declare i32 @dma_buf_read(ptr noundef, i64 noundef, ptr noundef, ptr noundef, i32) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_dma() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_err_invalid_dma()
  ret void
}

declare i64 @qemu_iovec_to_buf(ptr noundef, i64 noundef, ptr noundef, i64 noundef) #1

declare i64 @qemu_iovec_from_buf(ptr noundef, i64 noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_dma() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_DMA_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.28, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.29)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

declare void @qemu_sglist_destroy(ptr noundef) #1

declare void @qemu_iovec_destroy(ptr noundef) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #6

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_rw_complete_cb(i16 noundef zeroext %cid, ptr noundef %blkname) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %blkname.addr = alloca ptr, align 8
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store ptr %blkname, ptr %blkname.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_RW_COMPLETE_CB_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load ptr, ptr %blkname.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.30, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, ptr noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %cid.addr, align 2
  %conv12 = zext i16 %7 to i32
  %8 = load ptr, ptr %blkname.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.31, i32 noundef %conv12, ptr noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_aio(i16 noundef zeroext %cid, ptr noundef %errname, i16 noundef zeroext %status) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %errname.addr = alloca ptr, align 8
  %status.addr = alloca i16, align 2
  store i16 %cid, ptr %cid.addr, align 2
  store ptr %errname, ptr %errname.addr, align 8
  store i16 %status, ptr %status.addr, align 2
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load ptr, ptr %errname.addr, align 8
  %2 = load i16, ptr %status.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_aio(i16 noundef zeroext %0, ptr noundef %1, i16 noundef zeroext %2)
  ret void
}

; Function Attrs: nounwind
declare ptr @strerror(i32 noundef) #4

declare void @error_setg_errno_internal(ptr noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef, ptr noundef, ...) #1

declare void @error_report_err(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_aio(i16 noundef zeroext %cid, ptr noundef %errname, i16 noundef zeroext %status) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %errname.addr = alloca ptr, align 8
  %status.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store ptr %errname, ptr %errname.addr, align 8
  store i16 %status, ptr %status.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_AIO_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load ptr, ptr %errname.addr, align 8
  %7 = load i16, ptr %status.addr, align 2
  %conv12 = zext i16 %7 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.33, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, ptr noundef %6, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i16, ptr %cid.addr, align 2
  %conv13 = zext i16 %8 to i32
  %9 = load ptr, ptr %errname.addr, align 8
  %10 = load i16, ptr %status.addr, align 2
  %conv14 = zext i16 %10 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.34, i32 noundef %conv13, ptr noundef %9, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_get_zone_by_slba(ptr noundef %ns, i64 noundef %slba) #0 {
entry:
  %retval = alloca ptr, align 8
  %ns.addr = alloca ptr, align 8
  %slba.addr = alloca i64, align 8
  %zone_idx = alloca i32, align 4
  store ptr %ns, ptr %ns.addr, align 8
  store i64 %slba, ptr %slba.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %1 = load i64, ptr %slba.addr, align 8
  %call = call i32 @nvme_zone_idx(ptr noundef %0, i64 noundef %1)
  store i32 %call, ptr %zone_idx, align 4
  %2 = load i32, ptr %zone_idx, align 4
  %3 = load ptr, ptr %ns.addr, align 8
  %num_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 23
  %4 = load i32, ptr %num_zones, align 8
  %cmp = icmp uge i32 %2, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %ns.addr, align 8
  %zone_array = getelementptr inbounds %struct.NvmeNamespace, ptr %5, i32 0, i32 18
  %6 = load ptr, ptr %zone_array, align 8
  %7 = load i32, ptr %zone_idx, align 4
  %idxprom = zext i32 %7 to i64
  %arrayidx = getelementptr %struct.NvmeZone, ptr %6, i64 %idxprom
  store ptr %arrayidx, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_zoned_zrwa_implicit_flush(ptr noundef %ns, ptr noundef %zone, i32 noundef %nlbc) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %nlbc.addr = alloca i32, align 4
  %nzrwafgs = alloca i16, align 2
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  store i32 %nlbc, ptr %nlbc.addr, align 4
  %0 = load i32, ptr %nlbc.addr, align 4
  %1 = load ptr, ptr %ns.addr, align 8
  %zns = getelementptr inbounds %struct.NvmeNamespace, ptr %1, i32 0, i32 15
  %zrwafg = getelementptr inbounds %struct.anon.4, ptr %zns, i32 0, i32 1
  %2 = load i16, ptr %zrwafg, align 2
  %conv = zext i16 %2 to i32
  %add = add i32 %0, %conv
  %sub = sub i32 %add, 1
  %3 = load ptr, ptr %ns.addr, align 8
  %zns1 = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 15
  %zrwafg2 = getelementptr inbounds %struct.anon.4, ptr %zns1, i32 0, i32 1
  %4 = load i16, ptr %zrwafg2, align 2
  %conv3 = zext i16 %4 to i32
  %div = udiv i32 %sub, %conv3
  %conv4 = trunc i32 %div to i16
  store i16 %conv4, ptr %nzrwafgs, align 2
  %5 = load i16, ptr %nzrwafgs, align 2
  %conv5 = zext i16 %5 to i32
  %6 = load ptr, ptr %ns.addr, align 8
  %zns6 = getelementptr inbounds %struct.NvmeNamespace, ptr %6, i32 0, i32 15
  %zrwafg7 = getelementptr inbounds %struct.anon.4, ptr %zns6, i32 0, i32 1
  %7 = load i16, ptr %zrwafg7, align 2
  %conv8 = zext i16 %7 to i32
  %mul = mul i32 %conv5, %conv8
  store i32 %mul, ptr %nlbc.addr, align 4
  %8 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %8, i32 0, i32 0
  %zslba = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 5
  %9 = load i64, ptr %zslba, align 8
  %10 = load i32, ptr %nlbc.addr, align 4
  call void @trace_pci_nvme_zoned_zrwa_implicit_flush(i64 noundef %9, i32 noundef %10)
  %11 = load i32, ptr %nlbc.addr, align 4
  %conv9 = zext i32 %11 to i64
  %12 = load ptr, ptr %zone.addr, align 8
  %w_ptr = getelementptr inbounds %struct.NvmeZone, ptr %12, i32 0, i32 1
  %13 = load i64, ptr %w_ptr, align 8
  %add10 = add i64 %13, %conv9
  store i64 %add10, ptr %w_ptr, align 8
  %14 = load ptr, ptr %ns.addr, align 8
  %15 = load ptr, ptr %zone.addr, align 8
  %16 = load i32, ptr %nlbc.addr, align 4
  call void @nvme_advance_zone_wp(ptr noundef %14, ptr noundef %15, i32 noundef %16)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_advance_zone_wp(ptr noundef %ns, ptr noundef %zone, i32 noundef %nlb) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %nlb.addr = alloca i32, align 4
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i32, ptr %nlb.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %1, i32 0, i32 0
  %wp = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 6
  %2 = load i64, ptr %wp, align 8
  %add = add i64 %2, %conv
  store i64 %add, ptr %wp, align 8
  %3 = load ptr, ptr %zone.addr, align 8
  %d1 = getelementptr inbounds %struct.NvmeZone, ptr %3, i32 0, i32 0
  %wp2 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d1, i32 0, i32 6
  %4 = load i64, ptr %wp2, align 8
  %5 = load ptr, ptr %zone.addr, align 8
  %call = call i64 @nvme_zone_wr_boundary(ptr noundef %5)
  %cmp = icmp eq i64 %4, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %ns.addr, align 8
  %7 = load ptr, ptr %zone.addr, align 8
  %call4 = call zeroext i16 @nvme_zrm_finish(ptr noundef %6, ptr noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_zone_idx(ptr noundef %ns, i64 noundef %slba) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %slba.addr = alloca i64, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store i64 %slba, ptr %slba.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %zone_size_log2 = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 26
  %1 = load i32, ptr %zone_size_log2, align 8
  %cmp = icmp ugt i32 %1, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i64, ptr %slba.addr, align 8
  %3 = load ptr, ptr %ns.addr, align 8
  %zone_size_log21 = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 26
  %4 = load i32, ptr %zone_size_log21, align 8
  %sh_prom = zext i32 %4 to i64
  %shr = lshr i64 %2, %sh_prom
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load ptr, ptr %ns.addr, align 8
  %zone_size = getelementptr inbounds %struct.NvmeNamespace, ptr %6, i32 0, i32 24
  %7 = load i64, ptr %zone_size, align 8
  %div = udiv i64 %5, %7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %shr, %cond.true ], [ %div, %cond.false ]
  %conv = trunc i64 %cond to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_zoned_zrwa_implicit_flush(i64 noundef %zslba, i32 noundef %nlb) #0 {
entry:
  %zslba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  store i64 %zslba, ptr %zslba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i64, ptr %zslba.addr, align 8
  %1 = load i32, ptr %nlb.addr, align 4
  call void @_nocheck__trace_pci_nvme_zoned_zrwa_implicit_flush(i64 noundef %0, i32 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_zoned_zrwa_implicit_flush(i64 noundef %zslba, i32 noundef %nlb) #0 {
entry:
  %zslba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %zslba, ptr %zslba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ZONED_ZRWA_IMPLICIT_FLUSH_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %zslba.addr, align 8
  %6 = load i32, ptr %nlb.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.36, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %zslba.addr, align 8
  %8 = load i32, ptr %nlb.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.37, i64 noundef %7, i32 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @nvme_zone_wr_boundary(ptr noundef %zone) #0 {
entry:
  %zone.addr = alloca ptr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  %0 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %0, i32 0, i32 0
  %zslba = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 5
  %1 = load i64, ptr %zslba, align 8
  %2 = load ptr, ptr %zone.addr, align 8
  %d1 = getelementptr inbounds %struct.NvmeZone, ptr %2, i32 0, i32 0
  %zcap = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d1, i32 0, i32 4
  %3 = load i64, ptr %zcap, align 8
  %add = add i64 %1, %3
  ret i64 %add
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_zrm_finish(ptr noundef %ns, ptr noundef %zone) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  %0 = load ptr, ptr %zone.addr, align 8
  %call = call i32 @nvme_get_zone_state(ptr noundef %0)
  switch i32 %call, label %sw.default [
    i32 14, label %sw.bb
    i32 2, label %sw.bb1
    i32 3, label %sw.bb1
    i32 4, label %sw.bb2
    i32 1, label %sw.bb12
  ]

sw.bb:                                            ; preds = %entry
  store i16 0, ptr %retval, align 2
  br label %return

sw.bb1:                                           ; preds = %entry, %entry
  %1 = load ptr, ptr %ns.addr, align 8
  call void @nvme_aor_dec_open(ptr noundef %1)
  br label %sw.bb2

sw.bb2:                                           ; preds = %sw.bb1, %entry
  %2 = load ptr, ptr %ns.addr, align 8
  call void @nvme_aor_dec_active(ptr noundef %2)
  %3 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %3, i32 0, i32 0
  %za = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 2
  %4 = load i8, ptr %za, align 2
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end11

if.then:                                          ; preds = %sw.bb2
  %5 = load ptr, ptr %zone.addr, align 8
  %d3 = getelementptr inbounds %struct.NvmeZone, ptr %5, i32 0, i32 0
  %za4 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d3, i32 0, i32 2
  %6 = load i8, ptr %za4, align 2
  %conv5 = zext i8 %6 to i32
  %and6 = and i32 %conv5, -9
  %conv7 = trunc i32 %and6 to i8
  store i8 %conv7, ptr %za4, align 2
  %7 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %7, i32 0, i32 30
  %numzrwa = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 21
  %8 = load i32, ptr %numzrwa, align 4
  %tobool8 = icmp ne i32 %8, 0
  br i1 %tobool8, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.then
  %9 = load ptr, ptr %ns.addr, align 8
  %zns = getelementptr inbounds %struct.NvmeNamespace, ptr %9, i32 0, i32 15
  %numzrwa10 = getelementptr inbounds %struct.anon.4, ptr %zns, i32 0, i32 2
  %10 = load i32, ptr %numzrwa10, align 4
  %inc = add i32 %10, 1
  store i32 %inc, ptr %numzrwa10, align 4
  br label %if.end

if.end:                                           ; preds = %if.then9, %if.then
  br label %if.end11

if.end11:                                         ; preds = %if.end, %sw.bb2
  br label %sw.bb12

sw.bb12:                                          ; preds = %if.end11, %entry
  %11 = load ptr, ptr %ns.addr, align 8
  %12 = load ptr, ptr %zone.addr, align 8
  call void @nvme_assign_zone_state(ptr noundef %11, ptr noundef %12, i32 noundef 14)
  store i16 0, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %entry
  store i16 447, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.default, %sw.bb12, %sw.bb
  %13 = load i16, ptr %retval, align 2
  ret i16 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_get_zone_state(ptr noundef %zone) #0 {
entry:
  %zone.addr = alloca ptr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  %0 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %0, i32 0, i32 0
  %zs = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 1
  %1 = load i8, ptr %zs, align 1
  %conv = zext i8 %1 to i32
  %shr = ashr i32 %conv, 4
  ret i32 %shr
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_aor_dec_open(ptr noundef %ns) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 30
  %max_open_zones = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 19
  %1 = load i32, ptr %max_open_zones, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ns.addr, align 8
  %nr_open_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %2, i32 0, i32 28
  %3 = load i32, ptr %nr_open_zones, align 8
  %cmp = icmp sgt i32 %3, 0
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  br label %if.end

if.else:                                          ; preds = %if.then
  call void @__assert_fail(ptr noundef @.str.38, ptr noundef @.str.39, i32 noundef 339, ptr noundef @__PRETTY_FUNCTION__.nvme_aor_dec_open) #12
  unreachable

if.end:                                           ; preds = %if.then1
  %4 = load ptr, ptr %ns.addr, align 8
  %nr_open_zones2 = getelementptr inbounds %struct.NvmeNamespace, ptr %4, i32 0, i32 28
  %5 = load i32, ptr %nr_open_zones2, align 8
  %dec = add i32 %5, -1
  store i32 %dec, ptr %nr_open_zones2, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  %6 = load ptr, ptr %ns.addr, align 8
  %nr_open_zones4 = getelementptr inbounds %struct.NvmeNamespace, ptr %6, i32 0, i32 28
  %7 = load i32, ptr %nr_open_zones4, align 8
  %cmp5 = icmp sge i32 %7, 0
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.end3
  br label %if.end8

if.else7:                                         ; preds = %if.end3
  call void @__assert_fail(ptr noundef @.str.40, ptr noundef @.str.39, i32 noundef 342, ptr noundef @__PRETTY_FUNCTION__.nvme_aor_dec_open) #12
  unreachable

if.end8:                                          ; preds = %if.then6
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_aor_dec_active(ptr noundef %ns) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 30
  %max_active_zones = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 18
  %1 = load i32, ptr %max_active_zones, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ns.addr, align 8
  %nr_active_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %2, i32 0, i32 29
  %3 = load i32, ptr %nr_active_zones, align 4
  %cmp = icmp sgt i32 %3, 0
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  br label %if.end

if.else:                                          ; preds = %if.then
  call void @__assert_fail(ptr noundef @.str.41, ptr noundef @.str.39, i32 noundef 357, ptr noundef @__PRETTY_FUNCTION__.nvme_aor_dec_active) #12
  unreachable

if.end:                                           ; preds = %if.then1
  %4 = load ptr, ptr %ns.addr, align 8
  %nr_active_zones2 = getelementptr inbounds %struct.NvmeNamespace, ptr %4, i32 0, i32 29
  %5 = load i32, ptr %nr_active_zones2, align 4
  %dec = add i32 %5, -1
  store i32 %dec, ptr %nr_active_zones2, align 4
  %6 = load ptr, ptr %ns.addr, align 8
  %nr_active_zones3 = getelementptr inbounds %struct.NvmeNamespace, ptr %6, i32 0, i32 29
  %7 = load i32, ptr %nr_active_zones3, align 4
  %8 = load ptr, ptr %ns.addr, align 8
  %nr_open_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %8, i32 0, i32 28
  %9 = load i32, ptr %nr_open_zones, align 8
  %cmp4 = icmp sge i32 %7, %9
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.end
  br label %if.end7

if.else6:                                         ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.42, ptr noundef @.str.39, i32 noundef 359, ptr noundef @__PRETTY_FUNCTION__.nvme_aor_dec_active) #12
  unreachable

if.end7:                                          ; preds = %if.then5
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %entry
  %10 = load ptr, ptr %ns.addr, align 8
  %nr_active_zones9 = getelementptr inbounds %struct.NvmeNamespace, ptr %10, i32 0, i32 29
  %11 = load i32, ptr %nr_active_zones9, align 4
  %cmp10 = icmp sge i32 %11, 0
  br i1 %cmp10, label %if.then11, label %if.else12

if.then11:                                        ; preds = %if.end8
  br label %if.end13

if.else12:                                        ; preds = %if.end8
  call void @__assert_fail(ptr noundef @.str.43, ptr noundef @.str.39, i32 noundef 361, ptr noundef @__PRETTY_FUNCTION__.nvme_aor_dec_active) #12
  unreachable

if.end13:                                         ; preds = %if.then11
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_assign_zone_state(ptr noundef %ns, ptr noundef %zone, i32 noundef %state) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %state.addr = alloca i32, align 4
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  store i32 %state, ptr %state.addr, align 4
  %0 = load ptr, ptr %zone.addr, align 8
  %entry1 = getelementptr inbounds %struct.NvmeZone, ptr %0, i32 0, i32 2
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %entry1, i32 0, i32 1
  %1 = load ptr, ptr %tql_prev, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end96

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %zone.addr, align 8
  %call = call i32 @nvme_get_zone_state(ptr noundef %2)
  switch i32 %call, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb21
    i32 4, label %sw.bb46
    i32 14, label %sw.bb71
  ]

sw.bb:                                            ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %3 = load ptr, ptr %zone.addr, align 8
  %entry2 = getelementptr inbounds %struct.NvmeZone, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %entry2, align 8
  %cmp3 = icmp ne ptr %4, null
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %do.body
  %5 = load ptr, ptr %zone.addr, align 8
  %entry5 = getelementptr inbounds %struct.NvmeZone, ptr %5, i32 0, i32 2
  %tql_prev6 = getelementptr inbounds %struct.QTailQLink, ptr %entry5, i32 0, i32 1
  %6 = load ptr, ptr %tql_prev6, align 8
  %7 = load ptr, ptr %zone.addr, align 8
  %entry7 = getelementptr inbounds %struct.NvmeZone, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %entry7, align 8
  %entry8 = getelementptr inbounds %struct.NvmeZone, ptr %8, i32 0, i32 2
  %tql_prev9 = getelementptr inbounds %struct.QTailQLink, ptr %entry8, i32 0, i32 1
  store ptr %6, ptr %tql_prev9, align 8
  br label %if.end

if.else:                                          ; preds = %do.body
  %9 = load ptr, ptr %zone.addr, align 8
  %entry10 = getelementptr inbounds %struct.NvmeZone, ptr %9, i32 0, i32 2
  %tql_prev11 = getelementptr inbounds %struct.QTailQLink, ptr %entry10, i32 0, i32 1
  %10 = load ptr, ptr %tql_prev11, align 8
  %11 = load ptr, ptr %ns.addr, align 8
  %exp_open_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %11, i32 0, i32 19
  %tql_prev12 = getelementptr inbounds %struct.QTailQLink, ptr %exp_open_zones, i32 0, i32 1
  store ptr %10, ptr %tql_prev12, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then4
  %12 = load ptr, ptr %zone.addr, align 8
  %entry13 = getelementptr inbounds %struct.NvmeZone, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %entry13, align 8
  %14 = load ptr, ptr %zone.addr, align 8
  %entry14 = getelementptr inbounds %struct.NvmeZone, ptr %14, i32 0, i32 2
  %tql_prev15 = getelementptr inbounds %struct.QTailQLink, ptr %entry14, i32 0, i32 1
  %15 = load ptr, ptr %tql_prev15, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %15, i32 0, i32 0
  store ptr %13, ptr %tql_next, align 8
  %16 = load ptr, ptr %zone.addr, align 8
  %entry16 = getelementptr inbounds %struct.NvmeZone, ptr %16, i32 0, i32 2
  %tql_prev17 = getelementptr inbounds %struct.QTailQLink, ptr %entry16, i32 0, i32 1
  store ptr null, ptr %tql_prev17, align 8
  %17 = load ptr, ptr %zone.addr, align 8
  %entry18 = getelementptr inbounds %struct.NvmeZone, ptr %17, i32 0, i32 2
  %tql_next19 = getelementptr inbounds %struct.QTailQLink, ptr %entry18, i32 0, i32 0
  store ptr null, ptr %tql_next19, align 8
  %18 = load ptr, ptr %zone.addr, align 8
  %entry20 = getelementptr inbounds %struct.NvmeZone, ptr %18, i32 0, i32 2
  store ptr null, ptr %entry20, align 8
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %sw.epilog

sw.bb21:                                          ; preds = %if.then
  br label %do.body22

do.body22:                                        ; preds = %sw.bb21
  %19 = load ptr, ptr %zone.addr, align 8
  %entry23 = getelementptr inbounds %struct.NvmeZone, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %entry23, align 8
  %cmp24 = icmp ne ptr %20, null
  br i1 %cmp24, label %if.then25, label %if.else31

if.then25:                                        ; preds = %do.body22
  %21 = load ptr, ptr %zone.addr, align 8
  %entry26 = getelementptr inbounds %struct.NvmeZone, ptr %21, i32 0, i32 2
  %tql_prev27 = getelementptr inbounds %struct.QTailQLink, ptr %entry26, i32 0, i32 1
  %22 = load ptr, ptr %tql_prev27, align 8
  %23 = load ptr, ptr %zone.addr, align 8
  %entry28 = getelementptr inbounds %struct.NvmeZone, ptr %23, i32 0, i32 2
  %24 = load ptr, ptr %entry28, align 8
  %entry29 = getelementptr inbounds %struct.NvmeZone, ptr %24, i32 0, i32 2
  %tql_prev30 = getelementptr inbounds %struct.QTailQLink, ptr %entry29, i32 0, i32 1
  store ptr %22, ptr %tql_prev30, align 8
  br label %if.end35

if.else31:                                        ; preds = %do.body22
  %25 = load ptr, ptr %zone.addr, align 8
  %entry32 = getelementptr inbounds %struct.NvmeZone, ptr %25, i32 0, i32 2
  %tql_prev33 = getelementptr inbounds %struct.QTailQLink, ptr %entry32, i32 0, i32 1
  %26 = load ptr, ptr %tql_prev33, align 8
  %27 = load ptr, ptr %ns.addr, align 8
  %imp_open_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %27, i32 0, i32 20
  %tql_prev34 = getelementptr inbounds %struct.QTailQLink, ptr %imp_open_zones, i32 0, i32 1
  store ptr %26, ptr %tql_prev34, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.else31, %if.then25
  %28 = load ptr, ptr %zone.addr, align 8
  %entry36 = getelementptr inbounds %struct.NvmeZone, ptr %28, i32 0, i32 2
  %29 = load ptr, ptr %entry36, align 8
  %30 = load ptr, ptr %zone.addr, align 8
  %entry37 = getelementptr inbounds %struct.NvmeZone, ptr %30, i32 0, i32 2
  %tql_prev38 = getelementptr inbounds %struct.QTailQLink, ptr %entry37, i32 0, i32 1
  %31 = load ptr, ptr %tql_prev38, align 8
  %tql_next39 = getelementptr inbounds %struct.QTailQLink, ptr %31, i32 0, i32 0
  store ptr %29, ptr %tql_next39, align 8
  %32 = load ptr, ptr %zone.addr, align 8
  %entry40 = getelementptr inbounds %struct.NvmeZone, ptr %32, i32 0, i32 2
  %tql_prev41 = getelementptr inbounds %struct.QTailQLink, ptr %entry40, i32 0, i32 1
  store ptr null, ptr %tql_prev41, align 8
  %33 = load ptr, ptr %zone.addr, align 8
  %entry42 = getelementptr inbounds %struct.NvmeZone, ptr %33, i32 0, i32 2
  %tql_next43 = getelementptr inbounds %struct.QTailQLink, ptr %entry42, i32 0, i32 0
  store ptr null, ptr %tql_next43, align 8
  %34 = load ptr, ptr %zone.addr, align 8
  %entry44 = getelementptr inbounds %struct.NvmeZone, ptr %34, i32 0, i32 2
  store ptr null, ptr %entry44, align 8
  br label %do.end45

do.end45:                                         ; preds = %if.end35
  br label %sw.epilog

sw.bb46:                                          ; preds = %if.then
  br label %do.body47

do.body47:                                        ; preds = %sw.bb46
  %35 = load ptr, ptr %zone.addr, align 8
  %entry48 = getelementptr inbounds %struct.NvmeZone, ptr %35, i32 0, i32 2
  %36 = load ptr, ptr %entry48, align 8
  %cmp49 = icmp ne ptr %36, null
  br i1 %cmp49, label %if.then50, label %if.else56

if.then50:                                        ; preds = %do.body47
  %37 = load ptr, ptr %zone.addr, align 8
  %entry51 = getelementptr inbounds %struct.NvmeZone, ptr %37, i32 0, i32 2
  %tql_prev52 = getelementptr inbounds %struct.QTailQLink, ptr %entry51, i32 0, i32 1
  %38 = load ptr, ptr %tql_prev52, align 8
  %39 = load ptr, ptr %zone.addr, align 8
  %entry53 = getelementptr inbounds %struct.NvmeZone, ptr %39, i32 0, i32 2
  %40 = load ptr, ptr %entry53, align 8
  %entry54 = getelementptr inbounds %struct.NvmeZone, ptr %40, i32 0, i32 2
  %tql_prev55 = getelementptr inbounds %struct.QTailQLink, ptr %entry54, i32 0, i32 1
  store ptr %38, ptr %tql_prev55, align 8
  br label %if.end60

if.else56:                                        ; preds = %do.body47
  %41 = load ptr, ptr %zone.addr, align 8
  %entry57 = getelementptr inbounds %struct.NvmeZone, ptr %41, i32 0, i32 2
  %tql_prev58 = getelementptr inbounds %struct.QTailQLink, ptr %entry57, i32 0, i32 1
  %42 = load ptr, ptr %tql_prev58, align 8
  %43 = load ptr, ptr %ns.addr, align 8
  %closed_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %43, i32 0, i32 21
  %tql_prev59 = getelementptr inbounds %struct.QTailQLink, ptr %closed_zones, i32 0, i32 1
  store ptr %42, ptr %tql_prev59, align 8
  br label %if.end60

if.end60:                                         ; preds = %if.else56, %if.then50
  %44 = load ptr, ptr %zone.addr, align 8
  %entry61 = getelementptr inbounds %struct.NvmeZone, ptr %44, i32 0, i32 2
  %45 = load ptr, ptr %entry61, align 8
  %46 = load ptr, ptr %zone.addr, align 8
  %entry62 = getelementptr inbounds %struct.NvmeZone, ptr %46, i32 0, i32 2
  %tql_prev63 = getelementptr inbounds %struct.QTailQLink, ptr %entry62, i32 0, i32 1
  %47 = load ptr, ptr %tql_prev63, align 8
  %tql_next64 = getelementptr inbounds %struct.QTailQLink, ptr %47, i32 0, i32 0
  store ptr %45, ptr %tql_next64, align 8
  %48 = load ptr, ptr %zone.addr, align 8
  %entry65 = getelementptr inbounds %struct.NvmeZone, ptr %48, i32 0, i32 2
  %tql_prev66 = getelementptr inbounds %struct.QTailQLink, ptr %entry65, i32 0, i32 1
  store ptr null, ptr %tql_prev66, align 8
  %49 = load ptr, ptr %zone.addr, align 8
  %entry67 = getelementptr inbounds %struct.NvmeZone, ptr %49, i32 0, i32 2
  %tql_next68 = getelementptr inbounds %struct.QTailQLink, ptr %entry67, i32 0, i32 0
  store ptr null, ptr %tql_next68, align 8
  %50 = load ptr, ptr %zone.addr, align 8
  %entry69 = getelementptr inbounds %struct.NvmeZone, ptr %50, i32 0, i32 2
  store ptr null, ptr %entry69, align 8
  br label %do.end70

do.end70:                                         ; preds = %if.end60
  br label %sw.epilog

sw.bb71:                                          ; preds = %if.then
  br label %do.body72

do.body72:                                        ; preds = %sw.bb71
  %51 = load ptr, ptr %zone.addr, align 8
  %entry73 = getelementptr inbounds %struct.NvmeZone, ptr %51, i32 0, i32 2
  %52 = load ptr, ptr %entry73, align 8
  %cmp74 = icmp ne ptr %52, null
  br i1 %cmp74, label %if.then75, label %if.else81

if.then75:                                        ; preds = %do.body72
  %53 = load ptr, ptr %zone.addr, align 8
  %entry76 = getelementptr inbounds %struct.NvmeZone, ptr %53, i32 0, i32 2
  %tql_prev77 = getelementptr inbounds %struct.QTailQLink, ptr %entry76, i32 0, i32 1
  %54 = load ptr, ptr %tql_prev77, align 8
  %55 = load ptr, ptr %zone.addr, align 8
  %entry78 = getelementptr inbounds %struct.NvmeZone, ptr %55, i32 0, i32 2
  %56 = load ptr, ptr %entry78, align 8
  %entry79 = getelementptr inbounds %struct.NvmeZone, ptr %56, i32 0, i32 2
  %tql_prev80 = getelementptr inbounds %struct.QTailQLink, ptr %entry79, i32 0, i32 1
  store ptr %54, ptr %tql_prev80, align 8
  br label %if.end85

if.else81:                                        ; preds = %do.body72
  %57 = load ptr, ptr %zone.addr, align 8
  %entry82 = getelementptr inbounds %struct.NvmeZone, ptr %57, i32 0, i32 2
  %tql_prev83 = getelementptr inbounds %struct.QTailQLink, ptr %entry82, i32 0, i32 1
  %58 = load ptr, ptr %tql_prev83, align 8
  %59 = load ptr, ptr %ns.addr, align 8
  %full_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %59, i32 0, i32 22
  %tql_prev84 = getelementptr inbounds %struct.QTailQLink, ptr %full_zones, i32 0, i32 1
  store ptr %58, ptr %tql_prev84, align 8
  br label %if.end85

if.end85:                                         ; preds = %if.else81, %if.then75
  %60 = load ptr, ptr %zone.addr, align 8
  %entry86 = getelementptr inbounds %struct.NvmeZone, ptr %60, i32 0, i32 2
  %61 = load ptr, ptr %entry86, align 8
  %62 = load ptr, ptr %zone.addr, align 8
  %entry87 = getelementptr inbounds %struct.NvmeZone, ptr %62, i32 0, i32 2
  %tql_prev88 = getelementptr inbounds %struct.QTailQLink, ptr %entry87, i32 0, i32 1
  %63 = load ptr, ptr %tql_prev88, align 8
  %tql_next89 = getelementptr inbounds %struct.QTailQLink, ptr %63, i32 0, i32 0
  store ptr %61, ptr %tql_next89, align 8
  %64 = load ptr, ptr %zone.addr, align 8
  %entry90 = getelementptr inbounds %struct.NvmeZone, ptr %64, i32 0, i32 2
  %tql_prev91 = getelementptr inbounds %struct.QTailQLink, ptr %entry90, i32 0, i32 1
  store ptr null, ptr %tql_prev91, align 8
  %65 = load ptr, ptr %zone.addr, align 8
  %entry92 = getelementptr inbounds %struct.NvmeZone, ptr %65, i32 0, i32 2
  %tql_next93 = getelementptr inbounds %struct.QTailQLink, ptr %entry92, i32 0, i32 0
  store ptr null, ptr %tql_next93, align 8
  %66 = load ptr, ptr %zone.addr, align 8
  %entry94 = getelementptr inbounds %struct.NvmeZone, ptr %66, i32 0, i32 2
  store ptr null, ptr %entry94, align 8
  br label %do.end95

do.end95:                                         ; preds = %if.end85
  br label %sw.default

sw.default:                                       ; preds = %do.end95, %if.then
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %do.end70, %do.end45, %do.end
  br label %if.end96

if.end96:                                         ; preds = %sw.epilog, %entry
  %67 = load ptr, ptr %zone.addr, align 8
  %68 = load i32, ptr %state.addr, align 4
  call void @nvme_set_zone_state(ptr noundef %67, i32 noundef %68)
  %69 = load i32, ptr %state.addr, align 4
  switch i32 %69, label %sw.default154 [
    i32 3, label %sw.bb97
    i32 2, label %sw.bb111
    i32 4, label %sw.bb125
    i32 14, label %sw.bb139
    i32 13, label %sw.bb153
  ]

sw.bb97:                                          ; preds = %if.end96
  br label %do.body98

do.body98:                                        ; preds = %sw.bb97
  %70 = load ptr, ptr %zone.addr, align 8
  %entry99 = getelementptr inbounds %struct.NvmeZone, ptr %70, i32 0, i32 2
  store ptr null, ptr %entry99, align 8
  %71 = load ptr, ptr %ns.addr, align 8
  %exp_open_zones100 = getelementptr inbounds %struct.NvmeNamespace, ptr %71, i32 0, i32 19
  %tql_prev101 = getelementptr inbounds %struct.QTailQLink, ptr %exp_open_zones100, i32 0, i32 1
  %72 = load ptr, ptr %tql_prev101, align 8
  %73 = load ptr, ptr %zone.addr, align 8
  %entry102 = getelementptr inbounds %struct.NvmeZone, ptr %73, i32 0, i32 2
  %tql_prev103 = getelementptr inbounds %struct.QTailQLink, ptr %entry102, i32 0, i32 1
  store ptr %72, ptr %tql_prev103, align 8
  %74 = load ptr, ptr %zone.addr, align 8
  %75 = load ptr, ptr %ns.addr, align 8
  %exp_open_zones104 = getelementptr inbounds %struct.NvmeNamespace, ptr %75, i32 0, i32 19
  %tql_prev105 = getelementptr inbounds %struct.QTailQLink, ptr %exp_open_zones104, i32 0, i32 1
  %76 = load ptr, ptr %tql_prev105, align 8
  %tql_next106 = getelementptr inbounds %struct.QTailQLink, ptr %76, i32 0, i32 0
  store ptr %74, ptr %tql_next106, align 8
  %77 = load ptr, ptr %zone.addr, align 8
  %entry107 = getelementptr inbounds %struct.NvmeZone, ptr %77, i32 0, i32 2
  %78 = load ptr, ptr %ns.addr, align 8
  %exp_open_zones108 = getelementptr inbounds %struct.NvmeNamespace, ptr %78, i32 0, i32 19
  %tql_prev109 = getelementptr inbounds %struct.QTailQLink, ptr %exp_open_zones108, i32 0, i32 1
  store ptr %entry107, ptr %tql_prev109, align 8
  br label %do.end110

do.end110:                                        ; preds = %do.body98
  br label %sw.epilog155

sw.bb111:                                         ; preds = %if.end96
  br label %do.body112

do.body112:                                       ; preds = %sw.bb111
  %79 = load ptr, ptr %zone.addr, align 8
  %entry113 = getelementptr inbounds %struct.NvmeZone, ptr %79, i32 0, i32 2
  store ptr null, ptr %entry113, align 8
  %80 = load ptr, ptr %ns.addr, align 8
  %imp_open_zones114 = getelementptr inbounds %struct.NvmeNamespace, ptr %80, i32 0, i32 20
  %tql_prev115 = getelementptr inbounds %struct.QTailQLink, ptr %imp_open_zones114, i32 0, i32 1
  %81 = load ptr, ptr %tql_prev115, align 8
  %82 = load ptr, ptr %zone.addr, align 8
  %entry116 = getelementptr inbounds %struct.NvmeZone, ptr %82, i32 0, i32 2
  %tql_prev117 = getelementptr inbounds %struct.QTailQLink, ptr %entry116, i32 0, i32 1
  store ptr %81, ptr %tql_prev117, align 8
  %83 = load ptr, ptr %zone.addr, align 8
  %84 = load ptr, ptr %ns.addr, align 8
  %imp_open_zones118 = getelementptr inbounds %struct.NvmeNamespace, ptr %84, i32 0, i32 20
  %tql_prev119 = getelementptr inbounds %struct.QTailQLink, ptr %imp_open_zones118, i32 0, i32 1
  %85 = load ptr, ptr %tql_prev119, align 8
  %tql_next120 = getelementptr inbounds %struct.QTailQLink, ptr %85, i32 0, i32 0
  store ptr %83, ptr %tql_next120, align 8
  %86 = load ptr, ptr %zone.addr, align 8
  %entry121 = getelementptr inbounds %struct.NvmeZone, ptr %86, i32 0, i32 2
  %87 = load ptr, ptr %ns.addr, align 8
  %imp_open_zones122 = getelementptr inbounds %struct.NvmeNamespace, ptr %87, i32 0, i32 20
  %tql_prev123 = getelementptr inbounds %struct.QTailQLink, ptr %imp_open_zones122, i32 0, i32 1
  store ptr %entry121, ptr %tql_prev123, align 8
  br label %do.end124

do.end124:                                        ; preds = %do.body112
  br label %sw.epilog155

sw.bb125:                                         ; preds = %if.end96
  br label %do.body126

do.body126:                                       ; preds = %sw.bb125
  %88 = load ptr, ptr %zone.addr, align 8
  %entry127 = getelementptr inbounds %struct.NvmeZone, ptr %88, i32 0, i32 2
  store ptr null, ptr %entry127, align 8
  %89 = load ptr, ptr %ns.addr, align 8
  %closed_zones128 = getelementptr inbounds %struct.NvmeNamespace, ptr %89, i32 0, i32 21
  %tql_prev129 = getelementptr inbounds %struct.QTailQLink, ptr %closed_zones128, i32 0, i32 1
  %90 = load ptr, ptr %tql_prev129, align 8
  %91 = load ptr, ptr %zone.addr, align 8
  %entry130 = getelementptr inbounds %struct.NvmeZone, ptr %91, i32 0, i32 2
  %tql_prev131 = getelementptr inbounds %struct.QTailQLink, ptr %entry130, i32 0, i32 1
  store ptr %90, ptr %tql_prev131, align 8
  %92 = load ptr, ptr %zone.addr, align 8
  %93 = load ptr, ptr %ns.addr, align 8
  %closed_zones132 = getelementptr inbounds %struct.NvmeNamespace, ptr %93, i32 0, i32 21
  %tql_prev133 = getelementptr inbounds %struct.QTailQLink, ptr %closed_zones132, i32 0, i32 1
  %94 = load ptr, ptr %tql_prev133, align 8
  %tql_next134 = getelementptr inbounds %struct.QTailQLink, ptr %94, i32 0, i32 0
  store ptr %92, ptr %tql_next134, align 8
  %95 = load ptr, ptr %zone.addr, align 8
  %entry135 = getelementptr inbounds %struct.NvmeZone, ptr %95, i32 0, i32 2
  %96 = load ptr, ptr %ns.addr, align 8
  %closed_zones136 = getelementptr inbounds %struct.NvmeNamespace, ptr %96, i32 0, i32 21
  %tql_prev137 = getelementptr inbounds %struct.QTailQLink, ptr %closed_zones136, i32 0, i32 1
  store ptr %entry135, ptr %tql_prev137, align 8
  br label %do.end138

do.end138:                                        ; preds = %do.body126
  br label %sw.epilog155

sw.bb139:                                         ; preds = %if.end96
  br label %do.body140

do.body140:                                       ; preds = %sw.bb139
  %97 = load ptr, ptr %zone.addr, align 8
  %entry141 = getelementptr inbounds %struct.NvmeZone, ptr %97, i32 0, i32 2
  store ptr null, ptr %entry141, align 8
  %98 = load ptr, ptr %ns.addr, align 8
  %full_zones142 = getelementptr inbounds %struct.NvmeNamespace, ptr %98, i32 0, i32 22
  %tql_prev143 = getelementptr inbounds %struct.QTailQLink, ptr %full_zones142, i32 0, i32 1
  %99 = load ptr, ptr %tql_prev143, align 8
  %100 = load ptr, ptr %zone.addr, align 8
  %entry144 = getelementptr inbounds %struct.NvmeZone, ptr %100, i32 0, i32 2
  %tql_prev145 = getelementptr inbounds %struct.QTailQLink, ptr %entry144, i32 0, i32 1
  store ptr %99, ptr %tql_prev145, align 8
  %101 = load ptr, ptr %zone.addr, align 8
  %102 = load ptr, ptr %ns.addr, align 8
  %full_zones146 = getelementptr inbounds %struct.NvmeNamespace, ptr %102, i32 0, i32 22
  %tql_prev147 = getelementptr inbounds %struct.QTailQLink, ptr %full_zones146, i32 0, i32 1
  %103 = load ptr, ptr %tql_prev147, align 8
  %tql_next148 = getelementptr inbounds %struct.QTailQLink, ptr %103, i32 0, i32 0
  store ptr %101, ptr %tql_next148, align 8
  %104 = load ptr, ptr %zone.addr, align 8
  %entry149 = getelementptr inbounds %struct.NvmeZone, ptr %104, i32 0, i32 2
  %105 = load ptr, ptr %ns.addr, align 8
  %full_zones150 = getelementptr inbounds %struct.NvmeNamespace, ptr %105, i32 0, i32 22
  %tql_prev151 = getelementptr inbounds %struct.QTailQLink, ptr %full_zones150, i32 0, i32 1
  store ptr %entry149, ptr %tql_prev151, align 8
  br label %do.end152

do.end152:                                        ; preds = %do.body140
  br label %sw.bb153

sw.bb153:                                         ; preds = %do.end152, %if.end96
  br label %sw.epilog155

sw.default154:                                    ; preds = %if.end96
  %106 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %106, i32 0, i32 0
  %za = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 2
  store i8 0, ptr %za, align 2
  br label %sw.epilog155

sw.epilog155:                                     ; preds = %sw.default154, %sw.bb153, %do.end138, %do.end124, %do.end110
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_set_zone_state(ptr noundef %zone, i32 noundef %state) #0 {
entry:
  %zone.addr = alloca ptr, align 8
  %state.addr = alloca i32, align 4
  store ptr %zone, ptr %zone.addr, align 8
  store i32 %state, ptr %state.addr, align 4
  %0 = load i32, ptr %state.addr, align 4
  %shl = shl i32 %0, 4
  %conv = trunc i32 %shl to i8
  %1 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %1, i32 0, i32 0
  %zs = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 1
  store i8 %conv, ptr %zs, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_enqueue_req_completion(i16 noundef zeroext %cid, i16 noundef zeroext %cqid, i32 noundef %dw0, i32 noundef %dw1, i16 noundef zeroext %status) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %cqid.addr = alloca i16, align 2
  %dw0.addr = alloca i32, align 4
  %dw1.addr = alloca i32, align 4
  %status.addr = alloca i16, align 2
  store i16 %cid, ptr %cid.addr, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  store i32 %dw0, ptr %dw0.addr, align 4
  store i32 %dw1, ptr %dw1.addr, align 4
  store i16 %status, ptr %status.addr, align 2
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i16, ptr %cqid.addr, align 2
  %2 = load i32, ptr %dw0.addr, align 4
  %3 = load i32, ptr %dw1.addr, align 4
  %4 = load i16, ptr %status.addr, align 2
  call void @_nocheck__trace_pci_nvme_enqueue_req_completion(i16 noundef zeroext %0, i16 noundef zeroext %1, i32 noundef %2, i32 noundef %3, i16 noundef zeroext %4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_req_status(i16 noundef zeroext %cid, i32 noundef %nsid, i16 noundef zeroext %status, i8 noundef zeroext %opc) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %status.addr = alloca i16, align 2
  %opc.addr = alloca i8, align 1
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i16 %status, ptr %status.addr, align 2
  store i8 %opc, ptr %opc.addr, align 1
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i32, ptr %nsid.addr, align 4
  %2 = load i16, ptr %status.addr, align 2
  %3 = load i8, ptr %opc.addr, align 1
  call void @_nocheck__trace_pci_nvme_err_req_status(i16 noundef zeroext %0, i32 noundef %1, i16 noundef zeroext %2, i8 noundef zeroext %3)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_nsid(ptr noundef %ns) #0 {
entry:
  %retval = alloca i32, align 4
  %ns.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %1, i32 0, i32 30
  %nsid = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 2
  %2 = load i32, ptr %nsid, align 4
  store i32 %2, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i32, ptr %retval, align 4
  ret i32 %3
}

declare void @qemu_bh_schedule(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_enqueue_req_completion(i16 noundef zeroext %cid, i16 noundef zeroext %cqid, i32 noundef %dw0, i32 noundef %dw1, i16 noundef zeroext %status) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %cqid.addr = alloca i16, align 2
  %dw0.addr = alloca i32, align 4
  %dw1.addr = alloca i32, align 4
  %status.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  store i32 %dw0, ptr %dw0.addr, align 4
  store i32 %dw1, ptr %dw1.addr, align 4
  store i16 %status, ptr %status.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end17

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end17

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i16, ptr %cqid.addr, align 2
  %conv12 = zext i16 %6 to i32
  %7 = load i32, ptr %dw0.addr, align 4
  %8 = load i32, ptr %dw1.addr, align 4
  %9 = load i16, ptr %status.addr, align 2
  %conv13 = zext i16 %9 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.45, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12, i32 noundef %7, i32 noundef %8, i32 noundef %conv13)
  br label %if.end

if.else:                                          ; preds = %if.then
  %10 = load i16, ptr %cid.addr, align 2
  %conv14 = zext i16 %10 to i32
  %11 = load i16, ptr %cqid.addr, align 2
  %conv15 = zext i16 %11 to i32
  %12 = load i32, ptr %dw0.addr, align 4
  %13 = load i32, ptr %dw1.addr, align 4
  %14 = load i16, ptr %status.addr, align 2
  %conv16 = zext i16 %14 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.46, i32 noundef %conv14, i32 noundef %conv15, i32 noundef %12, i32 noundef %13, i32 noundef %conv16)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end17

if.end17:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_req_status(i16 noundef zeroext %cid, i32 noundef %nsid, i16 noundef zeroext %status, i8 noundef zeroext %opc) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %status.addr = alloca i16, align 2
  %opc.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i16 %status, ptr %status.addr, align 2
  store i8 %opc, ptr %opc.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_REQ_STATUS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end17

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end17

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i32, ptr %nsid.addr, align 4
  %7 = load i16, ptr %status.addr, align 2
  %conv12 = zext i16 %7 to i32
  %8 = load i8, ptr %opc.addr, align 1
  %conv13 = zext i8 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.47, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %6, i32 noundef %conv12, i32 noundef %conv13)
  br label %if.end

if.else:                                          ; preds = %if.then
  %9 = load i16, ptr %cid.addr, align 2
  %conv14 = zext i16 %9 to i32
  %10 = load i32, ptr %nsid.addr, align 4
  %11 = load i16, ptr %status.addr, align 2
  %conv15 = zext i16 %11 to i32
  %12 = load i8, ptr %opc.addr, align 1
  %conv16 = zext i8 %12 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.48, i32 noundef %conv14, i32 noundef %10, i32 noundef %conv15, i32 noundef %conv16)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end17

if.end17:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

declare ptr @type_register_static(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_instance_init(ptr noundef %obj) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  %n = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %call = call ptr @object_dynamic_cast_assert(ptr noundef %0, ptr noundef @.str.49, ptr noundef @.str.1, i32 noundef 8526, ptr noundef @__func__.nvme_instance_init)
  store ptr %call, ptr %n, align 8
  %1 = load ptr, ptr %obj.addr, align 8
  %2 = load ptr, ptr %n, align 8
  %namespace = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 34
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %namespace, i32 0, i32 1
  %bootindex = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 6
  %3 = load ptr, ptr %obj.addr, align 8
  %call1 = call ptr @DEVICE(ptr noundef %3)
  call void @device_add_bootindex_property(ptr noundef %1, ptr noundef %bootindex, ptr noundef @.str.51, ptr noundef @.str.52, ptr noundef %call1)
  %4 = load ptr, ptr %obj.addr, align 8
  %call2 = call ptr @object_property_add(ptr noundef %4, ptr noundef @.str.53, ptr noundef @.str.54, ptr noundef @nvme_get_smart_warning, ptr noundef @nvme_set_smart_warning, ptr noundef null, ptr noundef null)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_class_init(ptr noundef %oc, ptr noundef %data) #0 {
entry:
  %oc.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %dc = alloca ptr, align 8
  %pc = alloca ptr, align 8
  store ptr %oc, ptr %oc.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  %0 = load ptr, ptr %oc.addr, align 8
  %call = call ptr @DEVICE_CLASS(ptr noundef %0)
  store ptr %call, ptr %dc, align 8
  %1 = load ptr, ptr %oc.addr, align 8
  %call1 = call ptr @PCI_DEVICE_CLASS(ptr noundef %1)
  store ptr %call1, ptr %pc, align 8
  %2 = load ptr, ptr %pc, align 8
  %realize = getelementptr inbounds %struct.PCIDeviceClass, ptr %2, i32 0, i32 1
  store ptr @nvme_realize, ptr %realize, align 8
  %3 = load ptr, ptr %pc, align 8
  %config_write = getelementptr inbounds %struct.PCIDeviceClass, ptr %3, i32 0, i32 4
  store ptr @nvme_pci_write_config, ptr %config_write, align 8
  %4 = load ptr, ptr %pc, align 8
  %exit = getelementptr inbounds %struct.PCIDeviceClass, ptr %4, i32 0, i32 2
  store ptr @nvme_exit, ptr %exit, align 8
  %5 = load ptr, ptr %pc, align 8
  %class_id = getelementptr inbounds %struct.PCIDeviceClass, ptr %5, i32 0, i32 8
  store i16 264, ptr %class_id, align 2
  %6 = load ptr, ptr %pc, align 8
  %revision = getelementptr inbounds %struct.PCIDeviceClass, ptr %6, i32 0, i32 7
  store i8 2, ptr %revision, align 4
  %7 = load ptr, ptr %dc, align 8
  %categories = getelementptr inbounds %struct.DeviceClass, ptr %7, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1 x i64], ptr %categories, i64 0, i64 0
  call void @set_bit(i64 noundef 2, ptr noundef %arraydecay)
  %8 = load ptr, ptr %dc, align 8
  %desc = getelementptr inbounds %struct.DeviceClass, ptr %8, i32 0, i32 3
  store ptr @.str.68, ptr %desc, align 8
  %9 = load ptr, ptr %dc, align 8
  call void @device_class_set_props(ptr noundef %9, ptr noundef @nvme_props)
  %10 = load ptr, ptr %dc, align 8
  %vmsd = getelementptr inbounds %struct.DeviceClass, ptr %10, i32 0, i32 10
  store ptr @nvme_vmstate, ptr %vmsd, align 8
  %11 = load ptr, ptr %dc, align 8
  %reset = getelementptr inbounds %struct.DeviceClass, ptr %11, i32 0, i32 7
  store ptr @nvme_pci_reset, ptr %reset, align 8
  ret void
}

declare void @device_add_bootindex_property(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

declare ptr @object_property_add(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_get_smart_warning(ptr noundef %obj, ptr noundef %v, ptr noundef %name, ptr noundef %opaque, ptr noundef %errp) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %opaque.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %n = alloca ptr, align 8
  %value = alloca i8, align 1
  store ptr %obj, ptr %obj.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %call = call ptr @object_dynamic_cast_assert(ptr noundef %0, ptr noundef @.str.49, ptr noundef @.str.1, i32 noundef 8421, ptr noundef @__func__.nvme_get_smart_warning)
  store ptr %call, ptr %n, align 8
  %1 = load ptr, ptr %n, align 8
  %smart_critical_warning = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 19
  %2 = load i8, ptr %smart_critical_warning, align 2
  store i8 %2, ptr %value, align 1
  %3 = load ptr, ptr %v.addr, align 8
  %4 = load ptr, ptr %name.addr, align 8
  %5 = load ptr, ptr %errp.addr, align 8
  %call1 = call zeroext i1 @visit_type_uint8(ptr noundef %3, ptr noundef %4, ptr noundef %value, ptr noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_set_smart_warning(ptr noundef %obj, ptr noundef %v, ptr noundef %name, ptr noundef %opaque, ptr noundef %errp) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %opaque.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %n = alloca ptr, align 8
  %value = alloca i8, align 1
  %old_value = alloca i8, align 1
  %cap = alloca i8, align 1
  %index = alloca i8, align 1
  %event = alloca i8, align 1
  store ptr %obj, ptr %obj.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %call = call ptr @object_dynamic_cast_assert(ptr noundef %0, ptr noundef @.str.49, ptr noundef @.str.1, i32 noundef 8430, ptr noundef @__func__.nvme_set_smart_warning)
  store ptr %call, ptr %n, align 8
  store i8 0, ptr %cap, align 1
  %1 = load ptr, ptr %v.addr, align 8
  %2 = load ptr, ptr %name.addr, align 8
  %3 = load ptr, ptr %errp.addr, align 8
  %call1 = call zeroext i1 @visit_type_uint8(ptr noundef %1, ptr noundef %2, ptr noundef %value, ptr noundef %3)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i8 31, ptr %cap, align 1
  %4 = load ptr, ptr %n, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 3
  %cap2 = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 0
  %call3 = call i64 @ldq_le_p(ptr noundef %cap2)
  %shr = lshr i64 %call3, 56
  %and = and i64 %shr, 1
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %5 = load i8, ptr %cap, align 1
  %conv = zext i8 %5 to i32
  %or = or i32 %conv, 32
  %conv5 = trunc i32 %or to i8
  store i8 %conv5, ptr %cap, align 1
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  %6 = load i8, ptr %value, align 1
  %conv7 = zext i8 %6 to i32
  %7 = load i8, ptr %cap, align 1
  %conv8 = zext i8 %7 to i32
  %and9 = and i32 %conv7, %conv8
  %8 = load i8, ptr %value, align 1
  %conv10 = zext i8 %8 to i32
  %cmp = icmp ne i32 %and9, %conv10
  br i1 %cmp, label %if.then12, label %if.end16

if.then12:                                        ; preds = %if.end6
  %9 = load ptr, ptr %errp.addr, align 8
  %10 = load i8, ptr %value, align 1
  %conv13 = zext i8 %10 to i32
  %11 = load i8, ptr %cap, align 1
  %conv14 = zext i8 %11 to i32
  %not = xor i32 %conv14, -1
  %and15 = and i32 %conv13, %not
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %9, ptr noundef @.str.1, i32 noundef 8445, ptr noundef @__func__.nvme_set_smart_warning, ptr noundef @.str.55, i32 noundef %and15)
  br label %for.end

if.end16:                                         ; preds = %if.end6
  %12 = load ptr, ptr %n, align 8
  %smart_critical_warning = getelementptr inbounds %struct.NvmeCtrl, ptr %12, i32 0, i32 19
  %13 = load i8, ptr %smart_critical_warning, align 2
  store i8 %13, ptr %old_value, align 1
  %14 = load i8, ptr %value, align 1
  %15 = load ptr, ptr %n, align 8
  %smart_critical_warning17 = getelementptr inbounds %struct.NvmeCtrl, ptr %15, i32 0, i32 19
  store i8 %14, ptr %smart_critical_warning17, align 2
  store i8 0, ptr %index, align 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end16
  %16 = load i8, ptr %index, align 1
  %conv18 = zext i8 %16 to i32
  %cmp19 = icmp slt i32 %conv18, 6
  br i1 %cmp19, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load i8, ptr %index, align 1
  %conv21 = zext i8 %17 to i32
  %shl = shl i32 1, %conv21
  %conv22 = trunc i32 %shl to i8
  store i8 %conv22, ptr %event, align 1
  %18 = load i8, ptr %value, align 1
  %conv23 = zext i8 %18 to i32
  %19 = load i8, ptr %old_value, align 1
  %conv24 = zext i8 %19 to i32
  %not25 = xor i32 %conv24, -1
  %and26 = and i32 %conv23, %not25
  %20 = load i8, ptr %event, align 1
  %conv27 = zext i8 %20 to i32
  %and28 = and i32 %and26, %conv27
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.body
  %21 = load ptr, ptr %n, align 8
  %22 = load i8, ptr %event, align 1
  call void @nvme_smart_event(ptr noundef %21, i8 noundef zeroext %22)
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end31
  %23 = load i8, ptr %index, align 1
  %inc = add i8 %23, 1
  store i8 %inc, ptr %index, align 1
  br label %for.cond, !llvm.loop !11

for.end:                                          ; preds = %for.cond, %if.then12, %if.then
  ret void
}

declare zeroext i1 @visit_type_uint8(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @ldq_le_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %call = call i64 @ldq_he_p(ptr noundef %0)
  ret i64 %call
}

declare void @error_setg_internal(ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef, ...) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_smart_event(ptr noundef %n, i8 noundef zeroext %event) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %event.addr = alloca i8, align 1
  %aer_info = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store i8 %event, ptr %event.addr, align 1
  %0 = load ptr, ptr %n.addr, align 8
  %features = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 41
  %async_config = getelementptr inbounds %struct.anon.28, ptr %features, i32 0, i32 1
  %1 = load i32, ptr %async_config, align 4
  %and = and i32 %1, 255
  %2 = load i8, ptr %event.addr, align 1
  %conv = zext i8 %2 to i32
  %and1 = and i32 %and, %conv
  %tobool = icmp ne i32 %and1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i8, ptr %event.addr, align 1
  %conv2 = zext i8 %3 to i32
  switch i32 %conv2, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb3
    i32 4, label %sw.bb4
    i32 8, label %sw.bb4
    i32 16, label %sw.bb4
    i32 32, label %sw.bb4
  ]

sw.bb:                                            ; preds = %if.end
  store i8 2, ptr %aer_info, align 1
  br label %sw.epilog

sw.bb3:                                           ; preds = %if.end
  store i8 1, ptr %aer_info, align 1
  br label %sw.epilog

sw.bb4:                                           ; preds = %if.end, %if.end, %if.end, %if.end
  store i8 0, ptr %aer_info, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %return

sw.epilog:                                        ; preds = %sw.bb4, %sw.bb3, %sw.bb
  %4 = load ptr, ptr %n.addr, align 8
  %5 = load i8, ptr %aer_info, align 1
  call void @nvme_enqueue_event(ptr noundef %4, i8 noundef zeroext 1, i8 noundef zeroext %5, i8 noundef zeroext 2)
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @ldq_he_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %r = alloca i64, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %r, ptr align 1 %0, i64 8, i1 false)
  %1 = load i64, ptr %r, align 8
  ret i64 %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_enqueue_event(ptr noundef %n, i8 noundef zeroext %event_type, i8 noundef zeroext %event_info, i8 noundef zeroext %log_page) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %event_type.addr = alloca i8, align 1
  %event_info.addr = alloca i8, align 1
  %log_page.addr = alloca i8, align 1
  %event = alloca ptr, align 8
  %.compoundliteral = alloca %struct.NvmeAerResult, align 1
  store ptr %n, ptr %n.addr, align 8
  store i8 %event_type, ptr %event_type.addr, align 1
  store i8 %event_info, ptr %event_info.addr, align 1
  store i8 %log_page, ptr %log_page.addr, align 1
  %0 = load i8, ptr %event_type.addr, align 1
  %1 = load i8, ptr %event_info.addr, align 1
  %2 = load i8, ptr %log_page.addr, align 1
  call void @trace_pci_nvme_enqueue_event(i8 noundef zeroext %0, i8 noundef zeroext %1, i8 noundef zeroext %2)
  %3 = load ptr, ptr %n.addr, align 8
  %aer_queued = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 30
  %4 = load i32, ptr %aer_queued, align 8
  %5 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %5, i32 0, i32 4
  %aer_max_queued = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 6
  %6 = load i32, ptr %aer_max_queued, align 4
  %cmp = icmp eq i32 %4, %6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %n.addr, align 8
  %aer_queued1 = getelementptr inbounds %struct.NvmeCtrl, ptr %7, i32 0, i32 30
  %8 = load i32, ptr %aer_queued1, align 8
  call void @trace_pci_nvme_enqueue_event_noqueue(i32 noundef %8)
  br label %return

if.end:                                           ; preds = %entry
  %call = call noalias ptr @g_malloc_n(i64 noundef 1, i64 noundef 24) #11
  store ptr %call, ptr %event, align 8
  %9 = load ptr, ptr %event, align 8
  %result = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %9, i32 0, i32 1
  %event_type2 = getelementptr inbounds %struct.NvmeAerResult, ptr %.compoundliteral, i32 0, i32 0
  %10 = load i8, ptr %event_type.addr, align 1
  store i8 %10, ptr %event_type2, align 1
  %event_info3 = getelementptr inbounds %struct.NvmeAerResult, ptr %.compoundliteral, i32 0, i32 1
  %11 = load i8, ptr %event_info.addr, align 1
  store i8 %11, ptr %event_info3, align 1
  %log_page4 = getelementptr inbounds %struct.NvmeAerResult, ptr %.compoundliteral, i32 0, i32 2
  %12 = load i8, ptr %log_page.addr, align 1
  store i8 %12, ptr %log_page4, align 1
  %resv = getelementptr inbounds %struct.NvmeAerResult, ptr %.compoundliteral, i32 0, i32 3
  store i8 0, ptr %resv, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %result, ptr align 1 %.compoundliteral, i64 4, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.end
  %13 = load ptr, ptr %event, align 8
  %entry5 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %13, i32 0, i32 0
  store ptr null, ptr %entry5, align 8
  %14 = load ptr, ptr %n.addr, align 8
  %aer_queue = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 29
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %aer_queue, i32 0, i32 1
  %15 = load ptr, ptr %tql_prev, align 8
  %16 = load ptr, ptr %event, align 8
  %entry6 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %16, i32 0, i32 0
  %tql_prev7 = getelementptr inbounds %struct.QTailQLink, ptr %entry6, i32 0, i32 1
  store ptr %15, ptr %tql_prev7, align 8
  %17 = load ptr, ptr %event, align 8
  %18 = load ptr, ptr %n.addr, align 8
  %aer_queue8 = getelementptr inbounds %struct.NvmeCtrl, ptr %18, i32 0, i32 29
  %tql_prev9 = getelementptr inbounds %struct.QTailQLink, ptr %aer_queue8, i32 0, i32 1
  %19 = load ptr, ptr %tql_prev9, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %19, i32 0, i32 0
  store ptr %17, ptr %tql_next, align 8
  %20 = load ptr, ptr %event, align 8
  %entry10 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %n.addr, align 8
  %aer_queue11 = getelementptr inbounds %struct.NvmeCtrl, ptr %21, i32 0, i32 29
  %tql_prev12 = getelementptr inbounds %struct.QTailQLink, ptr %aer_queue11, i32 0, i32 1
  store ptr %entry10, ptr %tql_prev12, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %22 = load ptr, ptr %n.addr, align 8
  %aer_queued13 = getelementptr inbounds %struct.NvmeCtrl, ptr %22, i32 0, i32 30
  %23 = load i32, ptr %aer_queued13, align 8
  %inc = add i32 %23, 1
  store i32 %inc, ptr %aer_queued13, align 8
  %24 = load ptr, ptr %n.addr, align 8
  call void @nvme_process_aers(ptr noundef %24)
  br label %return

return:                                           ; preds = %do.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_enqueue_event(i8 noundef zeroext %typ, i8 noundef zeroext %info, i8 noundef zeroext %log_page) #0 {
entry:
  %typ.addr = alloca i8, align 1
  %info.addr = alloca i8, align 1
  %log_page.addr = alloca i8, align 1
  store i8 %typ, ptr %typ.addr, align 1
  store i8 %info, ptr %info.addr, align 1
  store i8 %log_page, ptr %log_page.addr, align 1
  %0 = load i8, ptr %typ.addr, align 1
  %1 = load i8, ptr %info.addr, align 1
  %2 = load i8, ptr %log_page.addr, align 1
  call void @_nocheck__trace_pci_nvme_enqueue_event(i8 noundef zeroext %0, i8 noundef zeroext %1, i8 noundef zeroext %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_enqueue_event_noqueue(i32 noundef %queued) #0 {
entry:
  %queued.addr = alloca i32, align 4
  store i32 %queued, ptr %queued.addr, align 4
  %0 = load i32, ptr %queued.addr, align 4
  call void @_nocheck__trace_pci_nvme_enqueue_event_noqueue(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_process_aers(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %n = alloca ptr, align 8
  %event = alloca ptr, align 8
  %next = alloca ptr, align 8
  %req = alloca ptr, align 8
  %result = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %n, align 8
  %1 = load ptr, ptr %n, align 8
  %aer_queued = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 30
  %2 = load i32, ptr %aer_queued, align 8
  call void @trace_pci_nvme_process_aers(i32 noundef %2)
  %3 = load ptr, ptr %n, align 8
  %aer_queue = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 29
  %4 = load ptr, ptr %aer_queue, align 8
  store ptr %4, ptr %event, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load ptr, ptr %event, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %6 = load ptr, ptr %event, align 8
  %entry1 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %entry1, align 8
  store ptr %7, ptr %next, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %8 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %8, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %9 = load ptr, ptr %n, align 8
  %outstanding_aers = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 12
  %10 = load i8, ptr %outstanding_aers, align 8
  %tobool2 = icmp ne i8 %10, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  call void @trace_pci_nvme_no_outstanding_aers()
  br label %for.end

if.end:                                           ; preds = %for.body
  %11 = load ptr, ptr %n, align 8
  %aer_mask = getelementptr inbounds %struct.NvmeCtrl, ptr %11, i32 0, i32 27
  %12 = load i8, ptr %aer_mask, align 8
  %conv = zext i8 %12 to i32
  %13 = load ptr, ptr %event, align 8
  %result3 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %13, i32 0, i32 1
  %event_type = getelementptr inbounds %struct.NvmeAerResult, ptr %result3, i32 0, i32 0
  %14 = load i8, ptr %event_type, align 8
  %conv4 = zext i8 %14 to i32
  %shl = shl i32 1, %conv4
  %and = and i32 %conv, %shl
  %tobool5 = icmp ne i32 %and, 0
  br i1 %tobool5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %if.end
  %15 = load ptr, ptr %event, align 8
  %result7 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %15, i32 0, i32 1
  %event_type8 = getelementptr inbounds %struct.NvmeAerResult, ptr %result7, i32 0, i32 0
  %16 = load i8, ptr %event_type8, align 8
  %17 = load ptr, ptr %n, align 8
  %aer_mask9 = getelementptr inbounds %struct.NvmeCtrl, ptr %17, i32 0, i32 27
  %18 = load i8, ptr %aer_mask9, align 8
  call void @trace_pci_nvme_aer_masked(i8 noundef zeroext %16, i8 noundef zeroext %18)
  br label %for.inc

if.end10:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.end10
  %19 = load ptr, ptr %event, align 8
  %entry11 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %19, i32 0, i32 0
  %20 = load ptr, ptr %entry11, align 8
  %cmp = icmp ne ptr %20, null
  br i1 %cmp, label %if.then13, label %if.else

if.then13:                                        ; preds = %do.body
  %21 = load ptr, ptr %event, align 8
  %entry14 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %21, i32 0, i32 0
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %entry14, i32 0, i32 1
  %22 = load ptr, ptr %tql_prev, align 8
  %23 = load ptr, ptr %event, align 8
  %entry15 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %23, i32 0, i32 0
  %24 = load ptr, ptr %entry15, align 8
  %entry16 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %24, i32 0, i32 0
  %tql_prev17 = getelementptr inbounds %struct.QTailQLink, ptr %entry16, i32 0, i32 1
  store ptr %22, ptr %tql_prev17, align 8
  br label %if.end22

if.else:                                          ; preds = %do.body
  %25 = load ptr, ptr %event, align 8
  %entry18 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %25, i32 0, i32 0
  %tql_prev19 = getelementptr inbounds %struct.QTailQLink, ptr %entry18, i32 0, i32 1
  %26 = load ptr, ptr %tql_prev19, align 8
  %27 = load ptr, ptr %n, align 8
  %aer_queue20 = getelementptr inbounds %struct.NvmeCtrl, ptr %27, i32 0, i32 29
  %tql_prev21 = getelementptr inbounds %struct.QTailQLink, ptr %aer_queue20, i32 0, i32 1
  store ptr %26, ptr %tql_prev21, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then13
  %28 = load ptr, ptr %event, align 8
  %entry23 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %28, i32 0, i32 0
  %29 = load ptr, ptr %entry23, align 8
  %30 = load ptr, ptr %event, align 8
  %entry24 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %30, i32 0, i32 0
  %tql_prev25 = getelementptr inbounds %struct.QTailQLink, ptr %entry24, i32 0, i32 1
  %31 = load ptr, ptr %tql_prev25, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %31, i32 0, i32 0
  store ptr %29, ptr %tql_next, align 8
  %32 = load ptr, ptr %event, align 8
  %entry26 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %32, i32 0, i32 0
  %tql_prev27 = getelementptr inbounds %struct.QTailQLink, ptr %entry26, i32 0, i32 1
  store ptr null, ptr %tql_prev27, align 8
  %33 = load ptr, ptr %event, align 8
  %entry28 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %33, i32 0, i32 0
  %tql_next29 = getelementptr inbounds %struct.QTailQLink, ptr %entry28, i32 0, i32 0
  store ptr null, ptr %tql_next29, align 8
  %34 = load ptr, ptr %event, align 8
  %entry30 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %34, i32 0, i32 0
  store ptr null, ptr %entry30, align 8
  br label %do.end

do.end:                                           ; preds = %if.end22
  %35 = load ptr, ptr %n, align 8
  %aer_queued31 = getelementptr inbounds %struct.NvmeCtrl, ptr %35, i32 0, i32 30
  %36 = load i32, ptr %aer_queued31, align 8
  %dec = add i32 %36, -1
  store i32 %dec, ptr %aer_queued31, align 8
  %37 = load ptr, ptr %event, align 8
  %result32 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %37, i32 0, i32 1
  %event_type33 = getelementptr inbounds %struct.NvmeAerResult, ptr %result32, i32 0, i32 0
  %38 = load i8, ptr %event_type33, align 8
  %conv34 = zext i8 %38 to i32
  %shl35 = shl i32 1, %conv34
  %39 = load ptr, ptr %n, align 8
  %aer_mask36 = getelementptr inbounds %struct.NvmeCtrl, ptr %39, i32 0, i32 27
  %40 = load i8, ptr %aer_mask36, align 8
  %conv37 = zext i8 %40 to i32
  %or = or i32 %conv37, %shl35
  %conv38 = trunc i32 %or to i8
  store i8 %conv38, ptr %aer_mask36, align 8
  %41 = load ptr, ptr %n, align 8
  %outstanding_aers39 = getelementptr inbounds %struct.NvmeCtrl, ptr %41, i32 0, i32 12
  %42 = load i8, ptr %outstanding_aers39, align 8
  %dec40 = add i8 %42, -1
  store i8 %dec40, ptr %outstanding_aers39, align 8
  %43 = load ptr, ptr %n, align 8
  %aer_reqs = getelementptr inbounds %struct.NvmeCtrl, ptr %43, i32 0, i32 28
  %44 = load ptr, ptr %aer_reqs, align 16
  %45 = load ptr, ptr %n, align 8
  %outstanding_aers41 = getelementptr inbounds %struct.NvmeCtrl, ptr %45, i32 0, i32 12
  %46 = load i8, ptr %outstanding_aers41, align 8
  %idxprom = zext i8 %46 to i64
  %arrayidx = getelementptr ptr, ptr %44, i64 %idxprom
  %47 = load ptr, ptr %arrayidx, align 8
  store ptr %47, ptr %req, align 8
  %48 = load ptr, ptr %req, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %48, i32 0, i32 5
  %result42 = getelementptr inbounds %struct.NvmeCqe, ptr %cqe, i32 0, i32 0
  store ptr %result42, ptr %result, align 8
  %49 = load ptr, ptr %event, align 8
  %result43 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %49, i32 0, i32 1
  %event_type44 = getelementptr inbounds %struct.NvmeAerResult, ptr %result43, i32 0, i32 0
  %50 = load i8, ptr %event_type44, align 8
  %51 = load ptr, ptr %result, align 8
  %event_type45 = getelementptr inbounds %struct.NvmeAerResult, ptr %51, i32 0, i32 0
  store i8 %50, ptr %event_type45, align 1
  %52 = load ptr, ptr %event, align 8
  %result46 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %52, i32 0, i32 1
  %event_info = getelementptr inbounds %struct.NvmeAerResult, ptr %result46, i32 0, i32 1
  %53 = load i8, ptr %event_info, align 1
  %54 = load ptr, ptr %result, align 8
  %event_info47 = getelementptr inbounds %struct.NvmeAerResult, ptr %54, i32 0, i32 1
  store i8 %53, ptr %event_info47, align 1
  %55 = load ptr, ptr %event, align 8
  %result48 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %55, i32 0, i32 1
  %log_page = getelementptr inbounds %struct.NvmeAerResult, ptr %result48, i32 0, i32 2
  %56 = load i8, ptr %log_page, align 2
  %57 = load ptr, ptr %result, align 8
  %log_page49 = getelementptr inbounds %struct.NvmeAerResult, ptr %57, i32 0, i32 2
  store i8 %56, ptr %log_page49, align 1
  %58 = load ptr, ptr %event, align 8
  call void @g_free(ptr noundef %58)
  %59 = load ptr, ptr %result, align 8
  %event_type50 = getelementptr inbounds %struct.NvmeAerResult, ptr %59, i32 0, i32 0
  %60 = load i8, ptr %event_type50, align 1
  %61 = load ptr, ptr %result, align 8
  %event_info51 = getelementptr inbounds %struct.NvmeAerResult, ptr %61, i32 0, i32 1
  %62 = load i8, ptr %event_info51, align 1
  %63 = load ptr, ptr %result, align 8
  %log_page52 = getelementptr inbounds %struct.NvmeAerResult, ptr %63, i32 0, i32 2
  %64 = load i8, ptr %log_page52, align 1
  call void @trace_pci_nvme_aer_post_cqe(i8 noundef zeroext %60, i8 noundef zeroext %62, i8 noundef zeroext %64)
  %65 = load ptr, ptr %n, align 8
  %admin_cq = getelementptr inbounds %struct.NvmeCtrl, ptr %65, i32 0, i32 39
  %66 = load ptr, ptr %req, align 8
  call void @nvme_enqueue_req_completion(ptr noundef %admin_cq, ptr noundef %66)
  br label %for.inc

for.inc:                                          ; preds = %do.end, %if.then6
  %67 = load ptr, ptr %next, align 8
  store ptr %67, ptr %event, align 8
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %if.then, %land.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_enqueue_event(i8 noundef zeroext %typ, i8 noundef zeroext %info, i8 noundef zeroext %log_page) #0 {
entry:
  %typ.addr = alloca i8, align 1
  %info.addr = alloca i8, align 1
  %log_page.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %typ, ptr %typ.addr, align 1
  store i8 %info, ptr %info.addr, align 1
  store i8 %log_page, ptr %log_page.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ENQUEUE_EVENT_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end17

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end17

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %typ.addr, align 1
  %conv11 = zext i8 %5 to i32
  %6 = load i8, ptr %info.addr, align 1
  %conv12 = zext i8 %6 to i32
  %7 = load i8, ptr %log_page.addr, align 1
  %conv13 = zext i8 %7 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.56, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12, i32 noundef %conv13)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i8, ptr %typ.addr, align 1
  %conv14 = zext i8 %8 to i32
  %9 = load i8, ptr %info.addr, align 1
  %conv15 = zext i8 %9 to i32
  %10 = load i8, ptr %log_page.addr, align 1
  %conv16 = zext i8 %10 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.57, i32 noundef %conv14, i32 noundef %conv15, i32 noundef %conv16)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end17

if.end17:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_enqueue_event_noqueue(i32 noundef %queued) #0 {
entry:
  %queued.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %queued, ptr %queued.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %queued.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.58, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %queued.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.59, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_process_aers(i32 noundef %queued) #0 {
entry:
  %queued.addr = alloca i32, align 4
  store i32 %queued, ptr %queued.addr, align 4
  %0 = load i32, ptr %queued.addr, align 4
  call void @_nocheck__trace_pci_nvme_process_aers(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_no_outstanding_aers() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_no_outstanding_aers()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_aer_masked(i8 noundef zeroext %type, i8 noundef zeroext %mask) #0 {
entry:
  %type.addr = alloca i8, align 1
  %mask.addr = alloca i8, align 1
  store i8 %type, ptr %type.addr, align 1
  store i8 %mask, ptr %mask.addr, align 1
  %0 = load i8, ptr %type.addr, align 1
  %1 = load i8, ptr %mask.addr, align 1
  call void @_nocheck__trace_pci_nvme_aer_masked(i8 noundef zeroext %0, i8 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_aer_post_cqe(i8 noundef zeroext %typ, i8 noundef zeroext %info, i8 noundef zeroext %log_page) #0 {
entry:
  %typ.addr = alloca i8, align 1
  %info.addr = alloca i8, align 1
  %log_page.addr = alloca i8, align 1
  store i8 %typ, ptr %typ.addr, align 1
  store i8 %info, ptr %info.addr, align 1
  store i8 %log_page, ptr %log_page.addr, align 1
  %0 = load i8, ptr %typ.addr, align 1
  %1 = load i8, ptr %info.addr, align 1
  %2 = load i8, ptr %log_page.addr, align 1
  call void @_nocheck__trace_pci_nvme_aer_post_cqe(i8 noundef zeroext %0, i8 noundef zeroext %1, i8 noundef zeroext %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_process_aers(i32 noundef %queued) #0 {
entry:
  %queued.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %queued, ptr %queued.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_PROCESS_AERS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %queued.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.60, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %queued.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.61, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_no_outstanding_aers() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_NO_OUTSTANDING_AERS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.62, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.63)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_aer_masked(i8 noundef zeroext %type, i8 noundef zeroext %mask) #0 {
entry:
  %type.addr = alloca i8, align 1
  %mask.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %type, ptr %type.addr, align 1
  store i8 %mask, ptr %mask.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_AER_MASKED_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %type.addr, align 1
  %conv11 = zext i8 %5 to i32
  %6 = load i8, ptr %mask.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.64, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i8, ptr %type.addr, align 1
  %conv13 = zext i8 %7 to i32
  %8 = load i8, ptr %mask.addr, align 1
  %conv14 = zext i8 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.65, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_aer_post_cqe(i8 noundef zeroext %typ, i8 noundef zeroext %info, i8 noundef zeroext %log_page) #0 {
entry:
  %typ.addr = alloca i8, align 1
  %info.addr = alloca i8, align 1
  %log_page.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %typ, ptr %typ.addr, align 1
  store i8 %info, ptr %info.addr, align 1
  store i8 %log_page, ptr %log_page.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_AER_POST_CQE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end17

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end17

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %typ.addr, align 1
  %conv11 = zext i8 %5 to i32
  %6 = load i8, ptr %info.addr, align 1
  %conv12 = zext i8 %6 to i32
  %7 = load i8, ptr %log_page.addr, align 1
  %conv13 = zext i8 %7 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.66, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12, i32 noundef %conv13)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i8, ptr %typ.addr, align 1
  %conv14 = zext i8 %8 to i32
  %9 = load i8, ptr %info.addr, align 1
  %conv15 = zext i8 %9 to i32
  %10 = load i8, ptr %log_page.addr, align 1
  %conv16 = zext i8 %10 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.67, i32 noundef %conv14, i32 noundef %conv15, i32 noundef %conv16)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end17

if.end17:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @DEVICE_CLASS(ptr noundef %klass) #0 {
entry:
  %klass.addr = alloca ptr, align 8
  store ptr %klass, ptr %klass.addr, align 8
  %0 = load ptr, ptr %klass.addr, align 8
  %call = call ptr @object_class_dynamic_cast_assert(ptr noundef %0, ptr noundef @.str.4, ptr noundef @.str.5, i32 noundef 77, ptr noundef @__func__.DEVICE_CLASS)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @PCI_DEVICE_CLASS(ptr noundef %klass) #0 {
entry:
  %klass.addr = alloca ptr, align 8
  store ptr %klass, ptr %klass.addr, align 8
  %0 = load ptr, ptr %klass.addr, align 8
  %call = call ptr @object_class_dynamic_cast_assert(ptr noundef %0, ptr noundef @.str.6, ptr noundef @.str.7, i32 noundef 10, ptr noundef @__func__.PCI_DEVICE_CLASS)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_realize(ptr noundef %pci_dev, ptr noundef %errp) #0 {
entry:
  %pci_dev.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %n = alloca ptr, align 8
  %dev = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %pn = alloca ptr, align 8
  store ptr %pci_dev, ptr %pci_dev.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %pci_dev.addr, align 8
  %call = call ptr @object_dynamic_cast_assert(ptr noundef %0, ptr noundef @.str.49, ptr noundef @.str.1, i32 noundef 8304, ptr noundef @__func__.nvme_realize)
  store ptr %call, ptr %n, align 8
  %1 = load ptr, ptr %pci_dev.addr, align 8
  %call1 = call ptr @DEVICE(ptr noundef %1)
  store ptr %call1, ptr %dev, align 8
  %2 = load ptr, ptr %pci_dev.addr, align 8
  %call2 = call ptr @pcie_sriov_get_pf(ptr noundef %2)
  %call3 = call ptr @object_dynamic_cast_assert(ptr noundef %call2, ptr noundef @.str.49, ptr noundef @.str.1, i32 noundef 8307, ptr noundef @__func__.nvme_realize)
  store ptr %call3, ptr %pn, align 8
  %3 = load ptr, ptr %pci_dev.addr, align 8
  %call4 = call i32 @pci_is_vf(ptr noundef %3)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %n, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %pn, align 8
  %params5 = getelementptr inbounds %struct.NvmeCtrl, ptr %5, i32 0, i32 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %params, ptr align 16 %params5, i64 48, i1 false)
  %6 = load ptr, ptr %pn, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %6, i32 0, i32 33
  %7 = load ptr, ptr %subsys, align 8
  %8 = load ptr, ptr %n, align 8
  %subsys6 = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 33
  store ptr %7, ptr %subsys6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load ptr, ptr %n, align 8
  %10 = load ptr, ptr %errp.addr, align 8
  %call7 = call zeroext i1 @nvme_check_params(ptr noundef %9, ptr noundef %10)
  br i1 %call7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %if.end25

if.end9:                                          ; preds = %if.end
  %11 = load ptr, ptr %n, align 8
  %bus = getelementptr inbounds %struct.NvmeCtrl, ptr %11, i32 0, i32 5
  %12 = load ptr, ptr %dev, align 8
  %13 = load ptr, ptr %dev, align 8
  %id = getelementptr inbounds %struct.DeviceState, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %id, align 8
  call void @qbus_init(ptr noundef %bus, i64 noundef 120, ptr noundef @.str.69, ptr noundef %12, ptr noundef %14)
  %15 = load ptr, ptr %n, align 8
  %16 = load ptr, ptr %errp.addr, align 8
  %call10 = call i32 @nvme_init_subsys(ptr noundef %15, ptr noundef %16)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  br label %if.end25

if.end13:                                         ; preds = %if.end9
  %17 = load ptr, ptr %n, align 8
  call void @nvme_init_state(ptr noundef %17)
  %18 = load ptr, ptr %n, align 8
  %19 = load ptr, ptr %pci_dev.addr, align 8
  %20 = load ptr, ptr %errp.addr, align 8
  %call14 = call zeroext i1 @nvme_init_pci(ptr noundef %18, ptr noundef %19, ptr noundef %20)
  br i1 %call14, label %if.end16, label %if.then15

if.then15:                                        ; preds = %if.end13
  br label %if.end25

if.end16:                                         ; preds = %if.end13
  %21 = load ptr, ptr %n, align 8
  %22 = load ptr, ptr %pci_dev.addr, align 8
  call void @nvme_init_ctrl(ptr noundef %21, ptr noundef %22)
  %23 = load ptr, ptr %n, align 8
  %namespace = getelementptr inbounds %struct.NvmeCtrl, ptr %23, i32 0, i32 34
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %namespace, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %24 = load ptr, ptr %blk, align 16
  %tobool17 = icmp ne ptr %24, null
  br i1 %tobool17, label %if.then18, label %if.end25

if.then18:                                        ; preds = %if.end16
  %25 = load ptr, ptr %n, align 8
  %namespace19 = getelementptr inbounds %struct.NvmeCtrl, ptr %25, i32 0, i32 34
  store ptr %namespace19, ptr %ns, align 8
  %26 = load ptr, ptr %ns, align 8
  %params20 = getelementptr inbounds %struct.NvmeNamespace, ptr %26, i32 0, i32 30
  %nsid = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params20, i32 0, i32 2
  store i32 1, ptr %nsid, align 4
  %27 = load ptr, ptr %ns, align 8
  %28 = load ptr, ptr %errp.addr, align 8
  %call21 = call i32 @nvme_ns_setup(ptr noundef %27, ptr noundef %28)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.then18
  br label %if.end25

if.end24:                                         ; preds = %if.then18
  %29 = load ptr, ptr %n, align 8
  %30 = load ptr, ptr %ns, align 8
  call void @nvme_attach_ns(ptr noundef %29, ptr noundef %30)
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.then23, %if.end16, %if.then15, %if.then12, %if.then8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_pci_write_config(ptr noundef %dev, i32 noundef %address, i32 noundef %val, i32 noundef %len) #0 {
entry:
  %dev.addr = alloca ptr, align 8
  %address.addr = alloca i32, align 4
  %val.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  store ptr %dev, ptr %dev.addr, align 8
  store i32 %address, ptr %address.addr, align 4
  store i32 %val, ptr %val.addr, align 4
  store i32 %len, ptr %len.addr, align 4
  %0 = load ptr, ptr %dev.addr, align 8
  %1 = load i32, ptr %address.addr, align 4
  %2 = load i32, ptr %val.addr, align 4
  %3 = load i32, ptr %len.addr, align 4
  call void @nvme_sriov_pre_write_ctrl(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3)
  %4 = load ptr, ptr %dev.addr, align 8
  %5 = load i32, ptr %address.addr, align 4
  %6 = load i32, ptr %val.addr, align 4
  %7 = load i32, ptr %len.addr, align 4
  call void @pci_default_write_config(ptr noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %7)
  %8 = load ptr, ptr %dev.addr, align 8
  %9 = load i32, ptr %address.addr, align 4
  %10 = load i32, ptr %val.addr, align 4
  %11 = load i32, ptr %len.addr, align 4
  call void @pcie_cap_flr_write_config(ptr noundef %8, i32 noundef %9, i32 noundef %10, i32 noundef %11)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_exit(ptr noundef %pci_dev) #0 {
entry:
  %pci_dev.addr = alloca ptr, align 8
  %n = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %pci_dev, ptr %pci_dev.addr, align 8
  %0 = load ptr, ptr %pci_dev.addr, align 8
  %call = call ptr @object_dynamic_cast_assert(ptr noundef %0, ptr noundef @.str.49, ptr noundef @.str.1, i32 noundef 8348, ptr noundef @__func__.nvme_exit)
  store ptr %call, ptr %n, align 8
  %1 = load ptr, ptr %n, align 8
  call void @nvme_ctrl_reset(ptr noundef %1, i32 noundef 0)
  %2 = load ptr, ptr %n, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 33
  %3 = load ptr, ptr %subsys, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %4 = load i32, ptr %i, align 4
  %cmp = icmp sle i32 %4, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %n, align 8
  %6 = load i32, ptr %i, align 4
  %call1 = call ptr @nvme_ns(ptr noundef %5, i32 noundef %6)
  store ptr %call1, ptr %ns, align 8
  %7 = load ptr, ptr %ns, align 8
  %tobool2 = icmp ne ptr %7, null
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %for.body
  %8 = load ptr, ptr %ns, align 8
  %attached = getelementptr inbounds %struct.NvmeNamespace, ptr %8, i32 0, i32 13
  %9 = load i32, ptr %attached, align 4
  %dec = add i32 %9, -1
  store i32 %dec, ptr %attached, align 4
  br label %if.end

if.end:                                           ; preds = %if.then3, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i32, ptr %i, align 4
  %inc = add i32 %10, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !13

for.end:                                          ; preds = %for.cond
  %11 = load ptr, ptr %n, align 8
  %subsys4 = getelementptr inbounds %struct.NvmeCtrl, ptr %11, i32 0, i32 33
  %12 = load ptr, ptr %subsys4, align 8
  %13 = load ptr, ptr %n, align 8
  call void @nvme_subsys_unregister_ctrl(ptr noundef %12, ptr noundef %13)
  br label %if.end5

if.end5:                                          ; preds = %for.end, %entry
  %14 = load ptr, ptr %n, align 8
  %cq = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 37
  %15 = load ptr, ptr %cq, align 8
  call void @g_free(ptr noundef %15)
  %16 = load ptr, ptr %n, align 8
  %sq = getelementptr inbounds %struct.NvmeCtrl, ptr %16, i32 0, i32 36
  %17 = load ptr, ptr %sq, align 16
  call void @g_free(ptr noundef %17)
  %18 = load ptr, ptr %n, align 8
  %aer_reqs = getelementptr inbounds %struct.NvmeCtrl, ptr %18, i32 0, i32 28
  %19 = load ptr, ptr %aer_reqs, align 16
  call void @g_free(ptr noundef %19)
  %20 = load ptr, ptr %n, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %20, i32 0, i32 4
  %cmb_size_mb = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 4
  %21 = load i32, ptr %cmb_size_mb, align 4
  %tobool6 = icmp ne i32 %21, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end5
  %22 = load ptr, ptr %n, align 8
  %cmb = getelementptr inbounds %struct.NvmeCtrl, ptr %22, i32 0, i32 25
  %buf = getelementptr inbounds %struct.anon.20, ptr %cmb, i32 0, i32 1
  %23 = load ptr, ptr %buf, align 16
  call void @g_free(ptr noundef %23)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end5
  %24 = load ptr, ptr %n, align 8
  %pmr = getelementptr inbounds %struct.NvmeCtrl, ptr %24, i32 0, i32 26
  %dev = getelementptr inbounds %struct.anon.21, ptr %pmr, i32 0, i32 0
  %25 = load ptr, ptr %dev, align 16
  %tobool9 = icmp ne ptr %25, null
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.end8
  %26 = load ptr, ptr %n, align 8
  %pmr11 = getelementptr inbounds %struct.NvmeCtrl, ptr %26, i32 0, i32 26
  %dev12 = getelementptr inbounds %struct.anon.21, ptr %pmr11, i32 0, i32 0
  %27 = load ptr, ptr %dev12, align 16
  call void @host_memory_backend_set_mapped(ptr noundef %27, i1 noundef zeroext false)
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %if.end8
  %28 = load ptr, ptr %pci_dev.addr, align 8
  %call14 = call i32 @pci_is_vf(ptr noundef %28)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end19, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end13
  %29 = load ptr, ptr %n, align 8
  %params16 = getelementptr inbounds %struct.NvmeCtrl, ptr %29, i32 0, i32 4
  %sriov_max_vfs = getelementptr inbounds %struct.NvmeParams, ptr %params16, i32 0, i32 14
  %30 = load i8, ptr %sriov_max_vfs, align 1
  %conv = zext i8 %30 to i32
  %tobool17 = icmp ne i32 %conv, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true
  %31 = load ptr, ptr %pci_dev.addr, align 8
  call void @pcie_sriov_pf_exit(ptr noundef %31)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %land.lhs.true, %if.end13
  %32 = load ptr, ptr %pci_dev.addr, align 8
  %33 = load ptr, ptr %n, align 8
  %bar0 = getelementptr inbounds %struct.NvmeCtrl, ptr %33, i32 0, i32 1
  %34 = load ptr, ptr %n, align 8
  %bar020 = getelementptr inbounds %struct.NvmeCtrl, ptr %34, i32 0, i32 1
  call void @msix_uninit(ptr noundef %32, ptr noundef %bar0, ptr noundef %bar020)
  %35 = load ptr, ptr %n, align 8
  %bar021 = getelementptr inbounds %struct.NvmeCtrl, ptr %35, i32 0, i32 1
  %36 = load ptr, ptr %n, align 8
  %iomem = getelementptr inbounds %struct.NvmeCtrl, ptr %36, i32 0, i32 2
  call void @memory_region_del_subregion(ptr noundef %bar021, ptr noundef %iomem)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @set_bit(i64 noundef %nr, ptr noundef %addr) #0 {
entry:
  %nr.addr = alloca i64, align 8
  %addr.addr = alloca ptr, align 8
  %mask = alloca i64, align 8
  %p = alloca ptr, align 8
  store i64 %nr, ptr %nr.addr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  %0 = load i64, ptr %nr.addr, align 8
  %rem = urem i64 %0, 64
  %shl = shl i64 1, %rem
  store i64 %shl, ptr %mask, align 8
  %1 = load ptr, ptr %addr.addr, align 8
  %2 = load i64, ptr %nr.addr, align 8
  %div = udiv i64 %2, 64
  %add.ptr = getelementptr i64, ptr %1, i64 %div
  store ptr %add.ptr, ptr %p, align 8
  %3 = load i64, ptr %mask, align 8
  %4 = load ptr, ptr %p, align 8
  %5 = load i64, ptr %4, align 8
  %or = or i64 %5, %3
  store i64 %or, ptr %4, align 8
  ret void
}

declare void @device_class_set_props(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_pci_reset(ptr noundef %qdev) #0 {
entry:
  %qdev.addr = alloca ptr, align 8
  %pci_dev = alloca ptr, align 8
  %n = alloca ptr, align 8
  store ptr %qdev, ptr %qdev.addr, align 8
  %0 = load ptr, ptr %qdev.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %0)
  store ptr %call, ptr %pci_dev, align 8
  %1 = load ptr, ptr %pci_dev, align 8
  %call1 = call ptr @object_dynamic_cast_assert(ptr noundef %1, ptr noundef @.str.49, ptr noundef @.str.1, i32 noundef 8463, ptr noundef @__func__.nvme_pci_reset)
  store ptr %call1, ptr %n, align 8
  call void @trace_pci_nvme_pci_reset()
  %2 = load ptr, ptr %n, align 8
  call void @nvme_ctrl_reset(ptr noundef %2, i32 noundef 0)
  ret void
}

declare ptr @object_class_dynamic_cast_assert(ptr noundef, ptr noundef, ptr noundef, i32 noundef, ptr noundef) #1

declare ptr @pcie_sriov_get_pf(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @pci_is_vf(ptr noundef %d) #0 {
entry:
  %d.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %exp = getelementptr inbounds %struct.PCIDevice, ptr %0, i32 0, i32 36
  %sriov_vf = getelementptr inbounds %struct.PCIExpressDevice, ptr %exp, i32 0, i32 9
  %pf = getelementptr inbounds %struct.PCIESriovVF, ptr %sriov_vf, i32 0, i32 0
  %1 = load ptr, ptr %pf, align 8
  %cmp = icmp ne ptr %1, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_check_params(ptr noundef %n, ptr noundef %errp) #0 {
entry:
  %retval = alloca i1, align 1
  %n.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %params = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %params1 = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 4
  store ptr %params1, ptr %params, align 8
  %1 = load ptr, ptr %params, align 8
  %num_queues = getelementptr inbounds %struct.NvmeParams, ptr %1, i32 0, i32 1
  %2 = load i32, ptr %num_queues, align 8
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (ptr, ...) @warn_report(ptr noundef @.str.70)
  %3 = load ptr, ptr %params, align 8
  %num_queues2 = getelementptr inbounds %struct.NvmeParams, ptr %3, i32 0, i32 1
  %4 = load i32, ptr %num_queues2, align 8
  %sub = sub i32 %4, 1
  %5 = load ptr, ptr %params, align 8
  %max_ioqpairs = getelementptr inbounds %struct.NvmeParams, ptr %5, i32 0, i32 2
  store i32 %sub, ptr %max_ioqpairs, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %n.addr, align 8
  %namespace = getelementptr inbounds %struct.NvmeCtrl, ptr %6, i32 0, i32 34
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %namespace, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %7 = load ptr, ptr %blk, align 16
  %tobool3 = icmp ne ptr %7, null
  br i1 %tobool3, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %8 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 33
  %9 = load ptr, ptr %subsys, align 8
  %tobool4 = icmp ne ptr %9, null
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true
  %10 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %10, ptr noundef @.str.1, i32 noundef 7777, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.71)
  store i1 false, ptr %retval, align 1
  br label %return

if.end6:                                          ; preds = %land.lhs.true, %if.end
  %11 = load ptr, ptr %params, align 8
  %max_ioqpairs7 = getelementptr inbounds %struct.NvmeParams, ptr %11, i32 0, i32 2
  %12 = load i32, ptr %max_ioqpairs7, align 4
  %cmp = icmp ult i32 %12, 1
  br i1 %cmp, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end6
  %13 = load ptr, ptr %params, align 8
  %max_ioqpairs8 = getelementptr inbounds %struct.NvmeParams, ptr %13, i32 0, i32 2
  %14 = load i32, ptr %max_ioqpairs8, align 4
  %cmp9 = icmp ugt i32 %14, 65535
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %lor.lhs.false, %if.end6
  %15 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %15, ptr noundef @.str.1, i32 noundef 7784, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.72, i32 noundef 65535)
  store i1 false, ptr %retval, align 1
  br label %return

if.end11:                                         ; preds = %lor.lhs.false
  %16 = load ptr, ptr %params, align 8
  %msix_qsize = getelementptr inbounds %struct.NvmeParams, ptr %16, i32 0, i32 3
  %17 = load i16, ptr %msix_qsize, align 8
  %conv = zext i16 %17 to i32
  %cmp12 = icmp slt i32 %conv, 1
  br i1 %cmp12, label %if.then19, label %lor.lhs.false14

lor.lhs.false14:                                  ; preds = %if.end11
  %18 = load ptr, ptr %params, align 8
  %msix_qsize15 = getelementptr inbounds %struct.NvmeParams, ptr %18, i32 0, i32 3
  %19 = load i16, ptr %msix_qsize15, align 8
  %conv16 = zext i16 %19 to i32
  %cmp17 = icmp sgt i32 %conv16, 2048
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %lor.lhs.false14, %if.end11
  %20 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %20, ptr noundef @.str.1, i32 noundef 7791, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.73, i32 noundef 2048)
  store i1 false, ptr %retval, align 1
  br label %return

if.end20:                                         ; preds = %lor.lhs.false14
  %21 = load ptr, ptr %params, align 8
  %serial = getelementptr inbounds %struct.NvmeParams, ptr %21, i32 0, i32 0
  %22 = load ptr, ptr %serial, align 8
  %tobool21 = icmp ne ptr %22, null
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.end20
  %23 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %23, ptr noundef @.str.1, i32 noundef 7796, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.74)
  store i1 false, ptr %retval, align 1
  br label %return

if.end23:                                         ; preds = %if.end20
  %24 = load ptr, ptr %n.addr, align 8
  %pmr = getelementptr inbounds %struct.NvmeCtrl, ptr %24, i32 0, i32 26
  %dev = getelementptr inbounds %struct.anon.21, ptr %pmr, i32 0, i32 0
  %25 = load ptr, ptr %dev, align 16
  %tobool24 = icmp ne ptr %25, null
  br i1 %tobool24, label %if.then25, label %if.end40

if.then25:                                        ; preds = %if.end23
  %26 = load ptr, ptr %n.addr, align 8
  %pmr26 = getelementptr inbounds %struct.NvmeCtrl, ptr %26, i32 0, i32 26
  %dev27 = getelementptr inbounds %struct.anon.21, ptr %pmr26, i32 0, i32 0
  %27 = load ptr, ptr %dev27, align 16
  %call = call zeroext i1 @host_memory_backend_is_mapped(ptr noundef %27)
  br i1 %call, label %if.then28, label %if.end32

if.then28:                                        ; preds = %if.then25
  %28 = load ptr, ptr %errp.addr, align 8
  %29 = load ptr, ptr %n.addr, align 8
  %pmr29 = getelementptr inbounds %struct.NvmeCtrl, ptr %29, i32 0, i32 26
  %dev30 = getelementptr inbounds %struct.anon.21, ptr %pmr29, i32 0, i32 0
  %30 = load ptr, ptr %dev30, align 16
  %call31 = call ptr @object_get_canonical_path_component(ptr noundef %30)
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %28, ptr noundef @.str.1, i32 noundef 7803, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.75, ptr noundef %call31)
  store i1 false, ptr %retval, align 1
  br label %return

if.end32:                                         ; preds = %if.then25
  %31 = load ptr, ptr %n.addr, align 8
  %pmr33 = getelementptr inbounds %struct.NvmeCtrl, ptr %31, i32 0, i32 26
  %dev34 = getelementptr inbounds %struct.anon.21, ptr %pmr33, i32 0, i32 0
  %32 = load ptr, ptr %dev34, align 16
  %size = getelementptr inbounds %struct.HostMemoryBackend, ptr %32, i32 0, i32 1
  %33 = load i64, ptr %size, align 8
  %call35 = call zeroext i1 @is_power_of_2(i64 noundef %33)
  br i1 %call35, label %if.end37, label %if.then36

if.then36:                                        ; preds = %if.end32
  %34 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %34, ptr noundef @.str.1, i32 noundef 7808, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.76)
  store i1 false, ptr %retval, align 1
  br label %return

if.end37:                                         ; preds = %if.end32
  %35 = load ptr, ptr %n.addr, align 8
  %pmr38 = getelementptr inbounds %struct.NvmeCtrl, ptr %35, i32 0, i32 26
  %dev39 = getelementptr inbounds %struct.anon.21, ptr %pmr38, i32 0, i32 0
  %36 = load ptr, ptr %dev39, align 16
  call void @host_memory_backend_set_mapped(ptr noundef %36, i1 noundef zeroext true)
  br label %if.end40

if.end40:                                         ; preds = %if.end37, %if.end23
  %37 = load ptr, ptr %n.addr, align 8
  %params41 = getelementptr inbounds %struct.NvmeCtrl, ptr %37, i32 0, i32 4
  %zasl = getelementptr inbounds %struct.NvmeParams, ptr %params41, i32 0, i32 10
  %38 = load i8, ptr %zasl, align 1
  %conv42 = zext i8 %38 to i32
  %39 = load ptr, ptr %n.addr, align 8
  %params43 = getelementptr inbounds %struct.NvmeCtrl, ptr %39, i32 0, i32 4
  %mdts = getelementptr inbounds %struct.NvmeParams, ptr %params43, i32 0, i32 7
  %40 = load i8, ptr %mdts, align 16
  %conv44 = zext i8 %40 to i32
  %cmp45 = icmp sgt i32 %conv42, %conv44
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end40
  %41 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %41, ptr noundef @.str.1, i32 noundef 7817, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.77)
  store i1 false, ptr %retval, align 1
  br label %return

if.end48:                                         ; preds = %if.end40
  %42 = load ptr, ptr %n.addr, align 8
  %params49 = getelementptr inbounds %struct.NvmeCtrl, ptr %42, i32 0, i32 4
  %vsl = getelementptr inbounds %struct.NvmeParams, ptr %params49, i32 0, i32 8
  %43 = load i8, ptr %vsl, align 1
  %tobool50 = icmp ne i8 %43, 0
  br i1 %tobool50, label %if.end52, label %if.then51

if.then51:                                        ; preds = %if.end48
  %44 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %44, ptr noundef @.str.1, i32 noundef 7822, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.78)
  store i1 false, ptr %retval, align 1
  br label %return

if.end52:                                         ; preds = %if.end48
  %45 = load ptr, ptr %params, align 8
  %sriov_max_vfs = getelementptr inbounds %struct.NvmeParams, ptr %45, i32 0, i32 14
  %46 = load i8, ptr %sriov_max_vfs, align 1
  %tobool53 = icmp ne i8 %46, 0
  br i1 %tobool53, label %if.then54, label %if.end139

if.then54:                                        ; preds = %if.end52
  %47 = load ptr, ptr %n.addr, align 8
  %subsys55 = getelementptr inbounds %struct.NvmeCtrl, ptr %47, i32 0, i32 33
  %48 = load ptr, ptr %subsys55, align 8
  %tobool56 = icmp ne ptr %48, null
  br i1 %tobool56, label %if.end58, label %if.then57

if.then57:                                        ; preds = %if.then54
  %49 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %49, ptr noundef @.str.1, i32 noundef 7828, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.79)
  store i1 false, ptr %retval, align 1
  br label %return

if.end58:                                         ; preds = %if.then54
  %50 = load ptr, ptr %params, align 8
  %sriov_max_vfs59 = getelementptr inbounds %struct.NvmeParams, ptr %50, i32 0, i32 14
  %51 = load i8, ptr %sriov_max_vfs59, align 1
  %conv60 = zext i8 %51 to i32
  %cmp61 = icmp sgt i32 %conv60, 127
  br i1 %cmp61, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.end58
  %52 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %52, ptr noundef @.str.1, i32 noundef 7834, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.80, i32 noundef 127)
  store i1 false, ptr %retval, align 1
  br label %return

if.end64:                                         ; preds = %if.end58
  %53 = load ptr, ptr %params, align 8
  %cmb_size_mb = getelementptr inbounds %struct.NvmeParams, ptr %53, i32 0, i32 4
  %54 = load i32, ptr %cmb_size_mb, align 4
  %tobool65 = icmp ne i32 %54, 0
  br i1 %tobool65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.end64
  %55 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %55, ptr noundef @.str.1, i32 noundef 7839, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.81)
  store i1 false, ptr %retval, align 1
  br label %return

if.end67:                                         ; preds = %if.end64
  %56 = load ptr, ptr %n.addr, align 8
  %pmr68 = getelementptr inbounds %struct.NvmeCtrl, ptr %56, i32 0, i32 26
  %dev69 = getelementptr inbounds %struct.anon.21, ptr %pmr68, i32 0, i32 0
  %57 = load ptr, ptr %dev69, align 16
  %tobool70 = icmp ne ptr %57, null
  br i1 %tobool70, label %if.then71, label %if.end72

if.then71:                                        ; preds = %if.end67
  %58 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %58, ptr noundef @.str.1, i32 noundef 7844, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.82)
  store i1 false, ptr %retval, align 1
  br label %return

if.end72:                                         ; preds = %if.end67
  %59 = load ptr, ptr %params, align 8
  %sriov_vq_flexible = getelementptr inbounds %struct.NvmeParams, ptr %59, i32 0, i32 15
  %60 = load i16, ptr %sriov_vq_flexible, align 8
  %tobool73 = icmp ne i16 %60, 0
  br i1 %tobool73, label %lor.lhs.false74, label %if.then76

lor.lhs.false74:                                  ; preds = %if.end72
  %61 = load ptr, ptr %params, align 8
  %sriov_vi_flexible = getelementptr inbounds %struct.NvmeParams, ptr %61, i32 0, i32 16
  %62 = load i16, ptr %sriov_vi_flexible, align 2
  %tobool75 = icmp ne i16 %62, 0
  br i1 %tobool75, label %if.end77, label %if.then76

if.then76:                                        ; preds = %lor.lhs.false74, %if.end72
  %63 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %63, ptr noundef @.str.1, i32 noundef 7850, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.83)
  store i1 false, ptr %retval, align 1
  br label %return

if.end77:                                         ; preds = %lor.lhs.false74
  %64 = load ptr, ptr %params, align 8
  %sriov_vq_flexible78 = getelementptr inbounds %struct.NvmeParams, ptr %64, i32 0, i32 15
  %65 = load i16, ptr %sriov_vq_flexible78, align 8
  %conv79 = zext i16 %65 to i32
  %66 = load ptr, ptr %params, align 8
  %sriov_max_vfs80 = getelementptr inbounds %struct.NvmeParams, ptr %66, i32 0, i32 14
  %67 = load i8, ptr %sriov_max_vfs80, align 1
  %conv81 = zext i8 %67 to i32
  %mul = mul i32 %conv81, 2
  %cmp82 = icmp slt i32 %conv79, %mul
  br i1 %cmp82, label %if.then84, label %if.end88

if.then84:                                        ; preds = %if.end77
  %68 = load ptr, ptr %errp.addr, align 8
  %69 = load ptr, ptr %params, align 8
  %sriov_max_vfs85 = getelementptr inbounds %struct.NvmeParams, ptr %69, i32 0, i32 14
  %70 = load i8, ptr %sriov_max_vfs85, align 1
  %conv86 = zext i8 %70 to i32
  %mul87 = mul i32 %conv86, 2
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %68, ptr noundef @.str.1, i32 noundef 7856, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.84, i32 noundef %mul87)
  store i1 false, ptr %retval, align 1
  br label %return

if.end88:                                         ; preds = %if.end77
  %71 = load ptr, ptr %params, align 8
  %max_ioqpairs89 = getelementptr inbounds %struct.NvmeParams, ptr %71, i32 0, i32 2
  %72 = load i32, ptr %max_ioqpairs89, align 4
  %73 = load ptr, ptr %params, align 8
  %sriov_vq_flexible90 = getelementptr inbounds %struct.NvmeParams, ptr %73, i32 0, i32 15
  %74 = load i16, ptr %sriov_vq_flexible90, align 8
  %conv91 = zext i16 %74 to i32
  %add = add i32 %conv91, 2
  %cmp92 = icmp ult i32 %72, %add
  br i1 %cmp92, label %if.then94, label %if.end95

if.then94:                                        ; preds = %if.end88
  %75 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %75, ptr noundef @.str.1, i32 noundef 7862, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.85)
  store i1 false, ptr %retval, align 1
  br label %return

if.end95:                                         ; preds = %if.end88
  %76 = load ptr, ptr %params, align 8
  %sriov_vi_flexible96 = getelementptr inbounds %struct.NvmeParams, ptr %76, i32 0, i32 16
  %77 = load i16, ptr %sriov_vi_flexible96, align 2
  %conv97 = zext i16 %77 to i32
  %78 = load ptr, ptr %params, align 8
  %sriov_max_vfs98 = getelementptr inbounds %struct.NvmeParams, ptr %78, i32 0, i32 14
  %79 = load i8, ptr %sriov_max_vfs98, align 1
  %conv99 = zext i8 %79 to i32
  %cmp100 = icmp slt i32 %conv97, %conv99
  br i1 %cmp100, label %if.then102, label %if.end105

if.then102:                                       ; preds = %if.end95
  %80 = load ptr, ptr %errp.addr, align 8
  %81 = load ptr, ptr %params, align 8
  %sriov_max_vfs103 = getelementptr inbounds %struct.NvmeParams, ptr %81, i32 0, i32 14
  %82 = load i8, ptr %sriov_max_vfs103, align 1
  %conv104 = zext i8 %82 to i32
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %80, ptr noundef @.str.1, i32 noundef 7868, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.86, i32 noundef %conv104)
  store i1 false, ptr %retval, align 1
  br label %return

if.end105:                                        ; preds = %if.end95
  %83 = load ptr, ptr %params, align 8
  %msix_qsize106 = getelementptr inbounds %struct.NvmeParams, ptr %83, i32 0, i32 3
  %84 = load i16, ptr %msix_qsize106, align 8
  %conv107 = zext i16 %84 to i32
  %85 = load ptr, ptr %params, align 8
  %sriov_vi_flexible108 = getelementptr inbounds %struct.NvmeParams, ptr %85, i32 0, i32 16
  %86 = load i16, ptr %sriov_vi_flexible108, align 2
  %conv109 = zext i16 %86 to i32
  %add110 = add i32 %conv109, 1
  %cmp111 = icmp slt i32 %conv107, %add110
  br i1 %cmp111, label %if.then113, label %if.end114

if.then113:                                       ; preds = %if.end105
  %87 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %87, ptr noundef @.str.1, i32 noundef 7874, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.87)
  store i1 false, ptr %retval, align 1
  br label %return

if.end114:                                        ; preds = %if.end105
  %88 = load ptr, ptr %params, align 8
  %sriov_max_vi_per_vf = getelementptr inbounds %struct.NvmeParams, ptr %88, i32 0, i32 18
  %89 = load i8, ptr %sriov_max_vi_per_vf, align 1
  %conv115 = zext i8 %89 to i32
  %tobool116 = icmp ne i32 %conv115, 0
  br i1 %tobool116, label %land.lhs.true117, label %if.end123

land.lhs.true117:                                 ; preds = %if.end114
  %90 = load ptr, ptr %params, align 8
  %sriov_max_vi_per_vf118 = getelementptr inbounds %struct.NvmeParams, ptr %90, i32 0, i32 18
  %91 = load i8, ptr %sriov_max_vi_per_vf118, align 1
  %conv119 = zext i8 %91 to i32
  %sub120 = sub i32 %conv119, 1
  %rem = srem i32 %sub120, 1
  %tobool121 = icmp ne i32 %rem, 0
  br i1 %tobool121, label %if.then122, label %if.end123

if.then122:                                       ; preds = %land.lhs.true117
  %92 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %92, ptr noundef @.str.1, i32 noundef 7882, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.88, i32 noundef 1)
  store i1 false, ptr %retval, align 1
  br label %return

if.end123:                                        ; preds = %land.lhs.true117, %if.end114
  %93 = load ptr, ptr %params, align 8
  %sriov_max_vq_per_vf = getelementptr inbounds %struct.NvmeParams, ptr %93, i32 0, i32 17
  %94 = load i8, ptr %sriov_max_vq_per_vf, align 4
  %conv124 = zext i8 %94 to i32
  %tobool125 = icmp ne i32 %conv124, 0
  br i1 %tobool125, label %land.lhs.true126, label %if.end138

land.lhs.true126:                                 ; preds = %if.end123
  %95 = load ptr, ptr %params, align 8
  %sriov_max_vq_per_vf127 = getelementptr inbounds %struct.NvmeParams, ptr %95, i32 0, i32 17
  %96 = load i8, ptr %sriov_max_vq_per_vf127, align 4
  %conv128 = zext i8 %96 to i32
  %cmp129 = icmp slt i32 %conv128, 2
  br i1 %cmp129, label %if.then137, label %lor.lhs.false131

lor.lhs.false131:                                 ; preds = %land.lhs.true126
  %97 = load ptr, ptr %params, align 8
  %sriov_max_vq_per_vf132 = getelementptr inbounds %struct.NvmeParams, ptr %97, i32 0, i32 17
  %98 = load i8, ptr %sriov_max_vq_per_vf132, align 4
  %conv133 = zext i8 %98 to i32
  %sub134 = sub i32 %conv133, 1
  %rem135 = srem i32 %sub134, 1
  %tobool136 = icmp ne i32 %rem135, 0
  br i1 %tobool136, label %if.then137, label %if.end138

if.then137:                                       ; preds = %lor.lhs.false131, %land.lhs.true126
  %99 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %99, ptr noundef @.str.1, i32 noundef 7891, ptr noundef @__func__.nvme_check_params, ptr noundef @.str.89, i32 noundef 1)
  store i1 false, ptr %retval, align 1
  br label %return

if.end138:                                        ; preds = %lor.lhs.false131, %if.end123
  br label %if.end139

if.end139:                                        ; preds = %if.end138, %if.end52
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end139, %if.then137, %if.then122, %if.then113, %if.then102, %if.then94, %if.then84, %if.then76, %if.then71, %if.then66, %if.then63, %if.then57, %if.then51, %if.then47, %if.then36, %if.then28, %if.then22, %if.then19, %if.then10, %if.then5
  %100 = load i1, ptr %retval, align 1
  ret i1 %100
}

declare void @qbus_init(ptr noundef, i64 noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_init_subsys(ptr noundef %n, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %n.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %cntlid = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 33
  %1 = load ptr, ptr %subsys, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %n.addr, align 8
  %3 = load ptr, ptr %errp.addr, align 8
  %call = call i32 @nvme_subsys_register_ctrl(ptr noundef %2, ptr noundef %3)
  store i32 %call, ptr %cntlid, align 4
  %4 = load i32, ptr %cntlid, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %if.end
  %5 = load i32, ptr %cntlid, align 4
  %conv = trunc i32 %5 to i16
  %6 = load ptr, ptr %n.addr, align 8
  %cntlid3 = getelementptr inbounds %struct.NvmeCtrl, ptr %6, i32 0, i32 6
  store i16 %conv, ptr %cntlid3, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end2, %if.then1, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_init_state(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %cap = alloca ptr, align 8
  %list = alloca ptr, align 8
  %sctrl = alloca ptr, align 8
  %pci = alloca ptr, align 8
  %max_vfs = alloca i8, align 1
  %i = alloca i32, align 4
  %_a57 = alloca i32, align 4
  %_b58 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %_a59 = alloca i32, align 4
  %_b60 = alloca i32, align 4
  %tmp131 = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 42
  store ptr %pri_ctrl_cap, ptr %cap, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %sec_ctrl_list = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 43
  store ptr %sec_ctrl_list, ptr %list, align 8
  %2 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %2)
  store ptr %call, ptr %pci, align 8
  %3 = load ptr, ptr %pci, align 8
  %call1 = call i32 @pci_is_vf(ptr noundef %3)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %n.addr, align 8
  %call2 = call ptr @nvme_sctrl(ptr noundef %4)
  store ptr %call2, ptr %sctrl, align 8
  store i8 0, ptr %max_vfs, align 1
  %5 = load ptr, ptr %sctrl, align 8
  %nvq = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %5, i32 0, i32 5
  %6 = load i16, ptr %nvq, align 1
  %conv = zext i16 %6 to i32
  %tobool3 = icmp ne i32 %conv, 0
  br i1 %tobool3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %7 = load ptr, ptr %sctrl, align 8
  %nvq4 = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %7, i32 0, i32 5
  %8 = load i16, ptr %nvq4, align 1
  %call5 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %8)
  %conv6 = zext i16 %call5 to i32
  %sub = sub i32 %conv6, 1
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ 0, %cond.false ]
  %9 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 21
  store i32 %cond, ptr %conf_ioqpairs, align 8
  %10 = load ptr, ptr %sctrl, align 8
  %nvi = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %10, i32 0, i32 6
  %11 = load i16, ptr %nvi, align 1
  %conv7 = zext i16 %11 to i32
  %tobool8 = icmp ne i32 %conv7, 0
  br i1 %tobool8, label %cond.true9, label %cond.false13

cond.true9:                                       ; preds = %cond.end
  %12 = load ptr, ptr %sctrl, align 8
  %nvi10 = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %12, i32 0, i32 6
  %13 = load i16, ptr %nvi10, align 1
  %call11 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %13)
  %conv12 = zext i16 %call11 to i32
  br label %cond.end14

cond.false13:                                     ; preds = %cond.end
  br label %cond.end14

cond.end14:                                       ; preds = %cond.false13, %cond.true9
  %cond15 = phi i32 [ %conv12, %cond.true9 ], [ 1, %cond.false13 ]
  %14 = load ptr, ptr %n.addr, align 8
  %conf_msix_qsize = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 20
  store i32 %cond15, ptr %conf_msix_qsize, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %15 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %15, i32 0, i32 4
  %sriov_max_vfs = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 14
  %16 = load i8, ptr %sriov_max_vfs, align 1
  store i8 %16, ptr %max_vfs, align 1
  %17 = load ptr, ptr %n.addr, align 8
  %params16 = getelementptr inbounds %struct.NvmeCtrl, ptr %17, i32 0, i32 4
  %max_ioqpairs = getelementptr inbounds %struct.NvmeParams, ptr %params16, i32 0, i32 2
  %18 = load i32, ptr %max_ioqpairs, align 4
  %19 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs17 = getelementptr inbounds %struct.NvmeCtrl, ptr %19, i32 0, i32 21
  store i32 %18, ptr %conf_ioqpairs17, align 8
  %20 = load ptr, ptr %n.addr, align 8
  %params18 = getelementptr inbounds %struct.NvmeCtrl, ptr %20, i32 0, i32 4
  %msix_qsize = getelementptr inbounds %struct.NvmeParams, ptr %params18, i32 0, i32 3
  %21 = load i16, ptr %msix_qsize, align 16
  %conv19 = zext i16 %21 to i32
  %22 = load ptr, ptr %n.addr, align 8
  %conf_msix_qsize20 = getelementptr inbounds %struct.NvmeCtrl, ptr %22, i32 0, i32 20
  store i32 %conv19, ptr %conf_msix_qsize20, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end14
  %23 = load ptr, ptr %n.addr, align 8
  %params21 = getelementptr inbounds %struct.NvmeCtrl, ptr %23, i32 0, i32 4
  %max_ioqpairs22 = getelementptr inbounds %struct.NvmeParams, ptr %params21, i32 0, i32 2
  %24 = load i32, ptr %max_ioqpairs22, align 4
  %add = add i32 %24, 1
  %conv23 = zext i32 %add to i64
  %call24 = call noalias ptr @g_malloc0_n(i64 noundef %conv23, i64 noundef 8) #11
  %25 = load ptr, ptr %n.addr, align 8
  %sq = getelementptr inbounds %struct.NvmeCtrl, ptr %25, i32 0, i32 36
  store ptr %call24, ptr %sq, align 16
  %26 = load ptr, ptr %n.addr, align 8
  %params25 = getelementptr inbounds %struct.NvmeCtrl, ptr %26, i32 0, i32 4
  %max_ioqpairs26 = getelementptr inbounds %struct.NvmeParams, ptr %params25, i32 0, i32 2
  %27 = load i32, ptr %max_ioqpairs26, align 4
  %add27 = add i32 %27, 1
  %conv28 = zext i32 %add27 to i64
  %call29 = call noalias ptr @g_malloc0_n(i64 noundef %conv28, i64 noundef 8) #11
  %28 = load ptr, ptr %n.addr, align 8
  %cq = getelementptr inbounds %struct.NvmeCtrl, ptr %28, i32 0, i32 37
  store ptr %call29, ptr %cq, align 8
  %29 = load ptr, ptr %n.addr, align 8
  %temperature = getelementptr inbounds %struct.NvmeCtrl, ptr %29, i32 0, i32 18
  store i16 323, ptr %temperature, align 16
  %30 = load ptr, ptr %n.addr, align 8
  %features = getelementptr inbounds %struct.NvmeCtrl, ptr %30, i32 0, i32 41
  %31 = getelementptr inbounds %struct.anon.28, ptr %features, i32 0, i32 0
  %temp_thresh_hi = getelementptr inbounds %struct.anon.29, ptr %31, i32 0, i32 0
  store i16 343, ptr %temp_thresh_hi, align 16
  %call30 = call i64 @qemu_clock_get_ms(i32 noundef 1)
  %32 = load ptr, ptr %n.addr, align 8
  %starttime_ms = getelementptr inbounds %struct.NvmeCtrl, ptr %32, i32 0, i32 17
  store i64 %call30, ptr %starttime_ms, align 8
  %33 = load ptr, ptr %n.addr, align 8
  %params31 = getelementptr inbounds %struct.NvmeCtrl, ptr %33, i32 0, i32 4
  %aerl = getelementptr inbounds %struct.NvmeParams, ptr %params31, i32 0, i32 5
  %34 = load i8, ptr %aerl, align 8
  %conv32 = zext i8 %34 to i32
  %add33 = add i32 %conv32, 1
  %conv34 = sext i32 %add33 to i64
  %call35 = call noalias ptr @g_malloc0_n(i64 noundef %conv34, i64 noundef 8) #11
  %35 = load ptr, ptr %n.addr, align 8
  %aer_reqs = getelementptr inbounds %struct.NvmeCtrl, ptr %35, i32 0, i32 28
  store ptr %call35, ptr %aer_reqs, align 16
  br label %do.body

do.body:                                          ; preds = %if.end
  %36 = load ptr, ptr %n.addr, align 8
  %aer_queue = getelementptr inbounds %struct.NvmeCtrl, ptr %36, i32 0, i32 29
  store ptr null, ptr %aer_queue, align 8
  %37 = load ptr, ptr %n.addr, align 8
  %aer_queue36 = getelementptr inbounds %struct.NvmeCtrl, ptr %37, i32 0, i32 29
  %38 = load ptr, ptr %n.addr, align 8
  %aer_queue37 = getelementptr inbounds %struct.NvmeCtrl, ptr %38, i32 0, i32 29
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %aer_queue37, i32 0, i32 1
  store ptr %aer_queue36, ptr %tql_prev, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %39 = load i8, ptr %max_vfs, align 1
  %conv38 = zext i8 %39 to i16
  %call39 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv38)
  %conv40 = trunc i16 %call39 to i8
  %40 = load ptr, ptr %list, align 8
  %numcntl = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %40, i32 0, i32 0
  store i8 %conv40, ptr %numcntl, align 1
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %41 = load i32, ptr %i, align 4
  %42 = load i8, ptr %max_vfs, align 1
  %conv41 = zext i8 %42 to i32
  %cmp = icmp slt i32 %41, %conv41
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %43 = load ptr, ptr %list, align 8
  %sec = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %43, i32 0, i32 2
  %44 = load i32, ptr %i, align 4
  %idxprom = sext i32 %44 to i64
  %arrayidx = getelementptr [127 x %struct.NvmeSecCtrlEntry], ptr %sec, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %sctrl, align 8
  %45 = load ptr, ptr %n.addr, align 8
  %cntlid = getelementptr inbounds %struct.NvmeCtrl, ptr %45, i32 0, i32 6
  %46 = load i16, ptr %cntlid, align 8
  %call43 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %46)
  %47 = load ptr, ptr %sctrl, align 8
  %pcid = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %47, i32 0, i32 1
  store i16 %call43, ptr %pcid, align 1
  %48 = load i32, ptr %i, align 4
  %add44 = add i32 %48, 1
  %conv45 = trunc i32 %add44 to i16
  %call46 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv45)
  %49 = load ptr, ptr %sctrl, align 8
  %vfn = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %49, i32 0, i32 4
  store i16 %call46, ptr %vfn, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %50 = load i32, ptr %i, align 4
  %inc = add i32 %50, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !14

for.end:                                          ; preds = %for.cond
  %51 = load ptr, ptr %n.addr, align 8
  %cntlid47 = getelementptr inbounds %struct.NvmeCtrl, ptr %51, i32 0, i32 6
  %52 = load i16, ptr %cntlid47, align 8
  %call48 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %52)
  %53 = load ptr, ptr %cap, align 8
  %cntlid49 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %53, i32 0, i32 0
  store i16 %call48, ptr %cntlid49, align 1
  %54 = load ptr, ptr %cap, align 8
  %crt = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %54, i32 0, i32 2
  store i8 3, ptr %crt, align 1
  %55 = load ptr, ptr %pci, align 8
  %call50 = call i32 @pci_is_vf(ptr noundef %55)
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %if.then52, label %if.else57

if.then52:                                        ; preds = %for.end
  %56 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs53 = getelementptr inbounds %struct.NvmeCtrl, ptr %56, i32 0, i32 21
  %57 = load i32, ptr %conf_ioqpairs53, align 8
  %add54 = add i32 1, %57
  %conv55 = trunc i32 %add54 to i16
  %call56 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv55)
  %58 = load ptr, ptr %cap, align 8
  %vqprt = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %58, i32 0, i32 7
  store i16 %call56, ptr %vqprt, align 1
  br label %if.end95

if.else57:                                        ; preds = %for.end
  %59 = load ptr, ptr %n.addr, align 8
  %params58 = getelementptr inbounds %struct.NvmeCtrl, ptr %59, i32 0, i32 4
  %max_ioqpairs59 = getelementptr inbounds %struct.NvmeParams, ptr %params58, i32 0, i32 2
  %60 = load i32, ptr %max_ioqpairs59, align 4
  %add60 = add i32 1, %60
  %61 = load ptr, ptr %n.addr, align 8
  %params61 = getelementptr inbounds %struct.NvmeCtrl, ptr %61, i32 0, i32 4
  %sriov_vq_flexible = getelementptr inbounds %struct.NvmeParams, ptr %params61, i32 0, i32 15
  %62 = load i16, ptr %sriov_vq_flexible, align 8
  %conv62 = zext i16 %62 to i32
  %sub63 = sub i32 %add60, %conv62
  %conv64 = trunc i32 %sub63 to i16
  %call65 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv64)
  %63 = load ptr, ptr %cap, align 8
  %vqprt66 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %63, i32 0, i32 7
  store i16 %call65, ptr %vqprt66, align 1
  %64 = load ptr, ptr %n.addr, align 8
  %params67 = getelementptr inbounds %struct.NvmeCtrl, ptr %64, i32 0, i32 4
  %sriov_vq_flexible68 = getelementptr inbounds %struct.NvmeParams, ptr %params67, i32 0, i32 15
  %65 = load i16, ptr %sriov_vq_flexible68, align 8
  %conv69 = zext i16 %65 to i32
  %call70 = call i32 @cpu_to_le32(i32 noundef %conv69)
  %66 = load ptr, ptr %cap, align 8
  %vqfrt = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %66, i32 0, i32 4
  store i32 %call70, ptr %vqfrt, align 1
  %67 = load ptr, ptr %cap, align 8
  %vqfrt71 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %67, i32 0, i32 4
  %68 = load i32, ptr %vqfrt71, align 1
  %conv72 = trunc i32 %68 to i16
  %69 = load ptr, ptr %cap, align 8
  %vqrfap = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %69, i32 0, i32 6
  store i16 %conv72, ptr %vqrfap, align 1
  %call73 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 1)
  %70 = load ptr, ptr %cap, align 8
  %vqgran = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %70, i32 0, i32 9
  store i16 %call73, ptr %vqgran, align 1
  %71 = load ptr, ptr %n.addr, align 8
  %params74 = getelementptr inbounds %struct.NvmeCtrl, ptr %71, i32 0, i32 4
  %sriov_max_vq_per_vf = getelementptr inbounds %struct.NvmeParams, ptr %params74, i32 0, i32 17
  %72 = load i8, ptr %sriov_max_vq_per_vf, align 4
  %conv75 = zext i8 %72 to i32
  %tobool76 = icmp ne i32 %conv75, 0
  br i1 %tobool76, label %cond.true77, label %cond.false83

cond.true77:                                      ; preds = %if.else57
  %73 = load ptr, ptr %n.addr, align 8
  %params78 = getelementptr inbounds %struct.NvmeCtrl, ptr %73, i32 0, i32 4
  %sriov_max_vq_per_vf79 = getelementptr inbounds %struct.NvmeParams, ptr %params78, i32 0, i32 17
  %74 = load i8, ptr %sriov_max_vq_per_vf79, align 4
  %conv80 = zext i8 %74 to i16
  %call81 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv80)
  %conv82 = zext i16 %call81 to i32
  br label %cond.end92

cond.false83:                                     ; preds = %if.else57
  %75 = load ptr, ptr %cap, align 8
  %vqfrt84 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %75, i32 0, i32 4
  %76 = load i32, ptr %vqfrt84, align 1
  %77 = load i8, ptr %max_vfs, align 1
  %conv85 = zext i8 %77 to i32
  store i32 %conv85, ptr %_a57, align 4
  store i32 1, ptr %_b58, align 4
  %78 = load i32, ptr %_a57, align 4
  %79 = load i32, ptr %_b58, align 4
  %cmp86 = icmp sgt i32 %78, %79
  br i1 %cmp86, label %cond.true88, label %cond.false89

cond.true88:                                      ; preds = %cond.false83
  %80 = load i32, ptr %_a57, align 4
  br label %cond.end90

cond.false89:                                     ; preds = %cond.false83
  %81 = load i32, ptr %_b58, align 4
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false89, %cond.true88
  %cond91 = phi i32 [ %80, %cond.true88 ], [ %81, %cond.false89 ]
  store i32 %cond91, ptr %tmp, align 4
  %82 = load i32, ptr %tmp, align 4
  %div = udiv i32 %76, %82
  br label %cond.end92

cond.end92:                                       ; preds = %cond.end90, %cond.true77
  %cond93 = phi i32 [ %conv82, %cond.true77 ], [ %div, %cond.end90 ]
  %conv94 = trunc i32 %cond93 to i16
  %83 = load ptr, ptr %cap, align 8
  %vqfrsm = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %83, i32 0, i32 8
  store i16 %conv94, ptr %vqfrsm, align 1
  br label %if.end95

if.end95:                                         ; preds = %cond.end92, %if.then52
  %84 = load ptr, ptr %pci, align 8
  %call96 = call i32 @pci_is_vf(ptr noundef %84)
  %tobool97 = icmp ne i32 %call96, 0
  br i1 %tobool97, label %if.then98, label %if.else102

if.then98:                                        ; preds = %if.end95
  %85 = load ptr, ptr %n.addr, align 8
  %conf_msix_qsize99 = getelementptr inbounds %struct.NvmeCtrl, ptr %85, i32 0, i32 20
  %86 = load i32, ptr %conf_msix_qsize99, align 4
  %conv100 = trunc i32 %86 to i16
  %call101 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv100)
  %87 = load ptr, ptr %cap, align 8
  %viprt = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %87, i32 0, i32 14
  store i16 %call101, ptr %viprt, align 1
  br label %if.end142

if.else102:                                       ; preds = %if.end95
  %88 = load ptr, ptr %n.addr, align 8
  %params103 = getelementptr inbounds %struct.NvmeCtrl, ptr %88, i32 0, i32 4
  %msix_qsize104 = getelementptr inbounds %struct.NvmeParams, ptr %params103, i32 0, i32 3
  %89 = load i16, ptr %msix_qsize104, align 16
  %conv105 = zext i16 %89 to i32
  %90 = load ptr, ptr %n.addr, align 8
  %params106 = getelementptr inbounds %struct.NvmeCtrl, ptr %90, i32 0, i32 4
  %sriov_vi_flexible = getelementptr inbounds %struct.NvmeParams, ptr %params106, i32 0, i32 16
  %91 = load i16, ptr %sriov_vi_flexible, align 2
  %conv107 = zext i16 %91 to i32
  %sub108 = sub i32 %conv105, %conv107
  %conv109 = trunc i32 %sub108 to i16
  %call110 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv109)
  %92 = load ptr, ptr %cap, align 8
  %viprt111 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %92, i32 0, i32 14
  store i16 %call110, ptr %viprt111, align 1
  %93 = load ptr, ptr %n.addr, align 8
  %params112 = getelementptr inbounds %struct.NvmeCtrl, ptr %93, i32 0, i32 4
  %sriov_vi_flexible113 = getelementptr inbounds %struct.NvmeParams, ptr %params112, i32 0, i32 16
  %94 = load i16, ptr %sriov_vi_flexible113, align 2
  %conv114 = zext i16 %94 to i32
  %call115 = call i32 @cpu_to_le32(i32 noundef %conv114)
  %95 = load ptr, ptr %cap, align 8
  %vifrt = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %95, i32 0, i32 11
  store i32 %call115, ptr %vifrt, align 1
  %96 = load ptr, ptr %cap, align 8
  %vifrt116 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %96, i32 0, i32 11
  %97 = load i32, ptr %vifrt116, align 1
  %conv117 = trunc i32 %97 to i16
  %98 = load ptr, ptr %cap, align 8
  %virfap = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %98, i32 0, i32 13
  store i16 %conv117, ptr %virfap, align 1
  %call118 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 1)
  %99 = load ptr, ptr %cap, align 8
  %vigran = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %99, i32 0, i32 16
  store i16 %call118, ptr %vigran, align 1
  %100 = load ptr, ptr %n.addr, align 8
  %params119 = getelementptr inbounds %struct.NvmeCtrl, ptr %100, i32 0, i32 4
  %sriov_max_vi_per_vf = getelementptr inbounds %struct.NvmeParams, ptr %params119, i32 0, i32 18
  %101 = load i8, ptr %sriov_max_vi_per_vf, align 1
  %conv120 = zext i8 %101 to i32
  %tobool121 = icmp ne i32 %conv120, 0
  br i1 %tobool121, label %cond.true122, label %cond.false128

cond.true122:                                     ; preds = %if.else102
  %102 = load ptr, ptr %n.addr, align 8
  %params123 = getelementptr inbounds %struct.NvmeCtrl, ptr %102, i32 0, i32 4
  %sriov_max_vi_per_vf124 = getelementptr inbounds %struct.NvmeParams, ptr %params123, i32 0, i32 18
  %103 = load i8, ptr %sriov_max_vi_per_vf124, align 1
  %conv125 = zext i8 %103 to i16
  %call126 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv125)
  %conv127 = zext i16 %call126 to i32
  br label %cond.end139

cond.false128:                                    ; preds = %if.else102
  %104 = load ptr, ptr %cap, align 8
  %vifrt129 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %104, i32 0, i32 11
  %105 = load i32, ptr %vifrt129, align 1
  %106 = load i8, ptr %max_vfs, align 1
  %conv130 = zext i8 %106 to i32
  store i32 %conv130, ptr %_a59, align 4
  store i32 1, ptr %_b60, align 4
  %107 = load i32, ptr %_a59, align 4
  %108 = load i32, ptr %_b60, align 4
  %cmp132 = icmp sgt i32 %107, %108
  br i1 %cmp132, label %cond.true134, label %cond.false135

cond.true134:                                     ; preds = %cond.false128
  %109 = load i32, ptr %_a59, align 4
  br label %cond.end136

cond.false135:                                    ; preds = %cond.false128
  %110 = load i32, ptr %_b60, align 4
  br label %cond.end136

cond.end136:                                      ; preds = %cond.false135, %cond.true134
  %cond137 = phi i32 [ %109, %cond.true134 ], [ %110, %cond.false135 ]
  store i32 %cond137, ptr %tmp131, align 4
  %111 = load i32, ptr %tmp131, align 4
  %div138 = udiv i32 %105, %111
  br label %cond.end139

cond.end139:                                      ; preds = %cond.end136, %cond.true122
  %cond140 = phi i32 [ %conv127, %cond.true122 ], [ %div138, %cond.end136 ]
  %conv141 = trunc i32 %cond140 to i16
  %112 = load ptr, ptr %cap, align 8
  %vifrsm = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %112, i32 0, i32 15
  store i16 %conv141, ptr %vifrsm, align 1
  br label %if.end142

if.end142:                                        ; preds = %cond.end139, %if.then98
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_init_pci(ptr noundef %n, ptr noundef %pci_dev, ptr noundef %errp) #0 {
entry:
  %retval = alloca i1, align 1
  %n.addr = alloca ptr, align 8
  %pci_dev.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %_auto_errp_prop = alloca %struct.ErrorPropagator, align 8
  %pci_conf = alloca ptr, align 8
  %bar_size = alloca i64, align 8
  %msix_table_offset = alloca i32, align 4
  %msix_pba_offset = alloca i32, align 4
  %ret = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %pci_dev, ptr %pci_dev.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %local_err = getelementptr inbounds %struct.ErrorPropagator, ptr %_auto_errp_prop, i32 0, i32 0
  store ptr null, ptr %local_err, align 8
  %errp1 = getelementptr inbounds %struct.ErrorPropagator, ptr %_auto_errp_prop, i32 0, i32 1
  %0 = load ptr, ptr %errp.addr, align 8
  store ptr %0, ptr %errp1, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load ptr, ptr %errp.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %do.body
  %2 = load ptr, ptr %errp.addr, align 8
  %cmp = icmp eq ptr %2, @error_fatal
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %do.body
  %local_err2 = getelementptr inbounds %struct.ErrorPropagator, ptr %_auto_errp_prop, i32 0, i32 0
  store ptr %local_err2, ptr %errp.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  %3 = load ptr, ptr %pci_dev.addr, align 8
  %config = getelementptr inbounds %struct.PCIDevice, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %config, align 8
  store ptr %4, ptr %pci_conf, align 8
  %5 = load ptr, ptr %pci_conf, align 8
  %arrayidx = getelementptr i8, ptr %5, i64 61
  store i8 1, ptr %arrayidx, align 1
  %6 = load ptr, ptr %pci_conf, align 8
  call void @pci_config_set_prog_interface(ptr noundef %6, i8 noundef zeroext 2)
  %7 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %7, i32 0, i32 4
  %use_intel_id = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 9
  %8 = load i8, ptr %use_intel_id, align 2
  %tobool3 = trunc i8 %8 to i1
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %do.end
  %9 = load ptr, ptr %pci_conf, align 8
  call void @pci_config_set_vendor_id(ptr noundef %9, i16 noundef zeroext -32634)
  %10 = load ptr, ptr %pci_conf, align 8
  call void @pci_config_set_device_id(ptr noundef %10, i16 noundef zeroext 22597)
  br label %if.end5

if.else:                                          ; preds = %do.end
  %11 = load ptr, ptr %pci_conf, align 8
  call void @pci_config_set_vendor_id(ptr noundef %11, i16 noundef zeroext 6966)
  %12 = load ptr, ptr %pci_conf, align 8
  call void @pci_config_set_device_id(ptr noundef %12, i16 noundef zeroext 16)
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then4
  %13 = load ptr, ptr %pci_conf, align 8
  call void @pci_config_set_class(ptr noundef %13, i16 noundef zeroext 264)
  %14 = load ptr, ptr %pci_dev.addr, align 8
  %call = call i32 @nvme_add_pm_capability(ptr noundef %14, i8 noundef zeroext 96)
  %15 = load ptr, ptr %pci_dev.addr, align 8
  %call6 = call i32 @pcie_endpoint_cap_init(ptr noundef %15, i8 noundef zeroext -128)
  %16 = load ptr, ptr %pci_dev.addr, align 8
  call void @pcie_cap_flr_init(ptr noundef %16)
  %17 = load ptr, ptr %n.addr, align 8
  %params7 = getelementptr inbounds %struct.NvmeCtrl, ptr %17, i32 0, i32 4
  %sriov_max_vfs = getelementptr inbounds %struct.NvmeParams, ptr %params7, i32 0, i32 14
  %18 = load i8, ptr %sriov_max_vfs, align 1
  %tobool8 = icmp ne i8 %18, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end5
  %19 = load ptr, ptr %pci_dev.addr, align 8
  call void @pcie_ari_init(ptr noundef %19, i16 noundef zeroext 256)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end5
  %20 = load ptr, ptr %n.addr, align 8
  %params11 = getelementptr inbounds %struct.NvmeCtrl, ptr %20, i32 0, i32 4
  %max_ioqpairs = getelementptr inbounds %struct.NvmeParams, ptr %params11, i32 0, i32 2
  %21 = load i32, ptr %max_ioqpairs, align 4
  %add = add i32 %21, 1
  %22 = load ptr, ptr %n.addr, align 8
  %params12 = getelementptr inbounds %struct.NvmeCtrl, ptr %22, i32 0, i32 4
  %msix_qsize = getelementptr inbounds %struct.NvmeParams, ptr %params12, i32 0, i32 3
  %23 = load i16, ptr %msix_qsize, align 16
  %conv = zext i16 %23 to i32
  %call13 = call i64 @nvme_bar_size(i32 noundef %add, i32 noundef %conv, ptr noundef %msix_table_offset, ptr noundef %msix_pba_offset)
  store i64 %call13, ptr %bar_size, align 8
  %24 = load ptr, ptr %n.addr, align 8
  %bar0 = getelementptr inbounds %struct.NvmeCtrl, ptr %24, i32 0, i32 1
  %25 = load ptr, ptr %n.addr, align 8
  %26 = load i64, ptr %bar_size, align 8
  call void @memory_region_init(ptr noundef %bar0, ptr noundef %25, ptr noundef @.str.90, i64 noundef %26)
  %27 = load ptr, ptr %n.addr, align 8
  %iomem = getelementptr inbounds %struct.NvmeCtrl, ptr %27, i32 0, i32 2
  %28 = load ptr, ptr %n.addr, align 8
  %29 = load ptr, ptr %n.addr, align 8
  %30 = load i32, ptr %msix_table_offset, align 4
  %conv14 = zext i32 %30 to i64
  call void @memory_region_init_io(ptr noundef %iomem, ptr noundef %28, ptr noundef @nvme_mmio_ops, ptr noundef %29, ptr noundef @.str.49, i64 noundef %conv14)
  %31 = load ptr, ptr %n.addr, align 8
  %bar015 = getelementptr inbounds %struct.NvmeCtrl, ptr %31, i32 0, i32 1
  %32 = load ptr, ptr %n.addr, align 8
  %iomem16 = getelementptr inbounds %struct.NvmeCtrl, ptr %32, i32 0, i32 2
  call void @memory_region_add_subregion(ptr noundef %bar015, i64 noundef 0, ptr noundef %iomem16)
  %33 = load ptr, ptr %pci_dev.addr, align 8
  %call17 = call i32 @pci_is_vf(ptr noundef %33)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.then19, label %if.else21

if.then19:                                        ; preds = %if.end10
  %34 = load ptr, ptr %pci_dev.addr, align 8
  %35 = load ptr, ptr %n.addr, align 8
  %bar020 = getelementptr inbounds %struct.NvmeCtrl, ptr %35, i32 0, i32 1
  call void @pcie_sriov_vf_register_bar(ptr noundef %34, i32 noundef 0, ptr noundef %bar020)
  br label %if.end23

if.else21:                                        ; preds = %if.end10
  %36 = load ptr, ptr %pci_dev.addr, align 8
  %37 = load ptr, ptr %n.addr, align 8
  %bar022 = getelementptr inbounds %struct.NvmeCtrl, ptr %37, i32 0, i32 1
  call void @pci_register_bar(ptr noundef %36, i32 noundef 0, i8 noundef zeroext 4, ptr noundef %bar022)
  br label %if.end23

if.end23:                                         ; preds = %if.else21, %if.then19
  %38 = load ptr, ptr %pci_dev.addr, align 8
  %39 = load ptr, ptr %n.addr, align 8
  %params24 = getelementptr inbounds %struct.NvmeCtrl, ptr %39, i32 0, i32 4
  %msix_qsize25 = getelementptr inbounds %struct.NvmeParams, ptr %params24, i32 0, i32 3
  %40 = load i16, ptr %msix_qsize25, align 16
  %41 = load ptr, ptr %n.addr, align 8
  %bar026 = getelementptr inbounds %struct.NvmeCtrl, ptr %41, i32 0, i32 1
  %42 = load i32, ptr %msix_table_offset, align 4
  %43 = load ptr, ptr %n.addr, align 8
  %bar027 = getelementptr inbounds %struct.NvmeCtrl, ptr %43, i32 0, i32 1
  %44 = load i32, ptr %msix_pba_offset, align 4
  %45 = load ptr, ptr %errp.addr, align 8
  %call28 = call i32 @msix_init(ptr noundef %38, i16 noundef zeroext %40, ptr noundef %bar026, i8 noundef zeroext 0, i32 noundef %42, ptr noundef %bar027, i8 noundef zeroext 0, i32 noundef %44, i8 noundef zeroext 0, ptr noundef %45)
  store i32 %call28, ptr %ret, align 4
  %46 = load i32, ptr %ret, align 4
  %cmp29 = icmp eq i32 %46, -95
  br i1 %cmp29, label %if.then31, label %if.else32

if.then31:                                        ; preds = %if.end23
  %47 = load ptr, ptr %errp.addr, align 8
  %48 = load ptr, ptr %47, align 8
  call void @warn_report_err(ptr noundef %48)
  %49 = load ptr, ptr %errp.addr, align 8
  store ptr null, ptr %49, align 8
  br label %if.end37

if.else32:                                        ; preds = %if.end23
  %50 = load i32, ptr %ret, align 4
  %cmp33 = icmp slt i32 %50, 0
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.else32
  store i1 false, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end36:                                         ; preds = %if.else32
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then31
  %51 = load ptr, ptr %pci_dev.addr, align 8
  %52 = load ptr, ptr %n.addr, align 8
  %conf_msix_qsize = getelementptr inbounds %struct.NvmeCtrl, ptr %52, i32 0, i32 20
  %53 = load i32, ptr %conf_msix_qsize, align 4
  call void @nvme_update_msixcap_ts(ptr noundef %51, i32 noundef %53)
  %54 = load ptr, ptr %n.addr, align 8
  %params38 = getelementptr inbounds %struct.NvmeCtrl, ptr %54, i32 0, i32 4
  %cmb_size_mb = getelementptr inbounds %struct.NvmeParams, ptr %params38, i32 0, i32 4
  %55 = load i32, ptr %cmb_size_mb, align 4
  %tobool39 = icmp ne i32 %55, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end37
  %56 = load ptr, ptr %n.addr, align 8
  %57 = load ptr, ptr %pci_dev.addr, align 8
  call void @nvme_init_cmb(ptr noundef %56, ptr noundef %57)
  br label %if.end41

if.end41:                                         ; preds = %if.then40, %if.end37
  %58 = load ptr, ptr %n.addr, align 8
  %pmr = getelementptr inbounds %struct.NvmeCtrl, ptr %58, i32 0, i32 26
  %dev = getelementptr inbounds %struct.anon.21, ptr %pmr, i32 0, i32 0
  %59 = load ptr, ptr %dev, align 16
  %tobool42 = icmp ne ptr %59, null
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end41
  %60 = load ptr, ptr %n.addr, align 8
  %61 = load ptr, ptr %pci_dev.addr, align 8
  call void @nvme_init_pmr(ptr noundef %60, ptr noundef %61)
  br label %if.end44

if.end44:                                         ; preds = %if.then43, %if.end41
  %62 = load ptr, ptr %pci_dev.addr, align 8
  %call45 = call i32 @pci_is_vf(ptr noundef %62)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.end52, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end44
  %63 = load ptr, ptr %n.addr, align 8
  %params47 = getelementptr inbounds %struct.NvmeCtrl, ptr %63, i32 0, i32 4
  %sriov_max_vfs48 = getelementptr inbounds %struct.NvmeParams, ptr %params47, i32 0, i32 14
  %64 = load i8, ptr %sriov_max_vfs48, align 1
  %conv49 = zext i8 %64 to i32
  %tobool50 = icmp ne i32 %conv49, 0
  br i1 %tobool50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %land.lhs.true
  %65 = load ptr, ptr %n.addr, align 8
  %66 = load ptr, ptr %pci_dev.addr, align 8
  call void @nvme_init_sriov(ptr noundef %65, ptr noundef %66, i16 noundef zeroext 288)
  br label %if.end52

if.end52:                                         ; preds = %if.then51, %land.lhs.true, %if.end44
  store i1 true, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end52, %if.then35
  call void @glib_auto_cleanup_ErrorPropagator(ptr noundef %_auto_errp_prop)
  %67 = load i1, ptr %retval, align 1
  ret i1 %67
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_init_ctrl(ptr noundef %n, ptr noundef %pci_dev) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %pci_dev.addr = alloca ptr, align 8
  %id = alloca ptr, align 8
  %pci_conf = alloca ptr, align 8
  %cap = alloca i64, align 8
  %sctrl = alloca ptr, align 8
  %ctratt = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %pci_dev, ptr %pci_dev.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %id_ctrl = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 40
  store ptr %id_ctrl, ptr %id, align 8
  %1 = load ptr, ptr %pci_dev.addr, align 8
  %config = getelementptr inbounds %struct.PCIDevice, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %config, align 8
  store ptr %2, ptr %pci_conf, align 8
  %3 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 3
  %cap1 = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 0
  %call = call i64 @ldq_le_p(ptr noundef %cap1)
  store i64 %call, ptr %cap, align 8
  %4 = load ptr, ptr %n.addr, align 8
  %call2 = call ptr @nvme_sctrl(ptr noundef %4)
  store ptr %call2, ptr %sctrl, align 8
  %5 = load ptr, ptr %pci_conf, align 8
  %add.ptr = getelementptr i8, ptr %5, i64 0
  %call3 = call zeroext i16 @pci_get_word(ptr noundef %add.ptr)
  %call4 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %call3)
  %6 = load ptr, ptr %id, align 8
  %vid = getelementptr inbounds %struct.NvmeIdCtrl, ptr %6, i32 0, i32 0
  store i16 %call4, ptr %vid, align 1
  %7 = load ptr, ptr %pci_conf, align 8
  %add.ptr5 = getelementptr i8, ptr %7, i64 44
  %call6 = call zeroext i16 @pci_get_word(ptr noundef %add.ptr5)
  %call7 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %call6)
  %8 = load ptr, ptr %id, align 8
  %ssvid = getelementptr inbounds %struct.NvmeIdCtrl, ptr %8, i32 0, i32 1
  store i16 %call7, ptr %ssvid, align 1
  %9 = load ptr, ptr %id, align 8
  %mn = getelementptr inbounds %struct.NvmeIdCtrl, ptr %9, i32 0, i32 3
  %arraydecay = getelementptr inbounds [40 x i8], ptr %mn, i64 0, i64 0
  call void @strpadcpy(ptr noundef %arraydecay, i32 noundef 40, ptr noundef @.str.483, i8 noundef signext 32)
  %10 = load ptr, ptr %id, align 8
  %fr = getelementptr inbounds %struct.NvmeIdCtrl, ptr %10, i32 0, i32 4
  %arraydecay8 = getelementptr inbounds [8 x i8], ptr %fr, i64 0, i64 0
  call void @strpadcpy(ptr noundef %arraydecay8, i32 noundef 8, ptr noundef @.str.484, i8 noundef signext 32)
  %11 = load ptr, ptr %id, align 8
  %sn = getelementptr inbounds %struct.NvmeIdCtrl, ptr %11, i32 0, i32 2
  %arraydecay9 = getelementptr inbounds [20 x i8], ptr %sn, i64 0, i64 0
  %12 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %12, i32 0, i32 4
  %serial = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 0
  %13 = load ptr, ptr %serial, align 16
  call void @strpadcpy(ptr noundef %arraydecay9, i32 noundef 20, ptr noundef %13, i8 noundef signext 32)
  %14 = load ptr, ptr %n.addr, align 8
  %cntlid = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 6
  %15 = load i16, ptr %cntlid, align 8
  %call10 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %15)
  %16 = load ptr, ptr %id, align 8
  %cntlid11 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %16, i32 0, i32 9
  store i16 %call10, ptr %cntlid11, align 1
  %call12 = call i32 @cpu_to_le32(i32 noundef 256)
  %17 = load ptr, ptr %id, align 8
  %oaes = getelementptr inbounds %struct.NvmeIdCtrl, ptr %17, i32 0, i32 13
  store i32 %call12, ptr %oaes, align 1
  store i32 32768, ptr %ctratt, align 4
  %18 = load ptr, ptr %id, align 8
  %rab = getelementptr inbounds %struct.NvmeIdCtrl, ptr %18, i32 0, i32 5
  store i8 6, ptr %rab, align 1
  %19 = load ptr, ptr %n.addr, align 8
  %params13 = getelementptr inbounds %struct.NvmeCtrl, ptr %19, i32 0, i32 4
  %use_intel_id = getelementptr inbounds %struct.NvmeParams, ptr %params13, i32 0, i32 9
  %20 = load i8, ptr %use_intel_id, align 2
  %tobool = trunc i8 %20 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %21 = load ptr, ptr %id, align 8
  %ieee = getelementptr inbounds %struct.NvmeIdCtrl, ptr %21, i32 0, i32 6
  %arrayidx = getelementptr [3 x i8], ptr %ieee, i64 0, i64 0
  store i8 -77, ptr %arrayidx, align 1
  %22 = load ptr, ptr %id, align 8
  %ieee14 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %22, i32 0, i32 6
  %arrayidx15 = getelementptr [3 x i8], ptr %ieee14, i64 0, i64 1
  store i8 2, ptr %arrayidx15, align 1
  %23 = load ptr, ptr %id, align 8
  %ieee16 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %23, i32 0, i32 6
  %arrayidx17 = getelementptr [3 x i8], ptr %ieee16, i64 0, i64 2
  store i8 0, ptr %arrayidx17, align 1
  br label %if.end

if.else:                                          ; preds = %entry
  %24 = load ptr, ptr %id, align 8
  %ieee18 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %24, i32 0, i32 6
  %arrayidx19 = getelementptr [3 x i8], ptr %ieee18, i64 0, i64 0
  store i8 0, ptr %arrayidx19, align 1
  %25 = load ptr, ptr %id, align 8
  %ieee20 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %25, i32 0, i32 6
  %arrayidx21 = getelementptr [3 x i8], ptr %ieee20, i64 0, i64 1
  store i8 84, ptr %arrayidx21, align 1
  %26 = load ptr, ptr %id, align 8
  %ieee22 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %26, i32 0, i32 6
  %arrayidx23 = getelementptr [3 x i8], ptr %ieee22, i64 0, i64 2
  store i8 82, ptr %arrayidx23, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %27 = load ptr, ptr %n.addr, align 8
  %params24 = getelementptr inbounds %struct.NvmeCtrl, ptr %27, i32 0, i32 4
  %mdts = getelementptr inbounds %struct.NvmeParams, ptr %params24, i32 0, i32 7
  %28 = load i8, ptr %mdts, align 16
  %29 = load ptr, ptr %id, align 8
  %mdts25 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %29, i32 0, i32 8
  store i8 %28, ptr %mdts25, align 1
  %call26 = call i32 @cpu_to_le32(i32 noundef 66560)
  %30 = load ptr, ptr %id, align 8
  %ver = getelementptr inbounds %struct.NvmeIdCtrl, ptr %30, i32 0, i32 10
  store i32 %call26, ptr %ver, align 1
  %call27 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 298)
  %31 = load ptr, ptr %id, align 8
  %oacs = getelementptr inbounds %struct.NvmeIdCtrl, ptr %31, i32 0, i32 19
  store i16 %call27, ptr %oacs, align 1
  %32 = load ptr, ptr %id, align 8
  %cntrltype = getelementptr inbounds %struct.NvmeIdCtrl, ptr %32, i32 0, i32 16
  store i8 1, ptr %cntrltype, align 1
  %33 = load ptr, ptr %id, align 8
  %acl = getelementptr inbounds %struct.NvmeIdCtrl, ptr %33, i32 0, i32 20
  store i8 3, ptr %acl, align 1
  %34 = load ptr, ptr %n.addr, align 8
  %params28 = getelementptr inbounds %struct.NvmeCtrl, ptr %34, i32 0, i32 4
  %aerl = getelementptr inbounds %struct.NvmeParams, ptr %params28, i32 0, i32 5
  %35 = load i8, ptr %aerl, align 8
  %36 = load ptr, ptr %id, align 8
  %aerl29 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %36, i32 0, i32 21
  store i8 %35, ptr %aerl29, align 1
  %37 = load ptr, ptr %id, align 8
  %frmw = getelementptr inbounds %struct.NvmeIdCtrl, ptr %37, i32 0, i32 22
  store i8 3, ptr %frmw, align 1
  %38 = load ptr, ptr %id, align 8
  %lpa = getelementptr inbounds %struct.NvmeIdCtrl, ptr %38, i32 0, i32 23
  store i8 7, ptr %lpa, align 1
  %call30 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 343)
  %39 = load ptr, ptr %id, align 8
  %wctemp = getelementptr inbounds %struct.NvmeIdCtrl, ptr %39, i32 0, i32 28
  store i16 %call30, ptr %wctemp, align 1
  %call31 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 373)
  %40 = load ptr, ptr %id, align 8
  %cctemp = getelementptr inbounds %struct.NvmeIdCtrl, ptr %40, i32 0, i32 29
  store i16 %call31, ptr %cctemp, align 1
  %41 = load ptr, ptr %id, align 8
  %sqes = getelementptr inbounds %struct.NvmeIdCtrl, ptr %41, i32 0, i32 48
  store i8 102, ptr %sqes, align 1
  %42 = load ptr, ptr %id, align 8
  %cqes = getelementptr inbounds %struct.NvmeIdCtrl, ptr %42, i32 0, i32 49
  store i8 68, ptr %cqes, align 1
  %call32 = call i32 @cpu_to_le32(i32 noundef 256)
  %43 = load ptr, ptr %id, align 8
  %nn = getelementptr inbounds %struct.NvmeIdCtrl, ptr %43, i32 0, i32 51
  store i32 %call32, ptr %nn, align 1
  %call33 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 349)
  %44 = load ptr, ptr %id, align 8
  %oncs = getelementptr inbounds %struct.NvmeIdCtrl, ptr %44, i32 0, i32 52
  store i16 %call33, ptr %oncs, align 1
  %45 = load ptr, ptr %id, align 8
  %vwc = getelementptr inbounds %struct.NvmeIdCtrl, ptr %45, i32 0, i32 55
  store i8 7, ptr %vwc, align 1
  %call34 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 3)
  %46 = load ptr, ptr %id, align 8
  %ocfs = getelementptr inbounds %struct.NvmeIdCtrl, ptr %46, i32 0, i32 61
  store i16 %call34, ptr %ocfs, align 1
  %call35 = call i32 @cpu_to_le32(i32 noundef 1)
  %47 = load ptr, ptr %id, align 8
  %sgls = getelementptr inbounds %struct.NvmeIdCtrl, ptr %47, i32 0, i32 62
  store i32 %call35, ptr %sgls, align 1
  %48 = load ptr, ptr %n.addr, align 8
  call void @nvme_init_subnqn(ptr noundef %48)
  %call36 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 2500)
  %49 = load ptr, ptr %id, align 8
  %psd = getelementptr inbounds %struct.NvmeIdCtrl, ptr %49, i32 0, i32 66
  %arrayidx37 = getelementptr [32 x %struct.NvmePSD], ptr %psd, i64 0, i64 0
  %mp = getelementptr inbounds %struct.NvmePSD, ptr %arrayidx37, i32 0, i32 0
  store i16 %call36, ptr %mp, align 1
  %call38 = call i32 @cpu_to_le32(i32 noundef 16)
  %50 = load ptr, ptr %id, align 8
  %psd39 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %50, i32 0, i32 66
  %arrayidx40 = getelementptr [32 x %struct.NvmePSD], ptr %psd39, i64 0, i64 0
  %enlat = getelementptr inbounds %struct.NvmePSD, ptr %arrayidx40, i32 0, i32 2
  store i32 %call38, ptr %enlat, align 1
  %call41 = call i32 @cpu_to_le32(i32 noundef 4)
  %51 = load ptr, ptr %id, align 8
  %psd42 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %51, i32 0, i32 66
  %arrayidx43 = getelementptr [32 x %struct.NvmePSD], ptr %psd42, i64 0, i64 0
  %exlat = getelementptr inbounds %struct.NvmePSD, ptr %arrayidx43, i32 0, i32 3
  store i32 %call41, ptr %exlat, align 1
  %52 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %52, i32 0, i32 33
  %53 = load ptr, ptr %subsys, align 8
  %tobool44 = icmp ne ptr %53, null
  br i1 %tobool44, label %if.then45, label %if.end54

if.then45:                                        ; preds = %if.end
  %54 = load ptr, ptr %id, align 8
  %cmic = getelementptr inbounds %struct.NvmeIdCtrl, ptr %54, i32 0, i32 7
  %55 = load i8, ptr %cmic, align 1
  %conv = zext i8 %55 to i32
  %or = or i32 %conv, 2
  %conv46 = trunc i32 %or to i8
  store i8 %conv46, ptr %cmic, align 1
  %56 = load i32, ptr %ctratt, align 4
  %or47 = or i32 %56, 16
  store i32 %or47, ptr %ctratt, align 4
  %call48 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 1)
  %57 = load ptr, ptr %id, align 8
  %endgidmax = getelementptr inbounds %struct.NvmeIdCtrl, ptr %57, i32 0, i32 46
  store i16 %call48, ptr %endgidmax, align 1
  %58 = load ptr, ptr %n.addr, align 8
  %subsys49 = getelementptr inbounds %struct.NvmeCtrl, ptr %58, i32 0, i32 33
  %59 = load ptr, ptr %subsys49, align 8
  %endgrp = getelementptr inbounds %struct.NvmeSubsystem, ptr %59, i32 0, i32 6
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %endgrp, i32 0, i32 1
  %enabled = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 9
  %60 = load i8, ptr %enabled, align 8
  %tobool50 = trunc i8 %60 to i1
  br i1 %tobool50, label %if.then51, label %if.end53

if.then51:                                        ; preds = %if.then45
  %61 = load i32, ptr %ctratt, align 4
  %or52 = or i32 %61, 524288
  store i32 %or52, ptr %ctratt, align 4
  br label %if.end53

if.end53:                                         ; preds = %if.then51, %if.then45
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.end
  %62 = load i32, ptr %ctratt, align 4
  %call55 = call i32 @cpu_to_le32(i32 noundef %62)
  %63 = load ptr, ptr %id, align 8
  %ctratt56 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %63, i32 0, i32 14
  store i32 %call55, ptr %ctratt56, align 1
  %64 = load i64, ptr %cap, align 8
  %or57 = or i64 %64, 2047
  store i64 %or57, ptr %cap, align 8
  %65 = load i64, ptr %cap, align 8
  %or58 = or i64 %65, 65536
  store i64 %or58, ptr %cap, align 8
  %66 = load i64, ptr %cap, align 8
  %or59 = or i64 %66, 251658240
  store i64 %or59, ptr %cap, align 8
  %67 = load i64, ptr %cap, align 8
  %or60 = or i64 %67, 137438953472
  store i64 %or60, ptr %cap, align 8
  %68 = load i64, ptr %cap, align 8
  %or61 = or i64 %68, 8796093022208
  store i64 %or61, ptr %cap, align 8
  %69 = load i64, ptr %cap, align 8
  %or62 = or i64 %69, 17592186044416
  store i64 %or62, ptr %cap, align 8
  %70 = load i64, ptr %cap, align 8
  %or63 = or i64 %70, 18014398509481984
  store i64 %or63, ptr %cap, align 8
  %71 = load ptr, ptr %n.addr, align 8
  %params64 = getelementptr inbounds %struct.NvmeCtrl, ptr %71, i32 0, i32 4
  %cmb_size_mb = getelementptr inbounds %struct.NvmeParams, ptr %params64, i32 0, i32 4
  %72 = load i32, ptr %cmb_size_mb, align 4
  %tobool65 = icmp ne i32 %72, 0
  %cond = select i1 %tobool65, i32 1, i32 0
  %and = and i32 %cond, 1
  %conv66 = sext i32 %and to i64
  %shl = shl i64 %conv66, 57
  %73 = load i64, ptr %cap, align 8
  %or67 = or i64 %73, %shl
  store i64 %or67, ptr %cap, align 8
  %74 = load ptr, ptr %n.addr, align 8
  %pmr = getelementptr inbounds %struct.NvmeCtrl, ptr %74, i32 0, i32 26
  %dev = getelementptr inbounds %struct.anon.21, ptr %pmr, i32 0, i32 0
  %75 = load ptr, ptr %dev, align 16
  %tobool68 = icmp ne ptr %75, null
  %cond69 = select i1 %tobool68, i32 1, i32 0
  %and70 = and i32 %cond69, 1
  %conv71 = sext i32 %and70 to i64
  %shl72 = shl i64 %conv71, 56
  %76 = load i64, ptr %cap, align 8
  %or73 = or i64 %76, %shl72
  store i64 %or73, ptr %cap, align 8
  %77 = load ptr, ptr %n.addr, align 8
  %bar74 = getelementptr inbounds %struct.NvmeCtrl, ptr %77, i32 0, i32 3
  %cap75 = getelementptr inbounds %struct.NvmeBar, ptr %bar74, i32 0, i32 0
  %78 = load i64, ptr %cap, align 8
  call void @stq_le_p(ptr noundef %cap75, i64 noundef %78)
  %79 = load ptr, ptr %n.addr, align 8
  %bar76 = getelementptr inbounds %struct.NvmeCtrl, ptr %79, i32 0, i32 3
  %vs = getelementptr inbounds %struct.NvmeBar, ptr %bar76, i32 0, i32 1
  call void @stl_le_p(ptr noundef %vs, i32 noundef 66560)
  %80 = load ptr, ptr %n.addr, align 8
  %bar77 = getelementptr inbounds %struct.NvmeCtrl, ptr %80, i32 0, i32 3
  %intms = getelementptr inbounds %struct.NvmeBar, ptr %bar77, i32 0, i32 2
  store i32 0, ptr %intms, align 4
  %81 = load ptr, ptr %n.addr, align 8
  %bar78 = getelementptr inbounds %struct.NvmeCtrl, ptr %81, i32 0, i32 3
  %intmc = getelementptr inbounds %struct.NvmeBar, ptr %bar78, i32 0, i32 3
  store i32 0, ptr %intmc, align 16
  %82 = load ptr, ptr %pci_dev.addr, align 8
  %call79 = call i32 @pci_is_vf(ptr noundef %82)
  %tobool80 = icmp ne i32 %call79, 0
  br i1 %tobool80, label %land.lhs.true, label %if.end84

land.lhs.true:                                    ; preds = %if.end54
  %83 = load ptr, ptr %sctrl, align 8
  %scs = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %83, i32 0, i32 2
  %84 = load i8, ptr %scs, align 1
  %tobool81 = icmp ne i8 %84, 0
  br i1 %tobool81, label %if.end84, label %if.then82

if.then82:                                        ; preds = %land.lhs.true
  %85 = load ptr, ptr %n.addr, align 8
  %bar83 = getelementptr inbounds %struct.NvmeCtrl, ptr %85, i32 0, i32 3
  %csts = getelementptr inbounds %struct.NvmeBar, ptr %bar83, i32 0, i32 6
  call void @stl_le_p(ptr noundef %csts, i32 noundef 2)
  br label %if.end84

if.end84:                                         ; preds = %if.then82, %land.lhs.true, %if.end54
  ret void
}

declare i32 @nvme_ns_setup(ptr noundef, ptr noundef) #1

declare void @warn_report(ptr noundef, ...) #1

declare zeroext i1 @host_memory_backend_is_mapped(ptr noundef) #1

declare ptr @object_get_canonical_path_component(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @is_power_of_2(i64 noundef %value) #0 {
entry:
  %retval = alloca i1, align 1
  %value.addr = alloca i64, align 8
  store i64 %value, ptr %value.addr, align 8
  %0 = load i64, ptr %value.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %value.addr, align 8
  %2 = load i64, ptr %value.addr, align 8
  %sub = sub i64 %2, 1
  %and = and i64 %1, %sub
  %tobool1 = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool1, true
  store i1 %lnot, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i1, ptr %retval, align 1
  ret i1 %3
}

declare void @host_memory_backend_set_mapped(ptr noundef, i1 noundef zeroext) #1

declare i32 @nvme_subsys_register_ctrl(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_sctrl(ptr noundef %n) #0 {
entry:
  %retval = alloca ptr, align 8
  %n.addr = alloca ptr, align 8
  %pci_dev = alloca ptr, align 8
  %pf = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %parent_obj = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 0
  store ptr %parent_obj, ptr %pci_dev, align 8
  %1 = load ptr, ptr %pci_dev, align 8
  %call = call ptr @pcie_sriov_get_pf(ptr noundef %1)
  %call1 = call ptr @object_dynamic_cast_assert(ptr noundef %call, ptr noundef @.str.49, ptr noundef @.str.39, i32 noundef 647, ptr noundef @__func__.nvme_sctrl)
  store ptr %call1, ptr %pf, align 8
  %2 = load ptr, ptr %pci_dev, align 8
  %call2 = call i32 @pci_is_vf(ptr noundef %2)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %pf, align 8
  %sec_ctrl_list = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 43
  %sec = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %sec_ctrl_list, i32 0, i32 2
  %4 = load ptr, ptr %pci_dev, align 8
  %call3 = call zeroext i16 @pcie_sriov_vf_number(ptr noundef %4)
  %idxprom = zext i16 %call3 to i64
  %arrayidx = getelementptr [127 x %struct.NvmeSecCtrlEntry], ptr %sec, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: allocsize(0,1)
declare noalias ptr @g_malloc0_n(i64 noundef, i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @qemu_clock_get_ms(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, ptr %type.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %call = call i64 @qemu_clock_get_ns(i32 noundef %0)
  %div = sdiv i64 %call, 1000000
  ret i64 %div
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @cpu_to_le16(i16 noundef zeroext %v) #0 {
entry:
  %v.addr = alloca i16, align 2
  store i16 %v, ptr %v.addr, align 2
  %0 = load i16, ptr %v.addr, align 2
  ret i16 %0
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @cpu_to_le32(i32 noundef %v) #0 {
entry:
  %v.addr = alloca i32, align 4
  store i32 %v, ptr %v.addr, align 4
  %0 = load i32, ptr %v.addr, align 4
  ret i32 %0
}

declare zeroext i16 @pcie_sriov_vf_number(ptr noundef) #1

declare i64 @qemu_clock_get_ns(i32 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_auto_cleanup_ErrorPropagator(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  call void @error_propagator_cleanup(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @pci_config_set_prog_interface(ptr noundef %pci_config, i8 noundef zeroext %val) #0 {
entry:
  %pci_config.addr = alloca ptr, align 8
  %val.addr = alloca i8, align 1
  store ptr %pci_config, ptr %pci_config.addr, align 8
  store i8 %val, ptr %val.addr, align 1
  %0 = load ptr, ptr %pci_config.addr, align 8
  %arrayidx = getelementptr i8, ptr %0, i64 9
  %1 = load i8, ptr %val.addr, align 1
  call void @pci_set_byte(ptr noundef %arrayidx, i8 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @pci_config_set_vendor_id(ptr noundef %pci_config, i16 noundef zeroext %val) #0 {
entry:
  %pci_config.addr = alloca ptr, align 8
  %val.addr = alloca i16, align 2
  store ptr %pci_config, ptr %pci_config.addr, align 8
  store i16 %val, ptr %val.addr, align 2
  %0 = load ptr, ptr %pci_config.addr, align 8
  %arrayidx = getelementptr i8, ptr %0, i64 0
  %1 = load i16, ptr %val.addr, align 2
  call void @pci_set_word(ptr noundef %arrayidx, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @pci_config_set_device_id(ptr noundef %pci_config, i16 noundef zeroext %val) #0 {
entry:
  %pci_config.addr = alloca ptr, align 8
  %val.addr = alloca i16, align 2
  store ptr %pci_config, ptr %pci_config.addr, align 8
  store i16 %val, ptr %val.addr, align 2
  %0 = load ptr, ptr %pci_config.addr, align 8
  %arrayidx = getelementptr i8, ptr %0, i64 2
  %1 = load i16, ptr %val.addr, align 2
  call void @pci_set_word(ptr noundef %arrayidx, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @pci_config_set_class(ptr noundef %pci_config, i16 noundef zeroext %val) #0 {
entry:
  %pci_config.addr = alloca ptr, align 8
  %val.addr = alloca i16, align 2
  store ptr %pci_config, ptr %pci_config.addr, align 8
  store i16 %val, ptr %val.addr, align 2
  %0 = load ptr, ptr %pci_config.addr, align 8
  %arrayidx = getelementptr i8, ptr %0, i64 10
  %1 = load i16, ptr %val.addr, align 2
  call void @pci_set_word(ptr noundef %arrayidx, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_add_pm_capability(ptr noundef %pci_dev, i8 noundef zeroext %offset) #0 {
entry:
  %retval = alloca i32, align 4
  %pci_dev.addr = alloca ptr, align 8
  %offset.addr = alloca i8, align 1
  %err = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %pci_dev, ptr %pci_dev.addr, align 8
  store i8 %offset, ptr %offset.addr, align 1
  store ptr null, ptr %err, align 8
  %0 = load ptr, ptr %pci_dev.addr, align 8
  %1 = load i8, ptr %offset.addr, align 1
  %call = call i32 @pci_add_capability(ptr noundef %0, i8 noundef zeroext 1, i8 noundef zeroext %1, i8 noundef zeroext 8, ptr noundef %err)
  store i32 %call, ptr %ret, align 4
  %2 = load ptr, ptr %err, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %err, align 8
  call void @error_report_err(ptr noundef %3)
  %4 = load i32, ptr %ret, align 4
  store i32 %4, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %pci_dev.addr, align 8
  %config = getelementptr inbounds %struct.PCIDevice, ptr %5, i32 0, i32 3
  %6 = load ptr, ptr %config, align 8
  %7 = load i8, ptr %offset.addr, align 1
  %conv = zext i8 %7 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr i8, ptr %6, i64 %idx.ext
  %add.ptr1 = getelementptr i8, ptr %add.ptr, i64 2
  call void @pci_set_word(ptr noundef %add.ptr1, i16 noundef zeroext 3)
  %8 = load ptr, ptr %pci_dev.addr, align 8
  %config2 = getelementptr inbounds %struct.PCIDevice, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %config2, align 8
  %10 = load i8, ptr %offset.addr, align 1
  %conv3 = zext i8 %10 to i32
  %idx.ext4 = sext i32 %conv3 to i64
  %add.ptr5 = getelementptr i8, ptr %9, i64 %idx.ext4
  %add.ptr6 = getelementptr i8, ptr %add.ptr5, i64 4
  call void @pci_set_word(ptr noundef %add.ptr6, i16 noundef zeroext 8)
  %11 = load ptr, ptr %pci_dev.addr, align 8
  %wmask = getelementptr inbounds %struct.PCIDevice, ptr %11, i32 0, i32 5
  %12 = load ptr, ptr %wmask, align 8
  %13 = load i8, ptr %offset.addr, align 1
  %conv7 = zext i8 %13 to i32
  %idx.ext8 = sext i32 %conv7 to i64
  %add.ptr9 = getelementptr i8, ptr %12, i64 %idx.ext8
  %add.ptr10 = getelementptr i8, ptr %add.ptr9, i64 4
  call void @pci_set_word(ptr noundef %add.ptr10, i16 noundef zeroext 3)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

declare i32 @pcie_endpoint_cap_init(ptr noundef, i8 noundef zeroext) #1

declare void @pcie_cap_flr_init(ptr noundef) #1

declare void @pcie_ari_init(ptr noundef, i16 noundef zeroext) #1

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @nvme_bar_size(i32 noundef %total_queues, i32 noundef %total_irqs, ptr noundef %msix_table_offset, ptr noundef %msix_pba_offset) #0 {
entry:
  %total_queues.addr = alloca i32, align 4
  %total_irqs.addr = alloca i32, align 4
  %msix_table_offset.addr = alloca ptr, align 8
  %msix_pba_offset.addr = alloca ptr, align 8
  %bar_size = alloca i64, align 8
  %msix_table_size = alloca i64, align 8
  %msix_pba_size = alloca i64, align 8
  store i32 %total_queues, ptr %total_queues.addr, align 4
  store i32 %total_irqs, ptr %total_irqs.addr, align 4
  store ptr %msix_table_offset, ptr %msix_table_offset.addr, align 8
  store ptr %msix_pba_offset, ptr %msix_pba_offset.addr, align 8
  %0 = load i32, ptr %total_queues.addr, align 4
  %mul = mul i32 2, %0
  %mul1 = mul i32 %mul, 4
  %conv = zext i32 %mul1 to i64
  %add = add i64 4096, %conv
  store i64 %add, ptr %bar_size, align 8
  %1 = load i64, ptr %bar_size, align 8
  %add2 = add i64 %1, 4096
  %sub = sub i64 %add2, 1
  %div = udiv i64 %sub, 4096
  %mul3 = mul i64 %div, 4096
  store i64 %mul3, ptr %bar_size, align 8
  %2 = load ptr, ptr %msix_table_offset.addr, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %bar_size, align 8
  %conv4 = trunc i64 %3 to i32
  %4 = load ptr, ptr %msix_table_offset.addr, align 8
  store i32 %conv4, ptr %4, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, ptr %total_irqs.addr, align 4
  %mul5 = mul i32 16, %5
  %conv6 = zext i32 %mul5 to i64
  store i64 %conv6, ptr %msix_table_size, align 8
  %6 = load i64, ptr %msix_table_size, align 8
  %7 = load i64, ptr %bar_size, align 8
  %add7 = add i64 %7, %6
  store i64 %add7, ptr %bar_size, align 8
  %8 = load i64, ptr %bar_size, align 8
  %add8 = add i64 %8, 4096
  %sub9 = sub i64 %add8, 1
  %div10 = udiv i64 %sub9, 4096
  %mul11 = mul i64 %div10, 4096
  store i64 %mul11, ptr %bar_size, align 8
  %9 = load ptr, ptr %msix_pba_offset.addr, align 8
  %tobool12 = icmp ne ptr %9, null
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end
  %10 = load i64, ptr %bar_size, align 8
  %conv14 = trunc i64 %10 to i32
  %11 = load ptr, ptr %msix_pba_offset.addr, align 8
  store i32 %conv14, ptr %11, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end
  %12 = load i32, ptr %total_irqs.addr, align 4
  %add16 = add i32 %12, 64
  %sub17 = sub i32 %add16, 1
  %div18 = udiv i32 %sub17, 64
  %mul19 = mul i32 %div18, 64
  %div20 = udiv i32 %mul19, 8
  %conv21 = zext i32 %div20 to i64
  store i64 %conv21, ptr %msix_pba_size, align 8
  %13 = load i64, ptr %msix_pba_size, align 8
  %14 = load i64, ptr %bar_size, align 8
  %add22 = add i64 %14, %13
  store i64 %add22, ptr %bar_size, align 8
  %15 = load i64, ptr %bar_size, align 8
  %call = call i64 @pow2ceil(i64 noundef %15)
  store i64 %call, ptr %bar_size, align 8
  %16 = load i64, ptr %bar_size, align 8
  ret i64 %16
}

declare void @memory_region_init(ptr noundef, ptr noundef, ptr noundef, i64 noundef) #1

declare void @memory_region_init_io(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, i64 noundef) #1

declare void @memory_region_add_subregion(ptr noundef, i64 noundef, ptr noundef) #1

declare void @pcie_sriov_vf_register_bar(ptr noundef, i32 noundef, ptr noundef) #1

declare void @pci_register_bar(ptr noundef, i32 noundef, i8 noundef zeroext, ptr noundef) #1

declare i32 @msix_init(ptr noundef, i16 noundef zeroext, ptr noundef, i8 noundef zeroext, i32 noundef, ptr noundef, i8 noundef zeroext, i32 noundef, i8 noundef zeroext, ptr noundef) #1

declare void @warn_report_err(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_update_msixcap_ts(ptr noundef %pci_dev, i32 noundef %table_size) #0 {
entry:
  %pci_dev.addr = alloca ptr, align 8
  %table_size.addr = alloca i32, align 4
  %config = alloca ptr, align 8
  store ptr %pci_dev, ptr %pci_dev.addr, align 8
  store i32 %table_size, ptr %table_size.addr, align 4
  %0 = load ptr, ptr %pci_dev.addr, align 8
  %call = call i32 @msix_present(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %table_size.addr, align 4
  %cmp = icmp ugt i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %2 = load i32, ptr %table_size.addr, align 4
  %3 = load ptr, ptr %pci_dev.addr, align 8
  %msix_entries_nr = getelementptr inbounds %struct.PCIDevice, ptr %3, i32 0, i32 22
  %4 = load i32, ptr %msix_entries_nr, align 4
  %cmp1 = icmp ule i32 %2, %4
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %land.lhs.true
  br label %if.end3

if.else:                                          ; preds = %land.lhs.true, %if.end
  call void @__assert_fail(ptr noundef @.str.479, ptr noundef @.str.1, i32 noundef 7048, ptr noundef @__PRETTY_FUNCTION__.nvme_update_msixcap_ts) #12
  unreachable

if.end3:                                          ; preds = %if.then2
  %5 = load ptr, ptr %pci_dev.addr, align 8
  %config4 = getelementptr inbounds %struct.PCIDevice, ptr %5, i32 0, i32 3
  %6 = load ptr, ptr %config4, align 8
  %7 = load ptr, ptr %pci_dev.addr, align 8
  %msix_cap = getelementptr inbounds %struct.PCIDevice, ptr %7, i32 0, i32 21
  %8 = load i8, ptr %msix_cap, align 16
  %conv = zext i8 %8 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr i8, ptr %6, i64 %idx.ext
  store ptr %add.ptr, ptr %config, align 8
  %9 = load ptr, ptr %config, align 8
  %add.ptr5 = getelementptr i8, ptr %9, i64 2
  %10 = load i32, ptr %table_size.addr, align 4
  %sub = sub i32 %10, 1
  %conv6 = trunc i32 %sub to i16
  call void @pci_set_word_by_mask(ptr noundef %add.ptr5, i16 noundef zeroext 2047, i16 noundef zeroext %conv6)
  br label %return

return:                                           ; preds = %if.end3, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_init_cmb(ptr noundef %n, ptr noundef %pci_dev) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %pci_dev.addr = alloca ptr, align 8
  %cmb_size = alloca i64, align 8
  %cap = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %pci_dev, ptr %pci_dev.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 4
  %cmb_size_mb = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 4
  %1 = load i32, ptr %cmb_size_mb, align 4
  %conv = zext i32 %1 to i64
  %mul = mul i64 %conv, 1048576
  store i64 %mul, ptr %cmb_size, align 8
  %2 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 3
  %cap1 = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 0
  %call = call i64 @ldq_le_p(ptr noundef %cap1)
  store i64 %call, ptr %cap, align 8
  %3 = load i64, ptr %cmb_size, align 8
  %call2 = call noalias ptr @g_malloc0(i64 noundef %3) #14
  %4 = load ptr, ptr %n.addr, align 8
  %cmb = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 25
  %buf = getelementptr inbounds %struct.anon.20, ptr %cmb, i32 0, i32 1
  store ptr %call2, ptr %buf, align 16
  %5 = load ptr, ptr %n.addr, align 8
  %cmb3 = getelementptr inbounds %struct.NvmeCtrl, ptr %5, i32 0, i32 25
  %mem = getelementptr inbounds %struct.anon.20, ptr %cmb3, i32 0, i32 0
  %6 = load ptr, ptr %n.addr, align 8
  %7 = load ptr, ptr %n.addr, align 8
  %8 = load i64, ptr %cmb_size, align 8
  call void @memory_region_init_io(ptr noundef %mem, ptr noundef %6, ptr noundef @nvme_cmb_ops, ptr noundef %7, ptr noundef @.str.482, i64 noundef %8)
  %9 = load ptr, ptr %pci_dev.addr, align 8
  %10 = load ptr, ptr %n.addr, align 8
  %cmb4 = getelementptr inbounds %struct.NvmeCtrl, ptr %10, i32 0, i32 25
  %mem5 = getelementptr inbounds %struct.anon.20, ptr %cmb4, i32 0, i32 0
  call void @pci_register_bar(ptr noundef %9, i32 noundef 2, i8 noundef zeroext 12, ptr noundef %mem5)
  %11 = load i64, ptr %cap, align 8
  %or = or i64 %11, 144115188075855872
  store i64 %or, ptr %cap, align 8
  %12 = load ptr, ptr %n.addr, align 8
  %bar6 = getelementptr inbounds %struct.NvmeCtrl, ptr %12, i32 0, i32 3
  %cap7 = getelementptr inbounds %struct.NvmeBar, ptr %bar6, i32 0, i32 0
  %13 = load i64, ptr %cap, align 8
  call void @stq_le_p(ptr noundef %cap7, i64 noundef %13)
  %14 = load ptr, ptr %n.addr, align 8
  %params8 = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 4
  %legacy_cmb = getelementptr inbounds %struct.NvmeParams, ptr %params8, i32 0, i32 12
  %15 = load i8, ptr %legacy_cmb, align 1
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %16 = load ptr, ptr %n.addr, align 8
  call void @nvme_cmb_enable_regs(ptr noundef %16)
  %17 = load ptr, ptr %n.addr, align 8
  %cmb9 = getelementptr inbounds %struct.NvmeCtrl, ptr %17, i32 0, i32 25
  %cmse = getelementptr inbounds %struct.anon.20, ptr %cmb9, i32 0, i32 2
  store i8 1, ptr %cmse, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_init_pmr(ptr noundef %n, ptr noundef %pci_dev) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %pci_dev.addr = alloca ptr, align 8
  %pmrcap = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %pci_dev, ptr %pci_dev.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 3
  %pmrcap1 = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 19
  %call = call i32 @ldl_le_p(ptr noundef %pmrcap1)
  store i32 %call, ptr %pmrcap, align 4
  %1 = load i32, ptr %pmrcap, align 4
  %conv = zext i32 %1 to i64
  %or = or i64 %conv, 8
  %conv2 = trunc i64 %or to i32
  store i32 %conv2, ptr %pmrcap, align 4
  %2 = load i32, ptr %pmrcap, align 4
  %conv3 = zext i32 %2 to i64
  %or4 = or i64 %conv3, 16
  %conv5 = trunc i64 %or4 to i32
  store i32 %conv5, ptr %pmrcap, align 4
  %3 = load i32, ptr %pmrcap, align 4
  %conv6 = zext i32 %3 to i64
  %or7 = or i64 %conv6, 128
  %conv8 = trunc i64 %or7 to i32
  store i32 %conv8, ptr %pmrcap, align 4
  %4 = load i32, ptr %pmrcap, align 4
  %conv9 = zext i32 %4 to i64
  %or10 = or i64 %conv9, 2048
  %conv11 = trunc i64 %or10 to i32
  store i32 %conv11, ptr %pmrcap, align 4
  %5 = load i32, ptr %pmrcap, align 4
  %conv12 = zext i32 %5 to i64
  %or13 = or i64 %conv12, 16777216
  %conv14 = trunc i64 %or13 to i32
  store i32 %conv14, ptr %pmrcap, align 4
  %6 = load ptr, ptr %n.addr, align 8
  %bar15 = getelementptr inbounds %struct.NvmeCtrl, ptr %6, i32 0, i32 3
  %pmrcap16 = getelementptr inbounds %struct.NvmeBar, ptr %bar15, i32 0, i32 19
  %7 = load i32, ptr %pmrcap, align 4
  call void @stl_le_p(ptr noundef %pmrcap16, i32 noundef %7)
  %8 = load ptr, ptr %pci_dev.addr, align 8
  %9 = load ptr, ptr %n.addr, align 8
  %pmr = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 26
  %dev = getelementptr inbounds %struct.anon.21, ptr %pmr, i32 0, i32 0
  %10 = load ptr, ptr %dev, align 16
  %mr = getelementptr inbounds %struct.HostMemoryBackend, ptr %10, i32 0, i32 13
  call void @pci_register_bar(ptr noundef %8, i32 noundef 4, i8 noundef zeroext 12, ptr noundef %mr)
  %11 = load ptr, ptr %n.addr, align 8
  %pmr17 = getelementptr inbounds %struct.NvmeCtrl, ptr %11, i32 0, i32 26
  %dev18 = getelementptr inbounds %struct.anon.21, ptr %pmr17, i32 0, i32 0
  %12 = load ptr, ptr %dev18, align 16
  %mr19 = getelementptr inbounds %struct.HostMemoryBackend, ptr %12, i32 0, i32 13
  call void @memory_region_set_enabled(ptr noundef %mr19, i1 noundef zeroext false)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_init_sriov(ptr noundef %n, ptr noundef %pci_dev, i16 noundef zeroext %offset) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %pci_dev.addr = alloca ptr, align 8
  %offset.addr = alloca i16, align 2
  %vf_dev_id = alloca i16, align 2
  %cap = alloca ptr, align 8
  %bar_size = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %pci_dev, ptr %pci_dev.addr, align 8
  store i16 %offset, ptr %offset.addr, align 2
  %0 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 4
  %use_intel_id = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 9
  %1 = load i8, ptr %use_intel_id, align 2
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i32 22597, i32 16
  %conv = trunc i32 %cond to i16
  store i16 %conv, ptr %vf_dev_id, align 2
  %2 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 42
  store ptr %pri_ctrl_cap, ptr %cap, align 8
  %3 = load ptr, ptr %cap, align 8
  %vqfrsm = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %3, i32 0, i32 8
  %4 = load i16, ptr %vqfrsm, align 1
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %4)
  %conv1 = zext i16 %call to i32
  %5 = load ptr, ptr %cap, align 8
  %vifrsm = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %5, i32 0, i32 15
  %6 = load i16, ptr %vifrsm, align 1
  %call2 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %6)
  %conv3 = zext i16 %call2 to i32
  %call4 = call i64 @nvme_bar_size(i32 noundef %conv1, i32 noundef %conv3, ptr noundef null, ptr noundef null)
  store i64 %call4, ptr %bar_size, align 8
  %7 = load ptr, ptr %pci_dev.addr, align 8
  %8 = load i16, ptr %offset.addr, align 2
  %9 = load i16, ptr %vf_dev_id, align 2
  %10 = load ptr, ptr %n.addr, align 8
  %params5 = getelementptr inbounds %struct.NvmeCtrl, ptr %10, i32 0, i32 4
  %sriov_max_vfs = getelementptr inbounds %struct.NvmeParams, ptr %params5, i32 0, i32 14
  %11 = load i8, ptr %sriov_max_vfs, align 1
  %conv6 = zext i8 %11 to i16
  %12 = load ptr, ptr %n.addr, align 8
  %params7 = getelementptr inbounds %struct.NvmeCtrl, ptr %12, i32 0, i32 4
  %sriov_max_vfs8 = getelementptr inbounds %struct.NvmeParams, ptr %params7, i32 0, i32 14
  %13 = load i8, ptr %sriov_max_vfs8, align 1
  %conv9 = zext i8 %13 to i16
  call void @pcie_sriov_pf_init(ptr noundef %7, i16 noundef zeroext %8, ptr noundef @.str.49, i16 noundef zeroext %9, i16 noundef zeroext %conv6, i16 noundef zeroext %conv9, i16 noundef zeroext 1, i16 noundef zeroext 1)
  %14 = load ptr, ptr %pci_dev.addr, align 8
  %15 = load i64, ptr %bar_size, align 8
  call void @pcie_sriov_pf_init_vf_bar(ptr noundef %14, i32 noundef 0, i8 noundef zeroext 4, i64 noundef %15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @error_propagator_cleanup(ptr noundef %prop) #0 {
entry:
  %prop.addr = alloca ptr, align 8
  store ptr %prop, ptr %prop.addr, align 8
  %0 = load ptr, ptr %prop.addr, align 8
  %errp = getelementptr inbounds %struct.ErrorPropagator, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %errp, align 8
  %2 = load ptr, ptr %prop.addr, align 8
  %local_err = getelementptr inbounds %struct.ErrorPropagator, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %1, ptr noundef %3)
  ret void
}

declare void @error_propagate(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @pci_set_byte(ptr noundef %config, i8 noundef zeroext %val) #0 {
entry:
  %config.addr = alloca ptr, align 8
  %val.addr = alloca i8, align 1
  store ptr %config, ptr %config.addr, align 8
  store i8 %val, ptr %val.addr, align 1
  %0 = load i8, ptr %val.addr, align 1
  %1 = load ptr, ptr %config.addr, align 8
  store i8 %0, ptr %1, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @pci_set_word(ptr noundef %config, i16 noundef zeroext %val) #0 {
entry:
  %config.addr = alloca ptr, align 8
  %val.addr = alloca i16, align 2
  store ptr %config, ptr %config.addr, align 8
  store i16 %val, ptr %val.addr, align 2
  %0 = load ptr, ptr %config.addr, align 8
  %1 = load i16, ptr %val.addr, align 2
  call void @stw_le_p(ptr noundef %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stw_le_p(ptr noundef %ptr, i16 noundef zeroext %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i16, align 2
  store ptr %ptr, ptr %ptr.addr, align 8
  store i16 %v, ptr %v.addr, align 2
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i16, ptr %v.addr, align 2
  call void @stw_he_p(ptr noundef %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stw_he_p(ptr noundef %ptr, i16 noundef zeroext %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i16, align 2
  store ptr %ptr, ptr %ptr.addr, align 8
  store i16 %v, ptr %v.addr, align 2
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %0, ptr align 2 %v.addr, i64 2, i1 false)
  ret void
}

declare i32 @pci_add_capability(ptr noundef, i8 noundef zeroext, i8 noundef zeroext, i8 noundef zeroext, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @pow2ceil(i64 noundef %value) #0 {
entry:
  %retval = alloca i64, align 8
  %value.addr = alloca i64, align 8
  %n = alloca i32, align 4
  store i64 %value, ptr %value.addr, align 8
  %0 = load i64, ptr %value.addr, align 8
  %sub = sub i64 %0, 1
  %call = call i32 @clz64(i64 noundef %sub)
  store i32 %call, ptr %n, align 4
  %1 = load i32, ptr %n, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %value.addr, align 8
  %tobool1 = icmp ne i64 %2, 0
  %lnot = xor i1 %tobool1, true
  %lnot.ext = zext i1 %lnot to i32
  %conv = sext i32 %lnot.ext to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %n, align 4
  %sub2 = sub i32 %3, 1
  %sh_prom = zext i32 %sub2 to i64
  %shr = lshr i64 -9223372036854775808, %sh_prom
  store i64 %shr, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i64, ptr %retval, align 8
  ret i64 %4
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @clz64(i64 noundef %val) #0 {
entry:
  %val.addr = alloca i64, align 8
  store i64 %val, ptr %val.addr, align 8
  %0 = load i64, ptr %val.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %val.addr, align 8
  %2 = call i64 @llvm.ctlz.i64(i64 %1, i1 true)
  %cast = trunc i64 %2 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %cast, %cond.true ], [ 64, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.ctlz.i64(i64, i1 immarg) #7

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @nvme_mmio_read(ptr noundef %opaque, i64 noundef %addr, i32 noundef %size) #0 {
entry:
  %retval = alloca i64, align 8
  %opaque.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  %n = alloca ptr, align 8
  %ptr = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %n, align 8
  %1 = load ptr, ptr %n, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 3
  store ptr %bar, ptr %ptr, align 8
  %2 = load i64, ptr %addr.addr, align 8
  %3 = load i32, ptr %size.addr, align 4
  call void @trace_pci_nvme_mmio_read(i64 noundef %2, i32 noundef %3)
  %4 = load i64, ptr %addr.addr, align 8
  %and = and i64 %4, 3
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %5 = load i64, ptr %addr.addr, align 8
  call void @trace_pci_nvme_ub_mmiord_misaligned32(i64 noundef %5)
  br label %do.body3

do.body3:                                         ; preds = %do.body
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot4 = xor i1 %call, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv8 = sext i32 %lnot.ext7 to i64
  %tobool9 = icmp ne i64 %conv8, 0
  br i1 %tobool9, label %if.then10, label %if.end

if.then10:                                        ; preds = %do.body3
  %6 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.91, ptr noundef @__func__.nvme_mmio_read, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then10, %do.body3
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.end11

do.end11:                                         ; preds = %do.end
  br label %if.end35

if.else:                                          ; preds = %entry
  %7 = load i32, ptr %size.addr, align 4
  %conv12 = zext i32 %7 to i64
  %cmp = icmp ult i64 %conv12, 4
  %lnot14 = xor i1 %cmp, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  %tobool19 = icmp ne i64 %conv18, 0
  br i1 %tobool19, label %if.then20, label %if.end34

if.then20:                                        ; preds = %if.else
  br label %do.body21

do.body21:                                        ; preds = %if.then20
  %8 = load i64, ptr %addr.addr, align 8
  call void @trace_pci_nvme_ub_mmiord_toosmall(i64 noundef %8)
  br label %do.body22

do.body22:                                        ; preds = %do.body21
  %call23 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot24 = xor i1 %call23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %tobool29 = icmp ne i64 %conv28, 0
  br i1 %tobool29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %do.body22
  %9 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.92, ptr noundef @__func__.nvme_mmio_read, i64 noundef %9)
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %do.body22
  br label %do.end32

do.end32:                                         ; preds = %if.end31
  br label %do.end33

do.end33:                                         ; preds = %do.end32
  br label %if.end34

if.end34:                                         ; preds = %do.end33, %if.else
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %do.end11
  %10 = load i64, ptr %addr.addr, align 8
  %11 = load i32, ptr %size.addr, align 4
  %conv36 = zext i32 %11 to i64
  %sub = sub i64 4096, %conv36
  %cmp37 = icmp ugt i64 %10, %sub
  br i1 %cmp37, label %if.then39, label %if.end53

if.then39:                                        ; preds = %if.end35
  br label %do.body40

do.body40:                                        ; preds = %if.then39
  %12 = load i64, ptr %addr.addr, align 8
  call void @trace_pci_nvme_ub_mmiord_invalid_ofs(i64 noundef %12)
  br label %do.body41

do.body41:                                        ; preds = %do.body40
  %call42 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot43 = xor i1 %call42, true
  %lnot45 = xor i1 %lnot43, true
  %lnot.ext46 = zext i1 %lnot45 to i32
  %conv47 = sext i32 %lnot.ext46 to i64
  %tobool48 = icmp ne i64 %conv47, 0
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %do.body41
  %13 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.93, ptr noundef @__func__.nvme_mmio_read, i64 noundef %13)
  br label %if.end50

if.end50:                                         ; preds = %if.then49, %do.body41
  br label %do.end51

do.end51:                                         ; preds = %if.end50
  br label %do.end52

do.end52:                                         ; preds = %do.end51
  store i64 0, ptr %retval, align 8
  br label %return

if.end53:                                         ; preds = %if.end35
  %14 = load ptr, ptr %n, align 8
  %call54 = call ptr @PCI_DEVICE(ptr noundef %14)
  %call55 = call i32 @pci_is_vf(ptr noundef %call54)
  %tobool56 = icmp ne i32 %call55, 0
  br i1 %tobool56, label %land.lhs.true, label %if.end63

land.lhs.true:                                    ; preds = %if.end53
  %15 = load ptr, ptr %n, align 8
  %call57 = call ptr @nvme_sctrl(ptr noundef %15)
  %scs = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %call57, i32 0, i32 2
  %16 = load i8, ptr %scs, align 1
  %tobool58 = icmp ne i8 %16, 0
  br i1 %tobool58, label %if.end63, label %land.lhs.true59

land.lhs.true59:                                  ; preds = %land.lhs.true
  %17 = load i64, ptr %addr.addr, align 8
  %cmp60 = icmp ne i64 %17, 28
  br i1 %cmp60, label %if.then62, label %if.end63

if.then62:                                        ; preds = %land.lhs.true59
  %18 = load i64, ptr %addr.addr, align 8
  %19 = load i32, ptr %size.addr, align 4
  call void @trace_pci_nvme_err_ignored_mmio_vf_offline(i64 noundef %18, i32 noundef %19)
  store i64 0, ptr %retval, align 8
  br label %return

if.end63:                                         ; preds = %land.lhs.true59, %land.lhs.true, %if.end53
  %20 = load i64, ptr %addr.addr, align 8
  %cmp64 = icmp eq i64 %20, 3592
  br i1 %cmp64, label %land.lhs.true66, label %if.end76

land.lhs.true66:                                  ; preds = %if.end63
  %21 = load ptr, ptr %n, align 8
  %bar67 = getelementptr inbounds %struct.NvmeCtrl, ptr %21, i32 0, i32 3
  %pmrcap = getelementptr inbounds %struct.NvmeBar, ptr %bar67, i32 0, i32 19
  %call68 = call i32 @ldl_le_p(ptr noundef %pmrcap)
  %shr = ashr i32 %call68, 10
  %and69 = and i32 %shr, 15
  %and70 = and i32 %and69, 2
  %tobool71 = icmp ne i32 %and70, 0
  br i1 %tobool71, label %if.then72, label %if.end76

if.then72:                                        ; preds = %land.lhs.true66
  %22 = load ptr, ptr %n, align 8
  %pmr = getelementptr inbounds %struct.NvmeCtrl, ptr %22, i32 0, i32 26
  %dev = getelementptr inbounds %struct.anon.21, ptr %pmr, i32 0, i32 0
  %23 = load ptr, ptr %dev, align 16
  %mr = getelementptr inbounds %struct.HostMemoryBackend, ptr %23, i32 0, i32 13
  %24 = load ptr, ptr %n, align 8
  %pmr73 = getelementptr inbounds %struct.NvmeCtrl, ptr %24, i32 0, i32 26
  %dev74 = getelementptr inbounds %struct.anon.21, ptr %pmr73, i32 0, i32 0
  %25 = load ptr, ptr %dev74, align 16
  %size75 = getelementptr inbounds %struct.HostMemoryBackend, ptr %25, i32 0, i32 1
  %26 = load i64, ptr %size75, align 8
  call void @memory_region_msync(ptr noundef %mr, i64 noundef 0, i64 noundef %26)
  br label %if.end76

if.end76:                                         ; preds = %if.then72, %land.lhs.true66, %if.end63
  %27 = load ptr, ptr %ptr, align 8
  %28 = load i64, ptr %addr.addr, align 8
  %add.ptr = getelementptr i8, ptr %27, i64 %28
  %29 = load i32, ptr %size.addr, align 4
  %call77 = call i64 @ldn_le_p(ptr noundef %add.ptr, i32 noundef %29)
  store i64 %call77, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end76, %if.then62, %do.end52
  %30 = load i64, ptr %retval, align 8
  ret i64 %30
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_mmio_write(ptr noundef %opaque, i64 noundef %addr, i64 noundef %data, i32 noundef %size) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %data.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  %n = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %data, ptr %data.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %n, align 8
  %1 = load i64, ptr %addr.addr, align 8
  %2 = load i64, ptr %data.addr, align 8
  %3 = load i32, ptr %size.addr, align 4
  call void @trace_pci_nvme_mmio_write(i64 noundef %1, i64 noundef %2, i32 noundef %3)
  %4 = load ptr, ptr %n, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %4)
  %call1 = call i32 @pci_is_vf(ptr noundef %call)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load ptr, ptr %n, align 8
  %call2 = call ptr @nvme_sctrl(ptr noundef %5)
  %scs = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %call2, i32 0, i32 2
  %6 = load i8, ptr %scs, align 1
  %tobool3 = icmp ne i8 %6, 0
  br i1 %tobool3, label %if.end, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %7 = load i64, ptr %addr.addr, align 8
  %cmp = icmp ne i64 %7, 28
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4
  %8 = load i64, ptr %addr.addr, align 8
  %9 = load i32, ptr %size.addr, align 4
  call void @trace_pci_nvme_err_ignored_mmio_vf_offline(i64 noundef %8, i32 noundef %9)
  br label %if.end7

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true, %entry
  %10 = load i64, ptr %addr.addr, align 8
  %cmp5 = icmp ult i64 %10, 4096
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %11 = load ptr, ptr %n, align 8
  %12 = load i64, ptr %addr.addr, align 8
  %13 = load i64, ptr %data.addr, align 8
  %14 = load i32, ptr %size.addr, align 4
  call void @nvme_write_bar(ptr noundef %11, i64 noundef %12, i64 noundef %13, i32 noundef %14)
  br label %if.end7

if.else:                                          ; preds = %if.end
  %15 = load ptr, ptr %n, align 8
  %16 = load i64, ptr %addr.addr, align 8
  %17 = load i64, ptr %data.addr, align 8
  %conv = trunc i64 %17 to i32
  call void @nvme_process_db(ptr noundef %15, i64 noundef %16, i32 noundef %conv)
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then6, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_read(i64 noundef %addr, i32 noundef %size) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i64, ptr %addr.addr, align 8
  %1 = load i32, ptr %size.addr, align 4
  call void @_nocheck__trace_pci_nvme_mmio_read(i64 noundef %0, i32 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiord_misaligned32(i64 noundef %offset) #0 {
entry:
  %offset.addr = alloca i64, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  call void @_nocheck__trace_pci_nvme_ub_mmiord_misaligned32(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiord_toosmall(i64 noundef %offset) #0 {
entry:
  %offset.addr = alloca i64, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  call void @_nocheck__trace_pci_nvme_ub_mmiord_toosmall(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiord_invalid_ofs(i64 noundef %offset) #0 {
entry:
  %offset.addr = alloca i64, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  call void @_nocheck__trace_pci_nvme_ub_mmiord_invalid_ofs(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_ignored_mmio_vf_offline(i64 noundef %addr, i32 noundef %size) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i64, ptr %addr.addr, align 8
  %1 = load i32, ptr %size.addr, align 4
  call void @_nocheck__trace_pci_nvme_err_ignored_mmio_vf_offline(i64 noundef %0, i32 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ldl_le_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %call = call i32 @ldl_he_p(ptr noundef %0)
  ret i32 %call
}

declare void @memory_region_msync(ptr noundef, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @ldn_le_p(ptr noundef %ptr, i32 noundef %sz) #0 {
entry:
  %retval = alloca i64, align 8
  %ptr.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %0 = load i32, ptr %sz.addr, align 4
  switch i32 %0, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb1
    i32 4, label %sw.bb4
    i32 8, label %sw.bb7
  ]

sw.bb:                                            ; preds = %entry
  %1 = load ptr, ptr %ptr.addr, align 8
  %call = call i32 @ldub_p(ptr noundef %1)
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %retval, align 8
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %2 = load ptr, ptr %ptr.addr, align 8
  %call2 = call i32 @lduw_le_p(ptr noundef %2)
  %conv3 = sext i32 %call2 to i64
  store i64 %conv3, ptr %retval, align 8
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %3 = load ptr, ptr %ptr.addr, align 8
  %call5 = call i32 @ldl_le_p(ptr noundef %3)
  %conv6 = zext i32 %call5 to i64
  store i64 %conv6, ptr %retval, align 8
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  %4 = load ptr, ptr %ptr.addr, align 8
  %call8 = call i64 @ldq_le_p(ptr noundef %4)
  store i64 %call8, ptr %retval, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.104, i32 noundef 419, ptr noundef @__func__.ldn_le_p, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb7, %sw.bb4, %sw.bb1, %sw.bb
  %5 = load i64, ptr %retval, align 8
  ret i64 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_read(i64 noundef %addr, i32 noundef %size) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_READ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  %6 = load i32, ptr %size.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.94, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %addr.addr, align 8
  %8 = load i32, ptr %size.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.95, i64 noundef %7, i32 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiord_misaligned32(i64 noundef %offset) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %offset.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.96, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %offset.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.97, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiord_toosmall(i64 noundef %offset) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIORD_TOOSMALL_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %offset.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.98, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %offset.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.99, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiord_invalid_ofs(i64 noundef %offset) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %offset.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.100, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %offset.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.101, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_ignored_mmio_vf_offline(i64 noundef %addr, i32 noundef %size) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_IGNORED_MMIO_VF_OFFLINE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  %6 = load i32, ptr %size.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.102, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %addr.addr, align 8
  %8 = load i32, ptr %size.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.103, i64 noundef %7, i32 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ldl_he_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %r = alloca i32, align 4
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %r, ptr align 1 %0, i64 4, i1 false)
  %1 = load i32, ptr %r, align 4
  ret i32 %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ldub_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i8, ptr %0, align 1
  %conv = zext i8 %1 to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @lduw_le_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %call = call i32 @lduw_he_p(ptr noundef %0)
  %conv = trunc i32 %call to i16
  %conv1 = zext i16 %conv to i32
  ret i32 %conv1
}

; Function Attrs: noreturn
declare void @g_assertion_message_expr(ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) #8

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @lduw_he_p(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %r = alloca i16, align 2
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %r, ptr align 1 %0, i64 2, i1 false)
  %1 = load i16, ptr %r, align 2
  %conv = zext i16 %1 to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_write(i64 noundef %addr, i64 noundef %data, i32 noundef %size) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %data.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %data, ptr %data.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i64, ptr %addr.addr, align 8
  %1 = load i64, ptr %data.addr, align 8
  %2 = load i32, ptr %size.addr, align 4
  call void @_nocheck__trace_pci_nvme_mmio_write(i64 noundef %0, i64 noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_write_bar(ptr noundef %n, i64 noundef %offset, i64 noundef %data, i32 noundef %size) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %data.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  %pci = alloca ptr, align 8
  %cap = alloca i64, align 8
  %cc = alloca i32, align 4
  %intms = alloca i32, align 4
  %csts = alloca i32, align 4
  %pmrsts = alloca i32, align 4
  %cmbmsc282 = alloca i64, align 8
  %cba = alloca i64, align 8
  %coerce = alloca i128, align 16
  %cmbsts = alloca i32, align 4
  %pmrmscu = alloca i64, align 8
  %cba415 = alloca i64, align 8
  %coerce425 = alloca i128, align 16
  store ptr %n, ptr %n.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %data, ptr %data.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %0)
  store ptr %call, ptr %pci, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 3
  %cap1 = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 0
  %call2 = call i64 @ldq_le_p(ptr noundef %cap1)
  store i64 %call2, ptr %cap, align 8
  %2 = load ptr, ptr %n.addr, align 8
  %bar3 = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 3
  %cc4 = getelementptr inbounds %struct.NvmeBar, ptr %bar3, i32 0, i32 4
  %call5 = call i32 @ldl_le_p(ptr noundef %cc4)
  store i32 %call5, ptr %cc, align 4
  %3 = load ptr, ptr %n.addr, align 8
  %bar6 = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 3
  %intms7 = getelementptr inbounds %struct.NvmeBar, ptr %bar6, i32 0, i32 2
  %call8 = call i32 @ldl_le_p(ptr noundef %intms7)
  store i32 %call8, ptr %intms, align 4
  %4 = load ptr, ptr %n.addr, align 8
  %bar9 = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 3
  %csts10 = getelementptr inbounds %struct.NvmeBar, ptr %bar9, i32 0, i32 6
  %call11 = call i32 @ldl_le_p(ptr noundef %csts10)
  store i32 %call11, ptr %csts, align 4
  %5 = load ptr, ptr %n.addr, align 8
  %bar12 = getelementptr inbounds %struct.NvmeCtrl, ptr %5, i32 0, i32 3
  %pmrsts13 = getelementptr inbounds %struct.NvmeBar, ptr %bar12, i32 0, i32 21
  %call14 = call i32 @ldl_le_p(ptr noundef %pmrsts13)
  store i32 %call14, ptr %pmrsts, align 4
  %6 = load i64, ptr %offset.addr, align 8
  %and = and i64 %6, 3
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot15 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot15 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool16 = icmp ne i64 %conv, 0
  br i1 %tobool16, label %if.then, label %if.end27

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %7 = load i64, ptr %offset.addr, align 8
  call void @trace_pci_nvme_ub_mmiowr_misaligned32(i64 noundef %7)
  br label %do.body17

do.body17:                                        ; preds = %do.body
  %call18 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot19 = xor i1 %call18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %tobool24 = icmp ne i64 %conv23, 0
  br i1 %tobool24, label %if.then25, label %if.end

if.then25:                                        ; preds = %do.body17
  %8 = load i64, ptr %offset.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.107, ptr noundef @__func__.nvme_write_bar, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then25, %do.body17
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.end26

do.end26:                                         ; preds = %do.end
  br label %if.end27

if.end27:                                         ; preds = %do.end26, %entry
  %9 = load i32, ptr %size.addr, align 4
  %conv28 = zext i32 %9 to i64
  %cmp = icmp ult i64 %conv28, 4
  %lnot30 = xor i1 %cmp, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %tobool35 = icmp ne i64 %conv34, 0
  br i1 %tobool35, label %if.then36, label %if.end50

if.then36:                                        ; preds = %if.end27
  br label %do.body37

do.body37:                                        ; preds = %if.then36
  %10 = load i64, ptr %offset.addr, align 8
  %11 = load i32, ptr %size.addr, align 4
  call void @trace_pci_nvme_ub_mmiowr_toosmall(i64 noundef %10, i32 noundef %11)
  br label %do.body38

do.body38:                                        ; preds = %do.body37
  %call39 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot40 = xor i1 %call39, true
  %lnot42 = xor i1 %lnot40, true
  %lnot.ext43 = zext i1 %lnot42 to i32
  %conv44 = sext i32 %lnot.ext43 to i64
  %tobool45 = icmp ne i64 %conv44, 0
  br i1 %tobool45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %do.body38
  %12 = load i64, ptr %offset.addr, align 8
  %13 = load i32, ptr %size.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.108, ptr noundef @__func__.nvme_write_bar, i64 noundef %12, i32 noundef %13)
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %do.body38
  br label %do.end48

do.end48:                                         ; preds = %if.end47
  br label %do.end49

do.end49:                                         ; preds = %do.end48
  br label %if.end50

if.end50:                                         ; preds = %do.end49, %if.end27
  %14 = load i64, ptr %offset.addr, align 8
  switch i64 %14, label %sw.default [
    i64 12, label %sw.bb
    i64 16, label %sw.bb83
    i64 20, label %sw.bb118
    i64 28, label %sw.bb174
    i64 32, label %sw.bb210
    i64 36, label %sw.bb216
    i64 40, label %sw.bb220
    i64 44, label %sw.bb222
    i64 48, label %sw.bb229
    i64 52, label %sw.bb231
    i64 56, label %sw.bb239
    i64 60, label %sw.bb253
    i64 80, label %sw.bb267
    i64 84, label %sw.bb312
    i64 3584, label %sw.bb317
    i64 3588, label %sw.bb331
    i64 3592, label %sw.bb355
    i64 3596, label %sw.bb369
    i64 3600, label %sw.bb383
    i64 3604, label %sw.bb397
    i64 3608, label %sw.bb442
  ]

sw.bb:                                            ; preds = %if.end50
  %15 = load ptr, ptr %pci, align 8
  %call51 = call i32 @msix_enabled(ptr noundef %15)
  %tobool52 = icmp ne i32 %call51, 0
  %lnot53 = xor i1 %tobool52, true
  %lnot55 = xor i1 %lnot53, true
  %lnot.ext56 = zext i1 %lnot55 to i32
  %conv57 = sext i32 %lnot.ext56 to i64
  %tobool58 = icmp ne i64 %conv57, 0
  br i1 %tobool58, label %if.then59, label %if.end73

if.then59:                                        ; preds = %sw.bb
  br label %do.body60

do.body60:                                        ; preds = %if.then59
  call void @trace_pci_nvme_ub_mmiowr_intmask_with_msix()
  br label %do.body61

do.body61:                                        ; preds = %do.body60
  %call62 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot63 = xor i1 %call62, true
  %lnot65 = xor i1 %lnot63, true
  %lnot.ext66 = zext i1 %lnot65 to i32
  %conv67 = sext i32 %lnot.ext66 to i64
  %tobool68 = icmp ne i64 %conv67, 0
  br i1 %tobool68, label %if.then69, label %if.end70

if.then69:                                        ; preds = %do.body61
  call void (ptr, ...) @qemu_log(ptr noundef @.str.109, ptr noundef @__func__.nvme_write_bar)
  br label %if.end70

if.end70:                                         ; preds = %if.then69, %do.body61
  br label %do.end71

do.end71:                                         ; preds = %if.end70
  br label %do.end72

do.end72:                                         ; preds = %do.end71
  br label %if.end73

if.end73:                                         ; preds = %do.end72, %sw.bb
  %16 = load i64, ptr %data.addr, align 8
  %17 = load i32, ptr %intms, align 4
  %conv74 = zext i32 %17 to i64
  %or = or i64 %conv74, %16
  %conv75 = trunc i64 %or to i32
  store i32 %conv75, ptr %intms, align 4
  %18 = load ptr, ptr %n.addr, align 8
  %bar76 = getelementptr inbounds %struct.NvmeCtrl, ptr %18, i32 0, i32 3
  %intms77 = getelementptr inbounds %struct.NvmeBar, ptr %bar76, i32 0, i32 2
  %19 = load i32, ptr %intms, align 4
  call void @stl_le_p(ptr noundef %intms77, i32 noundef %19)
  %20 = load ptr, ptr %n.addr, align 8
  %bar78 = getelementptr inbounds %struct.NvmeCtrl, ptr %20, i32 0, i32 3
  %intms79 = getelementptr inbounds %struct.NvmeBar, ptr %bar78, i32 0, i32 2
  %21 = load i32, ptr %intms79, align 4
  %22 = load ptr, ptr %n.addr, align 8
  %bar80 = getelementptr inbounds %struct.NvmeCtrl, ptr %22, i32 0, i32 3
  %intmc = getelementptr inbounds %struct.NvmeBar, ptr %bar80, i32 0, i32 3
  store i32 %21, ptr %intmc, align 16
  %23 = load i64, ptr %data.addr, align 8
  %and81 = and i64 %23, 4294967295
  %24 = load i32, ptr %intms, align 4
  %conv82 = zext i32 %24 to i64
  call void @trace_pci_nvme_mmio_intm_set(i64 noundef %and81, i64 noundef %conv82)
  %25 = load ptr, ptr %n.addr, align 8
  call void @nvme_irq_check(ptr noundef %25)
  br label %sw.epilog

sw.bb83:                                          ; preds = %if.end50
  %26 = load ptr, ptr %pci, align 8
  %call84 = call i32 @msix_enabled(ptr noundef %26)
  %tobool85 = icmp ne i32 %call84, 0
  %lnot86 = xor i1 %tobool85, true
  %lnot88 = xor i1 %lnot86, true
  %lnot.ext89 = zext i1 %lnot88 to i32
  %conv90 = sext i32 %lnot.ext89 to i64
  %tobool91 = icmp ne i64 %conv90, 0
  br i1 %tobool91, label %if.then92, label %if.end106

if.then92:                                        ; preds = %sw.bb83
  br label %do.body93

do.body93:                                        ; preds = %if.then92
  call void @trace_pci_nvme_ub_mmiowr_intmask_with_msix()
  br label %do.body94

do.body94:                                        ; preds = %do.body93
  %call95 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot96 = xor i1 %call95, true
  %lnot98 = xor i1 %lnot96, true
  %lnot.ext99 = zext i1 %lnot98 to i32
  %conv100 = sext i32 %lnot.ext99 to i64
  %tobool101 = icmp ne i64 %conv100, 0
  br i1 %tobool101, label %if.then102, label %if.end103

if.then102:                                       ; preds = %do.body94
  call void (ptr, ...) @qemu_log(ptr noundef @.str.110, ptr noundef @__func__.nvme_write_bar)
  br label %if.end103

if.end103:                                        ; preds = %if.then102, %do.body94
  br label %do.end104

do.end104:                                        ; preds = %if.end103
  br label %do.end105

do.end105:                                        ; preds = %do.end104
  br label %if.end106

if.end106:                                        ; preds = %do.end105, %sw.bb83
  %27 = load i64, ptr %data.addr, align 8
  %not = xor i64 %27, -1
  %28 = load i32, ptr %intms, align 4
  %conv107 = zext i32 %28 to i64
  %and108 = and i64 %conv107, %not
  %conv109 = trunc i64 %and108 to i32
  store i32 %conv109, ptr %intms, align 4
  %29 = load ptr, ptr %n.addr, align 8
  %bar110 = getelementptr inbounds %struct.NvmeCtrl, ptr %29, i32 0, i32 3
  %intms111 = getelementptr inbounds %struct.NvmeBar, ptr %bar110, i32 0, i32 2
  %30 = load i32, ptr %intms, align 4
  call void @stl_le_p(ptr noundef %intms111, i32 noundef %30)
  %31 = load ptr, ptr %n.addr, align 8
  %bar112 = getelementptr inbounds %struct.NvmeCtrl, ptr %31, i32 0, i32 3
  %intms113 = getelementptr inbounds %struct.NvmeBar, ptr %bar112, i32 0, i32 2
  %32 = load i32, ptr %intms113, align 4
  %33 = load ptr, ptr %n.addr, align 8
  %bar114 = getelementptr inbounds %struct.NvmeCtrl, ptr %33, i32 0, i32 3
  %intmc115 = getelementptr inbounds %struct.NvmeBar, ptr %bar114, i32 0, i32 3
  store i32 %32, ptr %intmc115, align 16
  %34 = load i64, ptr %data.addr, align 8
  %and116 = and i64 %34, 4294967295
  %35 = load i32, ptr %intms, align 4
  %conv117 = zext i32 %35 to i64
  call void @trace_pci_nvme_mmio_intm_clr(i64 noundef %and116, i64 noundef %conv117)
  %36 = load ptr, ptr %n.addr, align 8
  call void @nvme_irq_check(ptr noundef %36)
  br label %sw.epilog

sw.bb118:                                         ; preds = %if.end50
  %37 = load ptr, ptr %n.addr, align 8
  %bar119 = getelementptr inbounds %struct.NvmeCtrl, ptr %37, i32 0, i32 3
  %cc120 = getelementptr inbounds %struct.NvmeBar, ptr %bar119, i32 0, i32 4
  %38 = load i64, ptr %data.addr, align 8
  %conv121 = trunc i64 %38 to i32
  call void @stl_le_p(ptr noundef %cc120, i32 noundef %conv121)
  %39 = load i64, ptr %data.addr, align 8
  %and122 = and i64 %39, 4294967295
  call void @trace_pci_nvme_mmio_cfg(i64 noundef %and122)
  %40 = load i64, ptr %data.addr, align 8
  %shr = lshr i64 %40, 14
  %and123 = and i64 %shr, 3
  %tobool124 = icmp ne i64 %and123, 0
  br i1 %tobool124, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %sw.bb118
  %41 = load i32, ptr %cc, align 4
  %shr125 = lshr i32 %41, 14
  %and126 = and i32 %shr125, 3
  %tobool127 = icmp ne i32 %and126, 0
  br i1 %tobool127, label %if.else, label %if.then128

if.then128:                                       ; preds = %land.lhs.true
  call void @trace_pci_nvme_mmio_shutdown_set()
  %42 = load ptr, ptr %n.addr, align 8
  call void @nvme_ctrl_shutdown(ptr noundef %42)
  %43 = load i32, ptr %csts, align 4
  %and129 = and i32 %43, -13
  store i32 %and129, ptr %csts, align 4
  %44 = load i32, ptr %csts, align 4
  %or130 = or i32 %44, 8
  store i32 %or130, ptr %csts, align 4
  br label %if.end141

if.else:                                          ; preds = %land.lhs.true, %sw.bb118
  %45 = load i64, ptr %data.addr, align 8
  %shr131 = lshr i64 %45, 14
  %and132 = and i64 %shr131, 3
  %tobool133 = icmp ne i64 %and132, 0
  br i1 %tobool133, label %if.end140, label %land.lhs.true134

land.lhs.true134:                                 ; preds = %if.else
  %46 = load i32, ptr %cc, align 4
  %shr135 = lshr i32 %46, 14
  %and136 = and i32 %shr135, 3
  %tobool137 = icmp ne i32 %and136, 0
  br i1 %tobool137, label %if.then138, label %if.end140

if.then138:                                       ; preds = %land.lhs.true134
  call void @trace_pci_nvme_mmio_shutdown_cleared()
  %47 = load i32, ptr %csts, align 4
  %and139 = and i32 %47, -13
  store i32 %and139, ptr %csts, align 4
  br label %if.end140

if.end140:                                        ; preds = %if.then138, %land.lhs.true134, %if.else
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.then128
  %48 = load i64, ptr %data.addr, align 8
  %shr142 = lshr i64 %48, 0
  %and143 = and i64 %shr142, 1
  %tobool144 = icmp ne i64 %and143, 0
  br i1 %tobool144, label %land.lhs.true145, label %if.else161

land.lhs.true145:                                 ; preds = %if.end141
  %49 = load i32, ptr %cc, align 4
  %shr146 = lshr i32 %49, 0
  %and147 = and i32 %shr146, 1
  %tobool148 = icmp ne i32 %and147, 0
  br i1 %tobool148, label %if.else161, label %if.then149

if.then149:                                       ; preds = %land.lhs.true145
  %50 = load ptr, ptr %n.addr, align 8
  %call150 = call i32 @nvme_start_ctrl(ptr noundef %50)
  %tobool151 = icmp ne i32 %call150, 0
  %lnot152 = xor i1 %tobool151, true
  %lnot154 = xor i1 %lnot152, true
  %lnot.ext155 = zext i1 %lnot154 to i32
  %conv156 = sext i32 %lnot.ext155 to i64
  %tobool157 = icmp ne i64 %conv156, 0
  br i1 %tobool157, label %if.then158, label %if.else159

if.then158:                                       ; preds = %if.then149
  call void @trace_pci_nvme_err_startfail()
  store i32 2, ptr %csts, align 4
  br label %if.end160

if.else159:                                       ; preds = %if.then149
  call void @trace_pci_nvme_mmio_start_success()
  store i32 1, ptr %csts, align 4
  br label %if.end160

if.end160:                                        ; preds = %if.else159, %if.then158
  br label %if.end171

if.else161:                                       ; preds = %land.lhs.true145, %if.end141
  %51 = load i64, ptr %data.addr, align 8
  %shr162 = lshr i64 %51, 0
  %and163 = and i64 %shr162, 1
  %tobool164 = icmp ne i64 %and163, 0
  br i1 %tobool164, label %if.end170, label %land.lhs.true165

land.lhs.true165:                                 ; preds = %if.else161
  %52 = load i32, ptr %cc, align 4
  %shr166 = lshr i32 %52, 0
  %and167 = and i32 %shr166, 1
  %tobool168 = icmp ne i32 %and167, 0
  br i1 %tobool168, label %if.then169, label %if.end170

if.then169:                                       ; preds = %land.lhs.true165
  call void @trace_pci_nvme_mmio_stopped()
  %53 = load ptr, ptr %n.addr, align 8
  call void @nvme_ctrl_reset(ptr noundef %53, i32 noundef 1)
  br label %sw.epilog

if.end170:                                        ; preds = %land.lhs.true165, %if.else161
  br label %if.end171

if.end171:                                        ; preds = %if.end170, %if.end160
  %54 = load ptr, ptr %n.addr, align 8
  %bar172 = getelementptr inbounds %struct.NvmeCtrl, ptr %54, i32 0, i32 3
  %csts173 = getelementptr inbounds %struct.NvmeBar, ptr %bar172, i32 0, i32 6
  %55 = load i32, ptr %csts, align 4
  call void @stl_le_p(ptr noundef %csts173, i32 noundef %55)
  br label %sw.epilog

sw.bb174:                                         ; preds = %if.end50
  %56 = load i64, ptr %data.addr, align 8
  %and175 = and i64 %56, 16
  %tobool176 = icmp ne i64 %and175, 0
  br i1 %tobool176, label %if.then177, label %if.else191

if.then177:                                       ; preds = %sw.bb174
  br label %do.body178

do.body178:                                       ; preds = %if.then177
  call void @trace_pci_nvme_ub_mmiowr_ssreset_w1c_unsupported()
  br label %do.body179

do.body179:                                       ; preds = %do.body178
  %call180 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot181 = xor i1 %call180, true
  %lnot183 = xor i1 %lnot181, true
  %lnot.ext184 = zext i1 %lnot183 to i32
  %conv185 = sext i32 %lnot.ext184 to i64
  %tobool186 = icmp ne i64 %conv185, 0
  br i1 %tobool186, label %if.then187, label %if.end188

if.then187:                                       ; preds = %do.body179
  call void (ptr, ...) @qemu_log(ptr noundef @.str.111, ptr noundef @__func__.nvme_write_bar)
  br label %if.end188

if.end188:                                        ; preds = %if.then187, %do.body179
  br label %do.end189

do.end189:                                        ; preds = %if.end188
  br label %do.end190

do.end190:                                        ; preds = %do.end189
  br label %if.end209

if.else191:                                       ; preds = %sw.bb174
  %57 = load i64, ptr %data.addr, align 8
  %cmp192 = icmp ne i64 %57, 0
  br i1 %cmp192, label %if.then194, label %if.end208

if.then194:                                       ; preds = %if.else191
  br label %do.body195

do.body195:                                       ; preds = %if.then194
  call void @trace_pci_nvme_ub_mmiowr_ro_csts()
  br label %do.body196

do.body196:                                       ; preds = %do.body195
  %call197 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot198 = xor i1 %call197, true
  %lnot200 = xor i1 %lnot198, true
  %lnot.ext201 = zext i1 %lnot200 to i32
  %conv202 = sext i32 %lnot.ext201 to i64
  %tobool203 = icmp ne i64 %conv202, 0
  br i1 %tobool203, label %if.then204, label %if.end205

if.then204:                                       ; preds = %do.body196
  call void (ptr, ...) @qemu_log(ptr noundef @.str.112, ptr noundef @__func__.nvme_write_bar)
  br label %if.end205

if.end205:                                        ; preds = %if.then204, %do.body196
  br label %do.end206

do.end206:                                        ; preds = %if.end205
  br label %do.end207

do.end207:                                        ; preds = %do.end206
  br label %if.end208

if.end208:                                        ; preds = %do.end207, %if.else191
  br label %if.end209

if.end209:                                        ; preds = %if.end208, %do.end190
  br label %sw.epilog

sw.bb210:                                         ; preds = %if.end50
  %58 = load i64, ptr %data.addr, align 8
  %cmp211 = icmp eq i64 %58, 1314278757
  br i1 %cmp211, label %if.then213, label %if.else214

if.then213:                                       ; preds = %sw.bb210
  call void @trace_pci_nvme_ub_mmiowr_ssreset_unsupported()
  br label %if.end215

if.else214:                                       ; preds = %sw.bb210
  br label %sw.epilog

if.end215:                                        ; preds = %if.then213
  br label %sw.epilog

sw.bb216:                                         ; preds = %if.end50
  %59 = load ptr, ptr %n.addr, align 8
  %bar217 = getelementptr inbounds %struct.NvmeCtrl, ptr %59, i32 0, i32 3
  %aqa = getelementptr inbounds %struct.NvmeBar, ptr %bar217, i32 0, i32 8
  %60 = load i64, ptr %data.addr, align 8
  %conv218 = trunc i64 %60 to i32
  call void @stl_le_p(ptr noundef %aqa, i32 noundef %conv218)
  %61 = load i64, ptr %data.addr, align 8
  %and219 = and i64 %61, 4294967295
  call void @trace_pci_nvme_mmio_aqattr(i64 noundef %and219)
  br label %sw.epilog

sw.bb220:                                         ; preds = %if.end50
  %62 = load ptr, ptr %n.addr, align 8
  %bar221 = getelementptr inbounds %struct.NvmeCtrl, ptr %62, i32 0, i32 3
  %asq = getelementptr inbounds %struct.NvmeBar, ptr %bar221, i32 0, i32 9
  %63 = load i32, ptr %size.addr, align 4
  %64 = load i64, ptr %data.addr, align 8
  call void @stn_le_p(ptr noundef %asq, i32 noundef %63, i64 noundef %64)
  %65 = load i64, ptr %data.addr, align 8
  call void @trace_pci_nvme_mmio_asqaddr(i64 noundef %65)
  br label %sw.epilog

sw.bb222:                                         ; preds = %if.end50
  %66 = load ptr, ptr %n.addr, align 8
  %bar223 = getelementptr inbounds %struct.NvmeCtrl, ptr %66, i32 0, i32 3
  %asq224 = getelementptr inbounds %struct.NvmeBar, ptr %bar223, i32 0, i32 9
  %add.ptr = getelementptr i8, ptr %asq224, i64 4
  %67 = load i64, ptr %data.addr, align 8
  %conv225 = trunc i64 %67 to i32
  call void @stl_le_p(ptr noundef %add.ptr, i32 noundef %conv225)
  %68 = load i64, ptr %data.addr, align 8
  %69 = load ptr, ptr %n.addr, align 8
  %bar226 = getelementptr inbounds %struct.NvmeCtrl, ptr %69, i32 0, i32 3
  %asq227 = getelementptr inbounds %struct.NvmeBar, ptr %bar226, i32 0, i32 9
  %call228 = call i64 @ldq_le_p(ptr noundef %asq227)
  call void @trace_pci_nvme_mmio_asqaddr_hi(i64 noundef %68, i64 noundef %call228)
  br label %sw.epilog

sw.bb229:                                         ; preds = %if.end50
  %70 = load i64, ptr %data.addr, align 8
  call void @trace_pci_nvme_mmio_acqaddr(i64 noundef %70)
  %71 = load ptr, ptr %n.addr, align 8
  %bar230 = getelementptr inbounds %struct.NvmeCtrl, ptr %71, i32 0, i32 3
  %acq = getelementptr inbounds %struct.NvmeBar, ptr %bar230, i32 0, i32 10
  %72 = load i32, ptr %size.addr, align 4
  %73 = load i64, ptr %data.addr, align 8
  call void @stn_le_p(ptr noundef %acq, i32 noundef %72, i64 noundef %73)
  br label %sw.epilog

sw.bb231:                                         ; preds = %if.end50
  %74 = load ptr, ptr %n.addr, align 8
  %bar232 = getelementptr inbounds %struct.NvmeCtrl, ptr %74, i32 0, i32 3
  %acq233 = getelementptr inbounds %struct.NvmeBar, ptr %bar232, i32 0, i32 10
  %add.ptr234 = getelementptr i8, ptr %acq233, i64 4
  %75 = load i64, ptr %data.addr, align 8
  %conv235 = trunc i64 %75 to i32
  call void @stl_le_p(ptr noundef %add.ptr234, i32 noundef %conv235)
  %76 = load i64, ptr %data.addr, align 8
  %77 = load ptr, ptr %n.addr, align 8
  %bar236 = getelementptr inbounds %struct.NvmeCtrl, ptr %77, i32 0, i32 3
  %acq237 = getelementptr inbounds %struct.NvmeBar, ptr %bar236, i32 0, i32 10
  %call238 = call i64 @ldq_le_p(ptr noundef %acq237)
  call void @trace_pci_nvme_mmio_acqaddr_hi(i64 noundef %76, i64 noundef %call238)
  br label %sw.epilog

sw.bb239:                                         ; preds = %if.end50
  br label %do.body240

do.body240:                                       ; preds = %sw.bb239
  call void @trace_pci_nvme_ub_mmiowr_cmbloc_reserved()
  br label %do.body241

do.body241:                                       ; preds = %do.body240
  %call242 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot243 = xor i1 %call242, true
  %lnot245 = xor i1 %lnot243, true
  %lnot.ext246 = zext i1 %lnot245 to i32
  %conv247 = sext i32 %lnot.ext246 to i64
  %tobool248 = icmp ne i64 %conv247, 0
  br i1 %tobool248, label %if.then249, label %if.end250

if.then249:                                       ; preds = %do.body241
  call void (ptr, ...) @qemu_log(ptr noundef @.str.113, ptr noundef @__func__.nvme_write_bar)
  br label %if.end250

if.end250:                                        ; preds = %if.then249, %do.body241
  br label %do.end251

do.end251:                                        ; preds = %if.end250
  br label %do.end252

do.end252:                                        ; preds = %do.end251
  br label %sw.epilog

sw.bb253:                                         ; preds = %if.end50
  br label %do.body254

do.body254:                                       ; preds = %sw.bb253
  call void @trace_pci_nvme_ub_mmiowr_cmbsz_readonly()
  br label %do.body255

do.body255:                                       ; preds = %do.body254
  %call256 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot257 = xor i1 %call256, true
  %lnot259 = xor i1 %lnot257, true
  %lnot.ext260 = zext i1 %lnot259 to i32
  %conv261 = sext i32 %lnot.ext260 to i64
  %tobool262 = icmp ne i64 %conv261, 0
  br i1 %tobool262, label %if.then263, label %if.end264

if.then263:                                       ; preds = %do.body255
  call void (ptr, ...) @qemu_log(ptr noundef @.str.114, ptr noundef @__func__.nvme_write_bar)
  br label %if.end264

if.end264:                                        ; preds = %if.then263, %do.body255
  br label %do.end265

do.end265:                                        ; preds = %if.end264
  br label %do.end266

do.end266:                                        ; preds = %do.end265
  br label %sw.epilog

sw.bb267:                                         ; preds = %if.end50
  %78 = load i64, ptr %cap, align 8
  %shr268 = lshr i64 %78, 57
  %and269 = and i64 %shr268, 1
  %tobool270 = icmp ne i64 %and269, 0
  br i1 %tobool270, label %if.end272, label %if.then271

if.then271:                                       ; preds = %sw.bb267
  br label %sw.epilog

if.end272:                                        ; preds = %sw.bb267
  %79 = load ptr, ptr %n.addr, align 8
  %bar273 = getelementptr inbounds %struct.NvmeCtrl, ptr %79, i32 0, i32 3
  %cmbmsc = getelementptr inbounds %struct.NvmeBar, ptr %bar273, i32 0, i32 16
  %80 = load i32, ptr %size.addr, align 4
  %81 = load i64, ptr %data.addr, align 8
  call void @stn_le_p(ptr noundef %cmbmsc, i32 noundef %80, i64 noundef %81)
  %82 = load ptr, ptr %n.addr, align 8
  %cmb = getelementptr inbounds %struct.NvmeCtrl, ptr %82, i32 0, i32 25
  %cmse = getelementptr inbounds %struct.anon.20, ptr %cmb, i32 0, i32 2
  store i8 0, ptr %cmse, align 8
  %83 = load i64, ptr %data.addr, align 8
  %shr274 = lshr i64 %83, 0
  %and275 = and i64 %shr274, 1
  %tobool276 = icmp ne i64 %and275, 0
  br i1 %tobool276, label %if.then277, label %if.else308

if.then277:                                       ; preds = %if.end272
  %84 = load ptr, ptr %n.addr, align 8
  call void @nvme_cmb_enable_regs(ptr noundef %84)
  %85 = load i64, ptr %data.addr, align 8
  %shr278 = lshr i64 %85, 1
  %and279 = and i64 %shr278, 1
  %tobool280 = icmp ne i64 %and279, 0
  br i1 %tobool280, label %if.then281, label %if.end307

if.then281:                                       ; preds = %if.then277
  %86 = load ptr, ptr %n.addr, align 8
  %bar283 = getelementptr inbounds %struct.NvmeCtrl, ptr %86, i32 0, i32 3
  %cmbmsc284 = getelementptr inbounds %struct.NvmeBar, ptr %bar283, i32 0, i32 16
  %call285 = call i64 @ldq_le_p(ptr noundef %cmbmsc284)
  store i64 %call285, ptr %cmbmsc282, align 8
  %87 = load i64, ptr %cmbmsc282, align 8
  %shr286 = lshr i64 %87, 12
  %and287 = and i64 %shr286, 4503599627370495
  %shl = shl i64 %and287, 12
  store i64 %shl, ptr %cba, align 8
  %88 = load i64, ptr %cba, align 8
  %89 = load ptr, ptr %n.addr, align 8
  %cmb288 = getelementptr inbounds %struct.NvmeCtrl, ptr %89, i32 0, i32 25
  %mem = getelementptr inbounds %struct.anon.20, ptr %cmb288, i32 0, i32 0
  %size289 = getelementptr inbounds %struct.MemoryRegion, ptr %mem, i32 0, i32 18
  %90 = load i128, ptr %size289, align 16
  store i128 %90, ptr %coerce, align 16
  %91 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 0
  %92 = load i64, ptr %91, align 16
  %93 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 1
  %94 = load i64, ptr %93, align 8
  %call290 = call i64 @int128_get64(i64 noundef %92, i64 noundef %94)
  %add = add i64 %88, %call290
  %95 = load i64, ptr %cba, align 8
  %cmp291 = icmp ult i64 %add, %95
  br i1 %cmp291, label %if.then293, label %if.end302

if.then293:                                       ; preds = %if.then281
  %96 = load ptr, ptr %n.addr, align 8
  %bar294 = getelementptr inbounds %struct.NvmeCtrl, ptr %96, i32 0, i32 3
  %cmbsts295 = getelementptr inbounds %struct.NvmeBar, ptr %bar294, i32 0, i32 17
  %call296 = call i32 @ldl_le_p(ptr noundef %cmbsts295)
  store i32 %call296, ptr %cmbsts, align 4
  %97 = load i32, ptr %cmbsts, align 4
  %conv297 = zext i32 %97 to i64
  %or298 = or i64 %conv297, 1
  %conv299 = trunc i64 %or298 to i32
  store i32 %conv299, ptr %cmbsts, align 4
  %98 = load ptr, ptr %n.addr, align 8
  %bar300 = getelementptr inbounds %struct.NvmeCtrl, ptr %98, i32 0, i32 3
  %cmbsts301 = getelementptr inbounds %struct.NvmeBar, ptr %bar300, i32 0, i32 17
  %99 = load i32, ptr %cmbsts, align 4
  call void @stl_le_p(ptr noundef %cmbsts301, i32 noundef %99)
  br label %sw.epilog

if.end302:                                        ; preds = %if.then281
  %100 = load i64, ptr %cba, align 8
  %101 = load ptr, ptr %n.addr, align 8
  %cmb303 = getelementptr inbounds %struct.NvmeCtrl, ptr %101, i32 0, i32 25
  %cba304 = getelementptr inbounds %struct.anon.20, ptr %cmb303, i32 0, i32 3
  store i64 %100, ptr %cba304, align 16
  %102 = load ptr, ptr %n.addr, align 8
  %cmb305 = getelementptr inbounds %struct.NvmeCtrl, ptr %102, i32 0, i32 25
  %cmse306 = getelementptr inbounds %struct.anon.20, ptr %cmb305, i32 0, i32 2
  store i8 1, ptr %cmse306, align 8
  br label %if.end307

if.end307:                                        ; preds = %if.end302, %if.then277
  br label %if.end311

if.else308:                                       ; preds = %if.end272
  %103 = load ptr, ptr %n.addr, align 8
  %bar309 = getelementptr inbounds %struct.NvmeCtrl, ptr %103, i32 0, i32 3
  %cmbsz = getelementptr inbounds %struct.NvmeBar, ptr %bar309, i32 0, i32 12
  store i32 0, ptr %cmbsz, align 4
  %104 = load ptr, ptr %n.addr, align 8
  %bar310 = getelementptr inbounds %struct.NvmeCtrl, ptr %104, i32 0, i32 3
  %cmbloc = getelementptr inbounds %struct.NvmeBar, ptr %bar310, i32 0, i32 11
  store i32 0, ptr %cmbloc, align 8
  br label %if.end311

if.end311:                                        ; preds = %if.else308, %if.end307
  br label %sw.epilog

sw.bb312:                                         ; preds = %if.end50
  %105 = load ptr, ptr %n.addr, align 8
  %bar313 = getelementptr inbounds %struct.NvmeCtrl, ptr %105, i32 0, i32 3
  %cmbmsc314 = getelementptr inbounds %struct.NvmeBar, ptr %bar313, i32 0, i32 16
  %add.ptr315 = getelementptr i8, ptr %cmbmsc314, i64 4
  %106 = load i64, ptr %data.addr, align 8
  %conv316 = trunc i64 %106 to i32
  call void @stl_le_p(ptr noundef %add.ptr315, i32 noundef %conv316)
  br label %sw.epilog

sw.bb317:                                         ; preds = %if.end50
  br label %do.body318

do.body318:                                       ; preds = %sw.bb317
  call void @trace_pci_nvme_ub_mmiowr_pmrcap_readonly()
  br label %do.body319

do.body319:                                       ; preds = %do.body318
  %call320 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot321 = xor i1 %call320, true
  %lnot323 = xor i1 %lnot321, true
  %lnot.ext324 = zext i1 %lnot323 to i32
  %conv325 = sext i32 %lnot.ext324 to i64
  %tobool326 = icmp ne i64 %conv325, 0
  br i1 %tobool326, label %if.then327, label %if.end328

if.then327:                                       ; preds = %do.body319
  call void (ptr, ...) @qemu_log(ptr noundef @.str.115, ptr noundef @__func__.nvme_write_bar)
  br label %if.end328

if.end328:                                        ; preds = %if.then327, %do.body319
  br label %do.end329

do.end329:                                        ; preds = %if.end328
  br label %do.end330

do.end330:                                        ; preds = %do.end329
  br label %sw.epilog

sw.bb331:                                         ; preds = %if.end50
  %107 = load i64, ptr %cap, align 8
  %shr332 = lshr i64 %107, 56
  %and333 = and i64 %shr332, 1
  %tobool334 = icmp ne i64 %and333, 0
  br i1 %tobool334, label %if.end336, label %if.then335

if.then335:                                       ; preds = %sw.bb331
  br label %sw.epilog

if.end336:                                        ; preds = %sw.bb331
  %108 = load ptr, ptr %n.addr, align 8
  %bar337 = getelementptr inbounds %struct.NvmeCtrl, ptr %108, i32 0, i32 3
  %pmrctl = getelementptr inbounds %struct.NvmeBar, ptr %bar337, i32 0, i32 20
  %109 = load i64, ptr %data.addr, align 8
  %conv338 = trunc i64 %109 to i32
  call void @stl_le_p(ptr noundef %pmrctl, i32 noundef %conv338)
  %110 = load i64, ptr %data.addr, align 8
  %shr339 = lshr i64 %110, 0
  %and340 = and i64 %shr339, 1
  %tobool341 = icmp ne i64 %and340, 0
  br i1 %tobool341, label %if.then342, label %if.else343

if.then342:                                       ; preds = %if.end336
  %111 = load ptr, ptr %n.addr, align 8
  %pmr = getelementptr inbounds %struct.NvmeCtrl, ptr %111, i32 0, i32 26
  %dev = getelementptr inbounds %struct.anon.21, ptr %pmr, i32 0, i32 0
  %112 = load ptr, ptr %dev, align 16
  %mr = getelementptr inbounds %struct.HostMemoryBackend, ptr %112, i32 0, i32 13
  call void @memory_region_set_enabled(ptr noundef %mr, i1 noundef zeroext true)
  store i32 0, ptr %pmrsts, align 4
  br label %if.end352

if.else343:                                       ; preds = %if.end336
  %113 = load ptr, ptr %n.addr, align 8
  %pmr344 = getelementptr inbounds %struct.NvmeCtrl, ptr %113, i32 0, i32 26
  %dev345 = getelementptr inbounds %struct.anon.21, ptr %pmr344, i32 0, i32 0
  %114 = load ptr, ptr %dev345, align 16
  %mr346 = getelementptr inbounds %struct.HostMemoryBackend, ptr %114, i32 0, i32 13
  call void @memory_region_set_enabled(ptr noundef %mr346, i1 noundef zeroext false)
  %115 = load i32, ptr %pmrsts, align 4
  %conv347 = zext i32 %115 to i64
  %or348 = or i64 %conv347, 256
  %conv349 = trunc i64 %or348 to i32
  store i32 %conv349, ptr %pmrsts, align 4
  %116 = load ptr, ptr %n.addr, align 8
  %pmr350 = getelementptr inbounds %struct.NvmeCtrl, ptr %116, i32 0, i32 26
  %cmse351 = getelementptr inbounds %struct.anon.21, ptr %pmr350, i32 0, i32 1
  store i8 0, ptr %cmse351, align 8
  br label %if.end352

if.end352:                                        ; preds = %if.else343, %if.then342
  %117 = load ptr, ptr %n.addr, align 8
  %bar353 = getelementptr inbounds %struct.NvmeCtrl, ptr %117, i32 0, i32 3
  %pmrsts354 = getelementptr inbounds %struct.NvmeBar, ptr %bar353, i32 0, i32 21
  %118 = load i32, ptr %pmrsts, align 4
  call void @stl_le_p(ptr noundef %pmrsts354, i32 noundef %118)
  br label %sw.epilog

sw.bb355:                                         ; preds = %if.end50
  br label %do.body356

do.body356:                                       ; preds = %sw.bb355
  call void @trace_pci_nvme_ub_mmiowr_pmrsts_readonly()
  br label %do.body357

do.body357:                                       ; preds = %do.body356
  %call358 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot359 = xor i1 %call358, true
  %lnot361 = xor i1 %lnot359, true
  %lnot.ext362 = zext i1 %lnot361 to i32
  %conv363 = sext i32 %lnot.ext362 to i64
  %tobool364 = icmp ne i64 %conv363, 0
  br i1 %tobool364, label %if.then365, label %if.end366

if.then365:                                       ; preds = %do.body357
  call void (ptr, ...) @qemu_log(ptr noundef @.str.116, ptr noundef @__func__.nvme_write_bar)
  br label %if.end366

if.end366:                                        ; preds = %if.then365, %do.body357
  br label %do.end367

do.end367:                                        ; preds = %if.end366
  br label %do.end368

do.end368:                                        ; preds = %do.end367
  br label %sw.epilog

sw.bb369:                                         ; preds = %if.end50
  br label %do.body370

do.body370:                                       ; preds = %sw.bb369
  call void @trace_pci_nvme_ub_mmiowr_pmrebs_readonly()
  br label %do.body371

do.body371:                                       ; preds = %do.body370
  %call372 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot373 = xor i1 %call372, true
  %lnot375 = xor i1 %lnot373, true
  %lnot.ext376 = zext i1 %lnot375 to i32
  %conv377 = sext i32 %lnot.ext376 to i64
  %tobool378 = icmp ne i64 %conv377, 0
  br i1 %tobool378, label %if.then379, label %if.end380

if.then379:                                       ; preds = %do.body371
  call void (ptr, ...) @qemu_log(ptr noundef @.str.117, ptr noundef @__func__.nvme_write_bar)
  br label %if.end380

if.end380:                                        ; preds = %if.then379, %do.body371
  br label %do.end381

do.end381:                                        ; preds = %if.end380
  br label %do.end382

do.end382:                                        ; preds = %do.end381
  br label %sw.epilog

sw.bb383:                                         ; preds = %if.end50
  br label %do.body384

do.body384:                                       ; preds = %sw.bb383
  call void @trace_pci_nvme_ub_mmiowr_pmrswtp_readonly()
  br label %do.body385

do.body385:                                       ; preds = %do.body384
  %call386 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot387 = xor i1 %call386, true
  %lnot389 = xor i1 %lnot387, true
  %lnot.ext390 = zext i1 %lnot389 to i32
  %conv391 = sext i32 %lnot.ext390 to i64
  %tobool392 = icmp ne i64 %conv391, 0
  br i1 %tobool392, label %if.then393, label %if.end394

if.then393:                                       ; preds = %do.body385
  call void (ptr, ...) @qemu_log(ptr noundef @.str.118, ptr noundef @__func__.nvme_write_bar)
  br label %if.end394

if.end394:                                        ; preds = %if.then393, %do.body385
  br label %do.end395

do.end395:                                        ; preds = %if.end394
  br label %do.end396

do.end396:                                        ; preds = %do.end395
  br label %sw.epilog

sw.bb397:                                         ; preds = %if.end50
  %119 = load i64, ptr %cap, align 8
  %shr398 = lshr i64 %119, 56
  %and399 = and i64 %shr398, 1
  %tobool400 = icmp ne i64 %and399, 0
  br i1 %tobool400, label %if.end402, label %if.then401

if.then401:                                       ; preds = %sw.bb397
  br label %sw.epilog

if.end402:                                        ; preds = %sw.bb397
  %120 = load ptr, ptr %n.addr, align 8
  %bar403 = getelementptr inbounds %struct.NvmeCtrl, ptr %120, i32 0, i32 3
  %pmrmscl = getelementptr inbounds %struct.NvmeBar, ptr %bar403, i32 0, i32 24
  %121 = load i64, ptr %data.addr, align 8
  %conv404 = trunc i64 %121 to i32
  call void @stl_le_p(ptr noundef %pmrmscl, i32 noundef %conv404)
  %122 = load ptr, ptr %n.addr, align 8
  %pmr405 = getelementptr inbounds %struct.NvmeCtrl, ptr %122, i32 0, i32 26
  %cmse406 = getelementptr inbounds %struct.anon.21, ptr %pmr405, i32 0, i32 1
  store i8 0, ptr %cmse406, align 8
  %123 = load i64, ptr %data.addr, align 8
  %shr407 = lshr i64 %123, 1
  %and408 = and i64 %shr407, 1
  %tobool409 = icmp ne i64 %and408, 0
  br i1 %tobool409, label %if.then410, label %if.end441

if.then410:                                       ; preds = %if.end402
  %124 = load ptr, ptr %n.addr, align 8
  %bar411 = getelementptr inbounds %struct.NvmeCtrl, ptr %124, i32 0, i32 3
  %pmrmscu412 = getelementptr inbounds %struct.NvmeBar, ptr %bar411, i32 0, i32 25
  %call413 = call i32 @ldl_le_p(ptr noundef %pmrmscu412)
  %conv414 = sext i32 %call413 to i64
  store i64 %conv414, ptr %pmrmscu, align 8
  %125 = load i64, ptr %pmrmscu, align 8
  %shl416 = shl i64 %125, 32
  %126 = load i64, ptr %data.addr, align 8
  %shr417 = lshr i64 %126, 12
  %and418 = and i64 %shr417, 1048575
  %shl419 = shl i64 %and418, 12
  %or420 = or i64 %shl416, %shl419
  store i64 %or420, ptr %cba415, align 8
  %127 = load i64, ptr %cba415, align 8
  %128 = load ptr, ptr %n.addr, align 8
  %pmr421 = getelementptr inbounds %struct.NvmeCtrl, ptr %128, i32 0, i32 26
  %dev422 = getelementptr inbounds %struct.anon.21, ptr %pmr421, i32 0, i32 0
  %129 = load ptr, ptr %dev422, align 16
  %mr423 = getelementptr inbounds %struct.HostMemoryBackend, ptr %129, i32 0, i32 13
  %size424 = getelementptr inbounds %struct.MemoryRegion, ptr %mr423, i32 0, i32 18
  %130 = load i128, ptr %size424, align 16
  store i128 %130, ptr %coerce425, align 16
  %131 = getelementptr inbounds { i64, i64 }, ptr %coerce425, i32 0, i32 0
  %132 = load i64, ptr %131, align 16
  %133 = getelementptr inbounds { i64, i64 }, ptr %coerce425, i32 0, i32 1
  %134 = load i64, ptr %133, align 8
  %call426 = call i64 @int128_get64(i64 noundef %132, i64 noundef %134)
  %add427 = add i64 %127, %call426
  %135 = load i64, ptr %cba415, align 8
  %cmp428 = icmp ult i64 %add427, %135
  br i1 %cmp428, label %if.then430, label %if.end436

if.then430:                                       ; preds = %if.then410
  %136 = load i32, ptr %pmrsts, align 4
  %conv431 = zext i32 %136 to i64
  %or432 = or i64 %conv431, 4096
  %conv433 = trunc i64 %or432 to i32
  store i32 %conv433, ptr %pmrsts, align 4
  %137 = load ptr, ptr %n.addr, align 8
  %bar434 = getelementptr inbounds %struct.NvmeCtrl, ptr %137, i32 0, i32 3
  %pmrsts435 = getelementptr inbounds %struct.NvmeBar, ptr %bar434, i32 0, i32 21
  %138 = load i32, ptr %pmrsts, align 4
  call void @stl_le_p(ptr noundef %pmrsts435, i32 noundef %138)
  br label %sw.epilog

if.end436:                                        ; preds = %if.then410
  %139 = load ptr, ptr %n.addr, align 8
  %pmr437 = getelementptr inbounds %struct.NvmeCtrl, ptr %139, i32 0, i32 26
  %cmse438 = getelementptr inbounds %struct.anon.21, ptr %pmr437, i32 0, i32 1
  store i8 1, ptr %cmse438, align 8
  %140 = load i64, ptr %cba415, align 8
  %141 = load ptr, ptr %n.addr, align 8
  %pmr439 = getelementptr inbounds %struct.NvmeCtrl, ptr %141, i32 0, i32 26
  %cba440 = getelementptr inbounds %struct.anon.21, ptr %pmr439, i32 0, i32 2
  store i64 %140, ptr %cba440, align 16
  br label %if.end441

if.end441:                                        ; preds = %if.end436, %if.end402
  br label %sw.epilog

sw.bb442:                                         ; preds = %if.end50
  %142 = load i64, ptr %cap, align 8
  %shr443 = lshr i64 %142, 56
  %and444 = and i64 %shr443, 1
  %tobool445 = icmp ne i64 %and444, 0
  br i1 %tobool445, label %if.end447, label %if.then446

if.then446:                                       ; preds = %sw.bb442
  br label %sw.epilog

if.end447:                                        ; preds = %sw.bb442
  %143 = load ptr, ptr %n.addr, align 8
  %bar448 = getelementptr inbounds %struct.NvmeCtrl, ptr %143, i32 0, i32 3
  %pmrmscu449 = getelementptr inbounds %struct.NvmeBar, ptr %bar448, i32 0, i32 25
  %144 = load i64, ptr %data.addr, align 8
  %conv450 = trunc i64 %144 to i32
  call void @stl_le_p(ptr noundef %pmrmscu449, i32 noundef %conv450)
  br label %sw.epilog

sw.default:                                       ; preds = %if.end50
  br label %do.body451

do.body451:                                       ; preds = %sw.default
  %145 = load i64, ptr %offset.addr, align 8
  %146 = load i64, ptr %data.addr, align 8
  call void @trace_pci_nvme_ub_mmiowr_invalid(i64 noundef %145, i64 noundef %146)
  br label %do.body452

do.body452:                                       ; preds = %do.body451
  %call453 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot454 = xor i1 %call453, true
  %lnot456 = xor i1 %lnot454, true
  %lnot.ext457 = zext i1 %lnot456 to i32
  %conv458 = sext i32 %lnot.ext457 to i64
  %tobool459 = icmp ne i64 %conv458, 0
  br i1 %tobool459, label %if.then460, label %if.end461

if.then460:                                       ; preds = %do.body452
  %147 = load i64, ptr %offset.addr, align 8
  %148 = load i64, ptr %data.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.119, ptr noundef @__func__.nvme_write_bar, i64 noundef %147, i64 noundef %148)
  br label %if.end461

if.end461:                                        ; preds = %if.then460, %do.body452
  br label %do.end462

do.end462:                                        ; preds = %if.end461
  br label %do.end463

do.end463:                                        ; preds = %do.end462
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end463, %if.end447, %if.then446, %if.end441, %if.then430, %if.then401, %do.end396, %do.end382, %do.end368, %if.end352, %if.then335, %do.end330, %sw.bb312, %if.end311, %if.then293, %if.then271, %do.end266, %do.end252, %sw.bb231, %sw.bb229, %sw.bb222, %sw.bb220, %sw.bb216, %if.end215, %if.else214, %if.end209, %if.end171, %if.then169, %if.end106, %if.end73
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_process_db(ptr noundef %n, i64 noundef %addr, i32 noundef %val) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %val.addr = alloca i32, align 4
  %pci = alloca ptr, align 8
  %qid = alloca i32, align 4
  %new_head = alloca i16, align 2
  %start_sqs = alloca i32, align 4
  %cq = alloca ptr, align 8
  %.compoundliteral = alloca %struct.MemTxAttrs, align 4
  %sq = alloca ptr, align 8
  %new_tail = alloca i16, align 2
  %sq132 = alloca ptr, align 8
  %.compoundliteral207 = alloca %struct.MemTxAttrs, align 4
  store ptr %n, ptr %n.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %val, ptr %val.addr, align 4
  %0 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %0)
  store ptr %call, ptr %pci, align 8
  %1 = load i64, ptr %addr.addr, align 8
  %and = and i64 %1, 3
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load i64, ptr %addr.addr, align 8
  call void @trace_pci_nvme_ub_db_wr_misaligned(i64 noundef %2)
  br label %do.body3

do.body3:                                         ; preds = %do.body
  %call4 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot5 = xor i1 %call4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %tobool10 = icmp ne i64 %conv9, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %do.body3
  %3 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.460, ptr noundef @__func__.nvme_process_db, i64 noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then11, %do.body3
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.end12

do.end12:                                         ; preds = %do.end
  br label %if.end242

if.end13:                                         ; preds = %entry
  %4 = load i64, ptr %addr.addr, align 8
  %sub = sub i64 %4, 4096
  %shr = lshr i64 %sub, 2
  %and14 = and i64 %shr, 1
  %tobool15 = icmp ne i64 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end13
  %5 = load i32, ptr %val.addr, align 4
  %and17 = and i32 %5, 65535
  %conv18 = trunc i32 %and17 to i16
  store i16 %conv18, ptr %new_head, align 2
  %6 = load i64, ptr %addr.addr, align 8
  %sub19 = sub i64 %6, 4100
  %shr20 = lshr i64 %sub19, 3
  %conv21 = trunc i64 %shr20 to i32
  store i32 %conv21, ptr %qid, align 4
  %7 = load ptr, ptr %n.addr, align 8
  %8 = load i32, ptr %qid, align 4
  %conv22 = trunc i32 %8 to i16
  %call23 = call i32 @nvme_check_cqid(ptr noundef %7, i16 noundef zeroext %conv22)
  %tobool24 = icmp ne i32 %call23, 0
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %conv29 = sext i32 %lnot.ext28 to i64
  %tobool30 = icmp ne i64 %conv29, 0
  br i1 %tobool30, label %if.then31, label %if.end48

if.then31:                                        ; preds = %if.then16
  br label %do.body32

do.body32:                                        ; preds = %if.then31
  %9 = load i32, ptr %qid, align 4
  call void @trace_pci_nvme_ub_db_wr_invalid_cq(i32 noundef %9)
  br label %do.body33

do.body33:                                        ; preds = %do.body32
  %call34 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot35 = xor i1 %call34, true
  %lnot37 = xor i1 %lnot35, true
  %lnot.ext38 = zext i1 %lnot37 to i32
  %conv39 = sext i32 %lnot.ext38 to i64
  %tobool40 = icmp ne i64 %conv39, 0
  br i1 %tobool40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %do.body33
  %10 = load i32, ptr %qid, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.461, ptr noundef @__func__.nvme_process_db, i32 noundef %10)
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %do.body33
  br label %do.end43

do.end43:                                         ; preds = %if.end42
  br label %do.end44

do.end44:                                         ; preds = %do.end43
  %11 = load ptr, ptr %n.addr, align 8
  %outstanding_aers = getelementptr inbounds %struct.NvmeCtrl, ptr %11, i32 0, i32 12
  %12 = load i8, ptr %outstanding_aers, align 8
  %tobool45 = icmp ne i8 %12, 0
  br i1 %tobool45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %do.end44
  %13 = load ptr, ptr %n.addr, align 8
  call void @nvme_enqueue_event(ptr noundef %13, i8 noundef zeroext 0, i8 noundef zeroext 0, i8 noundef zeroext 1)
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %do.end44
  br label %if.end242

if.end48:                                         ; preds = %if.then16
  %14 = load ptr, ptr %n.addr, align 8
  %cq49 = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 37
  %15 = load ptr, ptr %cq49, align 8
  %16 = load i32, ptr %qid, align 4
  %idxprom = zext i32 %16 to i64
  %arrayidx = getelementptr ptr, ptr %15, i64 %idxprom
  %17 = load ptr, ptr %arrayidx, align 8
  store ptr %17, ptr %cq, align 8
  %18 = load i16, ptr %new_head, align 2
  %conv50 = zext i16 %18 to i32
  %19 = load ptr, ptr %cq, align 8
  %size = getelementptr inbounds %struct.NvmeCQueue, ptr %19, i32 0, i32 7
  %20 = load i32, ptr %size, align 4
  %cmp = icmp uge i32 %conv50, %20
  %lnot52 = xor i1 %cmp, true
  %lnot54 = xor i1 %lnot52, true
  %lnot.ext55 = zext i1 %lnot54 to i32
  %conv56 = sext i32 %lnot.ext55 to i64
  %tobool57 = icmp ne i64 %conv56, 0
  br i1 %tobool57, label %if.then58, label %if.end77

if.then58:                                        ; preds = %if.end48
  br label %do.body59

do.body59:                                        ; preds = %if.then58
  %21 = load i32, ptr %qid, align 4
  %22 = load i16, ptr %new_head, align 2
  call void @trace_pci_nvme_ub_db_wr_invalid_cqhead(i32 noundef %21, i16 noundef zeroext %22)
  br label %do.body60

do.body60:                                        ; preds = %do.body59
  %call61 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot62 = xor i1 %call61, true
  %lnot64 = xor i1 %lnot62, true
  %lnot.ext65 = zext i1 %lnot64 to i32
  %conv66 = sext i32 %lnot.ext65 to i64
  %tobool67 = icmp ne i64 %conv66, 0
  br i1 %tobool67, label %if.then68, label %if.end70

if.then68:                                        ; preds = %do.body60
  %23 = load i32, ptr %qid, align 4
  %24 = load i16, ptr %new_head, align 2
  %conv69 = zext i16 %24 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.462, ptr noundef @__func__.nvme_process_db, i32 noundef %23, i32 noundef %conv69)
  br label %if.end70

if.end70:                                         ; preds = %if.then68, %do.body60
  br label %do.end71

do.end71:                                         ; preds = %if.end70
  br label %do.end72

do.end72:                                         ; preds = %do.end71
  %25 = load ptr, ptr %n.addr, align 8
  %outstanding_aers73 = getelementptr inbounds %struct.NvmeCtrl, ptr %25, i32 0, i32 12
  %26 = load i8, ptr %outstanding_aers73, align 8
  %tobool74 = icmp ne i8 %26, 0
  br i1 %tobool74, label %if.then75, label %if.end76

if.then75:                                        ; preds = %do.end72
  %27 = load ptr, ptr %n.addr, align 8
  call void @nvme_enqueue_event(ptr noundef %27, i8 noundef zeroext 0, i8 noundef zeroext 1, i8 noundef zeroext 1)
  br label %if.end76

if.end76:                                         ; preds = %if.then75, %do.end72
  br label %if.end242

if.end77:                                         ; preds = %if.end48
  %28 = load ptr, ptr %cq, align 8
  %cqid = getelementptr inbounds %struct.NvmeCQueue, ptr %28, i32 0, i32 2
  %29 = load i16, ptr %cqid, align 2
  %30 = load i16, ptr %new_head, align 2
  call void @trace_pci_nvme_mmio_doorbell_cq(i16 noundef zeroext %29, i16 noundef zeroext %30)
  %31 = load ptr, ptr %cq, align 8
  %call78 = call zeroext i8 @nvme_cq_full(ptr noundef %31)
  %conv79 = zext i8 %call78 to i32
  %tobool80 = icmp ne i32 %conv79, 0
  %cond = select i1 %tobool80, i32 1, i32 0
  store i32 %cond, ptr %start_sqs, align 4
  %32 = load i16, ptr %new_head, align 2
  %conv81 = zext i16 %32 to i32
  %33 = load ptr, ptr %cq, align 8
  %head = getelementptr inbounds %struct.NvmeCQueue, ptr %33, i32 0, i32 4
  store i32 %conv81, ptr %head, align 8
  %34 = load i32, ptr %qid, align 4
  %tobool82 = icmp ne i32 %34, 0
  br i1 %tobool82, label %if.end115, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end77
  %35 = load ptr, ptr %n.addr, align 8
  %dbbuf_enabled = getelementptr inbounds %struct.NvmeCtrl, ptr %35, i32 0, i32 24
  %36 = load i8, ptr %dbbuf_enabled, align 16
  %tobool83 = trunc i8 %36 to i1
  br i1 %tobool83, label %if.then85, label %if.end115

if.then85:                                        ; preds = %land.lhs.true
  %37 = load ptr, ptr %pci, align 8
  %38 = load ptr, ptr %cq, align 8
  %db_addr = getelementptr inbounds %struct.NvmeCQueue, ptr %38, i32 0, i32 9
  %39 = load i64, ptr %db_addr, align 8
  %40 = load ptr, ptr %cq, align 8
  %head86 = getelementptr inbounds %struct.NvmeCQueue, ptr %40, i32 0, i32 4
  %41 = load i32, ptr %head86, align 8
  %bf.load = load i32, ptr %.compoundliteral, align 4
  %bf.clear = and i32 %bf.load, -2
  %bf.set = or i32 %bf.clear, 1
  store i32 %bf.set, ptr %.compoundliteral, align 4
  %bf.load87 = load i32, ptr %.compoundliteral, align 4
  %bf.clear88 = and i32 %bf.load87, -3
  %bf.set89 = or i32 %bf.clear88, 0
  store i32 %bf.set89, ptr %.compoundliteral, align 4
  %bf.load90 = load i32, ptr %.compoundliteral, align 4
  %bf.clear91 = and i32 %bf.load90, -13
  %bf.set92 = or i32 %bf.clear91, 0
  store i32 %bf.set92, ptr %.compoundliteral, align 4
  %bf.load93 = load i32, ptr %.compoundliteral, align 4
  %bf.clear94 = and i32 %bf.load93, -17
  %bf.set95 = or i32 %bf.clear94, 0
  store i32 %bf.set95, ptr %.compoundliteral, align 4
  %bf.load96 = load i32, ptr %.compoundliteral, align 4
  %bf.clear97 = and i32 %bf.load96, -33
  %bf.set98 = or i32 %bf.clear97, 0
  store i32 %bf.set98, ptr %.compoundliteral, align 4
  %bf.load99 = load i32, ptr %.compoundliteral, align 4
  %bf.clear100 = and i32 %bf.load99, -4194241
  %bf.set101 = or i32 %bf.clear100, 0
  store i32 %bf.set101, ptr %.compoundliteral, align 4
  %bf.load102 = load i32, ptr %.compoundliteral, align 4
  %bf.clear103 = and i32 %bf.load102, -4194305
  %bf.set104 = or i32 %bf.clear103, 0
  store i32 %bf.set104, ptr %.compoundliteral, align 4
  %bf.load105 = load i32, ptr %.compoundliteral, align 4
  %bf.clear106 = and i32 %bf.load105, -8388609
  %bf.set107 = or i32 %bf.clear106, 0
  store i32 %bf.set107, ptr %.compoundliteral, align 4
  %bf.load108 = load i32, ptr %.compoundliteral, align 4
  %bf.clear109 = and i32 %bf.load108, -16777217
  %bf.set110 = or i32 %bf.clear109, 0
  store i32 %bf.set110, ptr %.compoundliteral, align 4
  %bf.load111 = load i32, ptr %.compoundliteral, align 4
  %bf.clear112 = and i32 %bf.load111, -33554433
  %bf.set113 = or i32 %bf.clear112, 0
  store i32 %bf.set113, ptr %.compoundliteral, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %.compoundliteral, i32 0, i32 0
  %42 = load i32, ptr %coerce.dive, align 4
  %call114 = call i32 @stl_le_pci_dma(ptr noundef %37, i64 noundef %39, i32 noundef %41, i32 %42)
  br label %if.end115

if.end115:                                        ; preds = %if.then85, %land.lhs.true, %if.end77
  %43 = load i32, ptr %start_sqs, align 4
  %tobool116 = icmp ne i32 %43, 0
  br i1 %tobool116, label %if.then117, label %if.end121

if.then117:                                       ; preds = %if.end115
  %44 = load ptr, ptr %cq, align 8
  %sq_list = getelementptr inbounds %struct.NvmeCQueue, ptr %44, i32 0, i32 14
  %45 = load ptr, ptr %sq_list, align 8
  store ptr %45, ptr %sq, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then117
  %46 = load ptr, ptr %sq, align 8
  %tobool118 = icmp ne ptr %46, null
  br i1 %tobool118, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %47 = load ptr, ptr %sq, align 8
  %bh = getelementptr inbounds %struct.NvmeSQueue, ptr %47, i32 0, i32 9
  %48 = load ptr, ptr %bh, align 8
  call void @qemu_bh_schedule(ptr noundef %48)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %49 = load ptr, ptr %sq, align 8
  %entry119 = getelementptr inbounds %struct.NvmeSQueue, ptr %49, i32 0, i32 15
  %50 = load ptr, ptr %entry119, align 8
  store ptr %50, ptr %sq, align 8
  br label %for.cond, !llvm.loop !15

for.end:                                          ; preds = %for.cond
  %51 = load ptr, ptr %cq, align 8
  %bh120 = getelementptr inbounds %struct.NvmeCQueue, ptr %51, i32 0, i32 11
  %52 = load ptr, ptr %bh120, align 8
  call void @qemu_bh_schedule(ptr noundef %52)
  br label %if.end121

if.end121:                                        ; preds = %for.end, %if.end115
  %53 = load ptr, ptr %cq, align 8
  %tail = getelementptr inbounds %struct.NvmeCQueue, ptr %53, i32 0, i32 5
  %54 = load i32, ptr %tail, align 4
  %55 = load ptr, ptr %cq, align 8
  %head122 = getelementptr inbounds %struct.NvmeCQueue, ptr %55, i32 0, i32 4
  %56 = load i32, ptr %head122, align 8
  %cmp123 = icmp eq i32 %54, %56
  br i1 %cmp123, label %if.then125, label %if.end129

if.then125:                                       ; preds = %if.end121
  %57 = load ptr, ptr %cq, align 8
  %irq_enabled = getelementptr inbounds %struct.NvmeCQueue, ptr %57, i32 0, i32 3
  %58 = load i16, ptr %irq_enabled, align 4
  %tobool126 = icmp ne i16 %58, 0
  br i1 %tobool126, label %if.then127, label %if.end128

if.then127:                                       ; preds = %if.then125
  %59 = load ptr, ptr %n.addr, align 8
  %cq_pending = getelementptr inbounds %struct.NvmeCtrl, ptr %59, i32 0, i32 14
  %60 = load i32, ptr %cq_pending, align 16
  %dec = add i32 %60, -1
  store i32 %dec, ptr %cq_pending, align 16
  br label %if.end128

if.end128:                                        ; preds = %if.then127, %if.then125
  %61 = load ptr, ptr %n.addr, align 8
  %62 = load ptr, ptr %cq, align 8
  call void @nvme_irq_deassert(ptr noundef %61, ptr noundef %62)
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.end121
  br label %if.end242

if.else:                                          ; preds = %if.end13
  %63 = load i32, ptr %val.addr, align 4
  %and130 = and i32 %63, 65535
  %conv131 = trunc i32 %and130 to i16
  store i16 %conv131, ptr %new_tail, align 2
  %64 = load i64, ptr %addr.addr, align 8
  %sub133 = sub i64 %64, 4096
  %shr134 = lshr i64 %sub133, 3
  %conv135 = trunc i64 %shr134 to i32
  store i32 %conv135, ptr %qid, align 4
  %65 = load ptr, ptr %n.addr, align 8
  %66 = load i32, ptr %qid, align 4
  %conv136 = trunc i32 %66 to i16
  %call137 = call i32 @nvme_check_sqid(ptr noundef %65, i16 noundef zeroext %conv136)
  %tobool138 = icmp ne i32 %call137, 0
  %lnot139 = xor i1 %tobool138, true
  %lnot141 = xor i1 %lnot139, true
  %lnot.ext142 = zext i1 %lnot141 to i32
  %conv143 = sext i32 %lnot.ext142 to i64
  %tobool144 = icmp ne i64 %conv143, 0
  br i1 %tobool144, label %if.then145, label %if.end163

if.then145:                                       ; preds = %if.else
  br label %do.body146

do.body146:                                       ; preds = %if.then145
  %67 = load i32, ptr %qid, align 4
  call void @trace_pci_nvme_ub_db_wr_invalid_sq(i32 noundef %67)
  br label %do.body147

do.body147:                                       ; preds = %do.body146
  %call148 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot149 = xor i1 %call148, true
  %lnot151 = xor i1 %lnot149, true
  %lnot.ext152 = zext i1 %lnot151 to i32
  %conv153 = sext i32 %lnot.ext152 to i64
  %tobool154 = icmp ne i64 %conv153, 0
  br i1 %tobool154, label %if.then155, label %if.end156

if.then155:                                       ; preds = %do.body147
  %68 = load i32, ptr %qid, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.463, ptr noundef @__func__.nvme_process_db, i32 noundef %68)
  br label %if.end156

if.end156:                                        ; preds = %if.then155, %do.body147
  br label %do.end157

do.end157:                                        ; preds = %if.end156
  br label %do.end158

do.end158:                                        ; preds = %do.end157
  %69 = load ptr, ptr %n.addr, align 8
  %outstanding_aers159 = getelementptr inbounds %struct.NvmeCtrl, ptr %69, i32 0, i32 12
  %70 = load i8, ptr %outstanding_aers159, align 8
  %tobool160 = icmp ne i8 %70, 0
  br i1 %tobool160, label %if.then161, label %if.end162

if.then161:                                       ; preds = %do.end158
  %71 = load ptr, ptr %n.addr, align 8
  call void @nvme_enqueue_event(ptr noundef %71, i8 noundef zeroext 0, i8 noundef zeroext 0, i8 noundef zeroext 1)
  br label %if.end162

if.end162:                                        ; preds = %if.then161, %do.end158
  br label %if.end242

if.end163:                                        ; preds = %if.else
  %72 = load ptr, ptr %n.addr, align 8
  %sq164 = getelementptr inbounds %struct.NvmeCtrl, ptr %72, i32 0, i32 36
  %73 = load ptr, ptr %sq164, align 16
  %74 = load i32, ptr %qid, align 4
  %idxprom165 = zext i32 %74 to i64
  %arrayidx166 = getelementptr ptr, ptr %73, i64 %idxprom165
  %75 = load ptr, ptr %arrayidx166, align 8
  store ptr %75, ptr %sq132, align 8
  %76 = load i16, ptr %new_tail, align 2
  %conv167 = zext i16 %76 to i32
  %77 = load ptr, ptr %sq132, align 8
  %size168 = getelementptr inbounds %struct.NvmeSQueue, ptr %77, i32 0, i32 5
  %78 = load i32, ptr %size168, align 4
  %cmp169 = icmp uge i32 %conv167, %78
  %lnot171 = xor i1 %cmp169, true
  %lnot173 = xor i1 %lnot171, true
  %lnot.ext174 = zext i1 %lnot173 to i32
  %conv175 = sext i32 %lnot.ext174 to i64
  %tobool176 = icmp ne i64 %conv175, 0
  br i1 %tobool176, label %if.then177, label %if.end196

if.then177:                                       ; preds = %if.end163
  br label %do.body178

do.body178:                                       ; preds = %if.then177
  %79 = load i32, ptr %qid, align 4
  %80 = load i16, ptr %new_tail, align 2
  call void @trace_pci_nvme_ub_db_wr_invalid_sqtail(i32 noundef %79, i16 noundef zeroext %80)
  br label %do.body179

do.body179:                                       ; preds = %do.body178
  %call180 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 2048)
  %lnot181 = xor i1 %call180, true
  %lnot183 = xor i1 %lnot181, true
  %lnot.ext184 = zext i1 %lnot183 to i32
  %conv185 = sext i32 %lnot.ext184 to i64
  %tobool186 = icmp ne i64 %conv185, 0
  br i1 %tobool186, label %if.then187, label %if.end189

if.then187:                                       ; preds = %do.body179
  %81 = load i32, ptr %qid, align 4
  %82 = load i16, ptr %new_tail, align 2
  %conv188 = zext i16 %82 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.464, ptr noundef @__func__.nvme_process_db, i32 noundef %81, i32 noundef %conv188)
  br label %if.end189

if.end189:                                        ; preds = %if.then187, %do.body179
  br label %do.end190

do.end190:                                        ; preds = %if.end189
  br label %do.end191

do.end191:                                        ; preds = %do.end190
  %83 = load ptr, ptr %n.addr, align 8
  %outstanding_aers192 = getelementptr inbounds %struct.NvmeCtrl, ptr %83, i32 0, i32 12
  %84 = load i8, ptr %outstanding_aers192, align 8
  %tobool193 = icmp ne i8 %84, 0
  br i1 %tobool193, label %if.then194, label %if.end195

if.then194:                                       ; preds = %do.end191
  %85 = load ptr, ptr %n.addr, align 8
  call void @nvme_enqueue_event(ptr noundef %85, i8 noundef zeroext 0, i8 noundef zeroext 1, i8 noundef zeroext 1)
  br label %if.end195

if.end195:                                        ; preds = %if.then194, %do.end191
  br label %if.end242

if.end196:                                        ; preds = %if.end163
  %86 = load ptr, ptr %sq132, align 8
  %sqid = getelementptr inbounds %struct.NvmeSQueue, ptr %86, i32 0, i32 1
  %87 = load i16, ptr %sqid, align 8
  %88 = load i16, ptr %new_tail, align 2
  call void @trace_pci_nvme_mmio_doorbell_sq(i16 noundef zeroext %87, i16 noundef zeroext %88)
  %89 = load i16, ptr %new_tail, align 2
  %conv197 = zext i16 %89 to i32
  %90 = load ptr, ptr %sq132, align 8
  %tail198 = getelementptr inbounds %struct.NvmeSQueue, ptr %90, i32 0, i32 4
  store i32 %conv197, ptr %tail198, align 8
  %91 = load i32, ptr %qid, align 4
  %tobool199 = icmp ne i32 %91, 0
  br i1 %tobool199, label %if.end240, label %land.lhs.true200

land.lhs.true200:                                 ; preds = %if.end196
  %92 = load ptr, ptr %n.addr, align 8
  %dbbuf_enabled201 = getelementptr inbounds %struct.NvmeCtrl, ptr %92, i32 0, i32 24
  %93 = load i8, ptr %dbbuf_enabled201, align 16
  %tobool202 = trunc i8 %93 to i1
  br i1 %tobool202, label %if.then204, label %if.end240

if.then204:                                       ; preds = %land.lhs.true200
  %94 = load ptr, ptr %pci, align 8
  %95 = load ptr, ptr %sq132, align 8
  %db_addr205 = getelementptr inbounds %struct.NvmeSQueue, ptr %95, i32 0, i32 7
  %96 = load i64, ptr %db_addr205, align 8
  %97 = load ptr, ptr %sq132, align 8
  %tail206 = getelementptr inbounds %struct.NvmeSQueue, ptr %97, i32 0, i32 4
  %98 = load i32, ptr %tail206, align 8
  %bf.load208 = load i32, ptr %.compoundliteral207, align 4
  %bf.clear209 = and i32 %bf.load208, -2
  %bf.set210 = or i32 %bf.clear209, 1
  store i32 %bf.set210, ptr %.compoundliteral207, align 4
  %bf.load211 = load i32, ptr %.compoundliteral207, align 4
  %bf.clear212 = and i32 %bf.load211, -3
  %bf.set213 = or i32 %bf.clear212, 0
  store i32 %bf.set213, ptr %.compoundliteral207, align 4
  %bf.load214 = load i32, ptr %.compoundliteral207, align 4
  %bf.clear215 = and i32 %bf.load214, -13
  %bf.set216 = or i32 %bf.clear215, 0
  store i32 %bf.set216, ptr %.compoundliteral207, align 4
  %bf.load217 = load i32, ptr %.compoundliteral207, align 4
  %bf.clear218 = and i32 %bf.load217, -17
  %bf.set219 = or i32 %bf.clear218, 0
  store i32 %bf.set219, ptr %.compoundliteral207, align 4
  %bf.load220 = load i32, ptr %.compoundliteral207, align 4
  %bf.clear221 = and i32 %bf.load220, -33
  %bf.set222 = or i32 %bf.clear221, 0
  store i32 %bf.set222, ptr %.compoundliteral207, align 4
  %bf.load223 = load i32, ptr %.compoundliteral207, align 4
  %bf.clear224 = and i32 %bf.load223, -4194241
  %bf.set225 = or i32 %bf.clear224, 0
  store i32 %bf.set225, ptr %.compoundliteral207, align 4
  %bf.load226 = load i32, ptr %.compoundliteral207, align 4
  %bf.clear227 = and i32 %bf.load226, -4194305
  %bf.set228 = or i32 %bf.clear227, 0
  store i32 %bf.set228, ptr %.compoundliteral207, align 4
  %bf.load229 = load i32, ptr %.compoundliteral207, align 4
  %bf.clear230 = and i32 %bf.load229, -8388609
  %bf.set231 = or i32 %bf.clear230, 0
  store i32 %bf.set231, ptr %.compoundliteral207, align 4
  %bf.load232 = load i32, ptr %.compoundliteral207, align 4
  %bf.clear233 = and i32 %bf.load232, -16777217
  %bf.set234 = or i32 %bf.clear233, 0
  store i32 %bf.set234, ptr %.compoundliteral207, align 4
  %bf.load235 = load i32, ptr %.compoundliteral207, align 4
  %bf.clear236 = and i32 %bf.load235, -33554433
  %bf.set237 = or i32 %bf.clear236, 0
  store i32 %bf.set237, ptr %.compoundliteral207, align 4
  %coerce.dive238 = getelementptr inbounds %struct.MemTxAttrs, ptr %.compoundliteral207, i32 0, i32 0
  %99 = load i32, ptr %coerce.dive238, align 4
  %call239 = call i32 @stl_le_pci_dma(ptr noundef %94, i64 noundef %96, i32 noundef %98, i32 %99)
  br label %if.end240

if.end240:                                        ; preds = %if.then204, %land.lhs.true200, %if.end196
  %100 = load ptr, ptr %sq132, align 8
  %bh241 = getelementptr inbounds %struct.NvmeSQueue, ptr %100, i32 0, i32 9
  %101 = load ptr, ptr %bh241, align 8
  call void @qemu_bh_schedule(ptr noundef %101)
  br label %if.end242

if.end242:                                        ; preds = %if.end240, %if.end195, %if.end162, %if.end129, %if.end76, %if.end47, %do.end12
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_write(i64 noundef %addr, i64 noundef %data, i32 noundef %size) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %data.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %data, ptr %data.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_WRITE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  %6 = load i64, ptr %data.addr, align 8
  %7 = load i32, ptr %size.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.105, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6, i32 noundef %7)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i64, ptr %addr.addr, align 8
  %9 = load i64, ptr %data.addr, align 8
  %10 = load i32, ptr %size.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.106, i64 noundef %8, i64 noundef %9, i32 noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_misaligned32(i64 noundef %offset) #0 {
entry:
  %offset.addr = alloca i64, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_misaligned32(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_toosmall(i64 noundef %offset, i32 noundef %size) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  store i64 %offset, ptr %offset.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i64, ptr %offset.addr, align 8
  %1 = load i32, ptr %size.addr, align 4
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_toosmall(i64 noundef %0, i32 noundef %1)
  ret void
}

declare i32 @msix_enabled(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_intmask_with_msix() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_intmask_with_msix()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stl_le_p(ptr noundef %ptr, i32 noundef %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i32, align 4
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %v, ptr %v.addr, align 4
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i32, ptr %v.addr, align 4
  call void @stl_he_p(ptr noundef %0, i32 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_intm_set(i64 noundef %data, i64 noundef %new_mask) #0 {
entry:
  %data.addr = alloca i64, align 8
  %new_mask.addr = alloca i64, align 8
  store i64 %data, ptr %data.addr, align 8
  store i64 %new_mask, ptr %new_mask.addr, align 8
  %0 = load i64, ptr %data.addr, align 8
  %1 = load i64, ptr %new_mask.addr, align 8
  call void @_nocheck__trace_pci_nvme_mmio_intm_set(i64 noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_irq_check(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %pci = alloca ptr, align 8
  %intms = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %0)
  store ptr %call, ptr %pci, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 3
  %intms1 = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 2
  %call2 = call i32 @ldl_le_p(ptr noundef %intms1)
  store i32 %call2, ptr %intms, align 4
  %2 = load ptr, ptr %pci, align 8
  %call3 = call i32 @msix_enabled(ptr noundef %2)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end6

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %intms, align 4
  %not = xor i32 %3, -1
  %4 = load ptr, ptr %n.addr, align 8
  %irq_status = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 13
  %5 = load i32, ptr %irq_status, align 4
  %and = and i32 %not, %5
  %tobool4 = icmp ne i32 %and, 0
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  %6 = load ptr, ptr %pci, align 8
  call void @pci_irq_assert(ptr noundef %6)
  br label %if.end6

if.else:                                          ; preds = %if.end
  %7 = load ptr, ptr %pci, align 8
  call void @pci_irq_deassert(ptr noundef %7)
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then5, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_intm_clr(i64 noundef %data, i64 noundef %new_mask) #0 {
entry:
  %data.addr = alloca i64, align 8
  %new_mask.addr = alloca i64, align 8
  store i64 %data, ptr %data.addr, align 8
  store i64 %new_mask, ptr %new_mask.addr, align 8
  %0 = load i64, ptr %data.addr, align 8
  %1 = load i64, ptr %new_mask.addr, align 8
  call void @_nocheck__trace_pci_nvme_mmio_intm_clr(i64 noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_cfg(i64 noundef %data) #0 {
entry:
  %data.addr = alloca i64, align 8
  store i64 %data, ptr %data.addr, align 8
  %0 = load i64, ptr %data.addr, align 8
  call void @_nocheck__trace_pci_nvme_mmio_cfg(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_shutdown_set() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_mmio_shutdown_set()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_ctrl_shutdown(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %pmr = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 26
  %dev = getelementptr inbounds %struct.anon.21, ptr %pmr, i32 0, i32 0
  %1 = load ptr, ptr %dev, align 16
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %n.addr, align 8
  %pmr1 = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 26
  %dev2 = getelementptr inbounds %struct.anon.21, ptr %pmr1, i32 0, i32 0
  %3 = load ptr, ptr %dev2, align 16
  %mr = getelementptr inbounds %struct.HostMemoryBackend, ptr %3, i32 0, i32 13
  %4 = load ptr, ptr %n.addr, align 8
  %pmr3 = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 26
  %dev4 = getelementptr inbounds %struct.anon.21, ptr %pmr3, i32 0, i32 0
  %5 = load ptr, ptr %dev4, align 16
  %size = getelementptr inbounds %struct.HostMemoryBackend, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %size, align 8
  call void @memory_region_msync(ptr noundef %mr, i64 noundef 0, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, ptr %i, align 4
  %cmp = icmp sle i32 %7, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr %n.addr, align 8
  %9 = load i32, ptr %i, align 4
  %call = call ptr @nvme_ns(ptr noundef %8, i32 noundef %9)
  store ptr %call, ptr %ns, align 8
  %10 = load ptr, ptr %ns, align 8
  %tobool5 = icmp ne ptr %10, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %for.body
  br label %for.inc

if.end7:                                          ; preds = %for.body
  %11 = load ptr, ptr %ns, align 8
  call void @nvme_ns_shutdown(ptr noundef %11)
  br label %for.inc

for.inc:                                          ; preds = %if.end7, %if.then6
  %12 = load i32, ptr %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !16

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_shutdown_cleared() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_mmio_shutdown_cleared()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_start_ctrl(ptr noundef %n) #0 {
entry:
  %retval = alloca i32, align 4
  %n.addr = alloca ptr, align 8
  %cap = alloca i64, align 8
  %cc = alloca i32, align 4
  %aqa = alloca i32, align 4
  %asq = alloca i64, align 8
  %acq = alloca i64, align 8
  %page_bits = alloca i32, align 4
  %page_size = alloca i32, align 4
  %sctrl = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 3
  %cap1 = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 0
  %call = call i64 @ldq_le_p(ptr noundef %cap1)
  store i64 %call, ptr %cap, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %bar2 = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 3
  %cc3 = getelementptr inbounds %struct.NvmeBar, ptr %bar2, i32 0, i32 4
  %call4 = call i32 @ldl_le_p(ptr noundef %cc3)
  store i32 %call4, ptr %cc, align 4
  %2 = load ptr, ptr %n.addr, align 8
  %bar5 = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 3
  %aqa6 = getelementptr inbounds %struct.NvmeBar, ptr %bar5, i32 0, i32 8
  %call7 = call i32 @ldl_le_p(ptr noundef %aqa6)
  store i32 %call7, ptr %aqa, align 4
  %3 = load ptr, ptr %n.addr, align 8
  %bar8 = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 3
  %asq9 = getelementptr inbounds %struct.NvmeBar, ptr %bar8, i32 0, i32 9
  %call10 = call i64 @ldq_le_p(ptr noundef %asq9)
  store i64 %call10, ptr %asq, align 8
  %4 = load ptr, ptr %n.addr, align 8
  %bar11 = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 3
  %acq12 = getelementptr inbounds %struct.NvmeBar, ptr %bar11, i32 0, i32 10
  %call13 = call i64 @ldq_le_p(ptr noundef %acq12)
  store i64 %call13, ptr %acq, align 8
  %5 = load i32, ptr %cc, align 4
  %shr = lshr i32 %5, 7
  %and = and i32 %shr, 15
  %add = add i32 %and, 12
  store i32 %add, ptr %page_bits, align 4
  %6 = load i32, ptr %page_bits, align 4
  %shl = shl i32 1, %6
  store i32 %shl, ptr %page_size, align 4
  %7 = load ptr, ptr %n.addr, align 8
  %call14 = call ptr @nvme_sctrl(ptr noundef %7)
  store ptr %call14, ptr %sctrl, align 8
  %8 = load ptr, ptr %n.addr, align 8
  %call15 = call ptr @PCI_DEVICE(ptr noundef %8)
  %call16 = call i32 @pci_is_vf(ptr noundef %call15)
  %tobool = icmp ne i32 %call16, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %9 = load ptr, ptr %sctrl, align 8
  %scs = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %9, i32 0, i32 2
  %10 = load i8, ptr %scs, align 1
  %tobool17 = icmp ne i8 %10, 0
  br i1 %tobool17, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %11 = load ptr, ptr %sctrl, align 8
  %nvi = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %11, i32 0, i32 6
  %12 = load i16, ptr %nvi, align 1
  %call18 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %12)
  %13 = load ptr, ptr %sctrl, align 8
  %nvq = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %13, i32 0, i32 5
  %14 = load i16, ptr %nvq, align 1
  %call19 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %14)
  call void @trace_pci_nvme_err_startfail_virt_state(i16 noundef zeroext %call18, i16 noundef zeroext %call19)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %15 = load ptr, ptr %n.addr, align 8
  %cq = getelementptr inbounds %struct.NvmeCtrl, ptr %15, i32 0, i32 37
  %16 = load ptr, ptr %cq, align 8
  %arrayidx = getelementptr ptr, ptr %16, i64 0
  %17 = load ptr, ptr %arrayidx, align 8
  %tobool20 = icmp ne ptr %17, null
  %lnot = xor i1 %tobool20, true
  %lnot21 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot21 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool22 = icmp ne i64 %conv, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end
  call void @trace_pci_nvme_err_startfail_cq()
  store i32 -1, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end
  %18 = load ptr, ptr %n.addr, align 8
  %sq = getelementptr inbounds %struct.NvmeCtrl, ptr %18, i32 0, i32 36
  %19 = load ptr, ptr %sq, align 16
  %arrayidx25 = getelementptr ptr, ptr %19, i64 0
  %20 = load ptr, ptr %arrayidx25, align 8
  %tobool26 = icmp ne ptr %20, null
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %tobool32 = icmp ne i64 %conv31, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end24
  call void @trace_pci_nvme_err_startfail_sq()
  store i32 -1, ptr %retval, align 4
  br label %return

if.end34:                                         ; preds = %if.end24
  %21 = load i64, ptr %asq, align 8
  %22 = load i32, ptr %page_size, align 4
  %sub = sub i32 %22, 1
  %conv35 = zext i32 %sub to i64
  %and36 = and i64 %21, %conv35
  %tobool37 = icmp ne i64 %and36, 0
  %lnot38 = xor i1 %tobool37, true
  %lnot40 = xor i1 %lnot38, true
  %lnot.ext41 = zext i1 %lnot40 to i32
  %conv42 = sext i32 %lnot.ext41 to i64
  %tobool43 = icmp ne i64 %conv42, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end34
  %23 = load i64, ptr %asq, align 8
  call void @trace_pci_nvme_err_startfail_asq_misaligned(i64 noundef %23)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end45:                                         ; preds = %if.end34
  %24 = load i64, ptr %acq, align 8
  %25 = load i32, ptr %page_size, align 4
  %sub46 = sub i32 %25, 1
  %conv47 = zext i32 %sub46 to i64
  %and48 = and i64 %24, %conv47
  %tobool49 = icmp ne i64 %and48, 0
  %lnot50 = xor i1 %tobool49, true
  %lnot52 = xor i1 %lnot50, true
  %lnot.ext53 = zext i1 %lnot52 to i32
  %conv54 = sext i32 %lnot.ext53 to i64
  %tobool55 = icmp ne i64 %conv54, 0
  br i1 %tobool55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end45
  %26 = load i64, ptr %acq, align 8
  call void @trace_pci_nvme_err_startfail_acq_misaligned(i64 noundef %26)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end57:                                         ; preds = %if.end45
  %27 = load i64, ptr %cap, align 8
  %shr58 = lshr i64 %27, 37
  %and59 = and i64 %shr58, 255
  %28 = load i32, ptr %cc, align 4
  %shr60 = lshr i32 %28, 4
  %and61 = and i32 %shr60, 7
  %shl62 = shl i32 1, %and61
  %conv63 = sext i32 %shl62 to i64
  %and64 = and i64 %and59, %conv63
  %tobool65 = icmp ne i64 %and64, 0
  %lnot66 = xor i1 %tobool65, true
  %lnot68 = xor i1 %lnot66, true
  %lnot70 = xor i1 %lnot68, true
  %lnot.ext71 = zext i1 %lnot70 to i32
  %conv72 = sext i32 %lnot.ext71 to i64
  %tobool73 = icmp ne i64 %conv72, 0
  br i1 %tobool73, label %if.then74, label %if.end78

if.then74:                                        ; preds = %if.end57
  %29 = load i32, ptr %cc, align 4
  %shr75 = lshr i32 %29, 4
  %and76 = and i32 %shr75, 7
  %conv77 = trunc i32 %and76 to i8
  call void @trace_pci_nvme_err_startfail_css(i8 noundef zeroext %conv77)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end78:                                         ; preds = %if.end57
  %30 = load i32, ptr %cc, align 4
  %shr79 = lshr i32 %30, 7
  %and80 = and i32 %shr79, 15
  %conv81 = zext i32 %and80 to i64
  %31 = load i64, ptr %cap, align 8
  %shr82 = lshr i64 %31, 48
  %and83 = and i64 %shr82, 15
  %cmp = icmp ult i64 %conv81, %and83
  %lnot85 = xor i1 %cmp, true
  %lnot87 = xor i1 %lnot85, true
  %lnot.ext88 = zext i1 %lnot87 to i32
  %conv89 = sext i32 %lnot.ext88 to i64
  %tobool90 = icmp ne i64 %conv89, 0
  br i1 %tobool90, label %if.then91, label %if.end98

if.then91:                                        ; preds = %if.end78
  %32 = load i32, ptr %cc, align 4
  %shr92 = lshr i32 %32, 7
  %and93 = and i32 %shr92, 15
  %conv94 = trunc i32 %and93 to i8
  %33 = load i64, ptr %cap, align 8
  %shr95 = lshr i64 %33, 48
  %and96 = and i64 %shr95, 15
  %conv97 = trunc i64 %and96 to i8
  call void @trace_pci_nvme_err_startfail_page_too_small(i8 noundef zeroext %conv94, i8 noundef zeroext %conv97)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end98:                                         ; preds = %if.end78
  %34 = load i32, ptr %cc, align 4
  %shr99 = lshr i32 %34, 7
  %and100 = and i32 %shr99, 15
  %conv101 = zext i32 %and100 to i64
  %35 = load i64, ptr %cap, align 8
  %shr102 = lshr i64 %35, 52
  %and103 = and i64 %shr102, 15
  %cmp104 = icmp ugt i64 %conv101, %and103
  %lnot106 = xor i1 %cmp104, true
  %lnot108 = xor i1 %lnot106, true
  %lnot.ext109 = zext i1 %lnot108 to i32
  %conv110 = sext i32 %lnot.ext109 to i64
  %tobool111 = icmp ne i64 %conv110, 0
  br i1 %tobool111, label %if.then112, label %if.end119

if.then112:                                       ; preds = %if.end98
  %36 = load i32, ptr %cc, align 4
  %shr113 = lshr i32 %36, 7
  %and114 = and i32 %shr113, 15
  %conv115 = trunc i32 %and114 to i8
  %37 = load i64, ptr %cap, align 8
  %shr116 = lshr i64 %37, 52
  %and117 = and i64 %shr116, 15
  %conv118 = trunc i64 %and117 to i8
  call void @trace_pci_nvme_err_startfail_page_too_large(i8 noundef zeroext %conv115, i8 noundef zeroext %conv118)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end119:                                        ; preds = %if.end98
  %38 = load i32, ptr %aqa, align 4
  %shr120 = lshr i32 %38, 0
  %and121 = and i32 %shr120, 4095
  %tobool122 = icmp ne i32 %and121, 0
  %lnot123 = xor i1 %tobool122, true
  %lnot125 = xor i1 %lnot123, true
  %lnot127 = xor i1 %lnot125, true
  %lnot.ext128 = zext i1 %lnot127 to i32
  %conv129 = sext i32 %lnot.ext128 to i64
  %tobool130 = icmp ne i64 %conv129, 0
  br i1 %tobool130, label %if.then131, label %if.end132

if.then131:                                       ; preds = %if.end119
  call void @trace_pci_nvme_err_startfail_asqent_sz_zero()
  store i32 -1, ptr %retval, align 4
  br label %return

if.end132:                                        ; preds = %if.end119
  %39 = load i32, ptr %aqa, align 4
  %shr133 = lshr i32 %39, 16
  %and134 = and i32 %shr133, 4095
  %tobool135 = icmp ne i32 %and134, 0
  %lnot136 = xor i1 %tobool135, true
  %lnot138 = xor i1 %lnot136, true
  %lnot140 = xor i1 %lnot138, true
  %lnot.ext141 = zext i1 %lnot140 to i32
  %conv142 = sext i32 %lnot.ext141 to i64
  %tobool143 = icmp ne i64 %conv142, 0
  br i1 %tobool143, label %if.then144, label %if.end145

if.then144:                                       ; preds = %if.end132
  call void @trace_pci_nvme_err_startfail_acqent_sz_zero()
  store i32 -1, ptr %retval, align 4
  br label %return

if.end145:                                        ; preds = %if.end132
  %40 = load i32, ptr %page_bits, align 4
  %conv146 = trunc i32 %40 to i16
  %41 = load ptr, ptr %n.addr, align 8
  %page_bits147 = getelementptr inbounds %struct.NvmeCtrl, ptr %41, i32 0, i32 9
  store i16 %conv146, ptr %page_bits147, align 16
  %42 = load i32, ptr %page_size, align 4
  %43 = load ptr, ptr %n.addr, align 8
  %page_size148 = getelementptr inbounds %struct.NvmeCtrl, ptr %43, i32 0, i32 8
  store i32 %42, ptr %page_size148, align 4
  %44 = load ptr, ptr %n.addr, align 8
  %page_size149 = getelementptr inbounds %struct.NvmeCtrl, ptr %44, i32 0, i32 8
  %45 = load i32, ptr %page_size149, align 4
  %conv150 = zext i32 %45 to i64
  %div = udiv i64 %conv150, 8
  %conv151 = trunc i64 %div to i16
  %46 = load ptr, ptr %n.addr, align 8
  %max_prp_ents = getelementptr inbounds %struct.NvmeCtrl, ptr %46, i32 0, i32 10
  store i16 %conv151, ptr %max_prp_ents, align 2
  %47 = load ptr, ptr %n.addr, align 8
  %admin_cq = getelementptr inbounds %struct.NvmeCtrl, ptr %47, i32 0, i32 39
  %48 = load ptr, ptr %n.addr, align 8
  %49 = load i64, ptr %acq, align 8
  %50 = load i32, ptr %aqa, align 4
  %shr152 = lshr i32 %50, 16
  %and153 = and i32 %shr152, 4095
  %add154 = add i32 %and153, 1
  %conv155 = trunc i32 %add154 to i16
  call void @nvme_init_cq(ptr noundef %admin_cq, ptr noundef %48, i64 noundef %49, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext %conv155, i16 noundef zeroext 1)
  %51 = load ptr, ptr %n.addr, align 8
  %admin_sq = getelementptr inbounds %struct.NvmeCtrl, ptr %51, i32 0, i32 38
  %52 = load ptr, ptr %n.addr, align 8
  %53 = load i64, ptr %asq, align 8
  %54 = load i32, ptr %aqa, align 4
  %shr156 = lshr i32 %54, 0
  %and157 = and i32 %shr156, 4095
  %add158 = add i32 %and157, 1
  %conv159 = trunc i32 %add158 to i16
  call void @nvme_init_sq(ptr noundef %admin_sq, ptr noundef %52, i64 noundef %53, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext %conv159)
  %55 = load ptr, ptr %n.addr, align 8
  call void @nvme_set_timestamp(ptr noundef %55, i64 noundef 0)
  %56 = load ptr, ptr %n.addr, align 8
  call void @nvme_select_iocs(ptr noundef %56)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end145, %if.then144, %if.then131, %if.then112, %if.then91, %if.then74, %if.then56, %if.then44, %if.then33, %if.then23, %if.then
  %57 = load i32, ptr %retval, align 4
  ret i32 %57
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_startfail() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_err_startfail()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_start_success() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_mmio_start_success()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_stopped() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_mmio_stopped()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_ctrl_reset(ptr noundef %n, i32 noundef %rst) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %rst.addr = alloca i32, align 4
  %pci_dev = alloca ptr, align 8
  %sctrl = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %i = alloca i32, align 4
  %event = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store i32 %rst, ptr %rst.addr, align 4
  %0 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %0)
  store ptr %call, ptr %pci_dev, align 8
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %cmp = icmp sle i32 %1, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %n.addr, align 8
  %3 = load i32, ptr %i, align 4
  %call1 = call ptr @nvme_ns(ptr noundef %2, i32 noundef %3)
  store ptr %call1, ptr %ns, align 8
  %4 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %5 = load ptr, ptr %ns, align 8
  call void @nvme_ns_drain(ptr noundef %5)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %6 = load i32, ptr %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !17

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %i, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc11, %for.end
  %7 = load i32, ptr %i, align 4
  %8 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 4
  %max_ioqpairs = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 2
  %9 = load i32, ptr %max_ioqpairs, align 4
  %add = add i32 %9, 1
  %cmp3 = icmp ult i32 %7, %add
  br i1 %cmp3, label %for.body4, label %for.end13

for.body4:                                        ; preds = %for.cond2
  %10 = load ptr, ptr %n.addr, align 8
  %sq = getelementptr inbounds %struct.NvmeCtrl, ptr %10, i32 0, i32 36
  %11 = load ptr, ptr %sq, align 16
  %12 = load i32, ptr %i, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr ptr, ptr %11, i64 %idxprom
  %13 = load ptr, ptr %arrayidx, align 8
  %cmp5 = icmp ne ptr %13, null
  br i1 %cmp5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %for.body4
  %14 = load ptr, ptr %n.addr, align 8
  %sq7 = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 36
  %15 = load ptr, ptr %sq7, align 16
  %16 = load i32, ptr %i, align 4
  %idxprom8 = sext i32 %16 to i64
  %arrayidx9 = getelementptr ptr, ptr %15, i64 %idxprom8
  %17 = load ptr, ptr %arrayidx9, align 8
  %18 = load ptr, ptr %n.addr, align 8
  call void @nvme_free_sq(ptr noundef %17, ptr noundef %18)
  br label %if.end10

if.end10:                                         ; preds = %if.then6, %for.body4
  br label %for.inc11

for.inc11:                                        ; preds = %if.end10
  %19 = load i32, ptr %i, align 4
  %inc12 = add i32 %19, 1
  store i32 %inc12, ptr %i, align 4
  br label %for.cond2, !llvm.loop !18

for.end13:                                        ; preds = %for.cond2
  store i32 0, ptr %i, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc28, %for.end13
  %20 = load i32, ptr %i, align 4
  %21 = load ptr, ptr %n.addr, align 8
  %params15 = getelementptr inbounds %struct.NvmeCtrl, ptr %21, i32 0, i32 4
  %max_ioqpairs16 = getelementptr inbounds %struct.NvmeParams, ptr %params15, i32 0, i32 2
  %22 = load i32, ptr %max_ioqpairs16, align 4
  %add17 = add i32 %22, 1
  %cmp18 = icmp ult i32 %20, %add17
  br i1 %cmp18, label %for.body19, label %for.end30

for.body19:                                       ; preds = %for.cond14
  %23 = load ptr, ptr %n.addr, align 8
  %cq = getelementptr inbounds %struct.NvmeCtrl, ptr %23, i32 0, i32 37
  %24 = load ptr, ptr %cq, align 8
  %25 = load i32, ptr %i, align 4
  %idxprom20 = sext i32 %25 to i64
  %arrayidx21 = getelementptr ptr, ptr %24, i64 %idxprom20
  %26 = load ptr, ptr %arrayidx21, align 8
  %cmp22 = icmp ne ptr %26, null
  br i1 %cmp22, label %if.then23, label %if.end27

if.then23:                                        ; preds = %for.body19
  %27 = load ptr, ptr %n.addr, align 8
  %cq24 = getelementptr inbounds %struct.NvmeCtrl, ptr %27, i32 0, i32 37
  %28 = load ptr, ptr %cq24, align 8
  %29 = load i32, ptr %i, align 4
  %idxprom25 = sext i32 %29 to i64
  %arrayidx26 = getelementptr ptr, ptr %28, i64 %idxprom25
  %30 = load ptr, ptr %arrayidx26, align 8
  %31 = load ptr, ptr %n.addr, align 8
  call void @nvme_free_cq(ptr noundef %30, ptr noundef %31)
  br label %if.end27

if.end27:                                         ; preds = %if.then23, %for.body19
  br label %for.inc28

for.inc28:                                        ; preds = %if.end27
  %32 = load i32, ptr %i, align 4
  %inc29 = add i32 %32, 1
  store i32 %inc29, ptr %i, align 4
  br label %for.cond14, !llvm.loop !19

for.end30:                                        ; preds = %for.cond14
  br label %while.cond

while.cond:                                       ; preds = %do.end, %for.end30
  %33 = load ptr, ptr %n.addr, align 8
  %aer_queue = getelementptr inbounds %struct.NvmeCtrl, ptr %33, i32 0, i32 29
  %34 = load ptr, ptr %aer_queue, align 8
  %cmp31 = icmp eq ptr %34, null
  %lnot = xor i1 %cmp31, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %35 = load ptr, ptr %n.addr, align 8
  %aer_queue32 = getelementptr inbounds %struct.NvmeCtrl, ptr %35, i32 0, i32 29
  %36 = load ptr, ptr %aer_queue32, align 8
  store ptr %36, ptr %event, align 8
  br label %do.body

do.body:                                          ; preds = %while.body
  %37 = load ptr, ptr %event, align 8
  %entry33 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %37, i32 0, i32 0
  %38 = load ptr, ptr %entry33, align 8
  %cmp34 = icmp ne ptr %38, null
  br i1 %cmp34, label %if.then35, label %if.else

if.then35:                                        ; preds = %do.body
  %39 = load ptr, ptr %event, align 8
  %entry36 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %39, i32 0, i32 0
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %entry36, i32 0, i32 1
  %40 = load ptr, ptr %tql_prev, align 8
  %41 = load ptr, ptr %event, align 8
  %entry37 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %41, i32 0, i32 0
  %42 = load ptr, ptr %entry37, align 8
  %entry38 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %42, i32 0, i32 0
  %tql_prev39 = getelementptr inbounds %struct.QTailQLink, ptr %entry38, i32 0, i32 1
  store ptr %40, ptr %tql_prev39, align 8
  br label %if.end44

if.else:                                          ; preds = %do.body
  %43 = load ptr, ptr %event, align 8
  %entry40 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %43, i32 0, i32 0
  %tql_prev41 = getelementptr inbounds %struct.QTailQLink, ptr %entry40, i32 0, i32 1
  %44 = load ptr, ptr %tql_prev41, align 8
  %45 = load ptr, ptr %n.addr, align 8
  %aer_queue42 = getelementptr inbounds %struct.NvmeCtrl, ptr %45, i32 0, i32 29
  %tql_prev43 = getelementptr inbounds %struct.QTailQLink, ptr %aer_queue42, i32 0, i32 1
  store ptr %44, ptr %tql_prev43, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.else, %if.then35
  %46 = load ptr, ptr %event, align 8
  %entry45 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %46, i32 0, i32 0
  %47 = load ptr, ptr %entry45, align 8
  %48 = load ptr, ptr %event, align 8
  %entry46 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %48, i32 0, i32 0
  %tql_prev47 = getelementptr inbounds %struct.QTailQLink, ptr %entry46, i32 0, i32 1
  %49 = load ptr, ptr %tql_prev47, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %49, i32 0, i32 0
  store ptr %47, ptr %tql_next, align 8
  %50 = load ptr, ptr %event, align 8
  %entry48 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %50, i32 0, i32 0
  %tql_prev49 = getelementptr inbounds %struct.QTailQLink, ptr %entry48, i32 0, i32 1
  store ptr null, ptr %tql_prev49, align 8
  %51 = load ptr, ptr %event, align 8
  %entry50 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %51, i32 0, i32 0
  %tql_next51 = getelementptr inbounds %struct.QTailQLink, ptr %entry50, i32 0, i32 0
  store ptr null, ptr %tql_next51, align 8
  %52 = load ptr, ptr %event, align 8
  %entry52 = getelementptr inbounds %struct.NvmeAsyncEvent, ptr %52, i32 0, i32 0
  store ptr null, ptr %entry52, align 8
  br label %do.end

do.end:                                           ; preds = %if.end44
  %53 = load ptr, ptr %event, align 8
  call void @g_free(ptr noundef %53)
  br label %while.cond, !llvm.loop !20

while.end:                                        ; preds = %while.cond
  %54 = load ptr, ptr %n.addr, align 8
  %params53 = getelementptr inbounds %struct.NvmeCtrl, ptr %54, i32 0, i32 4
  %sriov_max_vfs = getelementptr inbounds %struct.NvmeParams, ptr %params53, i32 0, i32 14
  %55 = load i8, ptr %sriov_max_vfs, align 1
  %tobool54 = icmp ne i8 %55, 0
  br i1 %tobool54, label %if.then55, label %if.end80

if.then55:                                        ; preds = %while.end
  %56 = load ptr, ptr %pci_dev, align 8
  %call56 = call i32 @pci_is_vf(ptr noundef %56)
  %tobool57 = icmp ne i32 %call56, 0
  br i1 %tobool57, label %if.end75, label %if.then58

if.then58:                                        ; preds = %if.then55
  store i32 0, ptr %i, align 4
  br label %for.cond59

for.cond59:                                       ; preds = %for.inc68, %if.then58
  %57 = load i32, ptr %i, align 4
  %58 = load ptr, ptr %n.addr, align 8
  %sec_ctrl_list = getelementptr inbounds %struct.NvmeCtrl, ptr %58, i32 0, i32 43
  %numcntl = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %sec_ctrl_list, i32 0, i32 0
  %59 = load i8, ptr %numcntl, align 8
  %conv = zext i8 %59 to i32
  %cmp60 = icmp slt i32 %57, %conv
  br i1 %cmp60, label %for.body62, label %for.end70

for.body62:                                       ; preds = %for.cond59
  %60 = load ptr, ptr %n.addr, align 8
  %sec_ctrl_list63 = getelementptr inbounds %struct.NvmeCtrl, ptr %60, i32 0, i32 43
  %sec = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %sec_ctrl_list63, i32 0, i32 2
  %61 = load i32, ptr %i, align 4
  %idxprom64 = sext i32 %61 to i64
  %arrayidx65 = getelementptr [127 x %struct.NvmeSecCtrlEntry], ptr %sec, i64 0, i64 %idxprom64
  store ptr %arrayidx65, ptr %sctrl, align 8
  %62 = load ptr, ptr %n.addr, align 8
  %63 = load ptr, ptr %sctrl, align 8
  %scid = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %63, i32 0, i32 0
  %64 = load i16, ptr %scid, align 1
  %call66 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %64)
  %call67 = call zeroext i16 @nvme_virt_set_state(ptr noundef %62, i16 noundef zeroext %call66, i1 noundef zeroext false)
  br label %for.inc68

for.inc68:                                        ; preds = %for.body62
  %65 = load i32, ptr %i, align 4
  %inc69 = add i32 %65, 1
  store i32 %inc69, ptr %i, align 4
  br label %for.cond59, !llvm.loop !21

for.end70:                                        ; preds = %for.cond59
  %66 = load i32, ptr %rst.addr, align 4
  %cmp71 = icmp ne i32 %66, 1
  br i1 %cmp71, label %if.then73, label %if.end74

if.then73:                                        ; preds = %for.end70
  %67 = load ptr, ptr %pci_dev, align 8
  call void @pcie_sriov_pf_disable_vfs(ptr noundef %67)
  br label %if.end74

if.end74:                                         ; preds = %if.then73, %for.end70
  br label %if.end75

if.end75:                                         ; preds = %if.end74, %if.then55
  %68 = load i32, ptr %rst.addr, align 4
  %cmp76 = icmp ne i32 %68, 1
  br i1 %cmp76, label %if.then78, label %if.end79

if.then78:                                        ; preds = %if.end75
  %69 = load ptr, ptr %n.addr, align 8
  call void @nvme_activate_virt_res(ptr noundef %69)
  br label %if.end79

if.end79:                                         ; preds = %if.then78, %if.end75
  br label %if.end80

if.end80:                                         ; preds = %if.end79, %while.end
  %70 = load ptr, ptr %n.addr, align 8
  %aer_queued = getelementptr inbounds %struct.NvmeCtrl, ptr %70, i32 0, i32 30
  store i32 0, ptr %aer_queued, align 8
  %71 = load ptr, ptr %n.addr, align 8
  %aer_mask = getelementptr inbounds %struct.NvmeCtrl, ptr %71, i32 0, i32 27
  store i8 0, ptr %aer_mask, align 8
  %72 = load ptr, ptr %n.addr, align 8
  %outstanding_aers = getelementptr inbounds %struct.NvmeCtrl, ptr %72, i32 0, i32 12
  store i8 0, ptr %outstanding_aers, align 8
  %73 = load ptr, ptr %n.addr, align 8
  %qs_created = getelementptr inbounds %struct.NvmeCtrl, ptr %73, i32 0, i32 7
  store i8 0, ptr %qs_created, align 2
  %74 = load ptr, ptr %pci_dev, align 8
  %75 = load ptr, ptr %n.addr, align 8
  %conf_msix_qsize = getelementptr inbounds %struct.NvmeCtrl, ptr %75, i32 0, i32 20
  %76 = load i32, ptr %conf_msix_qsize, align 4
  call void @nvme_update_msixcap_ts(ptr noundef %74, i32 noundef %76)
  %77 = load ptr, ptr %pci_dev, align 8
  %call81 = call i32 @pci_is_vf(ptr noundef %77)
  %tobool82 = icmp ne i32 %call81, 0
  br i1 %tobool82, label %if.then83, label %if.else87

if.then83:                                        ; preds = %if.end80
  %78 = load ptr, ptr %n.addr, align 8
  %call84 = call ptr @nvme_sctrl(ptr noundef %78)
  store ptr %call84, ptr %sctrl, align 8
  %79 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %79, i32 0, i32 3
  %csts = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 6
  %80 = load ptr, ptr %sctrl, align 8
  %scs = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %80, i32 0, i32 2
  %81 = load i8, ptr %scs, align 1
  %conv85 = zext i8 %81 to i32
  %tobool86 = icmp ne i32 %conv85, 0
  %cond = select i1 %tobool86, i32 0, i32 2
  call void @stl_le_p(ptr noundef %csts, i32 noundef %cond)
  br label %if.end90

if.else87:                                        ; preds = %if.end80
  %82 = load ptr, ptr %n.addr, align 8
  %bar88 = getelementptr inbounds %struct.NvmeCtrl, ptr %82, i32 0, i32 3
  %csts89 = getelementptr inbounds %struct.NvmeBar, ptr %bar88, i32 0, i32 6
  call void @stl_le_p(ptr noundef %csts89, i32 noundef 0)
  br label %if.end90

if.end90:                                         ; preds = %if.else87, %if.then83
  %83 = load ptr, ptr %n.addr, align 8
  %bar91 = getelementptr inbounds %struct.NvmeCtrl, ptr %83, i32 0, i32 3
  %intms = getelementptr inbounds %struct.NvmeBar, ptr %bar91, i32 0, i32 2
  call void @stl_le_p(ptr noundef %intms, i32 noundef 0)
  %84 = load ptr, ptr %n.addr, align 8
  %bar92 = getelementptr inbounds %struct.NvmeCtrl, ptr %84, i32 0, i32 3
  %intmc = getelementptr inbounds %struct.NvmeBar, ptr %bar92, i32 0, i32 3
  call void @stl_le_p(ptr noundef %intmc, i32 noundef 0)
  %85 = load ptr, ptr %n.addr, align 8
  %bar93 = getelementptr inbounds %struct.NvmeCtrl, ptr %85, i32 0, i32 3
  %cc = getelementptr inbounds %struct.NvmeBar, ptr %bar93, i32 0, i32 4
  call void @stl_le_p(ptr noundef %cc, i32 noundef 0)
  %86 = load ptr, ptr %n.addr, align 8
  %dbbuf_dbs = getelementptr inbounds %struct.NvmeCtrl, ptr %86, i32 0, i32 22
  store i64 0, ptr %dbbuf_dbs, align 16
  %87 = load ptr, ptr %n.addr, align 8
  %dbbuf_eis = getelementptr inbounds %struct.NvmeCtrl, ptr %87, i32 0, i32 23
  store i64 0, ptr %dbbuf_eis, align 8
  %88 = load ptr, ptr %n.addr, align 8
  %dbbuf_enabled = getelementptr inbounds %struct.NvmeCtrl, ptr %88, i32 0, i32 24
  store i8 0, ptr %dbbuf_enabled, align 16
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_ssreset_w1c_unsupported() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_ssreset_w1c_unsupported()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_ro_csts() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_ro_csts()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_ssreset_unsupported() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_ssreset_unsupported()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_aqattr(i64 noundef %data) #0 {
entry:
  %data.addr = alloca i64, align 8
  store i64 %data, ptr %data.addr, align 8
  %0 = load i64, ptr %data.addr, align 8
  call void @_nocheck__trace_pci_nvme_mmio_aqattr(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stn_le_p(ptr noundef %ptr, i32 noundef %sz, i64 noundef %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %v.addr = alloca i64, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  store i64 %v, ptr %v.addr, align 8
  %0 = load i32, ptr %sz.addr, align 4
  switch i32 %0, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb1
    i32 4, label %sw.bb3
    i32 8, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  %1 = load ptr, ptr %ptr.addr, align 8
  %2 = load i64, ptr %v.addr, align 8
  %conv = trunc i64 %2 to i8
  call void @stb_p(ptr noundef %1, i8 noundef zeroext %conv)
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %3 = load ptr, ptr %ptr.addr, align 8
  %4 = load i64, ptr %v.addr, align 8
  %conv2 = trunc i64 %4 to i16
  call void @stw_le_p(ptr noundef %3, i16 noundef zeroext %conv2)
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %5 = load ptr, ptr %ptr.addr, align 8
  %6 = load i64, ptr %v.addr, align 8
  %conv4 = trunc i64 %6 to i32
  call void @stl_le_p(ptr noundef %5, i32 noundef %conv4)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %7 = load ptr, ptr %ptr.addr, align 8
  %8 = load i64, ptr %v.addr, align 8
  call void @stq_le_p(ptr noundef %7, i64 noundef %8)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.104, i32 noundef 419, ptr noundef @__func__.stn_le_p, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb5, %sw.bb3, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_asqaddr(i64 noundef %data) #0 {
entry:
  %data.addr = alloca i64, align 8
  store i64 %data, ptr %data.addr, align 8
  %0 = load i64, ptr %data.addr, align 8
  call void @_nocheck__trace_pci_nvme_mmio_asqaddr(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_asqaddr_hi(i64 noundef %data, i64 noundef %new_addr) #0 {
entry:
  %data.addr = alloca i64, align 8
  %new_addr.addr = alloca i64, align 8
  store i64 %data, ptr %data.addr, align 8
  store i64 %new_addr, ptr %new_addr.addr, align 8
  %0 = load i64, ptr %data.addr, align 8
  %1 = load i64, ptr %new_addr.addr, align 8
  call void @_nocheck__trace_pci_nvme_mmio_asqaddr_hi(i64 noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_acqaddr(i64 noundef %data) #0 {
entry:
  %data.addr = alloca i64, align 8
  store i64 %data, ptr %data.addr, align 8
  %0 = load i64, ptr %data.addr, align 8
  call void @_nocheck__trace_pci_nvme_mmio_acqaddr(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_acqaddr_hi(i64 noundef %data, i64 noundef %new_addr) #0 {
entry:
  %data.addr = alloca i64, align 8
  %new_addr.addr = alloca i64, align 8
  store i64 %data, ptr %data.addr, align 8
  store i64 %new_addr, ptr %new_addr.addr, align 8
  %0 = load i64, ptr %data.addr, align 8
  %1 = load i64, ptr %new_addr.addr, align 8
  call void @_nocheck__trace_pci_nvme_mmio_acqaddr_hi(i64 noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_cmbloc_reserved() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_cmbloc_reserved()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_cmbsz_readonly() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_cmbsz_readonly()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_cmb_enable_regs(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %cmbloc = alloca i32, align 4
  %cmbsz = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 3
  %cmbloc1 = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 11
  %call = call i32 @ldl_le_p(ptr noundef %cmbloc1)
  store i32 %call, ptr %cmbloc, align 4
  %1 = load ptr, ptr %n.addr, align 8
  %bar2 = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 3
  %cmbsz3 = getelementptr inbounds %struct.NvmeBar, ptr %bar2, i32 0, i32 12
  %call4 = call i32 @ldl_le_p(ptr noundef %cmbsz3)
  store i32 %call4, ptr %cmbsz, align 4
  %2 = load i32, ptr %cmbloc, align 4
  %conv = zext i32 %2 to i64
  %or = or i64 %conv, 64
  %conv5 = trunc i64 %or to i32
  store i32 %conv5, ptr %cmbloc, align 4
  %3 = load i32, ptr %cmbloc, align 4
  %conv6 = zext i32 %3 to i64
  %or7 = or i64 %conv6, 32
  %conv8 = trunc i64 %or7 to i32
  store i32 %conv8, ptr %cmbloc, align 4
  %4 = load i32, ptr %cmbloc, align 4
  %conv9 = zext i32 %4 to i64
  %or10 = or i64 %conv9, 2
  %conv11 = trunc i64 %or10 to i32
  store i32 %conv11, ptr %cmbloc, align 4
  %5 = load ptr, ptr %n.addr, align 8
  %bar12 = getelementptr inbounds %struct.NvmeCtrl, ptr %5, i32 0, i32 3
  %cmbloc13 = getelementptr inbounds %struct.NvmeBar, ptr %bar12, i32 0, i32 11
  %6 = load i32, ptr %cmbloc, align 4
  call void @stl_le_p(ptr noundef %cmbloc13, i32 noundef %6)
  %7 = load i32, ptr %cmbsz, align 4
  %conv14 = zext i32 %7 to i64
  %or15 = or i64 %conv14, 1
  %conv16 = trunc i64 %or15 to i32
  store i32 %conv16, ptr %cmbsz, align 4
  %8 = load i32, ptr %cmbsz, align 4
  %conv17 = zext i32 %8 to i64
  %or18 = or i64 %conv17, 0
  %conv19 = trunc i64 %or18 to i32
  store i32 %conv19, ptr %cmbsz, align 4
  %9 = load i32, ptr %cmbsz, align 4
  %conv20 = zext i32 %9 to i64
  %or21 = or i64 %conv20, 4
  %conv22 = trunc i64 %or21 to i32
  store i32 %conv22, ptr %cmbsz, align 4
  %10 = load i32, ptr %cmbsz, align 4
  %conv23 = zext i32 %10 to i64
  %or24 = or i64 %conv23, 8
  %conv25 = trunc i64 %or24 to i32
  store i32 %conv25, ptr %cmbsz, align 4
  %11 = load i32, ptr %cmbsz, align 4
  %conv26 = zext i32 %11 to i64
  %or27 = or i64 %conv26, 16
  %conv28 = trunc i64 %or27 to i32
  store i32 %conv28, ptr %cmbsz, align 4
  %12 = load i32, ptr %cmbsz, align 4
  %conv29 = zext i32 %12 to i64
  %or30 = or i64 %conv29, 512
  %conv31 = trunc i64 %or30 to i32
  store i32 %conv31, ptr %cmbsz, align 4
  %13 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %13, i32 0, i32 4
  %cmb_size_mb = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 4
  %14 = load i32, ptr %cmb_size_mb, align 4
  %and = and i32 %14, 1048575
  %conv32 = zext i32 %and to i64
  %shl = shl i64 %conv32, 12
  %15 = load i32, ptr %cmbsz, align 4
  %conv33 = zext i32 %15 to i64
  %or34 = or i64 %conv33, %shl
  %conv35 = trunc i64 %or34 to i32
  store i32 %conv35, ptr %cmbsz, align 4
  %16 = load ptr, ptr %n.addr, align 8
  %bar36 = getelementptr inbounds %struct.NvmeCtrl, ptr %16, i32 0, i32 3
  %cmbsz37 = getelementptr inbounds %struct.NvmeBar, ptr %bar36, i32 0, i32 12
  %17 = load i32, ptr %cmbsz, align 4
  call void @stl_le_p(ptr noundef %cmbsz37, i32 noundef %17)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_pmrcap_readonly() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_pmrcap_readonly()
  ret void
}

declare void @memory_region_set_enabled(ptr noundef, i1 noundef zeroext) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_pmrsts_readonly() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_pmrsts_readonly()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_pmrebs_readonly() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_pmrebs_readonly()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_pmrswtp_readonly() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_pmrswtp_readonly()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_mmiowr_invalid(i64 noundef %offset, i64 noundef %data) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %data.addr = alloca i64, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %data, ptr %data.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  %1 = load i64, ptr %data.addr, align 8
  call void @_nocheck__trace_pci_nvme_ub_mmiowr_invalid(i64 noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_misaligned32(i64 noundef %offset) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %offset.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.120, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %offset.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.121, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_toosmall(i64 noundef %offset, i32 noundef %size) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %offset.addr, align 8
  %6 = load i32, ptr %size.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.122, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %offset.addr, align 8
  %8 = load i32, ptr %size.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.123, i64 noundef %7, i32 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_intmask_with_msix() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.124, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.125)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stl_he_p(ptr noundef %ptr, i32 noundef %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i32, align 4
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %v, ptr %v.addr, align 4
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %0, ptr align 4 %v.addr, i64 4, i1 false)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_intm_set(i64 noundef %data, i64 noundef %new_mask) #0 {
entry:
  %data.addr = alloca i64, align 8
  %new_mask.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %data, ptr %data.addr, align 8
  store i64 %new_mask, ptr %new_mask.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_INTM_SET_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %data.addr, align 8
  %6 = load i64, ptr %new_mask.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.126, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %data.addr, align 8
  %8 = load i64, ptr %new_mask.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.127, i64 noundef %7, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @pci_irq_assert(ptr noundef %pci_dev) #0 {
entry:
  %pci_dev.addr = alloca ptr, align 8
  store ptr %pci_dev, ptr %pci_dev.addr, align 8
  %0 = load ptr, ptr %pci_dev.addr, align 8
  call void @pci_set_irq(ptr noundef %0, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @pci_irq_deassert(ptr noundef %pci_dev) #0 {
entry:
  %pci_dev.addr = alloca ptr, align 8
  store ptr %pci_dev, ptr %pci_dev.addr, align 8
  %0 = load ptr, ptr %pci_dev.addr, align 8
  call void @pci_set_irq(ptr noundef %0, i32 noundef 0)
  ret void
}

declare void @pci_set_irq(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_intm_clr(i64 noundef %data, i64 noundef %new_mask) #0 {
entry:
  %data.addr = alloca i64, align 8
  %new_mask.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %data, ptr %data.addr, align 8
  store i64 %new_mask, ptr %new_mask.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_INTM_CLR_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %data.addr, align 8
  %6 = load i64, ptr %new_mask.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.128, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %data.addr, align 8
  %8 = load i64, ptr %new_mask.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.129, i64 noundef %7, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_cfg(i64 noundef %data) #0 {
entry:
  %data.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %data, ptr %data.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_CFG_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %data.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.130, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %data.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.131, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_shutdown_set() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_SHUTDOWN_SET_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.132, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.133)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_ns(ptr noundef %n, i32 noundef %nsid) #0 {
entry:
  %retval = alloca ptr, align 8
  %n.addr = alloca ptr, align 8
  %nsid.addr = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store i32 %nsid, ptr %nsid.addr, align 4
  %0 = load i32, ptr %nsid.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %nsid.addr, align 4
  %cmp = icmp ugt i32 %1, 256
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %n.addr, align 8
  %namespaces = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 35
  %3 = load i32, ptr %nsid.addr, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr [257 x ptr], ptr %namespaces, i64 0, i64 %idxprom
  %4 = load ptr, ptr %arrayidx, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

declare void @nvme_ns_shutdown(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_shutdown_cleared() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.134, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.135)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_startfail_virt_state(i16 noundef zeroext %vq, i16 noundef zeroext %vi) #0 {
entry:
  %vq.addr = alloca i16, align 2
  %vi.addr = alloca i16, align 2
  store i16 %vq, ptr %vq.addr, align 2
  store i16 %vi, ptr %vi.addr, align 2
  %0 = load i16, ptr %vq.addr, align 2
  %1 = load i16, ptr %vi.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_startfail_virt_state(i16 noundef zeroext %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_startfail_cq() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_err_startfail_cq()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_startfail_sq() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_err_startfail_sq()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_startfail_asq_misaligned(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i64, ptr %addr.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_startfail_asq_misaligned(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_startfail_acq_misaligned(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i64, ptr %addr.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_startfail_acq_misaligned(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_startfail_css(i8 noundef zeroext %css) #0 {
entry:
  %css.addr = alloca i8, align 1
  store i8 %css, ptr %css.addr, align 1
  %0 = load i8, ptr %css.addr, align 1
  call void @_nocheck__trace_pci_nvme_err_startfail_css(i8 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_startfail_page_too_small(i8 noundef zeroext %log2ps, i8 noundef zeroext %maxlog2ps) #0 {
entry:
  %log2ps.addr = alloca i8, align 1
  %maxlog2ps.addr = alloca i8, align 1
  store i8 %log2ps, ptr %log2ps.addr, align 1
  store i8 %maxlog2ps, ptr %maxlog2ps.addr, align 1
  %0 = load i8, ptr %log2ps.addr, align 1
  %1 = load i8, ptr %maxlog2ps.addr, align 1
  call void @_nocheck__trace_pci_nvme_err_startfail_page_too_small(i8 noundef zeroext %0, i8 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_startfail_page_too_large(i8 noundef zeroext %log2ps, i8 noundef zeroext %maxlog2ps) #0 {
entry:
  %log2ps.addr = alloca i8, align 1
  %maxlog2ps.addr = alloca i8, align 1
  store i8 %log2ps, ptr %log2ps.addr, align 1
  store i8 %maxlog2ps, ptr %maxlog2ps.addr, align 1
  %0 = load i8, ptr %log2ps.addr, align 1
  %1 = load i8, ptr %maxlog2ps.addr, align 1
  call void @_nocheck__trace_pci_nvme_err_startfail_page_too_large(i8 noundef zeroext %0, i8 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_startfail_asqent_sz_zero() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_err_startfail_asqent_sz_zero()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_startfail_acqent_sz_zero() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_err_startfail_acqent_sz_zero()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_init_cq(ptr noundef %cq, ptr noundef %n, i64 noundef %dma_addr, i16 noundef zeroext %cqid, i16 noundef zeroext %vector, i16 noundef zeroext %size, i16 noundef zeroext %irq_enabled) #0 {
entry:
  %cq.addr = alloca ptr, align 8
  %n.addr = alloca ptr, align 8
  %dma_addr.addr = alloca i64, align 8
  %cqid.addr = alloca i16, align 2
  %vector.addr = alloca i16, align 2
  %size.addr = alloca i16, align 2
  %irq_enabled.addr = alloca i16, align 2
  %pci = alloca ptr, align 8
  store ptr %cq, ptr %cq.addr, align 8
  store ptr %n, ptr %n.addr, align 8
  store i64 %dma_addr, ptr %dma_addr.addr, align 8
  store i16 %cqid, ptr %cqid.addr, align 2
  store i16 %vector, ptr %vector.addr, align 2
  store i16 %size, ptr %size.addr, align 2
  store i16 %irq_enabled, ptr %irq_enabled.addr, align 2
  %0 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %0)
  store ptr %call, ptr %pci, align 8
  %1 = load ptr, ptr %pci, align 8
  %call1 = call i32 @msix_enabled(ptr noundef %1)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %pci, align 8
  %3 = load i16, ptr %vector.addr, align 2
  %conv = zext i16 %3 to i32
  call void @msix_vector_use(ptr noundef %2, i32 noundef %conv)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %n.addr, align 8
  %5 = load ptr, ptr %cq.addr, align 8
  %ctrl = getelementptr inbounds %struct.NvmeCQueue, ptr %5, i32 0, i32 0
  store ptr %4, ptr %ctrl, align 8
  %6 = load i16, ptr %cqid.addr, align 2
  %7 = load ptr, ptr %cq.addr, align 8
  %cqid2 = getelementptr inbounds %struct.NvmeCQueue, ptr %7, i32 0, i32 2
  store i16 %6, ptr %cqid2, align 2
  %8 = load i16, ptr %size.addr, align 2
  %conv3 = zext i16 %8 to i32
  %9 = load ptr, ptr %cq.addr, align 8
  %size4 = getelementptr inbounds %struct.NvmeCQueue, ptr %9, i32 0, i32 7
  store i32 %conv3, ptr %size4, align 4
  %10 = load i64, ptr %dma_addr.addr, align 8
  %11 = load ptr, ptr %cq.addr, align 8
  %dma_addr5 = getelementptr inbounds %struct.NvmeCQueue, ptr %11, i32 0, i32 8
  store i64 %10, ptr %dma_addr5, align 8
  %12 = load ptr, ptr %cq.addr, align 8
  %phase = getelementptr inbounds %struct.NvmeCQueue, ptr %12, i32 0, i32 1
  store i8 1, ptr %phase, align 8
  %13 = load i16, ptr %irq_enabled.addr, align 2
  %14 = load ptr, ptr %cq.addr, align 8
  %irq_enabled6 = getelementptr inbounds %struct.NvmeCQueue, ptr %14, i32 0, i32 3
  store i16 %13, ptr %irq_enabled6, align 4
  %15 = load i16, ptr %vector.addr, align 2
  %conv7 = zext i16 %15 to i32
  %16 = load ptr, ptr %cq.addr, align 8
  %vector8 = getelementptr inbounds %struct.NvmeCQueue, ptr %16, i32 0, i32 6
  store i32 %conv7, ptr %vector8, align 8
  %17 = load ptr, ptr %cq.addr, align 8
  %tail = getelementptr inbounds %struct.NvmeCQueue, ptr %17, i32 0, i32 5
  store i32 0, ptr %tail, align 4
  %18 = load ptr, ptr %cq.addr, align 8
  %head = getelementptr inbounds %struct.NvmeCQueue, ptr %18, i32 0, i32 4
  store i32 0, ptr %head, align 8
  br label %do.body

do.body:                                          ; preds = %if.end
  %19 = load ptr, ptr %cq.addr, align 8
  %req_list = getelementptr inbounds %struct.NvmeCQueue, ptr %19, i32 0, i32 15
  store ptr null, ptr %req_list, align 8
  %20 = load ptr, ptr %cq.addr, align 8
  %req_list9 = getelementptr inbounds %struct.NvmeCQueue, ptr %20, i32 0, i32 15
  %21 = load ptr, ptr %cq.addr, align 8
  %req_list10 = getelementptr inbounds %struct.NvmeCQueue, ptr %21, i32 0, i32 15
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %req_list10, i32 0, i32 1
  store ptr %req_list9, ptr %tql_prev, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body11

do.body11:                                        ; preds = %do.end
  %22 = load ptr, ptr %cq.addr, align 8
  %sq_list = getelementptr inbounds %struct.NvmeCQueue, ptr %22, i32 0, i32 14
  store ptr null, ptr %sq_list, align 8
  %23 = load ptr, ptr %cq.addr, align 8
  %sq_list12 = getelementptr inbounds %struct.NvmeCQueue, ptr %23, i32 0, i32 14
  %24 = load ptr, ptr %cq.addr, align 8
  %sq_list13 = getelementptr inbounds %struct.NvmeCQueue, ptr %24, i32 0, i32 14
  %tql_prev14 = getelementptr inbounds %struct.QTailQLink, ptr %sq_list13, i32 0, i32 1
  store ptr %sq_list12, ptr %tql_prev14, align 8
  br label %do.end15

do.end15:                                         ; preds = %do.body11
  %25 = load ptr, ptr %n.addr, align 8
  %dbbuf_enabled = getelementptr inbounds %struct.NvmeCtrl, ptr %25, i32 0, i32 24
  %26 = load i8, ptr %dbbuf_enabled, align 16
  %tobool16 = trunc i8 %26 to i1
  br i1 %tobool16, label %if.then17, label %if.end36

if.then17:                                        ; preds = %do.end15
  %27 = load ptr, ptr %n.addr, align 8
  %dbbuf_dbs = getelementptr inbounds %struct.NvmeCtrl, ptr %27, i32 0, i32 22
  %28 = load i64, ptr %dbbuf_dbs, align 16
  %29 = load i16, ptr %cqid.addr, align 2
  %conv18 = zext i16 %29 to i32
  %shl = shl i32 %conv18, 3
  %conv19 = sext i32 %shl to i64
  %add = add i64 %28, %conv19
  %add20 = add i64 %add, 4
  %30 = load ptr, ptr %cq.addr, align 8
  %db_addr = getelementptr inbounds %struct.NvmeCQueue, ptr %30, i32 0, i32 9
  store i64 %add20, ptr %db_addr, align 8
  %31 = load ptr, ptr %n.addr, align 8
  %dbbuf_eis = getelementptr inbounds %struct.NvmeCtrl, ptr %31, i32 0, i32 23
  %32 = load i64, ptr %dbbuf_eis, align 8
  %33 = load i16, ptr %cqid.addr, align 2
  %conv21 = zext i16 %33 to i32
  %shl22 = shl i32 %conv21, 3
  %conv23 = sext i32 %shl22 to i64
  %add24 = add i64 %32, %conv23
  %add25 = add i64 %add24, 4
  %34 = load ptr, ptr %cq.addr, align 8
  %ei_addr = getelementptr inbounds %struct.NvmeCQueue, ptr %34, i32 0, i32 10
  store i64 %add25, ptr %ei_addr, align 8
  %35 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %35, i32 0, i32 4
  %ioeventfd = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 13
  %36 = load i8, ptr %ioeventfd, align 2
  %tobool26 = trunc i8 %36 to i1
  br i1 %tobool26, label %land.lhs.true, label %if.end35

land.lhs.true:                                    ; preds = %if.then17
  %37 = load i16, ptr %cqid.addr, align 2
  %conv28 = zext i16 %37 to i32
  %cmp = icmp ne i32 %conv28, 0
  br i1 %cmp, label %if.then30, label %if.end35

if.then30:                                        ; preds = %land.lhs.true
  %38 = load ptr, ptr %cq.addr, align 8
  %call31 = call i32 @nvme_init_cq_ioeventfd(ptr noundef %38)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %if.then30
  %39 = load ptr, ptr %cq.addr, align 8
  %ioeventfd_enabled = getelementptr inbounds %struct.NvmeCQueue, ptr %39, i32 0, i32 13
  store i8 1, ptr %ioeventfd_enabled, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %land.lhs.true, %if.then17
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %do.end15
  %40 = load ptr, ptr %cq.addr, align 8
  %41 = load ptr, ptr %n.addr, align 8
  %cq37 = getelementptr inbounds %struct.NvmeCtrl, ptr %41, i32 0, i32 37
  %42 = load ptr, ptr %cq37, align 8
  %43 = load i16, ptr %cqid.addr, align 2
  %idxprom = zext i16 %43 to i64
  %arrayidx = getelementptr ptr, ptr %42, i64 %idxprom
  store ptr %40, ptr %arrayidx, align 8
  %44 = load ptr, ptr %cq.addr, align 8
  %45 = load ptr, ptr %cq.addr, align 8
  %ctrl38 = getelementptr inbounds %struct.NvmeCQueue, ptr %45, i32 0, i32 0
  %46 = load ptr, ptr %ctrl38, align 8
  %call39 = call ptr @DEVICE(ptr noundef %46)
  %mem_reentrancy_guard = getelementptr inbounds %struct.DeviceState, ptr %call39, i32 0, i32 18
  %call40 = call ptr @qemu_bh_new_full(ptr noundef @nvme_post_cqes, ptr noundef %44, ptr noundef @.str.156, ptr noundef %mem_reentrancy_guard)
  %47 = load ptr, ptr %cq.addr, align 8
  %bh = getelementptr inbounds %struct.NvmeCQueue, ptr %47, i32 0, i32 11
  store ptr %call40, ptr %bh, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_init_sq(ptr noundef %sq, ptr noundef %n, i64 noundef %dma_addr, i16 noundef zeroext %sqid, i16 noundef zeroext %cqid, i16 noundef zeroext %size) #0 {
entry:
  %sq.addr = alloca ptr, align 8
  %n.addr = alloca ptr, align 8
  %dma_addr.addr = alloca i64, align 8
  %sqid.addr = alloca i16, align 2
  %cqid.addr = alloca i16, align 2
  %size.addr = alloca i16, align 2
  %i = alloca i32, align 4
  %cq = alloca ptr, align 8
  store ptr %sq, ptr %sq.addr, align 8
  store ptr %n, ptr %n.addr, align 8
  store i64 %dma_addr, ptr %dma_addr.addr, align 8
  store i16 %sqid, ptr %sqid.addr, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  store i16 %size, ptr %size.addr, align 2
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load ptr, ptr %sq.addr, align 8
  %ctrl = getelementptr inbounds %struct.NvmeSQueue, ptr %1, i32 0, i32 0
  store ptr %0, ptr %ctrl, align 8
  %2 = load i64, ptr %dma_addr.addr, align 8
  %3 = load ptr, ptr %sq.addr, align 8
  %dma_addr1 = getelementptr inbounds %struct.NvmeSQueue, ptr %3, i32 0, i32 6
  store i64 %2, ptr %dma_addr1, align 8
  %4 = load i16, ptr %sqid.addr, align 2
  %5 = load ptr, ptr %sq.addr, align 8
  %sqid2 = getelementptr inbounds %struct.NvmeSQueue, ptr %5, i32 0, i32 1
  store i16 %4, ptr %sqid2, align 8
  %6 = load i16, ptr %size.addr, align 2
  %conv = zext i16 %6 to i32
  %7 = load ptr, ptr %sq.addr, align 8
  %size3 = getelementptr inbounds %struct.NvmeSQueue, ptr %7, i32 0, i32 5
  store i32 %conv, ptr %size3, align 4
  %8 = load i16, ptr %cqid.addr, align 2
  %9 = load ptr, ptr %sq.addr, align 8
  %cqid4 = getelementptr inbounds %struct.NvmeSQueue, ptr %9, i32 0, i32 2
  store i16 %8, ptr %cqid4, align 2
  %10 = load ptr, ptr %sq.addr, align 8
  %tail = getelementptr inbounds %struct.NvmeSQueue, ptr %10, i32 0, i32 4
  store i32 0, ptr %tail, align 8
  %11 = load ptr, ptr %sq.addr, align 8
  %head = getelementptr inbounds %struct.NvmeSQueue, ptr %11, i32 0, i32 3
  store i32 0, ptr %head, align 4
  %12 = load ptr, ptr %sq.addr, align 8
  %size5 = getelementptr inbounds %struct.NvmeSQueue, ptr %12, i32 0, i32 5
  %13 = load i32, ptr %size5, align 4
  %conv6 = zext i32 %13 to i64
  %call = call noalias ptr @g_malloc0_n(i64 noundef %conv6, i64 noundef 208) #11
  %14 = load ptr, ptr %sq.addr, align 8
  %io_req = getelementptr inbounds %struct.NvmeSQueue, ptr %14, i32 0, i32 12
  store ptr %call, ptr %io_req, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %15 = load ptr, ptr %sq.addr, align 8
  %req_list = getelementptr inbounds %struct.NvmeSQueue, ptr %15, i32 0, i32 13
  store ptr null, ptr %req_list, align 8
  %16 = load ptr, ptr %sq.addr, align 8
  %req_list7 = getelementptr inbounds %struct.NvmeSQueue, ptr %16, i32 0, i32 13
  %17 = load ptr, ptr %sq.addr, align 8
  %req_list8 = getelementptr inbounds %struct.NvmeSQueue, ptr %17, i32 0, i32 13
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %req_list8, i32 0, i32 1
  store ptr %req_list7, ptr %tql_prev, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body9

do.body9:                                         ; preds = %do.end
  %18 = load ptr, ptr %sq.addr, align 8
  %out_req_list = getelementptr inbounds %struct.NvmeSQueue, ptr %18, i32 0, i32 14
  store ptr null, ptr %out_req_list, align 8
  %19 = load ptr, ptr %sq.addr, align 8
  %out_req_list10 = getelementptr inbounds %struct.NvmeSQueue, ptr %19, i32 0, i32 14
  %20 = load ptr, ptr %sq.addr, align 8
  %out_req_list11 = getelementptr inbounds %struct.NvmeSQueue, ptr %20, i32 0, i32 14
  %tql_prev12 = getelementptr inbounds %struct.QTailQLink, ptr %out_req_list11, i32 0, i32 1
  store ptr %out_req_list10, ptr %tql_prev12, align 8
  br label %do.end13

do.end13:                                         ; preds = %do.body9
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end13
  %21 = load i32, ptr %i, align 4
  %22 = load ptr, ptr %sq.addr, align 8
  %size14 = getelementptr inbounds %struct.NvmeSQueue, ptr %22, i32 0, i32 5
  %23 = load i32, ptr %size14, align 4
  %cmp = icmp ult i32 %21, %23
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %24 = load ptr, ptr %sq.addr, align 8
  %25 = load ptr, ptr %sq.addr, align 8
  %io_req16 = getelementptr inbounds %struct.NvmeSQueue, ptr %25, i32 0, i32 12
  %26 = load ptr, ptr %io_req16, align 8
  %27 = load i32, ptr %i, align 4
  %idxprom = sext i32 %27 to i64
  %arrayidx = getelementptr %struct.NvmeRequest, ptr %26, i64 %idxprom
  %sq17 = getelementptr inbounds %struct.NvmeRequest, ptr %arrayidx, i32 0, i32 0
  store ptr %24, ptr %sq17, align 8
  br label %do.body18

do.body18:                                        ; preds = %for.body
  %28 = load ptr, ptr %sq.addr, align 8
  %io_req19 = getelementptr inbounds %struct.NvmeSQueue, ptr %28, i32 0, i32 12
  %29 = load ptr, ptr %io_req19, align 8
  %30 = load i32, ptr %i, align 4
  %idxprom20 = sext i32 %30 to i64
  %arrayidx21 = getelementptr %struct.NvmeRequest, ptr %29, i64 %idxprom20
  %entry22 = getelementptr inbounds %struct.NvmeRequest, ptr %arrayidx21, i32 0, i32 9
  store ptr null, ptr %entry22, align 8
  %31 = load ptr, ptr %sq.addr, align 8
  %req_list23 = getelementptr inbounds %struct.NvmeSQueue, ptr %31, i32 0, i32 13
  %tql_prev24 = getelementptr inbounds %struct.QTailQLink, ptr %req_list23, i32 0, i32 1
  %32 = load ptr, ptr %tql_prev24, align 8
  %33 = load ptr, ptr %sq.addr, align 8
  %io_req25 = getelementptr inbounds %struct.NvmeSQueue, ptr %33, i32 0, i32 12
  %34 = load ptr, ptr %io_req25, align 8
  %35 = load i32, ptr %i, align 4
  %idxprom26 = sext i32 %35 to i64
  %arrayidx27 = getelementptr %struct.NvmeRequest, ptr %34, i64 %idxprom26
  %entry28 = getelementptr inbounds %struct.NvmeRequest, ptr %arrayidx27, i32 0, i32 9
  %tql_prev29 = getelementptr inbounds %struct.QTailQLink, ptr %entry28, i32 0, i32 1
  store ptr %32, ptr %tql_prev29, align 8
  %36 = load ptr, ptr %sq.addr, align 8
  %io_req30 = getelementptr inbounds %struct.NvmeSQueue, ptr %36, i32 0, i32 12
  %37 = load ptr, ptr %io_req30, align 8
  %38 = load i32, ptr %i, align 4
  %idxprom31 = sext i32 %38 to i64
  %arrayidx32 = getelementptr %struct.NvmeRequest, ptr %37, i64 %idxprom31
  %39 = load ptr, ptr %sq.addr, align 8
  %req_list33 = getelementptr inbounds %struct.NvmeSQueue, ptr %39, i32 0, i32 13
  %tql_prev34 = getelementptr inbounds %struct.QTailQLink, ptr %req_list33, i32 0, i32 1
  %40 = load ptr, ptr %tql_prev34, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %40, i32 0, i32 0
  store ptr %arrayidx32, ptr %tql_next, align 8
  %41 = load ptr, ptr %sq.addr, align 8
  %io_req35 = getelementptr inbounds %struct.NvmeSQueue, ptr %41, i32 0, i32 12
  %42 = load ptr, ptr %io_req35, align 8
  %43 = load i32, ptr %i, align 4
  %idxprom36 = sext i32 %43 to i64
  %arrayidx37 = getelementptr %struct.NvmeRequest, ptr %42, i64 %idxprom36
  %entry38 = getelementptr inbounds %struct.NvmeRequest, ptr %arrayidx37, i32 0, i32 9
  %44 = load ptr, ptr %sq.addr, align 8
  %req_list39 = getelementptr inbounds %struct.NvmeSQueue, ptr %44, i32 0, i32 13
  %tql_prev40 = getelementptr inbounds %struct.QTailQLink, ptr %req_list39, i32 0, i32 1
  store ptr %entry38, ptr %tql_prev40, align 8
  br label %do.end41

do.end41:                                         ; preds = %do.body18
  br label %for.inc

for.inc:                                          ; preds = %do.end41
  %45 = load i32, ptr %i, align 4
  %inc = add i32 %45, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !22

for.end:                                          ; preds = %for.cond
  %46 = load ptr, ptr %sq.addr, align 8
  %47 = load ptr, ptr %sq.addr, align 8
  %ctrl42 = getelementptr inbounds %struct.NvmeSQueue, ptr %47, i32 0, i32 0
  %48 = load ptr, ptr %ctrl42, align 8
  %call43 = call ptr @DEVICE(ptr noundef %48)
  %mem_reentrancy_guard = getelementptr inbounds %struct.DeviceState, ptr %call43, i32 0, i32 18
  %call44 = call ptr @qemu_bh_new_full(ptr noundef @nvme_process_sq, ptr noundef %46, ptr noundef @.str.172, ptr noundef %mem_reentrancy_guard)
  %49 = load ptr, ptr %sq.addr, align 8
  %bh = getelementptr inbounds %struct.NvmeSQueue, ptr %49, i32 0, i32 9
  store ptr %call44, ptr %bh, align 8
  %50 = load ptr, ptr %n.addr, align 8
  %dbbuf_enabled = getelementptr inbounds %struct.NvmeCtrl, ptr %50, i32 0, i32 24
  %51 = load i8, ptr %dbbuf_enabled, align 16
  %tobool = trunc i8 %51 to i1
  br i1 %tobool, label %if.then, label %if.end62

if.then:                                          ; preds = %for.end
  %52 = load ptr, ptr %n.addr, align 8
  %dbbuf_dbs = getelementptr inbounds %struct.NvmeCtrl, ptr %52, i32 0, i32 22
  %53 = load i64, ptr %dbbuf_dbs, align 16
  %54 = load i16, ptr %sqid.addr, align 2
  %conv45 = zext i16 %54 to i32
  %shl = shl i32 %conv45, 3
  %conv46 = sext i32 %shl to i64
  %add = add i64 %53, %conv46
  %55 = load ptr, ptr %sq.addr, align 8
  %db_addr = getelementptr inbounds %struct.NvmeSQueue, ptr %55, i32 0, i32 7
  store i64 %add, ptr %db_addr, align 8
  %56 = load ptr, ptr %n.addr, align 8
  %dbbuf_eis = getelementptr inbounds %struct.NvmeCtrl, ptr %56, i32 0, i32 23
  %57 = load i64, ptr %dbbuf_eis, align 8
  %58 = load i16, ptr %sqid.addr, align 2
  %conv47 = zext i16 %58 to i32
  %shl48 = shl i32 %conv47, 3
  %conv49 = sext i32 %shl48 to i64
  %add50 = add i64 %57, %conv49
  %59 = load ptr, ptr %sq.addr, align 8
  %ei_addr = getelementptr inbounds %struct.NvmeSQueue, ptr %59, i32 0, i32 8
  store i64 %add50, ptr %ei_addr, align 8
  %60 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %60, i32 0, i32 4
  %ioeventfd = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 13
  %61 = load i8, ptr %ioeventfd, align 2
  %tobool51 = trunc i8 %61 to i1
  br i1 %tobool51, label %land.lhs.true, label %if.end61

land.lhs.true:                                    ; preds = %if.then
  %62 = load ptr, ptr %sq.addr, align 8
  %sqid53 = getelementptr inbounds %struct.NvmeSQueue, ptr %62, i32 0, i32 1
  %63 = load i16, ptr %sqid53, align 8
  %conv54 = zext i16 %63 to i32
  %cmp55 = icmp ne i32 %conv54, 0
  br i1 %cmp55, label %if.then57, label %if.end61

if.then57:                                        ; preds = %land.lhs.true
  %64 = load ptr, ptr %sq.addr, align 8
  %call58 = call i32 @nvme_init_sq_ioeventfd(ptr noundef %64)
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.end, label %if.then60

if.then60:                                        ; preds = %if.then57
  %65 = load ptr, ptr %sq.addr, align 8
  %ioeventfd_enabled = getelementptr inbounds %struct.NvmeSQueue, ptr %65, i32 0, i32 11
  store i8 1, ptr %ioeventfd_enabled, align 4
  br label %if.end

if.end:                                           ; preds = %if.then60, %if.then57
  br label %if.end61

if.end61:                                         ; preds = %if.end, %land.lhs.true, %if.then
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %for.end
  %66 = load ptr, ptr %n.addr, align 8
  %cq63 = getelementptr inbounds %struct.NvmeCtrl, ptr %66, i32 0, i32 37
  %67 = load ptr, ptr %cq63, align 8
  %68 = load i16, ptr %cqid.addr, align 2
  %idxprom64 = zext i16 %68 to i64
  %arrayidx65 = getelementptr ptr, ptr %67, i64 %idxprom64
  %69 = load ptr, ptr %arrayidx65, align 8
  %tobool66 = icmp ne ptr %69, null
  br i1 %tobool66, label %if.then67, label %if.else

if.then67:                                        ; preds = %if.end62
  br label %if.end68

if.else:                                          ; preds = %if.end62
  call void @__assert_fail(ptr noundef @.str.173, ptr noundef @.str.1, i32 noundef 4652, ptr noundef @__PRETTY_FUNCTION__.nvme_init_sq) #12
  unreachable

if.end68:                                         ; preds = %if.then67
  %70 = load ptr, ptr %n.addr, align 8
  %cq69 = getelementptr inbounds %struct.NvmeCtrl, ptr %70, i32 0, i32 37
  %71 = load ptr, ptr %cq69, align 8
  %72 = load i16, ptr %cqid.addr, align 2
  %idxprom70 = zext i16 %72 to i64
  %arrayidx71 = getelementptr ptr, ptr %71, i64 %idxprom70
  %73 = load ptr, ptr %arrayidx71, align 8
  store ptr %73, ptr %cq, align 8
  br label %do.body72

do.body72:                                        ; preds = %if.end68
  %74 = load ptr, ptr %sq.addr, align 8
  %entry73 = getelementptr inbounds %struct.NvmeSQueue, ptr %74, i32 0, i32 15
  store ptr null, ptr %entry73, align 8
  %75 = load ptr, ptr %cq, align 8
  %sq_list = getelementptr inbounds %struct.NvmeCQueue, ptr %75, i32 0, i32 14
  %tql_prev74 = getelementptr inbounds %struct.QTailQLink, ptr %sq_list, i32 0, i32 1
  %76 = load ptr, ptr %tql_prev74, align 8
  %77 = load ptr, ptr %sq.addr, align 8
  %entry75 = getelementptr inbounds %struct.NvmeSQueue, ptr %77, i32 0, i32 15
  %tql_prev76 = getelementptr inbounds %struct.QTailQLink, ptr %entry75, i32 0, i32 1
  store ptr %76, ptr %tql_prev76, align 8
  %78 = load ptr, ptr %sq.addr, align 8
  %79 = load ptr, ptr %cq, align 8
  %sq_list77 = getelementptr inbounds %struct.NvmeCQueue, ptr %79, i32 0, i32 14
  %tql_prev78 = getelementptr inbounds %struct.QTailQLink, ptr %sq_list77, i32 0, i32 1
  %80 = load ptr, ptr %tql_prev78, align 8
  %tql_next79 = getelementptr inbounds %struct.QTailQLink, ptr %80, i32 0, i32 0
  store ptr %78, ptr %tql_next79, align 8
  %81 = load ptr, ptr %sq.addr, align 8
  %entry80 = getelementptr inbounds %struct.NvmeSQueue, ptr %81, i32 0, i32 15
  %82 = load ptr, ptr %cq, align 8
  %sq_list81 = getelementptr inbounds %struct.NvmeCQueue, ptr %82, i32 0, i32 14
  %tql_prev82 = getelementptr inbounds %struct.QTailQLink, ptr %sq_list81, i32 0, i32 1
  store ptr %entry80, ptr %tql_prev82, align 8
  br label %do.end83

do.end83:                                         ; preds = %do.body72
  %83 = load ptr, ptr %sq.addr, align 8
  %84 = load ptr, ptr %n.addr, align 8
  %sq84 = getelementptr inbounds %struct.NvmeCtrl, ptr %84, i32 0, i32 36
  %85 = load ptr, ptr %sq84, align 16
  %86 = load i16, ptr %sqid.addr, align 2
  %idxprom85 = zext i16 %86 to i64
  %arrayidx86 = getelementptr ptr, ptr %85, i64 %idxprom85
  store ptr %83, ptr %arrayidx86, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_set_timestamp(ptr noundef %n, i64 noundef %ts) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %ts.addr = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i64 %ts, ptr %ts.addr, align 8
  %0 = load i64, ptr %ts.addr, align 8
  call void @trace_pci_nvme_setfeat_timestamp(i64 noundef %0)
  %1 = load i64, ptr %ts.addr, align 8
  %call = call i64 @le64_to_cpu(i64 noundef %1)
  %2 = load ptr, ptr %n.addr, align 8
  %host_timestamp = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 15
  store i64 %call, ptr %host_timestamp, align 8
  %call1 = call i64 @qemu_clock_get_ms(i32 noundef 1)
  %3 = load ptr, ptr %n.addr, align 8
  %timestamp_set_qemu_clock_ms = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 16
  store i64 %call1, ptr %timestamp_set_qemu_clock_ms, align 16
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_select_iocs(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %cmp = icmp sle i32 %0, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %n.addr, align 8
  %2 = load i32, ptr %i, align 4
  %call = call ptr @nvme_ns(ptr noundef %1, i32 noundef %2)
  store ptr %call, ptr %ns, align 8
  %3 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %4 = load ptr, ptr %n.addr, align 8
  %5 = load ptr, ptr %ns, align 8
  call void @nvme_select_iocs_ns(ptr noundef %4, ptr noundef %5)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %6 = load i32, ptr %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !23

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_startfail_virt_state(i16 noundef zeroext %vq, i16 noundef zeroext %vi) #0 {
entry:
  %vq.addr = alloca i16, align 2
  %vi.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %vq, ptr %vq.addr, align 2
  store i16 %vi, ptr %vi.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_STARTFAIL_VIRT_STATE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %vq.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i16, ptr %vi.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.136, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %vq.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i16, ptr %vi.addr, align 2
  %conv14 = zext i16 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.137, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_startfail_cq() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_STARTFAIL_CQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.138, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.139)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_startfail_sq() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_STARTFAIL_SQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.140, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.141)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_startfail_asq_misaligned(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.142, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.143, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_startfail_acq_misaligned(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.144, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.145, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_startfail_css(i8 noundef zeroext %css) #0 {
entry:
  %css.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %css, ptr %css.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_STARTFAIL_CSS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %css.addr, align 1
  %conv11 = zext i8 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.146, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i8, ptr %css.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.147, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_startfail_page_too_small(i8 noundef zeroext %log2ps, i8 noundef zeroext %maxlog2ps) #0 {
entry:
  %log2ps.addr = alloca i8, align 1
  %maxlog2ps.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %log2ps, ptr %log2ps.addr, align 1
  store i8 %maxlog2ps, ptr %maxlog2ps.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %log2ps.addr, align 1
  %conv11 = zext i8 %5 to i32
  %6 = load i8, ptr %maxlog2ps.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.148, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i8, ptr %log2ps.addr, align 1
  %conv13 = zext i8 %7 to i32
  %8 = load i8, ptr %maxlog2ps.addr, align 1
  %conv14 = zext i8 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.149, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_startfail_page_too_large(i8 noundef zeroext %log2ps, i8 noundef zeroext %maxlog2ps) #0 {
entry:
  %log2ps.addr = alloca i8, align 1
  %maxlog2ps.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %log2ps, ptr %log2ps.addr, align 1
  store i8 %maxlog2ps, ptr %maxlog2ps.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %log2ps.addr, align 1
  %conv11 = zext i8 %5 to i32
  %6 = load i8, ptr %maxlog2ps.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.150, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i8, ptr %log2ps.addr, align 1
  %conv13 = zext i8 %7 to i32
  %8 = load i8, ptr %maxlog2ps.addr, align 1
  %conv14 = zext i8 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.151, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_startfail_asqent_sz_zero() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.152, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.153)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_startfail_acqent_sz_zero() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.154, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.155)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

declare void @msix_vector_use(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_init_cq_ioeventfd(ptr noundef %cq) #0 {
entry:
  %retval = alloca i32, align 4
  %cq.addr = alloca ptr, align 8
  %n = alloca ptr, align 8
  %offset = alloca i16, align 2
  %ret = alloca i32, align 4
  store ptr %cq, ptr %cq.addr, align 8
  %0 = load ptr, ptr %cq.addr, align 8
  %ctrl = getelementptr inbounds %struct.NvmeCQueue, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %ctrl, align 8
  store ptr %1, ptr %n, align 8
  %2 = load ptr, ptr %cq.addr, align 8
  %cqid = getelementptr inbounds %struct.NvmeCQueue, ptr %2, i32 0, i32 2
  %3 = load i16, ptr %cqid, align 2
  %conv = zext i16 %3 to i32
  %shl = shl i32 %conv, 3
  %add = add i32 %shl, 4
  %conv1 = trunc i32 %add to i16
  store i16 %conv1, ptr %offset, align 2
  %4 = load ptr, ptr %cq.addr, align 8
  %notifier = getelementptr inbounds %struct.NvmeCQueue, ptr %4, i32 0, i32 12
  %call = call i32 @event_notifier_init(ptr noundef %notifier, i32 noundef 0)
  store i32 %call, ptr %ret, align 4
  %5 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, ptr %ret, align 4
  store i32 %6, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load ptr, ptr %cq.addr, align 8
  %notifier3 = getelementptr inbounds %struct.NvmeCQueue, ptr %7, i32 0, i32 12
  call void @event_notifier_set_handler(ptr noundef %notifier3, ptr noundef @nvme_cq_notifier)
  %8 = load ptr, ptr %n, align 8
  %iomem = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 2
  %9 = load i16, ptr %offset, align 2
  %conv4 = zext i16 %9 to i32
  %add5 = add i32 4096, %conv4
  %conv6 = sext i32 %add5 to i64
  %10 = load ptr, ptr %cq.addr, align 8
  %notifier7 = getelementptr inbounds %struct.NvmeCQueue, ptr %10, i32 0, i32 12
  call void @memory_region_add_eventfd(ptr noundef %iomem, i64 noundef %conv6, i32 noundef 4, i1 noundef zeroext false, i64 noundef 0, ptr noundef %notifier7)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

declare ptr @qemu_bh_new_full(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_post_cqes(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %cq = alloca ptr, align 8
  %n = alloca ptr, align 8
  %req = alloca ptr, align 8
  %next = alloca ptr, align 8
  %pending = alloca i8, align 1
  %ret = alloca i32, align 4
  %sq = alloca ptr, align 8
  %addr = alloca i64, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %cq, align 8
  %1 = load ptr, ptr %cq, align 8
  %ctrl = getelementptr inbounds %struct.NvmeCQueue, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %ctrl, align 8
  store ptr %2, ptr %n, align 8
  %3 = load ptr, ptr %cq, align 8
  %head = getelementptr inbounds %struct.NvmeCQueue, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %head, align 8
  %5 = load ptr, ptr %cq, align 8
  %tail = getelementptr inbounds %struct.NvmeCQueue, ptr %5, i32 0, i32 5
  %6 = load i32, ptr %tail, align 4
  %cmp = icmp ne i32 %4, %6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, ptr %pending, align 1
  %7 = load ptr, ptr %cq, align 8
  %req_list = getelementptr inbounds %struct.NvmeCQueue, ptr %7, i32 0, i32 15
  %8 = load ptr, ptr %req_list, align 8
  store ptr %8, ptr %req, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load ptr, ptr %req, align 8
  %tobool = icmp ne ptr %9, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %10 = load ptr, ptr %req, align 8
  %entry1 = getelementptr inbounds %struct.NvmeRequest, ptr %10, i32 0, i32 9
  %11 = load ptr, ptr %entry1, align 8
  store ptr %11, ptr %next, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %12 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %12, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %13 = load ptr, ptr %n, align 8
  %dbbuf_enabled = getelementptr inbounds %struct.NvmeCtrl, ptr %13, i32 0, i32 24
  %14 = load i8, ptr %dbbuf_enabled, align 16
  %tobool2 = trunc i8 %14 to i1
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %15 = load ptr, ptr %cq, align 8
  call void @nvme_update_cq_eventidx(ptr noundef %15)
  %16 = load ptr, ptr %cq, align 8
  call void @nvme_update_cq_head(ptr noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %17 = load ptr, ptr %cq, align 8
  %call = call zeroext i8 @nvme_cq_full(ptr noundef %17)
  %tobool3 = icmp ne i8 %call, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %for.end

if.end5:                                          ; preds = %if.end
  %18 = load ptr, ptr %req, align 8
  %sq6 = getelementptr inbounds %struct.NvmeRequest, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %sq6, align 8
  store ptr %19, ptr %sq, align 8
  %20 = load ptr, ptr %req, align 8
  %status = getelementptr inbounds %struct.NvmeRequest, ptr %20, i32 0, i32 3
  %21 = load i16, ptr %status, align 8
  %conv = zext i16 %21 to i32
  %shl = shl i32 %conv, 1
  %22 = load ptr, ptr %cq, align 8
  %phase = getelementptr inbounds %struct.NvmeCQueue, ptr %22, i32 0, i32 1
  %23 = load i8, ptr %phase, align 8
  %conv7 = zext i8 %23 to i32
  %or = or i32 %shl, %conv7
  %conv8 = trunc i32 %or to i16
  %call9 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv8)
  %24 = load ptr, ptr %req, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %24, i32 0, i32 5
  %status10 = getelementptr inbounds %struct.NvmeCqe, ptr %cqe, i32 0, i32 5
  store i16 %call9, ptr %status10, align 2
  %25 = load ptr, ptr %sq, align 8
  %sqid = getelementptr inbounds %struct.NvmeSQueue, ptr %25, i32 0, i32 1
  %26 = load i16, ptr %sqid, align 8
  %call11 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %26)
  %27 = load ptr, ptr %req, align 8
  %cqe12 = getelementptr inbounds %struct.NvmeRequest, ptr %27, i32 0, i32 5
  %sq_id = getelementptr inbounds %struct.NvmeCqe, ptr %cqe12, i32 0, i32 3
  store i16 %call11, ptr %sq_id, align 2
  %28 = load ptr, ptr %sq, align 8
  %head13 = getelementptr inbounds %struct.NvmeSQueue, ptr %28, i32 0, i32 3
  %29 = load i32, ptr %head13, align 4
  %conv14 = trunc i32 %29 to i16
  %call15 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv14)
  %30 = load ptr, ptr %req, align 8
  %cqe16 = getelementptr inbounds %struct.NvmeRequest, ptr %30, i32 0, i32 5
  %sq_head = getelementptr inbounds %struct.NvmeCqe, ptr %cqe16, i32 0, i32 2
  store i16 %call15, ptr %sq_head, align 8
  %31 = load ptr, ptr %cq, align 8
  %dma_addr = getelementptr inbounds %struct.NvmeCQueue, ptr %31, i32 0, i32 8
  %32 = load i64, ptr %dma_addr, align 8
  %33 = load ptr, ptr %cq, align 8
  %tail17 = getelementptr inbounds %struct.NvmeCQueue, ptr %33, i32 0, i32 5
  %34 = load i32, ptr %tail17, align 4
  %shl18 = shl i32 %34, 4
  %conv19 = zext i32 %shl18 to i64
  %add = add i64 %32, %conv19
  store i64 %add, ptr %addr, align 8
  %35 = load ptr, ptr %n, align 8
  %call20 = call ptr @PCI_DEVICE(ptr noundef %35)
  %36 = load i64, ptr %addr, align 8
  %37 = load ptr, ptr %req, align 8
  %cqe21 = getelementptr inbounds %struct.NvmeRequest, ptr %37, i32 0, i32 5
  %call22 = call i32 @pci_dma_write(ptr noundef %call20, i64 noundef %36, ptr noundef %cqe21, i64 noundef 16)
  store i32 %call22, ptr %ret, align 4
  %38 = load i32, ptr %ret, align 4
  %tobool23 = icmp ne i32 %38, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end5
  %39 = load i64, ptr %addr, align 8
  call void @trace_pci_nvme_err_addr_write(i64 noundef %39)
  call void @trace_pci_nvme_err_cfs()
  %40 = load ptr, ptr %n, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %40, i32 0, i32 3
  %csts = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 6
  call void @stl_le_p(ptr noundef %csts, i32 noundef 2)
  br label %for.end

if.end25:                                         ; preds = %if.end5
  br label %do.body

do.body:                                          ; preds = %if.end25
  %41 = load ptr, ptr %req, align 8
  %entry26 = getelementptr inbounds %struct.NvmeRequest, ptr %41, i32 0, i32 9
  %42 = load ptr, ptr %entry26, align 8
  %cmp27 = icmp ne ptr %42, null
  br i1 %cmp27, label %if.then29, label %if.else

if.then29:                                        ; preds = %do.body
  %43 = load ptr, ptr %req, align 8
  %entry30 = getelementptr inbounds %struct.NvmeRequest, ptr %43, i32 0, i32 9
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %entry30, i32 0, i32 1
  %44 = load ptr, ptr %tql_prev, align 8
  %45 = load ptr, ptr %req, align 8
  %entry31 = getelementptr inbounds %struct.NvmeRequest, ptr %45, i32 0, i32 9
  %46 = load ptr, ptr %entry31, align 8
  %entry32 = getelementptr inbounds %struct.NvmeRequest, ptr %46, i32 0, i32 9
  %tql_prev33 = getelementptr inbounds %struct.QTailQLink, ptr %entry32, i32 0, i32 1
  store ptr %44, ptr %tql_prev33, align 8
  br label %if.end38

if.else:                                          ; preds = %do.body
  %47 = load ptr, ptr %req, align 8
  %entry34 = getelementptr inbounds %struct.NvmeRequest, ptr %47, i32 0, i32 9
  %tql_prev35 = getelementptr inbounds %struct.QTailQLink, ptr %entry34, i32 0, i32 1
  %48 = load ptr, ptr %tql_prev35, align 8
  %49 = load ptr, ptr %cq, align 8
  %req_list36 = getelementptr inbounds %struct.NvmeCQueue, ptr %49, i32 0, i32 15
  %tql_prev37 = getelementptr inbounds %struct.QTailQLink, ptr %req_list36, i32 0, i32 1
  store ptr %48, ptr %tql_prev37, align 8
  br label %if.end38

if.end38:                                         ; preds = %if.else, %if.then29
  %50 = load ptr, ptr %req, align 8
  %entry39 = getelementptr inbounds %struct.NvmeRequest, ptr %50, i32 0, i32 9
  %51 = load ptr, ptr %entry39, align 8
  %52 = load ptr, ptr %req, align 8
  %entry40 = getelementptr inbounds %struct.NvmeRequest, ptr %52, i32 0, i32 9
  %tql_prev41 = getelementptr inbounds %struct.QTailQLink, ptr %entry40, i32 0, i32 1
  %53 = load ptr, ptr %tql_prev41, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %53, i32 0, i32 0
  store ptr %51, ptr %tql_next, align 8
  %54 = load ptr, ptr %req, align 8
  %entry42 = getelementptr inbounds %struct.NvmeRequest, ptr %54, i32 0, i32 9
  %tql_prev43 = getelementptr inbounds %struct.QTailQLink, ptr %entry42, i32 0, i32 1
  store ptr null, ptr %tql_prev43, align 8
  %55 = load ptr, ptr %req, align 8
  %entry44 = getelementptr inbounds %struct.NvmeRequest, ptr %55, i32 0, i32 9
  %tql_next45 = getelementptr inbounds %struct.QTailQLink, ptr %entry44, i32 0, i32 0
  store ptr null, ptr %tql_next45, align 8
  %56 = load ptr, ptr %req, align 8
  %entry46 = getelementptr inbounds %struct.NvmeRequest, ptr %56, i32 0, i32 9
  store ptr null, ptr %entry46, align 8
  br label %do.end

do.end:                                           ; preds = %if.end38
  %57 = load ptr, ptr %cq, align 8
  call void @nvme_inc_cq_tail(ptr noundef %57)
  %58 = load ptr, ptr %req, align 8
  %sg = getelementptr inbounds %struct.NvmeRequest, ptr %58, i32 0, i32 8
  call void @nvme_sg_unmap(ptr noundef %sg)
  br label %do.body47

do.body47:                                        ; preds = %do.end
  %59 = load ptr, ptr %req, align 8
  %entry48 = getelementptr inbounds %struct.NvmeRequest, ptr %59, i32 0, i32 9
  store ptr null, ptr %entry48, align 8
  %60 = load ptr, ptr %sq, align 8
  %req_list49 = getelementptr inbounds %struct.NvmeSQueue, ptr %60, i32 0, i32 13
  %tql_prev50 = getelementptr inbounds %struct.QTailQLink, ptr %req_list49, i32 0, i32 1
  %61 = load ptr, ptr %tql_prev50, align 8
  %62 = load ptr, ptr %req, align 8
  %entry51 = getelementptr inbounds %struct.NvmeRequest, ptr %62, i32 0, i32 9
  %tql_prev52 = getelementptr inbounds %struct.QTailQLink, ptr %entry51, i32 0, i32 1
  store ptr %61, ptr %tql_prev52, align 8
  %63 = load ptr, ptr %req, align 8
  %64 = load ptr, ptr %sq, align 8
  %req_list53 = getelementptr inbounds %struct.NvmeSQueue, ptr %64, i32 0, i32 13
  %tql_prev54 = getelementptr inbounds %struct.QTailQLink, ptr %req_list53, i32 0, i32 1
  %65 = load ptr, ptr %tql_prev54, align 8
  %tql_next55 = getelementptr inbounds %struct.QTailQLink, ptr %65, i32 0, i32 0
  store ptr %63, ptr %tql_next55, align 8
  %66 = load ptr, ptr %req, align 8
  %entry56 = getelementptr inbounds %struct.NvmeRequest, ptr %66, i32 0, i32 9
  %67 = load ptr, ptr %sq, align 8
  %req_list57 = getelementptr inbounds %struct.NvmeSQueue, ptr %67, i32 0, i32 13
  %tql_prev58 = getelementptr inbounds %struct.QTailQLink, ptr %req_list57, i32 0, i32 1
  store ptr %entry56, ptr %tql_prev58, align 8
  br label %do.end59

do.end59:                                         ; preds = %do.body47
  br label %for.inc

for.inc:                                          ; preds = %do.end59
  %68 = load ptr, ptr %next, align 8
  store ptr %68, ptr %req, align 8
  br label %for.cond, !llvm.loop !24

for.end:                                          ; preds = %if.then24, %if.then4, %land.end
  %69 = load ptr, ptr %cq, align 8
  %tail60 = getelementptr inbounds %struct.NvmeCQueue, ptr %69, i32 0, i32 5
  %70 = load i32, ptr %tail60, align 4
  %71 = load ptr, ptr %cq, align 8
  %head61 = getelementptr inbounds %struct.NvmeCQueue, ptr %71, i32 0, i32 4
  %72 = load i32, ptr %head61, align 8
  %cmp62 = icmp ne i32 %70, %72
  br i1 %cmp62, label %if.then64, label %if.end70

if.then64:                                        ; preds = %for.end
  %73 = load ptr, ptr %cq, align 8
  %irq_enabled = getelementptr inbounds %struct.NvmeCQueue, ptr %73, i32 0, i32 3
  %74 = load i16, ptr %irq_enabled, align 4
  %conv65 = zext i16 %74 to i32
  %tobool66 = icmp ne i32 %conv65, 0
  br i1 %tobool66, label %land.lhs.true, label %if.end69

land.lhs.true:                                    ; preds = %if.then64
  %75 = load i8, ptr %pending, align 1
  %tobool67 = trunc i8 %75 to i1
  br i1 %tobool67, label %if.end69, label %if.then68

if.then68:                                        ; preds = %land.lhs.true
  %76 = load ptr, ptr %n, align 8
  %cq_pending = getelementptr inbounds %struct.NvmeCtrl, ptr %76, i32 0, i32 14
  %77 = load i32, ptr %cq_pending, align 16
  %inc = add i32 %77, 1
  store i32 %inc, ptr %cq_pending, align 16
  br label %if.end69

if.end69:                                         ; preds = %if.then68, %land.lhs.true, %if.then64
  %78 = load ptr, ptr %n, align 8
  %79 = load ptr, ptr %cq, align 8
  call void @nvme_irq_assert(ptr noundef %78, ptr noundef %79)
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %for.end
  ret void
}

declare i32 @event_notifier_init(ptr noundef, i32 noundef) #1

declare void @event_notifier_set_handler(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_cq_notifier(ptr noundef %e) #0 {
entry:
  %e.addr = alloca ptr, align 8
  %cq = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %n = alloca ptr, align 8
  store ptr %e, ptr %e.addr, align 8
  %0 = load ptr, ptr %e.addr, align 8
  store ptr %0, ptr %__mptr, align 8
  %1 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 -64
  store ptr %add.ptr, ptr %tmp, align 8
  %2 = load ptr, ptr %tmp, align 8
  store ptr %2, ptr %cq, align 8
  %3 = load ptr, ptr %cq, align 8
  %ctrl = getelementptr inbounds %struct.NvmeCQueue, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %ctrl, align 8
  store ptr %4, ptr %n, align 8
  %5 = load ptr, ptr %e.addr, align 8
  %call = call i32 @event_notifier_test_and_clear(ptr noundef %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %cq, align 8
  call void @nvme_update_cq_head(ptr noundef %6)
  %7 = load ptr, ptr %cq, align 8
  %tail = getelementptr inbounds %struct.NvmeCQueue, ptr %7, i32 0, i32 5
  %8 = load i32, ptr %tail, align 4
  %9 = load ptr, ptr %cq, align 8
  %head = getelementptr inbounds %struct.NvmeCQueue, ptr %9, i32 0, i32 4
  %10 = load i32, ptr %head, align 8
  %cmp = icmp eq i32 %8, %10
  br i1 %cmp, label %if.then1, label %if.end5

if.then1:                                         ; preds = %if.end
  %11 = load ptr, ptr %cq, align 8
  %irq_enabled = getelementptr inbounds %struct.NvmeCQueue, ptr %11, i32 0, i32 3
  %12 = load i16, ptr %irq_enabled, align 4
  %tobool2 = icmp ne i16 %12, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.then1
  %13 = load ptr, ptr %n, align 8
  %cq_pending = getelementptr inbounds %struct.NvmeCtrl, ptr %13, i32 0, i32 14
  %14 = load i32, ptr %cq_pending, align 16
  %dec = add i32 %14, -1
  store i32 %dec, ptr %cq_pending, align 16
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.then1
  %15 = load ptr, ptr %n, align 8
  %16 = load ptr, ptr %cq, align 8
  call void @nvme_irq_deassert(ptr noundef %15, ptr noundef %16)
  br label %if.end5

if.end5:                                          ; preds = %if.end4, %if.end
  %17 = load ptr, ptr %cq, align 8
  %bh = getelementptr inbounds %struct.NvmeCQueue, ptr %17, i32 0, i32 11
  %18 = load ptr, ptr %bh, align 8
  call void @qemu_bh_schedule(ptr noundef %18)
  br label %return

return:                                           ; preds = %if.end5, %if.then
  ret void
}

declare void @memory_region_add_eventfd(ptr noundef, i64 noundef, i32 noundef, i1 noundef zeroext, i64 noundef, ptr noundef) #1

declare i32 @event_notifier_test_and_clear(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_update_cq_head(ptr noundef %cq) #0 {
entry:
  %cq.addr = alloca ptr, align 8
  %.compoundliteral = alloca %struct.MemTxAttrs, align 4
  store ptr %cq, ptr %cq.addr, align 8
  %0 = load ptr, ptr %cq.addr, align 8
  %ctrl = getelementptr inbounds %struct.NvmeCQueue, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %ctrl, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %1)
  %2 = load ptr, ptr %cq.addr, align 8
  %db_addr = getelementptr inbounds %struct.NvmeCQueue, ptr %2, i32 0, i32 9
  %3 = load i64, ptr %db_addr, align 8
  %4 = load ptr, ptr %cq.addr, align 8
  %head = getelementptr inbounds %struct.NvmeCQueue, ptr %4, i32 0, i32 4
  %bf.load = load i32, ptr %.compoundliteral, align 4
  %bf.clear = and i32 %bf.load, -2
  %bf.set = or i32 %bf.clear, 1
  store i32 %bf.set, ptr %.compoundliteral, align 4
  %bf.load1 = load i32, ptr %.compoundliteral, align 4
  %bf.clear2 = and i32 %bf.load1, -3
  %bf.set3 = or i32 %bf.clear2, 0
  store i32 %bf.set3, ptr %.compoundliteral, align 4
  %bf.load4 = load i32, ptr %.compoundliteral, align 4
  %bf.clear5 = and i32 %bf.load4, -13
  %bf.set6 = or i32 %bf.clear5, 0
  store i32 %bf.set6, ptr %.compoundliteral, align 4
  %bf.load7 = load i32, ptr %.compoundliteral, align 4
  %bf.clear8 = and i32 %bf.load7, -17
  %bf.set9 = or i32 %bf.clear8, 0
  store i32 %bf.set9, ptr %.compoundliteral, align 4
  %bf.load10 = load i32, ptr %.compoundliteral, align 4
  %bf.clear11 = and i32 %bf.load10, -33
  %bf.set12 = or i32 %bf.clear11, 0
  store i32 %bf.set12, ptr %.compoundliteral, align 4
  %bf.load13 = load i32, ptr %.compoundliteral, align 4
  %bf.clear14 = and i32 %bf.load13, -4194241
  %bf.set15 = or i32 %bf.clear14, 0
  store i32 %bf.set15, ptr %.compoundliteral, align 4
  %bf.load16 = load i32, ptr %.compoundliteral, align 4
  %bf.clear17 = and i32 %bf.load16, -4194305
  %bf.set18 = or i32 %bf.clear17, 0
  store i32 %bf.set18, ptr %.compoundliteral, align 4
  %bf.load19 = load i32, ptr %.compoundliteral, align 4
  %bf.clear20 = and i32 %bf.load19, -8388609
  %bf.set21 = or i32 %bf.clear20, 0
  store i32 %bf.set21, ptr %.compoundliteral, align 4
  %bf.load22 = load i32, ptr %.compoundliteral, align 4
  %bf.clear23 = and i32 %bf.load22, -16777217
  %bf.set24 = or i32 %bf.clear23, 0
  store i32 %bf.set24, ptr %.compoundliteral, align 4
  %bf.load25 = load i32, ptr %.compoundliteral, align 4
  %bf.clear26 = and i32 %bf.load25, -33554433
  %bf.set27 = or i32 %bf.clear26, 0
  store i32 %bf.set27, ptr %.compoundliteral, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %.compoundliteral, i32 0, i32 0
  %5 = load i32, ptr %coerce.dive, align 4
  %call28 = call i32 @ldl_le_pci_dma(ptr noundef %call, i64 noundef %3, ptr noundef %head, i32 %5)
  %6 = load ptr, ptr %cq.addr, align 8
  %cqid = getelementptr inbounds %struct.NvmeCQueue, ptr %6, i32 0, i32 2
  %7 = load i16, ptr %cqid, align 2
  %8 = load ptr, ptr %cq.addr, align 8
  %head29 = getelementptr inbounds %struct.NvmeCQueue, ptr %8, i32 0, i32 4
  %9 = load i32, ptr %head29, align 8
  %conv = trunc i32 %9 to i16
  call void @trace_pci_nvme_update_cq_head(i16 noundef zeroext %7, i16 noundef zeroext %conv)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_irq_deassert(ptr noundef %n, ptr noundef %cq) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %cq.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %cq, ptr %cq.addr, align 8
  %0 = load ptr, ptr %cq.addr, align 8
  %irq_enabled = getelementptr inbounds %struct.NvmeCQueue, ptr %0, i32 0, i32 3
  %1 = load i16, ptr %irq_enabled, align 4
  %tobool = icmp ne i16 %1, 0
  br i1 %tobool, label %if.then, label %if.end11

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %2)
  %call1 = call i32 @msix_enabled(ptr noundef %call)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  br label %if.end11

if.else:                                          ; preds = %if.then
  %3 = load ptr, ptr %cq.addr, align 8
  %vector = getelementptr inbounds %struct.NvmeCQueue, ptr %3, i32 0, i32 6
  %4 = load i32, ptr %vector, align 8
  %cmp = icmp ult i32 %4, 32
  br i1 %cmp, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.else
  br label %if.end

if.else5:                                         ; preds = %if.else
  call void @__assert_fail(ptr noundef @.str.159, ptr noundef @.str.1, i32 noundef 687, ptr noundef @__PRETTY_FUNCTION__.nvme_irq_deassert) #12
  unreachable

if.end:                                           ; preds = %if.then4
  %5 = load ptr, ptr %n.addr, align 8
  %cq_pending = getelementptr inbounds %struct.NvmeCtrl, ptr %5, i32 0, i32 14
  %6 = load i32, ptr %cq_pending, align 16
  %tobool6 = icmp ne i32 %6, 0
  br i1 %tobool6, label %if.end9, label %if.then7

if.then7:                                         ; preds = %if.end
  %7 = load ptr, ptr %cq.addr, align 8
  %vector8 = getelementptr inbounds %struct.NvmeCQueue, ptr %7, i32 0, i32 6
  %8 = load i32, ptr %vector8, align 8
  %shl = shl i32 1, %8
  %not = xor i32 %shl, -1
  %9 = load ptr, ptr %n.addr, align 8
  %irq_status = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 13
  %10 = load i32, ptr %irq_status, align 4
  %and = and i32 %10, %not
  store i32 %and, ptr %irq_status, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end
  %11 = load ptr, ptr %n.addr, align 8
  call void @nvme_irq_check(ptr noundef %11)
  br label %if.end10

if.end10:                                         ; preds = %if.end9
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then3, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ldl_le_pci_dma(ptr noundef %dev, i64 noundef %addr, ptr noundef %val, i32 %attrs.coerce) #0 {
entry:
  %attrs = alloca %struct.MemTxAttrs, align 4
  %dev.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %val.addr = alloca ptr, align 8
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  store i32 %attrs.coerce, ptr %coerce.dive, align 4
  store ptr %dev, ptr %dev.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  %0 = load ptr, ptr %dev.addr, align 8
  %call = call ptr @pci_get_address_space(ptr noundef %0)
  %1 = load i64, ptr %addr.addr, align 8
  %2 = load ptr, ptr %val.addr, align 8
  %coerce.dive1 = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  %3 = load i32, ptr %coerce.dive1, align 4
  %call2 = call i32 @ldl_le_dma(ptr noundef %call, i64 noundef %1, ptr noundef %2, i32 %3)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_update_cq_head(i16 noundef zeroext %cqid, i16 noundef zeroext %new_head) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  %new_head.addr = alloca i16, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  store i16 %new_head, ptr %new_head.addr, align 2
  %0 = load i16, ptr %cqid.addr, align 2
  %1 = load i16, ptr %new_head.addr, align 2
  call void @_nocheck__trace_pci_nvme_update_cq_head(i16 noundef zeroext %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ldl_le_dma(ptr noundef %as, i64 noundef %addr, ptr noundef %pval, i32 %attrs.coerce) #0 {
entry:
  %attrs = alloca %struct.MemTxAttrs, align 4
  %as.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %pval.addr = alloca ptr, align 8
  %res = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  store i32 %attrs.coerce, ptr %coerce.dive, align 4
  store ptr %as, ptr %as.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store ptr %pval, ptr %pval.addr, align 8
  %0 = load ptr, ptr %as.addr, align 8
  %1 = load i64, ptr %addr.addr, align 8
  %2 = load ptr, ptr %pval.addr, align 8
  %coerce.dive1 = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  %3 = load i32, ptr %coerce.dive1, align 4
  %call = call i32 @dma_memory_read(ptr noundef %0, i64 noundef %1, ptr noundef %2, i64 noundef 4, i32 %3)
  store i32 %call, ptr %res, align 4
  %4 = load ptr, ptr %pval.addr, align 8
  call void @le32_to_cpus(ptr noundef %4)
  %5 = load i32, ptr %res, align 4
  ret i32 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @dma_memory_read(ptr noundef %as, i64 noundef %addr, ptr noundef %buf, i64 noundef %len, i32 %attrs.coerce) #0 {
entry:
  %attrs = alloca %struct.MemTxAttrs, align 4
  %as.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  store i32 %attrs.coerce, ptr %coerce.dive, align 4
  store ptr %as, ptr %as.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %as.addr, align 8
  %1 = load i64, ptr %addr.addr, align 8
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load i64, ptr %len.addr, align 8
  %coerce.dive1 = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  %4 = load i32, ptr %coerce.dive1, align 4
  %call = call i32 @dma_memory_rw(ptr noundef %0, i64 noundef %1, ptr noundef %2, i64 noundef %3, i32 noundef 0, i32 %4)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @le32_to_cpus(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_update_cq_head(i16 noundef zeroext %cqid, i16 noundef zeroext %new_head) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  %new_head.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cqid, ptr %cqid.addr, align 2
  store i16 %new_head, ptr %new_head.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UPDATE_CQ_HEAD_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cqid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i16, ptr %new_head.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.157, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %cqid.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i16, ptr %new_head.addr, align 2
  %conv14 = zext i16 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.158, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_update_cq_eventidx(ptr noundef %cq) #0 {
entry:
  %cq.addr = alloca ptr, align 8
  %.compoundliteral = alloca %struct.MemTxAttrs, align 4
  store ptr %cq, ptr %cq.addr, align 8
  %0 = load ptr, ptr %cq.addr, align 8
  %cqid = getelementptr inbounds %struct.NvmeCQueue, ptr %0, i32 0, i32 2
  %1 = load i16, ptr %cqid, align 2
  %2 = load ptr, ptr %cq.addr, align 8
  %head = getelementptr inbounds %struct.NvmeCQueue, ptr %2, i32 0, i32 4
  %3 = load i32, ptr %head, align 8
  %conv = trunc i32 %3 to i16
  call void @trace_pci_nvme_update_cq_eventidx(i16 noundef zeroext %1, i16 noundef zeroext %conv)
  %4 = load ptr, ptr %cq.addr, align 8
  %ctrl = getelementptr inbounds %struct.NvmeCQueue, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %ctrl, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %5)
  %6 = load ptr, ptr %cq.addr, align 8
  %ei_addr = getelementptr inbounds %struct.NvmeCQueue, ptr %6, i32 0, i32 10
  %7 = load i64, ptr %ei_addr, align 8
  %8 = load ptr, ptr %cq.addr, align 8
  %head1 = getelementptr inbounds %struct.NvmeCQueue, ptr %8, i32 0, i32 4
  %9 = load i32, ptr %head1, align 8
  %bf.load = load i32, ptr %.compoundliteral, align 4
  %bf.clear = and i32 %bf.load, -2
  %bf.set = or i32 %bf.clear, 1
  store i32 %bf.set, ptr %.compoundliteral, align 4
  %bf.load2 = load i32, ptr %.compoundliteral, align 4
  %bf.clear3 = and i32 %bf.load2, -3
  %bf.set4 = or i32 %bf.clear3, 0
  store i32 %bf.set4, ptr %.compoundliteral, align 4
  %bf.load5 = load i32, ptr %.compoundliteral, align 4
  %bf.clear6 = and i32 %bf.load5, -13
  %bf.set7 = or i32 %bf.clear6, 0
  store i32 %bf.set7, ptr %.compoundliteral, align 4
  %bf.load8 = load i32, ptr %.compoundliteral, align 4
  %bf.clear9 = and i32 %bf.load8, -17
  %bf.set10 = or i32 %bf.clear9, 0
  store i32 %bf.set10, ptr %.compoundliteral, align 4
  %bf.load11 = load i32, ptr %.compoundliteral, align 4
  %bf.clear12 = and i32 %bf.load11, -33
  %bf.set13 = or i32 %bf.clear12, 0
  store i32 %bf.set13, ptr %.compoundliteral, align 4
  %bf.load14 = load i32, ptr %.compoundliteral, align 4
  %bf.clear15 = and i32 %bf.load14, -4194241
  %bf.set16 = or i32 %bf.clear15, 0
  store i32 %bf.set16, ptr %.compoundliteral, align 4
  %bf.load17 = load i32, ptr %.compoundliteral, align 4
  %bf.clear18 = and i32 %bf.load17, -4194305
  %bf.set19 = or i32 %bf.clear18, 0
  store i32 %bf.set19, ptr %.compoundliteral, align 4
  %bf.load20 = load i32, ptr %.compoundliteral, align 4
  %bf.clear21 = and i32 %bf.load20, -8388609
  %bf.set22 = or i32 %bf.clear21, 0
  store i32 %bf.set22, ptr %.compoundliteral, align 4
  %bf.load23 = load i32, ptr %.compoundliteral, align 4
  %bf.clear24 = and i32 %bf.load23, -16777217
  %bf.set25 = or i32 %bf.clear24, 0
  store i32 %bf.set25, ptr %.compoundliteral, align 4
  %bf.load26 = load i32, ptr %.compoundliteral, align 4
  %bf.clear27 = and i32 %bf.load26, -33554433
  %bf.set28 = or i32 %bf.clear27, 0
  store i32 %bf.set28, ptr %.compoundliteral, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %.compoundliteral, i32 0, i32 0
  %10 = load i32, ptr %coerce.dive, align 4
  %call29 = call i32 @stl_le_pci_dma(ptr noundef %call, i64 noundef %7, i32 noundef %9, i32 %10)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i8 @nvme_cq_full(ptr noundef %cq) #0 {
entry:
  %cq.addr = alloca ptr, align 8
  store ptr %cq, ptr %cq.addr, align 8
  %0 = load ptr, ptr %cq.addr, align 8
  %tail = getelementptr inbounds %struct.NvmeCQueue, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %tail, align 4
  %add = add i32 %1, 1
  %2 = load ptr, ptr %cq.addr, align 8
  %size = getelementptr inbounds %struct.NvmeCQueue, ptr %2, i32 0, i32 7
  %3 = load i32, ptr %size, align 4
  %rem = urem i32 %add, %3
  %4 = load ptr, ptr %cq.addr, align 8
  %head = getelementptr inbounds %struct.NvmeCQueue, ptr %4, i32 0, i32 4
  %5 = load i32, ptr %head, align 8
  %cmp = icmp eq i32 %rem, %5
  %conv = zext i1 %cmp to i32
  %conv1 = trunc i32 %conv to i8
  ret i8 %conv1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_addr_write(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i64, ptr %addr.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_addr_write(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_cfs() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_err_cfs()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_inc_cq_tail(ptr noundef %cq) #0 {
entry:
  %cq.addr = alloca ptr, align 8
  store ptr %cq, ptr %cq.addr, align 8
  %0 = load ptr, ptr %cq.addr, align 8
  %tail = getelementptr inbounds %struct.NvmeCQueue, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %tail, align 4
  %inc = add i32 %1, 1
  store i32 %inc, ptr %tail, align 4
  %2 = load ptr, ptr %cq.addr, align 8
  %tail1 = getelementptr inbounds %struct.NvmeCQueue, ptr %2, i32 0, i32 5
  %3 = load i32, ptr %tail1, align 4
  %4 = load ptr, ptr %cq.addr, align 8
  %size = getelementptr inbounds %struct.NvmeCQueue, ptr %4, i32 0, i32 7
  %5 = load i32, ptr %size, align 4
  %cmp = icmp uge i32 %3, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %cq.addr, align 8
  %tail2 = getelementptr inbounds %struct.NvmeCQueue, ptr %6, i32 0, i32 5
  store i32 0, ptr %tail2, align 4
  %7 = load ptr, ptr %cq.addr, align 8
  %phase = getelementptr inbounds %struct.NvmeCQueue, ptr %7, i32 0, i32 1
  %8 = load i8, ptr %phase, align 8
  %tobool = icmp ne i8 %8, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %conv = trunc i32 %lnot.ext to i8
  %9 = load ptr, ptr %cq.addr, align 8
  %phase3 = getelementptr inbounds %struct.NvmeCQueue, ptr %9, i32 0, i32 1
  store i8 %conv, ptr %phase3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_irq_assert(ptr noundef %n, ptr noundef %cq) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %cq.addr = alloca ptr, align 8
  %pci = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %cq, ptr %cq.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %0)
  store ptr %call, ptr %pci, align 8
  %1 = load ptr, ptr %cq.addr, align 8
  %irq_enabled = getelementptr inbounds %struct.NvmeCQueue, ptr %1, i32 0, i32 3
  %2 = load i16, ptr %irq_enabled, align 4
  %tobool = icmp ne i16 %2, 0
  br i1 %tobool, label %if.then, label %if.else10

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %pci, align 8
  %call1 = call i32 @msix_enabled(ptr noundef %3)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  %4 = load ptr, ptr %cq.addr, align 8
  %vector = getelementptr inbounds %struct.NvmeCQueue, ptr %4, i32 0, i32 6
  %5 = load i32, ptr %vector, align 8
  call void @trace_pci_nvme_irq_msix(i32 noundef %5)
  %6 = load ptr, ptr %pci, align 8
  %7 = load ptr, ptr %cq.addr, align 8
  %vector4 = getelementptr inbounds %struct.NvmeCQueue, ptr %7, i32 0, i32 6
  %8 = load i32, ptr %vector4, align 8
  call void @msix_notify(ptr noundef %6, i32 noundef %8)
  br label %if.end9

if.else:                                          ; preds = %if.then
  call void @trace_pci_nvme_irq_pin()
  %9 = load ptr, ptr %cq.addr, align 8
  %vector5 = getelementptr inbounds %struct.NvmeCQueue, ptr %9, i32 0, i32 6
  %10 = load i32, ptr %vector5, align 8
  %cmp = icmp ult i32 %10, 32
  br i1 %cmp, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  br label %if.end

if.else7:                                         ; preds = %if.else
  call void @__assert_fail(ptr noundef @.str.159, ptr noundef @.str.1, i32 noundef 672, ptr noundef @__PRETTY_FUNCTION__.nvme_irq_assert) #12
  unreachable

if.end:                                           ; preds = %if.then6
  %11 = load ptr, ptr %cq.addr, align 8
  %vector8 = getelementptr inbounds %struct.NvmeCQueue, ptr %11, i32 0, i32 6
  %12 = load i32, ptr %vector8, align 8
  %shl = shl i32 1, %12
  %13 = load ptr, ptr %n.addr, align 8
  %irq_status = getelementptr inbounds %struct.NvmeCtrl, ptr %13, i32 0, i32 13
  %14 = load i32, ptr %irq_status, align 4
  %or = or i32 %14, %shl
  store i32 %or, ptr %irq_status, align 4
  %15 = load ptr, ptr %n.addr, align 8
  call void @nvme_irq_check(ptr noundef %15)
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then3
  br label %if.end11

if.else10:                                        ; preds = %entry
  call void @trace_pci_nvme_irq_masked()
  br label %if.end11

if.end11:                                         ; preds = %if.else10, %if.end9
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_update_cq_eventidx(i16 noundef zeroext %cqid, i16 noundef zeroext %new_eventidx) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  %new_eventidx.addr = alloca i16, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  store i16 %new_eventidx, ptr %new_eventidx.addr, align 2
  %0 = load i16, ptr %cqid.addr, align 2
  %1 = load i16, ptr %new_eventidx.addr, align 2
  call void @_nocheck__trace_pci_nvme_update_cq_eventidx(i16 noundef zeroext %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @stl_le_pci_dma(ptr noundef %dev, i64 noundef %addr, i32 noundef %val, i32 %attrs.coerce) #0 {
entry:
  %attrs = alloca %struct.MemTxAttrs, align 4
  %dev.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %val.addr = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  store i32 %attrs.coerce, ptr %coerce.dive, align 4
  store ptr %dev, ptr %dev.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %val, ptr %val.addr, align 4
  %0 = load ptr, ptr %dev.addr, align 8
  %call = call ptr @pci_get_address_space(ptr noundef %0)
  %1 = load i64, ptr %addr.addr, align 8
  %2 = load i32, ptr %val.addr, align 4
  %coerce.dive1 = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  %3 = load i32, ptr %coerce.dive1, align 4
  %call2 = call i32 @stl_le_dma(ptr noundef %call, i64 noundef %1, i32 noundef %2, i32 %3)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_update_cq_eventidx(i16 noundef zeroext %cqid, i16 noundef zeroext %new_eventidx) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  %new_eventidx.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cqid, ptr %cqid.addr, align 2
  store i16 %new_eventidx, ptr %new_eventidx.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UPDATE_CQ_EVENTIDX_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cqid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i16, ptr %new_eventidx.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.160, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %cqid.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i16, ptr %new_eventidx.addr, align 2
  %conv14 = zext i16 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.161, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @stl_le_dma(ptr noundef %as, i64 noundef %addr, i32 noundef %val, i32 %attrs.coerce) #0 {
entry:
  %attrs = alloca %struct.MemTxAttrs, align 4
  %as.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %val.addr = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  store i32 %attrs.coerce, ptr %coerce.dive, align 4
  store ptr %as, ptr %as.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %val, ptr %val.addr, align 4
  %0 = load i32, ptr %val.addr, align 4
  %call = call i32 @cpu_to_le32(i32 noundef %0)
  store i32 %call, ptr %val.addr, align 4
  %1 = load ptr, ptr %as.addr, align 8
  %2 = load i64, ptr %addr.addr, align 8
  %coerce.dive1 = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  %3 = load i32, ptr %coerce.dive1, align 4
  %call2 = call i32 @dma_memory_write(ptr noundef %1, i64 noundef %2, ptr noundef %val.addr, i64 noundef 4, i32 %3)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @dma_memory_write(ptr noundef %as, i64 noundef %addr, ptr noundef %buf, i64 noundef %len, i32 %attrs.coerce) #0 {
entry:
  %attrs = alloca %struct.MemTxAttrs, align 4
  %as.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  store i32 %attrs.coerce, ptr %coerce.dive, align 4
  store ptr %as, ptr %as.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %as.addr, align 8
  %1 = load i64, ptr %addr.addr, align 8
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load i64, ptr %len.addr, align 8
  %coerce.dive1 = getelementptr inbounds %struct.MemTxAttrs, ptr %attrs, i32 0, i32 0
  %4 = load i32, ptr %coerce.dive1, align 4
  %call = call i32 @dma_memory_rw(ptr noundef %0, i64 noundef %1, ptr noundef %2, i64 noundef %3, i32 noundef 1, i32 %4)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_addr_write(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_ADDR_WRITE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.162, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.163, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_cfs() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_CFS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.164, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.165)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_irq_msix(i32 noundef %vector) #0 {
entry:
  %vector.addr = alloca i32, align 4
  store i32 %vector, ptr %vector.addr, align 4
  %0 = load i32, ptr %vector.addr, align 4
  call void @_nocheck__trace_pci_nvme_irq_msix(i32 noundef %0)
  ret void
}

declare void @msix_notify(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_irq_pin() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_irq_pin()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_irq_masked() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_irq_masked()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_irq_msix(i32 noundef %vector) #0 {
entry:
  %vector.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %vector, ptr %vector.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IRQ_MSIX_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %vector.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.166, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %vector.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.167, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_irq_pin() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IRQ_PIN_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.168, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.169)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_irq_masked() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IRQ_MASKED_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.170, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.171)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_process_sq(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %sq = alloca ptr, align 8
  %n = alloca ptr, align 8
  %cq = alloca ptr, align 8
  %status = alloca i16, align 2
  %addr = alloca i64, align 8
  %cmd = alloca %struct.NvmeCmd, align 1
  %req = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %sq, align 8
  %1 = load ptr, ptr %sq, align 8
  %ctrl = getelementptr inbounds %struct.NvmeSQueue, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %ctrl, align 8
  store ptr %2, ptr %n, align 8
  %3 = load ptr, ptr %n, align 8
  %cq1 = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 37
  %4 = load ptr, ptr %cq1, align 8
  %5 = load ptr, ptr %sq, align 8
  %cqid = getelementptr inbounds %struct.NvmeSQueue, ptr %5, i32 0, i32 2
  %6 = load i16, ptr %cqid, align 2
  %idxprom = zext i16 %6 to i64
  %arrayidx = getelementptr ptr, ptr %4, i64 %idxprom
  %7 = load ptr, ptr %arrayidx, align 8
  store ptr %7, ptr %cq, align 8
  %8 = load ptr, ptr %n, align 8
  %dbbuf_enabled = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 24
  %9 = load i8, ptr %dbbuf_enabled, align 16
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load ptr, ptr %sq, align 8
  call void @nvme_update_sq_tail(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end61, %if.end
  %11 = load ptr, ptr %sq, align 8
  %call = call zeroext i8 @nvme_sq_empty(ptr noundef %11)
  %conv = zext i8 %call to i32
  %tobool2 = icmp ne i32 %conv, 0
  br i1 %tobool2, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %12 = load ptr, ptr %sq, align 8
  %req_list = getelementptr inbounds %struct.NvmeSQueue, ptr %12, i32 0, i32 13
  %13 = load ptr, ptr %req_list, align 8
  %cmp = icmp eq ptr %13, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %while.cond
  %14 = phi i1 [ true, %while.cond ], [ %cmp, %lor.rhs ]
  %lnot = xor i1 %14, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %lor.end
  %15 = load ptr, ptr %sq, align 8
  %dma_addr = getelementptr inbounds %struct.NvmeSQueue, ptr %15, i32 0, i32 6
  %16 = load i64, ptr %dma_addr, align 8
  %17 = load ptr, ptr %sq, align 8
  %head = getelementptr inbounds %struct.NvmeSQueue, ptr %17, i32 0, i32 3
  %18 = load i32, ptr %head, align 4
  %shl = shl i32 %18, 6
  %conv4 = zext i32 %shl to i64
  %add = add i64 %16, %conv4
  store i64 %add, ptr %addr, align 8
  %19 = load ptr, ptr %n, align 8
  %20 = load i64, ptr %addr, align 8
  %call5 = call i32 @nvme_addr_read(ptr noundef %19, i64 noundef %20, ptr noundef %cmd, i32 noundef 64)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %while.body
  %21 = load i64, ptr %addr, align 8
  call void @trace_pci_nvme_err_addr_read(i64 noundef %21)
  call void @trace_pci_nvme_err_cfs()
  %22 = load ptr, ptr %n, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %22, i32 0, i32 3
  %csts = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 6
  call void @stl_le_p(ptr noundef %csts, i32 noundef 2)
  br label %while.end

if.end8:                                          ; preds = %while.body
  %23 = load ptr, ptr %sq, align 8
  call void @nvme_inc_sq_head(ptr noundef %23)
  %24 = load ptr, ptr %sq, align 8
  %req_list9 = getelementptr inbounds %struct.NvmeSQueue, ptr %24, i32 0, i32 13
  %25 = load ptr, ptr %req_list9, align 8
  store ptr %25, ptr %req, align 8
  br label %do.body

do.body:                                          ; preds = %if.end8
  %26 = load ptr, ptr %req, align 8
  %entry10 = getelementptr inbounds %struct.NvmeRequest, ptr %26, i32 0, i32 9
  %27 = load ptr, ptr %entry10, align 8
  %cmp11 = icmp ne ptr %27, null
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %do.body
  %28 = load ptr, ptr %req, align 8
  %entry14 = getelementptr inbounds %struct.NvmeRequest, ptr %28, i32 0, i32 9
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %entry14, i32 0, i32 1
  %29 = load ptr, ptr %tql_prev, align 8
  %30 = load ptr, ptr %req, align 8
  %entry15 = getelementptr inbounds %struct.NvmeRequest, ptr %30, i32 0, i32 9
  %31 = load ptr, ptr %entry15, align 8
  %entry16 = getelementptr inbounds %struct.NvmeRequest, ptr %31, i32 0, i32 9
  %tql_prev17 = getelementptr inbounds %struct.QTailQLink, ptr %entry16, i32 0, i32 1
  store ptr %29, ptr %tql_prev17, align 8
  br label %if.end22

if.else:                                          ; preds = %do.body
  %32 = load ptr, ptr %req, align 8
  %entry18 = getelementptr inbounds %struct.NvmeRequest, ptr %32, i32 0, i32 9
  %tql_prev19 = getelementptr inbounds %struct.QTailQLink, ptr %entry18, i32 0, i32 1
  %33 = load ptr, ptr %tql_prev19, align 8
  %34 = load ptr, ptr %sq, align 8
  %req_list20 = getelementptr inbounds %struct.NvmeSQueue, ptr %34, i32 0, i32 13
  %tql_prev21 = getelementptr inbounds %struct.QTailQLink, ptr %req_list20, i32 0, i32 1
  store ptr %33, ptr %tql_prev21, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then13
  %35 = load ptr, ptr %req, align 8
  %entry23 = getelementptr inbounds %struct.NvmeRequest, ptr %35, i32 0, i32 9
  %36 = load ptr, ptr %entry23, align 8
  %37 = load ptr, ptr %req, align 8
  %entry24 = getelementptr inbounds %struct.NvmeRequest, ptr %37, i32 0, i32 9
  %tql_prev25 = getelementptr inbounds %struct.QTailQLink, ptr %entry24, i32 0, i32 1
  %38 = load ptr, ptr %tql_prev25, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %38, i32 0, i32 0
  store ptr %36, ptr %tql_next, align 8
  %39 = load ptr, ptr %req, align 8
  %entry26 = getelementptr inbounds %struct.NvmeRequest, ptr %39, i32 0, i32 9
  %tql_prev27 = getelementptr inbounds %struct.QTailQLink, ptr %entry26, i32 0, i32 1
  store ptr null, ptr %tql_prev27, align 8
  %40 = load ptr, ptr %req, align 8
  %entry28 = getelementptr inbounds %struct.NvmeRequest, ptr %40, i32 0, i32 9
  %tql_next29 = getelementptr inbounds %struct.QTailQLink, ptr %entry28, i32 0, i32 0
  store ptr null, ptr %tql_next29, align 8
  %41 = load ptr, ptr %req, align 8
  %entry30 = getelementptr inbounds %struct.NvmeRequest, ptr %41, i32 0, i32 9
  store ptr null, ptr %entry30, align 8
  br label %do.end

do.end:                                           ; preds = %if.end22
  br label %do.body31

do.body31:                                        ; preds = %do.end
  %42 = load ptr, ptr %req, align 8
  %entry32 = getelementptr inbounds %struct.NvmeRequest, ptr %42, i32 0, i32 9
  store ptr null, ptr %entry32, align 8
  %43 = load ptr, ptr %sq, align 8
  %out_req_list = getelementptr inbounds %struct.NvmeSQueue, ptr %43, i32 0, i32 14
  %tql_prev33 = getelementptr inbounds %struct.QTailQLink, ptr %out_req_list, i32 0, i32 1
  %44 = load ptr, ptr %tql_prev33, align 8
  %45 = load ptr, ptr %req, align 8
  %entry34 = getelementptr inbounds %struct.NvmeRequest, ptr %45, i32 0, i32 9
  %tql_prev35 = getelementptr inbounds %struct.QTailQLink, ptr %entry34, i32 0, i32 1
  store ptr %44, ptr %tql_prev35, align 8
  %46 = load ptr, ptr %req, align 8
  %47 = load ptr, ptr %sq, align 8
  %out_req_list36 = getelementptr inbounds %struct.NvmeSQueue, ptr %47, i32 0, i32 14
  %tql_prev37 = getelementptr inbounds %struct.QTailQLink, ptr %out_req_list36, i32 0, i32 1
  %48 = load ptr, ptr %tql_prev37, align 8
  %tql_next38 = getelementptr inbounds %struct.QTailQLink, ptr %48, i32 0, i32 0
  store ptr %46, ptr %tql_next38, align 8
  %49 = load ptr, ptr %req, align 8
  %entry39 = getelementptr inbounds %struct.NvmeRequest, ptr %49, i32 0, i32 9
  %50 = load ptr, ptr %sq, align 8
  %out_req_list40 = getelementptr inbounds %struct.NvmeSQueue, ptr %50, i32 0, i32 14
  %tql_prev41 = getelementptr inbounds %struct.QTailQLink, ptr %out_req_list40, i32 0, i32 1
  store ptr %entry39, ptr %tql_prev41, align 8
  br label %do.end42

do.end42:                                         ; preds = %do.body31
  %51 = load ptr, ptr %req, align 8
  call void @nvme_req_clear(ptr noundef %51)
  %cid = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 2
  %52 = load i16, ptr %cid, align 1
  %53 = load ptr, ptr %req, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %53, i32 0, i32 5
  %cid43 = getelementptr inbounds %struct.NvmeCqe, ptr %cqe, i32 0, i32 4
  store i16 %52, ptr %cid43, align 4
  %54 = load ptr, ptr %req, align 8
  %cmd44 = getelementptr inbounds %struct.NvmeRequest, ptr %54, i32 0, i32 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %cmd44, ptr align 1 %cmd, i64 64, i1 false)
  %55 = load ptr, ptr %sq, align 8
  %sqid = getelementptr inbounds %struct.NvmeSQueue, ptr %55, i32 0, i32 1
  %56 = load i16, ptr %sqid, align 8
  %conv45 = zext i16 %56 to i32
  %tobool46 = icmp ne i32 %conv45, 0
  br i1 %tobool46, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end42
  %57 = load ptr, ptr %n, align 8
  %58 = load ptr, ptr %req, align 8
  %call47 = call zeroext i16 @nvme_io_cmd(ptr noundef %57, ptr noundef %58)
  %conv48 = zext i16 %call47 to i32
  br label %cond.end

cond.false:                                       ; preds = %do.end42
  %59 = load ptr, ptr %n, align 8
  %60 = load ptr, ptr %req, align 8
  %call49 = call zeroext i16 @nvme_admin_cmd(ptr noundef %59, ptr noundef %60)
  %conv50 = zext i16 %call49 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv48, %cond.true ], [ %conv50, %cond.false ]
  %conv51 = trunc i32 %cond to i16
  store i16 %conv51, ptr %status, align 2
  %61 = load i16, ptr %status, align 2
  %conv52 = zext i16 %61 to i32
  %cmp53 = icmp ne i32 %conv52, 65535
  br i1 %cmp53, label %if.then55, label %if.end57

if.then55:                                        ; preds = %cond.end
  %62 = load i16, ptr %status, align 2
  %63 = load ptr, ptr %req, align 8
  %status56 = getelementptr inbounds %struct.NvmeRequest, ptr %63, i32 0, i32 3
  store i16 %62, ptr %status56, align 8
  %64 = load ptr, ptr %cq, align 8
  %65 = load ptr, ptr %req, align 8
  call void @nvme_enqueue_req_completion(ptr noundef %64, ptr noundef %65)
  br label %if.end57

if.end57:                                         ; preds = %if.then55, %cond.end
  %66 = load ptr, ptr %n, align 8
  %dbbuf_enabled58 = getelementptr inbounds %struct.NvmeCtrl, ptr %66, i32 0, i32 24
  %67 = load i8, ptr %dbbuf_enabled58, align 16
  %tobool59 = trunc i8 %67 to i1
  br i1 %tobool59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.end57
  %68 = load ptr, ptr %sq, align 8
  call void @nvme_update_sq_eventidx(ptr noundef %68)
  %69 = load ptr, ptr %sq, align 8
  call void @nvme_update_sq_tail(ptr noundef %69)
  br label %if.end61

if.end61:                                         ; preds = %if.then60, %if.end57
  br label %while.cond, !llvm.loop !25

while.end:                                        ; preds = %if.then7, %lor.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_init_sq_ioeventfd(ptr noundef %sq) #0 {
entry:
  %retval = alloca i32, align 4
  %sq.addr = alloca ptr, align 8
  %n = alloca ptr, align 8
  %offset = alloca i16, align 2
  %ret = alloca i32, align 4
  store ptr %sq, ptr %sq.addr, align 8
  %0 = load ptr, ptr %sq.addr, align 8
  %ctrl = getelementptr inbounds %struct.NvmeSQueue, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %ctrl, align 8
  store ptr %1, ptr %n, align 8
  %2 = load ptr, ptr %sq.addr, align 8
  %sqid = getelementptr inbounds %struct.NvmeSQueue, ptr %2, i32 0, i32 1
  %3 = load i16, ptr %sqid, align 8
  %conv = zext i16 %3 to i32
  %shl = shl i32 %conv, 3
  %conv1 = trunc i32 %shl to i16
  store i16 %conv1, ptr %offset, align 2
  %4 = load ptr, ptr %sq.addr, align 8
  %notifier = getelementptr inbounds %struct.NvmeSQueue, ptr %4, i32 0, i32 10
  %call = call i32 @event_notifier_init(ptr noundef %notifier, i32 noundef 0)
  store i32 %call, ptr %ret, align 4
  %5 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, ptr %ret, align 4
  store i32 %6, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load ptr, ptr %sq.addr, align 8
  %notifier3 = getelementptr inbounds %struct.NvmeSQueue, ptr %7, i32 0, i32 10
  call void @event_notifier_set_handler(ptr noundef %notifier3, ptr noundef @nvme_sq_notifier)
  %8 = load ptr, ptr %n, align 8
  %iomem = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 2
  %9 = load i16, ptr %offset, align 2
  %conv4 = zext i16 %9 to i32
  %add = add i32 4096, %conv4
  %conv5 = sext i32 %add to i64
  %10 = load ptr, ptr %sq.addr, align 8
  %notifier6 = getelementptr inbounds %struct.NvmeSQueue, ptr %10, i32 0, i32 10
  call void @memory_region_add_eventfd(ptr noundef %iomem, i64 noundef %conv5, i32 noundef 4, i1 noundef zeroext false, i64 noundef 0, ptr noundef %notifier6)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_update_sq_tail(ptr noundef %sq) #0 {
entry:
  %sq.addr = alloca ptr, align 8
  %.compoundliteral = alloca %struct.MemTxAttrs, align 4
  store ptr %sq, ptr %sq.addr, align 8
  %0 = load ptr, ptr %sq.addr, align 8
  %ctrl = getelementptr inbounds %struct.NvmeSQueue, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %ctrl, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %1)
  %2 = load ptr, ptr %sq.addr, align 8
  %db_addr = getelementptr inbounds %struct.NvmeSQueue, ptr %2, i32 0, i32 7
  %3 = load i64, ptr %db_addr, align 8
  %4 = load ptr, ptr %sq.addr, align 8
  %tail = getelementptr inbounds %struct.NvmeSQueue, ptr %4, i32 0, i32 4
  %bf.load = load i32, ptr %.compoundliteral, align 4
  %bf.clear = and i32 %bf.load, -2
  %bf.set = or i32 %bf.clear, 1
  store i32 %bf.set, ptr %.compoundliteral, align 4
  %bf.load1 = load i32, ptr %.compoundliteral, align 4
  %bf.clear2 = and i32 %bf.load1, -3
  %bf.set3 = or i32 %bf.clear2, 0
  store i32 %bf.set3, ptr %.compoundliteral, align 4
  %bf.load4 = load i32, ptr %.compoundliteral, align 4
  %bf.clear5 = and i32 %bf.load4, -13
  %bf.set6 = or i32 %bf.clear5, 0
  store i32 %bf.set6, ptr %.compoundliteral, align 4
  %bf.load7 = load i32, ptr %.compoundliteral, align 4
  %bf.clear8 = and i32 %bf.load7, -17
  %bf.set9 = or i32 %bf.clear8, 0
  store i32 %bf.set9, ptr %.compoundliteral, align 4
  %bf.load10 = load i32, ptr %.compoundliteral, align 4
  %bf.clear11 = and i32 %bf.load10, -33
  %bf.set12 = or i32 %bf.clear11, 0
  store i32 %bf.set12, ptr %.compoundliteral, align 4
  %bf.load13 = load i32, ptr %.compoundliteral, align 4
  %bf.clear14 = and i32 %bf.load13, -4194241
  %bf.set15 = or i32 %bf.clear14, 0
  store i32 %bf.set15, ptr %.compoundliteral, align 4
  %bf.load16 = load i32, ptr %.compoundliteral, align 4
  %bf.clear17 = and i32 %bf.load16, -4194305
  %bf.set18 = or i32 %bf.clear17, 0
  store i32 %bf.set18, ptr %.compoundliteral, align 4
  %bf.load19 = load i32, ptr %.compoundliteral, align 4
  %bf.clear20 = and i32 %bf.load19, -8388609
  %bf.set21 = or i32 %bf.clear20, 0
  store i32 %bf.set21, ptr %.compoundliteral, align 4
  %bf.load22 = load i32, ptr %.compoundliteral, align 4
  %bf.clear23 = and i32 %bf.load22, -16777217
  %bf.set24 = or i32 %bf.clear23, 0
  store i32 %bf.set24, ptr %.compoundliteral, align 4
  %bf.load25 = load i32, ptr %.compoundliteral, align 4
  %bf.clear26 = and i32 %bf.load25, -33554433
  %bf.set27 = or i32 %bf.clear26, 0
  store i32 %bf.set27, ptr %.compoundliteral, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %.compoundliteral, i32 0, i32 0
  %5 = load i32, ptr %coerce.dive, align 4
  %call28 = call i32 @ldl_le_pci_dma(ptr noundef %call, i64 noundef %3, ptr noundef %tail, i32 %5)
  %6 = load ptr, ptr %sq.addr, align 8
  %sqid = getelementptr inbounds %struct.NvmeSQueue, ptr %6, i32 0, i32 1
  %7 = load i16, ptr %sqid, align 8
  %8 = load ptr, ptr %sq.addr, align 8
  %tail29 = getelementptr inbounds %struct.NvmeSQueue, ptr %8, i32 0, i32 4
  %9 = load i32, ptr %tail29, align 8
  %conv = trunc i32 %9 to i16
  call void @trace_pci_nvme_update_sq_tail(i16 noundef zeroext %7, i16 noundef zeroext %conv)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i8 @nvme_sq_empty(ptr noundef %sq) #0 {
entry:
  %sq.addr = alloca ptr, align 8
  store ptr %sq, ptr %sq.addr, align 8
  %0 = load ptr, ptr %sq.addr, align 8
  %head = getelementptr inbounds %struct.NvmeSQueue, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %head, align 4
  %2 = load ptr, ptr %sq.addr, align 8
  %tail = getelementptr inbounds %struct.NvmeSQueue, ptr %2, i32 0, i32 4
  %3 = load i32, ptr %tail, align 8
  %cmp = icmp eq i32 %1, %3
  %conv = zext i1 %cmp to i32
  %conv1 = trunc i32 %conv to i8
  ret i8 %conv1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_inc_sq_head(ptr noundef %sq) #0 {
entry:
  %sq.addr = alloca ptr, align 8
  store ptr %sq, ptr %sq.addr, align 8
  %0 = load ptr, ptr %sq.addr, align 8
  %head = getelementptr inbounds %struct.NvmeSQueue, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %head, align 4
  %add = add i32 %1, 1
  %2 = load ptr, ptr %sq.addr, align 8
  %size = getelementptr inbounds %struct.NvmeSQueue, ptr %2, i32 0, i32 5
  %3 = load i32, ptr %size, align 4
  %rem = urem i32 %add, %3
  %4 = load ptr, ptr %sq.addr, align 8
  %head1 = getelementptr inbounds %struct.NvmeSQueue, ptr %4, i32 0, i32 3
  store i32 %rem, ptr %head1, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_req_clear(ptr noundef %req) #0 {
entry:
  %req.addr = alloca ptr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %ns = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 1
  store ptr null, ptr %ns, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %opaque = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 4
  store ptr null, ptr %opaque, align 8
  %2 = load ptr, ptr %req.addr, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 2
  store ptr null, ptr %aiocb, align 8
  %3 = load ptr, ptr %req.addr, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 5
  call void @llvm.memset.p0.i64(ptr align 8 %cqe, i8 0, i64 16, i1 false)
  %4 = load ptr, ptr %req.addr, align 8
  %status = getelementptr inbounds %struct.NvmeRequest, ptr %4, i32 0, i32 3
  store i16 0, ptr %status, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_io_cmd(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %nsid = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  %nsid1 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 3
  %1 = load i32, ptr %nsid1, align 4
  %call = call i32 @le32_to_cpu(i32 noundef %1)
  store i32 %call, ptr %nsid, align 4
  %2 = load ptr, ptr %req.addr, align 8
  %call2 = call zeroext i16 @nvme_cid(ptr noundef %2)
  %3 = load i32, ptr %nsid, align 4
  %4 = load ptr, ptr %req.addr, align 8
  %call3 = call zeroext i16 @nvme_sqid(ptr noundef %4)
  %5 = load ptr, ptr %req.addr, align 8
  %cmd4 = getelementptr inbounds %struct.NvmeRequest, ptr %5, i32 0, i32 6
  %opcode = getelementptr inbounds %struct.NvmeCmd, ptr %cmd4, i32 0, i32 0
  %6 = load i8, ptr %opcode, align 8
  %7 = load ptr, ptr %req.addr, align 8
  %cmd5 = getelementptr inbounds %struct.NvmeRequest, ptr %7, i32 0, i32 6
  %opcode6 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd5, i32 0, i32 0
  %8 = load i8, ptr %opcode6, align 8
  %call7 = call ptr @nvme_io_opc_str(i8 noundef zeroext %8)
  call void @trace_pci_nvme_io_cmd(i16 noundef zeroext %call2, i32 noundef %3, i16 noundef zeroext %call3, i8 noundef zeroext %6, ptr noundef %call7)
  %9 = load ptr, ptr %n.addr, align 8
  %10 = load i32, ptr %nsid, align 4
  %call8 = call zeroext i1 @nvme_nsid_valid(ptr noundef %9, i32 noundef %10)
  br i1 %call8, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 16395, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %11 = load ptr, ptr %req.addr, align 8
  %cmd9 = getelementptr inbounds %struct.NvmeRequest, ptr %11, i32 0, i32 6
  %opcode10 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd9, i32 0, i32 0
  %12 = load i8, ptr %opcode10, align 8
  %conv = zext i8 %12 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end
  %13 = load ptr, ptr %n.addr, align 8
  %14 = load ptr, ptr %req.addr, align 8
  %call13 = call zeroext i16 @nvme_flush(ptr noundef %13, ptr noundef %14)
  store i16 %call13, ptr %retval, align 2
  br label %return

if.end14:                                         ; preds = %if.end
  %15 = load ptr, ptr %n.addr, align 8
  %16 = load i32, ptr %nsid, align 4
  %call15 = call ptr @nvme_ns(ptr noundef %15, i32 noundef %16)
  store ptr %call15, ptr %ns, align 8
  %17 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %17, null
  %lnot = xor i1 %tobool, true
  %lnot16 = xor i1 %lnot, true
  %lnot17 = xor i1 %lnot16, true
  %lnot.ext = zext i1 %lnot17 to i32
  %conv18 = sext i32 %lnot.ext to i64
  %tobool19 = icmp ne i64 %conv18, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end14
  store i16 16386, ptr %retval, align 2
  br label %return

if.end21:                                         ; preds = %if.end14
  %18 = load ptr, ptr %ns, align 8
  %iocs = getelementptr inbounds %struct.NvmeNamespace, ptr %18, i32 0, i32 10
  %19 = load ptr, ptr %iocs, align 8
  %20 = load ptr, ptr %req.addr, align 8
  %cmd22 = getelementptr inbounds %struct.NvmeRequest, ptr %20, i32 0, i32 6
  %opcode23 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd22, i32 0, i32 0
  %21 = load i8, ptr %opcode23, align 8
  %idxprom = zext i8 %21 to i64
  %arrayidx = getelementptr i32, ptr %19, i64 %idxprom
  %22 = load i32, ptr %arrayidx, align 4
  %and = and i32 %22, 1
  %tobool24 = icmp ne i32 %and, 0
  br i1 %tobool24, label %if.end28, label %if.then25

if.then25:                                        ; preds = %if.end21
  %23 = load ptr, ptr %req.addr, align 8
  %cmd26 = getelementptr inbounds %struct.NvmeRequest, ptr %23, i32 0, i32 6
  %opcode27 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd26, i32 0, i32 0
  %24 = load i8, ptr %opcode27, align 8
  call void @trace_pci_nvme_err_invalid_opc(i8 noundef zeroext %24)
  store i16 16385, ptr %retval, align 2
  br label %return

if.end28:                                         ; preds = %if.end21
  %25 = load ptr, ptr %ns, align 8
  %status = getelementptr inbounds %struct.NvmeNamespace, ptr %25, i32 0, i32 12
  %26 = load i16, ptr %status, align 2
  %tobool29 = icmp ne i16 %26, 0
  br i1 %tobool29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end28
  %27 = load ptr, ptr %ns, align 8
  %status31 = getelementptr inbounds %struct.NvmeNamespace, ptr %27, i32 0, i32 12
  %28 = load i16, ptr %status31, align 2
  store i16 %28, ptr %retval, align 2
  br label %return

if.end32:                                         ; preds = %if.end28
  %29 = load ptr, ptr %req.addr, align 8
  %cmd33 = getelementptr inbounds %struct.NvmeRequest, ptr %29, i32 0, i32 6
  %flags = getelementptr inbounds %struct.NvmeCmd, ptr %cmd33, i32 0, i32 1
  %30 = load i8, ptr %flags, align 1
  %conv34 = zext i8 %30 to i32
  %and35 = and i32 %conv34, 3
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end32
  store i16 2, ptr %retval, align 2
  br label %return

if.end38:                                         ; preds = %if.end32
  %31 = load ptr, ptr %ns, align 8
  %32 = load ptr, ptr %req.addr, align 8
  %ns39 = getelementptr inbounds %struct.NvmeRequest, ptr %32, i32 0, i32 1
  store ptr %31, ptr %ns39, align 8
  %33 = load ptr, ptr %req.addr, align 8
  %cmd40 = getelementptr inbounds %struct.NvmeRequest, ptr %33, i32 0, i32 6
  %opcode41 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd40, i32 0, i32 0
  %34 = load i8, ptr %opcode41, align 8
  %conv42 = zext i8 %34 to i32
  switch i32 %conv42, label %sw.default [
    i32 8, label %sw.bb
    i32 125, label %sw.bb44
    i32 1, label %sw.bb46
    i32 2, label %sw.bb48
    i32 5, label %sw.bb50
    i32 9, label %sw.bb52
    i32 12, label %sw.bb54
    i32 25, label %sw.bb56
    i32 121, label %sw.bb58
    i32 122, label %sw.bb60
    i32 18, label %sw.bb62
    i32 29, label %sw.bb64
  ]

sw.bb:                                            ; preds = %if.end38
  %35 = load ptr, ptr %n.addr, align 8
  %36 = load ptr, ptr %req.addr, align 8
  %call43 = call zeroext i16 @nvme_write_zeroes(ptr noundef %35, ptr noundef %36)
  store i16 %call43, ptr %retval, align 2
  br label %return

sw.bb44:                                          ; preds = %if.end38
  %37 = load ptr, ptr %n.addr, align 8
  %38 = load ptr, ptr %req.addr, align 8
  %call45 = call zeroext i16 @nvme_zone_append(ptr noundef %37, ptr noundef %38)
  store i16 %call45, ptr %retval, align 2
  br label %return

sw.bb46:                                          ; preds = %if.end38
  %39 = load ptr, ptr %n.addr, align 8
  %40 = load ptr, ptr %req.addr, align 8
  %call47 = call zeroext i16 @nvme_write(ptr noundef %39, ptr noundef %40)
  store i16 %call47, ptr %retval, align 2
  br label %return

sw.bb48:                                          ; preds = %if.end38
  %41 = load ptr, ptr %n.addr, align 8
  %42 = load ptr, ptr %req.addr, align 8
  %call49 = call zeroext i16 @nvme_read(ptr noundef %41, ptr noundef %42)
  store i16 %call49, ptr %retval, align 2
  br label %return

sw.bb50:                                          ; preds = %if.end38
  %43 = load ptr, ptr %n.addr, align 8
  %44 = load ptr, ptr %req.addr, align 8
  %call51 = call zeroext i16 @nvme_compare(ptr noundef %43, ptr noundef %44)
  store i16 %call51, ptr %retval, align 2
  br label %return

sw.bb52:                                          ; preds = %if.end38
  %45 = load ptr, ptr %n.addr, align 8
  %46 = load ptr, ptr %req.addr, align 8
  %call53 = call zeroext i16 @nvme_dsm(ptr noundef %45, ptr noundef %46)
  store i16 %call53, ptr %retval, align 2
  br label %return

sw.bb54:                                          ; preds = %if.end38
  %47 = load ptr, ptr %n.addr, align 8
  %48 = load ptr, ptr %req.addr, align 8
  %call55 = call zeroext i16 @nvme_verify(ptr noundef %47, ptr noundef %48)
  store i16 %call55, ptr %retval, align 2
  br label %return

sw.bb56:                                          ; preds = %if.end38
  %49 = load ptr, ptr %n.addr, align 8
  %50 = load ptr, ptr %req.addr, align 8
  %call57 = call zeroext i16 @nvme_copy(ptr noundef %49, ptr noundef %50)
  store i16 %call57, ptr %retval, align 2
  br label %return

sw.bb58:                                          ; preds = %if.end38
  %51 = load ptr, ptr %n.addr, align 8
  %52 = load ptr, ptr %req.addr, align 8
  %call59 = call zeroext i16 @nvme_zone_mgmt_send(ptr noundef %51, ptr noundef %52)
  store i16 %call59, ptr %retval, align 2
  br label %return

sw.bb60:                                          ; preds = %if.end38
  %53 = load ptr, ptr %n.addr, align 8
  %54 = load ptr, ptr %req.addr, align 8
  %call61 = call zeroext i16 @nvme_zone_mgmt_recv(ptr noundef %53, ptr noundef %54)
  store i16 %call61, ptr %retval, align 2
  br label %return

sw.bb62:                                          ; preds = %if.end38
  %55 = load ptr, ptr %n.addr, align 8
  %56 = load ptr, ptr %req.addr, align 8
  %call63 = call zeroext i16 @nvme_io_mgmt_recv(ptr noundef %55, ptr noundef %56)
  store i16 %call63, ptr %retval, align 2
  br label %return

sw.bb64:                                          ; preds = %if.end38
  %57 = load ptr, ptr %n.addr, align 8
  %58 = load ptr, ptr %req.addr, align 8
  %call65 = call zeroext i16 @nvme_io_mgmt_send(ptr noundef %57, ptr noundef %58)
  store i16 %call65, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %if.end38
  call void @__assert_fail(ptr noundef @.str.176, ptr noundef @.str.1, i32 noundef 4483, ptr noundef @__PRETTY_FUNCTION__.nvme_io_cmd) #12
  unreachable

return:                                           ; preds = %sw.bb64, %sw.bb62, %sw.bb60, %sw.bb58, %sw.bb56, %sw.bb54, %sw.bb52, %sw.bb50, %sw.bb48, %sw.bb46, %sw.bb44, %sw.bb, %if.then37, %if.then30, %if.then25, %if.then20, %if.then12, %if.then
  %59 = load i16, ptr %retval, align 2
  ret i16 %59
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_admin_cmd(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_cid(ptr noundef %0)
  %1 = load ptr, ptr %req.addr, align 8
  %call1 = call zeroext i16 @nvme_sqid(ptr noundef %1)
  %2 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 6
  %opcode = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 0
  %3 = load i8, ptr %opcode, align 8
  %4 = load ptr, ptr %req.addr, align 8
  %cmd2 = getelementptr inbounds %struct.NvmeRequest, ptr %4, i32 0, i32 6
  %opcode3 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd2, i32 0, i32 0
  %5 = load i8, ptr %opcode3, align 8
  %call4 = call ptr @nvme_adm_opc_str(i8 noundef zeroext %5)
  call void @trace_pci_nvme_admin_cmd(i16 noundef zeroext %call, i16 noundef zeroext %call1, i8 noundef zeroext %3, ptr noundef %call4)
  %6 = load ptr, ptr %req.addr, align 8
  %cmd5 = getelementptr inbounds %struct.NvmeRequest, ptr %6, i32 0, i32 6
  %opcode6 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd5, i32 0, i32 0
  %7 = load i8, ptr %opcode6, align 8
  %idxprom = zext i8 %7 to i64
  %arrayidx = getelementptr [256 x i32], ptr @nvme_cse_acs, i64 0, i64 %idxprom
  %8 = load i32, ptr %arrayidx, align 4
  %and = and i32 %8, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %9 = load ptr, ptr %req.addr, align 8
  %cmd7 = getelementptr inbounds %struct.NvmeRequest, ptr %9, i32 0, i32 6
  %opcode8 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd7, i32 0, i32 0
  %10 = load i8, ptr %opcode8, align 8
  call void @trace_pci_nvme_err_invalid_admin_opc(i8 noundef zeroext %10)
  store i16 16385, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %11 = load ptr, ptr %req.addr, align 8
  %cmd9 = getelementptr inbounds %struct.NvmeRequest, ptr %11, i32 0, i32 6
  %flags = getelementptr inbounds %struct.NvmeCmd, ptr %cmd9, i32 0, i32 1
  %12 = load i8, ptr %flags, align 1
  %conv = zext i8 %12 to i32
  %shr = ashr i32 %conv, 6
  %and10 = and i32 %shr, 3
  %cmp = icmp ne i32 %and10, 0
  br i1 %cmp, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  store i16 16386, ptr %retval, align 2
  br label %return

if.end13:                                         ; preds = %if.end
  %13 = load ptr, ptr %req.addr, align 8
  %cmd14 = getelementptr inbounds %struct.NvmeRequest, ptr %13, i32 0, i32 6
  %flags15 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd14, i32 0, i32 1
  %14 = load i8, ptr %flags15, align 1
  %conv16 = zext i8 %14 to i32
  %and17 = and i32 %conv16, 3
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end13
  store i16 2, ptr %retval, align 2
  br label %return

if.end20:                                         ; preds = %if.end13
  %15 = load ptr, ptr %req.addr, align 8
  %cmd21 = getelementptr inbounds %struct.NvmeRequest, ptr %15, i32 0, i32 6
  %opcode22 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd21, i32 0, i32 0
  %16 = load i8, ptr %opcode22, align 8
  %conv23 = zext i8 %16 to i32
  switch i32 %conv23, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb25
    i32 2, label %sw.bb27
    i32 4, label %sw.bb29
    i32 5, label %sw.bb31
    i32 6, label %sw.bb33
    i32 8, label %sw.bb35
    i32 9, label %sw.bb37
    i32 10, label %sw.bb39
    i32 12, label %sw.bb41
    i32 21, label %sw.bb43
    i32 28, label %sw.bb45
    i32 124, label %sw.bb47
    i32 128, label %sw.bb49
    i32 25, label %sw.bb51
    i32 26, label %sw.bb53
  ]

sw.bb:                                            ; preds = %if.end20
  %17 = load ptr, ptr %n.addr, align 8
  %18 = load ptr, ptr %req.addr, align 8
  %call24 = call zeroext i16 @nvme_del_sq(ptr noundef %17, ptr noundef %18)
  store i16 %call24, ptr %retval, align 2
  br label %return

sw.bb25:                                          ; preds = %if.end20
  %19 = load ptr, ptr %n.addr, align 8
  %20 = load ptr, ptr %req.addr, align 8
  %call26 = call zeroext i16 @nvme_create_sq(ptr noundef %19, ptr noundef %20)
  store i16 %call26, ptr %retval, align 2
  br label %return

sw.bb27:                                          ; preds = %if.end20
  %21 = load ptr, ptr %n.addr, align 8
  %22 = load ptr, ptr %req.addr, align 8
  %call28 = call zeroext i16 @nvme_get_log(ptr noundef %21, ptr noundef %22)
  store i16 %call28, ptr %retval, align 2
  br label %return

sw.bb29:                                          ; preds = %if.end20
  %23 = load ptr, ptr %n.addr, align 8
  %24 = load ptr, ptr %req.addr, align 8
  %call30 = call zeroext i16 @nvme_del_cq(ptr noundef %23, ptr noundef %24)
  store i16 %call30, ptr %retval, align 2
  br label %return

sw.bb31:                                          ; preds = %if.end20
  %25 = load ptr, ptr %n.addr, align 8
  %26 = load ptr, ptr %req.addr, align 8
  %call32 = call zeroext i16 @nvme_create_cq(ptr noundef %25, ptr noundef %26)
  store i16 %call32, ptr %retval, align 2
  br label %return

sw.bb33:                                          ; preds = %if.end20
  %27 = load ptr, ptr %n.addr, align 8
  %28 = load ptr, ptr %req.addr, align 8
  %call34 = call zeroext i16 @nvme_identify(ptr noundef %27, ptr noundef %28)
  store i16 %call34, ptr %retval, align 2
  br label %return

sw.bb35:                                          ; preds = %if.end20
  %29 = load ptr, ptr %n.addr, align 8
  %30 = load ptr, ptr %req.addr, align 8
  %call36 = call zeroext i16 @nvme_abort(ptr noundef %29, ptr noundef %30)
  store i16 %call36, ptr %retval, align 2
  br label %return

sw.bb37:                                          ; preds = %if.end20
  %31 = load ptr, ptr %n.addr, align 8
  %32 = load ptr, ptr %req.addr, align 8
  %call38 = call zeroext i16 @nvme_set_feature(ptr noundef %31, ptr noundef %32)
  store i16 %call38, ptr %retval, align 2
  br label %return

sw.bb39:                                          ; preds = %if.end20
  %33 = load ptr, ptr %n.addr, align 8
  %34 = load ptr, ptr %req.addr, align 8
  %call40 = call zeroext i16 @nvme_get_feature(ptr noundef %33, ptr noundef %34)
  store i16 %call40, ptr %retval, align 2
  br label %return

sw.bb41:                                          ; preds = %if.end20
  %35 = load ptr, ptr %n.addr, align 8
  %36 = load ptr, ptr %req.addr, align 8
  %call42 = call zeroext i16 @nvme_aer(ptr noundef %35, ptr noundef %36)
  store i16 %call42, ptr %retval, align 2
  br label %return

sw.bb43:                                          ; preds = %if.end20
  %37 = load ptr, ptr %n.addr, align 8
  %38 = load ptr, ptr %req.addr, align 8
  %call44 = call zeroext i16 @nvme_ns_attachment(ptr noundef %37, ptr noundef %38)
  store i16 %call44, ptr %retval, align 2
  br label %return

sw.bb45:                                          ; preds = %if.end20
  %39 = load ptr, ptr %n.addr, align 8
  %40 = load ptr, ptr %req.addr, align 8
  %call46 = call zeroext i16 @nvme_virt_mngmt(ptr noundef %39, ptr noundef %40)
  store i16 %call46, ptr %retval, align 2
  br label %return

sw.bb47:                                          ; preds = %if.end20
  %41 = load ptr, ptr %n.addr, align 8
  %42 = load ptr, ptr %req.addr, align 8
  %call48 = call zeroext i16 @nvme_dbbuf_config(ptr noundef %41, ptr noundef %42)
  store i16 %call48, ptr %retval, align 2
  br label %return

sw.bb49:                                          ; preds = %if.end20
  %43 = load ptr, ptr %n.addr, align 8
  %44 = load ptr, ptr %req.addr, align 8
  %call50 = call zeroext i16 @nvme_format(ptr noundef %43, ptr noundef %44)
  store i16 %call50, ptr %retval, align 2
  br label %return

sw.bb51:                                          ; preds = %if.end20
  %45 = load ptr, ptr %n.addr, align 8
  %46 = load ptr, ptr %req.addr, align 8
  %call52 = call zeroext i16 @nvme_directive_send(ptr noundef %45, ptr noundef %46)
  store i16 %call52, ptr %retval, align 2
  br label %return

sw.bb53:                                          ; preds = %if.end20
  %47 = load ptr, ptr %n.addr, align 8
  %48 = load ptr, ptr %req.addr, align 8
  %call54 = call zeroext i16 @nvme_directive_receive(ptr noundef %47, ptr noundef %48)
  store i16 %call54, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %if.end20
  call void @__assert_fail(ptr noundef @.str.176, ptr noundef @.str.1, i32 noundef 6972, ptr noundef @__PRETTY_FUNCTION__.nvme_admin_cmd) #12
  unreachable

return:                                           ; preds = %sw.bb53, %sw.bb51, %sw.bb49, %sw.bb47, %sw.bb45, %sw.bb43, %sw.bb41, %sw.bb39, %sw.bb37, %sw.bb35, %sw.bb33, %sw.bb31, %sw.bb29, %sw.bb27, %sw.bb25, %sw.bb, %if.then19, %if.then12, %if.then
  %49 = load i16, ptr %retval, align 2
  ret i16 %49
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_update_sq_eventidx(ptr noundef %sq) #0 {
entry:
  %sq.addr = alloca ptr, align 8
  %.compoundliteral = alloca %struct.MemTxAttrs, align 4
  store ptr %sq, ptr %sq.addr, align 8
  %0 = load ptr, ptr %sq.addr, align 8
  %sqid = getelementptr inbounds %struct.NvmeSQueue, ptr %0, i32 0, i32 1
  %1 = load i16, ptr %sqid, align 8
  %2 = load ptr, ptr %sq.addr, align 8
  %tail = getelementptr inbounds %struct.NvmeSQueue, ptr %2, i32 0, i32 4
  %3 = load i32, ptr %tail, align 8
  %conv = trunc i32 %3 to i16
  call void @trace_pci_nvme_update_sq_eventidx(i16 noundef zeroext %1, i16 noundef zeroext %conv)
  %4 = load ptr, ptr %sq.addr, align 8
  %ctrl = getelementptr inbounds %struct.NvmeSQueue, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %ctrl, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %5)
  %6 = load ptr, ptr %sq.addr, align 8
  %ei_addr = getelementptr inbounds %struct.NvmeSQueue, ptr %6, i32 0, i32 8
  %7 = load i64, ptr %ei_addr, align 8
  %8 = load ptr, ptr %sq.addr, align 8
  %tail1 = getelementptr inbounds %struct.NvmeSQueue, ptr %8, i32 0, i32 4
  %9 = load i32, ptr %tail1, align 8
  %bf.load = load i32, ptr %.compoundliteral, align 4
  %bf.clear = and i32 %bf.load, -2
  %bf.set = or i32 %bf.clear, 1
  store i32 %bf.set, ptr %.compoundliteral, align 4
  %bf.load2 = load i32, ptr %.compoundliteral, align 4
  %bf.clear3 = and i32 %bf.load2, -3
  %bf.set4 = or i32 %bf.clear3, 0
  store i32 %bf.set4, ptr %.compoundliteral, align 4
  %bf.load5 = load i32, ptr %.compoundliteral, align 4
  %bf.clear6 = and i32 %bf.load5, -13
  %bf.set7 = or i32 %bf.clear6, 0
  store i32 %bf.set7, ptr %.compoundliteral, align 4
  %bf.load8 = load i32, ptr %.compoundliteral, align 4
  %bf.clear9 = and i32 %bf.load8, -17
  %bf.set10 = or i32 %bf.clear9, 0
  store i32 %bf.set10, ptr %.compoundliteral, align 4
  %bf.load11 = load i32, ptr %.compoundliteral, align 4
  %bf.clear12 = and i32 %bf.load11, -33
  %bf.set13 = or i32 %bf.clear12, 0
  store i32 %bf.set13, ptr %.compoundliteral, align 4
  %bf.load14 = load i32, ptr %.compoundliteral, align 4
  %bf.clear15 = and i32 %bf.load14, -4194241
  %bf.set16 = or i32 %bf.clear15, 0
  store i32 %bf.set16, ptr %.compoundliteral, align 4
  %bf.load17 = load i32, ptr %.compoundliteral, align 4
  %bf.clear18 = and i32 %bf.load17, -4194305
  %bf.set19 = or i32 %bf.clear18, 0
  store i32 %bf.set19, ptr %.compoundliteral, align 4
  %bf.load20 = load i32, ptr %.compoundliteral, align 4
  %bf.clear21 = and i32 %bf.load20, -8388609
  %bf.set22 = or i32 %bf.clear21, 0
  store i32 %bf.set22, ptr %.compoundliteral, align 4
  %bf.load23 = load i32, ptr %.compoundliteral, align 4
  %bf.clear24 = and i32 %bf.load23, -16777217
  %bf.set25 = or i32 %bf.clear24, 0
  store i32 %bf.set25, ptr %.compoundliteral, align 4
  %bf.load26 = load i32, ptr %.compoundliteral, align 4
  %bf.clear27 = and i32 %bf.load26, -33554433
  %bf.set28 = or i32 %bf.clear27, 0
  store i32 %bf.set28, ptr %.compoundliteral, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %.compoundliteral, i32 0, i32 0
  %10 = load i32, ptr %coerce.dive, align 4
  %call29 = call i32 @stl_le_pci_dma(ptr noundef %call, i64 noundef %7, i32 noundef %9, i32 %10)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_update_sq_tail(i16 noundef zeroext %sqid, i16 noundef zeroext %new_tail) #0 {
entry:
  %sqid.addr = alloca i16, align 2
  %new_tail.addr = alloca i16, align 2
  store i16 %sqid, ptr %sqid.addr, align 2
  store i16 %new_tail, ptr %new_tail.addr, align 2
  %0 = load i16, ptr %sqid.addr, align 2
  %1 = load i16, ptr %new_tail.addr, align 2
  call void @_nocheck__trace_pci_nvme_update_sq_tail(i16 noundef zeroext %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_update_sq_tail(i16 noundef zeroext %sqid, i16 noundef zeroext %new_tail) #0 {
entry:
  %sqid.addr = alloca i16, align 2
  %new_tail.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %sqid, ptr %sqid.addr, align 2
  store i16 %new_tail, ptr %new_tail.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UPDATE_SQ_TAIL_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %sqid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i16, ptr %new_tail.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.174, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %sqid.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i16, ptr %new_tail.addr, align 2
  %conv14 = zext i16 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.175, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_io_cmd(i16 noundef zeroext %cid, i32 noundef %nsid, i16 noundef zeroext %sqid, i8 noundef zeroext %opcode, ptr noundef %opname) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %sqid.addr = alloca i16, align 2
  %opcode.addr = alloca i8, align 1
  %opname.addr = alloca ptr, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i16 %sqid, ptr %sqid.addr, align 2
  store i8 %opcode, ptr %opcode.addr, align 1
  store ptr %opname, ptr %opname.addr, align 8
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i32, ptr %nsid.addr, align 4
  %2 = load i16, ptr %sqid.addr, align 2
  %3 = load i8, ptr %opcode.addr, align 1
  %4 = load ptr, ptr %opname.addr, align 8
  call void @_nocheck__trace_pci_nvme_io_cmd(i16 noundef zeroext %0, i32 noundef %1, i16 noundef zeroext %2, i8 noundef zeroext %3, ptr noundef %4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_sqid(ptr noundef %req) #0 {
entry:
  %req.addr = alloca ptr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %sq = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %sq, align 8
  %sqid = getelementptr inbounds %struct.NvmeSQueue, ptr %1, i32 0, i32 1
  %2 = load i16, ptr %sqid, align 8
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %2)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_io_opc_str(i8 noundef zeroext %opc) #0 {
entry:
  %retval = alloca ptr, align 8
  %opc.addr = alloca i8, align 1
  store i8 %opc, ptr %opc.addr, align 1
  %0 = load i8, ptr %opc.addr, align 1
  %conv = zext i8 %0 to i32
  switch i32 %conv, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
    i32 5, label %sw.bb3
    i32 8, label %sw.bb4
    i32 9, label %sw.bb5
    i32 12, label %sw.bb6
    i32 25, label %sw.bb7
    i32 121, label %sw.bb8
    i32 122, label %sw.bb9
    i32 125, label %sw.bb10
  ]

sw.bb:                                            ; preds = %entry
  store ptr @.str.179, ptr %retval, align 8
  br label %return

sw.bb1:                                           ; preds = %entry
  store ptr @.str.180, ptr %retval, align 8
  br label %return

sw.bb2:                                           ; preds = %entry
  store ptr @.str.181, ptr %retval, align 8
  br label %return

sw.bb3:                                           ; preds = %entry
  store ptr @.str.182, ptr %retval, align 8
  br label %return

sw.bb4:                                           ; preds = %entry
  store ptr @.str.183, ptr %retval, align 8
  br label %return

sw.bb5:                                           ; preds = %entry
  store ptr @.str.184, ptr %retval, align 8
  br label %return

sw.bb6:                                           ; preds = %entry
  store ptr @.str.185, ptr %retval, align 8
  br label %return

sw.bb7:                                           ; preds = %entry
  store ptr @.str.186, ptr %retval, align 8
  br label %return

sw.bb8:                                           ; preds = %entry
  store ptr @.str.187, ptr %retval, align 8
  br label %return

sw.bb9:                                           ; preds = %entry
  store ptr @.str.188, ptr %retval, align 8
  br label %return

sw.bb10:                                          ; preds = %entry
  store ptr @.str.189, ptr %retval, align 8
  br label %return

sw.default:                                       ; preds = %entry
  store ptr @.str.190, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.default, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_nsid_valid(ptr noundef %n, i32 noundef %nsid) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %nsid.addr = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store i32 %nsid, ptr %nsid.addr, align 4
  %0 = load i32, ptr %nsid.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i32, ptr %nsid.addr, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %2 = load i32, ptr %nsid.addr, align 4
  %cmp1 = icmp ule i32 %2, 256
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %3 = phi i1 [ true, %land.rhs ], [ %cmp1, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %entry
  %4 = phi i1 [ false, %entry ], [ %3, %lor.end ]
  ret i1 %4
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_flush(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %iocb = alloca ptr, align 8
  %nsid = alloca i32, align 4
  %status = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  %nsid1 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 3
  %1 = load i32, ptr %nsid1, align 4
  %call = call i32 @le32_to_cpu(i32 noundef %1)
  store i32 %call, ptr %nsid, align 4
  %2 = load ptr, ptr %req.addr, align 8
  %call2 = call ptr @qemu_aio_get(ptr noundef @nvme_flush_aiocb_info, ptr noundef null, ptr noundef @nvme_misc_cb, ptr noundef %2)
  store ptr %call2, ptr %iocb, align 8
  %3 = load ptr, ptr %req.addr, align 8
  %4 = load ptr, ptr %iocb, align 8
  %req3 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %4, i32 0, i32 2
  store ptr %3, ptr %req3, align 8
  %5 = load ptr, ptr %iocb, align 8
  %ret = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %5, i32 0, i32 3
  store i32 0, ptr %ret, align 8
  %6 = load ptr, ptr %iocb, align 8
  %ns = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %6, i32 0, i32 4
  store ptr null, ptr %ns, align 8
  %7 = load ptr, ptr %iocb, align 8
  %nsid4 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %7, i32 0, i32 5
  store i32 0, ptr %nsid4, align 8
  %8 = load i32, ptr %nsid, align 4
  %cmp = icmp eq i32 %8, -1
  %9 = load ptr, ptr %iocb, align 8
  %broadcast = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %9, i32 0, i32 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, ptr %broadcast, align 4
  %10 = load ptr, ptr %iocb, align 8
  %broadcast5 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %10, i32 0, i32 6
  %11 = load i8, ptr %broadcast5, align 4
  %tobool = trunc i8 %11 to i1
  br i1 %tobool, label %if.end15, label %if.then

if.then:                                          ; preds = %entry
  %12 = load ptr, ptr %n.addr, align 8
  %13 = load i32, ptr %nsid, align 4
  %call6 = call zeroext i1 @nvme_nsid_valid(ptr noundef %12, i32 noundef %13)
  br i1 %call6, label %if.end, label %if.then7

if.then7:                                         ; preds = %if.then
  store i16 16395, ptr %status, align 2
  br label %out

if.end:                                           ; preds = %if.then
  %14 = load ptr, ptr %n.addr, align 8
  %15 = load i32, ptr %nsid, align 4
  %call8 = call ptr @nvme_ns(ptr noundef %14, i32 noundef %15)
  %16 = load ptr, ptr %iocb, align 8
  %ns9 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %16, i32 0, i32 4
  store ptr %call8, ptr %ns9, align 8
  %17 = load ptr, ptr %iocb, align 8
  %ns10 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %17, i32 0, i32 4
  %18 = load ptr, ptr %ns10, align 8
  %tobool11 = icmp ne ptr %18, null
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end
  store i16 16386, ptr %status, align 2
  br label %out

if.end13:                                         ; preds = %if.end
  %19 = load i32, ptr %nsid, align 4
  %20 = load ptr, ptr %iocb, align 8
  %nsid14 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %20, i32 0, i32 5
  store i32 %19, ptr %nsid14, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.end13, %entry
  %21 = load ptr, ptr %iocb, align 8
  %common = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %21, i32 0, i32 0
  %22 = load ptr, ptr %req.addr, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %22, i32 0, i32 2
  store ptr %common, ptr %aiocb, align 8
  %23 = load ptr, ptr %iocb, align 8
  call void @nvme_do_flush(ptr noundef %23)
  store i16 -1, ptr %retval, align 2
  br label %return

out:                                              ; preds = %if.then12, %if.then7
  %24 = load ptr, ptr %iocb, align 8
  call void @qemu_aio_unref(ptr noundef %24)
  %25 = load i16, ptr %status, align 2
  store i16 %25, ptr %retval, align 2
  br label %return

return:                                           ; preds = %out, %if.end15
  %26 = load i16, ptr %retval, align 2
  ret i16 %26
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_opc(i8 noundef zeroext %opc) #0 {
entry:
  %opc.addr = alloca i8, align 1
  store i8 %opc, ptr %opc.addr, align 1
  %0 = load i8, ptr %opc.addr, align 1
  call void @_nocheck__trace_pci_nvme_err_invalid_opc(i8 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_write_zeroes(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_do_write(ptr noundef %0, ptr noundef %1, i1 noundef zeroext false, i1 noundef zeroext true)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_zone_append(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_do_write(ptr noundef %0, ptr noundef %1, i1 noundef zeroext true, i1 noundef zeroext false)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_write(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_do_write(ptr noundef %0, ptr noundef %1, i1 noundef zeroext false, i1 noundef zeroext false)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_read(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %rw = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %slba = alloca i64, align 8
  %nlb = alloca i32, align 4
  %prinfo = alloca i8, align 1
  %data_size = alloca i64, align 8
  %mapped_size = alloca i64, align 8
  %data_offset = alloca i64, align 8
  %blk = alloca ptr, align 8
  %status = alloca i16, align 2
  %pract = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %ns1, align 8
  store ptr %2, ptr %ns, align 8
  %3 = load ptr, ptr %rw, align 8
  %slba2 = getelementptr inbounds %struct.NvmeRwCmd, ptr %3, i32 0, i32 8
  %4 = load i64, ptr %slba2, align 1
  %call = call i64 @le64_to_cpu(i64 noundef %4)
  store i64 %call, ptr %slba, align 8
  %5 = load ptr, ptr %rw, align 8
  %nlb3 = getelementptr inbounds %struct.NvmeRwCmd, ptr %5, i32 0, i32 9
  %6 = load i16, ptr %nlb3, align 1
  %call4 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %6)
  %conv = zext i16 %call4 to i32
  %add = add i32 %conv, 1
  store i32 %add, ptr %nlb, align 4
  %7 = load ptr, ptr %rw, align 8
  %control = getelementptr inbounds %struct.NvmeRwCmd, ptr %7, i32 0, i32 10
  %8 = load i16, ptr %control, align 1
  %call5 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %8)
  %conv6 = zext i16 %call5 to i32
  %shr = ashr i32 %conv6, 10
  %and = and i32 %shr, 15
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, ptr %prinfo, align 1
  %9 = load ptr, ptr %ns, align 8
  %10 = load i32, ptr %nlb, align 4
  %conv8 = zext i32 %10 to i64
  %call9 = call i64 @nvme_l2b(ptr noundef %9, i64 noundef %conv8)
  store i64 %call9, ptr %data_size, align 8
  %11 = load i64, ptr %data_size, align 8
  store i64 %11, ptr %mapped_size, align 8
  %12 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %12, i32 0, i32 1
  %blk10 = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %13 = load ptr, ptr %blk10, align 8
  store ptr %13, ptr %blk, align 8
  %14 = load ptr, ptr %ns, align 8
  %call11 = call zeroext i1 @nvme_ns_ext(ptr noundef %14)
  br i1 %call11, label %if.then, label %if.end28

if.then:                                          ; preds = %entry
  %15 = load ptr, ptr %ns, align 8
  %16 = load i32, ptr %nlb, align 4
  %conv12 = zext i32 %16 to i64
  %call13 = call i64 @nvme_m2b(ptr noundef %15, i64 noundef %conv12)
  %17 = load i64, ptr %mapped_size, align 8
  %add14 = add i64 %17, %call13
  store i64 %add14, ptr %mapped_size, align 8
  %18 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %18, i32 0, i32 5
  %dps = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 8
  %19 = load i8, ptr %dps, align 1
  %conv15 = zext i8 %19 to i32
  %and16 = and i32 %conv15, 7
  %tobool = icmp ne i32 %and16, 0
  br i1 %tobool, label %if.then17, label %if.end27

if.then17:                                        ; preds = %if.then
  %20 = load i8, ptr %prinfo, align 1
  %conv18 = zext i8 %20 to i32
  %and19 = and i32 %conv18, 8
  %tobool20 = icmp ne i32 %and19, 0
  %frombool = zext i1 %tobool20 to i8
  store i8 %frombool, ptr %pract, align 1
  %21 = load i8, ptr %pract, align 1
  %tobool21 = trunc i8 %21 to i1
  br i1 %tobool21, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then17
  %22 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %22, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %23 = load i16, ptr %ms, align 8
  %conv23 = zext i16 %23 to i64
  %24 = load ptr, ptr %ns, align 8
  %call24 = call i64 @nvme_pi_tuple_size(ptr noundef %24)
  %cmp = icmp eq i64 %conv23, %call24
  br i1 %cmp, label %if.then26, label %if.end

if.then26:                                        ; preds = %land.lhs.true
  %25 = load i64, ptr %data_size, align 8
  store i64 %25, ptr %mapped_size, align 8
  br label %if.end

if.end:                                           ; preds = %if.then26, %land.lhs.true, %if.then17
  br label %if.end27

if.end27:                                         ; preds = %if.end, %if.then
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %entry
  %26 = load ptr, ptr %req.addr, align 8
  %call29 = call zeroext i16 @nvme_cid(ptr noundef %26)
  %27 = load ptr, ptr %ns, align 8
  %call30 = call i32 @nvme_nsid(ptr noundef %27)
  %28 = load i32, ptr %nlb, align 4
  %29 = load i64, ptr %mapped_size, align 8
  %30 = load i64, ptr %slba, align 8
  call void @trace_pci_nvme_read(i16 noundef zeroext %call29, i32 noundef %call30, i32 noundef %28, i64 noundef %29, i64 noundef %30)
  %31 = load ptr, ptr %n.addr, align 8
  %32 = load i64, ptr %mapped_size, align 8
  %call31 = call zeroext i16 @nvme_check_mdts(ptr noundef %31, i64 noundef %32)
  store i16 %call31, ptr %status, align 2
  %33 = load i16, ptr %status, align 2
  %tobool32 = icmp ne i16 %33, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end28
  br label %invalid

if.end34:                                         ; preds = %if.end28
  %34 = load ptr, ptr %ns, align 8
  %35 = load i64, ptr %slba, align 8
  %36 = load i32, ptr %nlb, align 4
  %call35 = call zeroext i16 @nvme_check_bounds(ptr noundef %34, i64 noundef %35, i32 noundef %36)
  store i16 %call35, ptr %status, align 2
  %37 = load i16, ptr %status, align 2
  %tobool36 = icmp ne i16 %37, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end34
  br label %invalid

if.end38:                                         ; preds = %if.end34
  %38 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %38, i32 0, i32 30
  %zoned = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 14
  %39 = load i8, ptr %zoned, align 1
  %tobool39 = trunc i8 %39 to i1
  br i1 %tobool39, label %if.then40, label %if.end45

if.then40:                                        ; preds = %if.end38
  %40 = load ptr, ptr %ns, align 8
  %41 = load i64, ptr %slba, align 8
  %42 = load i32, ptr %nlb, align 4
  %call41 = call zeroext i16 @nvme_check_zone_read(ptr noundef %40, i64 noundef %41, i32 noundef %42)
  store i16 %call41, ptr %status, align 2
  %43 = load i16, ptr %status, align 2
  %tobool42 = icmp ne i16 %43, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.then40
  %44 = load i64, ptr %slba, align 8
  %45 = load i32, ptr %nlb, align 4
  %46 = load i16, ptr %status, align 2
  call void @trace_pci_nvme_err_zone_read_not_ok(i64 noundef %44, i32 noundef %45, i16 noundef zeroext %46)
  br label %invalid

if.end44:                                         ; preds = %if.then40
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %if.end38
  %47 = load ptr, ptr %ns, align 8
  %features = getelementptr inbounds %struct.NvmeNamespace, ptr %47, i32 0, i32 33
  %err_rec = getelementptr inbounds %struct.anon.13, ptr %features, i32 0, i32 0
  %48 = load i32, ptr %err_rec, align 8
  %and46 = and i32 %48, 65536
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.then48, label %if.end53

if.then48:                                        ; preds = %if.end45
  %49 = load ptr, ptr %ns, align 8
  %50 = load i64, ptr %slba, align 8
  %51 = load i32, ptr %nlb, align 4
  %call49 = call zeroext i16 @nvme_check_dulbe(ptr noundef %49, i64 noundef %50, i32 noundef %51)
  store i16 %call49, ptr %status, align 2
  %52 = load i16, ptr %status, align 2
  %tobool50 = icmp ne i16 %52, 0
  br i1 %tobool50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.then48
  br label %invalid

if.end52:                                         ; preds = %if.then48
  br label %if.end53

if.end53:                                         ; preds = %if.end52, %if.end45
  %53 = load ptr, ptr %ns, align 8
  %id_ns54 = getelementptr inbounds %struct.NvmeNamespace, ptr %53, i32 0, i32 5
  %dps55 = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns54, i32 0, i32 8
  %54 = load i8, ptr %dps55, align 1
  %conv56 = zext i8 %54 to i32
  %and57 = and i32 %conv56, 7
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.then59, label %if.end61

if.then59:                                        ; preds = %if.end53
  %55 = load ptr, ptr %n.addr, align 8
  %56 = load ptr, ptr %req.addr, align 8
  %call60 = call zeroext i16 @nvme_dif_rw(ptr noundef %55, ptr noundef %56)
  store i16 %call60, ptr %retval, align 2
  br label %return

if.end61:                                         ; preds = %if.end53
  %57 = load ptr, ptr %n.addr, align 8
  %58 = load i32, ptr %nlb, align 4
  %59 = load ptr, ptr %req.addr, align 8
  %call62 = call zeroext i16 @nvme_map_data(ptr noundef %57, i32 noundef %58, ptr noundef %59)
  store i16 %call62, ptr %status, align 2
  %60 = load i16, ptr %status, align 2
  %tobool63 = icmp ne i16 %60, 0
  br i1 %tobool63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.end61
  br label %invalid

if.end65:                                         ; preds = %if.end61
  %61 = load ptr, ptr %ns, align 8
  %62 = load i64, ptr %slba, align 8
  %call66 = call i64 @nvme_l2b(ptr noundef %61, i64 noundef %62)
  store i64 %call66, ptr %data_offset, align 8
  %63 = load ptr, ptr %blk, align 8
  %call67 = call ptr @blk_get_stats(ptr noundef %63)
  %64 = load ptr, ptr %req.addr, align 8
  %acct = getelementptr inbounds %struct.NvmeRequest, ptr %64, i32 0, i32 7
  %65 = load i64, ptr %data_size, align 8
  call void @block_acct_start(ptr noundef %call67, ptr noundef %acct, i64 noundef %65, i32 noundef 1)
  %66 = load ptr, ptr %blk, align 8
  %67 = load i64, ptr %data_offset, align 8
  %68 = load ptr, ptr %req.addr, align 8
  call void @nvme_blk_read(ptr noundef %66, i64 noundef %67, i32 noundef 512, ptr noundef @nvme_rw_cb, ptr noundef %68)
  store i16 -1, ptr %retval, align 2
  br label %return

invalid:                                          ; preds = %if.then64, %if.then51, %if.then43, %if.then37, %if.then33
  %69 = load ptr, ptr %blk, align 8
  %call68 = call ptr @blk_get_stats(ptr noundef %69)
  call void @block_acct_invalid(ptr noundef %call68, i32 noundef 1)
  %70 = load i16, ptr %status, align 2
  %conv69 = zext i16 %70 to i32
  %or = or i32 %conv69, 16384
  %conv70 = trunc i32 %or to i16
  store i16 %conv70, ptr %retval, align 2
  br label %return

return:                                           ; preds = %invalid, %if.end65, %if.then59
  %71 = load i16, ptr %retval, align 2
  ret i16 %71
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_compare(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %rw = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %blk = alloca ptr, align 8
  %slba = alloca i64, align 8
  %nlb = alloca i32, align 4
  %prinfo = alloca i8, align 1
  %data_len = alloca i64, align 8
  %len = alloca i64, align 8
  %offset = alloca i64, align 8
  %ctx = alloca ptr, align 8
  %status = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %ns1, align 8
  store ptr %2, ptr %ns, align 8
  %3 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 1
  %blk2 = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %4 = load ptr, ptr %blk2, align 8
  store ptr %4, ptr %blk, align 8
  %5 = load ptr, ptr %rw, align 8
  %slba3 = getelementptr inbounds %struct.NvmeRwCmd, ptr %5, i32 0, i32 8
  %6 = load i64, ptr %slba3, align 1
  %call = call i64 @le64_to_cpu(i64 noundef %6)
  store i64 %call, ptr %slba, align 8
  %7 = load ptr, ptr %rw, align 8
  %nlb4 = getelementptr inbounds %struct.NvmeRwCmd, ptr %7, i32 0, i32 9
  %8 = load i16, ptr %nlb4, align 1
  %call5 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %8)
  %conv = zext i16 %call5 to i32
  %add = add i32 %conv, 1
  store i32 %add, ptr %nlb, align 4
  %9 = load ptr, ptr %rw, align 8
  %control = getelementptr inbounds %struct.NvmeRwCmd, ptr %9, i32 0, i32 10
  %10 = load i16, ptr %control, align 1
  %call6 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %10)
  %conv7 = zext i16 %call6 to i32
  %shr = ashr i32 %conv7, 10
  %and = and i32 %shr, 15
  %conv8 = trunc i32 %and to i8
  store i8 %conv8, ptr %prinfo, align 1
  %11 = load ptr, ptr %ns, align 8
  %12 = load i32, ptr %nlb, align 4
  %conv9 = zext i32 %12 to i64
  %call10 = call i64 @nvme_l2b(ptr noundef %11, i64 noundef %conv9)
  store i64 %call10, ptr %data_len, align 8
  %13 = load i64, ptr %data_len, align 8
  store i64 %13, ptr %len, align 8
  %14 = load ptr, ptr %ns, align 8
  %15 = load i64, ptr %slba, align 8
  %call11 = call i64 @nvme_l2b(ptr noundef %14, i64 noundef %15)
  store i64 %call11, ptr %offset, align 8
  store ptr null, ptr %ctx, align 8
  %16 = load ptr, ptr %req.addr, align 8
  %call12 = call zeroext i16 @nvme_cid(ptr noundef %16)
  %17 = load ptr, ptr %ns, align 8
  %call13 = call i32 @nvme_nsid(ptr noundef %17)
  %18 = load i64, ptr %slba, align 8
  %19 = load i32, ptr %nlb, align 4
  call void @trace_pci_nvme_compare(i16 noundef zeroext %call12, i32 noundef %call13, i64 noundef %18, i32 noundef %19)
  %20 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %20, i32 0, i32 5
  %dps = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 8
  %21 = load i8, ptr %dps, align 1
  %conv14 = zext i8 %21 to i32
  %and15 = and i32 %conv14, 7
  %tobool = icmp ne i32 %and15, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %22 = load i8, ptr %prinfo, align 1
  %conv16 = zext i8 %22 to i32
  %and17 = and i32 %conv16, 8
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i16 16769, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %23 = load ptr, ptr %ns, align 8
  %call19 = call zeroext i1 @nvme_ns_ext(ptr noundef %23)
  br i1 %call19, label %if.then20, label %if.end24

if.then20:                                        ; preds = %if.end
  %24 = load ptr, ptr %ns, align 8
  %25 = load i32, ptr %nlb, align 4
  %conv21 = zext i32 %25 to i64
  %call22 = call i64 @nvme_m2b(ptr noundef %24, i64 noundef %conv21)
  %26 = load i64, ptr %len, align 8
  %add23 = add i64 %26, %call22
  store i64 %add23, ptr %len, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then20, %if.end
  %27 = load ptr, ptr %n.addr, align 8
  %28 = load i64, ptr %len, align 8
  %call25 = call zeroext i16 @nvme_check_mdts(ptr noundef %27, i64 noundef %28)
  store i16 %call25, ptr %status, align 2
  %29 = load i16, ptr %status, align 2
  %tobool26 = icmp ne i16 %29, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end24
  %30 = load i16, ptr %status, align 2
  store i16 %30, ptr %retval, align 2
  br label %return

if.end28:                                         ; preds = %if.end24
  %31 = load ptr, ptr %ns, align 8
  %32 = load i64, ptr %slba, align 8
  %33 = load i32, ptr %nlb, align 4
  %call29 = call zeroext i16 @nvme_check_bounds(ptr noundef %31, i64 noundef %32, i32 noundef %33)
  store i16 %call29, ptr %status, align 2
  %34 = load i16, ptr %status, align 2
  %tobool30 = icmp ne i16 %34, 0
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end28
  %35 = load i16, ptr %status, align 2
  store i16 %35, ptr %retval, align 2
  br label %return

if.end32:                                         ; preds = %if.end28
  %36 = load ptr, ptr %ns, align 8
  %features = getelementptr inbounds %struct.NvmeNamespace, ptr %36, i32 0, i32 33
  %err_rec = getelementptr inbounds %struct.anon.13, ptr %features, i32 0, i32 0
  %37 = load i32, ptr %err_rec, align 8
  %and33 = and i32 %37, 65536
  %tobool34 = icmp ne i32 %and33, 0
  br i1 %tobool34, label %if.then35, label %if.end40

if.then35:                                        ; preds = %if.end32
  %38 = load ptr, ptr %ns, align 8
  %39 = load i64, ptr %slba, align 8
  %40 = load i32, ptr %nlb, align 4
  %call36 = call zeroext i16 @nvme_check_dulbe(ptr noundef %38, i64 noundef %39, i32 noundef %40)
  store i16 %call36, ptr %status, align 2
  %41 = load i16, ptr %status, align 2
  %tobool37 = icmp ne i16 %41, 0
  br i1 %tobool37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.then35
  %42 = load i16, ptr %status, align 2
  store i16 %42, ptr %retval, align 2
  br label %return

if.end39:                                         ; preds = %if.then35
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.end32
  %43 = load ptr, ptr %n.addr, align 8
  %44 = load ptr, ptr %req.addr, align 8
  %sg = getelementptr inbounds %struct.NvmeRequest, ptr %44, i32 0, i32 8
  %45 = load i64, ptr %len, align 8
  %46 = load ptr, ptr %req.addr, align 8
  %cmd41 = getelementptr inbounds %struct.NvmeRequest, ptr %46, i32 0, i32 6
  %call42 = call zeroext i16 @nvme_map_dptr(ptr noundef %43, ptr noundef %sg, i64 noundef %45, ptr noundef %cmd41)
  store i16 %call42, ptr %status, align 2
  %47 = load i16, ptr %status, align 2
  %tobool43 = icmp ne i16 %47, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end40
  %48 = load i16, ptr %status, align 2
  store i16 %48, ptr %retval, align 2
  br label %return

if.end45:                                         ; preds = %if.end40
  %call46 = call noalias ptr @g_malloc_n(i64 noundef 1, i64 noundef 96) #11
  store ptr %call46, ptr %ctx, align 8
  %49 = load i64, ptr %data_len, align 8
  %call47 = call noalias ptr @g_malloc(i64 noundef %49) #14
  %50 = load ptr, ptr %ctx, align 8
  %data = getelementptr inbounds %struct.nvme_compare_ctx, ptr %50, i32 0, i32 0
  %bounce = getelementptr inbounds %struct.anon.38, ptr %data, i32 0, i32 1
  store ptr %call47, ptr %bounce, align 8
  %51 = load ptr, ptr %ctx, align 8
  %52 = load ptr, ptr %req.addr, align 8
  %opaque = getelementptr inbounds %struct.NvmeRequest, ptr %52, i32 0, i32 4
  store ptr %51, ptr %opaque, align 8
  %53 = load ptr, ptr %ctx, align 8
  %data48 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %53, i32 0, i32 0
  %iov = getelementptr inbounds %struct.anon.38, ptr %data48, i32 0, i32 0
  call void @qemu_iovec_init(ptr noundef %iov, i32 noundef 1)
  %54 = load ptr, ptr %ctx, align 8
  %data49 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %54, i32 0, i32 0
  %iov50 = getelementptr inbounds %struct.anon.38, ptr %data49, i32 0, i32 0
  %55 = load ptr, ptr %ctx, align 8
  %data51 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %55, i32 0, i32 0
  %bounce52 = getelementptr inbounds %struct.anon.38, ptr %data51, i32 0, i32 1
  %56 = load ptr, ptr %bounce52, align 8
  %57 = load i64, ptr %data_len, align 8
  call void @qemu_iovec_add(ptr noundef %iov50, ptr noundef %56, i64 noundef %57)
  %58 = load ptr, ptr %blk, align 8
  %call53 = call ptr @blk_get_stats(ptr noundef %58)
  %59 = load ptr, ptr %req.addr, align 8
  %acct = getelementptr inbounds %struct.NvmeRequest, ptr %59, i32 0, i32 7
  %60 = load i64, ptr %data_len, align 8
  call void @block_acct_start(ptr noundef %call53, ptr noundef %acct, i64 noundef %60, i32 noundef 1)
  %61 = load ptr, ptr %blk, align 8
  %62 = load i64, ptr %offset, align 8
  %63 = load ptr, ptr %ctx, align 8
  %data54 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %63, i32 0, i32 0
  %iov55 = getelementptr inbounds %struct.anon.38, ptr %data54, i32 0, i32 0
  %64 = load ptr, ptr %req.addr, align 8
  %call56 = call ptr @blk_aio_preadv(ptr noundef %61, i64 noundef %62, ptr noundef %iov55, i32 noundef 0, ptr noundef @nvme_compare_data_cb, ptr noundef %64)
  %65 = load ptr, ptr %req.addr, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %65, i32 0, i32 2
  store ptr %call56, ptr %aiocb, align 8
  store i16 -1, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end45, %if.then44, %if.then38, %if.then31, %if.then27, %if.then
  %66 = load i16, ptr %retval, align 2
  ret i16 %66
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_dsm(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %dsm = alloca ptr, align 8
  %attr = alloca i32, align 4
  %nr = alloca i32, align 4
  %status = alloca i16, align 2
  %iocb = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %ns1, align 8
  store ptr %1, ptr %ns, align 8
  %2 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 6
  store ptr %cmd, ptr %dsm, align 8
  %3 = load ptr, ptr %dsm, align 8
  %attributes = getelementptr inbounds %struct.NvmeDsmCmd, ptr %3, i32 0, i32 7
  %4 = load i32, ptr %attributes, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %4)
  store i32 %call, ptr %attr, align 4
  %5 = load ptr, ptr %dsm, align 8
  %nr2 = getelementptr inbounds %struct.NvmeDsmCmd, ptr %5, i32 0, i32 6
  %6 = load i32, ptr %nr2, align 1
  %call3 = call i32 @le32_to_cpu(i32 noundef %6)
  %and = and i32 %call3, 255
  %add = add i32 %and, 1
  store i32 %add, ptr %nr, align 4
  store i16 0, ptr %status, align 2
  %7 = load i32, ptr %nr, align 4
  %8 = load i32, ptr %attr, align 4
  call void @trace_pci_nvme_dsm(i32 noundef %7, i32 noundef %8)
  %9 = load i32, ptr %attr, align 4
  %and4 = and i32 %9, 4
  %tobool = icmp ne i32 %and4, 0
  br i1 %tobool, label %if.then, label %if.end16

if.then:                                          ; preds = %entry
  %10 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %10, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %11 = load ptr, ptr %blk, align 8
  %12 = load ptr, ptr %req.addr, align 8
  %call5 = call ptr @blk_aio_get(ptr noundef @nvme_dsm_aiocb_info, ptr noundef %11, ptr noundef @nvme_misc_cb, ptr noundef %12)
  store ptr %call5, ptr %iocb, align 8
  %13 = load ptr, ptr %req.addr, align 8
  %14 = load ptr, ptr %iocb, align 8
  %req6 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %14, i32 0, i32 2
  store ptr %13, ptr %req6, align 8
  %15 = load ptr, ptr %iocb, align 8
  %ret = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %15, i32 0, i32 3
  store i32 0, ptr %ret, align 8
  %16 = load i32, ptr %nr, align 4
  %conv = zext i32 %16 to i64
  %call7 = call noalias ptr @g_malloc_n(i64 noundef %conv, i64 noundef 16) #11
  %17 = load ptr, ptr %iocb, align 8
  %range = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %17, i32 0, i32 4
  store ptr %call7, ptr %range, align 8
  %18 = load i32, ptr %nr, align 4
  %19 = load ptr, ptr %iocb, align 8
  %nr8 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %19, i32 0, i32 5
  store i32 %18, ptr %nr8, align 8
  %20 = load ptr, ptr %iocb, align 8
  %idx = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %20, i32 0, i32 6
  store i32 0, ptr %idx, align 4
  %21 = load ptr, ptr %n.addr, align 8
  %22 = load ptr, ptr %iocb, align 8
  %range9 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %22, i32 0, i32 4
  %23 = load ptr, ptr %range9, align 8
  %24 = load i32, ptr %nr, align 4
  %conv10 = zext i32 %24 to i64
  %mul = mul i64 16, %conv10
  %conv11 = trunc i64 %mul to i32
  %25 = load ptr, ptr %req.addr, align 8
  %call12 = call zeroext i16 @nvme_h2c(ptr noundef %21, ptr noundef %23, i32 noundef %conv11, ptr noundef %25)
  store i16 %call12, ptr %status, align 2
  %26 = load i16, ptr %status, align 2
  %tobool13 = icmp ne i16 %26, 0
  br i1 %tobool13, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.then
  %27 = load ptr, ptr %iocb, align 8
  %range15 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %27, i32 0, i32 4
  %28 = load ptr, ptr %range15, align 8
  call void @g_free(ptr noundef %28)
  %29 = load ptr, ptr %iocb, align 8
  call void @qemu_aio_unref(ptr noundef %29)
  %30 = load i16, ptr %status, align 2
  store i16 %30, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %if.then
  %31 = load ptr, ptr %iocb, align 8
  %common = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %31, i32 0, i32 0
  %32 = load ptr, ptr %req.addr, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %32, i32 0, i32 2
  store ptr %common, ptr %aiocb, align 8
  %33 = load ptr, ptr %iocb, align 8
  call void @nvme_dsm_cb(ptr noundef %33, i32 noundef 0)
  store i16 -1, ptr %retval, align 2
  br label %return

if.end16:                                         ; preds = %entry
  %34 = load i16, ptr %status, align 2
  store i16 %34, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end16, %if.end, %if.then14
  %35 = load i16, ptr %retval, align 2
  ret i16 %35
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_verify(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %rw = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %blk = alloca ptr, align 8
  %slba = alloca i64, align 8
  %nlb = alloca i32, align 4
  %len = alloca i64, align 8
  %offset = alloca i64, align 8
  %prinfo = alloca i8, align 1
  %reftag = alloca i32, align 4
  %ctx = alloca ptr, align 8
  %status = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %ns1, align 8
  store ptr %2, ptr %ns, align 8
  %3 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 1
  %blk2 = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %4 = load ptr, ptr %blk2, align 8
  store ptr %4, ptr %blk, align 8
  %5 = load ptr, ptr %rw, align 8
  %slba3 = getelementptr inbounds %struct.NvmeRwCmd, ptr %5, i32 0, i32 8
  %6 = load i64, ptr %slba3, align 1
  %call = call i64 @le64_to_cpu(i64 noundef %6)
  store i64 %call, ptr %slba, align 8
  %7 = load ptr, ptr %rw, align 8
  %nlb4 = getelementptr inbounds %struct.NvmeRwCmd, ptr %7, i32 0, i32 9
  %8 = load i16, ptr %nlb4, align 1
  %call5 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %8)
  %conv = zext i16 %call5 to i32
  %add = add i32 %conv, 1
  store i32 %add, ptr %nlb, align 4
  %9 = load ptr, ptr %ns, align 8
  %10 = load i32, ptr %nlb, align 4
  %conv6 = zext i32 %10 to i64
  %call7 = call i64 @nvme_l2b(ptr noundef %9, i64 noundef %conv6)
  store i64 %call7, ptr %len, align 8
  %11 = load ptr, ptr %ns, align 8
  %12 = load i64, ptr %slba, align 8
  %call8 = call i64 @nvme_l2b(ptr noundef %11, i64 noundef %12)
  store i64 %call8, ptr %offset, align 8
  %13 = load ptr, ptr %rw, align 8
  %control = getelementptr inbounds %struct.NvmeRwCmd, ptr %13, i32 0, i32 10
  %14 = load i16, ptr %control, align 1
  %call9 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %14)
  %conv10 = zext i16 %call9 to i32
  %shr = ashr i32 %conv10, 10
  %and = and i32 %shr, 15
  %conv11 = trunc i32 %and to i8
  store i8 %conv11, ptr %prinfo, align 1
  %15 = load ptr, ptr %rw, align 8
  %reftag12 = getelementptr inbounds %struct.NvmeRwCmd, ptr %15, i32 0, i32 14
  %16 = load i32, ptr %reftag12, align 1
  %call13 = call i32 @le32_to_cpu(i32 noundef %16)
  store i32 %call13, ptr %reftag, align 4
  store ptr null, ptr %ctx, align 8
  %17 = load ptr, ptr %req.addr, align 8
  %call14 = call zeroext i16 @nvme_cid(ptr noundef %17)
  %18 = load ptr, ptr %ns, align 8
  %call15 = call i32 @nvme_nsid(ptr noundef %18)
  %19 = load i64, ptr %slba, align 8
  %20 = load i32, ptr %nlb, align 4
  call void @trace_pci_nvme_verify(i16 noundef zeroext %call14, i32 noundef %call15, i64 noundef %19, i32 noundef %20)
  %21 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %21, i32 0, i32 5
  %dps = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 8
  %22 = load i8, ptr %dps, align 1
  %conv16 = zext i8 %22 to i32
  %and17 = and i32 %conv16, 7
  %tobool = icmp ne i32 %and17, 0
  br i1 %tobool, label %if.then, label %if.end27

if.then:                                          ; preds = %entry
  %23 = load ptr, ptr %ns, align 8
  %24 = load i8, ptr %prinfo, align 1
  %25 = load i64, ptr %slba, align 8
  %26 = load i32, ptr %reftag, align 4
  %conv18 = zext i32 %26 to i64
  %call19 = call zeroext i16 @nvme_check_prinfo(ptr noundef %23, i8 noundef zeroext %24, i64 noundef %25, i64 noundef %conv18)
  store i16 %call19, ptr %status, align 2
  %27 = load i16, ptr %status, align 2
  %tobool20 = icmp ne i16 %27, 0
  br i1 %tobool20, label %if.then21, label %if.end

if.then21:                                        ; preds = %if.then
  %28 = load i16, ptr %status, align 2
  store i16 %28, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %if.then
  %29 = load i8, ptr %prinfo, align 1
  %conv22 = zext i8 %29 to i32
  %and23 = and i32 %conv22, 8
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end
  store i16 16769, ptr %retval, align 2
  br label %return

if.end26:                                         ; preds = %if.end
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %entry
  %30 = load i64, ptr %len, align 8
  %31 = load ptr, ptr %n.addr, align 8
  %page_size = getelementptr inbounds %struct.NvmeCtrl, ptr %31, i32 0, i32 8
  %32 = load i32, ptr %page_size, align 4
  %33 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %33, i32 0, i32 4
  %vsl = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 8
  %34 = load i8, ptr %vsl, align 1
  %conv28 = zext i8 %34 to i32
  %shl = shl i32 %32, %conv28
  %conv29 = zext i32 %shl to i64
  %cmp = icmp ugt i64 %30, %conv29
  br i1 %cmp, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end27
  store i16 16386, ptr %retval, align 2
  br label %return

if.end32:                                         ; preds = %if.end27
  %35 = load ptr, ptr %ns, align 8
  %36 = load i64, ptr %slba, align 8
  %37 = load i32, ptr %nlb, align 4
  %call33 = call zeroext i16 @nvme_check_bounds(ptr noundef %35, i64 noundef %36, i32 noundef %37)
  store i16 %call33, ptr %status, align 2
  %38 = load i16, ptr %status, align 2
  %tobool34 = icmp ne i16 %38, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end32
  %39 = load i16, ptr %status, align 2
  store i16 %39, ptr %retval, align 2
  br label %return

if.end36:                                         ; preds = %if.end32
  %40 = load ptr, ptr %ns, align 8
  %features = getelementptr inbounds %struct.NvmeNamespace, ptr %40, i32 0, i32 33
  %err_rec = getelementptr inbounds %struct.anon.13, ptr %features, i32 0, i32 0
  %41 = load i32, ptr %err_rec, align 8
  %and37 = and i32 %41, 65536
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.then39, label %if.end44

if.then39:                                        ; preds = %if.end36
  %42 = load ptr, ptr %ns, align 8
  %43 = load i64, ptr %slba, align 8
  %44 = load i32, ptr %nlb, align 4
  %call40 = call zeroext i16 @nvme_check_dulbe(ptr noundef %42, i64 noundef %43, i32 noundef %44)
  store i16 %call40, ptr %status, align 2
  %45 = load i16, ptr %status, align 2
  %tobool41 = icmp ne i16 %45, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.then39
  %46 = load i16, ptr %status, align 2
  store i16 %46, ptr %retval, align 2
  br label %return

if.end43:                                         ; preds = %if.then39
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.end36
  %call45 = call noalias ptr @g_malloc0_n(i64 noundef 1, i64 noundef 104) #11
  store ptr %call45, ptr %ctx, align 8
  %47 = load ptr, ptr %req.addr, align 8
  %48 = load ptr, ptr %ctx, align 8
  %req46 = getelementptr inbounds %struct.NvmeBounceContext, ptr %48, i32 0, i32 0
  store ptr %47, ptr %req46, align 8
  %49 = load i64, ptr %len, align 8
  %call47 = call noalias ptr @g_malloc(i64 noundef %49) #14
  %50 = load ptr, ptr %ctx, align 8
  %data = getelementptr inbounds %struct.NvmeBounceContext, ptr %50, i32 0, i32 1
  %bounce = getelementptr inbounds %struct.anon.40, ptr %data, i32 0, i32 1
  store ptr %call47, ptr %bounce, align 8
  %51 = load ptr, ptr %ctx, align 8
  %data48 = getelementptr inbounds %struct.NvmeBounceContext, ptr %51, i32 0, i32 1
  %iov = getelementptr inbounds %struct.anon.40, ptr %data48, i32 0, i32 0
  call void @qemu_iovec_init(ptr noundef %iov, i32 noundef 1)
  %52 = load ptr, ptr %ctx, align 8
  %data49 = getelementptr inbounds %struct.NvmeBounceContext, ptr %52, i32 0, i32 1
  %iov50 = getelementptr inbounds %struct.anon.40, ptr %data49, i32 0, i32 0
  %53 = load ptr, ptr %ctx, align 8
  %data51 = getelementptr inbounds %struct.NvmeBounceContext, ptr %53, i32 0, i32 1
  %bounce52 = getelementptr inbounds %struct.anon.40, ptr %data51, i32 0, i32 1
  %54 = load ptr, ptr %bounce52, align 8
  %55 = load i64, ptr %len, align 8
  call void @qemu_iovec_add(ptr noundef %iov50, ptr noundef %54, i64 noundef %55)
  %56 = load ptr, ptr %blk, align 8
  %call53 = call ptr @blk_get_stats(ptr noundef %56)
  %57 = load ptr, ptr %req.addr, align 8
  %acct = getelementptr inbounds %struct.NvmeRequest, ptr %57, i32 0, i32 7
  %58 = load ptr, ptr %ctx, align 8
  %data54 = getelementptr inbounds %struct.NvmeBounceContext, ptr %58, i32 0, i32 1
  %iov55 = getelementptr inbounds %struct.anon.40, ptr %data54, i32 0, i32 0
  %59 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov55, i32 0, i32 2
  %size = getelementptr inbounds %struct.anon.2, ptr %59, i32 0, i32 1
  %60 = load i64, ptr %size, align 8
  call void @block_acct_start(ptr noundef %call53, ptr noundef %acct, i64 noundef %60, i32 noundef 1)
  %61 = load ptr, ptr %ns, align 8
  %blkconf56 = getelementptr inbounds %struct.NvmeNamespace, ptr %61, i32 0, i32 1
  %blk57 = getelementptr inbounds %struct.BlockConf, ptr %blkconf56, i32 0, i32 0
  %62 = load ptr, ptr %blk57, align 8
  %63 = load i64, ptr %offset, align 8
  %64 = load ptr, ptr %ctx, align 8
  %data58 = getelementptr inbounds %struct.NvmeBounceContext, ptr %64, i32 0, i32 1
  %iov59 = getelementptr inbounds %struct.anon.40, ptr %data58, i32 0, i32 0
  %65 = load ptr, ptr %ctx, align 8
  %call60 = call ptr @blk_aio_preadv(ptr noundef %62, i64 noundef %63, ptr noundef %iov59, i32 noundef 0, ptr noundef @nvme_verify_mdata_in_cb, ptr noundef %65)
  %66 = load ptr, ptr %req.addr, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %66, i32 0, i32 2
  store ptr %call60, ptr %aiocb, align 8
  store i16 -1, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end44, %if.then42, %if.then35, %if.then31, %if.then25, %if.then21
  %67 = load i16, ptr %retval, align 2
  ret i16 %67
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_copy(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %copy = alloca ptr, align 8
  %iocb = alloca ptr, align 8
  %nr = alloca i16, align 2
  %format = alloca i8, align 1
  %prinfor = alloca i16, align 2
  %prinfow = alloca i16, align 2
  %len = alloca i64, align 8
  %status = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %ns1, align 8
  store ptr %1, ptr %ns, align 8
  %2 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 6
  store ptr %cmd, ptr %copy, align 8
  %3 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %4 = load ptr, ptr %blk, align 8
  %5 = load ptr, ptr %req.addr, align 8
  %call = call ptr @blk_aio_get(ptr noundef @nvme_copy_aiocb_info, ptr noundef %4, ptr noundef @nvme_misc_cb, ptr noundef %5)
  store ptr %call, ptr %iocb, align 8
  %6 = load ptr, ptr %copy, align 8
  %nr2 = getelementptr inbounds %struct.NvmeCopyCmd, ptr %6, i32 0, i32 9
  %7 = load i8, ptr %nr2, align 1
  %conv = zext i8 %7 to i32
  %add = add i32 %conv, 1
  %conv3 = trunc i32 %add to i16
  store i16 %conv3, ptr %nr, align 2
  %8 = load ptr, ptr %copy, align 8
  %control = getelementptr inbounds %struct.NvmeCopyCmd, ptr %8, i32 0, i32 10
  %arrayidx = getelementptr [3 x i8], ptr %control, i64 0, i64 0
  %9 = load i8, ptr %arrayidx, align 1
  %conv4 = zext i8 %9 to i32
  %and = and i32 %conv4, 15
  %conv5 = trunc i32 %and to i8
  store i8 %conv5, ptr %format, align 1
  %10 = load ptr, ptr %copy, align 8
  %control6 = getelementptr inbounds %struct.NvmeCopyCmd, ptr %10, i32 0, i32 10
  %arrayidx7 = getelementptr [3 x i8], ptr %control6, i64 0, i64 0
  %11 = load i8, ptr %arrayidx7, align 1
  %conv8 = zext i8 %11 to i32
  %shr = ashr i32 %conv8, 4
  %and9 = and i32 %shr, 15
  %conv10 = trunc i32 %and9 to i16
  store i16 %conv10, ptr %prinfor, align 2
  %12 = load ptr, ptr %copy, align 8
  %control11 = getelementptr inbounds %struct.NvmeCopyCmd, ptr %12, i32 0, i32 10
  %arrayidx12 = getelementptr [3 x i8], ptr %control11, i64 0, i64 2
  %13 = load i8, ptr %arrayidx12, align 1
  %conv13 = zext i8 %13 to i32
  %shr14 = ashr i32 %conv13, 2
  %and15 = and i32 %shr14, 15
  %conv16 = trunc i32 %and15 to i16
  store i16 %conv16, ptr %prinfow, align 2
  store i64 32, ptr %len, align 8
  %14 = load ptr, ptr %req.addr, align 8
  %call17 = call zeroext i16 @nvme_cid(ptr noundef %14)
  %15 = load ptr, ptr %ns, align 8
  %call18 = call i32 @nvme_nsid(ptr noundef %15)
  %16 = load i16, ptr %nr, align 2
  %17 = load i8, ptr %format, align 1
  call void @trace_pci_nvme_copy(i16 noundef zeroext %call17, i32 noundef %call18, i16 noundef zeroext %16, i8 noundef zeroext %17)
  %18 = load ptr, ptr %iocb, align 8
  %ranges = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %18, i32 0, i32 4
  store ptr null, ptr %ranges, align 8
  %19 = load ptr, ptr %iocb, align 8
  %zone = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %19, i32 0, i32 13
  store ptr null, ptr %zone, align 8
  %20 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %20, i32 0, i32 5
  %dps = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 8
  %21 = load i8, ptr %dps, align 1
  %conv19 = zext i8 %21 to i32
  %and20 = and i32 %conv19, 7
  %tobool = icmp ne i32 %and20, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %22 = load i16, ptr %prinfor, align 2
  %conv21 = zext i16 %22 to i32
  %and22 = and i32 %conv21, 8
  %23 = load i16, ptr %prinfow, align 2
  %conv23 = zext i16 %23 to i32
  %and24 = and i32 %conv23, 8
  %cmp = icmp ne i32 %and22, %and24
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i16 16386, ptr %status, align 2
  br label %invalid

if.end:                                           ; preds = %land.lhs.true, %entry
  %24 = load ptr, ptr %n.addr, align 8
  %id_ctrl = getelementptr inbounds %struct.NvmeCtrl, ptr %24, i32 0, i32 40
  %ocfs = getelementptr inbounds %struct.NvmeIdCtrl, ptr %id_ctrl, i32 0, i32 61
  %25 = load i16, ptr %ocfs, align 2
  %conv26 = zext i16 %25 to i32
  %26 = load i8, ptr %format, align 1
  %conv27 = zext i8 %26 to i32
  %shl = shl i32 1, %conv27
  %and28 = and i32 %conv26, %shl
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.end
  %27 = load i8, ptr %format, align 1
  call void @trace_pci_nvme_err_copy_invalid_format(i8 noundef zeroext %27)
  store i16 16386, ptr %status, align 2
  br label %invalid

if.end31:                                         ; preds = %if.end
  %28 = load i16, ptr %nr, align 2
  %conv32 = zext i16 %28 to i32
  %29 = load ptr, ptr %ns, align 8
  %id_ns33 = getelementptr inbounds %struct.NvmeNamespace, ptr %29, i32 0, i32 5
  %msrc = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns33, i32 0, i32 28
  %30 = load i8, ptr %msrc, align 8
  %conv34 = zext i8 %30 to i32
  %add35 = add i32 %conv34, 1
  %cmp36 = icmp sgt i32 %conv32, %add35
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end31
  store i16 16771, ptr %status, align 2
  br label %invalid

if.end39:                                         ; preds = %if.end31
  %31 = load ptr, ptr %ns, align 8
  %pif = getelementptr inbounds %struct.NvmeNamespace, ptr %31, i32 0, i32 14
  %32 = load i8, ptr %pif, align 8
  %conv40 = zext i8 %32 to i32
  %cmp41 = icmp eq i32 %conv40, 0
  br i1 %cmp41, label %land.lhs.true43, label %lor.lhs.false

land.lhs.true43:                                  ; preds = %if.end39
  %33 = load i8, ptr %format, align 1
  %conv44 = zext i8 %33 to i32
  %cmp45 = icmp ne i32 %conv44, 0
  br i1 %cmp45, label %if.then55, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true43, %if.end39
  %34 = load ptr, ptr %ns, align 8
  %pif47 = getelementptr inbounds %struct.NvmeNamespace, ptr %34, i32 0, i32 14
  %35 = load i8, ptr %pif47, align 8
  %conv48 = zext i8 %35 to i32
  %cmp49 = icmp ne i32 %conv48, 0
  br i1 %cmp49, label %land.lhs.true51, label %if.end56

land.lhs.true51:                                  ; preds = %lor.lhs.false
  %36 = load i8, ptr %format, align 1
  %conv52 = zext i8 %36 to i32
  %cmp53 = icmp ne i32 %conv52, 1
  br i1 %cmp53, label %if.then55, label %if.end56

if.then55:                                        ; preds = %land.lhs.true51, %land.lhs.true43
  store i16 16650, ptr %status, align 2
  br label %invalid

if.end56:                                         ; preds = %land.lhs.true51, %lor.lhs.false
  %37 = load ptr, ptr %ns, align 8
  %pif57 = getelementptr inbounds %struct.NvmeNamespace, ptr %37, i32 0, i32 14
  %38 = load i8, ptr %pif57, align 8
  %tobool58 = icmp ne i8 %38, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end56
  store i64 40, ptr %len, align 8
  br label %if.end60

if.end60:                                         ; preds = %if.then59, %if.end56
  %39 = load i8, ptr %format, align 1
  %conv61 = zext i8 %39 to i32
  %40 = load ptr, ptr %iocb, align 8
  %format62 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %40, i32 0, i32 5
  store i32 %conv61, ptr %format62, align 8
  %41 = load i16, ptr %nr, align 2
  %conv63 = zext i16 %41 to i64
  %42 = load i64, ptr %len, align 8
  %call64 = call noalias ptr @g_malloc_n(i64 noundef %conv63, i64 noundef %42) #11
  %43 = load ptr, ptr %iocb, align 8
  %ranges65 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %43, i32 0, i32 4
  store ptr %call64, ptr %ranges65, align 8
  %44 = load ptr, ptr %n.addr, align 8
  %45 = load ptr, ptr %iocb, align 8
  %ranges66 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %45, i32 0, i32 4
  %46 = load ptr, ptr %ranges66, align 8
  %47 = load i64, ptr %len, align 8
  %48 = load i16, ptr %nr, align 2
  %conv67 = zext i16 %48 to i64
  %mul = mul i64 %47, %conv67
  %conv68 = trunc i64 %mul to i32
  %49 = load ptr, ptr %req.addr, align 8
  %call69 = call zeroext i16 @nvme_h2c(ptr noundef %44, ptr noundef %46, i32 noundef %conv68, ptr noundef %49)
  store i16 %call69, ptr %status, align 2
  %50 = load i16, ptr %status, align 2
  %tobool70 = icmp ne i16 %50, 0
  br i1 %tobool70, label %if.then71, label %if.end72

if.then71:                                        ; preds = %if.end60
  br label %invalid

if.end72:                                         ; preds = %if.end60
  %51 = load ptr, ptr %copy, align 8
  %sdlba = getelementptr inbounds %struct.NvmeCopyCmd, ptr %51, i32 0, i32 8
  %52 = load i64, ptr %sdlba, align 1
  %call73 = call i64 @le64_to_cpu(i64 noundef %52)
  %53 = load ptr, ptr %iocb, align 8
  %slba = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %53, i32 0, i32 12
  store i64 %call73, ptr %slba, align 8
  %54 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %54, i32 0, i32 30
  %zoned = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 14
  %55 = load i8, ptr %zoned, align 1
  %tobool74 = trunc i8 %55 to i1
  br i1 %tobool74, label %if.then75, label %if.end88

if.then75:                                        ; preds = %if.end72
  %56 = load ptr, ptr %ns, align 8
  %57 = load ptr, ptr %iocb, align 8
  %slba76 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %57, i32 0, i32 12
  %58 = load i64, ptr %slba76, align 8
  %call77 = call ptr @nvme_get_zone_by_slba(ptr noundef %56, i64 noundef %58)
  %59 = load ptr, ptr %iocb, align 8
  %zone78 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %59, i32 0, i32 13
  store ptr %call77, ptr %zone78, align 8
  %60 = load ptr, ptr %iocb, align 8
  %zone79 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %60, i32 0, i32 13
  %61 = load ptr, ptr %zone79, align 8
  %tobool80 = icmp ne ptr %61, null
  br i1 %tobool80, label %if.end82, label %if.then81

if.then81:                                        ; preds = %if.then75
  store i16 16512, ptr %status, align 2
  br label %invalid

if.end82:                                         ; preds = %if.then75
  %62 = load ptr, ptr %n.addr, align 8
  %63 = load ptr, ptr %ns, align 8
  %64 = load ptr, ptr %iocb, align 8
  %zone83 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %64, i32 0, i32 13
  %65 = load ptr, ptr %zone83, align 8
  %call84 = call zeroext i16 @nvme_zrm_auto(ptr noundef %62, ptr noundef %63, ptr noundef %65)
  store i16 %call84, ptr %status, align 2
  %66 = load i16, ptr %status, align 2
  %tobool85 = icmp ne i16 %66, 0
  br i1 %tobool85, label %if.then86, label %if.end87

if.then86:                                        ; preds = %if.end82
  br label %invalid

if.end87:                                         ; preds = %if.end82
  br label %if.end88

if.end88:                                         ; preds = %if.end87, %if.end72
  %67 = load ptr, ptr %ns, align 8
  %68 = load ptr, ptr %iocb, align 8
  %69 = load i16, ptr %nr, align 2
  %call89 = call zeroext i16 @nvme_check_copy_mcl(ptr noundef %67, ptr noundef %68, i16 noundef zeroext %69)
  store i16 %call89, ptr %status, align 2
  %70 = load i16, ptr %status, align 2
  %tobool90 = icmp ne i16 %70, 0
  br i1 %tobool90, label %if.then91, label %if.end92

if.then91:                                        ; preds = %if.end88
  br label %invalid

if.end92:                                         ; preds = %if.end88
  %71 = load ptr, ptr %req.addr, align 8
  %72 = load ptr, ptr %iocb, align 8
  %req93 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %72, i32 0, i32 2
  store ptr %71, ptr %req93, align 8
  %73 = load ptr, ptr %iocb, align 8
  %ret = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %73, i32 0, i32 3
  store i32 0, ptr %ret, align 8
  %74 = load i16, ptr %nr, align 2
  %conv94 = zext i16 %74 to i32
  %75 = load ptr, ptr %iocb, align 8
  %nr95 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %75, i32 0, i32 6
  store i32 %conv94, ptr %nr95, align 4
  %76 = load ptr, ptr %iocb, align 8
  %idx = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %76, i32 0, i32 7
  store i32 0, ptr %idx, align 8
  %77 = load ptr, ptr %copy, align 8
  %reftag = getelementptr inbounds %struct.NvmeCopyCmd, ptr %77, i32 0, i32 13
  %78 = load i32, ptr %reftag, align 1
  %call96 = call i32 @le32_to_cpu(i32 noundef %78)
  %conv97 = zext i32 %call96 to i64
  %79 = load ptr, ptr %iocb, align 8
  %reftag98 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %79, i32 0, i32 11
  store i64 %conv97, ptr %reftag98, align 8
  %80 = load ptr, ptr %copy, align 8
  %cdw3 = getelementptr inbounds %struct.NvmeCopyCmd, ptr %80, i32 0, i32 5
  %81 = load i32, ptr %cdw3, align 1
  %call99 = call i32 @le32_to_cpu(i32 noundef %81)
  %conv100 = zext i32 %call99 to i64
  %shl101 = shl i64 %conv100, 32
  %82 = load ptr, ptr %iocb, align 8
  %reftag102 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %82, i32 0, i32 11
  %83 = load i64, ptr %reftag102, align 8
  %or = or i64 %83, %shl101
  store i64 %or, ptr %reftag102, align 8
  %84 = load ptr, ptr %ns, align 8
  %id_ns103 = getelementptr inbounds %struct.NvmeNamespace, ptr %84, i32 0, i32 5
  %mssrl = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns103, i32 0, i32 26
  %85 = load i16, ptr %mssrl, align 2
  %call104 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %85)
  %conv105 = zext i16 %call104 to i64
  %86 = load ptr, ptr %ns, align 8
  %lbasz = getelementptr inbounds %struct.NvmeNamespace, ptr %86, i32 0, i32 9
  %87 = load i64, ptr %lbasz, align 8
  %88 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %88, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %89 = load i16, ptr %ms, align 8
  %conv106 = zext i16 %89 to i64
  %add107 = add i64 %87, %conv106
  %call108 = call noalias ptr @g_malloc_n(i64 noundef %conv105, i64 noundef %add107) #11
  %90 = load ptr, ptr %iocb, align 8
  %bounce = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %90, i32 0, i32 8
  store ptr %call108, ptr %bounce, align 8
  %91 = load ptr, ptr %iocb, align 8
  %iov = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %91, i32 0, i32 9
  call void @qemu_iovec_init(ptr noundef %iov, i32 noundef 1)
  %92 = load ptr, ptr %ns, align 8
  %blkconf109 = getelementptr inbounds %struct.NvmeNamespace, ptr %92, i32 0, i32 1
  %blk110 = getelementptr inbounds %struct.BlockConf, ptr %blkconf109, i32 0, i32 0
  %93 = load ptr, ptr %blk110, align 8
  %call111 = call ptr @blk_get_stats(ptr noundef %93)
  %94 = load ptr, ptr %iocb, align 8
  %acct = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %94, i32 0, i32 10
  %read = getelementptr inbounds %struct.anon.41, ptr %acct, i32 0, i32 0
  call void @block_acct_start(ptr noundef %call111, ptr noundef %read, i64 noundef 0, i32 noundef 1)
  %95 = load ptr, ptr %ns, align 8
  %blkconf112 = getelementptr inbounds %struct.NvmeNamespace, ptr %95, i32 0, i32 1
  %blk113 = getelementptr inbounds %struct.BlockConf, ptr %blkconf112, i32 0, i32 0
  %96 = load ptr, ptr %blk113, align 8
  %call114 = call ptr @blk_get_stats(ptr noundef %96)
  %97 = load ptr, ptr %iocb, align 8
  %acct115 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %97, i32 0, i32 10
  %write = getelementptr inbounds %struct.anon.41, ptr %acct115, i32 0, i32 1
  call void @block_acct_start(ptr noundef %call114, ptr noundef %write, i64 noundef 0, i32 noundef 2)
  %98 = load ptr, ptr %iocb, align 8
  %common = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %98, i32 0, i32 0
  %99 = load ptr, ptr %req.addr, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %99, i32 0, i32 2
  store ptr %common, ptr %aiocb, align 8
  %100 = load ptr, ptr %iocb, align 8
  call void @nvme_do_copy(ptr noundef %100)
  store i16 -1, ptr %retval, align 2
  br label %return

invalid:                                          ; preds = %if.then91, %if.then86, %if.then81, %if.then71, %if.then55, %if.then38, %if.then30, %if.then
  %101 = load ptr, ptr %iocb, align 8
  %ranges116 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %101, i32 0, i32 4
  %102 = load ptr, ptr %ranges116, align 8
  call void @g_free(ptr noundef %102)
  %103 = load ptr, ptr %iocb, align 8
  call void @qemu_aio_unref(ptr noundef %103)
  %104 = load i16, ptr %status, align 2
  store i16 %104, ptr %retval, align 2
  br label %return

return:                                           ; preds = %invalid, %if.end92
  %105 = load i16, ptr %retval, align 2
  ret i16 %105
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_zone_mgmt_send(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %zone = alloca ptr, align 8
  %iocb = alloca ptr, align 8
  %zd_ext = alloca ptr, align 8
  %slba = alloca i64, align 8
  %zone_idx = alloca i32, align 4
  %status = alloca i16, align 2
  %action = alloca i8, align 1
  %all = alloca i8, align 1
  %proc_mask = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd1, ptr %cmd, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %ns2, align 8
  store ptr %2, ptr %ns, align 8
  store i64 0, ptr %slba, align 8
  store i32 0, ptr %zone_idx, align 4
  %3 = load ptr, ptr %cmd, align 8
  %zsa = getelementptr inbounds %struct.NvmeZoneSendCmd, ptr %3, i32 0, i32 8
  %4 = load i8, ptr %zsa, align 1
  store i8 %4, ptr %action, align 1
  store i32 0, ptr %proc_mask, align 4
  %5 = load ptr, ptr %cmd, align 8
  %zsflags = getelementptr inbounds %struct.NvmeZoneSendCmd, ptr %5, i32 0, i32 9
  %6 = load i8, ptr %zsflags, align 1
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %all, align 1
  %7 = load ptr, ptr %req.addr, align 8
  %status3 = getelementptr inbounds %struct.NvmeRequest, ptr %7, i32 0, i32 3
  store i16 0, ptr %status3, align 8
  %8 = load i8, ptr %all, align 1
  %tobool4 = trunc i8 %8 to i1
  br i1 %tobool4, label %if.end8, label %if.then

if.then:                                          ; preds = %entry
  %9 = load ptr, ptr %ns, align 8
  %10 = load ptr, ptr %req.addr, align 8
  %cmd5 = getelementptr inbounds %struct.NvmeRequest, ptr %10, i32 0, i32 6
  %call = call zeroext i16 @nvme_get_mgmt_zone_slba_idx(ptr noundef %9, ptr noundef %cmd5, ptr noundef %slba, ptr noundef %zone_idx)
  store i16 %call, ptr %status, align 2
  %11 = load i16, ptr %status, align 2
  %tobool6 = icmp ne i16 %11, 0
  br i1 %tobool6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  %12 = load i16, ptr %status, align 2
  store i16 %12, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end8

if.end8:                                          ; preds = %if.end, %entry
  %13 = load ptr, ptr %ns, align 8
  %zone_array = getelementptr inbounds %struct.NvmeNamespace, ptr %13, i32 0, i32 18
  %14 = load ptr, ptr %zone_array, align 8
  %15 = load i32, ptr %zone_idx, align 4
  %idxprom = zext i32 %15 to i64
  %arrayidx = getelementptr %struct.NvmeZone, ptr %14, i64 %idxprom
  store ptr %arrayidx, ptr %zone, align 8
  %16 = load i64, ptr %slba, align 8
  %17 = load ptr, ptr %zone, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %17, i32 0, i32 0
  %zslba = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 5
  %18 = load i64, ptr %zslba, align 8
  %cmp = icmp ne i64 %16, %18
  br i1 %cmp, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.end8
  %19 = load i8, ptr %action, align 1
  %conv10 = zext i8 %19 to i32
  %cmp11 = icmp ne i32 %conv10, 17
  br i1 %cmp11, label %if.then13, label %if.end16

if.then13:                                        ; preds = %land.lhs.true
  %20 = load i8, ptr %action, align 1
  %21 = load i64, ptr %slba, align 8
  %22 = load ptr, ptr %zone, align 8
  %d14 = getelementptr inbounds %struct.NvmeZone, ptr %22, i32 0, i32 0
  %zslba15 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d14, i32 0, i32 5
  %23 = load i64, ptr %zslba15, align 8
  call void @trace_pci_nvme_err_unaligned_zone_cmd(i8 noundef zeroext %20, i64 noundef %21, i64 noundef %23)
  store i16 16386, ptr %retval, align 2
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %if.end8
  %24 = load i8, ptr %action, align 1
  %conv17 = zext i8 %24 to i32
  switch i32 %conv17, label %sw.default [
    i32 3, label %sw.bb
    i32 1, label %sw.bb24
    i32 2, label %sw.bb31
    i32 4, label %sw.bb38
    i32 5, label %sw.bb47
    i32 16, label %sw.bb54
    i32 17, label %sw.bb73
  ]

sw.bb:                                            ; preds = %if.end16
  %25 = load i8, ptr %all, align 1
  %tobool18 = trunc i8 %25 to i1
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %sw.bb
  store i32 2, ptr %proc_mask, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %sw.bb
  %26 = load i64, ptr %slba, align 8
  %27 = load i32, ptr %zone_idx, align 4
  %28 = load i8, ptr %all, align 1
  %tobool21 = trunc i8 %28 to i1
  %conv22 = zext i1 %tobool21 to i32
  call void @trace_pci_nvme_open_zone(i64 noundef %26, i32 noundef %27, i32 noundef %conv22)
  %29 = load ptr, ptr %ns, align 8
  %30 = load ptr, ptr %zone, align 8
  %31 = load i32, ptr %proc_mask, align 4
  %32 = load ptr, ptr %req.addr, align 8
  %call23 = call zeroext i16 @nvme_do_zone_op(ptr noundef %29, ptr noundef %30, i32 noundef %31, ptr noundef @nvme_open_zone, ptr noundef %32)
  store i16 %call23, ptr %status, align 2
  br label %sw.epilog

sw.bb24:                                          ; preds = %if.end16
  %33 = load i8, ptr %all, align 1
  %tobool25 = trunc i8 %33 to i1
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %sw.bb24
  store i32 1, ptr %proc_mask, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %sw.bb24
  %34 = load i64, ptr %slba, align 8
  %35 = load i32, ptr %zone_idx, align 4
  %36 = load i8, ptr %all, align 1
  %tobool28 = trunc i8 %36 to i1
  %conv29 = zext i1 %tobool28 to i32
  call void @trace_pci_nvme_close_zone(i64 noundef %34, i32 noundef %35, i32 noundef %conv29)
  %37 = load ptr, ptr %ns, align 8
  %38 = load ptr, ptr %zone, align 8
  %39 = load i32, ptr %proc_mask, align 4
  %40 = load ptr, ptr %req.addr, align 8
  %call30 = call zeroext i16 @nvme_do_zone_op(ptr noundef %37, ptr noundef %38, i32 noundef %39, ptr noundef @nvme_close_zone, ptr noundef %40)
  store i16 %call30, ptr %status, align 2
  br label %sw.epilog

sw.bb31:                                          ; preds = %if.end16
  %41 = load i8, ptr %all, align 1
  %tobool32 = trunc i8 %41 to i1
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %sw.bb31
  store i32 3, ptr %proc_mask, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %sw.bb31
  %42 = load i64, ptr %slba, align 8
  %43 = load i32, ptr %zone_idx, align 4
  %44 = load i8, ptr %all, align 1
  %tobool35 = trunc i8 %44 to i1
  %conv36 = zext i1 %tobool35 to i32
  call void @trace_pci_nvme_finish_zone(i64 noundef %42, i32 noundef %43, i32 noundef %conv36)
  %45 = load ptr, ptr %ns, align 8
  %46 = load ptr, ptr %zone, align 8
  %47 = load i32, ptr %proc_mask, align 4
  %48 = load ptr, ptr %req.addr, align 8
  %call37 = call zeroext i16 @nvme_do_zone_op(ptr noundef %45, ptr noundef %46, i32 noundef %47, ptr noundef @nvme_finish_zone, ptr noundef %48)
  store i16 %call37, ptr %status, align 2
  br label %sw.epilog

sw.bb38:                                          ; preds = %if.end16
  %49 = load i64, ptr %slba, align 8
  %50 = load i32, ptr %zone_idx, align 4
  %51 = load i8, ptr %all, align 1
  %tobool39 = trunc i8 %51 to i1
  %conv40 = zext i1 %tobool39 to i32
  call void @trace_pci_nvme_reset_zone(i64 noundef %49, i32 noundef %50, i32 noundef %conv40)
  %52 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %52, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %53 = load ptr, ptr %blk, align 8
  %54 = load ptr, ptr %req.addr, align 8
  %call41 = call ptr @blk_aio_get(ptr noundef @nvme_zone_reset_aiocb_info, ptr noundef %53, ptr noundef @nvme_misc_cb, ptr noundef %54)
  store ptr %call41, ptr %iocb, align 8
  %55 = load ptr, ptr %req.addr, align 8
  %56 = load ptr, ptr %iocb, align 8
  %req42 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %56, i32 0, i32 2
  store ptr %55, ptr %req42, align 8
  %57 = load ptr, ptr %iocb, align 8
  %ret = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %57, i32 0, i32 3
  store i32 0, ptr %ret, align 8
  %58 = load i8, ptr %all, align 1
  %tobool43 = trunc i8 %58 to i1
  %59 = load ptr, ptr %iocb, align 8
  %all44 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %59, i32 0, i32 4
  %frombool45 = zext i1 %tobool43 to i8
  store i8 %frombool45, ptr %all44, align 4
  %60 = load i32, ptr %zone_idx, align 4
  %61 = load ptr, ptr %iocb, align 8
  %idx = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %61, i32 0, i32 5
  store i32 %60, ptr %idx, align 8
  %62 = load ptr, ptr %iocb, align 8
  %zone46 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %62, i32 0, i32 6
  store ptr null, ptr %zone46, align 8
  %63 = load ptr, ptr %iocb, align 8
  %common = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %63, i32 0, i32 0
  %64 = load ptr, ptr %req.addr, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %64, i32 0, i32 2
  store ptr %common, ptr %aiocb, align 8
  %65 = load ptr, ptr %iocb, align 8
  call void @nvme_zone_reset_cb(ptr noundef %65, i32 noundef 0)
  store i16 -1, ptr %retval, align 2
  br label %return

sw.bb47:                                          ; preds = %if.end16
  %66 = load i8, ptr %all, align 1
  %tobool48 = trunc i8 %66 to i1
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %sw.bb47
  store i32 4, ptr %proc_mask, align 4
  br label %if.end50

if.end50:                                         ; preds = %if.then49, %sw.bb47
  %67 = load i64, ptr %slba, align 8
  %68 = load i32, ptr %zone_idx, align 4
  %69 = load i8, ptr %all, align 1
  %tobool51 = trunc i8 %69 to i1
  %conv52 = zext i1 %tobool51 to i32
  call void @trace_pci_nvme_offline_zone(i64 noundef %67, i32 noundef %68, i32 noundef %conv52)
  %70 = load ptr, ptr %ns, align 8
  %71 = load ptr, ptr %zone, align 8
  %72 = load i32, ptr %proc_mask, align 4
  %73 = load ptr, ptr %req.addr, align 8
  %call53 = call zeroext i16 @nvme_do_zone_op(ptr noundef %70, ptr noundef %71, i32 noundef %72, ptr noundef @nvme_offline_zone, ptr noundef %73)
  store i16 %call53, ptr %status, align 2
  br label %sw.epilog

sw.bb54:                                          ; preds = %if.end16
  %74 = load i64, ptr %slba, align 8
  %75 = load i32, ptr %zone_idx, align 4
  call void @trace_pci_nvme_set_descriptor_extension(i64 noundef %74, i32 noundef %75)
  %76 = load i8, ptr %all, align 1
  %tobool55 = trunc i8 %76 to i1
  br i1 %tobool55, label %if.then58, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb54
  %77 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %77, i32 0, i32 30
  %zd_extension_size = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 20
  %78 = load i32, ptr %zd_extension_size, align 8
  %tobool57 = icmp ne i32 %78, 0
  br i1 %tobool57, label %if.end59, label %if.then58

if.then58:                                        ; preds = %lor.lhs.false, %sw.bb54
  store i16 16386, ptr %retval, align 2
  br label %return

if.end59:                                         ; preds = %lor.lhs.false
  %79 = load ptr, ptr %ns, align 8
  %80 = load i32, ptr %zone_idx, align 4
  %call60 = call ptr @nvme_get_zd_extension(ptr noundef %79, i32 noundef %80)
  store ptr %call60, ptr %zd_ext, align 8
  %81 = load ptr, ptr %n.addr, align 8
  %82 = load ptr, ptr %zd_ext, align 8
  %83 = load ptr, ptr %ns, align 8
  %params61 = getelementptr inbounds %struct.NvmeNamespace, ptr %83, i32 0, i32 30
  %zd_extension_size62 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params61, i32 0, i32 20
  %84 = load i32, ptr %zd_extension_size62, align 8
  %85 = load ptr, ptr %req.addr, align 8
  %call63 = call zeroext i16 @nvme_h2c(ptr noundef %81, ptr noundef %82, i32 noundef %84, ptr noundef %85)
  store i16 %call63, ptr %status, align 2
  %86 = load i16, ptr %status, align 2
  %tobool64 = icmp ne i16 %86, 0
  br i1 %tobool64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %if.end59
  %87 = load i32, ptr %zone_idx, align 4
  call void @trace_pci_nvme_err_zd_extension_map_error(i32 noundef %87)
  %88 = load i16, ptr %status, align 2
  store i16 %88, ptr %retval, align 2
  br label %return

if.end66:                                         ; preds = %if.end59
  %89 = load ptr, ptr %ns, align 8
  %90 = load ptr, ptr %zone, align 8
  %call67 = call zeroext i16 @nvme_set_zd_ext(ptr noundef %89, ptr noundef %90)
  store i16 %call67, ptr %status, align 2
  %91 = load i16, ptr %status, align 2
  %conv68 = zext i16 %91 to i32
  %cmp69 = icmp eq i32 %conv68, 0
  br i1 %cmp69, label %if.then71, label %if.end72

if.then71:                                        ; preds = %if.end66
  %92 = load i32, ptr %zone_idx, align 4
  call void @trace_pci_nvme_zd_extension_set(i32 noundef %92)
  %93 = load i16, ptr %status, align 2
  store i16 %93, ptr %retval, align 2
  br label %return

if.end72:                                         ; preds = %if.end66
  br label %sw.epilog

sw.bb73:                                          ; preds = %if.end16
  %94 = load i8, ptr %all, align 1
  %tobool74 = trunc i8 %94 to i1
  br i1 %tobool74, label %if.then75, label %if.end76

if.then75:                                        ; preds = %sw.bb73
  store i16 16386, ptr %retval, align 2
  br label %return

if.end76:                                         ; preds = %sw.bb73
  %95 = load ptr, ptr %n.addr, align 8
  %96 = load ptr, ptr %zone, align 8
  %97 = load i64, ptr %slba, align 8
  %98 = load ptr, ptr %req.addr, align 8
  %call77 = call zeroext i16 @nvme_zone_mgmt_send_zrwa_flush(ptr noundef %95, ptr noundef %96, i64 noundef %97, ptr noundef %98)
  store i16 %call77, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %if.end16
  %99 = load i8, ptr %action, align 1
  call void @trace_pci_nvme_err_invalid_mgmt_action(i8 noundef zeroext %99)
  store i16 2, ptr %status, align 2
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end72, %if.end50, %if.end34, %if.end27, %if.end20
  %100 = load i16, ptr %status, align 2
  %conv78 = zext i16 %100 to i32
  %cmp79 = icmp eq i32 %conv78, 447
  br i1 %cmp79, label %if.then81, label %if.end83

if.then81:                                        ; preds = %sw.epilog
  %101 = load i8, ptr %action, align 1
  %102 = load i64, ptr %slba, align 8
  %103 = load ptr, ptr %zone, align 8
  %d82 = getelementptr inbounds %struct.NvmeZone, ptr %103, i32 0, i32 0
  %za = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d82, i32 0, i32 2
  %104 = load i8, ptr %za, align 2
  call void @trace_pci_nvme_err_invalid_zone_state_transition(i8 noundef zeroext %101, i64 noundef %102, i8 noundef zeroext %104)
  br label %if.end83

if.end83:                                         ; preds = %if.then81, %sw.epilog
  %105 = load i16, ptr %status, align 2
  %tobool84 = icmp ne i16 %105, 0
  br i1 %tobool84, label %if.then85, label %if.end88

if.then85:                                        ; preds = %if.end83
  %106 = load i16, ptr %status, align 2
  %conv86 = zext i16 %106 to i32
  %or = or i32 %conv86, 16384
  %conv87 = trunc i32 %or to i16
  store i16 %conv87, ptr %status, align 2
  br label %if.end88

if.end88:                                         ; preds = %if.then85, %if.end83
  %107 = load i16, ptr %status, align 2
  store i16 %107, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end88, %if.end76, %if.then75, %if.then71, %if.then65, %if.then58, %sw.bb38, %if.then13, %if.then7
  %108 = load i16, ptr %retval, align 2
  ret i16 %108
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_zone_mgmt_recv(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %data_size = alloca i32, align 4
  %dw13 = alloca i32, align 4
  %zone_idx = alloca i32, align 4
  %zra = alloca i32, align 4
  %zrasf = alloca i32, align 4
  %partial = alloca i32, align 4
  %max_zones = alloca i64, align 8
  %nr_zones = alloca i64, align 8
  %status = alloca i16, align 2
  %slba = alloca i64, align 8
  %z = alloca ptr, align 8
  %zone = alloca ptr, align 8
  %header = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %buf_p = alloca ptr, align 8
  %zone_entry_sz = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd1, ptr %cmd, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %ns2, align 8
  store ptr %2, ptr %ns, align 8
  %3 = load ptr, ptr %cmd, align 8
  %cdw12 = getelementptr inbounds %struct.NvmeCmd, ptr %3, i32 0, i32 9
  %4 = load i32, ptr %cdw12, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %4)
  %add = add i32 %call, 1
  %shl = shl i32 %add, 2
  store i32 %shl, ptr %data_size, align 4
  %5 = load ptr, ptr %cmd, align 8
  %cdw13 = getelementptr inbounds %struct.NvmeCmd, ptr %5, i32 0, i32 10
  %6 = load i32, ptr %cdw13, align 1
  %call3 = call i32 @le32_to_cpu(i32 noundef %6)
  store i32 %call3, ptr %dw13, align 4
  store i64 0, ptr %nr_zones, align 8
  %7 = load ptr, ptr %req.addr, align 8
  %status4 = getelementptr inbounds %struct.NvmeRequest, ptr %7, i32 0, i32 3
  store i16 0, ptr %status4, align 8
  %8 = load ptr, ptr %ns, align 8
  %9 = load ptr, ptr %cmd, align 8
  %call5 = call zeroext i16 @nvme_get_mgmt_zone_slba_idx(ptr noundef %8, ptr noundef %9, ptr noundef %slba, ptr noundef %zone_idx)
  store i16 %call5, ptr %status, align 2
  %10 = load i16, ptr %status, align 2
  %tobool = icmp ne i16 %10, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load i16, ptr %status, align 2
  store i16 %11, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %12 = load i32, ptr %dw13, align 4
  %and = and i32 %12, 255
  store i32 %and, ptr %zra, align 4
  %13 = load i32, ptr %zra, align 4
  %cmp = icmp ne i32 %13, 0
  br i1 %cmp, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.end
  %14 = load i32, ptr %zra, align 4
  %cmp6 = icmp ne i32 %14, 1
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true
  store i16 16386, ptr %retval, align 2
  br label %return

if.end8:                                          ; preds = %land.lhs.true, %if.end
  %15 = load i32, ptr %zra, align 4
  %cmp9 = icmp eq i32 %15, 1
  br i1 %cmp9, label %land.lhs.true10, label %if.end13

land.lhs.true10:                                  ; preds = %if.end8
  %16 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %16, i32 0, i32 30
  %zd_extension_size = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 20
  %17 = load i32, ptr %zd_extension_size, align 8
  %tobool11 = icmp ne i32 %17, 0
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %land.lhs.true10
  store i16 16386, ptr %retval, align 2
  br label %return

if.end13:                                         ; preds = %land.lhs.true10, %if.end8
  %18 = load i32, ptr %dw13, align 4
  %shr = lshr i32 %18, 8
  %and14 = and i32 %shr, 255
  store i32 %and14, ptr %zrasf, align 4
  %19 = load i32, ptr %zrasf, align 4
  %cmp15 = icmp ugt i32 %19, 7
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  store i16 16386, ptr %retval, align 2
  br label %return

if.end17:                                         ; preds = %if.end13
  %20 = load i32, ptr %data_size, align 4
  %conv = zext i32 %20 to i64
  %cmp18 = icmp ult i64 %conv, 64
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  store i16 16386, ptr %retval, align 2
  br label %return

if.end21:                                         ; preds = %if.end17
  %21 = load ptr, ptr %n.addr, align 8
  %22 = load i32, ptr %data_size, align 4
  %conv22 = zext i32 %22 to i64
  %call23 = call zeroext i16 @nvme_check_mdts(ptr noundef %21, i64 noundef %conv22)
  store i16 %call23, ptr %status, align 2
  %23 = load i16, ptr %status, align 2
  %tobool24 = icmp ne i16 %23, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end21
  %24 = load i16, ptr %status, align 2
  store i16 %24, ptr %retval, align 2
  br label %return

if.end26:                                         ; preds = %if.end21
  %25 = load i32, ptr %dw13, align 4
  %shr27 = lshr i32 %25, 16
  %and28 = and i32 %shr27, 1
  store i32 %and28, ptr %partial, align 4
  store i64 64, ptr %zone_entry_sz, align 8
  %26 = load i32, ptr %zra, align 4
  %cmp29 = icmp eq i32 %26, 1
  br i1 %cmp29, label %if.then31, label %if.end36

if.then31:                                        ; preds = %if.end26
  %27 = load ptr, ptr %ns, align 8
  %params32 = getelementptr inbounds %struct.NvmeNamespace, ptr %27, i32 0, i32 30
  %zd_extension_size33 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params32, i32 0, i32 20
  %28 = load i32, ptr %zd_extension_size33, align 8
  %conv34 = zext i32 %28 to i64
  %29 = load i64, ptr %zone_entry_sz, align 8
  %add35 = add i64 %29, %conv34
  store i64 %add35, ptr %zone_entry_sz, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.then31, %if.end26
  %30 = load i32, ptr %data_size, align 4
  %conv37 = zext i32 %30 to i64
  %sub = sub i64 %conv37, 64
  %31 = load i64, ptr %zone_entry_sz, align 8
  %div = udiv i64 %sub, %31
  store i64 %div, ptr %max_zones, align 8
  %32 = load i32, ptr %data_size, align 4
  %conv38 = zext i32 %32 to i64
  %call39 = call noalias ptr @g_malloc0(i64 noundef %conv38) #14
  store ptr %call39, ptr %buf, align 8
  %33 = load ptr, ptr %ns, align 8
  %zone_array = getelementptr inbounds %struct.NvmeNamespace, ptr %33, i32 0, i32 18
  %34 = load ptr, ptr %zone_array, align 8
  %35 = load i32, ptr %zone_idx, align 4
  %idxprom = zext i32 %35 to i64
  %arrayidx = getelementptr %struct.NvmeZone, ptr %34, i64 %idxprom
  store ptr %arrayidx, ptr %zone, align 8
  %36 = load i32, ptr %zone_idx, align 4
  store i32 %36, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end36
  %37 = load i32, ptr %i, align 4
  %38 = load ptr, ptr %ns, align 8
  %num_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %38, i32 0, i32 23
  %39 = load i32, ptr %num_zones, align 8
  %cmp40 = icmp ult i32 %37, %39
  br i1 %cmp40, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %40 = load i32, ptr %partial, align 4
  %tobool42 = icmp ne i32 %40, 0
  br i1 %tobool42, label %land.lhs.true43, label %if.end47

land.lhs.true43:                                  ; preds = %for.body
  %41 = load i64, ptr %nr_zones, align 8
  %42 = load i64, ptr %max_zones, align 8
  %cmp44 = icmp uge i64 %41, %42
  br i1 %cmp44, label %if.then46, label %if.end47

if.then46:                                        ; preds = %land.lhs.true43
  br label %for.end

if.end47:                                         ; preds = %land.lhs.true43, %for.body
  %43 = load i32, ptr %zrasf, align 4
  %44 = load ptr, ptr %zone, align 8
  %incdec.ptr = getelementptr %struct.NvmeZone, ptr %44, i32 1
  store ptr %incdec.ptr, ptr %zone, align 8
  %call48 = call zeroext i1 @nvme_zone_matches_filter(i32 noundef %43, ptr noundef %44)
  br i1 %call48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end47
  %45 = load i64, ptr %nr_zones, align 8
  %inc = add i64 %45, 1
  store i64 %inc, ptr %nr_zones, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then49, %if.end47
  br label %for.inc

for.inc:                                          ; preds = %if.end50
  %46 = load i32, ptr %i, align 4
  %inc51 = add i32 %46, 1
  store i32 %inc51, ptr %i, align 4
  br label %for.cond, !llvm.loop !26

for.end:                                          ; preds = %if.then46, %for.cond
  %47 = load ptr, ptr %buf, align 8
  store ptr %47, ptr %header, align 8
  %48 = load i64, ptr %nr_zones, align 8
  %call52 = call i64 @cpu_to_le64(i64 noundef %48)
  %49 = load ptr, ptr %header, align 8
  %nr_zones53 = getelementptr inbounds %struct.NvmeZoneReportHeader, ptr %49, i32 0, i32 0
  store i64 %call52, ptr %nr_zones53, align 1
  %50 = load ptr, ptr %buf, align 8
  %add.ptr = getelementptr i8, ptr %50, i64 64
  store ptr %add.ptr, ptr %buf_p, align 8
  br label %for.cond54

for.cond54:                                       ; preds = %for.inc105, %for.end
  %51 = load i32, ptr %zone_idx, align 4
  %52 = load ptr, ptr %ns, align 8
  %num_zones55 = getelementptr inbounds %struct.NvmeNamespace, ptr %52, i32 0, i32 23
  %53 = load i32, ptr %num_zones55, align 8
  %cmp56 = icmp ult i32 %51, %53
  br i1 %cmp56, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond54
  %54 = load i64, ptr %max_zones, align 8
  %cmp58 = icmp ugt i64 %54, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond54
  %55 = phi i1 [ false, %for.cond54 ], [ %cmp58, %land.rhs ]
  br i1 %55, label %for.body60, label %for.end107

for.body60:                                       ; preds = %land.end
  %56 = load ptr, ptr %ns, align 8
  %zone_array61 = getelementptr inbounds %struct.NvmeNamespace, ptr %56, i32 0, i32 18
  %57 = load ptr, ptr %zone_array61, align 8
  %58 = load i32, ptr %zone_idx, align 4
  %idxprom62 = zext i32 %58 to i64
  %arrayidx63 = getelementptr %struct.NvmeZone, ptr %57, i64 %idxprom62
  store ptr %arrayidx63, ptr %zone, align 8
  %59 = load i32, ptr %zrasf, align 4
  %60 = load ptr, ptr %zone, align 8
  %call64 = call zeroext i1 @nvme_zone_matches_filter(i32 noundef %59, ptr noundef %60)
  br i1 %call64, label %if.then65, label %if.end104

if.then65:                                        ; preds = %for.body60
  %61 = load ptr, ptr %buf_p, align 8
  store ptr %61, ptr %z, align 8
  %62 = load ptr, ptr %buf_p, align 8
  %add.ptr66 = getelementptr i8, ptr %62, i64 64
  store ptr %add.ptr66, ptr %buf_p, align 8
  %63 = load ptr, ptr %zone, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %63, i32 0, i32 0
  %zt = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 0
  %64 = load i8, ptr %zt, align 8
  %65 = load ptr, ptr %z, align 8
  %zt67 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %65, i32 0, i32 0
  store i8 %64, ptr %zt67, align 1
  %66 = load ptr, ptr %zone, align 8
  %d68 = getelementptr inbounds %struct.NvmeZone, ptr %66, i32 0, i32 0
  %zs = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d68, i32 0, i32 1
  %67 = load i8, ptr %zs, align 1
  %68 = load ptr, ptr %z, align 8
  %zs69 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %68, i32 0, i32 1
  store i8 %67, ptr %zs69, align 1
  %69 = load ptr, ptr %zone, align 8
  %d70 = getelementptr inbounds %struct.NvmeZone, ptr %69, i32 0, i32 0
  %zcap = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d70, i32 0, i32 4
  %70 = load i64, ptr %zcap, align 8
  %call71 = call i64 @cpu_to_le64(i64 noundef %70)
  %71 = load ptr, ptr %z, align 8
  %zcap72 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %71, i32 0, i32 4
  store i64 %call71, ptr %zcap72, align 1
  %72 = load ptr, ptr %zone, align 8
  %d73 = getelementptr inbounds %struct.NvmeZone, ptr %72, i32 0, i32 0
  %zslba = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d73, i32 0, i32 5
  %73 = load i64, ptr %zslba, align 8
  %call74 = call i64 @cpu_to_le64(i64 noundef %73)
  %74 = load ptr, ptr %z, align 8
  %zslba75 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %74, i32 0, i32 5
  store i64 %call74, ptr %zslba75, align 1
  %75 = load ptr, ptr %zone, align 8
  %d76 = getelementptr inbounds %struct.NvmeZone, ptr %75, i32 0, i32 0
  %za = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d76, i32 0, i32 2
  %76 = load i8, ptr %za, align 2
  %77 = load ptr, ptr %z, align 8
  %za77 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %77, i32 0, i32 2
  store i8 %76, ptr %za77, align 1
  %78 = load ptr, ptr %zone, align 8
  %call78 = call zeroext i1 @nvme_wp_is_valid(ptr noundef %78)
  br i1 %call78, label %if.then79, label %if.else

if.then79:                                        ; preds = %if.then65
  %79 = load ptr, ptr %zone, align 8
  %d80 = getelementptr inbounds %struct.NvmeZone, ptr %79, i32 0, i32 0
  %wp = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d80, i32 0, i32 6
  %80 = load i64, ptr %wp, align 8
  %call81 = call i64 @cpu_to_le64(i64 noundef %80)
  %81 = load ptr, ptr %z, align 8
  %wp82 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %81, i32 0, i32 6
  store i64 %call81, ptr %wp82, align 1
  br label %if.end85

if.else:                                          ; preds = %if.then65
  %call83 = call i64 @cpu_to_le64(i64 noundef -1)
  %82 = load ptr, ptr %z, align 8
  %wp84 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %82, i32 0, i32 6
  store i64 %call83, ptr %wp84, align 1
  br label %if.end85

if.end85:                                         ; preds = %if.else, %if.then79
  %83 = load i32, ptr %zra, align 4
  %cmp86 = icmp eq i32 %83, 1
  br i1 %cmp86, label %if.then88, label %if.end103

if.then88:                                        ; preds = %if.end85
  %84 = load ptr, ptr %zone, align 8
  %d89 = getelementptr inbounds %struct.NvmeZone, ptr %84, i32 0, i32 0
  %za90 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d89, i32 0, i32 2
  %85 = load i8, ptr %za90, align 2
  %conv91 = zext i8 %85 to i32
  %and92 = and i32 %conv91, 128
  %tobool93 = icmp ne i32 %and92, 0
  br i1 %tobool93, label %if.then94, label %if.end99

if.then94:                                        ; preds = %if.then88
  %86 = load ptr, ptr %buf_p, align 8
  %87 = load ptr, ptr %ns, align 8
  %88 = load i32, ptr %zone_idx, align 4
  %call95 = call ptr @nvme_get_zd_extension(ptr noundef %87, i32 noundef %88)
  %89 = load ptr, ptr %ns, align 8
  %params96 = getelementptr inbounds %struct.NvmeNamespace, ptr %89, i32 0, i32 30
  %zd_extension_size97 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params96, i32 0, i32 20
  %90 = load i32, ptr %zd_extension_size97, align 8
  %conv98 = zext i32 %90 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %86, ptr align 1 %call95, i64 %conv98, i1 false)
  br label %if.end99

if.end99:                                         ; preds = %if.then94, %if.then88
  %91 = load ptr, ptr %ns, align 8
  %params100 = getelementptr inbounds %struct.NvmeNamespace, ptr %91, i32 0, i32 30
  %zd_extension_size101 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params100, i32 0, i32 20
  %92 = load i32, ptr %zd_extension_size101, align 8
  %93 = load ptr, ptr %buf_p, align 8
  %idx.ext = zext i32 %92 to i64
  %add.ptr102 = getelementptr i8, ptr %93, i64 %idx.ext
  store ptr %add.ptr102, ptr %buf_p, align 8
  br label %if.end103

if.end103:                                        ; preds = %if.end99, %if.end85
  %94 = load i64, ptr %max_zones, align 8
  %dec = add i64 %94, -1
  store i64 %dec, ptr %max_zones, align 8
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %for.body60
  br label %for.inc105

for.inc105:                                       ; preds = %if.end104
  %95 = load i32, ptr %zone_idx, align 4
  %inc106 = add i32 %95, 1
  store i32 %inc106, ptr %zone_idx, align 4
  br label %for.cond54, !llvm.loop !27

for.end107:                                       ; preds = %land.end
  %96 = load ptr, ptr %n.addr, align 8
  %97 = load ptr, ptr %buf, align 8
  %98 = load i32, ptr %data_size, align 4
  %99 = load ptr, ptr %req.addr, align 8
  %call108 = call zeroext i16 @nvme_c2h(ptr noundef %96, ptr noundef %97, i32 noundef %98, ptr noundef %99)
  store i16 %call108, ptr %status, align 2
  %100 = load ptr, ptr %buf, align 8
  call void @g_free(ptr noundef %100)
  %101 = load i16, ptr %status, align 2
  store i16 %101, ptr %retval, align 2
  br label %return

return:                                           ; preds = %for.end107, %if.then25, %if.then20, %if.then16, %if.then12, %if.then7, %if.then
  %102 = load i16, ptr %retval, align 2
  ret i16 %102
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_io_mgmt_recv(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %cdw10 = alloca i32, align 4
  %numd = alloca i32, align 4
  %mo = alloca i8, align 1
  %len = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd1, ptr %cmd, align 8
  %1 = load ptr, ptr %cmd, align 8
  %cdw102 = getelementptr inbounds %struct.NvmeCmd, ptr %1, i32 0, i32 7
  %2 = load i32, ptr %cdw102, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %cdw10, align 4
  %3 = load ptr, ptr %cmd, align 8
  %cdw11 = getelementptr inbounds %struct.NvmeCmd, ptr %3, i32 0, i32 8
  %4 = load i32, ptr %cdw11, align 1
  %call3 = call i32 @le32_to_cpu(i32 noundef %4)
  store i32 %call3, ptr %numd, align 4
  %5 = load i32, ptr %cdw10, align 4
  %and = and i32 %5, 255
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %mo, align 1
  %6 = load i32, ptr %numd, align 4
  %add = add i32 %6, 1
  %shl = shl i32 %add, 2
  %conv4 = zext i32 %shl to i64
  store i64 %conv4, ptr %len, align 8
  %7 = load i8, ptr %mo, align 1
  %conv5 = zext i8 %7 to i32
  switch i32 %conv5, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb6
  ]

sw.bb:                                            ; preds = %entry
  store i16 0, ptr %retval, align 2
  br label %return

sw.bb6:                                           ; preds = %entry
  %8 = load ptr, ptr %n.addr, align 8
  %9 = load ptr, ptr %req.addr, align 8
  %10 = load i64, ptr %len, align 8
  %call7 = call zeroext i16 @nvme_io_mgmt_recv_ruhs(ptr noundef %8, ptr noundef %9, i64 noundef %10)
  store i16 %call7, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %entry
  store i16 16386, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.default, %sw.bb6, %sw.bb
  %11 = load i16, ptr %retval, align 2
  ret i16 %11
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_io_mgmt_send(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %cdw10 = alloca i32, align 4
  %mo = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd1, ptr %cmd, align 8
  %1 = load ptr, ptr %cmd, align 8
  %cdw102 = getelementptr inbounds %struct.NvmeCmd, ptr %1, i32 0, i32 7
  %2 = load i32, ptr %cdw102, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %cdw10, align 4
  %3 = load i32, ptr %cdw10, align 4
  %and = and i32 %3, 255
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %mo, align 1
  %4 = load i8, ptr %mo, align 1
  %conv3 = zext i8 %4 to i32
  switch i32 %conv3, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb4
  ]

sw.bb:                                            ; preds = %entry
  store i16 0, ptr %retval, align 2
  br label %return

sw.bb4:                                           ; preds = %entry
  %5 = load ptr, ptr %n.addr, align 8
  %6 = load ptr, ptr %req.addr, align 8
  %call5 = call zeroext i16 @nvme_io_mgmt_send_ruh_update(ptr noundef %5, ptr noundef %6)
  store i16 %call5, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %entry
  store i16 16386, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.default, %sw.bb4, %sw.bb
  %7 = load i16, ptr %retval, align 2
  ret i16 %7
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_io_cmd(i16 noundef zeroext %cid, i32 noundef %nsid, i16 noundef zeroext %sqid, i8 noundef zeroext %opcode, ptr noundef %opname) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %sqid.addr = alloca i16, align 2
  %opcode.addr = alloca i8, align 1
  %opname.addr = alloca ptr, align 8
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i16 %sqid, ptr %sqid.addr, align 2
  store i8 %opcode, ptr %opcode.addr, align 1
  store ptr %opname, ptr %opname.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IO_CMD_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end17

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end17

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i32, ptr %nsid.addr, align 4
  %7 = load i16, ptr %sqid.addr, align 2
  %conv12 = zext i16 %7 to i32
  %8 = load i8, ptr %opcode.addr, align 1
  %conv13 = zext i8 %8 to i32
  %9 = load ptr, ptr %opname.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.177, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %6, i32 noundef %conv12, i32 noundef %conv13, ptr noundef %9)
  br label %if.end

if.else:                                          ; preds = %if.then
  %10 = load i16, ptr %cid.addr, align 2
  %conv14 = zext i16 %10 to i32
  %11 = load i32, ptr %nsid.addr, align 4
  %12 = load i16, ptr %sqid.addr, align 2
  %conv15 = zext i16 %12 to i32
  %13 = load i8, ptr %opcode.addr, align 1
  %conv16 = zext i8 %13 to i32
  %14 = load ptr, ptr %opname.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.178, i32 noundef %conv14, i32 noundef %11, i32 noundef %conv15, i32 noundef %conv16, ptr noundef %14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end17

if.end17:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

declare ptr @qemu_aio_get(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_misc_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %req = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %req, align 8
  %1 = load ptr, ptr %req, align 8
  %call = call zeroext i16 @nvme_cid(ptr noundef %1)
  call void @trace_pci_nvme_misc_cb(i16 noundef zeroext %call)
  %2 = load i32, ptr %ret.addr, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %req, align 8
  %4 = load i32, ptr %ret.addr, align 4
  call void @nvme_aio_err(ptr noundef %3, i32 noundef %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr %req, align 8
  %call1 = call ptr @nvme_cq(ptr noundef %5)
  %6 = load ptr, ptr %req, align 8
  call void @nvme_enqueue_req_completion(ptr noundef %call1, ptr noundef %6)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_do_flush(ptr noundef %iocb) #0 {
entry:
  %iocb.addr = alloca ptr, align 8
  %req = alloca ptr, align 8
  %n = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %iocb, ptr %iocb.addr, align 8
  %0 = load ptr, ptr %iocb.addr, align 8
  %req1 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %req1, align 8
  store ptr %1, ptr %req, align 8
  %2 = load ptr, ptr %req, align 8
  %call = call ptr @nvme_ctrl(ptr noundef %2)
  store ptr %call, ptr %n, align 8
  %3 = load ptr, ptr %iocb.addr, align 8
  %ret = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %3, i32 0, i32 3
  %4 = load i32, ptr %ret, align 8
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %done

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %iocb.addr, align 8
  %broadcast = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %5, i32 0, i32 6
  %6 = load i8, ptr %broadcast, align 4
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %if.then2, label %if.end10

if.then2:                                         ; preds = %if.end
  %7 = load ptr, ptr %iocb.addr, align 8
  %nsid = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %7, i32 0, i32 5
  %8 = load i32, ptr %nsid, align 8
  %add = add i32 %8, 1
  store i32 %add, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then2
  %9 = load i32, ptr %i, align 4
  %cmp3 = icmp sle i32 %9, 256
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %n, align 8
  %11 = load i32, ptr %i, align 4
  %call4 = call ptr @nvme_ns(ptr noundef %10, i32 noundef %11)
  %12 = load ptr, ptr %iocb.addr, align 8
  %ns = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %12, i32 0, i32 4
  store ptr %call4, ptr %ns, align 8
  %13 = load ptr, ptr %iocb.addr, align 8
  %ns5 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %ns5, align 8
  %tobool6 = icmp ne ptr %14, null
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %for.body
  %15 = load i32, ptr %i, align 4
  %16 = load ptr, ptr %iocb.addr, align 8
  %nsid8 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %16, i32 0, i32 5
  store i32 %15, ptr %nsid8, align 8
  br label %for.end

if.end9:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %17 = load i32, ptr %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !28

for.end:                                          ; preds = %if.then7, %for.cond
  br label %if.end10

if.end10:                                         ; preds = %for.end, %if.end
  %18 = load ptr, ptr %iocb.addr, align 8
  %ns11 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %18, i32 0, i32 4
  %19 = load ptr, ptr %ns11, align 8
  %tobool12 = icmp ne ptr %19, null
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end10
  br label %done

if.end14:                                         ; preds = %if.end10
  %20 = load ptr, ptr %iocb.addr, align 8
  call void @nvme_flush_ns_cb(ptr noundef %20, i32 noundef 0)
  br label %return

done:                                             ; preds = %if.then13, %if.then
  %21 = load ptr, ptr %iocb.addr, align 8
  %common = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %21, i32 0, i32 0
  %cb = getelementptr inbounds %struct.BlockAIOCB, ptr %common, i32 0, i32 2
  %22 = load ptr, ptr %cb, align 8
  %23 = load ptr, ptr %iocb.addr, align 8
  %common15 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %23, i32 0, i32 0
  %opaque = getelementptr inbounds %struct.BlockAIOCB, ptr %common15, i32 0, i32 3
  %24 = load ptr, ptr %opaque, align 8
  %25 = load ptr, ptr %iocb.addr, align 8
  %ret16 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %25, i32 0, i32 3
  %26 = load i32, ptr %ret16, align 8
  call void %22(ptr noundef %24, i32 noundef %26)
  %27 = load ptr, ptr %iocb.addr, align 8
  call void @qemu_aio_unref(ptr noundef %27)
  br label %return

return:                                           ; preds = %done, %if.end14
  ret void
}

declare void @qemu_aio_unref(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_flush_cancel(ptr noundef %acb) #0 {
entry:
  %acb.addr = alloca ptr, align 8
  %iocb = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  store ptr %acb, ptr %acb.addr, align 8
  %0 = load ptr, ptr %acb.addr, align 8
  store ptr %0, ptr %__mptr, align 8
  %1 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 0
  store ptr %add.ptr, ptr %tmp, align 8
  %2 = load ptr, ptr %tmp, align 8
  store ptr %2, ptr %iocb, align 8
  %3 = load ptr, ptr %iocb, align 8
  %ret = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %3, i32 0, i32 3
  store i32 -125, ptr %ret, align 8
  %4 = load ptr, ptr %iocb, align 8
  %aiocb = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %aiocb, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %iocb, align 8
  %aiocb1 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %aiocb1, align 8
  call void @blk_aio_cancel_async(ptr noundef %7)
  %8 = load ptr, ptr %iocb, align 8
  %aiocb2 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %8, i32 0, i32 1
  store ptr null, ptr %aiocb2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @blk_aio_cancel_async(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_misc_cb(i16 noundef zeroext %cid) #0 {
entry:
  %cid.addr = alloca i16, align 2
  store i16 %cid, ptr %cid.addr, align 2
  %0 = load i16, ptr %cid.addr, align 2
  call void @_nocheck__trace_pci_nvme_misc_cb(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_misc_cb(i16 noundef zeroext %cid) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MISC_CB_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.191, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %cid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.192, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_ctrl(ptr noundef %req) #0 {
entry:
  %req.addr = alloca ptr, align 8
  %sq = alloca ptr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %sq1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %sq1, align 8
  store ptr %1, ptr %sq, align 8
  %2 = load ptr, ptr %sq, align 8
  %ctrl = getelementptr inbounds %struct.NvmeSQueue, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %ctrl, align 8
  ret ptr %3
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_flush_ns_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %iocb = alloca ptr, align 8
  %ns = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %iocb, align 8
  %1 = load ptr, ptr %iocb, align 8
  %ns1 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %ns1, align 8
  store ptr %2, ptr %ns, align 8
  %3 = load i32, ptr %ret.addr, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load i32, ptr %ret.addr, align 4
  %5 = load ptr, ptr %iocb, align 8
  %ret2 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %5, i32 0, i32 3
  store i32 %4, ptr %ret2, align 8
  br label %out

if.else:                                          ; preds = %entry
  %6 = load ptr, ptr %iocb, align 8
  %ret3 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %6, i32 0, i32 3
  %7 = load i32, ptr %ret3, align 8
  %cmp4 = icmp slt i32 %7, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  br label %out

if.end:                                           ; preds = %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  %8 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end6
  %9 = load ptr, ptr %iocb, align 8
  %nsid = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %9, i32 0, i32 5
  %10 = load i32, ptr %nsid, align 8
  call void @trace_pci_nvme_flush_ns(i32 noundef %10)
  %11 = load ptr, ptr %iocb, align 8
  %ns8 = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %11, i32 0, i32 4
  store ptr null, ptr %ns8, align 8
  %12 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %12, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %13 = load ptr, ptr %blk, align 8
  %14 = load ptr, ptr %iocb, align 8
  %call = call ptr @blk_aio_flush(ptr noundef %13, ptr noundef @nvme_flush_ns_cb, ptr noundef %14)
  %15 = load ptr, ptr %iocb, align 8
  %aiocb = getelementptr inbounds %struct.NvmeFlushAIOCB, ptr %15, i32 0, i32 1
  store ptr %call, ptr %aiocb, align 8
  br label %return

if.end9:                                          ; preds = %if.end6
  br label %out

out:                                              ; preds = %if.end9, %if.then5, %if.then
  %16 = load ptr, ptr %iocb, align 8
  call void @nvme_do_flush(ptr noundef %16)
  br label %return

return:                                           ; preds = %out, %if.then7
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_flush_ns(i32 noundef %nsid) #0 {
entry:
  %nsid.addr = alloca i32, align 4
  store i32 %nsid, ptr %nsid.addr, align 4
  %0 = load i32, ptr %nsid.addr, align 4
  call void @_nocheck__trace_pci_nvme_flush_ns(i32 noundef %0)
  ret void
}

declare ptr @blk_aio_flush(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_flush_ns(i32 noundef %nsid) #0 {
entry:
  %nsid.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %nsid, ptr %nsid.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_FLUSH_NS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %nsid.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.193, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %nsid.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.194, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_opc(i8 noundef zeroext %opc) #0 {
entry:
  %opc.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %opc, ptr %opc.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_OPC_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %opc.addr, align 1
  %conv11 = zext i8 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.195, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i8, ptr %opc.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.196, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_do_write(ptr noundef %n, ptr noundef %req, i1 noundef zeroext %append, i1 noundef zeroext %wrz) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %append.addr = alloca i8, align 1
  %wrz.addr = alloca i8, align 1
  %rw = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %slba = alloca i64, align 8
  %nlb = alloca i32, align 4
  %ctrl = alloca i16, align 2
  %prinfo = alloca i8, align 1
  %data_size = alloca i64, align 8
  %mapped_size = alloca i64, align 8
  %data_offset = alloca i64, align 8
  %zone = alloca ptr, align 8
  %res = alloca ptr, align 8
  %blk = alloca ptr, align 8
  %status = alloca i16, align 2
  %pract = alloca i8, align 1
  %piremap = alloca i8, align 1
  %reftag = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %frombool = zext i1 %append to i8
  store i8 %frombool, ptr %append.addr, align 1
  %frombool1 = zext i1 %wrz to i8
  store i8 %frombool1, ptr %wrz.addr, align 1
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %ns2, align 8
  store ptr %2, ptr %ns, align 8
  %3 = load ptr, ptr %rw, align 8
  %slba3 = getelementptr inbounds %struct.NvmeRwCmd, ptr %3, i32 0, i32 8
  %4 = load i64, ptr %slba3, align 1
  %call = call i64 @le64_to_cpu(i64 noundef %4)
  store i64 %call, ptr %slba, align 8
  %5 = load ptr, ptr %rw, align 8
  %nlb4 = getelementptr inbounds %struct.NvmeRwCmd, ptr %5, i32 0, i32 9
  %6 = load i16, ptr %nlb4, align 1
  %call5 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %6)
  %conv = zext i16 %call5 to i32
  %add = add i32 %conv, 1
  store i32 %add, ptr %nlb, align 4
  %7 = load ptr, ptr %rw, align 8
  %control = getelementptr inbounds %struct.NvmeRwCmd, ptr %7, i32 0, i32 10
  %8 = load i16, ptr %control, align 1
  %call6 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %8)
  store i16 %call6, ptr %ctrl, align 2
  %9 = load i16, ptr %ctrl, align 2
  %conv7 = zext i16 %9 to i32
  %shr = ashr i32 %conv7, 10
  %and = and i32 %shr, 15
  %conv8 = trunc i32 %and to i8
  store i8 %conv8, ptr %prinfo, align 1
  %10 = load ptr, ptr %ns, align 8
  %11 = load i32, ptr %nlb, align 4
  %conv9 = zext i32 %11 to i64
  %call10 = call i64 @nvme_l2b(ptr noundef %10, i64 noundef %conv9)
  store i64 %call10, ptr %data_size, align 8
  %12 = load i64, ptr %data_size, align 8
  store i64 %12, ptr %mapped_size, align 8
  %13 = load ptr, ptr %req.addr, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %13, i32 0, i32 5
  store ptr %cqe, ptr %res, align 8
  %14 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %14, i32 0, i32 1
  %blk11 = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %15 = load ptr, ptr %blk11, align 8
  store ptr %15, ptr %blk, align 8
  %16 = load ptr, ptr %ns, align 8
  %call12 = call zeroext i1 @nvme_ns_ext(ptr noundef %16)
  br i1 %call12, label %if.then, label %if.end32

if.then:                                          ; preds = %entry
  %17 = load ptr, ptr %ns, align 8
  %18 = load i32, ptr %nlb, align 4
  %conv13 = zext i32 %18 to i64
  %call14 = call i64 @nvme_m2b(ptr noundef %17, i64 noundef %conv13)
  %19 = load i64, ptr %mapped_size, align 8
  %add15 = add i64 %19, %call14
  store i64 %add15, ptr %mapped_size, align 8
  %20 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %20, i32 0, i32 5
  %dps = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 8
  %21 = load i8, ptr %dps, align 1
  %conv16 = zext i8 %21 to i32
  %and17 = and i32 %conv16, 7
  %tobool = icmp ne i32 %and17, 0
  br i1 %tobool, label %if.then18, label %if.end31

if.then18:                                        ; preds = %if.then
  %22 = load i8, ptr %prinfo, align 1
  %conv19 = zext i8 %22 to i32
  %and20 = and i32 %conv19, 8
  %tobool21 = icmp ne i32 %and20, 0
  %frombool22 = zext i1 %tobool21 to i8
  store i8 %frombool22, ptr %pract, align 1
  %23 = load i8, ptr %pract, align 1
  %tobool23 = trunc i8 %23 to i1
  br i1 %tobool23, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then18
  %24 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %24, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %25 = load i16, ptr %ms, align 8
  %conv25 = zext i16 %25 to i64
  %26 = load ptr, ptr %ns, align 8
  %call26 = call i64 @nvme_pi_tuple_size(ptr noundef %26)
  %cmp = icmp eq i64 %conv25, %call26
  br i1 %cmp, label %if.then28, label %if.end

if.then28:                                        ; preds = %land.lhs.true
  %27 = load ptr, ptr %ns, align 8
  %28 = load i32, ptr %nlb, align 4
  %conv29 = zext i32 %28 to i64
  %call30 = call i64 @nvme_m2b(ptr noundef %27, i64 noundef %conv29)
  %29 = load i64, ptr %mapped_size, align 8
  %sub = sub i64 %29, %call30
  store i64 %sub, ptr %mapped_size, align 8
  br label %if.end

if.end:                                           ; preds = %if.then28, %land.lhs.true, %if.then18
  br label %if.end31

if.end31:                                         ; preds = %if.end, %if.then
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %entry
  %30 = load ptr, ptr %req.addr, align 8
  %call33 = call zeroext i16 @nvme_cid(ptr noundef %30)
  %31 = load ptr, ptr %rw, align 8
  %opcode = getelementptr inbounds %struct.NvmeRwCmd, ptr %31, i32 0, i32 0
  %32 = load i8, ptr %opcode, align 1
  %call34 = call ptr @nvme_io_opc_str(i8 noundef zeroext %32)
  %33 = load ptr, ptr %ns, align 8
  %call35 = call i32 @nvme_nsid(ptr noundef %33)
  %34 = load i32, ptr %nlb, align 4
  %35 = load i64, ptr %mapped_size, align 8
  %36 = load i64, ptr %slba, align 8
  call void @trace_pci_nvme_write(i16 noundef zeroext %call33, ptr noundef %call34, i32 noundef %call35, i32 noundef %34, i64 noundef %35, i64 noundef %36)
  %37 = load i8, ptr %wrz.addr, align 1
  %tobool36 = trunc i8 %37 to i1
  br i1 %tobool36, label %if.end42, label %if.then37

if.then37:                                        ; preds = %if.end32
  %38 = load ptr, ptr %n.addr, align 8
  %39 = load i64, ptr %mapped_size, align 8
  %call38 = call zeroext i16 @nvme_check_mdts(ptr noundef %38, i64 noundef %39)
  store i16 %call38, ptr %status, align 2
  %40 = load i16, ptr %status, align 2
  %tobool39 = icmp ne i16 %40, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.then37
  br label %invalid

if.end41:                                         ; preds = %if.then37
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.end32
  %41 = load ptr, ptr %ns, align 8
  %42 = load i64, ptr %slba, align 8
  %43 = load i32, ptr %nlb, align 4
  %call43 = call zeroext i16 @nvme_check_bounds(ptr noundef %41, i64 noundef %42, i32 noundef %43)
  store i16 %call43, ptr %status, align 2
  %44 = load i16, ptr %status, align 2
  %tobool44 = icmp ne i16 %44, 0
  br i1 %tobool44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.end42
  br label %invalid

if.end46:                                         ; preds = %if.end42
  %45 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %45, i32 0, i32 30
  %zoned = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 14
  %46 = load i8, ptr %zoned, align 1
  %tobool47 = trunc i8 %46 to i1
  br i1 %tobool47, label %if.then48, label %if.else142

if.then48:                                        ; preds = %if.end46
  %47 = load ptr, ptr %ns, align 8
  %48 = load i64, ptr %slba, align 8
  %call49 = call ptr @nvme_get_zone_by_slba(ptr noundef %47, i64 noundef %48)
  store ptr %call49, ptr %zone, align 8
  %49 = load ptr, ptr %zone, align 8
  %tobool50 = icmp ne ptr %49, null
  br i1 %tobool50, label %if.then51, label %if.else

if.then51:                                        ; preds = %if.then48
  br label %if.end52

if.else:                                          ; preds = %if.then48
  call void @__assert_fail(ptr noundef @.str.35, ptr noundef @.str.1, i32 noundef 3554, ptr noundef @__PRETTY_FUNCTION__.nvme_do_write) #12
  unreachable

if.end52:                                         ; preds = %if.then51
  %50 = load i8, ptr %append.addr, align 1
  %tobool53 = trunc i8 %50 to i1
  br i1 %tobool53, label %if.then54, label %if.end123

if.then54:                                        ; preds = %if.end52
  %51 = load i16, ptr %ctrl, align 2
  %conv55 = zext i16 %51 to i32
  %and56 = and i32 %conv55, 512
  %tobool57 = icmp ne i32 %and56, 0
  %lnot = xor i1 %tobool57, true
  %lnot58 = xor i1 %lnot, true
  %frombool59 = zext i1 %lnot58 to i8
  store i8 %frombool59, ptr %piremap, align 1
  %52 = load ptr, ptr %zone, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %52, i32 0, i32 0
  %za = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 2
  %53 = load i8, ptr %za, align 2
  %conv60 = zext i8 %53 to i32
  %and61 = and i32 %conv60, 8
  %tobool62 = icmp ne i32 %and61, 0
  %lnot63 = xor i1 %tobool62, true
  %lnot64 = xor i1 %lnot63, true
  %lnot.ext = zext i1 %lnot64 to i32
  %conv65 = sext i32 %lnot.ext to i64
  %tobool66 = icmp ne i64 %conv65, 0
  br i1 %tobool66, label %if.then67, label %if.end68

if.then67:                                        ; preds = %if.then54
  store i16 16822, ptr %retval, align 2
  br label %return

if.end68:                                         ; preds = %if.then54
  %54 = load i64, ptr %slba, align 8
  %55 = load ptr, ptr %zone, align 8
  %d69 = getelementptr inbounds %struct.NvmeZone, ptr %55, i32 0, i32 0
  %zslba = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d69, i32 0, i32 5
  %56 = load i64, ptr %zslba, align 8
  %cmp70 = icmp ne i64 %54, %56
  %lnot72 = xor i1 %cmp70, true
  %lnot74 = xor i1 %lnot72, true
  %lnot.ext75 = zext i1 %lnot74 to i32
  %conv76 = sext i32 %lnot.ext75 to i64
  %tobool77 = icmp ne i64 %conv76, 0
  br i1 %tobool77, label %if.then78, label %if.end81

if.then78:                                        ; preds = %if.end68
  %57 = load i64, ptr %slba, align 8
  %58 = load ptr, ptr %zone, align 8
  %d79 = getelementptr inbounds %struct.NvmeZone, ptr %58, i32 0, i32 0
  %zslba80 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d79, i32 0, i32 5
  %59 = load i64, ptr %zslba80, align 8
  call void @trace_pci_nvme_err_append_not_at_start(i64 noundef %57, i64 noundef %59)
  store i16 2, ptr %status, align 2
  br label %invalid

if.end81:                                         ; preds = %if.end68
  %60 = load ptr, ptr %n.addr, align 8
  %params82 = getelementptr inbounds %struct.NvmeCtrl, ptr %60, i32 0, i32 4
  %zasl = getelementptr inbounds %struct.NvmeParams, ptr %params82, i32 0, i32 10
  %61 = load i8, ptr %zasl, align 1
  %conv83 = zext i8 %61 to i32
  %tobool84 = icmp ne i32 %conv83, 0
  br i1 %tobool84, label %land.lhs.true85, label %if.end93

land.lhs.true85:                                  ; preds = %if.end81
  %62 = load i64, ptr %data_size, align 8
  %63 = load ptr, ptr %n.addr, align 8
  %page_size = getelementptr inbounds %struct.NvmeCtrl, ptr %63, i32 0, i32 8
  %64 = load i32, ptr %page_size, align 4
  %conv86 = zext i32 %64 to i64
  %65 = load ptr, ptr %n.addr, align 8
  %params87 = getelementptr inbounds %struct.NvmeCtrl, ptr %65, i32 0, i32 4
  %zasl88 = getelementptr inbounds %struct.NvmeParams, ptr %params87, i32 0, i32 10
  %66 = load i8, ptr %zasl88, align 1
  %conv89 = zext i8 %66 to i32
  %sh_prom = zext i32 %conv89 to i64
  %shl = shl i64 %conv86, %sh_prom
  %cmp90 = icmp ugt i64 %62, %shl
  br i1 %cmp90, label %if.then92, label %if.end93

if.then92:                                        ; preds = %land.lhs.true85
  %67 = load i64, ptr %data_size, align 8
  call void @trace_pci_nvme_err_zasl(i64 noundef %67)
  store i16 16386, ptr %retval, align 2
  br label %return

if.end93:                                         ; preds = %land.lhs.true85, %if.end81
  %68 = load ptr, ptr %zone, align 8
  %w_ptr = getelementptr inbounds %struct.NvmeZone, ptr %68, i32 0, i32 1
  %69 = load i64, ptr %w_ptr, align 8
  store i64 %69, ptr %slba, align 8
  %70 = load i64, ptr %slba, align 8
  %call94 = call i64 @cpu_to_le64(i64 noundef %70)
  %71 = load ptr, ptr %rw, align 8
  %slba95 = getelementptr inbounds %struct.NvmeRwCmd, ptr %71, i32 0, i32 8
  store i64 %call94, ptr %slba95, align 1
  %72 = load i64, ptr %slba, align 8
  %call96 = call i64 @cpu_to_le64(i64 noundef %72)
  %73 = load ptr, ptr %res, align 8
  %slba97 = getelementptr inbounds %struct.NvmeZonedResult, ptr %73, i32 0, i32 0
  store i64 %call96, ptr %slba97, align 1
  %74 = load ptr, ptr %ns, align 8
  %id_ns98 = getelementptr inbounds %struct.NvmeNamespace, ptr %74, i32 0, i32 5
  %dps99 = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns98, i32 0, i32 8
  %75 = load i8, ptr %dps99, align 1
  %conv100 = zext i8 %75 to i32
  %and101 = and i32 %conv100, 7
  switch i32 %and101, label %sw.epilog [
    i32 1, label %sw.bb
    i32 2, label %sw.bb105
    i32 3, label %sw.bb119
  ]

sw.bb:                                            ; preds = %if.end93
  %76 = load i8, ptr %piremap, align 1
  %tobool102 = trunc i8 %76 to i1
  br i1 %tobool102, label %if.end104, label %if.then103

if.then103:                                       ; preds = %sw.bb
  store i16 16769, ptr %retval, align 2
  br label %return

if.end104:                                        ; preds = %sw.bb
  br label %sw.bb105

sw.bb105:                                         ; preds = %if.end104, %if.end93
  %77 = load i8, ptr %piremap, align 1
  %tobool106 = trunc i8 %77 to i1
  br i1 %tobool106, label %if.then107, label %if.end118

if.then107:                                       ; preds = %sw.bb105
  %78 = load ptr, ptr %rw, align 8
  %reftag108 = getelementptr inbounds %struct.NvmeRwCmd, ptr %78, i32 0, i32 14
  %79 = load i32, ptr %reftag108, align 1
  %call109 = call i32 @le32_to_cpu(i32 noundef %79)
  store i32 %call109, ptr %reftag, align 4
  %80 = load i32, ptr %reftag, align 4
  %conv110 = zext i32 %80 to i64
  %81 = load i64, ptr %slba, align 8
  %82 = load ptr, ptr %zone, align 8
  %d111 = getelementptr inbounds %struct.NvmeZone, ptr %82, i32 0, i32 0
  %zslba112 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d111, i32 0, i32 5
  %83 = load i64, ptr %zslba112, align 8
  %sub113 = sub i64 %81, %83
  %add114 = add i64 %conv110, %sub113
  %conv115 = trunc i64 %add114 to i32
  %call116 = call i32 @cpu_to_le32(i32 noundef %conv115)
  %84 = load ptr, ptr %rw, align 8
  %reftag117 = getelementptr inbounds %struct.NvmeRwCmd, ptr %84, i32 0, i32 14
  store i32 %call116, ptr %reftag117, align 1
  br label %if.end118

if.end118:                                        ; preds = %if.then107, %sw.bb105
  br label %sw.epilog

sw.bb119:                                         ; preds = %if.end93
  %85 = load i8, ptr %piremap, align 1
  %tobool120 = trunc i8 %85 to i1
  br i1 %tobool120, label %if.then121, label %if.end122

if.then121:                                       ; preds = %sw.bb119
  store i16 16769, ptr %retval, align 2
  br label %return

if.end122:                                        ; preds = %sw.bb119
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end122, %if.end118, %if.end93
  br label %if.end123

if.end123:                                        ; preds = %sw.epilog, %if.end52
  %86 = load ptr, ptr %ns, align 8
  %87 = load ptr, ptr %zone, align 8
  %88 = load i64, ptr %slba, align 8
  %89 = load i32, ptr %nlb, align 4
  %call124 = call zeroext i16 @nvme_check_zone_write(ptr noundef %86, ptr noundef %87, i64 noundef %88, i32 noundef %89)
  store i16 %call124, ptr %status, align 2
  %90 = load i16, ptr %status, align 2
  %tobool125 = icmp ne i16 %90, 0
  br i1 %tobool125, label %if.then126, label %if.end127

if.then126:                                       ; preds = %if.end123
  br label %invalid

if.end127:                                        ; preds = %if.end123
  %91 = load ptr, ptr %n.addr, align 8
  %92 = load ptr, ptr %ns, align 8
  %93 = load ptr, ptr %zone, align 8
  %call128 = call zeroext i16 @nvme_zrm_auto(ptr noundef %91, ptr noundef %92, ptr noundef %93)
  store i16 %call128, ptr %status, align 2
  %94 = load i16, ptr %status, align 2
  %tobool129 = icmp ne i16 %94, 0
  br i1 %tobool129, label %if.then130, label %if.end131

if.then130:                                       ; preds = %if.end127
  br label %invalid

if.end131:                                        ; preds = %if.end127
  %95 = load ptr, ptr %zone, align 8
  %d132 = getelementptr inbounds %struct.NvmeZone, ptr %95, i32 0, i32 0
  %za133 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d132, i32 0, i32 2
  %96 = load i8, ptr %za133, align 2
  %conv134 = zext i8 %96 to i32
  %and135 = and i32 %conv134, 8
  %tobool136 = icmp ne i32 %and135, 0
  br i1 %tobool136, label %if.end141, label %if.then137

if.then137:                                       ; preds = %if.end131
  %97 = load i32, ptr %nlb, align 4
  %conv138 = zext i32 %97 to i64
  %98 = load ptr, ptr %zone, align 8
  %w_ptr139 = getelementptr inbounds %struct.NvmeZone, ptr %98, i32 0, i32 1
  %99 = load i64, ptr %w_ptr139, align 8
  %add140 = add i64 %99, %conv138
  store i64 %add140, ptr %w_ptr139, align 8
  br label %if.end141

if.end141:                                        ; preds = %if.then137, %if.end131
  br label %if.end150

if.else142:                                       ; preds = %if.end46
  %100 = load ptr, ptr %ns, align 8
  %endgrp = getelementptr inbounds %struct.NvmeNamespace, ptr %100, i32 0, i32 32
  %101 = load ptr, ptr %endgrp, align 8
  %tobool143 = icmp ne ptr %101, null
  br i1 %tobool143, label %land.lhs.true144, label %if.end149

land.lhs.true144:                                 ; preds = %if.else142
  %102 = load ptr, ptr %ns, align 8
  %endgrp145 = getelementptr inbounds %struct.NvmeNamespace, ptr %102, i32 0, i32 32
  %103 = load ptr, ptr %endgrp145, align 8
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %103, i32 0, i32 1
  %enabled = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 9
  %104 = load i8, ptr %enabled, align 8
  %tobool146 = trunc i8 %104 to i1
  br i1 %tobool146, label %if.then148, label %if.end149

if.then148:                                       ; preds = %land.lhs.true144
  %105 = load ptr, ptr %n.addr, align 8
  %106 = load ptr, ptr %req.addr, align 8
  %107 = load i64, ptr %slba, align 8
  %108 = load i32, ptr %nlb, align 4
  call void @nvme_do_write_fdp(ptr noundef %105, ptr noundef %106, i64 noundef %107, i32 noundef %108)
  br label %if.end149

if.end149:                                        ; preds = %if.then148, %land.lhs.true144, %if.else142
  br label %if.end150

if.end150:                                        ; preds = %if.end149, %if.end141
  %109 = load ptr, ptr %ns, align 8
  %110 = load i64, ptr %slba, align 8
  %call151 = call i64 @nvme_l2b(ptr noundef %109, i64 noundef %110)
  store i64 %call151, ptr %data_offset, align 8
  %111 = load ptr, ptr %ns, align 8
  %id_ns152 = getelementptr inbounds %struct.NvmeNamespace, ptr %111, i32 0, i32 5
  %dps153 = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns152, i32 0, i32 8
  %112 = load i8, ptr %dps153, align 1
  %conv154 = zext i8 %112 to i32
  %and155 = and i32 %conv154, 7
  %tobool156 = icmp ne i32 %and155, 0
  br i1 %tobool156, label %if.then157, label %if.end159

if.then157:                                       ; preds = %if.end150
  %113 = load ptr, ptr %n.addr, align 8
  %114 = load ptr, ptr %req.addr, align 8
  %call158 = call zeroext i16 @nvme_dif_rw(ptr noundef %113, ptr noundef %114)
  store i16 %call158, ptr %retval, align 2
  br label %return

if.end159:                                        ; preds = %if.end150
  %115 = load i8, ptr %wrz.addr, align 1
  %tobool160 = trunc i8 %115 to i1
  br i1 %tobool160, label %if.else167, label %if.then161

if.then161:                                       ; preds = %if.end159
  %116 = load ptr, ptr %n.addr, align 8
  %117 = load i32, ptr %nlb, align 4
  %118 = load ptr, ptr %req.addr, align 8
  %call162 = call zeroext i16 @nvme_map_data(ptr noundef %116, i32 noundef %117, ptr noundef %118)
  store i16 %call162, ptr %status, align 2
  %119 = load i16, ptr %status, align 2
  %tobool163 = icmp ne i16 %119, 0
  br i1 %tobool163, label %if.then164, label %if.end165

if.then164:                                       ; preds = %if.then161
  br label %invalid

if.end165:                                        ; preds = %if.then161
  %120 = load ptr, ptr %blk, align 8
  %call166 = call ptr @blk_get_stats(ptr noundef %120)
  %121 = load ptr, ptr %req.addr, align 8
  %acct = getelementptr inbounds %struct.NvmeRequest, ptr %121, i32 0, i32 7
  %122 = load i64, ptr %data_size, align 8
  call void @block_acct_start(ptr noundef %call166, ptr noundef %acct, i64 noundef %122, i32 noundef 2)
  %123 = load ptr, ptr %blk, align 8
  %124 = load i64, ptr %data_offset, align 8
  %125 = load ptr, ptr %req.addr, align 8
  call void @nvme_blk_write(ptr noundef %123, i64 noundef %124, i32 noundef 512, ptr noundef @nvme_rw_cb, ptr noundef %125)
  br label %if.end169

if.else167:                                       ; preds = %if.end159
  %126 = load ptr, ptr %blk, align 8
  %127 = load i64, ptr %data_offset, align 8
  %128 = load i64, ptr %data_size, align 8
  %129 = load ptr, ptr %req.addr, align 8
  %call168 = call ptr @blk_aio_pwrite_zeroes(ptr noundef %126, i64 noundef %127, i64 noundef %128, i32 noundef 4, ptr noundef @nvme_rw_cb, ptr noundef %129)
  %130 = load ptr, ptr %req.addr, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %130, i32 0, i32 2
  store ptr %call168, ptr %aiocb, align 8
  br label %if.end169

if.end169:                                        ; preds = %if.else167, %if.end165
  store i16 -1, ptr %retval, align 2
  br label %return

invalid:                                          ; preds = %if.then164, %if.then130, %if.then126, %if.then78, %if.then45, %if.then40
  %131 = load ptr, ptr %blk, align 8
  %call170 = call ptr @blk_get_stats(ptr noundef %131)
  call void @block_acct_invalid(ptr noundef %call170, i32 noundef 2)
  %132 = load i16, ptr %status, align 2
  %conv171 = zext i16 %132 to i32
  %or = or i32 %conv171, 16384
  %conv172 = trunc i32 %or to i16
  store i16 %conv172, ptr %retval, align 2
  br label %return

return:                                           ; preds = %invalid, %if.end169, %if.then157, %if.then121, %if.then103, %if.then92, %if.then67
  %133 = load i16, ptr %retval, align 2
  ret i16 %133
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @nvme_m2b(ptr noundef %ns, i64 noundef %lba) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %lba.addr = alloca i64, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store i64 %lba, ptr %lba.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %1 = load i16, ptr %ms, align 8
  %conv = zext i16 %1 to i64
  %2 = load i64, ptr %lba.addr, align 8
  %mul = mul i64 %conv, %2
  ret i64 %mul
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_write(i16 noundef zeroext %cid, ptr noundef %verb, i32 noundef %nsid, i32 noundef %nlb, i64 noundef %count, i64 noundef %lba) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %verb.addr = alloca ptr, align 8
  %nsid.addr = alloca i32, align 4
  %nlb.addr = alloca i32, align 4
  %count.addr = alloca i64, align 8
  %lba.addr = alloca i64, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store ptr %verb, ptr %verb.addr, align 8
  store i32 %nsid, ptr %nsid.addr, align 4
  store i32 %nlb, ptr %nlb.addr, align 4
  store i64 %count, ptr %count.addr, align 8
  store i64 %lba, ptr %lba.addr, align 8
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load ptr, ptr %verb.addr, align 8
  %2 = load i32, ptr %nsid.addr, align 4
  %3 = load i32, ptr %nlb.addr, align 4
  %4 = load i64, ptr %count.addr, align 8
  %5 = load i64, ptr %lba.addr, align 8
  call void @_nocheck__trace_pci_nvme_write(i16 noundef zeroext %0, ptr noundef %1, i32 noundef %2, i32 noundef %3, i64 noundef %4, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_check_mdts(ptr noundef %n, i64 noundef %len) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %mdts = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 4
  %mdts1 = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 7
  %1 = load i8, ptr %mdts1, align 16
  store i8 %1, ptr %mdts, align 1
  %2 = load i8, ptr %mdts, align 1
  %conv = zext i8 %2 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load i64, ptr %len.addr, align 8
  %4 = load ptr, ptr %n.addr, align 8
  %page_size = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 8
  %5 = load i32, ptr %page_size, align 4
  %6 = load i8, ptr %mdts, align 1
  %conv2 = zext i8 %6 to i32
  %shl = shl i32 %5, %conv2
  %conv3 = zext i32 %shl to i64
  %cmp = icmp ugt i64 %3, %conv3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %7 = load i64, ptr %len.addr, align 8
  call void @trace_pci_nvme_err_mdts(i64 noundef %7)
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i16, ptr %retval, align 2
  ret i16 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_check_bounds(ptr noundef %ns, i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %nsze = alloca i64, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load ptr, ptr %ns.addr, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 5
  %nsze1 = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 0
  %1 = load i64, ptr %nsze1, align 8
  %call = call i64 @le64_to_cpu(i64 noundef %1)
  store i64 %call, ptr %nsze, align 8
  %2 = load i64, ptr %slba.addr, align 8
  %sub = sub i64 -1, %2
  %3 = load i32, ptr %nlb.addr, align 4
  %conv = zext i32 %3 to i64
  %cmp = icmp ult i64 %sub, %conv
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %4 = load i64, ptr %slba.addr, align 8
  %5 = load i32, ptr %nlb.addr, align 4
  %conv3 = zext i32 %5 to i64
  %add = add i64 %4, %conv3
  %6 = load i64, ptr %nsze, align 8
  %cmp4 = icmp ugt i64 %add, %6
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %7 = phi i1 [ true, %entry ], [ %cmp4, %lor.rhs ]
  %lnot = xor i1 %7, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  %8 = load i64, ptr %slba.addr, align 8
  %9 = load i32, ptr %nlb.addr, align 4
  %conv8 = zext i32 %9 to i64
  %10 = load i64, ptr %nsze, align 8
  call void @trace_pci_nvme_err_invalid_lba_range(i64 noundef %8, i64 noundef %conv8, i64 noundef %10)
  store i16 16512, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %lor.end
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i16, ptr %retval, align 2
  ret i16 %11
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_append_not_at_start(i64 noundef %slba, i64 noundef %zone) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone.addr = alloca i64, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i64 %zone, ptr %zone.addr, align 8
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i64, ptr %zone.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_append_not_at_start(i64 noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_zasl(i64 noundef %len) #0 {
entry:
  %len.addr = alloca i64, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i64, ptr %len.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_zasl(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @cpu_to_le64(i64 noundef %v) #0 {
entry:
  %v.addr = alloca i64, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load i64, ptr %v.addr, align 8
  ret i64 %0
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_check_zone_write(ptr noundef %ns, ptr noundef %zone, i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %zcap = alloca i64, align 8
  %status = alloca i16, align 2
  %ezrwa = alloca i64, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load ptr, ptr %zone.addr, align 8
  %call = call i64 @nvme_zone_wr_boundary(ptr noundef %0)
  store i64 %call, ptr %zcap, align 8
  %1 = load ptr, ptr %zone.addr, align 8
  %call1 = call zeroext i16 @nvme_check_zone_state_for_write(ptr noundef %1)
  store i16 %call1, ptr %status, align 2
  %2 = load i16, ptr %status, align 2
  %tobool = icmp ne i16 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i16, ptr %status, align 2
  store i16 %3, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %4, i32 0, i32 0
  %za = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 2
  %5 = load i8, ptr %za, align 2
  %conv = zext i8 %5 to i32
  %and = and i32 %conv, 8
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %6 = load ptr, ptr %zone.addr, align 8
  %w_ptr = getelementptr inbounds %struct.NvmeZone, ptr %6, i32 0, i32 1
  %7 = load i64, ptr %w_ptr, align 8
  %8 = load ptr, ptr %ns.addr, align 8
  %zns = getelementptr inbounds %struct.NvmeNamespace, ptr %8, i32 0, i32 15
  %zrwas = getelementptr inbounds %struct.anon.4, ptr %zns, i32 0, i32 0
  %9 = load i16, ptr %zrwas, align 4
  %conv4 = zext i16 %9 to i32
  %mul = mul i32 2, %conv4
  %conv5 = sext i32 %mul to i64
  %add = add i64 %7, %conv5
  store i64 %add, ptr %ezrwa, align 8
  %10 = load i64, ptr %slba.addr, align 8
  %11 = load ptr, ptr %zone.addr, align 8
  %w_ptr6 = getelementptr inbounds %struct.NvmeZone, ptr %11, i32 0, i32 1
  %12 = load i64, ptr %w_ptr6, align 8
  %cmp = icmp ult i64 %10, %12
  br i1 %cmp, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then3
  %13 = load i64, ptr %slba.addr, align 8
  %14 = load i32, ptr %nlb.addr, align 4
  %conv8 = zext i32 %14 to i64
  %add9 = add i64 %13, %conv8
  %15 = load i64, ptr %ezrwa, align 8
  %cmp10 = icmp ugt i64 %add9, %15
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %lor.lhs.false, %if.then3
  %16 = load i64, ptr %slba.addr, align 8
  %17 = load ptr, ptr %zone.addr, align 8
  %w_ptr13 = getelementptr inbounds %struct.NvmeZone, ptr %17, i32 0, i32 1
  %18 = load i64, ptr %w_ptr13, align 8
  call void @trace_pci_nvme_err_zone_invalid_write(i64 noundef %16, i64 noundef %18)
  store i16 444, ptr %retval, align 2
  br label %return

if.end14:                                         ; preds = %lor.lhs.false
  br label %if.end25

if.else:                                          ; preds = %if.end
  %19 = load i64, ptr %slba.addr, align 8
  %20 = load ptr, ptr %zone.addr, align 8
  %w_ptr15 = getelementptr inbounds %struct.NvmeZone, ptr %20, i32 0, i32 1
  %21 = load i64, ptr %w_ptr15, align 8
  %cmp16 = icmp ne i64 %19, %21
  %lnot = xor i1 %cmp16, true
  %lnot18 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot18 to i32
  %conv19 = sext i32 %lnot.ext to i64
  %tobool20 = icmp ne i64 %conv19, 0
  br i1 %tobool20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.else
  %22 = load i64, ptr %slba.addr, align 8
  %23 = load ptr, ptr %zone.addr, align 8
  %d22 = getelementptr inbounds %struct.NvmeZone, ptr %23, i32 0, i32 0
  %zslba = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d22, i32 0, i32 5
  %24 = load i64, ptr %zslba, align 8
  %25 = load ptr, ptr %zone.addr, align 8
  %w_ptr23 = getelementptr inbounds %struct.NvmeZone, ptr %25, i32 0, i32 1
  %26 = load i64, ptr %w_ptr23, align 8
  call void @trace_pci_nvme_err_write_not_at_wp(i64 noundef %22, i64 noundef %24, i64 noundef %26)
  store i16 444, ptr %retval, align 2
  br label %return

if.end24:                                         ; preds = %if.else
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end14
  %27 = load i64, ptr %slba.addr, align 8
  %28 = load i32, ptr %nlb.addr, align 4
  %conv26 = zext i32 %28 to i64
  %add27 = add i64 %27, %conv26
  %29 = load i64, ptr %zcap, align 8
  %cmp28 = icmp ugt i64 %add27, %29
  %lnot30 = xor i1 %cmp28, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %tobool35 = icmp ne i64 %conv34, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end25
  %30 = load i64, ptr %slba.addr, align 8
  %31 = load i32, ptr %nlb.addr, align 4
  %32 = load i64, ptr %zcap, align 8
  call void @trace_pci_nvme_err_zone_boundary(i64 noundef %30, i32 noundef %31, i64 noundef %32)
  store i16 440, ptr %retval, align 2
  br label %return

if.end37:                                         ; preds = %if.end25
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end37, %if.then36, %if.then21, %if.then12, %if.then
  %33 = load i16, ptr %retval, align 2
  ret i16 %33
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_zrm_auto(ptr noundef %n, ptr noundef %ns, ptr noundef %zone) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load ptr, ptr %ns.addr, align 8
  %2 = load ptr, ptr %zone.addr, align 8
  %call = call zeroext i16 @nvme_zrm_open_flags(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef 1)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_do_write_fdp(ptr noundef %n, ptr noundef %req, i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %ns = alloca ptr, align 8
  %rw = alloca ptr, align 8
  %data_size = alloca i64, align 8
  %dw12 = alloca i32, align 4
  %dtype = alloca i8, align 1
  %pid = alloca i16, align 2
  %ph = alloca i16, align 2
  %rg = alloca i16, align 2
  %ruhid = alloca i16, align 2
  %ru = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load ptr, ptr %req.addr, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %ns1, align 8
  store ptr %1, ptr %ns, align 8
  %2 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %3 = load ptr, ptr %ns, align 8
  %4 = load i32, ptr %nlb.addr, align 4
  %conv = zext i32 %4 to i64
  %call = call i64 @nvme_l2b(ptr noundef %3, i64 noundef %conv)
  store i64 %call, ptr %data_size, align 8
  %5 = load ptr, ptr %req.addr, align 8
  %cmd2 = getelementptr inbounds %struct.NvmeRequest, ptr %5, i32 0, i32 6
  %cdw12 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd2, i32 0, i32 9
  %6 = load i32, ptr %cdw12, align 8
  %call3 = call i32 @le32_to_cpu(i32 noundef %6)
  store i32 %call3, ptr %dw12, align 4
  %7 = load i32, ptr %dw12, align 4
  %shr = lshr i32 %7, 20
  %and = and i32 %shr, 15
  %conv4 = trunc i32 %and to i8
  store i8 %conv4, ptr %dtype, align 1
  %8 = load ptr, ptr %rw, align 8
  %dspec = getelementptr inbounds %struct.NvmeRwCmd, ptr %8, i32 0, i32 13
  %9 = load i16, ptr %dspec, align 1
  %call5 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %9)
  store i16 %call5, ptr %pid, align 2
  %10 = load i8, ptr %dtype, align 1
  %conv6 = zext i8 %10 to i32
  %cmp = icmp ne i32 %conv6, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load ptr, ptr %ns, align 8
  %12 = load i16, ptr %pid, align 2
  %call8 = call zeroext i1 @nvme_parse_pid(ptr noundef %11, i16 noundef zeroext %12, ptr noundef %ph, ptr noundef %rg)
  br i1 %call8, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i16 0, ptr %ph, align 2
  store i16 0, ptr %rg, align 2
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %13 = load ptr, ptr %ns, align 8
  %fdp = getelementptr inbounds %struct.NvmeNamespace, ptr %13, i32 0, i32 34
  %phs = getelementptr inbounds %struct.anon.14, ptr %fdp, i32 0, i32 1
  %14 = load ptr, ptr %phs, align 8
  %15 = load i16, ptr %ph, align 2
  %idxprom = zext i16 %15 to i64
  %arrayidx = getelementptr i16, ptr %14, i64 %idxprom
  %16 = load i16, ptr %arrayidx, align 2
  store i16 %16, ptr %ruhid, align 2
  %17 = load ptr, ptr %ns, align 8
  %endgrp = getelementptr inbounds %struct.NvmeNamespace, ptr %17, i32 0, i32 32
  %18 = load ptr, ptr %endgrp, align 8
  %fdp9 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %18, i32 0, i32 1
  %ruhs = getelementptr inbounds %struct.anon.36, ptr %fdp9, i32 0, i32 10
  %19 = load ptr, ptr %ruhs, align 8
  %20 = load i16, ptr %ruhid, align 2
  %idxprom10 = zext i16 %20 to i64
  %arrayidx11 = getelementptr %struct.NvmeRuHandle, ptr %19, i64 %idxprom10
  %rus = getelementptr inbounds %struct.NvmeRuHandle, ptr %arrayidx11, i32 0, i32 5
  %21 = load ptr, ptr %rus, align 8
  %22 = load i16, ptr %rg, align 2
  %idxprom12 = zext i16 %22 to i64
  %arrayidx13 = getelementptr %struct.NvmeReclaimUnit, ptr %21, i64 %idxprom12
  store ptr %arrayidx13, ptr %ru, align 8
  %23 = load ptr, ptr %ns, align 8
  %endgrp14 = getelementptr inbounds %struct.NvmeNamespace, ptr %23, i32 0, i32 32
  %24 = load ptr, ptr %endgrp14, align 8
  %fdp15 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %24, i32 0, i32 1
  %hbmw = getelementptr inbounds %struct.anon.36, ptr %fdp15, i32 0, i32 6
  %25 = load i64, ptr %data_size, align 8
  call void @nvme_fdp_stat_inc(ptr noundef %hbmw, i64 noundef %25)
  %26 = load ptr, ptr %ns, align 8
  %endgrp16 = getelementptr inbounds %struct.NvmeNamespace, ptr %26, i32 0, i32 32
  %27 = load ptr, ptr %endgrp16, align 8
  %fdp17 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %27, i32 0, i32 1
  %mbmw = getelementptr inbounds %struct.anon.36, ptr %fdp17, i32 0, i32 7
  %28 = load i64, ptr %data_size, align 8
  call void @nvme_fdp_stat_inc(ptr noundef %mbmw, i64 noundef %28)
  br label %while.cond

while.cond:                                       ; preds = %if.end24, %if.end
  %29 = load i32, ptr %nlb.addr, align 4
  %tobool = icmp ne i32 %29, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %30 = load i32, ptr %nlb.addr, align 4
  %conv18 = zext i32 %30 to i64
  %31 = load ptr, ptr %ru, align 8
  %ruamw = getelementptr inbounds %struct.NvmeReclaimUnit, ptr %31, i32 0, i32 0
  %32 = load i64, ptr %ruamw, align 8
  %cmp19 = icmp ult i64 %conv18, %32
  br i1 %cmp19, label %if.then21, label %if.end24

if.then21:                                        ; preds = %while.body
  %33 = load i32, ptr %nlb.addr, align 4
  %conv22 = zext i32 %33 to i64
  %34 = load ptr, ptr %ru, align 8
  %ruamw23 = getelementptr inbounds %struct.NvmeReclaimUnit, ptr %34, i32 0, i32 0
  %35 = load i64, ptr %ruamw23, align 8
  %sub = sub i64 %35, %conv22
  store i64 %sub, ptr %ruamw23, align 8
  br label %while.end

if.end24:                                         ; preds = %while.body
  %36 = load ptr, ptr %ru, align 8
  %ruamw25 = getelementptr inbounds %struct.NvmeReclaimUnit, ptr %36, i32 0, i32 0
  %37 = load i64, ptr %ruamw25, align 8
  %38 = load i32, ptr %nlb.addr, align 4
  %conv26 = zext i32 %38 to i64
  %sub27 = sub i64 %conv26, %37
  %conv28 = trunc i64 %sub27 to i32
  store i32 %conv28, ptr %nlb.addr, align 4
  %39 = load ptr, ptr %n.addr, align 8
  %40 = load ptr, ptr %ns, align 8
  %41 = load i16, ptr %pid, align 2
  %call29 = call zeroext i1 @nvme_update_ruh(ptr noundef %39, ptr noundef %40, i16 noundef zeroext %41)
  br label %while.cond, !llvm.loop !29

while.end:                                        ; preds = %if.then21, %while.cond
  ret void
}

declare zeroext i16 @nvme_dif_rw(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_map_data(ptr noundef %n, i32 noundef %nlb, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %nlb.addr = alloca i32, align 4
  %req.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %rw = alloca ptr, align 8
  %pi = alloca i8, align 1
  %pract = alloca i8, align 1
  %len = alloca i64, align 8
  %status = alloca i16, align 2
  %sg = alloca %struct.NvmeSg, align 8
  store ptr %n, ptr %n.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %ns1, align 8
  store ptr %1, ptr %ns, align 8
  %2 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %3 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 5
  %dps = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 8
  %4 = load i8, ptr %dps, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 7
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %frombool = zext i1 %lnot2 to i8
  store i8 %frombool, ptr %pi, align 1
  %5 = load ptr, ptr %rw, align 8
  %control = getelementptr inbounds %struct.NvmeRwCmd, ptr %5, i32 0, i32 10
  %6 = load i16, ptr %control, align 1
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %6)
  %conv3 = zext i16 %call to i32
  %and4 = and i32 %conv3, 8192
  %tobool5 = icmp ne i32 %and4, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot7 = xor i1 %lnot6, true
  %frombool8 = zext i1 %lnot7 to i8
  store i8 %frombool8, ptr %pract, align 1
  %7 = load ptr, ptr %ns, align 8
  %8 = load i32, ptr %nlb.addr, align 4
  %conv9 = zext i32 %8 to i64
  %call10 = call i64 @nvme_l2b(ptr noundef %7, i64 noundef %conv9)
  store i64 %call10, ptr %len, align 8
  %9 = load ptr, ptr %ns, align 8
  %call11 = call zeroext i1 @nvme_ns_ext(ptr noundef %9)
  br i1 %call11, label %land.lhs.true, label %if.end32

land.lhs.true:                                    ; preds = %entry
  %10 = load i8, ptr %pi, align 1
  %tobool13 = trunc i8 %10 to i1
  br i1 %tobool13, label %land.lhs.true15, label %if.then

land.lhs.true15:                                  ; preds = %land.lhs.true
  %11 = load i8, ptr %pract, align 1
  %tobool16 = trunc i8 %11 to i1
  br i1 %tobool16, label %land.lhs.true18, label %if.then

land.lhs.true18:                                  ; preds = %land.lhs.true15
  %12 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %12, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %13 = load i16, ptr %ms, align 8
  %conv19 = zext i16 %13 to i64
  %14 = load ptr, ptr %ns, align 8
  %call20 = call i64 @nvme_pi_tuple_size(ptr noundef %14)
  %cmp = icmp eq i64 %conv19, %call20
  br i1 %cmp, label %if.end32, label %if.then

if.then:                                          ; preds = %land.lhs.true18, %land.lhs.true15, %land.lhs.true
  %15 = load ptr, ptr %ns, align 8
  %16 = load i32, ptr %nlb.addr, align 4
  %conv22 = zext i32 %16 to i64
  %call23 = call i64 @nvme_m2b(ptr noundef %15, i64 noundef %conv22)
  %17 = load i64, ptr %len, align 8
  %add = add i64 %17, %call23
  store i64 %add, ptr %len, align 8
  %18 = load ptr, ptr %n.addr, align 8
  %19 = load i64, ptr %len, align 8
  %20 = load ptr, ptr %req.addr, align 8
  %cmd24 = getelementptr inbounds %struct.NvmeRequest, ptr %20, i32 0, i32 6
  %call25 = call zeroext i16 @nvme_map_dptr(ptr noundef %18, ptr noundef %sg, i64 noundef %19, ptr noundef %cmd24)
  store i16 %call25, ptr %status, align 2
  %21 = load i16, ptr %status, align 2
  %tobool26 = icmp ne i16 %21, 0
  br i1 %tobool26, label %if.then27, label %if.end

if.then27:                                        ; preds = %if.then
  %22 = load i16, ptr %status, align 2
  store i16 %22, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %if.then
  %23 = load ptr, ptr %n.addr, align 8
  %24 = load ptr, ptr %req.addr, align 8
  %sg28 = getelementptr inbounds %struct.NvmeRequest, ptr %24, i32 0, i32 8
  %flags = getelementptr inbounds %struct.NvmeSg, ptr %sg, i32 0, i32 0
  %25 = load i32, ptr %flags, align 8
  %and29 = and i32 %25, 2
  %tobool30 = icmp ne i32 %and29, 0
  call void @nvme_sg_init(ptr noundef %23, ptr noundef %sg28, i1 noundef zeroext %tobool30)
  %26 = load ptr, ptr %ns, align 8
  %27 = load ptr, ptr %req.addr, align 8
  %sg31 = getelementptr inbounds %struct.NvmeRequest, ptr %27, i32 0, i32 8
  call void @nvme_sg_split(ptr noundef %sg, ptr noundef %26, ptr noundef %sg31, ptr noundef null)
  call void @nvme_sg_unmap(ptr noundef %sg)
  store i16 0, ptr %retval, align 2
  br label %return

if.end32:                                         ; preds = %land.lhs.true18, %entry
  %28 = load ptr, ptr %n.addr, align 8
  %29 = load ptr, ptr %req.addr, align 8
  %sg33 = getelementptr inbounds %struct.NvmeRequest, ptr %29, i32 0, i32 8
  %30 = load i64, ptr %len, align 8
  %31 = load ptr, ptr %req.addr, align 8
  %cmd34 = getelementptr inbounds %struct.NvmeRequest, ptr %31, i32 0, i32 6
  %call35 = call zeroext i16 @nvme_map_dptr(ptr noundef %28, ptr noundef %sg33, i64 noundef %30, ptr noundef %cmd34)
  store i16 %call35, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end32, %if.end, %if.then27
  %32 = load i16, ptr %retval, align 2
  ret i16 %32
}

declare void @block_acct_start(ptr noundef, ptr noundef, i64 noundef, i32 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_blk_write(ptr noundef %blk, i64 noundef %offset, i32 noundef %align, ptr noundef %cb, ptr noundef %req) #0 {
entry:
  %blk.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  %cb.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  store ptr %blk, ptr %blk.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i32 %align, ptr %align.addr, align 4
  store ptr %cb, ptr %cb.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %sg = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 8
  %flags = getelementptr inbounds %struct.NvmeSg, ptr %sg, i32 0, i32 0
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.228, ptr noundef @.str.1, i32 noundef 1460, ptr noundef @__PRETTY_FUNCTION__.nvme_blk_write) #12
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load ptr, ptr %req.addr, align 8
  %sg1 = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 8
  %flags2 = getelementptr inbounds %struct.NvmeSg, ptr %sg1, i32 0, i32 0
  %3 = load i32, ptr %flags2, align 8
  %and3 = and i32 %3, 2
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.else7

if.then5:                                         ; preds = %if.end
  %4 = load ptr, ptr %blk.addr, align 8
  %5 = load ptr, ptr %req.addr, align 8
  %sg6 = getelementptr inbounds %struct.NvmeRequest, ptr %5, i32 0, i32 8
  %6 = getelementptr inbounds %struct.NvmeSg, ptr %sg6, i32 0, i32 1
  %7 = load i64, ptr %offset.addr, align 8
  %8 = load i32, ptr %align.addr, align 4
  %9 = load ptr, ptr %cb.addr, align 8
  %10 = load ptr, ptr %req.addr, align 8
  %call = call ptr @dma_blk_write(ptr noundef %4, ptr noundef %6, i64 noundef %7, i32 noundef %8, ptr noundef %9, ptr noundef %10)
  %11 = load ptr, ptr %req.addr, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %11, i32 0, i32 2
  store ptr %call, ptr %aiocb, align 8
  br label %if.end11

if.else7:                                         ; preds = %if.end
  %12 = load ptr, ptr %blk.addr, align 8
  %13 = load i64, ptr %offset.addr, align 8
  %14 = load ptr, ptr %req.addr, align 8
  %sg8 = getelementptr inbounds %struct.NvmeRequest, ptr %14, i32 0, i32 8
  %15 = getelementptr inbounds %struct.NvmeSg, ptr %sg8, i32 0, i32 1
  %16 = load ptr, ptr %cb.addr, align 8
  %17 = load ptr, ptr %req.addr, align 8
  %call9 = call ptr @blk_aio_pwritev(ptr noundef %12, i64 noundef %13, ptr noundef %15, i32 noundef 0, ptr noundef %16, ptr noundef %17)
  %18 = load ptr, ptr %req.addr, align 8
  %aiocb10 = getelementptr inbounds %struct.NvmeRequest, ptr %18, i32 0, i32 2
  store ptr %call9, ptr %aiocb10, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.else7, %if.then5
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_rw_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %blk = alloca ptr, align 8
  %rw = alloca ptr, align 8
  %slba = alloca i64, align 8
  %nlb = alloca i32, align 4
  %offset = alloca i64, align 8
  %mlen = alloca i64, align 8
  %status = alloca i16, align 2
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %req, align 8
  %1 = load ptr, ptr %req, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %ns1, align 8
  store ptr %2, ptr %ns, align 8
  %3 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 1
  %blk2 = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %4 = load ptr, ptr %blk2, align 8
  store ptr %4, ptr %blk, align 8
  %5 = load ptr, ptr %req, align 8
  %call = call zeroext i16 @nvme_cid(ptr noundef %5)
  %6 = load ptr, ptr %blk, align 8
  %call3 = call ptr @blk_name(ptr noundef %6)
  call void @trace_pci_nvme_rw_cb(i16 noundef zeroext %call, ptr noundef %call3)
  %7 = load i32, ptr %ret.addr, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %out

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %8, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %9 = load i16, ptr %ms, align 8
  %tobool4 = icmp ne i16 %9, 0
  br i1 %tobool4, label %if.then5, label %if.end37

if.then5:                                         ; preds = %if.end
  %10 = load ptr, ptr %req, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %10, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %11 = load ptr, ptr %rw, align 8
  %slba6 = getelementptr inbounds %struct.NvmeRwCmd, ptr %11, i32 0, i32 8
  %12 = load i64, ptr %slba6, align 1
  %call7 = call i64 @le64_to_cpu(i64 noundef %12)
  store i64 %call7, ptr %slba, align 8
  %13 = load ptr, ptr %rw, align 8
  %nlb8 = getelementptr inbounds %struct.NvmeRwCmd, ptr %13, i32 0, i32 9
  %14 = load i16, ptr %nlb8, align 1
  %call9 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %14)
  %conv = zext i16 %call9 to i32
  %add = add i32 %conv, 1
  store i32 %add, ptr %nlb, align 4
  %15 = load ptr, ptr %ns, align 8
  %16 = load i64, ptr %slba, align 8
  %call10 = call i64 @nvme_moff(ptr noundef %15, i64 noundef %16)
  store i64 %call10, ptr %offset, align 8
  %17 = load ptr, ptr %req, align 8
  %cmd11 = getelementptr inbounds %struct.NvmeRequest, ptr %17, i32 0, i32 6
  %opcode = getelementptr inbounds %struct.NvmeCmd, ptr %cmd11, i32 0, i32 0
  %18 = load i8, ptr %opcode, align 8
  %conv12 = zext i8 %18 to i32
  %cmp = icmp eq i32 %conv12, 8
  br i1 %cmp, label %if.then14, label %if.end18

if.then14:                                        ; preds = %if.then5
  %19 = load ptr, ptr %ns, align 8
  %20 = load i32, ptr %nlb, align 4
  %conv15 = zext i32 %20 to i64
  %call16 = call i64 @nvme_m2b(ptr noundef %19, i64 noundef %conv15)
  store i64 %call16, ptr %mlen, align 8
  %21 = load ptr, ptr %blk, align 8
  %22 = load i64, ptr %offset, align 8
  %23 = load i64, ptr %mlen, align 8
  %24 = load ptr, ptr %req, align 8
  %call17 = call ptr @blk_aio_pwrite_zeroes(ptr noundef %21, i64 noundef %22, i64 noundef %23, i32 noundef 4, ptr noundef @nvme_rw_complete_cb, ptr noundef %24)
  %25 = load ptr, ptr %req, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %25, i32 0, i32 2
  store ptr %call17, ptr %aiocb, align 8
  br label %return

if.end18:                                         ; preds = %if.then5
  %26 = load ptr, ptr %ns, align 8
  %call19 = call zeroext i1 @nvme_ns_ext(ptr noundef %26)
  br i1 %call19, label %if.then23, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end18
  %27 = load ptr, ptr %req, align 8
  %cmd21 = getelementptr inbounds %struct.NvmeRequest, ptr %27, i32 0, i32 6
  %mptr = getelementptr inbounds %struct.NvmeCmd, ptr %cmd21, i32 0, i32 5
  %28 = load i64, ptr %mptr, align 8
  %tobool22 = icmp ne i64 %28, 0
  br i1 %tobool22, label %if.then23, label %if.end36

if.then23:                                        ; preds = %lor.lhs.false, %if.end18
  %29 = load ptr, ptr %req, align 8
  %sg = getelementptr inbounds %struct.NvmeRequest, ptr %29, i32 0, i32 8
  call void @nvme_sg_unmap(ptr noundef %sg)
  %30 = load ptr, ptr %req, align 8
  %call24 = call ptr @nvme_ctrl(ptr noundef %30)
  %31 = load i32, ptr %nlb, align 4
  %32 = load ptr, ptr %req, align 8
  %call25 = call zeroext i16 @nvme_map_mdata(ptr noundef %call24, i32 noundef %31, ptr noundef %32)
  store i16 %call25, ptr %status, align 2
  %33 = load i16, ptr %status, align 2
  %tobool26 = icmp ne i16 %33, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.then23
  store i32 -14, ptr %ret.addr, align 4
  br label %out

if.end28:                                         ; preds = %if.then23
  %34 = load ptr, ptr %req, align 8
  %cmd29 = getelementptr inbounds %struct.NvmeRequest, ptr %34, i32 0, i32 6
  %opcode30 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd29, i32 0, i32 0
  %35 = load i8, ptr %opcode30, align 8
  %conv31 = zext i8 %35 to i32
  %cmp32 = icmp eq i32 %conv31, 2
  br i1 %cmp32, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end28
  %36 = load ptr, ptr %blk, align 8
  %37 = load i64, ptr %offset, align 8
  %38 = load ptr, ptr %req, align 8
  call void @nvme_blk_read(ptr noundef %36, i64 noundef %37, i32 noundef 1, ptr noundef @nvme_rw_complete_cb, ptr noundef %38)
  br label %return

if.end35:                                         ; preds = %if.end28
  %39 = load ptr, ptr %blk, align 8
  %40 = load i64, ptr %offset, align 8
  %41 = load ptr, ptr %req, align 8
  call void @nvme_blk_write(ptr noundef %39, i64 noundef %40, i32 noundef 1, ptr noundef @nvme_rw_complete_cb, ptr noundef %41)
  br label %return

if.end36:                                         ; preds = %lor.lhs.false
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end
  br label %out

out:                                              ; preds = %if.end37, %if.then27, %if.then
  %42 = load ptr, ptr %req, align 8
  %43 = load i32, ptr %ret.addr, align 4
  call void @nvme_rw_complete_cb(ptr noundef %42, i32 noundef %43)
  br label %return

return:                                           ; preds = %out, %if.end35, %if.then34, %if.then14
  ret void
}

declare ptr @blk_aio_pwrite_zeroes(ptr noundef, i64 noundef, i64 noundef, i32 noundef, ptr noundef, ptr noundef) #1

declare void @block_acct_invalid(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_write(i16 noundef zeroext %cid, ptr noundef %verb, i32 noundef %nsid, i32 noundef %nlb, i64 noundef %count, i64 noundef %lba) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %verb.addr = alloca ptr, align 8
  %nsid.addr = alloca i32, align 4
  %nlb.addr = alloca i32, align 4
  %count.addr = alloca i64, align 8
  %lba.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store ptr %verb, ptr %verb.addr, align 8
  store i32 %nsid, ptr %nsid.addr, align 4
  store i32 %nlb, ptr %nlb.addr, align 4
  store i64 %count, ptr %count.addr, align 8
  store i64 %lba, ptr %lba.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_WRITE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load ptr, ptr %verb.addr, align 8
  %7 = load i32, ptr %nsid.addr, align 4
  %8 = load i32, ptr %nlb.addr, align 4
  %9 = load i64, ptr %count.addr, align 8
  %10 = load i64, ptr %lba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.197, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, ptr noundef %6, i32 noundef %7, i32 noundef %8, i64 noundef %9, i64 noundef %10)
  br label %if.end

if.else:                                          ; preds = %if.then
  %11 = load i16, ptr %cid.addr, align 2
  %conv12 = zext i16 %11 to i32
  %12 = load ptr, ptr %verb.addr, align 8
  %13 = load i32, ptr %nsid.addr, align 4
  %14 = load i32, ptr %nlb.addr, align 4
  %15 = load i64, ptr %count.addr, align 8
  %16 = load i64, ptr %lba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.198, i32 noundef %conv12, ptr noundef %12, i32 noundef %13, i32 noundef %14, i64 noundef %15, i64 noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_mdts(i64 noundef %len) #0 {
entry:
  %len.addr = alloca i64, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i64, ptr %len.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_mdts(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_mdts(i64 noundef %len) #0 {
entry:
  %len.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_MDTS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %len.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.199, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %len.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.200, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_lba_range(i64 noundef %start, i64 noundef %len, i64 noundef %limit) #0 {
entry:
  %start.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %limit.addr = alloca i64, align 8
  store i64 %start, ptr %start.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i64 %limit, ptr %limit.addr, align 8
  %0 = load i64, ptr %start.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  %2 = load i64, ptr %limit.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_invalid_lba_range(i64 noundef %0, i64 noundef %1, i64 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_lba_range(i64 noundef %start, i64 noundef %len, i64 noundef %limit) #0 {
entry:
  %start.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %limit.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %start, ptr %start.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i64 %limit, ptr %limit.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %start.addr, align 8
  %6 = load i64, ptr %len.addr, align 8
  %7 = load i64, ptr %limit.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.201, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6, i64 noundef %7)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i64, ptr %start.addr, align 8
  %9 = load i64, ptr %len.addr, align 8
  %10 = load i64, ptr %limit.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.202, i64 noundef %8, i64 noundef %9, i64 noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_append_not_at_start(i64 noundef %slba, i64 noundef %zone) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i64 %zone, ptr %zone.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i64, ptr %zone.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.203, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %slba.addr, align 8
  %8 = load i64, ptr %zone.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.204, i64 noundef %7, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_zasl(i64 noundef %len) #0 {
entry:
  %len.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_ZASL_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %len.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.205, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %len.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.206, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_check_zone_state_for_write(ptr noundef %zone) #0 {
entry:
  %retval = alloca i16, align 2
  %zone.addr = alloca ptr, align 8
  %zslba = alloca i64, align 8
  store ptr %zone, ptr %zone.addr, align 8
  %0 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %0, i32 0, i32 0
  %zslba1 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 5
  %1 = load i64, ptr %zslba1, align 8
  store i64 %1, ptr %zslba, align 8
  %2 = load ptr, ptr %zone.addr, align 8
  %call = call i32 @nvme_get_zone_state(ptr noundef %2)
  switch i32 %call, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb
    i32 3, label %sw.bb
    i32 4, label %sw.bb
    i32 14, label %sw.bb2
    i32 15, label %sw.bb3
    i32 13, label %sw.bb4
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry
  store i16 0, ptr %retval, align 2
  br label %return

sw.bb2:                                           ; preds = %entry
  %3 = load i64, ptr %zslba, align 8
  call void @trace_pci_nvme_err_zone_is_full(i64 noundef %3)
  store i16 441, ptr %retval, align 2
  br label %return

sw.bb3:                                           ; preds = %entry
  %4 = load i64, ptr %zslba, align 8
  call void @trace_pci_nvme_err_zone_is_offline(i64 noundef %4)
  store i16 443, ptr %retval, align 2
  br label %return

sw.bb4:                                           ; preds = %entry
  %5 = load i64, ptr %zslba, align 8
  call void @trace_pci_nvme_err_zone_is_read_only(i64 noundef %5)
  store i16 442, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.176, ptr noundef @.str.1, i32 noundef 1815, ptr noundef @__PRETTY_FUNCTION__.nvme_check_zone_state_for_write) #12
  unreachable

return:                                           ; preds = %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb
  %6 = load i16, ptr %retval, align 2
  ret i16 %6
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_zone_invalid_write(i64 noundef %slba, i64 noundef %wp) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %wp.addr = alloca i64, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i64 %wp, ptr %wp.addr, align 8
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i64, ptr %wp.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_zone_invalid_write(i64 noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_write_not_at_wp(i64 noundef %slba, i64 noundef %zone, i64 noundef %wp) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone.addr = alloca i64, align 8
  %wp.addr = alloca i64, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i64 %zone, ptr %zone.addr, align 8
  store i64 %wp, ptr %wp.addr, align 8
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i64, ptr %zone.addr, align 8
  %2 = load i64, ptr %wp.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_write_not_at_wp(i64 noundef %0, i64 noundef %1, i64 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_zone_boundary(i64 noundef %slba, i32 noundef %nlb, i64 noundef %zcap) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %zcap.addr = alloca i64, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  store i64 %zcap, ptr %zcap.addr, align 8
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i32, ptr %nlb.addr, align 4
  %2 = load i64, ptr %zcap.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_zone_boundary(i64 noundef %0, i32 noundef %1, i64 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_zone_is_full(i64 noundef %zslba) #0 {
entry:
  %zslba.addr = alloca i64, align 8
  store i64 %zslba, ptr %zslba.addr, align 8
  %0 = load i64, ptr %zslba.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_zone_is_full(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_zone_is_offline(i64 noundef %zslba) #0 {
entry:
  %zslba.addr = alloca i64, align 8
  store i64 %zslba, ptr %zslba.addr, align 8
  %0 = load i64, ptr %zslba.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_zone_is_offline(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_zone_is_read_only(i64 noundef %zslba) #0 {
entry:
  %zslba.addr = alloca i64, align 8
  store i64 %zslba, ptr %zslba.addr, align 8
  %0 = load i64, ptr %zslba.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_zone_is_read_only(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_zone_is_full(i64 noundef %zslba) #0 {
entry:
  %zslba.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %zslba, ptr %zslba.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_ZONE_IS_FULL_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %zslba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.207, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %zslba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.208, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_zone_is_offline(i64 noundef %zslba) #0 {
entry:
  %zslba.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %zslba, ptr %zslba.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %zslba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.209, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %zslba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.210, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_zone_is_read_only(i64 noundef %zslba) #0 {
entry:
  %zslba.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %zslba, ptr %zslba.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %zslba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.211, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %zslba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.212, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_zone_invalid_write(i64 noundef %slba, i64 noundef %wp) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %wp.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i64 %wp, ptr %wp.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i64, ptr %wp.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.213, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %slba.addr, align 8
  %8 = load i64, ptr %wp.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.214, i64 noundef %7, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_write_not_at_wp(i64 noundef %slba, i64 noundef %zone, i64 noundef %wp) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone.addr = alloca i64, align 8
  %wp.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i64 %zone, ptr %zone.addr, align 8
  store i64 %wp, ptr %wp.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i64, ptr %zone.addr, align 8
  %7 = load i64, ptr %wp.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.215, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6, i64 noundef %7)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i64, ptr %slba.addr, align 8
  %9 = load i64, ptr %zone.addr, align 8
  %10 = load i64, ptr %wp.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.216, i64 noundef %8, i64 noundef %9, i64 noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_zone_boundary(i64 noundef %slba, i32 noundef %nlb, i64 noundef %zcap) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %zcap.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  store i64 %zcap, ptr %zcap.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_ZONE_BOUNDARY_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i32, ptr %nlb.addr, align 4
  %7 = load i64, ptr %zcap.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.217, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6, i64 noundef %7)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i64, ptr %slba.addr, align 8
  %9 = load i32, ptr %nlb.addr, align 4
  %10 = load i64, ptr %zcap.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.218, i64 noundef %8, i32 noundef %9, i64 noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_zrm_open_flags(ptr noundef %n, ptr noundef %ns, ptr noundef %zone, i32 noundef %flags) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %act = alloca i32, align 4
  %status = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 0, ptr %act, align 4
  %0 = load ptr, ptr %zone.addr, align 8
  %call = call i32 @nvme_get_zone_state(ptr noundef %0)
  switch i32 %call, label %sw.default [
    i32 1, label %sw.bb
    i32 4, label %sw.bb1
    i32 2, label %sw.bb14
    i32 3, label %sw.bb19
  ]

sw.bb:                                            ; preds = %entry
  store i32 1, ptr %act, align 4
  br label %sw.bb1

sw.bb1:                                           ; preds = %sw.bb, %entry
  %1 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 4
  %auto_transition_zones = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 11
  %2 = load i8, ptr %auto_transition_zones, align 4
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb1
  %3 = load ptr, ptr %ns.addr, align 8
  call void @nvme_zrm_auto_transition_zone(ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb1
  %4 = load ptr, ptr %ns.addr, align 8
  %5 = load i32, ptr %act, align 4
  %6 = load i32, ptr %flags.addr, align 4
  %and = and i32 %6, 2
  %tobool2 = icmp ne i32 %and, 0
  %cond = select i1 %tobool2, i32 1, i32 0
  %call3 = call zeroext i16 @nvme_zns_check_resources(ptr noundef %4, i32 noundef %5, i32 noundef 1, i32 noundef %cond)
  store i16 %call3, ptr %status, align 2
  %7 = load i16, ptr %status, align 2
  %tobool4 = icmp ne i16 %7, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %8 = load i16, ptr %status, align 2
  store i16 %8, ptr %retval, align 2
  br label %return

if.end6:                                          ; preds = %if.end
  %9 = load i32, ptr %act, align 4
  %tobool7 = icmp ne i32 %9, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %10 = load ptr, ptr %ns.addr, align 8
  call void @nvme_aor_inc_active(ptr noundef %10)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %11 = load ptr, ptr %ns.addr, align 8
  call void @nvme_aor_inc_open(ptr noundef %11)
  %12 = load i32, ptr %flags.addr, align 4
  %and10 = and i32 %12, 1
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  %13 = load ptr, ptr %ns.addr, align 8
  %14 = load ptr, ptr %zone.addr, align 8
  call void @nvme_assign_zone_state(ptr noundef %13, ptr noundef %14, i32 noundef 2)
  store i16 0, ptr %retval, align 2
  br label %return

if.end13:                                         ; preds = %if.end9
  br label %sw.bb14

sw.bb14:                                          ; preds = %if.end13, %entry
  %15 = load i32, ptr %flags.addr, align 4
  %and15 = and i32 %15, 1
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %sw.bb14
  store i16 0, ptr %retval, align 2
  br label %return

if.end18:                                         ; preds = %sw.bb14
  %16 = load ptr, ptr %ns.addr, align 8
  %17 = load ptr, ptr %zone.addr, align 8
  call void @nvme_assign_zone_state(ptr noundef %16, ptr noundef %17, i32 noundef 3)
  br label %sw.bb19

sw.bb19:                                          ; preds = %if.end18, %entry
  %18 = load i32, ptr %flags.addr, align 4
  %and20 = and i32 %18, 2
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %sw.bb19
  %19 = load ptr, ptr %ns.addr, align 8
  %zns = getelementptr inbounds %struct.NvmeNamespace, ptr %19, i32 0, i32 15
  %numzrwa = getelementptr inbounds %struct.anon.4, ptr %zns, i32 0, i32 2
  %20 = load i32, ptr %numzrwa, align 4
  %dec = add i32 %20, -1
  store i32 %dec, ptr %numzrwa, align 4
  %21 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %21, i32 0, i32 0
  %za = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 2
  %22 = load i8, ptr %za, align 2
  %conv = zext i8 %22 to i32
  %or = or i32 %conv, 8
  %conv23 = trunc i32 %or to i8
  store i8 %conv23, ptr %za, align 2
  br label %if.end24

if.end24:                                         ; preds = %if.then22, %sw.bb19
  store i16 0, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %entry
  store i16 447, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.default, %if.end24, %if.then17, %if.then12, %if.then5
  %23 = load i16, ptr %retval, align 2
  ret i16 %23
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_zrm_auto_transition_zone(ptr noundef %ns) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %zone = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 30
  %max_open_zones = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 19
  %1 = load i32, ptr %max_open_zones, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %ns.addr, align 8
  %nr_open_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %2, i32 0, i32 28
  %3 = load i32, ptr %nr_open_zones, align 8
  %4 = load ptr, ptr %ns.addr, align 8
  %params1 = getelementptr inbounds %struct.NvmeNamespace, ptr %4, i32 0, i32 30
  %max_open_zones2 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params1, i32 0, i32 19
  %5 = load i32, ptr %max_open_zones2, align 4
  %cmp = icmp eq i32 %3, %5
  br i1 %cmp, label %if.then, label %if.end25

if.then:                                          ; preds = %land.lhs.true
  %6 = load ptr, ptr %ns.addr, align 8
  %imp_open_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %6, i32 0, i32 20
  %7 = load ptr, ptr %imp_open_zones, align 8
  store ptr %7, ptr %zone, align 8
  %8 = load ptr, ptr %zone, align 8
  %tobool3 = icmp ne ptr %8, null
  br i1 %tobool3, label %if.then4, label %if.end24

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  %9 = load ptr, ptr %zone, align 8
  %entry5 = getelementptr inbounds %struct.NvmeZone, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %entry5, align 8
  %cmp6 = icmp ne ptr %10, null
  br i1 %cmp6, label %if.then7, label %if.else

if.then7:                                         ; preds = %do.body
  %11 = load ptr, ptr %zone, align 8
  %entry8 = getelementptr inbounds %struct.NvmeZone, ptr %11, i32 0, i32 2
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %entry8, i32 0, i32 1
  %12 = load ptr, ptr %tql_prev, align 8
  %13 = load ptr, ptr %zone, align 8
  %entry9 = getelementptr inbounds %struct.NvmeZone, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %entry9, align 8
  %entry10 = getelementptr inbounds %struct.NvmeZone, ptr %14, i32 0, i32 2
  %tql_prev11 = getelementptr inbounds %struct.QTailQLink, ptr %entry10, i32 0, i32 1
  store ptr %12, ptr %tql_prev11, align 8
  br label %if.end

if.else:                                          ; preds = %do.body
  %15 = load ptr, ptr %zone, align 8
  %entry12 = getelementptr inbounds %struct.NvmeZone, ptr %15, i32 0, i32 2
  %tql_prev13 = getelementptr inbounds %struct.QTailQLink, ptr %entry12, i32 0, i32 1
  %16 = load ptr, ptr %tql_prev13, align 8
  %17 = load ptr, ptr %ns.addr, align 8
  %imp_open_zones14 = getelementptr inbounds %struct.NvmeNamespace, ptr %17, i32 0, i32 20
  %tql_prev15 = getelementptr inbounds %struct.QTailQLink, ptr %imp_open_zones14, i32 0, i32 1
  store ptr %16, ptr %tql_prev15, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then7
  %18 = load ptr, ptr %zone, align 8
  %entry16 = getelementptr inbounds %struct.NvmeZone, ptr %18, i32 0, i32 2
  %19 = load ptr, ptr %entry16, align 8
  %20 = load ptr, ptr %zone, align 8
  %entry17 = getelementptr inbounds %struct.NvmeZone, ptr %20, i32 0, i32 2
  %tql_prev18 = getelementptr inbounds %struct.QTailQLink, ptr %entry17, i32 0, i32 1
  %21 = load ptr, ptr %tql_prev18, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %21, i32 0, i32 0
  store ptr %19, ptr %tql_next, align 8
  %22 = load ptr, ptr %zone, align 8
  %entry19 = getelementptr inbounds %struct.NvmeZone, ptr %22, i32 0, i32 2
  %tql_prev20 = getelementptr inbounds %struct.QTailQLink, ptr %entry19, i32 0, i32 1
  store ptr null, ptr %tql_prev20, align 8
  %23 = load ptr, ptr %zone, align 8
  %entry21 = getelementptr inbounds %struct.NvmeZone, ptr %23, i32 0, i32 2
  %tql_next22 = getelementptr inbounds %struct.QTailQLink, ptr %entry21, i32 0, i32 0
  store ptr null, ptr %tql_next22, align 8
  %24 = load ptr, ptr %zone, align 8
  %entry23 = getelementptr inbounds %struct.NvmeZone, ptr %24, i32 0, i32 2
  store ptr null, ptr %entry23, align 8
  br label %do.end

do.end:                                           ; preds = %if.end
  %25 = load ptr, ptr %ns.addr, align 8
  %26 = load ptr, ptr %zone, align 8
  %call = call zeroext i16 @nvme_zrm_close(ptr noundef %25, ptr noundef %26)
  br label %if.end24

if.end24:                                         ; preds = %do.end, %if.then
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_zns_check_resources(ptr noundef %ns, i32 noundef %act, i32 noundef %opn, i32 noundef %zrwa) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %act.addr = alloca i32, align 4
  %opn.addr = alloca i32, align 4
  %zrwa.addr = alloca i32, align 4
  store ptr %ns, ptr %ns.addr, align 8
  store i32 %act, ptr %act.addr, align 4
  store i32 %opn, ptr %opn.addr, align 4
  store i32 %zrwa, ptr %zrwa.addr, align 4
  %0 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 30
  %max_active_zones = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 18
  %1 = load i32, ptr %max_active_zones, align 8
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %ns.addr, align 8
  %nr_active_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %2, i32 0, i32 29
  %3 = load i32, ptr %nr_active_zones, align 4
  %4 = load i32, ptr %act.addr, align 4
  %add = add i32 %3, %4
  %5 = load ptr, ptr %ns.addr, align 8
  %params1 = getelementptr inbounds %struct.NvmeNamespace, ptr %5, i32 0, i32 30
  %max_active_zones2 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params1, i32 0, i32 18
  %6 = load i32, ptr %max_active_zones2, align 8
  %cmp3 = icmp ugt i32 %add, %6
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %7 = load ptr, ptr %ns.addr, align 8
  %params4 = getelementptr inbounds %struct.NvmeNamespace, ptr %7, i32 0, i32 30
  %max_active_zones5 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params4, i32 0, i32 18
  %8 = load i32, ptr %max_active_zones5, align 8
  call void @trace_pci_nvme_err_insuff_active_res(i32 noundef %8)
  store i16 16829, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %9 = load ptr, ptr %ns.addr, align 8
  %params6 = getelementptr inbounds %struct.NvmeNamespace, ptr %9, i32 0, i32 30
  %max_open_zones = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params6, i32 0, i32 19
  %10 = load i32, ptr %max_open_zones, align 4
  %cmp7 = icmp ne i32 %10, 0
  br i1 %cmp7, label %land.lhs.true8, label %if.end16

land.lhs.true8:                                   ; preds = %if.end
  %11 = load ptr, ptr %ns.addr, align 8
  %nr_open_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %11, i32 0, i32 28
  %12 = load i32, ptr %nr_open_zones, align 8
  %13 = load i32, ptr %opn.addr, align 4
  %add9 = add i32 %12, %13
  %14 = load ptr, ptr %ns.addr, align 8
  %params10 = getelementptr inbounds %struct.NvmeNamespace, ptr %14, i32 0, i32 30
  %max_open_zones11 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params10, i32 0, i32 19
  %15 = load i32, ptr %max_open_zones11, align 4
  %cmp12 = icmp ugt i32 %add9, %15
  br i1 %cmp12, label %if.then13, label %if.end16

if.then13:                                        ; preds = %land.lhs.true8
  %16 = load ptr, ptr %ns.addr, align 8
  %params14 = getelementptr inbounds %struct.NvmeNamespace, ptr %16, i32 0, i32 30
  %max_open_zones15 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params14, i32 0, i32 19
  %17 = load i32, ptr %max_open_zones15, align 4
  call void @trace_pci_nvme_err_insuff_open_res(i32 noundef %17)
  store i16 16830, ptr %retval, align 2
  br label %return

if.end16:                                         ; preds = %land.lhs.true8, %if.end
  %18 = load i32, ptr %zrwa.addr, align 4
  %19 = load ptr, ptr %ns.addr, align 8
  %zns = getelementptr inbounds %struct.NvmeNamespace, ptr %19, i32 0, i32 15
  %numzrwa = getelementptr inbounds %struct.anon.4, ptr %zns, i32 0, i32 2
  %20 = load i32, ptr %numzrwa, align 4
  %cmp17 = icmp ugt i32 %18, %20
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end16
  store i16 16823, ptr %retval, align 2
  br label %return

if.end19:                                         ; preds = %if.end16
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end19, %if.then18, %if.then13, %if.then
  %21 = load i16, ptr %retval, align 2
  ret i16 %21
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_aor_inc_active(ptr noundef %ns) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %nr_active_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 29
  %1 = load i32, ptr %nr_active_zones, align 4
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.43, ptr noundef @.str.39, i32 noundef 347, ptr noundef @__PRETTY_FUNCTION__.nvme_aor_inc_active) #12
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %2, i32 0, i32 30
  %max_active_zones = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 18
  %3 = load i32, ptr %max_active_zones, align 8
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then1, label %if.end10

if.then1:                                         ; preds = %if.end
  %4 = load ptr, ptr %ns.addr, align 8
  %nr_active_zones2 = getelementptr inbounds %struct.NvmeNamespace, ptr %4, i32 0, i32 29
  %5 = load i32, ptr %nr_active_zones2, align 4
  %inc = add i32 %5, 1
  store i32 %inc, ptr %nr_active_zones2, align 4
  %6 = load ptr, ptr %ns.addr, align 8
  %nr_active_zones3 = getelementptr inbounds %struct.NvmeNamespace, ptr %6, i32 0, i32 29
  %7 = load i32, ptr %nr_active_zones3, align 4
  %8 = load ptr, ptr %ns.addr, align 8
  %params4 = getelementptr inbounds %struct.NvmeNamespace, ptr %8, i32 0, i32 30
  %max_active_zones5 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params4, i32 0, i32 18
  %9 = load i32, ptr %max_active_zones5, align 8
  %cmp6 = icmp ule i32 %7, %9
  br i1 %cmp6, label %if.then7, label %if.else8

if.then7:                                         ; preds = %if.then1
  br label %if.end9

if.else8:                                         ; preds = %if.then1
  call void @__assert_fail(ptr noundef @.str.223, ptr noundef @.str.39, i32 noundef 350, ptr noundef @__PRETTY_FUNCTION__.nvme_aor_inc_active) #12
  unreachable

if.end9:                                          ; preds = %if.then7
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_aor_inc_open(ptr noundef %ns) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %nr_open_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 28
  %1 = load i32, ptr %nr_open_zones, align 8
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.40, ptr noundef @.str.39, i32 noundef 329, ptr noundef @__PRETTY_FUNCTION__.nvme_aor_inc_open) #12
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %2, i32 0, i32 30
  %max_open_zones = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 19
  %3 = load i32, ptr %max_open_zones, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then1, label %if.end10

if.then1:                                         ; preds = %if.end
  %4 = load ptr, ptr %ns.addr, align 8
  %nr_open_zones2 = getelementptr inbounds %struct.NvmeNamespace, ptr %4, i32 0, i32 28
  %5 = load i32, ptr %nr_open_zones2, align 8
  %inc = add i32 %5, 1
  store i32 %inc, ptr %nr_open_zones2, align 8
  %6 = load ptr, ptr %ns.addr, align 8
  %nr_open_zones3 = getelementptr inbounds %struct.NvmeNamespace, ptr %6, i32 0, i32 28
  %7 = load i32, ptr %nr_open_zones3, align 8
  %8 = load ptr, ptr %ns.addr, align 8
  %params4 = getelementptr inbounds %struct.NvmeNamespace, ptr %8, i32 0, i32 30
  %max_open_zones5 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params4, i32 0, i32 19
  %9 = load i32, ptr %max_open_zones5, align 4
  %cmp6 = icmp ule i32 %7, %9
  br i1 %cmp6, label %if.then7, label %if.else8

if.then7:                                         ; preds = %if.then1
  br label %if.end9

if.else8:                                         ; preds = %if.then1
  call void @__assert_fail(ptr noundef @.str.224, ptr noundef @.str.39, i32 noundef 332, ptr noundef @__PRETTY_FUNCTION__.nvme_aor_inc_open) #12
  unreachable

if.end9:                                          ; preds = %if.then7
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_zrm_close(ptr noundef %ns, ptr noundef %zone) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  %0 = load ptr, ptr %zone.addr, align 8
  %call = call i32 @nvme_get_zone_state(ptr noundef %0)
  switch i32 %call, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb
    i32 4, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry, %entry
  %1 = load ptr, ptr %ns.addr, align 8
  call void @nvme_aor_dec_open(ptr noundef %1)
  %2 = load ptr, ptr %ns.addr, align 8
  %3 = load ptr, ptr %zone.addr, align 8
  call void @nvme_assign_zone_state(ptr noundef %2, ptr noundef %3, i32 noundef 4)
  br label %sw.bb1

sw.bb1:                                           ; preds = %sw.bb, %entry
  store i16 0, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %entry
  store i16 447, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.default, %sw.bb1
  %4 = load i16, ptr %retval, align 2
  ret i16 %4
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_insuff_active_res(i32 noundef %max_active) #0 {
entry:
  %max_active.addr = alloca i32, align 4
  store i32 %max_active, ptr %max_active.addr, align 4
  %0 = load i32, ptr %max_active.addr, align 4
  call void @_nocheck__trace_pci_nvme_err_insuff_active_res(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_insuff_open_res(i32 noundef %max_open) #0 {
entry:
  %max_open.addr = alloca i32, align 4
  store i32 %max_open, ptr %max_open.addr, align 4
  %0 = load i32, ptr %max_open.addr, align 4
  call void @_nocheck__trace_pci_nvme_err_insuff_open_res(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_insuff_active_res(i32 noundef %max_active) #0 {
entry:
  %max_active.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %max_active, ptr %max_active.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %max_active.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.219, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %max_active.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.220, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_insuff_open_res(i32 noundef %max_open) #0 {
entry:
  %max_open.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %max_open, ptr %max_open.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %max_open.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.221, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %max_open.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.222, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_parse_pid(ptr noundef %ns, i16 noundef zeroext %pid, ptr noundef %ph, ptr noundef %rg) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %pid.addr = alloca i16, align 2
  %ph.addr = alloca ptr, align 8
  %rg.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store i16 %pid, ptr %pid.addr, align 2
  store ptr %ph, ptr %ph.addr, align 8
  store ptr %rg, ptr %rg.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %1 = load i16, ptr %pid.addr, align 2
  %call = call zeroext i16 @nvme_pid2rg(ptr noundef %0, i16 noundef zeroext %1)
  %2 = load ptr, ptr %rg.addr, align 8
  store i16 %call, ptr %2, align 2
  %3 = load ptr, ptr %ns.addr, align 8
  %4 = load i16, ptr %pid.addr, align 2
  %call1 = call zeroext i16 @nvme_pid2ph(ptr noundef %3, i16 noundef zeroext %4)
  %5 = load ptr, ptr %ph.addr, align 8
  store i16 %call1, ptr %5, align 2
  %6 = load ptr, ptr %ns.addr, align 8
  %7 = load ptr, ptr %ph.addr, align 8
  %8 = load i16, ptr %7, align 2
  %call2 = call zeroext i1 @nvme_ph_valid(ptr noundef %6, i16 noundef zeroext %8)
  br i1 %call2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %9 = load ptr, ptr %ns.addr, align 8
  %endgrp = getelementptr inbounds %struct.NvmeNamespace, ptr %9, i32 0, i32 32
  %10 = load ptr, ptr %endgrp, align 8
  %11 = load ptr, ptr %rg.addr, align 8
  %12 = load i16, ptr %11, align 2
  %call3 = call zeroext i1 @nvme_rg_valid(ptr noundef %10, i16 noundef zeroext %12)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %13 = phi i1 [ false, %entry ], [ %call3, %land.rhs ]
  ret i1 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_fdp_stat_inc(ptr noundef %a, i64 noundef %b) #0 {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca i64, align 8
  %ret = alloca i64, align 8
  store ptr %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load i64, ptr %0, align 8
  %2 = load i64, ptr %b.addr, align 8
  %add = add i64 %1, %2
  store i64 %add, ptr %ret, align 8
  %3 = load i64, ptr %ret, align 8
  %4 = load ptr, ptr %a.addr, align 8
  %5 = load i64, ptr %4, align 8
  %cmp = icmp ult i64 %3, %5
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, ptr %ret, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ -1, %cond.true ], [ %6, %cond.false ]
  %7 = load ptr, ptr %a.addr, align 8
  store i64 %cond, ptr %7, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_update_ruh(ptr noundef %n, ptr noundef %ns, i16 noundef zeroext %pid) #0 {
entry:
  %retval = alloca i1, align 1
  %n.addr = alloca ptr, align 8
  %ns.addr = alloca ptr, align 8
  %pid.addr = alloca i16, align 2
  %endgrp = alloca ptr, align 8
  %ruh = alloca ptr, align 8
  %ru = alloca ptr, align 8
  %e = alloca ptr, align 8
  %ph = alloca i16, align 2
  %rg = alloca i16, align 2
  %ruhid = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store i16 %pid, ptr %pid.addr, align 2
  %0 = load ptr, ptr %ns.addr, align 8
  %endgrp1 = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 32
  %1 = load ptr, ptr %endgrp1, align 8
  store ptr %1, ptr %endgrp, align 8
  store ptr null, ptr %e, align 8
  %2 = load ptr, ptr %ns.addr, align 8
  %3 = load i16, ptr %pid.addr, align 2
  %call = call zeroext i1 @nvme_parse_pid(ptr noundef %2, i16 noundef zeroext %3, ptr noundef %ph, ptr noundef %rg)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %ns.addr, align 8
  %fdp = getelementptr inbounds %struct.NvmeNamespace, ptr %4, i32 0, i32 34
  %phs = getelementptr inbounds %struct.anon.14, ptr %fdp, i32 0, i32 1
  %5 = load ptr, ptr %phs, align 8
  %6 = load i16, ptr %ph, align 2
  %idxprom = zext i16 %6 to i64
  %arrayidx = getelementptr i16, ptr %5, i64 %idxprom
  %7 = load i16, ptr %arrayidx, align 2
  store i16 %7, ptr %ruhid, align 2
  %8 = load ptr, ptr %endgrp, align 8
  %fdp2 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %8, i32 0, i32 1
  %ruhs = getelementptr inbounds %struct.anon.36, ptr %fdp2, i32 0, i32 10
  %9 = load ptr, ptr %ruhs, align 8
  %10 = load i16, ptr %ruhid, align 2
  %idxprom3 = zext i16 %10 to i64
  %arrayidx4 = getelementptr %struct.NvmeRuHandle, ptr %9, i64 %idxprom3
  store ptr %arrayidx4, ptr %ruh, align 8
  %11 = load ptr, ptr %ruh, align 8
  %rus = getelementptr inbounds %struct.NvmeRuHandle, ptr %11, i32 0, i32 5
  %12 = load ptr, ptr %rus, align 8
  %13 = load i16, ptr %rg, align 2
  %idxprom5 = zext i16 %13 to i64
  %arrayidx6 = getelementptr %struct.NvmeReclaimUnit, ptr %12, i64 %idxprom5
  store ptr %arrayidx6, ptr %ru, align 8
  %14 = load ptr, ptr %ru, align 8
  %ruamw = getelementptr inbounds %struct.NvmeReclaimUnit, ptr %14, i32 0, i32 0
  %15 = load i64, ptr %ruamw, align 8
  %tobool = icmp ne i64 %15, 0
  br i1 %tobool, label %if.then7, label %if.end24

if.then7:                                         ; preds = %if.end
  %16 = load ptr, ptr %ruh, align 8
  %call8 = call i32 @log_event(ptr noundef %16, i8 noundef zeroext 0)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end20

if.then10:                                        ; preds = %if.then7
  %17 = load ptr, ptr %n.addr, align 8
  %18 = load ptr, ptr %endgrp, align 8
  %fdp11 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %18, i32 0, i32 1
  %host_events = getelementptr inbounds %struct.anon.36, ptr %fdp11, i32 0, i32 0
  %call12 = call ptr @nvme_fdp_alloc_event(ptr noundef %17, ptr noundef %host_events)
  store ptr %call12, ptr %e, align 8
  %19 = load ptr, ptr %e, align 8
  %type = getelementptr inbounds %struct.NvmeFdpEvent, ptr %19, i32 0, i32 0
  store i8 0, ptr %type, align 1
  %20 = load ptr, ptr %e, align 8
  %flags = getelementptr inbounds %struct.NvmeFdpEvent, ptr %20, i32 0, i32 1
  store i8 7, ptr %flags, align 1
  %21 = load i16, ptr %pid.addr, align 2
  %call13 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %21)
  %22 = load ptr, ptr %e, align 8
  %pid14 = getelementptr inbounds %struct.NvmeFdpEvent, ptr %22, i32 0, i32 2
  store i16 %call13, ptr %pid14, align 1
  %23 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %23, i32 0, i32 30
  %nsid = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 2
  %24 = load i32, ptr %nsid, align 4
  %call15 = call i32 @cpu_to_le32(i32 noundef %24)
  %25 = load ptr, ptr %e, align 8
  %nsid16 = getelementptr inbounds %struct.NvmeFdpEvent, ptr %25, i32 0, i32 4
  store i32 %call15, ptr %nsid16, align 1
  %26 = load i16, ptr %rg, align 2
  %call17 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %26)
  %27 = load ptr, ptr %e, align 8
  %rgid = getelementptr inbounds %struct.NvmeFdpEvent, ptr %27, i32 0, i32 6
  store i16 %call17, ptr %rgid, align 1
  %28 = load i16, ptr %ruhid, align 2
  %call18 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %28)
  %conv = trunc i16 %call18 to i8
  %29 = load ptr, ptr %e, align 8
  %ruhid19 = getelementptr inbounds %struct.NvmeFdpEvent, ptr %29, i32 0, i32 7
  store i8 %conv, ptr %ruhid19, align 1
  br label %if.end20

if.end20:                                         ; preds = %if.then10, %if.then7
  %30 = load ptr, ptr %endgrp, align 8
  %fdp21 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %30, i32 0, i32 1
  %mbmw = getelementptr inbounds %struct.anon.36, ptr %fdp21, i32 0, i32 7
  %31 = load ptr, ptr %ns.addr, align 8
  %32 = load ptr, ptr %ru, align 8
  %ruamw22 = getelementptr inbounds %struct.NvmeReclaimUnit, ptr %32, i32 0, i32 0
  %33 = load i64, ptr %ruamw22, align 8
  %call23 = call i64 @nvme_l2b(ptr noundef %31, i64 noundef %33)
  call void @nvme_fdp_stat_inc(ptr noundef %mbmw, i64 noundef %call23)
  br label %if.end24

if.end24:                                         ; preds = %if.end20, %if.end
  %34 = load ptr, ptr %ruh, align 8
  %ruamw25 = getelementptr inbounds %struct.NvmeRuHandle, ptr %34, i32 0, i32 4
  %35 = load i64, ptr %ruamw25, align 8
  %36 = load ptr, ptr %ru, align 8
  %ruamw26 = getelementptr inbounds %struct.NvmeReclaimUnit, ptr %36, i32 0, i32 0
  store i64 %35, ptr %ruamw26, align 8
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end24, %if.then
  %37 = load i1, ptr %retval, align 1
  ret i1 %37
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_pid2rg(ptr noundef %ns, i16 noundef zeroext %pid) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %pid.addr = alloca i16, align 2
  %rgif = alloca i16, align 2
  store ptr %ns, ptr %ns.addr, align 8
  store i16 %pid, ptr %pid.addr, align 2
  %0 = load ptr, ptr %ns.addr, align 8
  %endgrp = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 32
  %1 = load ptr, ptr %endgrp, align 8
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %1, i32 0, i32 1
  %rgif1 = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 4
  %2 = load i8, ptr %rgif1, align 4
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %rgif, align 2
  %3 = load i16, ptr %rgif, align 2
  %tobool = icmp ne i16 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 0, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i16, ptr %pid.addr, align 2
  %conv2 = zext i16 %4 to i32
  %5 = load i16, ptr %rgif, align 2
  %conv3 = zext i16 %5 to i32
  %sub = sub i32 16, %conv3
  %shr = ashr i32 %conv2, %sub
  %conv4 = trunc i32 %shr to i16
  store i16 %conv4, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i16, ptr %retval, align 2
  ret i16 %6
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_pid2ph(ptr noundef %ns, i16 noundef zeroext %pid) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %pid.addr = alloca i16, align 2
  %rgif = alloca i16, align 2
  store ptr %ns, ptr %ns.addr, align 8
  store i16 %pid, ptr %pid.addr, align 2
  %0 = load ptr, ptr %ns.addr, align 8
  %endgrp = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 32
  %1 = load ptr, ptr %endgrp, align 8
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %1, i32 0, i32 1
  %rgif1 = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 4
  %2 = load i8, ptr %rgif1, align 4
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %rgif, align 2
  %3 = load i16, ptr %rgif, align 2
  %tobool = icmp ne i16 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load i16, ptr %pid.addr, align 2
  store i16 %4, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i16, ptr %pid.addr, align 2
  %conv2 = zext i16 %5 to i32
  %6 = load i16, ptr %rgif, align 2
  %conv3 = zext i16 %6 to i32
  %sub = sub i32 15, %conv3
  %shl = shl i32 1, %sub
  %sub4 = sub i32 %shl, 1
  %and = and i32 %conv2, %sub4
  %conv5 = trunc i32 %and to i16
  store i16 %conv5, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i16, ptr %retval, align 2
  ret i16 %7
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_ph_valid(ptr noundef %ns, i16 noundef zeroext %ph) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %ph.addr = alloca i16, align 2
  store ptr %ns, ptr %ns.addr, align 8
  store i16 %ph, ptr %ph.addr, align 2
  %0 = load i16, ptr %ph.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load ptr, ptr %ns.addr, align 8
  %fdp = getelementptr inbounds %struct.NvmeNamespace, ptr %1, i32 0, i32 34
  %nphs = getelementptr inbounds %struct.anon.14, ptr %fdp, i32 0, i32 0
  %2 = load i16, ptr %nphs, align 8
  %conv1 = zext i16 %2 to i32
  %cmp = icmp slt i32 %conv, %conv1
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_rg_valid(ptr noundef %endgrp, i16 noundef zeroext %rg) #0 {
entry:
  %endgrp.addr = alloca ptr, align 8
  %rg.addr = alloca i16, align 2
  store ptr %endgrp, ptr %endgrp.addr, align 8
  store i16 %rg, ptr %rg.addr, align 2
  %0 = load i16, ptr %rg.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load ptr, ptr %endgrp.addr, align 8
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %1, i32 0, i32 1
  %nrg = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 3
  %2 = load i16, ptr %nrg, align 2
  %conv1 = zext i16 %2 to i32
  %cmp = icmp slt i32 %conv, %conv1
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @log_event(ptr noundef %ruh, i8 noundef zeroext %event_type) #0 {
entry:
  %ruh.addr = alloca ptr, align 8
  %event_type.addr = alloca i8, align 1
  store ptr %ruh, ptr %ruh.addr, align 8
  store i8 %event_type, ptr %event_type.addr, align 1
  %0 = load ptr, ptr %ruh.addr, align 8
  %event_filter = getelementptr inbounds %struct.NvmeRuHandle, ptr %0, i32 0, i32 2
  %1 = load i64, ptr %event_filter, align 8
  %2 = load i8, ptr %event_type.addr, align 1
  %idxprom = zext i8 %2 to i64
  %arrayidx = getelementptr [255 x i8], ptr @nvme_fdp_evf_shifts, i64 0, i64 %idxprom
  %3 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %3 to i32
  %sh_prom = zext i32 %conv to i64
  %shr = lshr i64 %1, %sh_prom
  %and = and i64 %shr, 1
  %conv1 = trunc i64 %and to i32
  ret i32 %conv1
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_fdp_alloc_event(ptr noundef %n, ptr noundef %ebuf) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %ebuf.addr = alloca ptr, align 8
  %ret = alloca ptr, align 8
  %is_full = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store ptr %ebuf, ptr %ebuf.addr, align 8
  store ptr null, ptr %ret, align 8
  %0 = load ptr, ptr %ebuf.addr, align 8
  %next = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %next, align 4
  %2 = load ptr, ptr %ebuf.addr, align 8
  %start = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %2, i32 0, i32 2
  %3 = load i32, ptr %start, align 4
  %cmp = icmp eq i32 %1, %3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %4 = load ptr, ptr %ebuf.addr, align 8
  %nelems = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %4, i32 0, i32 1
  %5 = load i32, ptr %nelems, align 4
  %tobool = icmp ne i32 %5, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %tobool, %land.rhs ]
  %frombool = zext i1 %6 to i8
  store i8 %frombool, ptr %is_full, align 1
  %7 = load ptr, ptr %ebuf.addr, align 8
  %events = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %ebuf.addr, align 8
  %next1 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %8, i32 0, i32 3
  %9 = load i32, ptr %next1, align 4
  %inc = add i32 %9, 1
  store i32 %inc, ptr %next1, align 4
  %idxprom = zext i32 %9 to i64
  %arrayidx = getelementptr [63 x %struct.NvmeFdpEvent], ptr %events, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %ret, align 8
  %10 = load ptr, ptr %ebuf.addr, align 8
  %next2 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %10, i32 0, i32 3
  %11 = load i32, ptr %next2, align 4
  %cmp3 = icmp eq i32 %11, 63
  %lnot = xor i1 %cmp3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  %12 = load ptr, ptr %ebuf.addr, align 8
  %next6 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %12, i32 0, i32 3
  store i32 0, ptr %next6, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.end
  %13 = load i8, ptr %is_full, align 1
  %tobool7 = trunc i8 %13 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end
  %14 = load ptr, ptr %ebuf.addr, align 8
  %next9 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %14, i32 0, i32 3
  %15 = load i32, ptr %next9, align 4
  %16 = load ptr, ptr %ebuf.addr, align 8
  %start10 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %16, i32 0, i32 2
  store i32 %15, ptr %start10, align 4
  br label %if.end13

if.else:                                          ; preds = %if.end
  %17 = load ptr, ptr %ebuf.addr, align 8
  %nelems11 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %17, i32 0, i32 1
  %18 = load i32, ptr %nelems11, align 4
  %inc12 = add i32 %18, 1
  store i32 %inc12, ptr %nelems11, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then8
  %19 = load ptr, ptr %ret, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %19, i8 0, i64 64, i1 false)
  %20 = load ptr, ptr %n.addr, align 8
  %call = call i64 @nvme_get_timestamp(ptr noundef %20)
  %21 = load ptr, ptr %ret, align 8
  %timestamp = getelementptr inbounds %struct.NvmeFdpEvent, ptr %21, i32 0, i32 3
  store i64 %call, ptr %timestamp, align 1
  %22 = load ptr, ptr %ret, align 8
  ret ptr %22
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @nvme_get_timestamp(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %current_time = alloca i64, align 8
  %elapsed_time = alloca i64, align 8
  %ts = alloca %union.nvme_timestamp, align 8
  store ptr %n, ptr %n.addr, align 8
  %call = call i64 @qemu_clock_get_ms(i32 noundef 1)
  store i64 %call, ptr %current_time, align 8
  %0 = load i64, ptr %current_time, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %timestamp_set_qemu_clock_ms = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 16
  %2 = load i64, ptr %timestamp_set_qemu_clock_ms, align 16
  %sub = sub i64 %0, %2
  store i64 %sub, ptr %elapsed_time, align 8
  store i64 0, ptr %ts, align 8
  %3 = load ptr, ptr %n.addr, align 8
  %host_timestamp = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 15
  %4 = load i64, ptr %host_timestamp, align 8
  %5 = load i64, ptr %elapsed_time, align 8
  %add = add i64 %4, %5
  %bf.load = load i64, ptr %ts, align 8
  %bf.value = and i64 %add, 281474976710655
  %bf.clear = and i64 %bf.load, -281474976710656
  %bf.set = or i64 %bf.clear, %bf.value
  store i64 %bf.set, ptr %ts, align 8
  %6 = load ptr, ptr %n.addr, align 8
  %host_timestamp1 = getelementptr inbounds %struct.NvmeCtrl, ptr %6, i32 0, i32 15
  %7 = load i64, ptr %host_timestamp1, align 8
  %tobool = icmp ne i64 %7, 0
  %cond = select i1 %tobool, i32 1, i32 0
  %conv = sext i32 %cond to i64
  %bf.load2 = load i64, ptr %ts, align 8
  %bf.value3 = and i64 %conv, 7
  %bf.shl = shl i64 %bf.value3, 49
  %bf.clear4 = and i64 %bf.load2, -3940649673949185
  %bf.set5 = or i64 %bf.clear4, %bf.shl
  store i64 %bf.set5, ptr %ts, align 8
  %8 = load i64, ptr %ts, align 8
  call void @trace_pci_nvme_getfeat_timestamp(i64 noundef %8)
  %9 = load i64, ptr %ts, align 8
  %call6 = call i64 @cpu_to_le64(i64 noundef %9)
  ret i64 %call6
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_getfeat_timestamp(i64 noundef %ts) #0 {
entry:
  %ts.addr = alloca i64, align 8
  store i64 %ts, ptr %ts.addr, align 8
  %0 = load i64, ptr %ts.addr, align 8
  call void @_nocheck__trace_pci_nvme_getfeat_timestamp(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_getfeat_timestamp(i64 noundef %ts) #0 {
entry:
  %ts.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %ts, ptr %ts.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_GETFEAT_TIMESTAMP_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %ts.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.226, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %ts.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.227, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_sg_split(ptr noundef %sg, ptr noundef %ns, ptr noundef %data, ptr noundef %mdata) #0 {
entry:
  %sg.addr = alloca ptr, align 8
  %ns.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %mdata.addr = alloca ptr, align 8
  %dst = alloca ptr, align 8
  %trans_len = alloca i32, align 4
  %count = alloca i32, align 4
  %offset = alloca i64, align 8
  %dma = alloca i8, align 1
  %sge_len = alloca i64, align 8
  %sg_len = alloca i64, align 8
  %sg_idx = alloca i32, align 4
  %_a5 = alloca i64, align 8
  %_b6 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %_a7 = alloca i64, align 8
  %_b8 = alloca i64, align 8
  %tmp25 = alloca i64, align 8
  store ptr %sg, ptr %sg.addr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %mdata, ptr %mdata.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  store ptr %0, ptr %dst, align 8
  %1 = load ptr, ptr %ns.addr, align 8
  %lbasz = getelementptr inbounds %struct.NvmeNamespace, ptr %1, i32 0, i32 9
  %2 = load i64, ptr %lbasz, align 8
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %count, align 4
  store i64 0, ptr %offset, align 8
  %3 = load ptr, ptr %sg.addr, align 8
  %flags = getelementptr inbounds %struct.NvmeSg, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %flags, align 8
  %and = and i32 %4, 2
  %tobool = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %dma, align 1
  %5 = load i8, ptr %dma, align 1
  %tobool1 = trunc i8 %5 to i1
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load ptr, ptr %sg.addr, align 8
  %7 = getelementptr inbounds %struct.NvmeSg, ptr %6, i32 0, i32 1
  %size = getelementptr inbounds %struct.QEMUSGList, ptr %7, i32 0, i32 3
  %8 = load i64, ptr %size, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load ptr, ptr %sg.addr, align 8
  %10 = getelementptr inbounds %struct.NvmeSg, ptr %9, i32 0, i32 1
  %11 = getelementptr inbounds %struct.QEMUIOVector, ptr %10, i32 0, i32 2
  %size3 = getelementptr inbounds %struct.anon.2, ptr %11, i32 0, i32 1
  %12 = load i64, ptr %size3, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %8, %cond.true ], [ %12, %cond.false ]
  store i64 %cond, ptr %sg_len, align 8
  store i32 0, ptr %sg_idx, align 4
  %13 = load ptr, ptr %sg.addr, align 8
  %flags4 = getelementptr inbounds %struct.NvmeSg, ptr %13, i32 0, i32 0
  %14 = load i32, ptr %flags4, align 8
  %and5 = and i32 %14, 1
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  br label %if.end

if.else:                                          ; preds = %cond.end
  call void @__assert_fail(ptr noundef @.str.27, ptr noundef @.str.1, i32 noundef 748, ptr noundef @__PRETTY_FUNCTION__.nvme_sg_split) #12
  unreachable

if.end:                                           ; preds = %if.then
  br label %while.cond

while.cond:                                       ; preds = %if.end75, %if.end
  %15 = load i64, ptr %sg_len, align 8
  %tobool7 = icmp ne i64 %15, 0
  br i1 %tobool7, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %16 = load i8, ptr %dma, align 1
  %tobool8 = trunc i8 %16 to i1
  br i1 %tobool8, label %cond.true10, label %cond.false12

cond.true10:                                      ; preds = %while.body
  %17 = load ptr, ptr %sg.addr, align 8
  %18 = getelementptr inbounds %struct.NvmeSg, ptr %17, i32 0, i32 1
  %sg11 = getelementptr inbounds %struct.QEMUSGList, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %sg11, align 8
  %20 = load i32, ptr %sg_idx, align 4
  %idxprom = sext i32 %20 to i64
  %arrayidx = getelementptr %struct.ScatterGatherEntry, ptr %19, i64 %idxprom
  %len = getelementptr inbounds %struct.ScatterGatherEntry, ptr %arrayidx, i32 0, i32 1
  %21 = load i64, ptr %len, align 8
  br label %cond.end15

cond.false12:                                     ; preds = %while.body
  %22 = load ptr, ptr %sg.addr, align 8
  %23 = getelementptr inbounds %struct.NvmeSg, ptr %22, i32 0, i32 1
  %iov = getelementptr inbounds %struct.QEMUIOVector, ptr %23, i32 0, i32 0
  %24 = load ptr, ptr %iov, align 8
  %25 = load i32, ptr %sg_idx, align 4
  %idxprom13 = sext i32 %25 to i64
  %arrayidx14 = getelementptr %struct.iovec, ptr %24, i64 %idxprom13
  %iov_len = getelementptr inbounds %struct.iovec, ptr %arrayidx14, i32 0, i32 1
  %26 = load i64, ptr %iov_len, align 8
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false12, %cond.true10
  %cond16 = phi i64 [ %21, %cond.true10 ], [ %26, %cond.false12 ]
  store i64 %cond16, ptr %sge_len, align 8
  %27 = load i64, ptr %sg_len, align 8
  store i64 %27, ptr %_a5, align 8
  %28 = load i32, ptr %count, align 4
  %conv17 = zext i32 %28 to i64
  store i64 %conv17, ptr %_b6, align 8
  %29 = load i64, ptr %_a5, align 8
  %30 = load i64, ptr %_b6, align 8
  %cmp = icmp ult i64 %29, %30
  br i1 %cmp, label %cond.true19, label %cond.false20

cond.true19:                                      ; preds = %cond.end15
  %31 = load i64, ptr %_a5, align 8
  br label %cond.end21

cond.false20:                                     ; preds = %cond.end15
  %32 = load i64, ptr %_b6, align 8
  br label %cond.end21

cond.end21:                                       ; preds = %cond.false20, %cond.true19
  %cond22 = phi i64 [ %31, %cond.true19 ], [ %32, %cond.false20 ]
  store i64 %cond22, ptr %tmp, align 8
  %33 = load i64, ptr %tmp, align 8
  %conv23 = trunc i64 %33 to i32
  store i32 %conv23, ptr %trans_len, align 4
  %34 = load i32, ptr %trans_len, align 4
  %conv24 = zext i32 %34 to i64
  store i64 %conv24, ptr %_a7, align 8
  %35 = load i64, ptr %sge_len, align 8
  %36 = load i64, ptr %offset, align 8
  %sub = sub i64 %35, %36
  store i64 %sub, ptr %_b8, align 8
  %37 = load i64, ptr %_a7, align 8
  %38 = load i64, ptr %_b8, align 8
  %cmp26 = icmp ult i64 %37, %38
  br i1 %cmp26, label %cond.true28, label %cond.false29

cond.true28:                                      ; preds = %cond.end21
  %39 = load i64, ptr %_a7, align 8
  br label %cond.end30

cond.false29:                                     ; preds = %cond.end21
  %40 = load i64, ptr %_b8, align 8
  br label %cond.end30

cond.end30:                                       ; preds = %cond.false29, %cond.true28
  %cond31 = phi i64 [ %39, %cond.true28 ], [ %40, %cond.false29 ]
  store i64 %cond31, ptr %tmp25, align 8
  %41 = load i64, ptr %tmp25, align 8
  %conv32 = trunc i64 %41 to i32
  store i32 %conv32, ptr %trans_len, align 4
  %42 = load ptr, ptr %dst, align 8
  %tobool33 = icmp ne ptr %42, null
  br i1 %tobool33, label %if.then34, label %if.end47

if.then34:                                        ; preds = %cond.end30
  %43 = load i8, ptr %dma, align 1
  %tobool35 = trunc i8 %43 to i1
  br i1 %tobool35, label %if.then36, label %if.else41

if.then36:                                        ; preds = %if.then34
  %44 = load ptr, ptr %dst, align 8
  %45 = getelementptr inbounds %struct.NvmeSg, ptr %44, i32 0, i32 1
  %46 = load ptr, ptr %sg.addr, align 8
  %47 = getelementptr inbounds %struct.NvmeSg, ptr %46, i32 0, i32 1
  %sg37 = getelementptr inbounds %struct.QEMUSGList, ptr %47, i32 0, i32 0
  %48 = load ptr, ptr %sg37, align 8
  %49 = load i32, ptr %sg_idx, align 4
  %idxprom38 = sext i32 %49 to i64
  %arrayidx39 = getelementptr %struct.ScatterGatherEntry, ptr %48, i64 %idxprom38
  %base = getelementptr inbounds %struct.ScatterGatherEntry, ptr %arrayidx39, i32 0, i32 0
  %50 = load i64, ptr %base, align 8
  %51 = load i64, ptr %offset, align 8
  %add = add i64 %50, %51
  %52 = load i32, ptr %trans_len, align 4
  %conv40 = zext i32 %52 to i64
  call void @qemu_sglist_add(ptr noundef %45, i64 noundef %add, i64 noundef %conv40)
  br label %if.end46

if.else41:                                        ; preds = %if.then34
  %53 = load ptr, ptr %dst, align 8
  %54 = getelementptr inbounds %struct.NvmeSg, ptr %53, i32 0, i32 1
  %55 = load ptr, ptr %sg.addr, align 8
  %56 = getelementptr inbounds %struct.NvmeSg, ptr %55, i32 0, i32 1
  %iov42 = getelementptr inbounds %struct.QEMUIOVector, ptr %56, i32 0, i32 0
  %57 = load ptr, ptr %iov42, align 8
  %58 = load i32, ptr %sg_idx, align 4
  %idxprom43 = sext i32 %58 to i64
  %arrayidx44 = getelementptr %struct.iovec, ptr %57, i64 %idxprom43
  %iov_base = getelementptr inbounds %struct.iovec, ptr %arrayidx44, i32 0, i32 0
  %59 = load ptr, ptr %iov_base, align 8
  %60 = load i64, ptr %offset, align 8
  %add.ptr = getelementptr i8, ptr %59, i64 %60
  %61 = load i32, ptr %trans_len, align 4
  %conv45 = zext i32 %61 to i64
  call void @qemu_iovec_add(ptr noundef %54, ptr noundef %add.ptr, i64 noundef %conv45)
  br label %if.end46

if.end46:                                         ; preds = %if.else41, %if.then36
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %cond.end30
  %62 = load i32, ptr %trans_len, align 4
  %conv48 = zext i32 %62 to i64
  %63 = load i64, ptr %sg_len, align 8
  %sub49 = sub i64 %63, %conv48
  store i64 %sub49, ptr %sg_len, align 8
  %64 = load i32, ptr %trans_len, align 4
  %65 = load i32, ptr %count, align 4
  %sub50 = sub i32 %65, %64
  store i32 %sub50, ptr %count, align 4
  %66 = load i32, ptr %trans_len, align 4
  %conv51 = zext i32 %66 to i64
  %67 = load i64, ptr %offset, align 8
  %add52 = add i64 %67, %conv51
  store i64 %add52, ptr %offset, align 8
  %68 = load i32, ptr %count, align 4
  %cmp53 = icmp eq i32 %68, 0
  br i1 %cmp53, label %if.then55, label %if.end71

if.then55:                                        ; preds = %if.end47
  %69 = load ptr, ptr %dst, align 8
  %70 = load ptr, ptr %data.addr, align 8
  %cmp56 = icmp eq ptr %69, %70
  br i1 %cmp56, label %cond.true58, label %cond.false59

cond.true58:                                      ; preds = %if.then55
  %71 = load ptr, ptr %mdata.addr, align 8
  br label %cond.end60

cond.false59:                                     ; preds = %if.then55
  %72 = load ptr, ptr %data.addr, align 8
  br label %cond.end60

cond.end60:                                       ; preds = %cond.false59, %cond.true58
  %cond61 = phi ptr [ %71, %cond.true58 ], [ %72, %cond.false59 ]
  store ptr %cond61, ptr %dst, align 8
  %73 = load ptr, ptr %dst, align 8
  %74 = load ptr, ptr %data.addr, align 8
  %cmp62 = icmp eq ptr %73, %74
  br i1 %cmp62, label %cond.true64, label %cond.false66

cond.true64:                                      ; preds = %cond.end60
  %75 = load ptr, ptr %ns.addr, align 8
  %lbasz65 = getelementptr inbounds %struct.NvmeNamespace, ptr %75, i32 0, i32 9
  %76 = load i64, ptr %lbasz65, align 8
  br label %cond.end68

cond.false66:                                     ; preds = %cond.end60
  %77 = load ptr, ptr %ns.addr, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %77, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %78 = load i16, ptr %ms, align 8
  %conv67 = zext i16 %78 to i64
  br label %cond.end68

cond.end68:                                       ; preds = %cond.false66, %cond.true64
  %cond69 = phi i64 [ %76, %cond.true64 ], [ %conv67, %cond.false66 ]
  %conv70 = trunc i64 %cond69 to i32
  store i32 %conv70, ptr %count, align 4
  br label %if.end71

if.end71:                                         ; preds = %cond.end68, %if.end47
  %79 = load i64, ptr %sge_len, align 8
  %80 = load i64, ptr %offset, align 8
  %cmp72 = icmp eq i64 %79, %80
  br i1 %cmp72, label %if.then74, label %if.end75

if.then74:                                        ; preds = %if.end71
  store i64 0, ptr %offset, align 8
  %81 = load i32, ptr %sg_idx, align 4
  %inc = add i32 %81, 1
  store i32 %inc, ptr %sg_idx, align 4
  br label %if.end75

if.end75:                                         ; preds = %if.then74, %if.end71
  br label %while.cond, !llvm.loop !30

while.end:                                        ; preds = %while.cond
  ret void
}

declare ptr @dma_blk_write(ptr noundef, ptr noundef, i64 noundef, i32 noundef, ptr noundef, ptr noundef) #1

declare ptr @blk_aio_pwritev(ptr noundef, i64 noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_rw_cb(i16 noundef zeroext %cid, ptr noundef %blkname) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %blkname.addr = alloca ptr, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store ptr %blkname, ptr %blkname.addr, align 8
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load ptr, ptr %blkname.addr, align 8
  call void @_nocheck__trace_pci_nvme_rw_cb(i16 noundef zeroext %0, ptr noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @nvme_moff(ptr noundef %ns, i64 noundef %lba) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %lba.addr = alloca i64, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store i64 %lba, ptr %lba.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %moff = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 4
  %1 = load i64, ptr %moff, align 8
  %2 = load ptr, ptr %ns.addr, align 8
  %3 = load i64, ptr %lba.addr, align 8
  %call = call i64 @nvme_m2b(ptr noundef %2, i64 noundef %3)
  %add = add i64 %1, %call
  ret i64 %add
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_map_mdata(ptr noundef %n, i32 noundef %nlb, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %nlb.addr = alloca i32, align 4
  %req.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %len = alloca i64, align 8
  %status = alloca i16, align 2
  %sg = alloca %struct.NvmeSg, align 8
  store ptr %n, ptr %n.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %ns1, align 8
  store ptr %1, ptr %ns, align 8
  %2 = load ptr, ptr %ns, align 8
  %3 = load i32, ptr %nlb.addr, align 4
  %conv = zext i32 %3 to i64
  %call = call i64 @nvme_m2b(ptr noundef %2, i64 noundef %conv)
  store i64 %call, ptr %len, align 8
  %4 = load ptr, ptr %ns, align 8
  %call2 = call zeroext i1 @nvme_ns_ext(ptr noundef %4)
  br i1 %call2, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %ns, align 8
  %6 = load i32, ptr %nlb.addr, align 4
  %conv3 = zext i32 %6 to i64
  %call4 = call i64 @nvme_l2b(ptr noundef %5, i64 noundef %conv3)
  %7 = load i64, ptr %len, align 8
  %add = add i64 %7, %call4
  store i64 %add, ptr %len, align 8
  %8 = load ptr, ptr %n.addr, align 8
  %9 = load i64, ptr %len, align 8
  %10 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %10, i32 0, i32 6
  %call5 = call zeroext i16 @nvme_map_dptr(ptr noundef %8, ptr noundef %sg, i64 noundef %9, ptr noundef %cmd)
  store i16 %call5, ptr %status, align 2
  %11 = load i16, ptr %status, align 2
  %tobool = icmp ne i16 %11, 0
  br i1 %tobool, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %12 = load i16, ptr %status, align 2
  store i16 %12, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %if.then
  %13 = load ptr, ptr %n.addr, align 8
  %14 = load ptr, ptr %req.addr, align 8
  %sg7 = getelementptr inbounds %struct.NvmeRequest, ptr %14, i32 0, i32 8
  %flags = getelementptr inbounds %struct.NvmeSg, ptr %sg, i32 0, i32 0
  %15 = load i32, ptr %flags, align 8
  %and = and i32 %15, 2
  %tobool8 = icmp ne i32 %and, 0
  call void @nvme_sg_init(ptr noundef %13, ptr noundef %sg7, i1 noundef zeroext %tobool8)
  %16 = load ptr, ptr %ns, align 8
  %17 = load ptr, ptr %req.addr, align 8
  %sg9 = getelementptr inbounds %struct.NvmeRequest, ptr %17, i32 0, i32 8
  call void @nvme_sg_split(ptr noundef %sg, ptr noundef %16, ptr noundef null, ptr noundef %sg9)
  call void @nvme_sg_unmap(ptr noundef %sg)
  store i16 0, ptr %retval, align 2
  br label %return

if.end10:                                         ; preds = %entry
  %18 = load ptr, ptr %n.addr, align 8
  %19 = load ptr, ptr %req.addr, align 8
  %sg11 = getelementptr inbounds %struct.NvmeRequest, ptr %19, i32 0, i32 8
  %20 = load i64, ptr %len, align 8
  %21 = load ptr, ptr %req.addr, align 8
  %cmd12 = getelementptr inbounds %struct.NvmeRequest, ptr %21, i32 0, i32 6
  %call13 = call zeroext i16 @nvme_map_mptr(ptr noundef %18, ptr noundef %sg11, i64 noundef %20, ptr noundef %cmd12)
  store i16 %call13, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end10, %if.end, %if.then6
  %22 = load i16, ptr %retval, align 2
  ret i16 %22
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_blk_read(ptr noundef %blk, i64 noundef %offset, i32 noundef %align, ptr noundef %cb, ptr noundef %req) #0 {
entry:
  %blk.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %align.addr = alloca i32, align 4
  %cb.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  store ptr %blk, ptr %blk.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i32 %align, ptr %align.addr, align 4
  store ptr %cb, ptr %cb.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %sg = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 8
  %flags = getelementptr inbounds %struct.NvmeSg, ptr %sg, i32 0, i32 0
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.228, ptr noundef @.str.1, i32 noundef 1447, ptr noundef @__PRETTY_FUNCTION__.nvme_blk_read) #12
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load ptr, ptr %req.addr, align 8
  %sg1 = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 8
  %flags2 = getelementptr inbounds %struct.NvmeSg, ptr %sg1, i32 0, i32 0
  %3 = load i32, ptr %flags2, align 8
  %and3 = and i32 %3, 2
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.else7

if.then5:                                         ; preds = %if.end
  %4 = load ptr, ptr %blk.addr, align 8
  %5 = load ptr, ptr %req.addr, align 8
  %sg6 = getelementptr inbounds %struct.NvmeRequest, ptr %5, i32 0, i32 8
  %6 = getelementptr inbounds %struct.NvmeSg, ptr %sg6, i32 0, i32 1
  %7 = load i64, ptr %offset.addr, align 8
  %8 = load i32, ptr %align.addr, align 4
  %9 = load ptr, ptr %cb.addr, align 8
  %10 = load ptr, ptr %req.addr, align 8
  %call = call ptr @dma_blk_read(ptr noundef %4, ptr noundef %6, i64 noundef %7, i32 noundef %8, ptr noundef %9, ptr noundef %10)
  %11 = load ptr, ptr %req.addr, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %11, i32 0, i32 2
  store ptr %call, ptr %aiocb, align 8
  br label %if.end11

if.else7:                                         ; preds = %if.end
  %12 = load ptr, ptr %blk.addr, align 8
  %13 = load i64, ptr %offset.addr, align 8
  %14 = load ptr, ptr %req.addr, align 8
  %sg8 = getelementptr inbounds %struct.NvmeRequest, ptr %14, i32 0, i32 8
  %15 = getelementptr inbounds %struct.NvmeSg, ptr %sg8, i32 0, i32 1
  %16 = load ptr, ptr %cb.addr, align 8
  %17 = load ptr, ptr %req.addr, align 8
  %call9 = call ptr @blk_aio_preadv(ptr noundef %12, i64 noundef %13, ptr noundef %15, i32 noundef 0, ptr noundef %16, ptr noundef %17)
  %18 = load ptr, ptr %req.addr, align 8
  %aiocb10 = getelementptr inbounds %struct.NvmeRequest, ptr %18, i32 0, i32 2
  store ptr %call9, ptr %aiocb10, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.else7, %if.then5
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_rw_cb(i16 noundef zeroext %cid, ptr noundef %blkname) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %blkname.addr = alloca ptr, align 8
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store ptr %blkname, ptr %blkname.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_RW_CB_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load ptr, ptr %blkname.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.229, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, ptr noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %cid.addr, align 2
  %conv12 = zext i16 %7 to i32
  %8 = load ptr, ptr %blkname.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.230, i32 noundef %conv12, ptr noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

declare ptr @dma_blk_read(ptr noundef, ptr noundef, i64 noundef, i32 noundef, ptr noundef, ptr noundef) #1

declare ptr @blk_aio_preadv(ptr noundef, i64 noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_read(i16 noundef zeroext %cid, i32 noundef %nsid, i32 noundef %nlb, i64 noundef %count, i64 noundef %lba) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %nlb.addr = alloca i32, align 4
  %count.addr = alloca i64, align 8
  %lba.addr = alloca i64, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i32 %nlb, ptr %nlb.addr, align 4
  store i64 %count, ptr %count.addr, align 8
  store i64 %lba, ptr %lba.addr, align 8
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i32, ptr %nsid.addr, align 4
  %2 = load i32, ptr %nlb.addr, align 4
  %3 = load i64, ptr %count.addr, align 8
  %4 = load i64, ptr %lba.addr, align 8
  call void @_nocheck__trace_pci_nvme_read(i16 noundef zeroext %0, i32 noundef %1, i32 noundef %2, i64 noundef %3, i64 noundef %4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_check_zone_read(ptr noundef %ns, i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %zone = alloca ptr, align 8
  %bndry = alloca i64, align 8
  %end = alloca i64, align 8
  %status = alloca i16, align 2
  store ptr %ns, ptr %ns.addr, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load ptr, ptr %ns.addr, align 8
  %1 = load i64, ptr %slba.addr, align 8
  %call = call ptr @nvme_get_zone_by_slba(ptr noundef %0, i64 noundef %1)
  store ptr %call, ptr %zone, align 8
  %2 = load ptr, ptr %zone, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.35, ptr noundef @.str.1, i32 noundef 1883, ptr noundef @__PRETTY_FUNCTION__.nvme_check_zone_read) #12
  unreachable

if.end:                                           ; preds = %if.then
  %3 = load ptr, ptr %ns.addr, align 8
  %4 = load ptr, ptr %zone, align 8
  %call1 = call i64 @nvme_zone_rd_boundary(ptr noundef %3, ptr noundef %4)
  store i64 %call1, ptr %bndry, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i32, ptr %nlb.addr, align 4
  %conv = zext i32 %6 to i64
  %add = add i64 %5, %conv
  store i64 %add, ptr %end, align 8
  %7 = load ptr, ptr %zone, align 8
  %call2 = call zeroext i16 @nvme_check_zone_state_for_read(ptr noundef %7)
  store i16 %call2, ptr %status, align 2
  %8 = load i16, ptr %status, align 2
  %tobool3 = icmp ne i16 %8, 0
  br i1 %tobool3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.end
  br label %if.end23

if.else5:                                         ; preds = %if.end
  %9 = load i64, ptr %end, align 8
  %10 = load i64, ptr %bndry, align 8
  %cmp = icmp ugt i64 %9, %10
  %lnot = xor i1 %cmp, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %tobool9 = icmp ne i64 %conv8, 0
  br i1 %tobool9, label %if.then10, label %if.end22

if.then10:                                        ; preds = %if.else5
  %11 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %11, i32 0, i32 30
  %cross_zone_read = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 15
  %12 = load i8, ptr %cross_zone_read, align 2
  %tobool11 = trunc i8 %12 to i1
  br i1 %tobool11, label %if.else13, label %if.then12

if.then12:                                        ; preds = %if.then10
  store i16 440, ptr %status, align 2
  br label %if.end21

if.else13:                                        ; preds = %if.then10
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.else13
  %13 = load ptr, ptr %zone, align 8
  %incdec.ptr = getelementptr %struct.NvmeZone, ptr %13, i32 1
  store ptr %incdec.ptr, ptr %zone, align 8
  %14 = load ptr, ptr %zone, align 8
  %call14 = call zeroext i16 @nvme_check_zone_state_for_read(ptr noundef %14)
  store i16 %call14, ptr %status, align 2
  %15 = load i16, ptr %status, align 2
  %tobool15 = icmp ne i16 %15, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %do.body
  br label %do.end

if.end17:                                         ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end17
  %16 = load i64, ptr %end, align 8
  %17 = load ptr, ptr %ns.addr, align 8
  %18 = load ptr, ptr %zone, align 8
  %call18 = call i64 @nvme_zone_rd_boundary(ptr noundef %17, ptr noundef %18)
  %cmp19 = icmp ugt i64 %16, %call18
  br i1 %cmp19, label %do.body, label %do.end, !llvm.loop !31

do.end:                                           ; preds = %do.cond, %if.then16
  br label %if.end21

if.end21:                                         ; preds = %do.end, %if.then12
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.else5
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then4
  %19 = load i16, ptr %status, align 2
  ret i16 %19
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_zone_read_not_ok(i64 noundef %slba, i32 noundef %nlb, i16 noundef zeroext %status) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %status.addr = alloca i16, align 2
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  store i16 %status, ptr %status.addr, align 2
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i32, ptr %nlb.addr, align 4
  %2 = load i16, ptr %status.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_zone_read_not_ok(i64 noundef %0, i32 noundef %1, i16 noundef zeroext %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_check_dulbe(ptr noundef %ns, i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %ret = alloca i32, align 4
  %err = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  store ptr null, ptr %err, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %1 = load i64, ptr %slba.addr, align 8
  %2 = load i32, ptr %nlb.addr, align 4
  %call = call i32 @nvme_block_status_all(ptr noundef %0, i64 noundef %1, i32 noundef %2, i32 noundef 1)
  store i32 %call, ptr %ret, align 4
  %3 = load i32, ptr %ret, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.end2

if.then:                                          ; preds = %entry
  %4 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %5 = load i32, ptr %ret, align 4
  %sub = sub i32 0, %5
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %err, ptr noundef @.str.1, i32 noundef 1729, ptr noundef @__func__.nvme_check_dulbe, i32 noundef %sub, ptr noundef @.str.235)
  %6 = load ptr, ptr %err, align 8
  call void @error_report_err(ptr noundef %6)
  store i16 6, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %if.then
  store i16 647, ptr %retval, align 2
  br label %return

if.end2:                                          ; preds = %entry
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end2, %if.end, %if.then1
  %7 = load i16, ptr %retval, align 2
  ret i16 %7
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_read(i16 noundef zeroext %cid, i32 noundef %nsid, i32 noundef %nlb, i64 noundef %count, i64 noundef %lba) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %nlb.addr = alloca i32, align 4
  %count.addr = alloca i64, align 8
  %lba.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i32 %nlb, ptr %nlb.addr, align 4
  store i64 %count, ptr %count.addr, align 8
  store i64 %lba, ptr %lba.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_READ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i32, ptr %nsid.addr, align 4
  %7 = load i32, ptr %nlb.addr, align 4
  %8 = load i64, ptr %count.addr, align 8
  %9 = load i64, ptr %lba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.231, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %6, i32 noundef %7, i64 noundef %8, i64 noundef %9)
  br label %if.end

if.else:                                          ; preds = %if.then
  %10 = load i16, ptr %cid.addr, align 2
  %conv12 = zext i16 %10 to i32
  %11 = load i32, ptr %nsid.addr, align 4
  %12 = load i32, ptr %nlb.addr, align 4
  %13 = load i64, ptr %count.addr, align 8
  %14 = load i64, ptr %lba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.232, i32 noundef %conv12, i32 noundef %11, i32 noundef %12, i64 noundef %13, i64 noundef %14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @nvme_zone_rd_boundary(ptr noundef %ns, ptr noundef %zone) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  %0 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %0, i32 0, i32 0
  %zslba = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 5
  %1 = load i64, ptr %zslba, align 8
  %2 = load ptr, ptr %ns.addr, align 8
  %zone_size = getelementptr inbounds %struct.NvmeNamespace, ptr %2, i32 0, i32 24
  %3 = load i64, ptr %zone_size, align 8
  %add = add i64 %1, %3
  ret i64 %add
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_check_zone_state_for_read(ptr noundef %zone) #0 {
entry:
  %retval = alloca i16, align 2
  %zone.addr = alloca ptr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  %0 = load ptr, ptr %zone.addr, align 8
  %call = call i32 @nvme_get_zone_state(ptr noundef %0)
  switch i32 %call, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb
    i32 3, label %sw.bb
    i32 14, label %sw.bb
    i32 4, label %sw.bb
    i32 13, label %sw.bb
    i32 15, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry
  store i16 0, ptr %retval, align 2
  br label %return

sw.bb1:                                           ; preds = %entry
  %1 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %1, i32 0, i32 0
  %zslba = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 5
  %2 = load i64, ptr %zslba, align 8
  call void @trace_pci_nvme_err_zone_is_offline(i64 noundef %2)
  store i16 443, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.176, ptr noundef @.str.1, i32 noundef 1869, ptr noundef @__PRETTY_FUNCTION__.nvme_check_zone_state_for_read) #12
  unreachable

return:                                           ; preds = %sw.bb1, %sw.bb
  %3 = load i16, ptr %retval, align 2
  ret i16 %3
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_zone_read_not_ok(i64 noundef %slba, i32 noundef %nlb, i16 noundef zeroext %status) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %status.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  store i16 %status, ptr %status.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i32, ptr %nlb.addr, align 4
  %7 = load i16, ptr %status.addr, align 2
  %conv11 = zext i16 %7 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.233, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i64, ptr %slba.addr, align 8
  %9 = load i32, ptr %nlb.addr, align 4
  %10 = load i16, ptr %status.addr, align 2
  %conv12 = zext i16 %10 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.234, i64 noundef %8, i32 noundef %9, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_block_status_all(ptr noundef %ns, i64 noundef %slba, i32 noundef %nlb, i32 noundef %flags) #0 {
entry:
  %retval = alloca i32, align 4
  %ns.addr = alloca ptr, align 8
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %bs = alloca ptr, align 8
  %pnum = alloca i64, align 8
  %bytes = alloca i64, align 8
  %offset = alloca i64, align 8
  %ret = alloca i32, align 4
  store ptr %ns, ptr %ns.addr, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %ns.addr, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %1 = load ptr, ptr %blk, align 8
  %call = call ptr @blk_bs(ptr noundef %1)
  store ptr %call, ptr %bs, align 8
  store i64 0, ptr %pnum, align 8
  %2 = load ptr, ptr %ns.addr, align 8
  %3 = load i32, ptr %nlb.addr, align 4
  %conv = zext i32 %3 to i64
  %call1 = call i64 @nvme_l2b(ptr noundef %2, i64 noundef %conv)
  store i64 %call1, ptr %bytes, align 8
  %4 = load ptr, ptr %ns.addr, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %call2 = call i64 @nvme_l2b(ptr noundef %4, i64 noundef %5)
  store i64 %call2, ptr %offset, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %6 = load i64, ptr %pnum, align 8
  %7 = load i64, ptr %bytes, align 8
  %sub = sub i64 %7, %6
  store i64 %sub, ptr %bytes, align 8
  %8 = load ptr, ptr %bs, align 8
  %9 = load i64, ptr %offset, align 8
  %10 = load i64, ptr %bytes, align 8
  %call3 = call i32 @bdrv_block_status(ptr noundef %8, i64 noundef %9, i64 noundef %10, ptr noundef %pnum, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %ret, align 4
  %11 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %11, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %12 = load i32, ptr %ret, align 4
  store i32 %12, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.body
  %13 = load i64, ptr %offset, align 8
  %14 = load i64, ptr %bytes, align 8
  %15 = load i64, ptr %pnum, align 8
  %16 = load i32, ptr %ret, align 4
  %17 = load i32, ptr %ret, align 4
  %and = and i32 %17, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot, true
  call void @trace_pci_nvme_block_status(i64 noundef %13, i64 noundef %14, i64 noundef %15, i32 noundef %16, i1 noundef zeroext %lnot5)
  %18 = load i32, ptr %ret, align 4
  %19 = load i32, ptr %flags.addr, align 4
  %and6 = and i32 %18, %19
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end
  %20 = load i64, ptr %pnum, align 8
  %21 = load i64, ptr %offset, align 8
  %add = add i64 %21, %20
  store i64 %add, ptr %offset, align 8
  br label %do.cond

do.cond:                                          ; preds = %if.end9
  %22 = load i64, ptr %pnum, align 8
  %23 = load i64, ptr %bytes, align 8
  %cmp10 = icmp ne i64 %22, %23
  br i1 %cmp10, label %do.body, label %do.end, !llvm.loop !32

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %do.end, %if.then8, %if.then
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

declare ptr @blk_bs(ptr noundef) #1

declare i32 @bdrv_block_status(ptr noundef, i64 noundef, i64 noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_block_status(i64 noundef %offset, i64 noundef %bytes, i64 noundef %pnum, i32 noundef %ret, i1 noundef zeroext %zeroed) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %bytes.addr = alloca i64, align 8
  %pnum.addr = alloca i64, align 8
  %ret.addr = alloca i32, align 4
  %zeroed.addr = alloca i8, align 1
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %bytes, ptr %bytes.addr, align 8
  store i64 %pnum, ptr %pnum.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %frombool = zext i1 %zeroed to i8
  store i8 %frombool, ptr %zeroed.addr, align 1
  %0 = load i64, ptr %offset.addr, align 8
  %1 = load i64, ptr %bytes.addr, align 8
  %2 = load i64, ptr %pnum.addr, align 8
  %3 = load i32, ptr %ret.addr, align 4
  %4 = load i8, ptr %zeroed.addr, align 1
  %tobool = trunc i8 %4 to i1
  call void @_nocheck__trace_pci_nvme_block_status(i64 noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef %3, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_block_status(i64 noundef %offset, i64 noundef %bytes, i64 noundef %pnum, i32 noundef %ret, i1 noundef zeroext %zeroed) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %bytes.addr = alloca i64, align 8
  %pnum.addr = alloca i64, align 8
  %ret.addr = alloca i32, align 4
  %zeroed.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %bytes, ptr %bytes.addr, align 8
  store i64 %pnum, ptr %pnum.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %frombool = zext i1 %zeroed to i8
  store i8 %frombool, ptr %zeroed.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_BLOCK_STATUS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %offset.addr, align 8
  %6 = load i64, ptr %bytes.addr, align 8
  %7 = load i64, ptr %pnum.addr, align 8
  %8 = load i32, ptr %ret.addr, align 4
  %9 = load i8, ptr %zeroed.addr, align 1
  %tobool11 = trunc i8 %9 to i1
  %conv12 = zext i1 %tobool11 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.236, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6, i64 noundef %7, i32 noundef %8, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %10 = load i64, ptr %offset.addr, align 8
  %11 = load i64, ptr %bytes.addr, align 8
  %12 = load i64, ptr %pnum.addr, align 8
  %13 = load i32, ptr %ret.addr, align 4
  %14 = load i8, ptr %zeroed.addr, align 1
  %tobool13 = trunc i8 %14 to i1
  %conv14 = zext i1 %tobool13 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.237, i64 noundef %10, i64 noundef %11, i64 noundef %12, i32 noundef %13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_compare(i16 noundef zeroext %cid, i32 noundef %nsid, i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i32, ptr %nsid.addr, align 4
  %2 = load i64, ptr %slba.addr, align 8
  %3 = load i32, ptr %nlb.addr, align 4
  call void @_nocheck__trace_pci_nvme_compare(i16 noundef zeroext %0, i32 noundef %1, i64 noundef %2, i32 noundef %3)
  ret void
}

; Function Attrs: allocsize(0)
declare noalias ptr @g_malloc(i64 noundef) #9

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_compare_data_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %req = alloca ptr, align 8
  %n = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %blk = alloca ptr, align 8
  %acct = alloca ptr, align 8
  %stats = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %status = alloca i16, align 2
  %rw = alloca ptr, align 8
  %slba = alloca i64, align 8
  %nlb = alloca i32, align 4
  %mlen = alloca i64, align 8
  %offset = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %req, align 8
  %1 = load ptr, ptr %req, align 8
  %call = call ptr @nvme_ctrl(ptr noundef %1)
  store ptr %call, ptr %n, align 8
  %2 = load ptr, ptr %req, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %ns1, align 8
  store ptr %3, ptr %ns, align 8
  %4 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %4, i32 0, i32 1
  %blk2 = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %5 = load ptr, ptr %blk2, align 8
  store ptr %5, ptr %blk, align 8
  %6 = load ptr, ptr %req, align 8
  %acct3 = getelementptr inbounds %struct.NvmeRequest, ptr %6, i32 0, i32 7
  store ptr %acct3, ptr %acct, align 8
  %7 = load ptr, ptr %blk, align 8
  %call4 = call ptr @blk_get_stats(ptr noundef %7)
  store ptr %call4, ptr %stats, align 8
  %8 = load ptr, ptr %req, align 8
  %opaque5 = getelementptr inbounds %struct.NvmeRequest, ptr %8, i32 0, i32 4
  %9 = load ptr, ptr %opaque5, align 8
  store ptr %9, ptr %ctx, align 8
  store ptr null, ptr %buf, align 8
  %10 = load ptr, ptr %req, align 8
  %call6 = call zeroext i16 @nvme_cid(ptr noundef %10)
  call void @trace_pci_nvme_compare_data_cb(i16 noundef zeroext %call6)
  %11 = load i32, ptr %ret.addr, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %12 = load ptr, ptr %stats, align 8
  %13 = load ptr, ptr %acct, align 8
  call void @block_acct_failed(ptr noundef %12, ptr noundef %13)
  %14 = load ptr, ptr %req, align 8
  %15 = load i32, ptr %ret.addr, align 4
  call void @nvme_aio_err(ptr noundef %14, i32 noundef %15)
  br label %out

if.end:                                           ; preds = %entry
  %16 = load ptr, ptr %ctx, align 8
  %data = getelementptr inbounds %struct.nvme_compare_ctx, ptr %16, i32 0, i32 0
  %iov = getelementptr inbounds %struct.anon.38, ptr %data, i32 0, i32 0
  %17 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov, i32 0, i32 2
  %size = getelementptr inbounds %struct.anon.2, ptr %17, i32 0, i32 1
  %18 = load i64, ptr %size, align 8
  %call7 = call noalias ptr @g_malloc(i64 noundef %18) #14
  store ptr %call7, ptr %buf, align 8
  %19 = load ptr, ptr %n, align 8
  %20 = load ptr, ptr %buf, align 8
  %21 = load ptr, ptr %ctx, align 8
  %data8 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %21, i32 0, i32 0
  %iov9 = getelementptr inbounds %struct.anon.38, ptr %data8, i32 0, i32 0
  %22 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov9, i32 0, i32 2
  %size10 = getelementptr inbounds %struct.anon.2, ptr %22, i32 0, i32 1
  %23 = load i64, ptr %size10, align 8
  %conv = trunc i64 %23 to i32
  %24 = load ptr, ptr %req, align 8
  %call11 = call zeroext i16 @nvme_bounce_data(ptr noundef %19, ptr noundef %20, i32 noundef %conv, i32 noundef 0, ptr noundef %24)
  store i16 %call11, ptr %status, align 2
  %25 = load i16, ptr %status, align 2
  %tobool12 = icmp ne i16 %25, 0
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end
  %26 = load i16, ptr %status, align 2
  %27 = load ptr, ptr %req, align 8
  %status14 = getelementptr inbounds %struct.NvmeRequest, ptr %27, i32 0, i32 3
  store i16 %26, ptr %status14, align 8
  br label %out

if.end15:                                         ; preds = %if.end
  %28 = load ptr, ptr %buf, align 8
  %29 = load ptr, ptr %ctx, align 8
  %data16 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %29, i32 0, i32 0
  %bounce = getelementptr inbounds %struct.anon.38, ptr %data16, i32 0, i32 1
  %30 = load ptr, ptr %bounce, align 8
  %31 = load ptr, ptr %ctx, align 8
  %data17 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %31, i32 0, i32 0
  %iov18 = getelementptr inbounds %struct.anon.38, ptr %data17, i32 0, i32 0
  %32 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov18, i32 0, i32 2
  %size19 = getelementptr inbounds %struct.anon.2, ptr %32, i32 0, i32 1
  %33 = load i64, ptr %size19, align 8
  %call20 = call i32 @memcmp(ptr noundef %28, ptr noundef %30, i64 noundef %33) #16
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.end15
  %34 = load ptr, ptr %req, align 8
  %status23 = getelementptr inbounds %struct.NvmeRequest, ptr %34, i32 0, i32 3
  store i16 17029, ptr %status23, align 8
  br label %out

if.end24:                                         ; preds = %if.end15
  %35 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %35, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %36 = load i16, ptr %ms, align 8
  %tobool25 = icmp ne i16 %36, 0
  br i1 %tobool25, label %if.then26, label %if.end46

if.then26:                                        ; preds = %if.end24
  %37 = load ptr, ptr %req, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %37, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %38 = load ptr, ptr %rw, align 8
  %slba27 = getelementptr inbounds %struct.NvmeRwCmd, ptr %38, i32 0, i32 8
  %39 = load i64, ptr %slba27, align 1
  %call28 = call i64 @le64_to_cpu(i64 noundef %39)
  store i64 %call28, ptr %slba, align 8
  %40 = load ptr, ptr %rw, align 8
  %nlb29 = getelementptr inbounds %struct.NvmeRwCmd, ptr %40, i32 0, i32 9
  %41 = load i16, ptr %nlb29, align 1
  %call30 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %41)
  %conv31 = zext i16 %call30 to i32
  %add = add i32 %conv31, 1
  store i32 %add, ptr %nlb, align 4
  %42 = load ptr, ptr %ns, align 8
  %43 = load i32, ptr %nlb, align 4
  %conv32 = zext i32 %43 to i64
  %call33 = call i64 @nvme_m2b(ptr noundef %42, i64 noundef %conv32)
  store i64 %call33, ptr %mlen, align 8
  %44 = load ptr, ptr %ns, align 8
  %45 = load i64, ptr %slba, align 8
  %call34 = call i64 @nvme_moff(ptr noundef %44, i64 noundef %45)
  store i64 %call34, ptr %offset, align 8
  %46 = load i64, ptr %mlen, align 8
  %call35 = call noalias ptr @g_malloc(i64 noundef %46) #14
  %47 = load ptr, ptr %ctx, align 8
  %mdata = getelementptr inbounds %struct.nvme_compare_ctx, ptr %47, i32 0, i32 1
  %bounce36 = getelementptr inbounds %struct.anon.39, ptr %mdata, i32 0, i32 1
  store ptr %call35, ptr %bounce36, align 8
  %48 = load ptr, ptr %ctx, align 8
  %mdata37 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %48, i32 0, i32 1
  %iov38 = getelementptr inbounds %struct.anon.39, ptr %mdata37, i32 0, i32 0
  call void @qemu_iovec_init(ptr noundef %iov38, i32 noundef 1)
  %49 = load ptr, ptr %ctx, align 8
  %mdata39 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %49, i32 0, i32 1
  %iov40 = getelementptr inbounds %struct.anon.39, ptr %mdata39, i32 0, i32 0
  %50 = load ptr, ptr %ctx, align 8
  %mdata41 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %50, i32 0, i32 1
  %bounce42 = getelementptr inbounds %struct.anon.39, ptr %mdata41, i32 0, i32 1
  %51 = load ptr, ptr %bounce42, align 8
  %52 = load i64, ptr %mlen, align 8
  call void @qemu_iovec_add(ptr noundef %iov40, ptr noundef %51, i64 noundef %52)
  %53 = load ptr, ptr %blk, align 8
  %54 = load i64, ptr %offset, align 8
  %55 = load ptr, ptr %ctx, align 8
  %mdata43 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %55, i32 0, i32 1
  %iov44 = getelementptr inbounds %struct.anon.39, ptr %mdata43, i32 0, i32 0
  %56 = load ptr, ptr %req, align 8
  %call45 = call ptr @blk_aio_preadv(ptr noundef %53, i64 noundef %54, ptr noundef %iov44, i32 noundef 0, ptr noundef @nvme_compare_mdata_cb, ptr noundef %56)
  %57 = load ptr, ptr %req, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %57, i32 0, i32 2
  store ptr %call45, ptr %aiocb, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end46:                                         ; preds = %if.end24
  %58 = load ptr, ptr %stats, align 8
  %59 = load ptr, ptr %acct, align 8
  call void @block_acct_done(ptr noundef %58, ptr noundef %59)
  br label %out

out:                                              ; preds = %if.end46, %if.then22, %if.then13, %if.then
  %60 = load ptr, ptr %ctx, align 8
  %data47 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %60, i32 0, i32 0
  %iov48 = getelementptr inbounds %struct.anon.38, ptr %data47, i32 0, i32 0
  call void @qemu_iovec_destroy(ptr noundef %iov48)
  %61 = load ptr, ptr %ctx, align 8
  %data49 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %61, i32 0, i32 0
  %bounce50 = getelementptr inbounds %struct.anon.38, ptr %data49, i32 0, i32 1
  %62 = load ptr, ptr %bounce50, align 8
  call void @g_free(ptr noundef %62)
  %63 = load ptr, ptr %ctx, align 8
  call void @g_free(ptr noundef %63)
  %64 = load ptr, ptr %req, align 8
  %call51 = call ptr @nvme_cq(ptr noundef %64)
  %65 = load ptr, ptr %req, align 8
  call void @nvme_enqueue_req_completion(ptr noundef %call51, ptr noundef %65)
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %out, %if.then26
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %buf)
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_compare(i16 noundef zeroext %cid, i32 noundef %nsid, i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_COMPARE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i32, ptr %nsid.addr, align 4
  %7 = load i64, ptr %slba.addr, align 8
  %8 = load i32, ptr %nlb.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.238, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %6, i64 noundef %7, i32 noundef %8)
  br label %if.end

if.else:                                          ; preds = %if.then
  %9 = load i16, ptr %cid.addr, align 2
  %conv12 = zext i16 %9 to i32
  %10 = load i32, ptr %nsid.addr, align 4
  %11 = load i64, ptr %slba.addr, align 8
  %12 = load i32, ptr %nlb.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.239, i32 noundef %conv12, i32 noundef %10, i64 noundef %11, i32 noundef %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_compare_data_cb(i16 noundef zeroext %cid) #0 {
entry:
  %cid.addr = alloca i16, align 2
  store i16 %cid, ptr %cid.addr, align 2
  %0 = load i16, ptr %cid.addr, align 2
  call void @_nocheck__trace_pci_nvme_compare_data_cb(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #10

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_compare_mdata_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %n = alloca ptr, align 8
  %rw = alloca ptr, align 8
  %prinfo = alloca i8, align 1
  %apptag = alloca i16, align 2
  %appmask = alloca i16, align 2
  %reftag = alloca i64, align 8
  %cdw3 = alloca i64, align 8
  %ctx = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %blk = alloca ptr, align 8
  %acct = alloca ptr, align 8
  %stats = alloca ptr, align 8
  %status = alloca i16, align 2
  %slba = alloca i64, align 8
  %bufp = alloca ptr, align 8
  %mbufp = alloca ptr, align 8
  %end = alloca ptr, align 8
  %pil = alloca i16, align 2
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %req, align 8
  %1 = load ptr, ptr %req, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %ns1, align 8
  store ptr %2, ptr %ns, align 8
  %3 = load ptr, ptr %req, align 8
  %call = call ptr @nvme_ctrl(ptr noundef %3)
  store ptr %call, ptr %n, align 8
  %4 = load ptr, ptr %req, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %4, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %5 = load ptr, ptr %rw, align 8
  %control = getelementptr inbounds %struct.NvmeRwCmd, ptr %5, i32 0, i32 10
  %6 = load i16, ptr %control, align 1
  %call2 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %6)
  %conv = zext i16 %call2 to i32
  %shr = ashr i32 %conv, 10
  %and = and i32 %shr, 15
  %conv3 = trunc i32 %and to i8
  store i8 %conv3, ptr %prinfo, align 1
  %7 = load ptr, ptr %rw, align 8
  %apptag4 = getelementptr inbounds %struct.NvmeRwCmd, ptr %7, i32 0, i32 15
  %8 = load i16, ptr %apptag4, align 1
  %call5 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %8)
  store i16 %call5, ptr %apptag, align 2
  %9 = load ptr, ptr %rw, align 8
  %appmask6 = getelementptr inbounds %struct.NvmeRwCmd, ptr %9, i32 0, i32 16
  %10 = load i16, ptr %appmask6, align 1
  %call7 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %10)
  store i16 %call7, ptr %appmask, align 2
  %11 = load ptr, ptr %rw, align 8
  %reftag8 = getelementptr inbounds %struct.NvmeRwCmd, ptr %11, i32 0, i32 14
  %12 = load i32, ptr %reftag8, align 1
  %call9 = call i32 @le32_to_cpu(i32 noundef %12)
  %conv10 = zext i32 %call9 to i64
  store i64 %conv10, ptr %reftag, align 8
  %13 = load ptr, ptr %rw, align 8
  %cdw311 = getelementptr inbounds %struct.NvmeRwCmd, ptr %13, i32 0, i32 5
  %14 = load i32, ptr %cdw311, align 1
  %call12 = call i32 @le32_to_cpu(i32 noundef %14)
  %conv13 = zext i32 %call12 to i64
  store i64 %conv13, ptr %cdw3, align 8
  %15 = load ptr, ptr %req, align 8
  %opaque14 = getelementptr inbounds %struct.NvmeRequest, ptr %15, i32 0, i32 4
  %16 = load ptr, ptr %opaque14, align 8
  store ptr %16, ptr %ctx, align 8
  store ptr null, ptr %buf, align 8
  %17 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %17, i32 0, i32 1
  %blk15 = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %18 = load ptr, ptr %blk15, align 8
  store ptr %18, ptr %blk, align 8
  %19 = load ptr, ptr %req, align 8
  %acct16 = getelementptr inbounds %struct.NvmeRequest, ptr %19, i32 0, i32 7
  store ptr %acct16, ptr %acct, align 8
  %20 = load ptr, ptr %blk, align 8
  %call17 = call ptr @blk_get_stats(ptr noundef %20)
  store ptr %call17, ptr %stats, align 8
  store i16 0, ptr %status, align 2
  %21 = load i64, ptr %cdw3, align 8
  %shl = shl i64 %21, 32
  %22 = load i64, ptr %reftag, align 8
  %or = or i64 %22, %shl
  store i64 %or, ptr %reftag, align 8
  %23 = load ptr, ptr %req, align 8
  %call18 = call zeroext i16 @nvme_cid(ptr noundef %23)
  call void @trace_pci_nvme_compare_mdata_cb(i16 noundef zeroext %call18)
  %24 = load i32, ptr %ret.addr, align 4
  %tobool = icmp ne i32 %24, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %25 = load ptr, ptr %stats, align 8
  %26 = load ptr, ptr %acct, align 8
  call void @block_acct_failed(ptr noundef %25, ptr noundef %26)
  %27 = load ptr, ptr %req, align 8
  %28 = load i32, ptr %ret.addr, align 4
  call void @nvme_aio_err(ptr noundef %27, i32 noundef %28)
  br label %out

if.end:                                           ; preds = %entry
  %29 = load ptr, ptr %ctx, align 8
  %mdata = getelementptr inbounds %struct.nvme_compare_ctx, ptr %29, i32 0, i32 1
  %iov = getelementptr inbounds %struct.anon.39, ptr %mdata, i32 0, i32 0
  %30 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov, i32 0, i32 2
  %size = getelementptr inbounds %struct.anon.2, ptr %30, i32 0, i32 1
  %31 = load i64, ptr %size, align 8
  %call19 = call noalias ptr @g_malloc(i64 noundef %31) #14
  store ptr %call19, ptr %buf, align 8
  %32 = load ptr, ptr %n, align 8
  %33 = load ptr, ptr %buf, align 8
  %34 = load ptr, ptr %ctx, align 8
  %mdata20 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %34, i32 0, i32 1
  %iov21 = getelementptr inbounds %struct.anon.39, ptr %mdata20, i32 0, i32 0
  %35 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov21, i32 0, i32 2
  %size22 = getelementptr inbounds %struct.anon.2, ptr %35, i32 0, i32 1
  %36 = load i64, ptr %size22, align 8
  %conv23 = trunc i64 %36 to i32
  %37 = load ptr, ptr %req, align 8
  %call24 = call zeroext i16 @nvme_bounce_mdata(ptr noundef %32, ptr noundef %33, i32 noundef %conv23, i32 noundef 0, ptr noundef %37)
  store i16 %call24, ptr %status, align 2
  %38 = load i16, ptr %status, align 2
  %tobool25 = icmp ne i16 %38, 0
  br i1 %tobool25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %if.end
  %39 = load i16, ptr %status, align 2
  %40 = load ptr, ptr %req, align 8
  %status27 = getelementptr inbounds %struct.NvmeRequest, ptr %40, i32 0, i32 3
  store i16 %39, ptr %status27, align 8
  br label %out

if.end28:                                         ; preds = %if.end
  %41 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %41, i32 0, i32 5
  %dps = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 8
  %42 = load i8, ptr %dps, align 1
  %conv29 = zext i8 %42 to i32
  %and30 = and i32 %conv29, 7
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.then32, label %if.end90

if.then32:                                        ; preds = %if.end28
  %43 = load ptr, ptr %rw, align 8
  %slba33 = getelementptr inbounds %struct.NvmeRwCmd, ptr %43, i32 0, i32 8
  %44 = load i64, ptr %slba33, align 1
  %call34 = call i64 @le64_to_cpu(i64 noundef %44)
  store i64 %call34, ptr %slba, align 8
  %45 = load ptr, ptr %ctx, align 8
  %mdata35 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %45, i32 0, i32 1
  %bounce = getelementptr inbounds %struct.anon.39, ptr %mdata35, i32 0, i32 1
  %46 = load ptr, ptr %bounce, align 8
  store ptr %46, ptr %mbufp, align 8
  %47 = load ptr, ptr %mbufp, align 8
  %48 = load ptr, ptr %ctx, align 8
  %mdata36 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %48, i32 0, i32 1
  %iov37 = getelementptr inbounds %struct.anon.39, ptr %mdata36, i32 0, i32 0
  %49 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov37, i32 0, i32 2
  %size38 = getelementptr inbounds %struct.anon.2, ptr %49, i32 0, i32 1
  %50 = load i64, ptr %size38, align 8
  %add.ptr = getelementptr i8, ptr %47, i64 %50
  store ptr %add.ptr, ptr %end, align 8
  store i16 0, ptr %pil, align 2
  %51 = load ptr, ptr %ns, align 8
  %52 = load ptr, ptr %ctx, align 8
  %data = getelementptr inbounds %struct.nvme_compare_ctx, ptr %52, i32 0, i32 0
  %bounce39 = getelementptr inbounds %struct.anon.38, ptr %data, i32 0, i32 1
  %53 = load ptr, ptr %bounce39, align 8
  %54 = load ptr, ptr %ctx, align 8
  %data40 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %54, i32 0, i32 0
  %iov41 = getelementptr inbounds %struct.anon.38, ptr %data40, i32 0, i32 0
  %55 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov41, i32 0, i32 2
  %size42 = getelementptr inbounds %struct.anon.2, ptr %55, i32 0, i32 1
  %56 = load i64, ptr %size42, align 8
  %57 = load ptr, ptr %ctx, align 8
  %mdata43 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %57, i32 0, i32 1
  %bounce44 = getelementptr inbounds %struct.anon.39, ptr %mdata43, i32 0, i32 1
  %58 = load ptr, ptr %bounce44, align 8
  %59 = load ptr, ptr %ctx, align 8
  %mdata45 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %59, i32 0, i32 1
  %iov46 = getelementptr inbounds %struct.anon.39, ptr %mdata45, i32 0, i32 0
  %60 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov46, i32 0, i32 2
  %size47 = getelementptr inbounds %struct.anon.2, ptr %60, i32 0, i32 1
  %61 = load i64, ptr %size47, align 8
  %62 = load i8, ptr %prinfo, align 1
  %63 = load i64, ptr %slba, align 8
  %64 = load i16, ptr %apptag, align 2
  %65 = load i16, ptr %appmask, align 2
  %call48 = call zeroext i16 @nvme_dif_check(ptr noundef %51, ptr noundef %53, i64 noundef %56, ptr noundef %58, i64 noundef %61, i8 noundef zeroext %62, i64 noundef %63, i16 noundef zeroext %64, i16 noundef zeroext %65, ptr noundef %reftag)
  store i16 %call48, ptr %status, align 2
  %66 = load i16, ptr %status, align 2
  %tobool49 = icmp ne i16 %66, 0
  br i1 %tobool49, label %if.then50, label %if.end52

if.then50:                                        ; preds = %if.then32
  %67 = load i16, ptr %status, align 2
  %68 = load ptr, ptr %req, align 8
  %status51 = getelementptr inbounds %struct.NvmeRequest, ptr %68, i32 0, i32 3
  store i16 %67, ptr %status51, align 8
  br label %out

if.end52:                                         ; preds = %if.then32
  %69 = load ptr, ptr %ns, align 8
  %id_ns53 = getelementptr inbounds %struct.NvmeNamespace, ptr %69, i32 0, i32 5
  %dps54 = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns53, i32 0, i32 8
  %70 = load i8, ptr %dps54, align 1
  %conv55 = zext i8 %70 to i32
  %and56 = and i32 %conv55, 8
  %tobool57 = icmp ne i32 %and56, 0
  br i1 %tobool57, label %if.end62, label %if.then58

if.then58:                                        ; preds = %if.end52
  %71 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %71, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %72 = load i16, ptr %ms, align 8
  %conv59 = zext i16 %72 to i64
  %73 = load ptr, ptr %ns, align 8
  %call60 = call i64 @nvme_pi_tuple_size(ptr noundef %73)
  %sub = sub i64 %conv59, %call60
  %conv61 = trunc i64 %sub to i16
  store i16 %conv61, ptr %pil, align 2
  br label %if.end62

if.end62:                                         ; preds = %if.then58, %if.end52
  %74 = load ptr, ptr %buf, align 8
  store ptr %74, ptr %bufp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end62
  %75 = load ptr, ptr %mbufp, align 8
  %76 = load ptr, ptr %end, align 8
  %cmp = icmp ult ptr %75, %76
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %77 = load ptr, ptr %bufp, align 8
  %78 = load i16, ptr %pil, align 2
  %conv64 = sext i16 %78 to i32
  %idx.ext = sext i32 %conv64 to i64
  %add.ptr65 = getelementptr i8, ptr %77, i64 %idx.ext
  %79 = load ptr, ptr %mbufp, align 8
  %80 = load i16, ptr %pil, align 2
  %conv66 = sext i16 %80 to i32
  %idx.ext67 = sext i32 %conv66 to i64
  %add.ptr68 = getelementptr i8, ptr %79, i64 %idx.ext67
  %81 = load ptr, ptr %ns, align 8
  %lbaf69 = getelementptr inbounds %struct.NvmeNamespace, ptr %81, i32 0, i32 7
  %ms70 = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf69, i32 0, i32 0
  %82 = load i16, ptr %ms70, align 8
  %conv71 = zext i16 %82 to i32
  %83 = load i16, ptr %pil, align 2
  %conv72 = sext i16 %83 to i32
  %sub73 = sub i32 %conv71, %conv72
  %conv74 = sext i32 %sub73 to i64
  %call75 = call i32 @memcmp(ptr noundef %add.ptr65, ptr noundef %add.ptr68, i64 noundef %conv74) #16
  %tobool76 = icmp ne i32 %call75, 0
  br i1 %tobool76, label %if.then77, label %if.end79

if.then77:                                        ; preds = %for.body
  %84 = load ptr, ptr %req, align 8
  %status78 = getelementptr inbounds %struct.NvmeRequest, ptr %84, i32 0, i32 3
  store i16 17029, ptr %status78, align 8
  br label %out

if.end79:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end79
  %85 = load ptr, ptr %ns, align 8
  %lbaf80 = getelementptr inbounds %struct.NvmeNamespace, ptr %85, i32 0, i32 7
  %ms81 = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf80, i32 0, i32 0
  %86 = load i16, ptr %ms81, align 8
  %conv82 = zext i16 %86 to i32
  %87 = load ptr, ptr %bufp, align 8
  %idx.ext83 = sext i32 %conv82 to i64
  %add.ptr84 = getelementptr i8, ptr %87, i64 %idx.ext83
  store ptr %add.ptr84, ptr %bufp, align 8
  %88 = load ptr, ptr %ns, align 8
  %lbaf85 = getelementptr inbounds %struct.NvmeNamespace, ptr %88, i32 0, i32 7
  %ms86 = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf85, i32 0, i32 0
  %89 = load i16, ptr %ms86, align 8
  %conv87 = zext i16 %89 to i32
  %90 = load ptr, ptr %mbufp, align 8
  %idx.ext88 = sext i32 %conv87 to i64
  %add.ptr89 = getelementptr i8, ptr %90, i64 %idx.ext88
  store ptr %add.ptr89, ptr %mbufp, align 8
  br label %for.cond, !llvm.loop !33

for.end:                                          ; preds = %for.cond
  br label %out

if.end90:                                         ; preds = %if.end28
  %91 = load ptr, ptr %buf, align 8
  %92 = load ptr, ptr %ctx, align 8
  %mdata91 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %92, i32 0, i32 1
  %bounce92 = getelementptr inbounds %struct.anon.39, ptr %mdata91, i32 0, i32 1
  %93 = load ptr, ptr %bounce92, align 8
  %94 = load ptr, ptr %ctx, align 8
  %mdata93 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %94, i32 0, i32 1
  %iov94 = getelementptr inbounds %struct.anon.39, ptr %mdata93, i32 0, i32 0
  %95 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov94, i32 0, i32 2
  %size95 = getelementptr inbounds %struct.anon.2, ptr %95, i32 0, i32 1
  %96 = load i64, ptr %size95, align 8
  %call96 = call i32 @memcmp(ptr noundef %91, ptr noundef %93, i64 noundef %96) #16
  %tobool97 = icmp ne i32 %call96, 0
  br i1 %tobool97, label %if.then98, label %if.end100

if.then98:                                        ; preds = %if.end90
  %97 = load ptr, ptr %req, align 8
  %status99 = getelementptr inbounds %struct.NvmeRequest, ptr %97, i32 0, i32 3
  store i16 17029, ptr %status99, align 8
  br label %out

if.end100:                                        ; preds = %if.end90
  %98 = load ptr, ptr %stats, align 8
  %99 = load ptr, ptr %acct, align 8
  call void @block_acct_done(ptr noundef %98, ptr noundef %99)
  br label %out

out:                                              ; preds = %if.end100, %if.then98, %for.end, %if.then77, %if.then50, %if.then26, %if.then
  %100 = load ptr, ptr %ctx, align 8
  %data101 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %100, i32 0, i32 0
  %iov102 = getelementptr inbounds %struct.anon.38, ptr %data101, i32 0, i32 0
  call void @qemu_iovec_destroy(ptr noundef %iov102)
  %101 = load ptr, ptr %ctx, align 8
  %data103 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %101, i32 0, i32 0
  %bounce104 = getelementptr inbounds %struct.anon.38, ptr %data103, i32 0, i32 1
  %102 = load ptr, ptr %bounce104, align 8
  call void @g_free(ptr noundef %102)
  %103 = load ptr, ptr %ctx, align 8
  %mdata105 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %103, i32 0, i32 1
  %iov106 = getelementptr inbounds %struct.anon.39, ptr %mdata105, i32 0, i32 0
  call void @qemu_iovec_destroy(ptr noundef %iov106)
  %104 = load ptr, ptr %ctx, align 8
  %mdata107 = getelementptr inbounds %struct.nvme_compare_ctx, ptr %104, i32 0, i32 1
  %bounce108 = getelementptr inbounds %struct.anon.39, ptr %mdata107, i32 0, i32 1
  %105 = load ptr, ptr %bounce108, align 8
  call void @g_free(ptr noundef %105)
  %106 = load ptr, ptr %ctx, align 8
  call void @g_free(ptr noundef %106)
  %107 = load ptr, ptr %req, align 8
  %call109 = call ptr @nvme_cq(ptr noundef %107)
  %108 = load ptr, ptr %req, align 8
  call void @nvme_enqueue_req_completion(ptr noundef %call109, ptr noundef %108)
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %buf)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_compare_data_cb(i16 noundef zeroext %cid) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_COMPARE_DATA_CB_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.240, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %cid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.241, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_compare_mdata_cb(i16 noundef zeroext %cid) #0 {
entry:
  %cid.addr = alloca i16, align 2
  store i16 %cid, ptr %cid.addr, align 2
  %0 = load i16, ptr %cid.addr, align 2
  call void @_nocheck__trace_pci_nvme_compare_mdata_cb(i16 noundef zeroext %0)
  ret void
}

declare zeroext i16 @nvme_dif_check(ptr noundef, ptr noundef, i64 noundef, ptr noundef, i64 noundef, i8 noundef zeroext, i64 noundef, i16 noundef zeroext, i16 noundef zeroext, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_compare_mdata_cb(i16 noundef zeroext %cid) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_COMPARE_MDATA_CB_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.242, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %cid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.243, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_dsm(i32 noundef %nr, i32 noundef %attr) #0 {
entry:
  %nr.addr = alloca i32, align 4
  %attr.addr = alloca i32, align 4
  store i32 %nr, ptr %nr.addr, align 4
  store i32 %attr, ptr %attr.addr, align 4
  %0 = load i32, ptr %nr.addr, align 4
  %1 = load i32, ptr %attr.addr, align 4
  call void @_nocheck__trace_pci_nvme_dsm(i32 noundef %0, i32 noundef %1)
  ret void
}

declare ptr @blk_aio_get(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_h2c(ptr noundef %n, ptr noundef %ptr, i32 noundef %len, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %req.addr = alloca ptr, align 8
  %status = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %sg = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 8
  %2 = load i32, ptr %len.addr, align 4
  %conv = zext i32 %2 to i64
  %3 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 6
  %call = call zeroext i16 @nvme_map_dptr(ptr noundef %0, ptr noundef %sg, i64 noundef %conv, ptr noundef %cmd)
  store i16 %call, ptr %status, align 2
  %4 = load i16, ptr %status, align 2
  %tobool = icmp ne i16 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i16, ptr %status, align 2
  store i16 %5, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %n.addr, align 8
  %7 = load ptr, ptr %req.addr, align 8
  %sg1 = getelementptr inbounds %struct.NvmeRequest, ptr %7, i32 0, i32 8
  %8 = load ptr, ptr %ptr.addr, align 8
  %9 = load i32, ptr %len.addr, align 4
  %call2 = call zeroext i16 @nvme_tx(ptr noundef %6, ptr noundef %sg1, ptr noundef %8, i32 noundef %9, i32 noundef 0)
  store i16 %call2, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i16, ptr %retval, align 2
  ret i16 %10
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_dsm_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %iocb = alloca ptr, align 8
  %req = alloca ptr, align 8
  %n = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %range = alloca ptr, align 8
  %slba = alloca i64, align 8
  %nlb = alloca i32, align 4
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %iocb, align 8
  %1 = load ptr, ptr %iocb, align 8
  %req1 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %req1, align 8
  store ptr %2, ptr %req, align 8
  %3 = load ptr, ptr %req, align 8
  %call = call ptr @nvme_ctrl(ptr noundef %3)
  store ptr %call, ptr %n, align 8
  %4 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %ns2, align 8
  store ptr %5, ptr %ns, align 8
  %6 = load ptr, ptr %iocb, align 8
  %ret3 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %6, i32 0, i32 3
  %7 = load i32, ptr %ret3, align 8
  %cmp = icmp slt i32 %7, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %done

if.else:                                          ; preds = %entry
  %8 = load i32, ptr %ret.addr, align 4
  %cmp4 = icmp slt i32 %8, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %9 = load i32, ptr %ret.addr, align 4
  %10 = load ptr, ptr %iocb, align 8
  %ret6 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %10, i32 0, i32 3
  store i32 %9, ptr %ret6, align 8
  br label %done

if.end:                                           ; preds = %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end
  br label %next

next:                                             ; preds = %if.then22, %if.then18, %if.end7
  %11 = load ptr, ptr %iocb, align 8
  %idx = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %11, i32 0, i32 6
  %12 = load i32, ptr %idx, align 4
  %13 = load ptr, ptr %iocb, align 8
  %nr = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %13, i32 0, i32 5
  %14 = load i32, ptr %nr, align 8
  %cmp8 = icmp eq i32 %12, %14
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %next
  br label %done

if.end10:                                         ; preds = %next
  %15 = load ptr, ptr %iocb, align 8
  %range11 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %15, i32 0, i32 4
  %16 = load ptr, ptr %range11, align 8
  %17 = load ptr, ptr %iocb, align 8
  %idx12 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %17, i32 0, i32 6
  %18 = load i32, ptr %idx12, align 4
  %inc = add i32 %18, 1
  store i32 %inc, ptr %idx12, align 4
  %idxprom = zext i32 %18 to i64
  %arrayidx = getelementptr %struct.NvmeDsmRange, ptr %16, i64 %idxprom
  store ptr %arrayidx, ptr %range, align 8
  %19 = load ptr, ptr %range, align 8
  %slba13 = getelementptr inbounds %struct.NvmeDsmRange, ptr %19, i32 0, i32 2
  %20 = load i64, ptr %slba13, align 1
  %call14 = call i64 @le64_to_cpu(i64 noundef %20)
  store i64 %call14, ptr %slba, align 8
  %21 = load ptr, ptr %range, align 8
  %nlb15 = getelementptr inbounds %struct.NvmeDsmRange, ptr %21, i32 0, i32 1
  %22 = load i32, ptr %nlb15, align 1
  %call16 = call i32 @le32_to_cpu(i32 noundef %22)
  store i32 %call16, ptr %nlb, align 4
  %23 = load i64, ptr %slba, align 8
  %24 = load i32, ptr %nlb, align 4
  call void @trace_pci_nvme_dsm_deallocate(i64 noundef %23, i32 noundef %24)
  %25 = load i32, ptr %nlb, align 4
  %26 = load ptr, ptr %n, align 8
  %dmrsl = getelementptr inbounds %struct.NvmeCtrl, ptr %26, i32 0, i32 31
  %27 = load i32, ptr %dmrsl, align 4
  %cmp17 = icmp ugt i32 %25, %27
  br i1 %cmp17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end10
  %28 = load i32, ptr %nlb, align 4
  %29 = load ptr, ptr %n, align 8
  %dmrsl19 = getelementptr inbounds %struct.NvmeCtrl, ptr %29, i32 0, i32 31
  %30 = load i32, ptr %dmrsl19, align 4
  call void @trace_pci_nvme_dsm_single_range_limit_exceeded(i32 noundef %28, i32 noundef %30)
  br label %next

if.end20:                                         ; preds = %if.end10
  %31 = load ptr, ptr %ns, align 8
  %32 = load i64, ptr %slba, align 8
  %33 = load i32, ptr %nlb, align 4
  %call21 = call zeroext i16 @nvme_check_bounds(ptr noundef %31, i64 noundef %32, i32 noundef %33)
  %tobool = icmp ne i16 %call21, 0
  br i1 %tobool, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end20
  %34 = load i64, ptr %slba, align 8
  %35 = load i32, ptr %nlb, align 4
  %conv = zext i32 %35 to i64
  %36 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %36, i32 0, i32 5
  %nsze = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 0
  %37 = load i64, ptr %nsze, align 8
  call void @trace_pci_nvme_err_invalid_lba_range(i64 noundef %34, i64 noundef %conv, i64 noundef %37)
  br label %next

if.end23:                                         ; preds = %if.end20
  %38 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %38, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %39 = load ptr, ptr %blk, align 8
  %40 = load ptr, ptr %ns, align 8
  %41 = load i64, ptr %slba, align 8
  %call24 = call i64 @nvme_l2b(ptr noundef %40, i64 noundef %41)
  %42 = load ptr, ptr %ns, align 8
  %43 = load i32, ptr %nlb, align 4
  %conv25 = zext i32 %43 to i64
  %call26 = call i64 @nvme_l2b(ptr noundef %42, i64 noundef %conv25)
  %44 = load ptr, ptr %iocb, align 8
  %call27 = call ptr @blk_aio_pdiscard(ptr noundef %39, i64 noundef %call24, i64 noundef %call26, ptr noundef @nvme_dsm_md_cb, ptr noundef %44)
  %45 = load ptr, ptr %iocb, align 8
  %aiocb = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %45, i32 0, i32 1
  store ptr %call27, ptr %aiocb, align 8
  br label %return

done:                                             ; preds = %if.then9, %if.then5, %if.then
  %46 = load ptr, ptr %iocb, align 8
  %aiocb28 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %46, i32 0, i32 1
  store ptr null, ptr %aiocb28, align 8
  %47 = load ptr, ptr %iocb, align 8
  %common = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %47, i32 0, i32 0
  %cb = getelementptr inbounds %struct.BlockAIOCB, ptr %common, i32 0, i32 2
  %48 = load ptr, ptr %cb, align 8
  %49 = load ptr, ptr %iocb, align 8
  %common29 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %49, i32 0, i32 0
  %opaque30 = getelementptr inbounds %struct.BlockAIOCB, ptr %common29, i32 0, i32 3
  %50 = load ptr, ptr %opaque30, align 8
  %51 = load ptr, ptr %iocb, align 8
  %ret31 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %51, i32 0, i32 3
  %52 = load i32, ptr %ret31, align 8
  call void %48(ptr noundef %50, i32 noundef %52)
  %53 = load ptr, ptr %iocb, align 8
  call void @qemu_aio_unref(ptr noundef %53)
  br label %return

return:                                           ; preds = %done, %if.end23
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_dsm(i32 noundef %nr, i32 noundef %attr) #0 {
entry:
  %nr.addr = alloca i32, align 4
  %attr.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %nr, ptr %nr.addr, align 4
  store i32 %attr, ptr %attr.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_DSM_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %nr.addr, align 4
  %6 = load i32, ptr %attr.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.244, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5, i32 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i32, ptr %nr.addr, align 4
  %8 = load i32, ptr %attr.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.245, i32 noundef %7, i32 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_dsm_cancel(ptr noundef %aiocb) #0 {
entry:
  %aiocb.addr = alloca ptr, align 8
  %iocb = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  store ptr %aiocb, ptr %aiocb.addr, align 8
  %0 = load ptr, ptr %aiocb.addr, align 8
  store ptr %0, ptr %__mptr, align 8
  %1 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 0
  store ptr %add.ptr, ptr %tmp, align 8
  %2 = load ptr, ptr %tmp, align 8
  store ptr %2, ptr %iocb, align 8
  %3 = load ptr, ptr %iocb, align 8
  %nr = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %3, i32 0, i32 5
  %4 = load i32, ptr %nr, align 8
  %5 = load ptr, ptr %iocb, align 8
  %idx = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %5, i32 0, i32 6
  store i32 %4, ptr %idx, align 4
  %6 = load ptr, ptr %iocb, align 8
  %ret = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %6, i32 0, i32 3
  store i32 -125, ptr %ret, align 8
  %7 = load ptr, ptr %iocb, align 8
  %aiocb1 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %aiocb1, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %9 = load ptr, ptr %iocb, align 8
  %aiocb2 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %aiocb2, align 8
  call void @blk_aio_cancel_async(ptr noundef %10)
  %11 = load ptr, ptr %iocb, align 8
  %aiocb3 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %11, i32 0, i32 1
  store ptr null, ptr %aiocb3, align 8
  br label %if.end8

if.else:                                          ; preds = %entry
  %12 = load ptr, ptr %iocb, align 8
  %idx4 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %12, i32 0, i32 6
  %13 = load i32, ptr %idx4, align 4
  %14 = load ptr, ptr %iocb, align 8
  %nr5 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %14, i32 0, i32 5
  %15 = load i32, ptr %nr5, align 8
  %cmp = icmp eq i32 %13, %15
  br i1 %cmp, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  br label %if.end

if.else7:                                         ; preds = %if.else
  call void @__assert_fail(ptr noundef @.str.246, ptr noundef @.str.1, i32 noundef 2496, ptr noundef @__PRETTY_FUNCTION__.nvme_dsm_cancel) #12
  unreachable

if.end:                                           ; preds = %if.then6
  br label %if.end8

if.end8:                                          ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_dsm_deallocate(i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i32, ptr %nlb.addr, align 4
  call void @_nocheck__trace_pci_nvme_dsm_deallocate(i64 noundef %0, i32 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_dsm_single_range_limit_exceeded(i32 noundef %nlb, i32 noundef %dmrsl) #0 {
entry:
  %nlb.addr = alloca i32, align 4
  %dmrsl.addr = alloca i32, align 4
  store i32 %nlb, ptr %nlb.addr, align 4
  store i32 %dmrsl, ptr %dmrsl.addr, align 4
  %0 = load i32, ptr %nlb.addr, align 4
  %1 = load i32, ptr %dmrsl.addr, align 4
  call void @_nocheck__trace_pci_nvme_dsm_single_range_limit_exceeded(i32 noundef %0, i32 noundef %1)
  ret void
}

declare ptr @blk_aio_pdiscard(ptr noundef, i64 noundef, i64 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_dsm_md_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %iocb = alloca ptr, align 8
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %range = alloca ptr, align 8
  %slba = alloca i64, align 8
  %nlb = alloca i32, align 4
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %iocb, align 8
  %1 = load ptr, ptr %iocb, align 8
  %req1 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %req1, align 8
  store ptr %2, ptr %req, align 8
  %3 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %ns2, align 8
  store ptr %4, ptr %ns, align 8
  %5 = load i32, ptr %ret.addr, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load ptr, ptr %iocb, align 8
  %ret3 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %6, i32 0, i32 3
  %7 = load i32, ptr %ret3, align 8
  %cmp4 = icmp slt i32 %7, 0
  br i1 %cmp4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %8 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %8, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %9 = load i16, ptr %ms, align 8
  %tobool = icmp ne i16 %9, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false5, %lor.lhs.false, %entry
  br label %done

if.end:                                           ; preds = %lor.lhs.false5
  %10 = load ptr, ptr %iocb, align 8
  %range6 = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %range6, align 8
  %12 = load ptr, ptr %iocb, align 8
  %idx = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %12, i32 0, i32 6
  %13 = load i32, ptr %idx, align 4
  %sub = sub i32 %13, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr %struct.NvmeDsmRange, ptr %11, i64 %idxprom
  store ptr %arrayidx, ptr %range, align 8
  %14 = load ptr, ptr %range, align 8
  %slba7 = getelementptr inbounds %struct.NvmeDsmRange, ptr %14, i32 0, i32 2
  %15 = load i64, ptr %slba7, align 1
  %call = call i64 @le64_to_cpu(i64 noundef %15)
  store i64 %call, ptr %slba, align 8
  %16 = load ptr, ptr %range, align 8
  %nlb8 = getelementptr inbounds %struct.NvmeDsmRange, ptr %16, i32 0, i32 1
  %17 = load i32, ptr %nlb8, align 1
  %call9 = call i32 @le32_to_cpu(i32 noundef %17)
  store i32 %call9, ptr %nlb, align 4
  %18 = load ptr, ptr %ns, align 8
  %19 = load i64, ptr %slba, align 8
  %20 = load i32, ptr %nlb, align 4
  %call10 = call i32 @nvme_block_status_all(ptr noundef %18, i64 noundef %19, i32 noundef %20, i32 noundef 2)
  store i32 %call10, ptr %ret.addr, align 4
  %21 = load i32, ptr %ret.addr, align 4
  %tobool11 = icmp ne i32 %21, 0
  br i1 %tobool11, label %if.then12, label %if.end16

if.then12:                                        ; preds = %if.end
  %22 = load i32, ptr %ret.addr, align 4
  %cmp13 = icmp slt i32 %22, 0
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.then12
  br label %done

if.end15:                                         ; preds = %if.then12
  %23 = load ptr, ptr %iocb, align 8
  call void @nvme_dsm_cb(ptr noundef %23, i32 noundef 0)
  br label %return

if.end16:                                         ; preds = %if.end
  %24 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %24, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %25 = load ptr, ptr %blk, align 8
  %26 = load ptr, ptr %ns, align 8
  %27 = load i64, ptr %slba, align 8
  %call17 = call i64 @nvme_moff(ptr noundef %26, i64 noundef %27)
  %28 = load ptr, ptr %ns, align 8
  %29 = load i32, ptr %nlb, align 4
  %conv = zext i32 %29 to i64
  %call18 = call i64 @nvme_m2b(ptr noundef %28, i64 noundef %conv)
  %30 = load ptr, ptr %iocb, align 8
  %call19 = call ptr @blk_aio_pwrite_zeroes(ptr noundef %25, i64 noundef %call17, i64 noundef %call18, i32 noundef 4, ptr noundef @nvme_dsm_cb, ptr noundef %30)
  %31 = load ptr, ptr %iocb, align 8
  %aiocb = getelementptr inbounds %struct.NvmeDSMAIOCB, ptr %31, i32 0, i32 1
  store ptr %call19, ptr %aiocb, align 8
  br label %return

done:                                             ; preds = %if.then14, %if.then
  %32 = load ptr, ptr %iocb, align 8
  %33 = load i32, ptr %ret.addr, align 4
  call void @nvme_dsm_cb(ptr noundef %32, i32 noundef %33)
  br label %return

return:                                           ; preds = %done, %if.end16, %if.end15
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_dsm_deallocate(i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_DSM_DEALLOCATE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i32, ptr %nlb.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.247, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %slba.addr, align 8
  %8 = load i32, ptr %nlb.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.248, i64 noundef %7, i32 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_dsm_single_range_limit_exceeded(i32 noundef %nlb, i32 noundef %dmrsl) #0 {
entry:
  %nlb.addr = alloca i32, align 4
  %dmrsl.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  store i32 %dmrsl, ptr %dmrsl.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_DSM_SINGLE_RANGE_LIMIT_EXCEEDED_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %nlb.addr, align 4
  %6 = load i32, ptr %dmrsl.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.249, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5, i32 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i32, ptr %nlb.addr, align 4
  %8 = load i32, ptr %dmrsl.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.250, i32 noundef %7, i32 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_verify(i16 noundef zeroext %cid, i32 noundef %nsid, i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i32, ptr %nsid.addr, align 4
  %2 = load i64, ptr %slba.addr, align 8
  %3 = load i32, ptr %nlb.addr, align 4
  call void @_nocheck__trace_pci_nvme_verify(i16 noundef zeroext %0, i32 noundef %1, i64 noundef %2, i32 noundef %3)
  ret void
}

declare zeroext i16 @nvme_check_prinfo(ptr noundef, i8 noundef zeroext, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_verify_mdata_in_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %ctx = alloca ptr, align 8
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %rw = alloca ptr, align 8
  %slba = alloca i64, align 8
  %nlb = alloca i32, align 4
  %mlen = alloca i64, align 8
  %offset = alloca i64, align 8
  %blk = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %ctx, align 8
  %1 = load ptr, ptr %ctx, align 8
  %req1 = getelementptr inbounds %struct.NvmeBounceContext, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %req1, align 8
  store ptr %2, ptr %req, align 8
  %3 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %ns2, align 8
  store ptr %4, ptr %ns, align 8
  %5 = load ptr, ptr %req, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %5, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %6 = load ptr, ptr %rw, align 8
  %slba3 = getelementptr inbounds %struct.NvmeRwCmd, ptr %6, i32 0, i32 8
  %7 = load i64, ptr %slba3, align 1
  %call = call i64 @le64_to_cpu(i64 noundef %7)
  store i64 %call, ptr %slba, align 8
  %8 = load ptr, ptr %rw, align 8
  %nlb4 = getelementptr inbounds %struct.NvmeRwCmd, ptr %8, i32 0, i32 9
  %9 = load i16, ptr %nlb4, align 1
  %call5 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %9)
  %conv = zext i16 %call5 to i32
  %add = add i32 %conv, 1
  store i32 %add, ptr %nlb, align 4
  %10 = load ptr, ptr %ns, align 8
  %11 = load i32, ptr %nlb, align 4
  %conv6 = zext i32 %11 to i64
  %call7 = call i64 @nvme_m2b(ptr noundef %10, i64 noundef %conv6)
  store i64 %call7, ptr %mlen, align 8
  %12 = load ptr, ptr %ns, align 8
  %13 = load i64, ptr %slba, align 8
  %call8 = call i64 @nvme_moff(ptr noundef %12, i64 noundef %13)
  store i64 %call8, ptr %offset, align 8
  %14 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %14, i32 0, i32 1
  %blk9 = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %15 = load ptr, ptr %blk9, align 8
  store ptr %15, ptr %blk, align 8
  %16 = load ptr, ptr %req, align 8
  %call10 = call zeroext i16 @nvme_cid(ptr noundef %16)
  %17 = load ptr, ptr %blk, align 8
  %call11 = call ptr @blk_name(ptr noundef %17)
  call void @trace_pci_nvme_verify_mdata_in_cb(i16 noundef zeroext %call10, ptr noundef %call11)
  %18 = load i32, ptr %ret.addr, align 4
  %tobool = icmp ne i32 %18, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %out

if.end:                                           ; preds = %entry
  %19 = load i64, ptr %mlen, align 8
  %call12 = call noalias ptr @g_malloc(i64 noundef %19) #14
  %20 = load ptr, ptr %ctx, align 8
  %mdata = getelementptr inbounds %struct.NvmeBounceContext, ptr %20, i32 0, i32 2
  %bounce = getelementptr inbounds %struct.anon.40, ptr %mdata, i32 0, i32 1
  store ptr %call12, ptr %bounce, align 8
  %21 = load ptr, ptr %ctx, align 8
  %mdata13 = getelementptr inbounds %struct.NvmeBounceContext, ptr %21, i32 0, i32 2
  %iov = getelementptr inbounds %struct.anon.40, ptr %mdata13, i32 0, i32 0
  call void @qemu_iovec_reset(ptr noundef %iov)
  %22 = load ptr, ptr %ctx, align 8
  %mdata14 = getelementptr inbounds %struct.NvmeBounceContext, ptr %22, i32 0, i32 2
  %iov15 = getelementptr inbounds %struct.anon.40, ptr %mdata14, i32 0, i32 0
  %23 = load ptr, ptr %ctx, align 8
  %mdata16 = getelementptr inbounds %struct.NvmeBounceContext, ptr %23, i32 0, i32 2
  %bounce17 = getelementptr inbounds %struct.anon.40, ptr %mdata16, i32 0, i32 1
  %24 = load ptr, ptr %bounce17, align 8
  %25 = load i64, ptr %mlen, align 8
  call void @qemu_iovec_add(ptr noundef %iov15, ptr noundef %24, i64 noundef %25)
  %26 = load ptr, ptr %blk, align 8
  %27 = load i64, ptr %offset, align 8
  %28 = load ptr, ptr %ctx, align 8
  %mdata18 = getelementptr inbounds %struct.NvmeBounceContext, ptr %28, i32 0, i32 2
  %iov19 = getelementptr inbounds %struct.anon.40, ptr %mdata18, i32 0, i32 0
  %29 = load ptr, ptr %ctx, align 8
  %call20 = call ptr @blk_aio_preadv(ptr noundef %26, i64 noundef %27, ptr noundef %iov19, i32 noundef 0, ptr noundef @nvme_verify_cb, ptr noundef %29)
  %30 = load ptr, ptr %req, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %30, i32 0, i32 2
  store ptr %call20, ptr %aiocb, align 8
  br label %return

out:                                              ; preds = %if.then
  %31 = load ptr, ptr %ctx, align 8
  %32 = load i32, ptr %ret.addr, align 4
  call void @nvme_verify_cb(ptr noundef %31, i32 noundef %32)
  br label %return

return:                                           ; preds = %out, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_verify(i16 noundef zeroext %cid, i32 noundef %nsid, i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_VERIFY_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i32, ptr %nsid.addr, align 4
  %7 = load i64, ptr %slba.addr, align 8
  %8 = load i32, ptr %nlb.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.251, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %6, i64 noundef %7, i32 noundef %8)
  br label %if.end

if.else:                                          ; preds = %if.then
  %9 = load i16, ptr %cid.addr, align 2
  %conv12 = zext i16 %9 to i32
  %10 = load i32, ptr %nsid.addr, align 4
  %11 = load i64, ptr %slba.addr, align 8
  %12 = load i32, ptr %nlb.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.252, i32 noundef %conv12, i32 noundef %10, i64 noundef %11, i32 noundef %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_verify_mdata_in_cb(i16 noundef zeroext %cid, ptr noundef %blkname) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %blkname.addr = alloca ptr, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store ptr %blkname, ptr %blkname.addr, align 8
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load ptr, ptr %blkname.addr, align 8
  call void @_nocheck__trace_pci_nvme_verify_mdata_in_cb(i16 noundef zeroext %0, ptr noundef %1)
  ret void
}

declare void @qemu_iovec_reset(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_verify_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %ctx = alloca ptr, align 8
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %blk = alloca ptr, align 8
  %acct = alloca ptr, align 8
  %stats = alloca ptr, align 8
  %rw = alloca ptr, align 8
  %slba = alloca i64, align 8
  %prinfo = alloca i8, align 1
  %apptag = alloca i16, align 2
  %appmask = alloca i16, align 2
  %reftag = alloca i64, align 8
  %cdw3 = alloca i64, align 8
  %status = alloca i16, align 2
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %ctx, align 8
  %1 = load ptr, ptr %ctx, align 8
  %req1 = getelementptr inbounds %struct.NvmeBounceContext, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %req1, align 8
  store ptr %2, ptr %req, align 8
  %3 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %ns2, align 8
  store ptr %4, ptr %ns, align 8
  %5 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %5, i32 0, i32 1
  %blk3 = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %6 = load ptr, ptr %blk3, align 8
  store ptr %6, ptr %blk, align 8
  %7 = load ptr, ptr %req, align 8
  %acct4 = getelementptr inbounds %struct.NvmeRequest, ptr %7, i32 0, i32 7
  store ptr %acct4, ptr %acct, align 8
  %8 = load ptr, ptr %blk, align 8
  %call = call ptr @blk_get_stats(ptr noundef %8)
  store ptr %call, ptr %stats, align 8
  %9 = load ptr, ptr %req, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %9, i32 0, i32 6
  store ptr %cmd, ptr %rw, align 8
  %10 = load ptr, ptr %rw, align 8
  %slba5 = getelementptr inbounds %struct.NvmeRwCmd, ptr %10, i32 0, i32 8
  %11 = load i64, ptr %slba5, align 1
  %call6 = call i64 @le64_to_cpu(i64 noundef %11)
  store i64 %call6, ptr %slba, align 8
  %12 = load ptr, ptr %rw, align 8
  %control = getelementptr inbounds %struct.NvmeRwCmd, ptr %12, i32 0, i32 10
  %13 = load i16, ptr %control, align 1
  %call7 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %13)
  %conv = zext i16 %call7 to i32
  %shr = ashr i32 %conv, 10
  %and = and i32 %shr, 15
  %conv8 = trunc i32 %and to i8
  store i8 %conv8, ptr %prinfo, align 1
  %14 = load ptr, ptr %rw, align 8
  %apptag9 = getelementptr inbounds %struct.NvmeRwCmd, ptr %14, i32 0, i32 15
  %15 = load i16, ptr %apptag9, align 1
  %call10 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %15)
  store i16 %call10, ptr %apptag, align 2
  %16 = load ptr, ptr %rw, align 8
  %appmask11 = getelementptr inbounds %struct.NvmeRwCmd, ptr %16, i32 0, i32 16
  %17 = load i16, ptr %appmask11, align 1
  %call12 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %17)
  store i16 %call12, ptr %appmask, align 2
  %18 = load ptr, ptr %rw, align 8
  %reftag13 = getelementptr inbounds %struct.NvmeRwCmd, ptr %18, i32 0, i32 14
  %19 = load i32, ptr %reftag13, align 1
  %call14 = call i32 @le32_to_cpu(i32 noundef %19)
  %conv15 = zext i32 %call14 to i64
  store i64 %conv15, ptr %reftag, align 8
  %20 = load ptr, ptr %rw, align 8
  %cdw316 = getelementptr inbounds %struct.NvmeRwCmd, ptr %20, i32 0, i32 5
  %21 = load i32, ptr %cdw316, align 1
  %call17 = call i32 @le32_to_cpu(i32 noundef %21)
  %conv18 = zext i32 %call17 to i64
  store i64 %conv18, ptr %cdw3, align 8
  %22 = load i64, ptr %cdw3, align 8
  %shl = shl i64 %22, 32
  %23 = load i64, ptr %reftag, align 8
  %or = or i64 %23, %shl
  store i64 %or, ptr %reftag, align 8
  %24 = load ptr, ptr %req, align 8
  %call19 = call zeroext i16 @nvme_cid(ptr noundef %24)
  %25 = load i8, ptr %prinfo, align 1
  %26 = load i16, ptr %apptag, align 2
  %27 = load i16, ptr %appmask, align 2
  %28 = load i64, ptr %reftag, align 8
  %conv20 = trunc i64 %28 to i32
  call void @trace_pci_nvme_verify_cb(i16 noundef zeroext %call19, i8 noundef zeroext %25, i16 noundef zeroext %26, i16 noundef zeroext %27, i32 noundef %conv20)
  %29 = load i32, ptr %ret.addr, align 4
  %tobool = icmp ne i32 %29, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %30 = load ptr, ptr %stats, align 8
  %31 = load ptr, ptr %acct, align 8
  call void @block_acct_failed(ptr noundef %30, ptr noundef %31)
  %32 = load ptr, ptr %req, align 8
  %33 = load i32, ptr %ret.addr, align 4
  call void @nvme_aio_err(ptr noundef %32, i32 noundef %33)
  br label %out

if.end:                                           ; preds = %entry
  %34 = load ptr, ptr %stats, align 8
  %35 = load ptr, ptr %acct, align 8
  call void @block_acct_done(ptr noundef %34, ptr noundef %35)
  %36 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %36, i32 0, i32 5
  %dps = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 8
  %37 = load i8, ptr %dps, align 1
  %conv21 = zext i8 %37 to i32
  %and22 = and i32 %conv21, 7
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end42

if.then24:                                        ; preds = %if.end
  %38 = load ptr, ptr %ns, align 8
  %39 = load ptr, ptr %ctx, align 8
  %mdata = getelementptr inbounds %struct.NvmeBounceContext, ptr %39, i32 0, i32 2
  %bounce = getelementptr inbounds %struct.anon.40, ptr %mdata, i32 0, i32 1
  %40 = load ptr, ptr %bounce, align 8
  %41 = load ptr, ptr %ctx, align 8
  %mdata25 = getelementptr inbounds %struct.NvmeBounceContext, ptr %41, i32 0, i32 2
  %iov = getelementptr inbounds %struct.anon.40, ptr %mdata25, i32 0, i32 0
  %42 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov, i32 0, i32 2
  %size = getelementptr inbounds %struct.anon.2, ptr %42, i32 0, i32 1
  %43 = load i64, ptr %size, align 8
  %44 = load i64, ptr %slba, align 8
  %call26 = call zeroext i16 @nvme_dif_mangle_mdata(ptr noundef %38, ptr noundef %40, i64 noundef %43, i64 noundef %44)
  store i16 %call26, ptr %status, align 2
  %45 = load i16, ptr %status, align 2
  %tobool27 = icmp ne i16 %45, 0
  br i1 %tobool27, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.then24
  %46 = load i16, ptr %status, align 2
  %47 = load ptr, ptr %req, align 8
  %status29 = getelementptr inbounds %struct.NvmeRequest, ptr %47, i32 0, i32 3
  store i16 %46, ptr %status29, align 8
  br label %out

if.end30:                                         ; preds = %if.then24
  %48 = load ptr, ptr %ns, align 8
  %49 = load ptr, ptr %ctx, align 8
  %data = getelementptr inbounds %struct.NvmeBounceContext, ptr %49, i32 0, i32 1
  %bounce31 = getelementptr inbounds %struct.anon.40, ptr %data, i32 0, i32 1
  %50 = load ptr, ptr %bounce31, align 8
  %51 = load ptr, ptr %ctx, align 8
  %data32 = getelementptr inbounds %struct.NvmeBounceContext, ptr %51, i32 0, i32 1
  %iov33 = getelementptr inbounds %struct.anon.40, ptr %data32, i32 0, i32 0
  %52 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov33, i32 0, i32 2
  %size34 = getelementptr inbounds %struct.anon.2, ptr %52, i32 0, i32 1
  %53 = load i64, ptr %size34, align 8
  %54 = load ptr, ptr %ctx, align 8
  %mdata35 = getelementptr inbounds %struct.NvmeBounceContext, ptr %54, i32 0, i32 2
  %bounce36 = getelementptr inbounds %struct.anon.40, ptr %mdata35, i32 0, i32 1
  %55 = load ptr, ptr %bounce36, align 8
  %56 = load ptr, ptr %ctx, align 8
  %mdata37 = getelementptr inbounds %struct.NvmeBounceContext, ptr %56, i32 0, i32 2
  %iov38 = getelementptr inbounds %struct.anon.40, ptr %mdata37, i32 0, i32 0
  %57 = getelementptr inbounds %struct.QEMUIOVector, ptr %iov38, i32 0, i32 2
  %size39 = getelementptr inbounds %struct.anon.2, ptr %57, i32 0, i32 1
  %58 = load i64, ptr %size39, align 8
  %59 = load i8, ptr %prinfo, align 1
  %60 = load i64, ptr %slba, align 8
  %61 = load i16, ptr %apptag, align 2
  %62 = load i16, ptr %appmask, align 2
  %call40 = call zeroext i16 @nvme_dif_check(ptr noundef %48, ptr noundef %50, i64 noundef %53, ptr noundef %55, i64 noundef %58, i8 noundef zeroext %59, i64 noundef %60, i16 noundef zeroext %61, i16 noundef zeroext %62, ptr noundef %reftag)
  %63 = load ptr, ptr %req, align 8
  %status41 = getelementptr inbounds %struct.NvmeRequest, ptr %63, i32 0, i32 3
  store i16 %call40, ptr %status41, align 8
  br label %if.end42

if.end42:                                         ; preds = %if.end30, %if.end
  br label %out

out:                                              ; preds = %if.end42, %if.then28, %if.then
  %64 = load ptr, ptr %ctx, align 8
  %data43 = getelementptr inbounds %struct.NvmeBounceContext, ptr %64, i32 0, i32 1
  %iov44 = getelementptr inbounds %struct.anon.40, ptr %data43, i32 0, i32 0
  call void @qemu_iovec_destroy(ptr noundef %iov44)
  %65 = load ptr, ptr %ctx, align 8
  %data45 = getelementptr inbounds %struct.NvmeBounceContext, ptr %65, i32 0, i32 1
  %bounce46 = getelementptr inbounds %struct.anon.40, ptr %data45, i32 0, i32 1
  %66 = load ptr, ptr %bounce46, align 8
  call void @g_free(ptr noundef %66)
  %67 = load ptr, ptr %ctx, align 8
  %mdata47 = getelementptr inbounds %struct.NvmeBounceContext, ptr %67, i32 0, i32 2
  %iov48 = getelementptr inbounds %struct.anon.40, ptr %mdata47, i32 0, i32 0
  call void @qemu_iovec_destroy(ptr noundef %iov48)
  %68 = load ptr, ptr %ctx, align 8
  %mdata49 = getelementptr inbounds %struct.NvmeBounceContext, ptr %68, i32 0, i32 2
  %bounce50 = getelementptr inbounds %struct.anon.40, ptr %mdata49, i32 0, i32 1
  %69 = load ptr, ptr %bounce50, align 8
  call void @g_free(ptr noundef %69)
  %70 = load ptr, ptr %ctx, align 8
  call void @g_free(ptr noundef %70)
  %71 = load ptr, ptr %req, align 8
  %call51 = call ptr @nvme_cq(ptr noundef %71)
  %72 = load ptr, ptr %req, align 8
  call void @nvme_enqueue_req_completion(ptr noundef %call51, ptr noundef %72)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_verify_mdata_in_cb(i16 noundef zeroext %cid, ptr noundef %blkname) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %blkname.addr = alloca ptr, align 8
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store ptr %blkname, ptr %blkname.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_VERIFY_MDATA_IN_CB_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load ptr, ptr %blkname.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.253, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, ptr noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %cid.addr, align 2
  %conv12 = zext i16 %7 to i32
  %8 = load ptr, ptr %blkname.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.254, i32 noundef %conv12, ptr noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_verify_cb(i16 noundef zeroext %cid, i8 noundef zeroext %prinfo, i16 noundef zeroext %apptag, i16 noundef zeroext %appmask, i32 noundef %reftag) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %prinfo.addr = alloca i8, align 1
  %apptag.addr = alloca i16, align 2
  %appmask.addr = alloca i16, align 2
  %reftag.addr = alloca i32, align 4
  store i16 %cid, ptr %cid.addr, align 2
  store i8 %prinfo, ptr %prinfo.addr, align 1
  store i16 %apptag, ptr %apptag.addr, align 2
  store i16 %appmask, ptr %appmask.addr, align 2
  store i32 %reftag, ptr %reftag.addr, align 4
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i8, ptr %prinfo.addr, align 1
  %2 = load i16, ptr %apptag.addr, align 2
  %3 = load i16, ptr %appmask.addr, align 2
  %4 = load i32, ptr %reftag.addr, align 4
  call void @_nocheck__trace_pci_nvme_verify_cb(i16 noundef zeroext %0, i8 noundef zeroext %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i32 noundef %4)
  ret void
}

declare zeroext i16 @nvme_dif_mangle_mdata(ptr noundef, ptr noundef, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_verify_cb(i16 noundef zeroext %cid, i8 noundef zeroext %prinfo, i16 noundef zeroext %apptag, i16 noundef zeroext %appmask, i32 noundef %reftag) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %prinfo.addr = alloca i8, align 1
  %apptag.addr = alloca i16, align 2
  %appmask.addr = alloca i16, align 2
  %reftag.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i8 %prinfo, ptr %prinfo.addr, align 1
  store i16 %apptag, ptr %apptag.addr, align 2
  store i16 %appmask, ptr %appmask.addr, align 2
  store i32 %reftag, ptr %reftag.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_VERIFY_CB_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end19

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i8, ptr %prinfo.addr, align 1
  %conv12 = zext i8 %6 to i32
  %7 = load i16, ptr %apptag.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i16, ptr %appmask.addr, align 2
  %conv14 = zext i16 %8 to i32
  %9 = load i32, ptr %reftag.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.255, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12, i32 noundef %conv13, i32 noundef %conv14, i32 noundef %9)
  br label %if.end

if.else:                                          ; preds = %if.then
  %10 = load i16, ptr %cid.addr, align 2
  %conv15 = zext i16 %10 to i32
  %11 = load i8, ptr %prinfo.addr, align 1
  %conv16 = zext i8 %11 to i32
  %12 = load i16, ptr %apptag.addr, align 2
  %conv17 = zext i16 %12 to i32
  %13 = load i16, ptr %appmask.addr, align 2
  %conv18 = zext i16 %13 to i32
  %14 = load i32, ptr %reftag.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.256, i32 noundef %conv15, i32 noundef %conv16, i32 noundef %conv17, i32 noundef %conv18, i32 noundef %14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end19

if.end19:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_copy(i16 noundef zeroext %cid, i32 noundef %nsid, i16 noundef zeroext %nr, i8 noundef zeroext %format) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %nr.addr = alloca i16, align 2
  %format.addr = alloca i8, align 1
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i16 %nr, ptr %nr.addr, align 2
  store i8 %format, ptr %format.addr, align 1
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i32, ptr %nsid.addr, align 4
  %2 = load i16, ptr %nr.addr, align 2
  %3 = load i8, ptr %format.addr, align 1
  call void @_nocheck__trace_pci_nvme_copy(i16 noundef zeroext %0, i32 noundef %1, i16 noundef zeroext %2, i8 noundef zeroext %3)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_copy_invalid_format(i8 noundef zeroext %format) #0 {
entry:
  %format.addr = alloca i8, align 1
  store i8 %format, ptr %format.addr, align 1
  %0 = load i8, ptr %format.addr, align 1
  call void @_nocheck__trace_pci_nvme_err_copy_invalid_format(i8 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_check_copy_mcl(ptr noundef %ns, ptr noundef %iocb, i16 noundef zeroext %nr) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %iocb.addr = alloca ptr, align 8
  %nr.addr = alloca i16, align 2
  %copy_len = alloca i32, align 4
  %idx = alloca i32, align 4
  %nlb = alloca i32, align 4
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %iocb, ptr %iocb.addr, align 8
  store i16 %nr, ptr %nr.addr, align 2
  store i32 0, ptr %copy_len, align 4
  store i32 0, ptr %idx, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %idx, align 4
  %1 = load i16, ptr %nr.addr, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp slt i32 %0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %iocb.addr, align 8
  %ranges = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %ranges, align 8
  %4 = load i32, ptr %idx, align 4
  %5 = load ptr, ptr %iocb.addr, align 8
  %format = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %5, i32 0, i32 5
  %6 = load i32, ptr %format, align 8
  %conv2 = trunc i32 %6 to i8
  call void @nvme_copy_source_range_parse(ptr noundef %3, i32 noundef %4, i8 noundef zeroext %conv2, ptr noundef null, ptr noundef %nlb, ptr noundef null, ptr noundef null, ptr noundef null)
  %7 = load i32, ptr %nlb, align 4
  %add = add i32 %7, 1
  %8 = load i32, ptr %copy_len, align 4
  %add3 = add i32 %8, %add
  store i32 %add3, ptr %copy_len, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i32, ptr %idx, align 4
  %inc = add i32 %9, 1
  store i32 %inc, ptr %idx, align 4
  br label %for.cond, !llvm.loop !34

for.end:                                          ; preds = %for.cond
  %10 = load i32, ptr %copy_len, align 4
  %11 = load ptr, ptr %ns.addr, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %11, i32 0, i32 5
  %mcl = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 27
  %12 = load i32, ptr %mcl, align 4
  %cmp4 = icmp ugt i32 %10, %12
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  store i16 16771, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %for.end
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load i16, ptr %retval, align 2
  ret i16 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_do_copy(ptr noundef %iocb) #0 {
entry:
  %iocb.addr = alloca ptr, align 8
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %slba = alloca i64, align 8
  %nlb = alloca i32, align 4
  %len = alloca i64, align 8
  %status = alloca i16, align 2
  store ptr %iocb, ptr %iocb.addr, align 8
  %0 = load ptr, ptr %iocb.addr, align 8
  %req1 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %req1, align 8
  store ptr %1, ptr %req, align 8
  %2 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %ns2, align 8
  store ptr %3, ptr %ns, align 8
  %4 = load ptr, ptr %iocb.addr, align 8
  %ret = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %ret, align 8
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %done

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %iocb.addr, align 8
  %idx = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %6, i32 0, i32 7
  %7 = load i32, ptr %idx, align 8
  %8 = load ptr, ptr %iocb.addr, align 8
  %nr = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %8, i32 0, i32 6
  %9 = load i32, ptr %nr, align 4
  %cmp3 = icmp eq i32 %7, %9
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %done

if.end5:                                          ; preds = %if.end
  %10 = load ptr, ptr %iocb.addr, align 8
  %ranges = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %ranges, align 8
  %12 = load ptr, ptr %iocb.addr, align 8
  %idx6 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %12, i32 0, i32 7
  %13 = load i32, ptr %idx6, align 8
  %14 = load ptr, ptr %iocb.addr, align 8
  %format = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %14, i32 0, i32 5
  %15 = load i32, ptr %format, align 8
  %conv = trunc i32 %15 to i8
  call void @nvme_copy_source_range_parse(ptr noundef %11, i32 noundef %13, i8 noundef zeroext %conv, ptr noundef %slba, ptr noundef %nlb, ptr noundef null, ptr noundef null, ptr noundef null)
  %16 = load ptr, ptr %ns, align 8
  %17 = load i32, ptr %nlb, align 4
  %conv7 = zext i32 %17 to i64
  %call = call i64 @nvme_l2b(ptr noundef %16, i64 noundef %conv7)
  store i64 %call, ptr %len, align 8
  %18 = load i64, ptr %slba, align 8
  %19 = load i32, ptr %nlb, align 4
  call void @trace_pci_nvme_copy_source_range(i64 noundef %18, i32 noundef %19)
  %20 = load i32, ptr %nlb, align 4
  %21 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %21, i32 0, i32 5
  %mssrl = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 26
  %22 = load i16, ptr %mssrl, align 2
  %call8 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %22)
  %conv9 = zext i16 %call8 to i32
  %cmp10 = icmp ugt i32 %20, %conv9
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end5
  store i16 16771, ptr %status, align 2
  br label %invalid

if.end13:                                         ; preds = %if.end5
  %23 = load ptr, ptr %ns, align 8
  %24 = load i64, ptr %slba, align 8
  %25 = load i32, ptr %nlb, align 4
  %call14 = call zeroext i16 @nvme_check_bounds(ptr noundef %23, i64 noundef %24, i32 noundef %25)
  store i16 %call14, ptr %status, align 2
  %26 = load i16, ptr %status, align 2
  %tobool = icmp ne i16 %26, 0
  br i1 %tobool, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end13
  br label %invalid

if.end16:                                         ; preds = %if.end13
  %27 = load ptr, ptr %ns, align 8
  %features = getelementptr inbounds %struct.NvmeNamespace, ptr %27, i32 0, i32 33
  %err_rec = getelementptr inbounds %struct.anon.13, ptr %features, i32 0, i32 0
  %28 = load i32, ptr %err_rec, align 8
  %and = and i32 %28, 65536
  %tobool17 = icmp ne i32 %and, 0
  br i1 %tobool17, label %if.then18, label %if.end23

if.then18:                                        ; preds = %if.end16
  %29 = load ptr, ptr %ns, align 8
  %30 = load i64, ptr %slba, align 8
  %31 = load i32, ptr %nlb, align 4
  %call19 = call zeroext i16 @nvme_check_dulbe(ptr noundef %29, i64 noundef %30, i32 noundef %31)
  store i16 %call19, ptr %status, align 2
  %32 = load i16, ptr %status, align 2
  %tobool20 = icmp ne i16 %32, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.then18
  br label %invalid

if.end22:                                         ; preds = %if.then18
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.end16
  %33 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %33, i32 0, i32 30
  %zoned = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 14
  %34 = load i8, ptr %zoned, align 1
  %tobool24 = trunc i8 %34 to i1
  br i1 %tobool24, label %if.then25, label %if.end30

if.then25:                                        ; preds = %if.end23
  %35 = load ptr, ptr %ns, align 8
  %36 = load i64, ptr %slba, align 8
  %37 = load i32, ptr %nlb, align 4
  %call26 = call zeroext i16 @nvme_check_zone_read(ptr noundef %35, i64 noundef %36, i32 noundef %37)
  store i16 %call26, ptr %status, align 2
  %38 = load i16, ptr %status, align 2
  %tobool27 = icmp ne i16 %38, 0
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.then25
  br label %invalid

if.end29:                                         ; preds = %if.then25
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %if.end23
  %39 = load ptr, ptr %iocb.addr, align 8
  %iov = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %39, i32 0, i32 9
  call void @qemu_iovec_reset(ptr noundef %iov)
  %40 = load ptr, ptr %iocb.addr, align 8
  %iov31 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %40, i32 0, i32 9
  %41 = load ptr, ptr %iocb.addr, align 8
  %bounce = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %41, i32 0, i32 8
  %42 = load ptr, ptr %bounce, align 8
  %43 = load i64, ptr %len, align 8
  call void @qemu_iovec_add(ptr noundef %iov31, ptr noundef %42, i64 noundef %43)
  %44 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %44, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %45 = load ptr, ptr %blk, align 8
  %46 = load ptr, ptr %ns, align 8
  %47 = load i64, ptr %slba, align 8
  %call32 = call i64 @nvme_l2b(ptr noundef %46, i64 noundef %47)
  %48 = load ptr, ptr %iocb.addr, align 8
  %iov33 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %48, i32 0, i32 9
  %49 = load ptr, ptr %iocb.addr, align 8
  %call34 = call ptr @blk_aio_preadv(ptr noundef %45, i64 noundef %call32, ptr noundef %iov33, i32 noundef 0, ptr noundef @nvme_copy_in_cb, ptr noundef %49)
  %50 = load ptr, ptr %iocb.addr, align 8
  %aiocb = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %50, i32 0, i32 1
  store ptr %call34, ptr %aiocb, align 8
  br label %return

invalid:                                          ; preds = %if.then28, %if.then21, %if.then15, %if.then12
  %51 = load i16, ptr %status, align 2
  %52 = load ptr, ptr %req, align 8
  %status35 = getelementptr inbounds %struct.NvmeRequest, ptr %52, i32 0, i32 3
  store i16 %51, ptr %status35, align 8
  %53 = load ptr, ptr %iocb.addr, align 8
  %ret36 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %53, i32 0, i32 3
  store i32 -1, ptr %ret36, align 8
  br label %done

done:                                             ; preds = %invalid, %if.then4, %if.then
  %54 = load ptr, ptr %iocb.addr, align 8
  call void @nvme_copy_done(ptr noundef %54)
  br label %return

return:                                           ; preds = %done, %if.end30
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_copy_cancel(ptr noundef %aiocb) #0 {
entry:
  %aiocb.addr = alloca ptr, align 8
  %iocb = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  store ptr %aiocb, ptr %aiocb.addr, align 8
  %0 = load ptr, ptr %aiocb.addr, align 8
  store ptr %0, ptr %__mptr, align 8
  %1 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 0
  store ptr %add.ptr, ptr %tmp, align 8
  %2 = load ptr, ptr %tmp, align 8
  store ptr %2, ptr %iocb, align 8
  %3 = load ptr, ptr %iocb, align 8
  %ret = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %3, i32 0, i32 3
  store i32 -125, ptr %ret, align 8
  %4 = load ptr, ptr %iocb, align 8
  %aiocb1 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %aiocb1, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %iocb, align 8
  %aiocb2 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %aiocb2, align 8
  call void @blk_aio_cancel_async(ptr noundef %7)
  %8 = load ptr, ptr %iocb, align 8
  %aiocb3 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %8, i32 0, i32 1
  store ptr null, ptr %aiocb3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_copy(i16 noundef zeroext %cid, i32 noundef %nsid, i16 noundef zeroext %nr, i8 noundef zeroext %format) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %nr.addr = alloca i16, align 2
  %format.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i16 %nr, ptr %nr.addr, align 2
  store i8 %format, ptr %format.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_COPY_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end17

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end17

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i32, ptr %nsid.addr, align 4
  %7 = load i16, ptr %nr.addr, align 2
  %conv12 = zext i16 %7 to i32
  %8 = load i8, ptr %format.addr, align 1
  %conv13 = zext i8 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.257, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %6, i32 noundef %conv12, i32 noundef %conv13)
  br label %if.end

if.else:                                          ; preds = %if.then
  %9 = load i16, ptr %cid.addr, align 2
  %conv14 = zext i16 %9 to i32
  %10 = load i32, ptr %nsid.addr, align 4
  %11 = load i16, ptr %nr.addr, align 2
  %conv15 = zext i16 %11 to i32
  %12 = load i8, ptr %format.addr, align 1
  %conv16 = zext i8 %12 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.258, i32 noundef %conv14, i32 noundef %10, i32 noundef %conv15, i32 noundef %conv16)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end17

if.end17:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_copy_invalid_format(i8 noundef zeroext %format) #0 {
entry:
  %format.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %format, ptr %format.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_COPY_INVALID_FORMAT_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %format.addr, align 1
  %conv11 = zext i8 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.259, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i8, ptr %format.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.260, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_copy_source_range_parse(ptr noundef %ranges, i32 noundef %idx, i8 noundef zeroext %format, ptr noundef %slba, ptr noundef %nlb, ptr noundef %apptag, ptr noundef %appmask, ptr noundef %reftag) #0 {
entry:
  %ranges.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  %format.addr = alloca i8, align 1
  %slba.addr = alloca ptr, align 8
  %nlb.addr = alloca ptr, align 8
  %apptag.addr = alloca ptr, align 8
  %appmask.addr = alloca ptr, align 8
  %reftag.addr = alloca ptr, align 8
  store ptr %ranges, ptr %ranges.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store i8 %format, ptr %format.addr, align 1
  store ptr %slba, ptr %slba.addr, align 8
  store ptr %nlb, ptr %nlb.addr, align 8
  store ptr %apptag, ptr %apptag.addr, align 8
  store ptr %appmask, ptr %appmask.addr, align 8
  store ptr %reftag, ptr %reftag.addr, align 8
  %0 = load i8, ptr %format.addr, align 1
  %conv = zext i8 %0 to i32
  switch i32 %conv, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %1 = load ptr, ptr %ranges.addr, align 8
  %2 = load i32, ptr %idx.addr, align 4
  %3 = load ptr, ptr %slba.addr, align 8
  %4 = load ptr, ptr %nlb.addr, align 8
  %5 = load ptr, ptr %apptag.addr, align 8
  %6 = load ptr, ptr %appmask.addr, align 8
  %7 = load ptr, ptr %reftag.addr, align 8
  call void @nvme_copy_source_range_parse_format0(ptr noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef %6, ptr noundef %7)
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %8 = load ptr, ptr %ranges.addr, align 8
  %9 = load i32, ptr %idx.addr, align 4
  %10 = load ptr, ptr %slba.addr, align 8
  %11 = load ptr, ptr %nlb.addr, align 8
  %12 = load ptr, ptr %apptag.addr, align 8
  %13 = load ptr, ptr %appmask.addr, align 8
  %14 = load ptr, ptr %reftag.addr, align 8
  call void @nvme_copy_source_range_parse_format1(ptr noundef %8, i32 noundef %9, ptr noundef %10, ptr noundef %11, ptr noundef %12, ptr noundef %13, ptr noundef %14)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  call void @abort() #12
  unreachable

sw.epilog:                                        ; preds = %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_copy_source_range_parse_format0(ptr noundef %ranges, i32 noundef %idx, ptr noundef %slba, ptr noundef %nlb, ptr noundef %apptag, ptr noundef %appmask, ptr noundef %reftag) #0 {
entry:
  %ranges.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  %slba.addr = alloca ptr, align 8
  %nlb.addr = alloca ptr, align 8
  %apptag.addr = alloca ptr, align 8
  %appmask.addr = alloca ptr, align 8
  %reftag.addr = alloca ptr, align 8
  %_ranges = alloca ptr, align 8
  store ptr %ranges, ptr %ranges.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %slba, ptr %slba.addr, align 8
  store ptr %nlb, ptr %nlb.addr, align 8
  store ptr %apptag, ptr %apptag.addr, align 8
  store ptr %appmask, ptr %appmask.addr, align 8
  store ptr %reftag, ptr %reftag.addr, align 8
  %0 = load ptr, ptr %ranges.addr, align 8
  store ptr %0, ptr %_ranges, align 8
  %1 = load ptr, ptr %slba.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %_ranges, align 8
  %3 = load i32, ptr %idx.addr, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr %struct.NvmeCopySourceRangeFormat0, ptr %2, i64 %idxprom
  %slba1 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat0, ptr %arrayidx, i32 0, i32 1
  %4 = load i64, ptr %slba1, align 1
  %call = call i64 @le64_to_cpu(i64 noundef %4)
  %5 = load ptr, ptr %slba.addr, align 8
  store i64 %call, ptr %5, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %nlb.addr, align 8
  %tobool2 = icmp ne ptr %6, null
  br i1 %tobool2, label %if.then3, label %if.end8

if.then3:                                         ; preds = %if.end
  %7 = load ptr, ptr %_ranges, align 8
  %8 = load i32, ptr %idx.addr, align 4
  %idxprom4 = sext i32 %8 to i64
  %arrayidx5 = getelementptr %struct.NvmeCopySourceRangeFormat0, ptr %7, i64 %idxprom4
  %nlb6 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat0, ptr %arrayidx5, i32 0, i32 2
  %9 = load i16, ptr %nlb6, align 1
  %call7 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %9)
  %conv = zext i16 %call7 to i32
  %add = add i32 %conv, 1
  %10 = load ptr, ptr %nlb.addr, align 8
  store i32 %add, ptr %10, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then3, %if.end
  %11 = load ptr, ptr %apptag.addr, align 8
  %tobool9 = icmp ne ptr %11, null
  br i1 %tobool9, label %if.then10, label %if.end15

if.then10:                                        ; preds = %if.end8
  %12 = load ptr, ptr %_ranges, align 8
  %13 = load i32, ptr %idx.addr, align 4
  %idxprom11 = sext i32 %13 to i64
  %arrayidx12 = getelementptr %struct.NvmeCopySourceRangeFormat0, ptr %12, i64 %idxprom11
  %apptag13 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat0, ptr %arrayidx12, i32 0, i32 5
  %14 = load i16, ptr %apptag13, align 1
  %call14 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %14)
  %15 = load ptr, ptr %apptag.addr, align 8
  store i16 %call14, ptr %15, align 2
  br label %if.end15

if.end15:                                         ; preds = %if.then10, %if.end8
  %16 = load ptr, ptr %appmask.addr, align 8
  %tobool16 = icmp ne ptr %16, null
  br i1 %tobool16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.end15
  %17 = load ptr, ptr %_ranges, align 8
  %18 = load i32, ptr %idx.addr, align 4
  %idxprom18 = sext i32 %18 to i64
  %arrayidx19 = getelementptr %struct.NvmeCopySourceRangeFormat0, ptr %17, i64 %idxprom18
  %appmask20 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat0, ptr %arrayidx19, i32 0, i32 6
  %19 = load i16, ptr %appmask20, align 1
  %call21 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %19)
  %20 = load ptr, ptr %appmask.addr, align 8
  store i16 %call21, ptr %20, align 2
  br label %if.end22

if.end22:                                         ; preds = %if.then17, %if.end15
  %21 = load ptr, ptr %reftag.addr, align 8
  %tobool23 = icmp ne ptr %21, null
  br i1 %tobool23, label %if.then24, label %if.end30

if.then24:                                        ; preds = %if.end22
  %22 = load ptr, ptr %_ranges, align 8
  %23 = load i32, ptr %idx.addr, align 4
  %idxprom25 = sext i32 %23 to i64
  %arrayidx26 = getelementptr %struct.NvmeCopySourceRangeFormat0, ptr %22, i64 %idxprom25
  %reftag27 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat0, ptr %arrayidx26, i32 0, i32 4
  %24 = load i32, ptr %reftag27, align 1
  %call28 = call i32 @le32_to_cpu(i32 noundef %24)
  %conv29 = zext i32 %call28 to i64
  %25 = load ptr, ptr %reftag.addr, align 8
  store i64 %conv29, ptr %25, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then24, %if.end22
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_copy_source_range_parse_format1(ptr noundef %ranges, i32 noundef %idx, ptr noundef %slba, ptr noundef %nlb, ptr noundef %apptag, ptr noundef %appmask, ptr noundef %reftag) #0 {
entry:
  %ranges.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  %slba.addr = alloca ptr, align 8
  %nlb.addr = alloca ptr, align 8
  %apptag.addr = alloca ptr, align 8
  %appmask.addr = alloca ptr, align 8
  %reftag.addr = alloca ptr, align 8
  %_ranges = alloca ptr, align 8
  store ptr %ranges, ptr %ranges.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %slba, ptr %slba.addr, align 8
  store ptr %nlb, ptr %nlb.addr, align 8
  store ptr %apptag, ptr %apptag.addr, align 8
  store ptr %appmask, ptr %appmask.addr, align 8
  store ptr %reftag, ptr %reftag.addr, align 8
  %0 = load ptr, ptr %ranges.addr, align 8
  store ptr %0, ptr %_ranges, align 8
  %1 = load ptr, ptr %slba.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %_ranges, align 8
  %3 = load i32, ptr %idx.addr, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr %struct.NvmeCopySourceRangeFormat1, ptr %2, i64 %idxprom
  %slba1 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat1, ptr %arrayidx, i32 0, i32 1
  %4 = load i64, ptr %slba1, align 1
  %call = call i64 @le64_to_cpu(i64 noundef %4)
  %5 = load ptr, ptr %slba.addr, align 8
  store i64 %call, ptr %5, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %nlb.addr, align 8
  %tobool2 = icmp ne ptr %6, null
  br i1 %tobool2, label %if.then3, label %if.end8

if.then3:                                         ; preds = %if.end
  %7 = load ptr, ptr %_ranges, align 8
  %8 = load i32, ptr %idx.addr, align 4
  %idxprom4 = sext i32 %8 to i64
  %arrayidx5 = getelementptr %struct.NvmeCopySourceRangeFormat1, ptr %7, i64 %idxprom4
  %nlb6 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat1, ptr %arrayidx5, i32 0, i32 2
  %9 = load i16, ptr %nlb6, align 1
  %call7 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %9)
  %conv = zext i16 %call7 to i32
  %add = add i32 %conv, 1
  %10 = load ptr, ptr %nlb.addr, align 8
  store i32 %add, ptr %10, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then3, %if.end
  %11 = load ptr, ptr %apptag.addr, align 8
  %tobool9 = icmp ne ptr %11, null
  br i1 %tobool9, label %if.then10, label %if.end15

if.then10:                                        ; preds = %if.end8
  %12 = load ptr, ptr %_ranges, align 8
  %13 = load i32, ptr %idx.addr, align 4
  %idxprom11 = sext i32 %13 to i64
  %arrayidx12 = getelementptr %struct.NvmeCopySourceRangeFormat1, ptr %12, i64 %idxprom11
  %apptag13 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat1, ptr %arrayidx12, i32 0, i32 5
  %14 = load i16, ptr %apptag13, align 1
  %call14 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %14)
  %15 = load ptr, ptr %apptag.addr, align 8
  store i16 %call14, ptr %15, align 2
  br label %if.end15

if.end15:                                         ; preds = %if.then10, %if.end8
  %16 = load ptr, ptr %appmask.addr, align 8
  %tobool16 = icmp ne ptr %16, null
  br i1 %tobool16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.end15
  %17 = load ptr, ptr %_ranges, align 8
  %18 = load i32, ptr %idx.addr, align 4
  %idxprom18 = sext i32 %18 to i64
  %arrayidx19 = getelementptr %struct.NvmeCopySourceRangeFormat1, ptr %17, i64 %idxprom18
  %appmask20 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat1, ptr %arrayidx19, i32 0, i32 6
  %19 = load i16, ptr %appmask20, align 1
  %call21 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %19)
  %20 = load ptr, ptr %appmask.addr, align 8
  store i16 %call21, ptr %20, align 2
  br label %if.end22

if.end22:                                         ; preds = %if.then17, %if.end15
  %21 = load ptr, ptr %reftag.addr, align 8
  %tobool23 = icmp ne ptr %21, null
  br i1 %tobool23, label %if.then24, label %if.end63

if.then24:                                        ; preds = %if.end22
  %22 = load ptr, ptr %reftag.addr, align 8
  store i64 0, ptr %22, align 8
  %23 = load ptr, ptr %_ranges, align 8
  %24 = load i32, ptr %idx.addr, align 4
  %idxprom25 = sext i32 %24 to i64
  %arrayidx26 = getelementptr %struct.NvmeCopySourceRangeFormat1, ptr %23, i64 %idxprom25
  %sr = getelementptr inbounds %struct.NvmeCopySourceRangeFormat1, ptr %arrayidx26, i32 0, i32 4
  %arrayidx27 = getelementptr [10 x i8], ptr %sr, i64 0, i64 4
  %25 = load i8, ptr %arrayidx27, align 1
  %conv28 = zext i8 %25 to i64
  %shl = shl i64 %conv28, 40
  %26 = load ptr, ptr %reftag.addr, align 8
  %27 = load i64, ptr %26, align 8
  %or = or i64 %27, %shl
  store i64 %or, ptr %26, align 8
  %28 = load ptr, ptr %_ranges, align 8
  %29 = load i32, ptr %idx.addr, align 4
  %idxprom29 = sext i32 %29 to i64
  %arrayidx30 = getelementptr %struct.NvmeCopySourceRangeFormat1, ptr %28, i64 %idxprom29
  %sr31 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat1, ptr %arrayidx30, i32 0, i32 4
  %arrayidx32 = getelementptr [10 x i8], ptr %sr31, i64 0, i64 5
  %30 = load i8, ptr %arrayidx32, align 1
  %conv33 = zext i8 %30 to i64
  %shl34 = shl i64 %conv33, 32
  %31 = load ptr, ptr %reftag.addr, align 8
  %32 = load i64, ptr %31, align 8
  %or35 = or i64 %32, %shl34
  store i64 %or35, ptr %31, align 8
  %33 = load ptr, ptr %_ranges, align 8
  %34 = load i32, ptr %idx.addr, align 4
  %idxprom36 = sext i32 %34 to i64
  %arrayidx37 = getelementptr %struct.NvmeCopySourceRangeFormat1, ptr %33, i64 %idxprom36
  %sr38 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat1, ptr %arrayidx37, i32 0, i32 4
  %arrayidx39 = getelementptr [10 x i8], ptr %sr38, i64 0, i64 6
  %35 = load i8, ptr %arrayidx39, align 1
  %conv40 = zext i8 %35 to i64
  %shl41 = shl i64 %conv40, 24
  %36 = load ptr, ptr %reftag.addr, align 8
  %37 = load i64, ptr %36, align 8
  %or42 = or i64 %37, %shl41
  store i64 %or42, ptr %36, align 8
  %38 = load ptr, ptr %_ranges, align 8
  %39 = load i32, ptr %idx.addr, align 4
  %idxprom43 = sext i32 %39 to i64
  %arrayidx44 = getelementptr %struct.NvmeCopySourceRangeFormat1, ptr %38, i64 %idxprom43
  %sr45 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat1, ptr %arrayidx44, i32 0, i32 4
  %arrayidx46 = getelementptr [10 x i8], ptr %sr45, i64 0, i64 7
  %40 = load i8, ptr %arrayidx46, align 1
  %conv47 = zext i8 %40 to i64
  %shl48 = shl i64 %conv47, 16
  %41 = load ptr, ptr %reftag.addr, align 8
  %42 = load i64, ptr %41, align 8
  %or49 = or i64 %42, %shl48
  store i64 %or49, ptr %41, align 8
  %43 = load ptr, ptr %_ranges, align 8
  %44 = load i32, ptr %idx.addr, align 4
  %idxprom50 = sext i32 %44 to i64
  %arrayidx51 = getelementptr %struct.NvmeCopySourceRangeFormat1, ptr %43, i64 %idxprom50
  %sr52 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat1, ptr %arrayidx51, i32 0, i32 4
  %arrayidx53 = getelementptr [10 x i8], ptr %sr52, i64 0, i64 8
  %45 = load i8, ptr %arrayidx53, align 1
  %conv54 = zext i8 %45 to i64
  %shl55 = shl i64 %conv54, 8
  %46 = load ptr, ptr %reftag.addr, align 8
  %47 = load i64, ptr %46, align 8
  %or56 = or i64 %47, %shl55
  store i64 %or56, ptr %46, align 8
  %48 = load ptr, ptr %_ranges, align 8
  %49 = load i32, ptr %idx.addr, align 4
  %idxprom57 = sext i32 %49 to i64
  %arrayidx58 = getelementptr %struct.NvmeCopySourceRangeFormat1, ptr %48, i64 %idxprom57
  %sr59 = getelementptr inbounds %struct.NvmeCopySourceRangeFormat1, ptr %arrayidx58, i32 0, i32 4
  %arrayidx60 = getelementptr [10 x i8], ptr %sr59, i64 0, i64 9
  %50 = load i8, ptr %arrayidx60, align 1
  %conv61 = zext i8 %50 to i64
  %51 = load ptr, ptr %reftag.addr, align 8
  %52 = load i64, ptr %51, align 8
  %or62 = or i64 %52, %conv61
  store i64 %or62, ptr %51, align 8
  br label %if.end63

if.end63:                                         ; preds = %if.then24, %if.end22
  ret void
}

; Function Attrs: noreturn nounwind
declare void @abort() #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_copy_source_range(i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i32, ptr %nlb.addr, align 4
  call void @_nocheck__trace_pci_nvme_copy_source_range(i64 noundef %0, i32 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_copy_in_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %iocb = alloca ptr, align 8
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %slba = alloca i64, align 8
  %nlb = alloca i32, align 4
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %iocb, align 8
  %1 = load ptr, ptr %iocb, align 8
  %req1 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %req1, align 8
  store ptr %2, ptr %req, align 8
  %3 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %ns2, align 8
  store ptr %4, ptr %ns, align 8
  %5 = load i32, ptr %ret.addr, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load ptr, ptr %iocb, align 8
  %ret3 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %6, i32 0, i32 3
  %7 = load i32, ptr %ret3, align 8
  %cmp4 = icmp slt i32 %7, 0
  br i1 %cmp4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %8 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %8, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %9 = load i16, ptr %ms, align 8
  %tobool = icmp ne i16 %9, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false5, %lor.lhs.false, %entry
  br label %out

if.end:                                           ; preds = %lor.lhs.false5
  %10 = load ptr, ptr %iocb, align 8
  %ranges = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %ranges, align 8
  %12 = load ptr, ptr %iocb, align 8
  %idx = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %12, i32 0, i32 7
  %13 = load i32, ptr %idx, align 8
  %14 = load ptr, ptr %iocb, align 8
  %format = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %14, i32 0, i32 5
  %15 = load i32, ptr %format, align 8
  %conv = trunc i32 %15 to i8
  call void @nvme_copy_source_range_parse(ptr noundef %11, i32 noundef %13, i8 noundef zeroext %conv, ptr noundef %slba, ptr noundef %nlb, ptr noundef null, ptr noundef null, ptr noundef null)
  %16 = load ptr, ptr %iocb, align 8
  %iov = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %16, i32 0, i32 9
  call void @qemu_iovec_reset(ptr noundef %iov)
  %17 = load ptr, ptr %iocb, align 8
  %iov6 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %17, i32 0, i32 9
  %18 = load ptr, ptr %iocb, align 8
  %bounce = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %18, i32 0, i32 8
  %19 = load ptr, ptr %bounce, align 8
  %20 = load ptr, ptr %ns, align 8
  %21 = load i32, ptr %nlb, align 4
  %conv7 = zext i32 %21 to i64
  %call = call i64 @nvme_l2b(ptr noundef %20, i64 noundef %conv7)
  %add.ptr = getelementptr i8, ptr %19, i64 %call
  %22 = load ptr, ptr %ns, align 8
  %23 = load i32, ptr %nlb, align 4
  %conv8 = zext i32 %23 to i64
  %call9 = call i64 @nvme_m2b(ptr noundef %22, i64 noundef %conv8)
  call void @qemu_iovec_add(ptr noundef %iov6, ptr noundef %add.ptr, i64 noundef %call9)
  %24 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %24, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %25 = load ptr, ptr %blk, align 8
  %26 = load ptr, ptr %ns, align 8
  %27 = load i64, ptr %slba, align 8
  %call10 = call i64 @nvme_moff(ptr noundef %26, i64 noundef %27)
  %28 = load ptr, ptr %iocb, align 8
  %iov11 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %28, i32 0, i32 9
  %29 = load ptr, ptr %iocb, align 8
  %call12 = call ptr @blk_aio_preadv(ptr noundef %25, i64 noundef %call10, ptr noundef %iov11, i32 noundef 0, ptr noundef @nvme_copy_in_completed_cb, ptr noundef %29)
  %30 = load ptr, ptr %iocb, align 8
  %aiocb = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %30, i32 0, i32 1
  store ptr %call12, ptr %aiocb, align 8
  br label %return

out:                                              ; preds = %if.then
  %31 = load ptr, ptr %iocb, align 8
  %32 = load i32, ptr %ret.addr, align 4
  call void @nvme_copy_in_completed_cb(ptr noundef %31, i32 noundef %32)
  br label %return

return:                                           ; preds = %out, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_copy_done(ptr noundef %iocb) #0 {
entry:
  %iocb.addr = alloca ptr, align 8
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %stats = alloca ptr, align 8
  store ptr %iocb, ptr %iocb.addr, align 8
  %0 = load ptr, ptr %iocb.addr, align 8
  %req1 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %req1, align 8
  store ptr %1, ptr %req, align 8
  %2 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %ns2, align 8
  store ptr %3, ptr %ns, align 8
  %4 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %4, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %5 = load ptr, ptr %blk, align 8
  %call = call ptr @blk_get_stats(ptr noundef %5)
  store ptr %call, ptr %stats, align 8
  %6 = load ptr, ptr %iocb.addr, align 8
  %idx = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %6, i32 0, i32 7
  %7 = load i32, ptr %idx, align 8
  %8 = load ptr, ptr %iocb.addr, align 8
  %nr = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %8, i32 0, i32 6
  %9 = load i32, ptr %nr, align 4
  %cmp = icmp ne i32 %7, %9
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load ptr, ptr %iocb.addr, align 8
  %idx3 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %10, i32 0, i32 7
  %11 = load i32, ptr %idx3, align 8
  %call4 = call i32 @cpu_to_le32(i32 noundef %11)
  %12 = load ptr, ptr %req, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %12, i32 0, i32 5
  %result = getelementptr inbounds %struct.NvmeCqe, ptr %cqe, i32 0, i32 0
  store i32 %call4, ptr %result, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %13 = load ptr, ptr %iocb.addr, align 8
  %iov = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %13, i32 0, i32 9
  call void @qemu_iovec_destroy(ptr noundef %iov)
  %14 = load ptr, ptr %iocb.addr, align 8
  %bounce = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %14, i32 0, i32 8
  %15 = load ptr, ptr %bounce, align 8
  call void @g_free(ptr noundef %15)
  %16 = load ptr, ptr %iocb.addr, align 8
  %ret = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %16, i32 0, i32 3
  %17 = load i32, ptr %ret, align 8
  %cmp5 = icmp slt i32 %17, 0
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %18 = load ptr, ptr %stats, align 8
  %19 = load ptr, ptr %iocb.addr, align 8
  %acct = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %19, i32 0, i32 10
  %read = getelementptr inbounds %struct.anon.41, ptr %acct, i32 0, i32 0
  call void @block_acct_failed(ptr noundef %18, ptr noundef %read)
  %20 = load ptr, ptr %stats, align 8
  %21 = load ptr, ptr %iocb.addr, align 8
  %acct7 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %21, i32 0, i32 10
  %write = getelementptr inbounds %struct.anon.41, ptr %acct7, i32 0, i32 1
  call void @block_acct_failed(ptr noundef %20, ptr noundef %write)
  br label %if.end12

if.else:                                          ; preds = %if.end
  %22 = load ptr, ptr %stats, align 8
  %23 = load ptr, ptr %iocb.addr, align 8
  %acct8 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %23, i32 0, i32 10
  %read9 = getelementptr inbounds %struct.anon.41, ptr %acct8, i32 0, i32 0
  call void @block_acct_done(ptr noundef %22, ptr noundef %read9)
  %24 = load ptr, ptr %stats, align 8
  %25 = load ptr, ptr %iocb.addr, align 8
  %acct10 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %25, i32 0, i32 10
  %write11 = getelementptr inbounds %struct.anon.41, ptr %acct10, i32 0, i32 1
  call void @block_acct_done(ptr noundef %24, ptr noundef %write11)
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then6
  %26 = load ptr, ptr %iocb.addr, align 8
  %common = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %26, i32 0, i32 0
  %cb = getelementptr inbounds %struct.BlockAIOCB, ptr %common, i32 0, i32 2
  %27 = load ptr, ptr %cb, align 8
  %28 = load ptr, ptr %iocb.addr, align 8
  %common13 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %28, i32 0, i32 0
  %opaque = getelementptr inbounds %struct.BlockAIOCB, ptr %common13, i32 0, i32 3
  %29 = load ptr, ptr %opaque, align 8
  %30 = load ptr, ptr %iocb.addr, align 8
  %ret14 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %30, i32 0, i32 3
  %31 = load i32, ptr %ret14, align 8
  call void %27(ptr noundef %29, i32 noundef %31)
  %32 = load ptr, ptr %iocb.addr, align 8
  call void @qemu_aio_unref(ptr noundef %32)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_copy_source_range(i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_COPY_SOURCE_RANGE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i32, ptr %nlb.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.261, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %slba.addr, align 8
  %8 = load i32, ptr %nlb.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.262, i64 noundef %7, i32 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_copy_in_completed_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %iocb = alloca ptr, align 8
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %nlb = alloca i32, align 4
  %slba = alloca i64, align 8
  %apptag = alloca i16, align 2
  %appmask = alloca i16, align 2
  %reftag = alloca i64, align 8
  %len = alloca i64, align 8
  %status = alloca i16, align 2
  %copy = alloca ptr, align 8
  %prinfor = alloca i16, align 2
  %prinfow = alloca i16, align 2
  %mlen = alloca i64, align 8
  %mbounce = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %iocb, align 8
  %1 = load ptr, ptr %iocb, align 8
  %req1 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %req1, align 8
  store ptr %2, ptr %req, align 8
  %3 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %ns2, align 8
  store ptr %4, ptr %ns, align 8
  %5 = load i32, ptr %ret.addr, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load i32, ptr %ret.addr, align 4
  %7 = load ptr, ptr %iocb, align 8
  %ret3 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %7, i32 0, i32 3
  store i32 %6, ptr %ret3, align 8
  br label %out

if.else:                                          ; preds = %entry
  %8 = load ptr, ptr %iocb, align 8
  %ret4 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %8, i32 0, i32 3
  %9 = load i32, ptr %ret4, align 8
  %cmp5 = icmp slt i32 %9, 0
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.else
  br label %out

if.end:                                           ; preds = %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end
  %10 = load ptr, ptr %iocb, align 8
  %ranges = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %ranges, align 8
  %12 = load ptr, ptr %iocb, align 8
  %idx = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %12, i32 0, i32 7
  %13 = load i32, ptr %idx, align 8
  %14 = load ptr, ptr %iocb, align 8
  %format = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %14, i32 0, i32 5
  %15 = load i32, ptr %format, align 8
  %conv = trunc i32 %15 to i8
  call void @nvme_copy_source_range_parse(ptr noundef %11, i32 noundef %13, i8 noundef zeroext %conv, ptr noundef %slba, ptr noundef %nlb, ptr noundef %apptag, ptr noundef %appmask, ptr noundef %reftag)
  %16 = load ptr, ptr %ns, align 8
  %17 = load i32, ptr %nlb, align 4
  %conv8 = zext i32 %17 to i64
  %call = call i64 @nvme_l2b(ptr noundef %16, i64 noundef %conv8)
  store i64 %call, ptr %len, align 8
  %18 = load ptr, ptr %iocb, align 8
  %slba9 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %18, i32 0, i32 12
  %19 = load i64, ptr %slba9, align 8
  %20 = load i32, ptr %nlb, align 4
  call void @trace_pci_nvme_copy_out(i64 noundef %19, i32 noundef %20)
  %21 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %21, i32 0, i32 5
  %dps = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 8
  %22 = load i8, ptr %dps, align 1
  %conv10 = zext i8 %22 to i32
  %and = and i32 %conv10, 7
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then11, label %if.end62

if.then11:                                        ; preds = %if.end7
  %23 = load ptr, ptr %req, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %23, i32 0, i32 6
  store ptr %cmd, ptr %copy, align 8
  %24 = load ptr, ptr %copy, align 8
  %control = getelementptr inbounds %struct.NvmeCopyCmd, ptr %24, i32 0, i32 10
  %arrayidx = getelementptr [3 x i8], ptr %control, i64 0, i64 0
  %25 = load i8, ptr %arrayidx, align 1
  %conv12 = zext i8 %25 to i32
  %shr = ashr i32 %conv12, 4
  %and13 = and i32 %shr, 15
  %conv14 = trunc i32 %and13 to i16
  store i16 %conv14, ptr %prinfor, align 2
  %26 = load ptr, ptr %copy, align 8
  %control15 = getelementptr inbounds %struct.NvmeCopyCmd, ptr %26, i32 0, i32 10
  %arrayidx16 = getelementptr [3 x i8], ptr %control15, i64 0, i64 2
  %27 = load i8, ptr %arrayidx16, align 1
  %conv17 = zext i8 %27 to i32
  %shr18 = ashr i32 %conv17, 2
  %and19 = and i32 %shr18, 15
  %conv20 = trunc i32 %and19 to i16
  store i16 %conv20, ptr %prinfow, align 2
  %28 = load ptr, ptr %ns, align 8
  %29 = load i32, ptr %nlb, align 4
  %conv21 = zext i32 %29 to i64
  %call22 = call i64 @nvme_m2b(ptr noundef %28, i64 noundef %conv21)
  store i64 %call22, ptr %mlen, align 8
  %30 = load ptr, ptr %iocb, align 8
  %bounce = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %30, i32 0, i32 8
  %31 = load ptr, ptr %bounce, align 8
  %32 = load ptr, ptr %ns, align 8
  %33 = load i32, ptr %nlb, align 4
  %conv23 = zext i32 %33 to i64
  %call24 = call i64 @nvme_l2b(ptr noundef %32, i64 noundef %conv23)
  %add.ptr = getelementptr i8, ptr %31, i64 %call24
  store ptr %add.ptr, ptr %mbounce, align 8
  %34 = load ptr, ptr %ns, align 8
  %35 = load ptr, ptr %mbounce, align 8
  %36 = load i64, ptr %mlen, align 8
  %37 = load i64, ptr %slba, align 8
  %call25 = call zeroext i16 @nvme_dif_mangle_mdata(ptr noundef %34, ptr noundef %35, i64 noundef %36, i64 noundef %37)
  store i16 %call25, ptr %status, align 2
  %38 = load i16, ptr %status, align 2
  %tobool26 = icmp ne i16 %38, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.then11
  br label %invalid

if.end28:                                         ; preds = %if.then11
  %39 = load ptr, ptr %ns, align 8
  %40 = load ptr, ptr %iocb, align 8
  %bounce29 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %40, i32 0, i32 8
  %41 = load ptr, ptr %bounce29, align 8
  %42 = load i64, ptr %len, align 8
  %43 = load ptr, ptr %mbounce, align 8
  %44 = load i64, ptr %mlen, align 8
  %45 = load i16, ptr %prinfor, align 2
  %conv30 = trunc i16 %45 to i8
  %46 = load i64, ptr %slba, align 8
  %47 = load i16, ptr %apptag, align 2
  %48 = load i16, ptr %appmask, align 2
  %call31 = call zeroext i16 @nvme_dif_check(ptr noundef %39, ptr noundef %41, i64 noundef %42, ptr noundef %43, i64 noundef %44, i8 noundef zeroext %conv30, i64 noundef %46, i16 noundef zeroext %47, i16 noundef zeroext %48, ptr noundef %reftag)
  store i16 %call31, ptr %status, align 2
  %49 = load i16, ptr %status, align 2
  %tobool32 = icmp ne i16 %49, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end28
  br label %invalid

if.end34:                                         ; preds = %if.end28
  %50 = load ptr, ptr %copy, align 8
  %apptag35 = getelementptr inbounds %struct.NvmeCopyCmd, ptr %50, i32 0, i32 14
  %51 = load i16, ptr %apptag35, align 1
  %call36 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %51)
  store i16 %call36, ptr %apptag, align 2
  %52 = load ptr, ptr %copy, align 8
  %appmask37 = getelementptr inbounds %struct.NvmeCopyCmd, ptr %52, i32 0, i32 15
  %53 = load i16, ptr %appmask37, align 1
  %call38 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %53)
  store i16 %call38, ptr %appmask, align 2
  %54 = load i16, ptr %prinfow, align 2
  %conv39 = zext i16 %54 to i32
  %and40 = and i32 %conv39, 8
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %if.then42, label %if.else52

if.then42:                                        ; preds = %if.end34
  %55 = load ptr, ptr %ns, align 8
  %56 = load i16, ptr %prinfow, align 2
  %conv43 = trunc i16 %56 to i8
  %57 = load ptr, ptr %iocb, align 8
  %slba44 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %57, i32 0, i32 12
  %58 = load i64, ptr %slba44, align 8
  %59 = load ptr, ptr %iocb, align 8
  %reftag45 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %59, i32 0, i32 11
  %60 = load i64, ptr %reftag45, align 8
  %call46 = call zeroext i16 @nvme_check_prinfo(ptr noundef %55, i8 noundef zeroext %conv43, i64 noundef %58, i64 noundef %60)
  store i16 %call46, ptr %status, align 2
  %61 = load i16, ptr %status, align 2
  %tobool47 = icmp ne i16 %61, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.then42
  br label %invalid

if.end49:                                         ; preds = %if.then42
  %62 = load ptr, ptr %ns, align 8
  %63 = load ptr, ptr %iocb, align 8
  %bounce50 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %63, i32 0, i32 8
  %64 = load ptr, ptr %bounce50, align 8
  %65 = load i64, ptr %len, align 8
  %66 = load ptr, ptr %mbounce, align 8
  %67 = load i64, ptr %mlen, align 8
  %68 = load i16, ptr %apptag, align 2
  %69 = load ptr, ptr %iocb, align 8
  %reftag51 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %69, i32 0, i32 11
  call void @nvme_dif_pract_generate_dif(ptr noundef %62, ptr noundef %64, i64 noundef %65, ptr noundef %66, i64 noundef %67, i16 noundef zeroext %68, ptr noundef %reftag51)
  br label %if.end61

if.else52:                                        ; preds = %if.end34
  %70 = load ptr, ptr %ns, align 8
  %71 = load ptr, ptr %iocb, align 8
  %bounce53 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %71, i32 0, i32 8
  %72 = load ptr, ptr %bounce53, align 8
  %73 = load i64, ptr %len, align 8
  %74 = load ptr, ptr %mbounce, align 8
  %75 = load i64, ptr %mlen, align 8
  %76 = load i16, ptr %prinfow, align 2
  %conv54 = trunc i16 %76 to i8
  %77 = load ptr, ptr %iocb, align 8
  %slba55 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %77, i32 0, i32 12
  %78 = load i64, ptr %slba55, align 8
  %79 = load i16, ptr %apptag, align 2
  %80 = load i16, ptr %appmask, align 2
  %81 = load ptr, ptr %iocb, align 8
  %reftag56 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %81, i32 0, i32 11
  %call57 = call zeroext i16 @nvme_dif_check(ptr noundef %70, ptr noundef %72, i64 noundef %73, ptr noundef %74, i64 noundef %75, i8 noundef zeroext %conv54, i64 noundef %78, i16 noundef zeroext %79, i16 noundef zeroext %80, ptr noundef %reftag56)
  store i16 %call57, ptr %status, align 2
  %82 = load i16, ptr %status, align 2
  %tobool58 = icmp ne i16 %82, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.else52
  br label %invalid

if.end60:                                         ; preds = %if.else52
  br label %if.end61

if.end61:                                         ; preds = %if.end60, %if.end49
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %if.end7
  %83 = load ptr, ptr %ns, align 8
  %84 = load ptr, ptr %iocb, align 8
  %slba63 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %84, i32 0, i32 12
  %85 = load i64, ptr %slba63, align 8
  %86 = load i32, ptr %nlb, align 4
  %call64 = call zeroext i16 @nvme_check_bounds(ptr noundef %83, i64 noundef %85, i32 noundef %86)
  store i16 %call64, ptr %status, align 2
  %87 = load i16, ptr %status, align 2
  %tobool65 = icmp ne i16 %87, 0
  br i1 %tobool65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.end62
  br label %invalid

if.end67:                                         ; preds = %if.end62
  %88 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %88, i32 0, i32 30
  %zoned = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 14
  %89 = load i8, ptr %zoned, align 1
  %tobool68 = trunc i8 %89 to i1
  br i1 %tobool68, label %if.then69, label %if.end83

if.then69:                                        ; preds = %if.end67
  %90 = load ptr, ptr %ns, align 8
  %91 = load ptr, ptr %iocb, align 8
  %zone = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %91, i32 0, i32 13
  %92 = load ptr, ptr %zone, align 8
  %93 = load ptr, ptr %iocb, align 8
  %slba70 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %93, i32 0, i32 12
  %94 = load i64, ptr %slba70, align 8
  %95 = load i32, ptr %nlb, align 4
  %call71 = call zeroext i16 @nvme_check_zone_write(ptr noundef %90, ptr noundef %92, i64 noundef %94, i32 noundef %95)
  store i16 %call71, ptr %status, align 2
  %96 = load i16, ptr %status, align 2
  %tobool72 = icmp ne i16 %96, 0
  br i1 %tobool72, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.then69
  br label %invalid

if.end74:                                         ; preds = %if.then69
  %97 = load ptr, ptr %iocb, align 8
  %zone75 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %97, i32 0, i32 13
  %98 = load ptr, ptr %zone75, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %98, i32 0, i32 0
  %za = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 2
  %99 = load i8, ptr %za, align 2
  %conv76 = zext i8 %99 to i32
  %and77 = and i32 %conv76, 8
  %tobool78 = icmp ne i32 %and77, 0
  br i1 %tobool78, label %if.end82, label %if.then79

if.then79:                                        ; preds = %if.end74
  %100 = load i32, ptr %nlb, align 4
  %conv80 = zext i32 %100 to i64
  %101 = load ptr, ptr %iocb, align 8
  %zone81 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %101, i32 0, i32 13
  %102 = load ptr, ptr %zone81, align 8
  %w_ptr = getelementptr inbounds %struct.NvmeZone, ptr %102, i32 0, i32 1
  %103 = load i64, ptr %w_ptr, align 8
  %add = add i64 %103, %conv80
  store i64 %add, ptr %w_ptr, align 8
  br label %if.end82

if.end82:                                         ; preds = %if.then79, %if.end74
  br label %if.end83

if.end83:                                         ; preds = %if.end82, %if.end67
  %104 = load ptr, ptr %iocb, align 8
  %iov = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %104, i32 0, i32 9
  call void @qemu_iovec_reset(ptr noundef %iov)
  %105 = load ptr, ptr %iocb, align 8
  %iov84 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %105, i32 0, i32 9
  %106 = load ptr, ptr %iocb, align 8
  %bounce85 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %106, i32 0, i32 8
  %107 = load ptr, ptr %bounce85, align 8
  %108 = load i64, ptr %len, align 8
  call void @qemu_iovec_add(ptr noundef %iov84, ptr noundef %107, i64 noundef %108)
  %109 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %109, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %110 = load ptr, ptr %blk, align 8
  %111 = load ptr, ptr %ns, align 8
  %112 = load ptr, ptr %iocb, align 8
  %slba86 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %112, i32 0, i32 12
  %113 = load i64, ptr %slba86, align 8
  %call87 = call i64 @nvme_l2b(ptr noundef %111, i64 noundef %113)
  %114 = load ptr, ptr %iocb, align 8
  %iov88 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %114, i32 0, i32 9
  %115 = load ptr, ptr %iocb, align 8
  %call89 = call ptr @blk_aio_pwritev(ptr noundef %110, i64 noundef %call87, ptr noundef %iov88, i32 noundef 0, ptr noundef @nvme_copy_out_cb, ptr noundef %115)
  %116 = load ptr, ptr %iocb, align 8
  %aiocb = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %116, i32 0, i32 1
  store ptr %call89, ptr %aiocb, align 8
  br label %return

invalid:                                          ; preds = %if.then73, %if.then66, %if.then59, %if.then48, %if.then33, %if.then27
  %117 = load i16, ptr %status, align 2
  %118 = load ptr, ptr %req, align 8
  %status90 = getelementptr inbounds %struct.NvmeRequest, ptr %118, i32 0, i32 3
  store i16 %117, ptr %status90, align 8
  %119 = load ptr, ptr %iocb, align 8
  %ret91 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %119, i32 0, i32 3
  store i32 -1, ptr %ret91, align 8
  br label %out

out:                                              ; preds = %invalid, %if.then6, %if.then
  %120 = load ptr, ptr %iocb, align 8
  call void @nvme_do_copy(ptr noundef %120)
  br label %return

return:                                           ; preds = %out, %if.end83
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_copy_out(i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i32, ptr %nlb.addr, align 4
  call void @_nocheck__trace_pci_nvme_copy_out(i64 noundef %0, i32 noundef %1)
  ret void
}

declare void @nvme_dif_pract_generate_dif(ptr noundef, ptr noundef, i64 noundef, ptr noundef, i64 noundef, i16 noundef zeroext, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_copy_out_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %iocb = alloca ptr, align 8
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %nlb = alloca i32, align 4
  %mlen = alloca i64, align 8
  %mbounce = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %iocb, align 8
  %1 = load ptr, ptr %iocb, align 8
  %req1 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %req1, align 8
  store ptr %2, ptr %req, align 8
  %3 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %ns2, align 8
  store ptr %4, ptr %ns, align 8
  %5 = load i32, ptr %ret.addr, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load ptr, ptr %iocb, align 8
  %ret3 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %6, i32 0, i32 3
  %7 = load i32, ptr %ret3, align 8
  %cmp4 = icmp slt i32 %7, 0
  br i1 %cmp4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %8 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %8, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %9 = load i16, ptr %ms, align 8
  %tobool = icmp ne i16 %9, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false5, %lor.lhs.false, %entry
  br label %out

if.end:                                           ; preds = %lor.lhs.false5
  %10 = load ptr, ptr %iocb, align 8
  %ranges = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %ranges, align 8
  %12 = load ptr, ptr %iocb, align 8
  %idx = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %12, i32 0, i32 7
  %13 = load i32, ptr %idx, align 8
  %14 = load ptr, ptr %iocb, align 8
  %format = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %14, i32 0, i32 5
  %15 = load i32, ptr %format, align 8
  %conv = trunc i32 %15 to i8
  call void @nvme_copy_source_range_parse(ptr noundef %11, i32 noundef %13, i8 noundef zeroext %conv, ptr noundef null, ptr noundef %nlb, ptr noundef null, ptr noundef null, ptr noundef null)
  %16 = load ptr, ptr %ns, align 8
  %17 = load i32, ptr %nlb, align 4
  %conv6 = zext i32 %17 to i64
  %call = call i64 @nvme_m2b(ptr noundef %16, i64 noundef %conv6)
  store i64 %call, ptr %mlen, align 8
  %18 = load ptr, ptr %iocb, align 8
  %bounce = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %18, i32 0, i32 8
  %19 = load ptr, ptr %bounce, align 8
  %20 = load ptr, ptr %ns, align 8
  %21 = load i32, ptr %nlb, align 4
  %conv7 = zext i32 %21 to i64
  %call8 = call i64 @nvme_l2b(ptr noundef %20, i64 noundef %conv7)
  %add.ptr = getelementptr i8, ptr %19, i64 %call8
  store ptr %add.ptr, ptr %mbounce, align 8
  %22 = load ptr, ptr %iocb, align 8
  %iov = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %22, i32 0, i32 9
  call void @qemu_iovec_reset(ptr noundef %iov)
  %23 = load ptr, ptr %iocb, align 8
  %iov9 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %23, i32 0, i32 9
  %24 = load ptr, ptr %mbounce, align 8
  %25 = load i64, ptr %mlen, align 8
  call void @qemu_iovec_add(ptr noundef %iov9, ptr noundef %24, i64 noundef %25)
  %26 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %26, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %27 = load ptr, ptr %blk, align 8
  %28 = load ptr, ptr %ns, align 8
  %29 = load ptr, ptr %iocb, align 8
  %slba = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %29, i32 0, i32 12
  %30 = load i64, ptr %slba, align 8
  %call10 = call i64 @nvme_moff(ptr noundef %28, i64 noundef %30)
  %31 = load ptr, ptr %iocb, align 8
  %iov11 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %31, i32 0, i32 9
  %32 = load ptr, ptr %iocb, align 8
  %call12 = call ptr @blk_aio_pwritev(ptr noundef %27, i64 noundef %call10, ptr noundef %iov11, i32 noundef 0, ptr noundef @nvme_copy_out_completed_cb, ptr noundef %32)
  %33 = load ptr, ptr %iocb, align 8
  %aiocb = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %33, i32 0, i32 1
  store ptr %call12, ptr %aiocb, align 8
  br label %return

out:                                              ; preds = %if.then
  %34 = load ptr, ptr %iocb, align 8
  %35 = load i32, ptr %ret.addr, align 4
  call void @nvme_copy_out_completed_cb(ptr noundef %34, i32 noundef %35)
  br label %return

return:                                           ; preds = %out, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_copy_out(i64 noundef %slba, i32 noundef %nlb) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %nlb.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %nlb, ptr %nlb.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_COPY_OUT_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i32, ptr %nlb.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.263, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %slba.addr, align 8
  %8 = load i32, ptr %nlb.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.264, i64 noundef %7, i32 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_copy_out_completed_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %iocb = alloca ptr, align 8
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %nlb = alloca i32, align 4
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %iocb, align 8
  %1 = load ptr, ptr %iocb, align 8
  %req1 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %req1, align 8
  store ptr %2, ptr %req, align 8
  %3 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %ns2, align 8
  store ptr %4, ptr %ns, align 8
  %5 = load ptr, ptr %iocb, align 8
  %ranges = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %5, i32 0, i32 4
  %6 = load ptr, ptr %ranges, align 8
  %7 = load ptr, ptr %iocb, align 8
  %idx = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %7, i32 0, i32 7
  %8 = load i32, ptr %idx, align 8
  %9 = load ptr, ptr %iocb, align 8
  %format = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %9, i32 0, i32 5
  %10 = load i32, ptr %format, align 8
  %conv = trunc i32 %10 to i8
  call void @nvme_copy_source_range_parse(ptr noundef %6, i32 noundef %8, i8 noundef zeroext %conv, ptr noundef null, ptr noundef %nlb, ptr noundef null, ptr noundef null, ptr noundef null)
  %11 = load i32, ptr %ret.addr, align 4
  %cmp = icmp slt i32 %11, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %12 = load i32, ptr %ret.addr, align 4
  %13 = load ptr, ptr %iocb, align 8
  %ret4 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %13, i32 0, i32 3
  store i32 %12, ptr %ret4, align 8
  br label %out

if.else:                                          ; preds = %entry
  %14 = load ptr, ptr %iocb, align 8
  %ret5 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %14, i32 0, i32 3
  %15 = load i32, ptr %ret5, align 8
  %cmp6 = icmp slt i32 %15, 0
  br i1 %cmp6, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else
  br label %out

if.end:                                           ; preds = %if.else
  br label %if.end9

if.end9:                                          ; preds = %if.end
  %16 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %16, i32 0, i32 30
  %zoned = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 14
  %17 = load i8, ptr %zoned, align 1
  %tobool = trunc i8 %17 to i1
  br i1 %tobool, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end9
  %18 = load ptr, ptr %ns, align 8
  %19 = load ptr, ptr %iocb, align 8
  %zone = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %19, i32 0, i32 13
  %20 = load ptr, ptr %zone, align 8
  %21 = load i32, ptr %nlb, align 4
  call void @nvme_advance_zone_wp(ptr noundef %18, ptr noundef %20, i32 noundef %21)
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.end9
  %22 = load ptr, ptr %iocb, align 8
  %idx12 = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %22, i32 0, i32 7
  %23 = load i32, ptr %idx12, align 8
  %inc = add i32 %23, 1
  store i32 %inc, ptr %idx12, align 8
  %24 = load i32, ptr %nlb, align 4
  %conv13 = zext i32 %24 to i64
  %25 = load ptr, ptr %iocb, align 8
  %slba = getelementptr inbounds %struct.NvmeCopyAIOCB, ptr %25, i32 0, i32 12
  %26 = load i64, ptr %slba, align 8
  %add = add i64 %26, %conv13
  store i64 %add, ptr %slba, align 8
  br label %out

out:                                              ; preds = %if.end11, %if.then8, %if.then
  %27 = load ptr, ptr %iocb, align 8
  call void @nvme_do_copy(ptr noundef %27)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_get_mgmt_zone_slba_idx(ptr noundef %ns, ptr noundef %c, ptr noundef %slba, ptr noundef %zone_idx) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  %slba.addr = alloca ptr, align 8
  %zone_idx.addr = alloca ptr, align 8
  %dw10 = alloca i32, align 4
  %dw11 = alloca i32, align 4
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %slba, ptr %slba.addr, align 8
  store ptr %zone_idx, ptr %zone_idx.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %cdw10 = getelementptr inbounds %struct.NvmeCmd, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %cdw10, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %1)
  store i32 %call, ptr %dw10, align 4
  %2 = load ptr, ptr %c.addr, align 8
  %cdw11 = getelementptr inbounds %struct.NvmeCmd, ptr %2, i32 0, i32 8
  %3 = load i32, ptr %cdw11, align 1
  %call1 = call i32 @le32_to_cpu(i32 noundef %3)
  store i32 %call1, ptr %dw11, align 4
  %4 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %4, i32 0, i32 30
  %zoned = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 14
  %5 = load i8, ptr %zoned, align 1
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %c.addr, align 8
  %opcode = getelementptr inbounds %struct.NvmeCmd, ptr %6, i32 0, i32 0
  %7 = load i8, ptr %opcode, align 1
  call void @trace_pci_nvme_err_invalid_opc(i8 noundef zeroext %7)
  store i16 16385, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %8 = load i32, ptr %dw11, align 4
  %conv = zext i32 %8 to i64
  %shl = shl i64 %conv, 32
  %9 = load i32, ptr %dw10, align 4
  %conv2 = zext i32 %9 to i64
  %or = or i64 %shl, %conv2
  %10 = load ptr, ptr %slba.addr, align 8
  store i64 %or, ptr %10, align 8
  %11 = load ptr, ptr %slba.addr, align 8
  %12 = load i64, ptr %11, align 8
  %13 = load ptr, ptr %ns.addr, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %13, i32 0, i32 5
  %nsze = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 0
  %14 = load i64, ptr %nsze, align 8
  %cmp = icmp uge i64 %12, %14
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %tobool6 = icmp ne i64 %conv5, 0
  br i1 %tobool6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end
  %15 = load ptr, ptr %slba.addr, align 8
  %16 = load i64, ptr %15, align 8
  %17 = load ptr, ptr %ns.addr, align 8
  %id_ns8 = getelementptr inbounds %struct.NvmeNamespace, ptr %17, i32 0, i32 5
  %nsze9 = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns8, i32 0, i32 0
  %18 = load i64, ptr %nsze9, align 8
  call void @trace_pci_nvme_err_invalid_lba_range(i64 noundef %16, i64 noundef 0, i64 noundef %18)
  %19 = load ptr, ptr %slba.addr, align 8
  store i64 0, ptr %19, align 8
  store i16 16512, ptr %retval, align 2
  br label %return

if.end10:                                         ; preds = %if.end
  %20 = load ptr, ptr %ns.addr, align 8
  %21 = load ptr, ptr %slba.addr, align 8
  %22 = load i64, ptr %21, align 8
  %call11 = call i32 @nvme_zone_idx(ptr noundef %20, i64 noundef %22)
  %23 = load ptr, ptr %zone_idx.addr, align 8
  store i32 %call11, ptr %23, align 4
  %24 = load ptr, ptr %zone_idx.addr, align 8
  %25 = load i32, ptr %24, align 4
  %26 = load ptr, ptr %ns.addr, align 8
  %num_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %26, i32 0, i32 23
  %27 = load i32, ptr %num_zones, align 8
  %cmp12 = icmp ult i32 %25, %27
  br i1 %cmp12, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end10
  br label %if.end15

if.else:                                          ; preds = %if.end10
  call void @__assert_fail(ptr noundef @.str.265, ptr noundef @.str.1, i32 noundef 3683, ptr noundef @__PRETTY_FUNCTION__.nvme_get_mgmt_zone_slba_idx) #12
  unreachable

if.end15:                                         ; preds = %if.then14
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end15, %if.then7, %if.then
  %28 = load i16, ptr %retval, align 2
  ret i16 %28
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_unaligned_zone_cmd(i8 noundef zeroext %action, i64 noundef %slba, i64 noundef %zslba) #0 {
entry:
  %action.addr = alloca i8, align 1
  %slba.addr = alloca i64, align 8
  %zslba.addr = alloca i64, align 8
  store i8 %action, ptr %action.addr, align 1
  store i64 %slba, ptr %slba.addr, align 8
  store i64 %zslba, ptr %zslba.addr, align 8
  %0 = load i8, ptr %action.addr, align 1
  %1 = load i64, ptr %slba.addr, align 8
  %2 = load i64, ptr %zslba.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_unaligned_zone_cmd(i8 noundef zeroext %0, i64 noundef %1, i64 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_open_zone(i64 noundef %slba, i32 noundef %zone_idx, i32 noundef %all) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone_idx.addr = alloca i32, align 4
  %all.addr = alloca i32, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  store i32 %all, ptr %all.addr, align 4
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i32, ptr %zone_idx.addr, align 4
  %2 = load i32, ptr %all.addr, align 4
  call void @_nocheck__trace_pci_nvme_open_zone(i64 noundef %0, i32 noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_do_zone_op(ptr noundef %ns, ptr noundef %zone, i32 noundef %proc_mask, ptr noundef %op_hndlr, ptr noundef %req) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %proc_mask.addr = alloca i32, align 4
  %op_hndlr.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %next = alloca ptr, align 8
  %status = alloca i16, align 2
  %i = alloca i32, align 4
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  store i32 %proc_mask, ptr %proc_mask.addr, align 4
  store ptr %op_hndlr, ptr %op_hndlr.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  store i16 0, ptr %status, align 2
  %0 = load i32, ptr %proc_mask.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %op_hndlr.addr, align 8
  %2 = load ptr, ptr %ns.addr, align 8
  %3 = load ptr, ptr %zone.addr, align 8
  %4 = load ptr, ptr %zone.addr, align 8
  %call = call i32 @nvme_get_zone_state(ptr noundef %4)
  %5 = load ptr, ptr %req.addr, align 8
  %call1 = call zeroext i16 %1(ptr noundef %2, ptr noundef %3, i32 noundef %call, ptr noundef %5)
  store i16 %call1, ptr %status, align 2
  br label %if.end90

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %proc_mask.addr, align 4
  %and = and i32 %6, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then3, label %if.end11

if.then3:                                         ; preds = %if.else
  %7 = load ptr, ptr %ns.addr, align 8
  %closed_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %7, i32 0, i32 21
  %8 = load ptr, ptr %closed_zones, align 8
  store ptr %8, ptr %zone.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %9 = load ptr, ptr %zone.addr, align 8
  %tobool4 = icmp ne ptr %9, null
  br i1 %tobool4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %10 = load ptr, ptr %zone.addr, align 8
  %entry5 = getelementptr inbounds %struct.NvmeZone, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %entry5, align 8
  store ptr %11, ptr %next, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %12 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %12, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %13 = load ptr, ptr %ns.addr, align 8
  %14 = load ptr, ptr %zone.addr, align 8
  %15 = load i32, ptr %proc_mask.addr, align 4
  %16 = load ptr, ptr %op_hndlr.addr, align 8
  %17 = load ptr, ptr %req.addr, align 8
  %call6 = call zeroext i16 @nvme_bulk_proc_zone(ptr noundef %13, ptr noundef %14, i32 noundef %15, ptr noundef %16, ptr noundef %17)
  store i16 %call6, ptr %status, align 2
  %18 = load i16, ptr %status, align 2
  %conv = zext i16 %18 to i32
  %tobool7 = icmp ne i32 %conv, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %19 = load i16, ptr %status, align 2
  %conv8 = zext i16 %19 to i32
  %cmp = icmp ne i32 %conv8, 65535
  br i1 %cmp, label %if.then10, label %if.end

if.then10:                                        ; preds = %land.lhs.true
  br label %out

if.end:                                           ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %20 = load ptr, ptr %next, align 8
  store ptr %20, ptr %zone.addr, align 8
  br label %for.cond, !llvm.loop !35

for.end:                                          ; preds = %land.end
  br label %if.end11

if.end11:                                         ; preds = %for.end, %if.else
  %21 = load i32, ptr %proc_mask.addr, align 4
  %and12 = and i32 %21, 1
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then14, label %if.end49

if.then14:                                        ; preds = %if.end11
  %22 = load ptr, ptr %ns.addr, align 8
  %imp_open_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %22, i32 0, i32 20
  %23 = load ptr, ptr %imp_open_zones, align 8
  store ptr %23, ptr %zone.addr, align 8
  br label %for.cond15

for.cond15:                                       ; preds = %for.inc30, %if.then14
  %24 = load ptr, ptr %zone.addr, align 8
  %tobool16 = icmp ne ptr %24, null
  br i1 %tobool16, label %land.rhs17, label %land.end19

land.rhs17:                                       ; preds = %for.cond15
  %25 = load ptr, ptr %zone.addr, align 8
  %entry18 = getelementptr inbounds %struct.NvmeZone, ptr %25, i32 0, i32 2
  %26 = load ptr, ptr %entry18, align 8
  store ptr %26, ptr %next, align 8
  br label %land.end19

land.end19:                                       ; preds = %land.rhs17, %for.cond15
  %27 = phi i1 [ false, %for.cond15 ], [ true, %land.rhs17 ]
  br i1 %27, label %for.body20, label %for.end31

for.body20:                                       ; preds = %land.end19
  %28 = load ptr, ptr %ns.addr, align 8
  %29 = load ptr, ptr %zone.addr, align 8
  %30 = load i32, ptr %proc_mask.addr, align 4
  %31 = load ptr, ptr %op_hndlr.addr, align 8
  %32 = load ptr, ptr %req.addr, align 8
  %call21 = call zeroext i16 @nvme_bulk_proc_zone(ptr noundef %28, ptr noundef %29, i32 noundef %30, ptr noundef %31, ptr noundef %32)
  store i16 %call21, ptr %status, align 2
  %33 = load i16, ptr %status, align 2
  %conv22 = zext i16 %33 to i32
  %tobool23 = icmp ne i32 %conv22, 0
  br i1 %tobool23, label %land.lhs.true24, label %if.end29

land.lhs.true24:                                  ; preds = %for.body20
  %34 = load i16, ptr %status, align 2
  %conv25 = zext i16 %34 to i32
  %cmp26 = icmp ne i32 %conv25, 65535
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %land.lhs.true24
  br label %out

if.end29:                                         ; preds = %land.lhs.true24, %for.body20
  br label %for.inc30

for.inc30:                                        ; preds = %if.end29
  %35 = load ptr, ptr %next, align 8
  store ptr %35, ptr %zone.addr, align 8
  br label %for.cond15, !llvm.loop !36

for.end31:                                        ; preds = %land.end19
  %36 = load ptr, ptr %ns.addr, align 8
  %exp_open_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %36, i32 0, i32 19
  %37 = load ptr, ptr %exp_open_zones, align 8
  store ptr %37, ptr %zone.addr, align 8
  br label %for.cond32

for.cond32:                                       ; preds = %for.inc47, %for.end31
  %38 = load ptr, ptr %zone.addr, align 8
  %tobool33 = icmp ne ptr %38, null
  br i1 %tobool33, label %land.rhs34, label %land.end36

land.rhs34:                                       ; preds = %for.cond32
  %39 = load ptr, ptr %zone.addr, align 8
  %entry35 = getelementptr inbounds %struct.NvmeZone, ptr %39, i32 0, i32 2
  %40 = load ptr, ptr %entry35, align 8
  store ptr %40, ptr %next, align 8
  br label %land.end36

land.end36:                                       ; preds = %land.rhs34, %for.cond32
  %41 = phi i1 [ false, %for.cond32 ], [ true, %land.rhs34 ]
  br i1 %41, label %for.body37, label %for.end48

for.body37:                                       ; preds = %land.end36
  %42 = load ptr, ptr %ns.addr, align 8
  %43 = load ptr, ptr %zone.addr, align 8
  %44 = load i32, ptr %proc_mask.addr, align 4
  %45 = load ptr, ptr %op_hndlr.addr, align 8
  %46 = load ptr, ptr %req.addr, align 8
  %call38 = call zeroext i16 @nvme_bulk_proc_zone(ptr noundef %42, ptr noundef %43, i32 noundef %44, ptr noundef %45, ptr noundef %46)
  store i16 %call38, ptr %status, align 2
  %47 = load i16, ptr %status, align 2
  %conv39 = zext i16 %47 to i32
  %tobool40 = icmp ne i32 %conv39, 0
  br i1 %tobool40, label %land.lhs.true41, label %if.end46

land.lhs.true41:                                  ; preds = %for.body37
  %48 = load i16, ptr %status, align 2
  %conv42 = zext i16 %48 to i32
  %cmp43 = icmp ne i32 %conv42, 65535
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %land.lhs.true41
  br label %out

if.end46:                                         ; preds = %land.lhs.true41, %for.body37
  br label %for.inc47

for.inc47:                                        ; preds = %if.end46
  %49 = load ptr, ptr %next, align 8
  store ptr %49, ptr %zone.addr, align 8
  br label %for.cond32, !llvm.loop !37

for.end48:                                        ; preds = %land.end36
  br label %if.end49

if.end49:                                         ; preds = %for.end48, %if.end11
  %50 = load i32, ptr %proc_mask.addr, align 4
  %and50 = and i32 %50, 8
  %tobool51 = icmp ne i32 %and50, 0
  br i1 %tobool51, label %if.then52, label %if.end70

if.then52:                                        ; preds = %if.end49
  %51 = load ptr, ptr %ns.addr, align 8
  %full_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %51, i32 0, i32 22
  %52 = load ptr, ptr %full_zones, align 8
  store ptr %52, ptr %zone.addr, align 8
  br label %for.cond53

for.cond53:                                       ; preds = %for.inc68, %if.then52
  %53 = load ptr, ptr %zone.addr, align 8
  %tobool54 = icmp ne ptr %53, null
  br i1 %tobool54, label %land.rhs55, label %land.end57

land.rhs55:                                       ; preds = %for.cond53
  %54 = load ptr, ptr %zone.addr, align 8
  %entry56 = getelementptr inbounds %struct.NvmeZone, ptr %54, i32 0, i32 2
  %55 = load ptr, ptr %entry56, align 8
  store ptr %55, ptr %next, align 8
  br label %land.end57

land.end57:                                       ; preds = %land.rhs55, %for.cond53
  %56 = phi i1 [ false, %for.cond53 ], [ true, %land.rhs55 ]
  br i1 %56, label %for.body58, label %for.end69

for.body58:                                       ; preds = %land.end57
  %57 = load ptr, ptr %ns.addr, align 8
  %58 = load ptr, ptr %zone.addr, align 8
  %59 = load i32, ptr %proc_mask.addr, align 4
  %60 = load ptr, ptr %op_hndlr.addr, align 8
  %61 = load ptr, ptr %req.addr, align 8
  %call59 = call zeroext i16 @nvme_bulk_proc_zone(ptr noundef %57, ptr noundef %58, i32 noundef %59, ptr noundef %60, ptr noundef %61)
  store i16 %call59, ptr %status, align 2
  %62 = load i16, ptr %status, align 2
  %conv60 = zext i16 %62 to i32
  %tobool61 = icmp ne i32 %conv60, 0
  br i1 %tobool61, label %land.lhs.true62, label %if.end67

land.lhs.true62:                                  ; preds = %for.body58
  %63 = load i16, ptr %status, align 2
  %conv63 = zext i16 %63 to i32
  %cmp64 = icmp ne i32 %conv63, 65535
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %land.lhs.true62
  br label %out

if.end67:                                         ; preds = %land.lhs.true62, %for.body58
  br label %for.inc68

for.inc68:                                        ; preds = %if.end67
  %64 = load ptr, ptr %next, align 8
  store ptr %64, ptr %zone.addr, align 8
  br label %for.cond53, !llvm.loop !38

for.end69:                                        ; preds = %land.end57
  br label %if.end70

if.end70:                                         ; preds = %for.end69, %if.end49
  %65 = load i32, ptr %proc_mask.addr, align 4
  %and71 = and i32 %65, 4
  %tobool72 = icmp ne i32 %and71, 0
  br i1 %tobool72, label %if.then73, label %if.end89

if.then73:                                        ; preds = %if.end70
  store i32 0, ptr %i, align 4
  br label %for.cond74

for.cond74:                                       ; preds = %for.inc87, %if.then73
  %66 = load i32, ptr %i, align 4
  %67 = load ptr, ptr %ns.addr, align 8
  %num_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %67, i32 0, i32 23
  %68 = load i32, ptr %num_zones, align 8
  %cmp75 = icmp ult i32 %66, %68
  br i1 %cmp75, label %for.body77, label %for.end88

for.body77:                                       ; preds = %for.cond74
  %69 = load ptr, ptr %ns.addr, align 8
  %70 = load ptr, ptr %zone.addr, align 8
  %71 = load i32, ptr %proc_mask.addr, align 4
  %72 = load ptr, ptr %op_hndlr.addr, align 8
  %73 = load ptr, ptr %req.addr, align 8
  %call78 = call zeroext i16 @nvme_bulk_proc_zone(ptr noundef %69, ptr noundef %70, i32 noundef %71, ptr noundef %72, ptr noundef %73)
  store i16 %call78, ptr %status, align 2
  %74 = load i16, ptr %status, align 2
  %conv79 = zext i16 %74 to i32
  %tobool80 = icmp ne i32 %conv79, 0
  br i1 %tobool80, label %land.lhs.true81, label %if.end86

land.lhs.true81:                                  ; preds = %for.body77
  %75 = load i16, ptr %status, align 2
  %conv82 = zext i16 %75 to i32
  %cmp83 = icmp ne i32 %conv82, 65535
  br i1 %cmp83, label %if.then85, label %if.end86

if.then85:                                        ; preds = %land.lhs.true81
  br label %out

if.end86:                                         ; preds = %land.lhs.true81, %for.body77
  br label %for.inc87

for.inc87:                                        ; preds = %if.end86
  %76 = load i32, ptr %i, align 4
  %inc = add i32 %76, 1
  store i32 %inc, ptr %i, align 4
  %77 = load ptr, ptr %zone.addr, align 8
  %incdec.ptr = getelementptr %struct.NvmeZone, ptr %77, i32 1
  store ptr %incdec.ptr, ptr %zone.addr, align 8
  br label %for.cond74, !llvm.loop !39

for.end88:                                        ; preds = %for.cond74
  br label %if.end89

if.end89:                                         ; preds = %for.end88, %if.end70
  br label %if.end90

if.end90:                                         ; preds = %if.end89, %if.then
  br label %out

out:                                              ; preds = %if.end90, %if.then85, %if.then66, %if.then45, %if.then28, %if.then10
  %78 = load i16, ptr %status, align 2
  ret i16 %78
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_open_zone(ptr noundef %ns, ptr noundef %zone, i32 noundef %state, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %state.addr = alloca i32, align 4
  %req.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %flags = alloca i32, align 4
  %ozcs = alloca i16, align 2
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  store i32 %state, ptr %state.addr, align 4
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd1, ptr %cmd, align 8
  store i32 0, ptr %flags, align 4
  %1 = load ptr, ptr %cmd, align 8
  %zsflags = getelementptr inbounds %struct.NvmeZoneSendCmd, ptr %1, i32 0, i32 9
  %2 = load i8, ptr %zsflags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end11

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %ns.addr, align 8
  %id_ns_zoned = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 17
  %4 = load ptr, ptr %id_ns_zoned, align 8
  %ozcs2 = getelementptr inbounds %struct.NvmeIdNsZoned, ptr %4, i32 0, i32 1
  %5 = load i16, ptr %ozcs2, align 1
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %5)
  store i16 %call, ptr %ozcs, align 2
  %6 = load i16, ptr %ozcs, align 2
  %conv3 = zext i16 %6 to i32
  %and4 = and i32 %conv3, 2
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.end, label %if.then6

if.then6:                                         ; preds = %if.then
  store i16 16822, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %if.then
  %7 = load ptr, ptr %zone.addr, align 8
  %w_ptr = getelementptr inbounds %struct.NvmeZone, ptr %7, i32 0, i32 1
  %8 = load i64, ptr %w_ptr, align 8
  %9 = load ptr, ptr %ns.addr, align 8
  %zns = getelementptr inbounds %struct.NvmeNamespace, ptr %9, i32 0, i32 15
  %zrwafg = getelementptr inbounds %struct.anon.4, ptr %zns, i32 0, i32 1
  %10 = load i16, ptr %zrwafg, align 2
  %conv7 = zext i16 %10 to i64
  %rem = urem i64 %8, %conv7
  %tobool8 = icmp ne i64 %rem, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  store i16 16823, ptr %retval, align 2
  br label %return

if.end10:                                         ; preds = %if.end
  store i32 2, ptr %flags, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %entry
  %11 = load ptr, ptr %req.addr, align 8
  %call12 = call ptr @nvme_ctrl(ptr noundef %11)
  %12 = load ptr, ptr %ns.addr, align 8
  %13 = load ptr, ptr %zone.addr, align 8
  %14 = load i32, ptr %flags, align 4
  %call13 = call zeroext i16 @nvme_zrm_open_flags(ptr noundef %call12, ptr noundef %12, ptr noundef %13, i32 noundef %14)
  store i16 %call13, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end11, %if.then9, %if.then6
  %15 = load i16, ptr %retval, align 2
  ret i16 %15
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_close_zone(i64 noundef %slba, i32 noundef %zone_idx, i32 noundef %all) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone_idx.addr = alloca i32, align 4
  %all.addr = alloca i32, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  store i32 %all, ptr %all.addr, align 4
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i32, ptr %zone_idx.addr, align 4
  %2 = load i32, ptr %all.addr, align 4
  call void @_nocheck__trace_pci_nvme_close_zone(i64 noundef %0, i32 noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_close_zone(ptr noundef %ns, ptr noundef %zone, i32 noundef %state, ptr noundef %req) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %state.addr = alloca i32, align 4
  %req.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  store i32 %state, ptr %state.addr, align 4
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %1 = load ptr, ptr %zone.addr, align 8
  %call = call zeroext i16 @nvme_zrm_close(ptr noundef %0, ptr noundef %1)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_finish_zone(i64 noundef %slba, i32 noundef %zone_idx, i32 noundef %all) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone_idx.addr = alloca i32, align 4
  %all.addr = alloca i32, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  store i32 %all, ptr %all.addr, align 4
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i32, ptr %zone_idx.addr, align 4
  %2 = load i32, ptr %all.addr, align 4
  call void @_nocheck__trace_pci_nvme_finish_zone(i64 noundef %0, i32 noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_finish_zone(ptr noundef %ns, ptr noundef %zone, i32 noundef %state, ptr noundef %req) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %state.addr = alloca i32, align 4
  %req.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  store i32 %state, ptr %state.addr, align 4
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %1 = load ptr, ptr %zone.addr, align 8
  %call = call zeroext i16 @nvme_zrm_finish(ptr noundef %0, ptr noundef %1)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_reset_zone(i64 noundef %slba, i32 noundef %zone_idx, i32 noundef %all) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone_idx.addr = alloca i32, align 4
  %all.addr = alloca i32, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  store i32 %all, ptr %all.addr, align 4
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i32, ptr %zone_idx.addr, align 4
  %2 = load i32, ptr %all.addr, align 4
  call void @_nocheck__trace_pci_nvme_reset_zone(i64 noundef %0, i32 noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_zone_reset_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %iocb = alloca ptr, align 8
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %zone15 = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %iocb, align 8
  %1 = load ptr, ptr %iocb, align 8
  %req1 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %req1, align 8
  store ptr %2, ptr %req, align 8
  %3 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %ns2, align 8
  store ptr %4, ptr %ns, align 8
  %5 = load ptr, ptr %iocb, align 8
  %ret3 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %5, i32 0, i32 3
  %6 = load i32, ptr %ret3, align 8
  %cmp = icmp slt i32 %6, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %done

if.else:                                          ; preds = %entry
  %7 = load i32, ptr %ret.addr, align 4
  %cmp4 = icmp slt i32 %7, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %8 = load i32, ptr %ret.addr, align 4
  %9 = load ptr, ptr %iocb, align 8
  %ret6 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %9, i32 0, i32 3
  store i32 %8, ptr %ret6, align 8
  br label %done

if.end:                                           ; preds = %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end
  %10 = load ptr, ptr %iocb, align 8
  %zone = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %10, i32 0, i32 6
  %11 = load ptr, ptr %zone, align 8
  %tobool = icmp ne ptr %11, null
  br i1 %tobool, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.end7
  %12 = load ptr, ptr %ns, align 8
  %13 = load ptr, ptr %iocb, align 8
  %zone9 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %13, i32 0, i32 6
  %14 = load ptr, ptr %zone9, align 8
  %call = call zeroext i16 @nvme_zrm_reset(ptr noundef %12, ptr noundef %14)
  %15 = load ptr, ptr %iocb, align 8
  %all = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %15, i32 0, i32 4
  %16 = load i8, ptr %all, align 4
  %tobool10 = trunc i8 %16 to i1
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.then8
  br label %done

if.end12:                                         ; preds = %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %if.end7
  br label %while.cond

while.cond:                                       ; preds = %sw.default, %if.end21, %if.end13
  %17 = load ptr, ptr %iocb, align 8
  %idx = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %17, i32 0, i32 5
  %18 = load i32, ptr %idx, align 8
  %19 = load ptr, ptr %ns, align 8
  %num_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %19, i32 0, i32 23
  %20 = load i32, ptr %num_zones, align 8
  %cmp14 = icmp ult i32 %18, %20
  br i1 %cmp14, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load ptr, ptr %ns, align 8
  %zone_array = getelementptr inbounds %struct.NvmeNamespace, ptr %21, i32 0, i32 18
  %22 = load ptr, ptr %zone_array, align 8
  %23 = load ptr, ptr %iocb, align 8
  %idx16 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %23, i32 0, i32 5
  %24 = load i32, ptr %idx16, align 8
  %inc = add i32 %24, 1
  store i32 %inc, ptr %idx16, align 8
  %idxprom = sext i32 %24 to i64
  %arrayidx = getelementptr %struct.NvmeZone, ptr %22, i64 %idxprom
  store ptr %arrayidx, ptr %zone15, align 8
  %25 = load ptr, ptr %zone15, align 8
  %call17 = call i32 @nvme_get_zone_state(ptr noundef %25)
  switch i32 %call17, label %sw.default [
    i32 1, label %sw.bb
    i32 3, label %sw.bb22
    i32 2, label %sw.bb22
    i32 4, label %sw.bb22
    i32 14, label %sw.bb22
  ]

sw.bb:                                            ; preds = %while.body
  %26 = load ptr, ptr %iocb, align 8
  %all18 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %26, i32 0, i32 4
  %27 = load i8, ptr %all18, align 4
  %tobool19 = trunc i8 %27 to i1
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %sw.bb
  br label %done

if.end21:                                         ; preds = %sw.bb
  br label %while.cond, !llvm.loop !40

sw.bb22:                                          ; preds = %while.body, %while.body, %while.body, %while.body
  %28 = load ptr, ptr %zone15, align 8
  %29 = load ptr, ptr %iocb, align 8
  %zone23 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %29, i32 0, i32 6
  store ptr %28, ptr %zone23, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %while.body
  br label %while.cond, !llvm.loop !40

sw.epilog:                                        ; preds = %sw.bb22
  %30 = load ptr, ptr %zone15, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %30, i32 0, i32 0
  %zslba = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 5
  %31 = load i64, ptr %zslba, align 8
  call void @trace_pci_nvme_zns_zone_reset(i64 noundef %31)
  %32 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %32, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %33 = load ptr, ptr %blk, align 8
  %34 = load ptr, ptr %ns, align 8
  %35 = load ptr, ptr %zone15, align 8
  %d24 = getelementptr inbounds %struct.NvmeZone, ptr %35, i32 0, i32 0
  %zslba25 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d24, i32 0, i32 5
  %36 = load i64, ptr %zslba25, align 8
  %call26 = call i64 @nvme_l2b(ptr noundef %34, i64 noundef %36)
  %37 = load ptr, ptr %ns, align 8
  %38 = load ptr, ptr %ns, align 8
  %zone_size = getelementptr inbounds %struct.NvmeNamespace, ptr %38, i32 0, i32 24
  %39 = load i64, ptr %zone_size, align 8
  %call27 = call i64 @nvme_l2b(ptr noundef %37, i64 noundef %39)
  %40 = load ptr, ptr %iocb, align 8
  %call28 = call ptr @blk_aio_pwrite_zeroes(ptr noundef %33, i64 noundef %call26, i64 noundef %call27, i32 noundef 4, ptr noundef @nvme_zone_reset_epilogue_cb, ptr noundef %40)
  %41 = load ptr, ptr %iocb, align 8
  %aiocb = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %41, i32 0, i32 1
  store ptr %call28, ptr %aiocb, align 8
  br label %return

while.end:                                        ; preds = %while.cond
  br label %done

done:                                             ; preds = %while.end, %if.then20, %if.then11, %if.then5, %if.then
  %42 = load ptr, ptr %iocb, align 8
  %aiocb29 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %42, i32 0, i32 1
  store ptr null, ptr %aiocb29, align 8
  %43 = load ptr, ptr %iocb, align 8
  %common = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %43, i32 0, i32 0
  %cb = getelementptr inbounds %struct.BlockAIOCB, ptr %common, i32 0, i32 2
  %44 = load ptr, ptr %cb, align 8
  %45 = load ptr, ptr %iocb, align 8
  %common30 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %45, i32 0, i32 0
  %opaque31 = getelementptr inbounds %struct.BlockAIOCB, ptr %common30, i32 0, i32 3
  %46 = load ptr, ptr %opaque31, align 8
  %47 = load ptr, ptr %iocb, align 8
  %ret32 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %47, i32 0, i32 3
  %48 = load i32, ptr %ret32, align 8
  call void %44(ptr noundef %46, i32 noundef %48)
  %49 = load ptr, ptr %iocb, align 8
  call void @qemu_aio_unref(ptr noundef %49)
  br label %return

return:                                           ; preds = %done, %sw.epilog
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_offline_zone(i64 noundef %slba, i32 noundef %zone_idx, i32 noundef %all) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone_idx.addr = alloca i32, align 4
  %all.addr = alloca i32, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  store i32 %all, ptr %all.addr, align 4
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i32, ptr %zone_idx.addr, align 4
  %2 = load i32, ptr %all.addr, align 4
  call void @_nocheck__trace_pci_nvme_offline_zone(i64 noundef %0, i32 noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_offline_zone(ptr noundef %ns, ptr noundef %zone, i32 noundef %state, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %state.addr = alloca i32, align 4
  %req.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  store i32 %state, ptr %state.addr, align 4
  store ptr %req, ptr %req.addr, align 8
  %0 = load i32, ptr %state.addr, align 4
  switch i32 %0, label %sw.default [
    i32 13, label %sw.bb
    i32 15, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %1 = load ptr, ptr %ns.addr, align 8
  %2 = load ptr, ptr %zone.addr, align 8
  call void @nvme_assign_zone_state(ptr noundef %1, ptr noundef %2, i32 noundef 15)
  br label %sw.bb1

sw.bb1:                                           ; preds = %sw.bb, %entry
  store i16 0, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %entry
  store i16 447, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.default, %sw.bb1
  %3 = load i16, ptr %retval, align 2
  ret i16 %3
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_set_descriptor_extension(i64 noundef %slba, i32 noundef %zone_idx) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone_idx.addr = alloca i32, align 4
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  %0 = load i64, ptr %slba.addr, align 8
  %1 = load i32, ptr %zone_idx.addr, align 4
  call void @_nocheck__trace_pci_nvme_set_descriptor_extension(i64 noundef %0, i32 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_get_zd_extension(ptr noundef %ns, i32 noundef %zone_idx) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %zone_idx.addr = alloca i32, align 4
  store ptr %ns, ptr %ns.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  %0 = load ptr, ptr %ns.addr, align 8
  %zd_extensions = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 27
  %1 = load ptr, ptr %zd_extensions, align 8
  %2 = load i32, ptr %zone_idx.addr, align 4
  %3 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 30
  %zd_extension_size = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 20
  %4 = load i32, ptr %zd_extension_size, align 8
  %mul = mul i32 %2, %4
  %idxprom = zext i32 %mul to i64
  %arrayidx = getelementptr i8, ptr %1, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_zd_extension_map_error(i32 noundef %zone_idx) #0 {
entry:
  %zone_idx.addr = alloca i32, align 4
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  %0 = load i32, ptr %zone_idx.addr, align 4
  call void @_nocheck__trace_pci_nvme_err_zd_extension_map_error(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_set_zd_ext(ptr noundef %ns, ptr noundef %zone) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %status = alloca i16, align 2
  %state = alloca i8, align 1
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  %0 = load ptr, ptr %zone.addr, align 8
  %call = call i32 @nvme_get_zone_state(ptr noundef %0)
  %conv = trunc i32 %call to i8
  store i8 %conv, ptr %state, align 1
  %1 = load i8, ptr %state, align 1
  %conv1 = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv1, 1
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ns.addr, align 8
  %call3 = call zeroext i16 @nvme_aor_check(ptr noundef %2, i32 noundef 1, i32 noundef 0)
  store i16 %call3, ptr %status, align 2
  %3 = load i16, ptr %status, align 2
  %tobool = icmp ne i16 %3, 0
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %4 = load i16, ptr %status, align 2
  store i16 %4, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %if.then
  %5 = load ptr, ptr %ns.addr, align 8
  call void @nvme_aor_inc_active(ptr noundef %5)
  %6 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %6, i32 0, i32 0
  %za = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 2
  %7 = load i8, ptr %za, align 2
  %conv5 = zext i8 %7 to i32
  %or = or i32 %conv5, 128
  %conv6 = trunc i32 %or to i8
  store i8 %conv6, ptr %za, align 2
  %8 = load ptr, ptr %ns.addr, align 8
  %9 = load ptr, ptr %zone.addr, align 8
  call void @nvme_assign_zone_state(ptr noundef %8, ptr noundef %9, i32 noundef 4)
  store i16 0, ptr %retval, align 2
  br label %return

if.end7:                                          ; preds = %entry
  store i16 447, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end7, %if.end, %if.then4
  %10 = load i16, ptr %retval, align 2
  ret i16 %10
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_zd_extension_set(i32 noundef %zone_idx) #0 {
entry:
  %zone_idx.addr = alloca i32, align 4
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  %0 = load i32, ptr %zone_idx.addr, align 4
  call void @_nocheck__trace_pci_nvme_zd_extension_set(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_zone_mgmt_send_zrwa_flush(ptr noundef %n, ptr noundef %zone, i64 noundef %elba, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %elba.addr = alloca i64, align 8
  %req.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %ozcs = alloca i16, align 2
  %wp = alloca i64, align 8
  %nlb = alloca i32, align 4
  %status = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  store i64 %elba, ptr %elba.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %ns1, align 8
  store ptr %1, ptr %ns, align 8
  %2 = load ptr, ptr %ns, align 8
  %id_ns_zoned = getelementptr inbounds %struct.NvmeNamespace, ptr %2, i32 0, i32 17
  %3 = load ptr, ptr %id_ns_zoned, align 8
  %ozcs2 = getelementptr inbounds %struct.NvmeIdNsZoned, ptr %3, i32 0, i32 1
  %4 = load i16, ptr %ozcs2, align 1
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %4)
  store i16 %call, ptr %ozcs, align 2
  %5 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %5, i32 0, i32 0
  %wp3 = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 6
  %6 = load i64, ptr %wp3, align 8
  store i64 %6, ptr %wp, align 8
  %7 = load i64, ptr %elba.addr, align 8
  %8 = load i64, ptr %wp, align 8
  %sub = sub i64 %7, %8
  %add = add i64 %sub, 1
  %conv = trunc i64 %add to i32
  store i32 %conv, ptr %nlb, align 4
  %9 = load i16, ptr %ozcs, align 2
  %conv4 = zext i16 %9 to i32
  %and = and i32 %conv4, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 16822, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %10 = load ptr, ptr %zone.addr, align 8
  %d5 = getelementptr inbounds %struct.NvmeZone, ptr %10, i32 0, i32 0
  %za = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d5, i32 0, i32 2
  %11 = load i8, ptr %za, align 2
  %conv6 = zext i8 %11 to i32
  %and7 = and i32 %conv6, 8
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end
  store i16 16386, ptr %retval, align 2
  br label %return

if.end10:                                         ; preds = %if.end
  %12 = load i64, ptr %elba.addr, align 8
  %13 = load i64, ptr %wp, align 8
  %cmp = icmp ult i64 %12, %13
  br i1 %cmp, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end10
  %14 = load i64, ptr %elba.addr, align 8
  %15 = load i64, ptr %wp, align 8
  %16 = load ptr, ptr %ns, align 8
  %zns = getelementptr inbounds %struct.NvmeNamespace, ptr %16, i32 0, i32 15
  %zrwas = getelementptr inbounds %struct.anon.4, ptr %zns, i32 0, i32 0
  %17 = load i16, ptr %zrwas, align 4
  %conv12 = zext i16 %17 to i64
  %add13 = add i64 %15, %conv12
  %cmp14 = icmp ugt i64 %14, %add13
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %if.end10
  store i16 16824, ptr %retval, align 2
  br label %return

if.end17:                                         ; preds = %lor.lhs.false
  %18 = load i32, ptr %nlb, align 4
  %19 = load ptr, ptr %ns, align 8
  %zns18 = getelementptr inbounds %struct.NvmeNamespace, ptr %19, i32 0, i32 15
  %zrwafg = getelementptr inbounds %struct.anon.4, ptr %zns18, i32 0, i32 1
  %20 = load i16, ptr %zrwafg, align 2
  %conv19 = zext i16 %20 to i32
  %rem = urem i32 %18, %conv19
  %tobool20 = icmp ne i32 %rem, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end17
  store i16 16386, ptr %retval, align 2
  br label %return

if.end22:                                         ; preds = %if.end17
  %21 = load ptr, ptr %n.addr, align 8
  %22 = load ptr, ptr %ns, align 8
  %23 = load ptr, ptr %zone.addr, align 8
  %call23 = call zeroext i16 @nvme_zrm_auto(ptr noundef %21, ptr noundef %22, ptr noundef %23)
  store i16 %call23, ptr %status, align 2
  %24 = load i16, ptr %status, align 2
  %tobool24 = icmp ne i16 %24, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end22
  %25 = load i16, ptr %status, align 2
  store i16 %25, ptr %retval, align 2
  br label %return

if.end26:                                         ; preds = %if.end22
  %26 = load i32, ptr %nlb, align 4
  %conv27 = zext i32 %26 to i64
  %27 = load ptr, ptr %zone.addr, align 8
  %w_ptr = getelementptr inbounds %struct.NvmeZone, ptr %27, i32 0, i32 1
  %28 = load i64, ptr %w_ptr, align 8
  %add28 = add i64 %28, %conv27
  store i64 %add28, ptr %w_ptr, align 8
  %29 = load ptr, ptr %ns, align 8
  %30 = load ptr, ptr %zone.addr, align 8
  %31 = load i32, ptr %nlb, align 4
  call void @nvme_advance_zone_wp(ptr noundef %29, ptr noundef %30, i32 noundef %31)
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end26, %if.then25, %if.then21, %if.then16, %if.then9, %if.then
  %32 = load i16, ptr %retval, align 2
  ret i16 %32
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_mgmt_action(i8 noundef zeroext %action) #0 {
entry:
  %action.addr = alloca i8, align 1
  store i8 %action, ptr %action.addr, align 1
  %0 = load i8, ptr %action.addr, align 1
  call void @_nocheck__trace_pci_nvme_err_invalid_mgmt_action(i8 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_zone_state_transition(i8 noundef zeroext %action, i64 noundef %slba, i8 noundef zeroext %attrs) #0 {
entry:
  %action.addr = alloca i8, align 1
  %slba.addr = alloca i64, align 8
  %attrs.addr = alloca i8, align 1
  store i8 %action, ptr %action.addr, align 1
  store i64 %slba, ptr %slba.addr, align 8
  store i8 %attrs, ptr %attrs.addr, align 1
  %0 = load i8, ptr %action.addr, align 1
  %1 = load i64, ptr %slba.addr, align 8
  %2 = load i8, ptr %attrs.addr, align 1
  call void @_nocheck__trace_pci_nvme_err_invalid_zone_state_transition(i8 noundef zeroext %0, i64 noundef %1, i8 noundef zeroext %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_unaligned_zone_cmd(i8 noundef zeroext %action, i64 noundef %slba, i64 noundef %zslba) #0 {
entry:
  %action.addr = alloca i8, align 1
  %slba.addr = alloca i64, align 8
  %zslba.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i8 %action, ptr %action.addr, align 1
  store i64 %slba, ptr %slba.addr, align 8
  store i64 %zslba, ptr %zslba.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %action.addr, align 1
  %conv11 = zext i8 %5 to i32
  %6 = load i64, ptr %slba.addr, align 8
  %7 = load i64, ptr %zslba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.266, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i64 noundef %6, i64 noundef %7)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i8, ptr %action.addr, align 1
  %conv12 = zext i8 %8 to i32
  %9 = load i64, ptr %slba.addr, align 8
  %10 = load i64, ptr %zslba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.267, i32 noundef %conv12, i64 noundef %9, i64 noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_open_zone(i64 noundef %slba, i32 noundef %zone_idx, i32 noundef %all) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone_idx.addr = alloca i32, align 4
  %all.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  store i32 %all, ptr %all.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_OPEN_ZONE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i32, ptr %zone_idx.addr, align 4
  %7 = load i32, ptr %all.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.268, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6, i32 noundef %7)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i64, ptr %slba.addr, align 8
  %9 = load i32, ptr %zone_idx.addr, align 4
  %10 = load i32, ptr %all.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.269, i64 noundef %8, i32 noundef %9, i32 noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_bulk_proc_zone(ptr noundef %ns, ptr noundef %zone, i32 noundef %proc_mask, ptr noundef %op_hndlr, ptr noundef %req) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  %proc_mask.addr = alloca i32, align 4
  %op_hndlr.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %status = alloca i16, align 2
  %zs = alloca i32, align 4
  %proc_zone = alloca i8, align 1
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  store i32 %proc_mask, ptr %proc_mask.addr, align 4
  store ptr %op_hndlr, ptr %op_hndlr.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  store i16 0, ptr %status, align 2
  %0 = load ptr, ptr %zone.addr, align 8
  %call = call i32 @nvme_get_zone_state(ptr noundef %0)
  store i32 %call, ptr %zs, align 4
  %1 = load i32, ptr %zs, align 4
  switch i32 %1, label %sw.default [
    i32 2, label %sw.bb
    i32 3, label %sw.bb
    i32 4, label %sw.bb1
    i32 13, label %sw.bb5
    i32 14, label %sw.bb9
  ]

sw.bb:                                            ; preds = %entry, %entry
  %2 = load i32, ptr %proc_mask.addr, align 4
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %proc_zone, align 1
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %3 = load i32, ptr %proc_mask.addr, align 4
  %and2 = and i32 %3, 2
  %tobool3 = icmp ne i32 %and2, 0
  %frombool4 = zext i1 %tobool3 to i8
  store i8 %frombool4, ptr %proc_zone, align 1
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %4 = load i32, ptr %proc_mask.addr, align 4
  %and6 = and i32 %4, 4
  %tobool7 = icmp ne i32 %and6, 0
  %frombool8 = zext i1 %tobool7 to i8
  store i8 %frombool8, ptr %proc_zone, align 1
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %5 = load i32, ptr %proc_mask.addr, align 4
  %and10 = and i32 %5, 8
  %tobool11 = icmp ne i32 %and10, 0
  %frombool12 = zext i1 %tobool11 to i8
  store i8 %frombool12, ptr %proc_zone, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i8 0, ptr %proc_zone, align 1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb9, %sw.bb5, %sw.bb1, %sw.bb
  %6 = load i8, ptr %proc_zone, align 1
  %tobool13 = trunc i8 %6 to i1
  br i1 %tobool13, label %if.then, label %if.end

if.then:                                          ; preds = %sw.epilog
  %7 = load ptr, ptr %op_hndlr.addr, align 8
  %8 = load ptr, ptr %ns.addr, align 8
  %9 = load ptr, ptr %zone.addr, align 8
  %10 = load i32, ptr %zs, align 4
  %11 = load ptr, ptr %req.addr, align 8
  %call14 = call zeroext i16 %7(ptr noundef %8, ptr noundef %9, i32 noundef %10, ptr noundef %11)
  store i16 %call14, ptr %status, align 2
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.epilog
  %12 = load i16, ptr %status, align 2
  ret i16 %12
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_close_zone(i64 noundef %slba, i32 noundef %zone_idx, i32 noundef %all) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone_idx.addr = alloca i32, align 4
  %all.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  store i32 %all, ptr %all.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_CLOSE_ZONE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i32, ptr %zone_idx.addr, align 4
  %7 = load i32, ptr %all.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.270, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6, i32 noundef %7)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i64, ptr %slba.addr, align 8
  %9 = load i32, ptr %zone_idx.addr, align 4
  %10 = load i32, ptr %all.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.271, i64 noundef %8, i32 noundef %9, i32 noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_finish_zone(i64 noundef %slba, i32 noundef %zone_idx, i32 noundef %all) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone_idx.addr = alloca i32, align 4
  %all.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  store i32 %all, ptr %all.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_FINISH_ZONE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i32, ptr %zone_idx.addr, align 4
  %7 = load i32, ptr %all.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.272, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6, i32 noundef %7)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i64, ptr %slba.addr, align 8
  %9 = load i32, ptr %zone_idx.addr, align 4
  %10 = load i32, ptr %all.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.273, i64 noundef %8, i32 noundef %9, i32 noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_reset_zone(i64 noundef %slba, i32 noundef %zone_idx, i32 noundef %all) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone_idx.addr = alloca i32, align 4
  %all.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  store i32 %all, ptr %all.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_RESET_ZONE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i32, ptr %zone_idx.addr, align 4
  %7 = load i32, ptr %all.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.274, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6, i32 noundef %7)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i64, ptr %slba.addr, align 8
  %9 = load i32, ptr %zone_idx.addr, align 4
  %10 = load i32, ptr %all.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.275, i64 noundef %8, i32 noundef %9, i32 noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_zone_reset_cancel(ptr noundef %aiocb) #0 {
entry:
  %aiocb.addr = alloca ptr, align 8
  %iocb = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  store ptr %aiocb, ptr %aiocb.addr, align 8
  %0 = load ptr, ptr %aiocb.addr, align 8
  store ptr %0, ptr %__mptr, align 8
  %1 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 0
  store ptr %add.ptr, ptr %tmp, align 8
  %2 = load ptr, ptr %tmp, align 8
  store ptr %2, ptr %iocb, align 8
  %3 = load ptr, ptr %iocb, align 8
  %req1 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %req1, align 8
  store ptr %4, ptr %req, align 8
  %5 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %ns2, align 8
  store ptr %6, ptr %ns, align 8
  %7 = load ptr, ptr %ns, align 8
  %num_zones = getelementptr inbounds %struct.NvmeNamespace, ptr %7, i32 0, i32 23
  %8 = load i32, ptr %num_zones, align 8
  %9 = load ptr, ptr %iocb, align 8
  %idx = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %9, i32 0, i32 5
  store i32 %8, ptr %idx, align 8
  %10 = load ptr, ptr %iocb, align 8
  %ret = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %10, i32 0, i32 3
  store i32 -125, ptr %ret, align 8
  %11 = load ptr, ptr %iocb, align 8
  %aiocb3 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %aiocb3, align 8
  %tobool = icmp ne ptr %12, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %13 = load ptr, ptr %iocb, align 8
  %aiocb4 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %aiocb4, align 8
  call void @blk_aio_cancel_async(ptr noundef %14)
  %15 = load ptr, ptr %iocb, align 8
  %aiocb5 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %15, i32 0, i32 1
  store ptr null, ptr %aiocb5, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_zrm_reset(ptr noundef %ns, ptr noundef %zone) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %zone.addr = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %zone, ptr %zone.addr, align 8
  %0 = load ptr, ptr %zone.addr, align 8
  %call = call i32 @nvme_get_zone_state(ptr noundef %0)
  switch i32 %call, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb
    i32 4, label %sw.bb1
    i32 14, label %sw.bb6
    i32 1, label %sw.bb10
  ]

sw.bb:                                            ; preds = %entry, %entry
  %1 = load ptr, ptr %ns.addr, align 8
  call void @nvme_aor_dec_open(ptr noundef %1)
  br label %sw.bb1

sw.bb1:                                           ; preds = %sw.bb, %entry
  %2 = load ptr, ptr %ns.addr, align 8
  call void @nvme_aor_dec_active(ptr noundef %2)
  %3 = load ptr, ptr %zone.addr, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %3, i32 0, i32 0
  %za = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 2
  %4 = load i8, ptr %za, align 2
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %sw.bb1
  %5 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %5, i32 0, i32 30
  %numzrwa = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 21
  %6 = load i32, ptr %numzrwa, align 4
  %tobool2 = icmp ne i32 %6, 0
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %7 = load ptr, ptr %ns.addr, align 8
  %zns = getelementptr inbounds %struct.NvmeNamespace, ptr %7, i32 0, i32 15
  %numzrwa4 = getelementptr inbounds %struct.anon.4, ptr %zns, i32 0, i32 2
  %8 = load i32, ptr %numzrwa4, align 4
  %inc = add i32 %8, 1
  store i32 %inc, ptr %numzrwa4, align 4
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  br label %if.end5

if.end5:                                          ; preds = %if.end, %sw.bb1
  br label %sw.bb6

sw.bb6:                                           ; preds = %if.end5, %entry
  %9 = load ptr, ptr %zone.addr, align 8
  %d7 = getelementptr inbounds %struct.NvmeZone, ptr %9, i32 0, i32 0
  %zslba = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d7, i32 0, i32 5
  %10 = load i64, ptr %zslba, align 8
  %11 = load ptr, ptr %zone.addr, align 8
  %w_ptr = getelementptr inbounds %struct.NvmeZone, ptr %11, i32 0, i32 1
  store i64 %10, ptr %w_ptr, align 8
  %12 = load ptr, ptr %zone.addr, align 8
  %w_ptr8 = getelementptr inbounds %struct.NvmeZone, ptr %12, i32 0, i32 1
  %13 = load i64, ptr %w_ptr8, align 8
  %14 = load ptr, ptr %zone.addr, align 8
  %d9 = getelementptr inbounds %struct.NvmeZone, ptr %14, i32 0, i32 0
  %wp = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d9, i32 0, i32 6
  store i64 %13, ptr %wp, align 8
  %15 = load ptr, ptr %ns.addr, align 8
  %16 = load ptr, ptr %zone.addr, align 8
  call void @nvme_assign_zone_state(ptr noundef %15, ptr noundef %16, i32 noundef 1)
  br label %sw.bb10

sw.bb10:                                          ; preds = %sw.bb6, %entry
  store i16 0, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %entry
  store i16 447, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.default, %sw.bb10
  %17 = load i16, ptr %retval, align 2
  ret i16 %17
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_zns_zone_reset(i64 noundef %zslba) #0 {
entry:
  %zslba.addr = alloca i64, align 8
  store i64 %zslba, ptr %zslba.addr, align 8
  %0 = load i64, ptr %zslba.addr, align 8
  call void @_nocheck__trace_pci_nvme_zns_zone_reset(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_zone_reset_epilogue_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %iocb = alloca ptr, align 8
  %req = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %moff = alloca i64, align 8
  %count = alloca i32, align 4
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %iocb, align 8
  %1 = load ptr, ptr %iocb, align 8
  %req1 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %req1, align 8
  store ptr %2, ptr %req, align 8
  %3 = load ptr, ptr %req, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %ns2, align 8
  store ptr %4, ptr %ns, align 8
  %5 = load i32, ptr %ret.addr, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load ptr, ptr %iocb, align 8
  %ret3 = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %6, i32 0, i32 3
  %7 = load i32, ptr %ret3, align 8
  %cmp4 = icmp slt i32 %7, 0
  br i1 %cmp4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %8 = load ptr, ptr %ns, align 8
  %lbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %8, i32 0, i32 7
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %lbaf, i32 0, i32 0
  %9 = load i16, ptr %ms, align 8
  %tobool = icmp ne i16 %9, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false5, %lor.lhs.false, %entry
  br label %out

if.end:                                           ; preds = %lor.lhs.false5
  %10 = load ptr, ptr %ns, align 8
  %11 = load ptr, ptr %iocb, align 8
  %zone = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %11, i32 0, i32 6
  %12 = load ptr, ptr %zone, align 8
  %d = getelementptr inbounds %struct.NvmeZone, ptr %12, i32 0, i32 0
  %zslba = getelementptr inbounds %struct.NvmeZoneDescr, ptr %d, i32 0, i32 5
  %13 = load i64, ptr %zslba, align 8
  %call = call i64 @nvme_moff(ptr noundef %10, i64 noundef %13)
  store i64 %call, ptr %moff, align 8
  %14 = load ptr, ptr %ns, align 8
  %15 = load ptr, ptr %ns, align 8
  %zone_size = getelementptr inbounds %struct.NvmeNamespace, ptr %15, i32 0, i32 24
  %16 = load i64, ptr %zone_size, align 8
  %call6 = call i64 @nvme_m2b(ptr noundef %14, i64 noundef %16)
  %conv = trunc i64 %call6 to i32
  store i32 %conv, ptr %count, align 4
  %17 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %17, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %18 = load ptr, ptr %blk, align 8
  %19 = load i64, ptr %moff, align 8
  %20 = load i32, ptr %count, align 4
  %conv7 = sext i32 %20 to i64
  %21 = load ptr, ptr %iocb, align 8
  %call8 = call ptr @blk_aio_pwrite_zeroes(ptr noundef %18, i64 noundef %19, i64 noundef %conv7, i32 noundef 4, ptr noundef @nvme_zone_reset_cb, ptr noundef %21)
  %22 = load ptr, ptr %iocb, align 8
  %aiocb = getelementptr inbounds %struct.NvmeZoneResetAIOCB, ptr %22, i32 0, i32 1
  store ptr %call8, ptr %aiocb, align 8
  br label %return

out:                                              ; preds = %if.then
  %23 = load ptr, ptr %iocb, align 8
  %24 = load i32, ptr %ret.addr, align 4
  call void @nvme_zone_reset_cb(ptr noundef %23, i32 noundef %24)
  br label %return

return:                                           ; preds = %out, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_zns_zone_reset(i64 noundef %zslba) #0 {
entry:
  %zslba.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %zslba, ptr %zslba.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ZNS_ZONE_RESET_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %zslba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.276, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %zslba.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.277, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_offline_zone(i64 noundef %slba, i32 noundef %zone_idx, i32 noundef %all) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone_idx.addr = alloca i32, align 4
  %all.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  store i32 %all, ptr %all.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_OFFLINE_ZONE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i32, ptr %zone_idx.addr, align 4
  %7 = load i32, ptr %all.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.278, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6, i32 noundef %7)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i64, ptr %slba.addr, align 8
  %9 = load i32, ptr %zone_idx.addr, align 4
  %10 = load i32, ptr %all.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.279, i64 noundef %8, i32 noundef %9, i32 noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_set_descriptor_extension(i64 noundef %slba, i32 noundef %zone_idx) #0 {
entry:
  %slba.addr = alloca i64, align 8
  %zone_idx.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %slba, ptr %slba.addr, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %slba.addr, align 8
  %6 = load i32, ptr %zone_idx.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.280, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %slba.addr, align 8
  %8 = load i32, ptr %zone_idx.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.281, i64 noundef %7, i32 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_zd_extension_map_error(i32 noundef %zone_idx) #0 {
entry:
  %zone_idx.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %zone_idx.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.282, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %zone_idx.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.283, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_aor_check(ptr noundef %ns, i32 noundef %act, i32 noundef %opn) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %act.addr = alloca i32, align 4
  %opn.addr = alloca i32, align 4
  store ptr %ns, ptr %ns.addr, align 8
  store i32 %act, ptr %act.addr, align 4
  store i32 %opn, ptr %opn.addr, align 4
  %0 = load ptr, ptr %ns.addr, align 8
  %1 = load i32, ptr %act.addr, align 4
  %2 = load i32, ptr %opn.addr, align 4
  %call = call zeroext i16 @nvme_zns_check_resources(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 0)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_zd_extension_set(i32 noundef %zone_idx) #0 {
entry:
  %zone_idx.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %zone_idx, ptr %zone_idx.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ZD_EXTENSION_SET_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %zone_idx.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.284, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %zone_idx.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.285, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_mgmt_action(i8 noundef zeroext %action) #0 {
entry:
  %action.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %action, ptr %action.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %action.addr, align 1
  %conv11 = zext i8 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.286, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i8, ptr %action.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.287, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_zone_state_transition(i8 noundef zeroext %action, i64 noundef %slba, i8 noundef zeroext %attrs) #0 {
entry:
  %action.addr = alloca i8, align 1
  %slba.addr = alloca i64, align 8
  %attrs.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %action, ptr %action.addr, align 1
  store i64 %slba, ptr %slba.addr, align 8
  store i8 %attrs, ptr %attrs.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %action.addr, align 1
  %conv11 = zext i8 %5 to i32
  %6 = load i64, ptr %slba.addr, align 8
  %7 = load i8, ptr %attrs.addr, align 1
  %conv12 = zext i8 %7 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.288, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i64 noundef %6, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i8, ptr %action.addr, align 1
  %conv13 = zext i8 %8 to i32
  %9 = load i64, ptr %slba.addr, align 8
  %10 = load i8, ptr %attrs.addr, align 1
  %conv14 = zext i8 %10 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.289, i32 noundef %conv13, i64 noundef %9, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: allocsize(0)
declare noalias ptr @g_malloc0(i64 noundef) #9

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_zone_matches_filter(i32 noundef %zafs, ptr noundef %zl) #0 {
entry:
  %retval = alloca i1, align 1
  %zafs.addr = alloca i32, align 4
  %zl.addr = alloca ptr, align 8
  %zs = alloca i32, align 4
  store i32 %zafs, ptr %zafs.addr, align 4
  store ptr %zl, ptr %zl.addr, align 8
  %0 = load ptr, ptr %zl.addr, align 8
  %call = call i32 @nvme_get_zone_state(ptr noundef %0)
  store i32 %call, ptr %zs, align 4
  %1 = load i32, ptr %zafs.addr, align 4
  switch i32 %1, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
    i32 3, label %sw.bb4
    i32 4, label %sw.bb6
    i32 5, label %sw.bb8
    i32 6, label %sw.bb10
    i32 7, label %sw.bb12
  ]

sw.bb:                                            ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb1:                                           ; preds = %entry
  %2 = load i32, ptr %zs, align 4
  %cmp = icmp eq i32 %2, 1
  store i1 %cmp, ptr %retval, align 1
  br label %return

sw.bb2:                                           ; preds = %entry
  %3 = load i32, ptr %zs, align 4
  %cmp3 = icmp eq i32 %3, 2
  store i1 %cmp3, ptr %retval, align 1
  br label %return

sw.bb4:                                           ; preds = %entry
  %4 = load i32, ptr %zs, align 4
  %cmp5 = icmp eq i32 %4, 3
  store i1 %cmp5, ptr %retval, align 1
  br label %return

sw.bb6:                                           ; preds = %entry
  %5 = load i32, ptr %zs, align 4
  %cmp7 = icmp eq i32 %5, 4
  store i1 %cmp7, ptr %retval, align 1
  br label %return

sw.bb8:                                           ; preds = %entry
  %6 = load i32, ptr %zs, align 4
  %cmp9 = icmp eq i32 %6, 14
  store i1 %cmp9, ptr %retval, align 1
  br label %return

sw.bb10:                                          ; preds = %entry
  %7 = load i32, ptr %zs, align 4
  %cmp11 = icmp eq i32 %7, 13
  store i1 %cmp11, ptr %retval, align 1
  br label %return

sw.bb12:                                          ; preds = %entry
  %8 = load i32, ptr %zs, align 4
  %cmp13 = icmp eq i32 %8, 15
  store i1 %cmp13, ptr %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb12, %sw.bb10, %sw.bb8, %sw.bb6, %sw.bb4, %sw.bb2, %sw.bb1, %sw.bb
  %9 = load i1, ptr %retval, align 1
  ret i1 %9
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @nvme_wp_is_valid(ptr noundef %zone) #0 {
entry:
  %zone.addr = alloca ptr, align 8
  %st = alloca i8, align 1
  store ptr %zone, ptr %zone.addr, align 8
  %0 = load ptr, ptr %zone.addr, align 8
  %call = call i32 @nvme_get_zone_state(ptr noundef %0)
  %conv = trunc i32 %call to i8
  store i8 %conv, ptr %st, align 1
  %1 = load i8, ptr %st, align 1
  %conv1 = zext i8 %1 to i32
  %cmp = icmp ne i32 %conv1, 14
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %2 = load i8, ptr %st, align 1
  %conv3 = zext i8 %2 to i32
  %cmp4 = icmp ne i32 %conv3, 13
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %3 = load i8, ptr %st, align 1
  %conv6 = zext i8 %3 to i32
  %cmp7 = icmp ne i32 %conv6, 15
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %4 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp7, %land.rhs ]
  ret i1 %4
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_c2h(ptr noundef %n, ptr noundef %ptr, i32 noundef %len, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %req.addr = alloca ptr, align 8
  %status = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %sg = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 8
  %2 = load i32, ptr %len.addr, align 4
  %conv = zext i32 %2 to i64
  %3 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 6
  %call = call zeroext i16 @nvme_map_dptr(ptr noundef %0, ptr noundef %sg, i64 noundef %conv, ptr noundef %cmd)
  store i16 %call, ptr %status, align 2
  %4 = load i16, ptr %status, align 2
  %tobool = icmp ne i16 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i16, ptr %status, align 2
  store i16 %5, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %n.addr, align 8
  %7 = load ptr, ptr %req.addr, align 8
  %sg1 = getelementptr inbounds %struct.NvmeRequest, ptr %7, i32 0, i32 8
  %8 = load ptr, ptr %ptr.addr, align 8
  %9 = load i32, ptr %len.addr, align 4
  %call2 = call zeroext i16 @nvme_tx(ptr noundef %6, ptr noundef %sg1, ptr noundef %8, i32 noundef %9, i32 noundef 1)
  store i16 %call2, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i16, ptr %retval, align 2
  ret i16 %10
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_io_mgmt_recv_ruhs(ptr noundef %n, ptr noundef %req, i64 noundef %len) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %ns = alloca ptr, align 8
  %endgrp = alloca ptr, align 8
  %hdr = alloca ptr, align 8
  %ruhsd = alloca ptr, align 8
  %nruhsd = alloca i32, align 4
  %rg = alloca i16, align 2
  %ph = alloca i16, align 2
  %ruhid = alloca ptr, align 8
  %trans_len = alloca i64, align 8
  %buf = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %_a23 = alloca i64, align 8
  %_b24 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %ruh = alloca ptr, align 8
  %pid = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %ns1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %ns1, align 8
  store ptr %1, ptr %ns, align 8
  store ptr null, ptr %buf, align 8
  %2 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 33
  %3 = load ptr, ptr %subsys, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 16386, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %4, i32 0, i32 30
  %nsid = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 2
  %5 = load i32, ptr %nsid, align 4
  %cmp = icmp eq i32 %5, 0
  br i1 %cmp, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %6 = load ptr, ptr %ns, align 8
  %params2 = getelementptr inbounds %struct.NvmeNamespace, ptr %6, i32 0, i32 30
  %nsid3 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params2, i32 0, i32 2
  %7 = load i32, ptr %nsid3, align 4
  %cmp4 = icmp eq i32 %7, -1
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  store i16 16395, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end6:                                          ; preds = %lor.lhs.false
  %8 = load ptr, ptr %n.addr, align 8
  %subsys7 = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 33
  %9 = load ptr, ptr %subsys7, align 8
  %endgrp8 = getelementptr inbounds %struct.NvmeSubsystem, ptr %9, i32 0, i32 6
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %endgrp8, i32 0, i32 1
  %enabled = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 9
  %10 = load i8, ptr %enabled, align 8
  %tobool9 = trunc i8 %10 to i1
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end6
  store i16 16425, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end11:                                         ; preds = %if.end6
  %11 = load ptr, ptr %ns, align 8
  %endgrp12 = getelementptr inbounds %struct.NvmeNamespace, ptr %11, i32 0, i32 32
  %12 = load ptr, ptr %endgrp12, align 8
  store ptr %12, ptr %endgrp, align 8
  %13 = load ptr, ptr %ns, align 8
  %fdp13 = getelementptr inbounds %struct.NvmeNamespace, ptr %13, i32 0, i32 34
  %nphs = getelementptr inbounds %struct.anon.14, ptr %fdp13, i32 0, i32 0
  %14 = load i16, ptr %nphs, align 8
  %conv = zext i16 %14 to i32
  %15 = load ptr, ptr %endgrp, align 8
  %fdp14 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %15, i32 0, i32 1
  %nrg = getelementptr inbounds %struct.anon.36, ptr %fdp14, i32 0, i32 3
  %16 = load i16, ptr %nrg, align 2
  %conv15 = zext i16 %16 to i32
  %mul = mul i32 %conv, %conv15
  store i32 %mul, ptr %nruhsd, align 4
  %17 = load i32, ptr %nruhsd, align 4
  %conv16 = zext i32 %17 to i64
  %mul17 = mul i64 %conv16, 32
  %add = add i64 16, %mul17
  store i64 %add, ptr %trans_len, align 8
  %18 = load i64, ptr %trans_len, align 8
  %call = call noalias ptr @g_malloc(i64 noundef %18) #14
  store ptr %call, ptr %buf, align 8
  %19 = load i64, ptr %trans_len, align 8
  store i64 %19, ptr %_a23, align 8
  %20 = load i64, ptr %len.addr, align 8
  store i64 %20, ptr %_b24, align 8
  %21 = load i64, ptr %_a23, align 8
  %22 = load i64, ptr %_b24, align 8
  %cmp18 = icmp ult i64 %21, %22
  br i1 %cmp18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end11
  %23 = load i64, ptr %_a23, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end11
  %24 = load i64, ptr %_b24, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %23, %cond.true ], [ %24, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %25 = load i64, ptr %tmp, align 8
  store i64 %25, ptr %trans_len, align 8
  %26 = load ptr, ptr %buf, align 8
  store ptr %26, ptr %hdr, align 8
  %27 = load ptr, ptr %buf, align 8
  %add.ptr = getelementptr i8, ptr %27, i64 16
  store ptr %add.ptr, ptr %ruhsd, align 8
  %28 = load i32, ptr %nruhsd, align 4
  %conv20 = trunc i32 %28 to i16
  %call21 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv20)
  %29 = load ptr, ptr %hdr, align 8
  %nruhsd22 = getelementptr inbounds %struct.NvmeRuhStatus, ptr %29, i32 0, i32 1
  store i16 %call21, ptr %nruhsd22, align 1
  %30 = load ptr, ptr %ns, align 8
  %fdp23 = getelementptr inbounds %struct.NvmeNamespace, ptr %30, i32 0, i32 34
  %phs = getelementptr inbounds %struct.anon.14, ptr %fdp23, i32 0, i32 1
  %31 = load ptr, ptr %phs, align 8
  store ptr %31, ptr %ruhid, align 8
  store i16 0, ptr %ph, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc47, %cond.end
  %32 = load i16, ptr %ph, align 2
  %conv24 = zext i16 %32 to i32
  %33 = load ptr, ptr %ns, align 8
  %fdp25 = getelementptr inbounds %struct.NvmeNamespace, ptr %33, i32 0, i32 34
  %nphs26 = getelementptr inbounds %struct.anon.14, ptr %fdp25, i32 0, i32 0
  %34 = load i16, ptr %nphs26, align 8
  %conv27 = zext i16 %34 to i32
  %cmp28 = icmp slt i32 %conv24, %conv27
  br i1 %cmp28, label %for.body, label %for.end50

for.body:                                         ; preds = %for.cond
  %35 = load ptr, ptr %endgrp, align 8
  %fdp30 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %35, i32 0, i32 1
  %ruhs = getelementptr inbounds %struct.anon.36, ptr %fdp30, i32 0, i32 10
  %36 = load ptr, ptr %ruhs, align 8
  %37 = load ptr, ptr %ruhid, align 8
  %38 = load i16, ptr %37, align 2
  %idxprom = zext i16 %38 to i64
  %arrayidx = getelementptr %struct.NvmeRuHandle, ptr %36, i64 %idxprom
  store ptr %arrayidx, ptr %ruh, align 8
  store i16 0, ptr %rg, align 2
  br label %for.cond31

for.cond31:                                       ; preds = %for.inc, %for.body
  %39 = load i16, ptr %rg, align 2
  %conv32 = zext i16 %39 to i32
  %40 = load ptr, ptr %endgrp, align 8
  %fdp33 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %40, i32 0, i32 1
  %nrg34 = getelementptr inbounds %struct.anon.36, ptr %fdp33, i32 0, i32 3
  %41 = load i16, ptr %nrg34, align 2
  %conv35 = zext i16 %41 to i32
  %cmp36 = icmp slt i32 %conv32, %conv35
  br i1 %cmp36, label %for.body38, label %for.end

for.body38:                                       ; preds = %for.cond31
  %42 = load ptr, ptr %ns, align 8
  %43 = load i16, ptr %rg, align 2
  %44 = load i16, ptr %ph, align 2
  %call39 = call zeroext i16 @nvme_make_pid(ptr noundef %42, i16 noundef zeroext %43, i16 noundef zeroext %44)
  store i16 %call39, ptr %pid, align 2
  %45 = load i16, ptr %pid, align 2
  %call40 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %45)
  %46 = load ptr, ptr %ruhsd, align 8
  %pid41 = getelementptr inbounds %struct.NvmeRuhStatusDescr, ptr %46, i32 0, i32 0
  store i16 %call40, ptr %pid41, align 1
  %47 = load ptr, ptr %ruhid, align 8
  %48 = load i16, ptr %47, align 2
  %49 = load ptr, ptr %ruhsd, align 8
  %ruhid42 = getelementptr inbounds %struct.NvmeRuhStatusDescr, ptr %49, i32 0, i32 1
  store i16 %48, ptr %ruhid42, align 1
  %50 = load ptr, ptr %ruhsd, align 8
  %earutr = getelementptr inbounds %struct.NvmeRuhStatusDescr, ptr %50, i32 0, i32 2
  store i32 0, ptr %earutr, align 1
  %51 = load ptr, ptr %ruh, align 8
  %rus = getelementptr inbounds %struct.NvmeRuHandle, ptr %51, i32 0, i32 5
  %52 = load ptr, ptr %rus, align 8
  %53 = load i16, ptr %rg, align 2
  %idxprom43 = zext i16 %53 to i64
  %arrayidx44 = getelementptr %struct.NvmeReclaimUnit, ptr %52, i64 %idxprom43
  %ruamw = getelementptr inbounds %struct.NvmeReclaimUnit, ptr %arrayidx44, i32 0, i32 0
  %54 = load i64, ptr %ruamw, align 8
  %call45 = call i64 @cpu_to_le64(i64 noundef %54)
  %55 = load ptr, ptr %ruhsd, align 8
  %ruamw46 = getelementptr inbounds %struct.NvmeRuhStatusDescr, ptr %55, i32 0, i32 3
  store i64 %call45, ptr %ruamw46, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body38
  %56 = load i16, ptr %rg, align 2
  %inc = add i16 %56, 1
  store i16 %inc, ptr %rg, align 2
  %57 = load ptr, ptr %ruhsd, align 8
  %incdec.ptr = getelementptr %struct.NvmeRuhStatusDescr, ptr %57, i32 1
  store ptr %incdec.ptr, ptr %ruhsd, align 8
  br label %for.cond31, !llvm.loop !41

for.end:                                          ; preds = %for.cond31
  br label %for.inc47

for.inc47:                                        ; preds = %for.end
  %58 = load i16, ptr %ph, align 2
  %inc48 = add i16 %58, 1
  store i16 %inc48, ptr %ph, align 2
  %59 = load ptr, ptr %ruhid, align 8
  %incdec.ptr49 = getelementptr i16, ptr %59, i32 1
  store ptr %incdec.ptr49, ptr %ruhid, align 8
  br label %for.cond, !llvm.loop !42

for.end50:                                        ; preds = %for.cond
  %60 = load ptr, ptr %n.addr, align 8
  %61 = load ptr, ptr %buf, align 8
  %62 = load i64, ptr %trans_len, align 8
  %conv51 = trunc i64 %62 to i32
  %63 = load ptr, ptr %req.addr, align 8
  %call52 = call zeroext i16 @nvme_c2h(ptr noundef %60, ptr noundef %61, i32 noundef %conv51, ptr noundef %63)
  store i16 %call52, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end50, %if.then10, %if.then5, %if.then
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %buf)
  %64 = load i16, ptr %retval, align 2
  ret i16 %64
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_make_pid(ptr noundef %ns, i16 noundef zeroext %rg, i16 noundef zeroext %ph) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %rg.addr = alloca i16, align 2
  %ph.addr = alloca i16, align 2
  %rgif = alloca i16, align 2
  store ptr %ns, ptr %ns.addr, align 8
  store i16 %rg, ptr %rg.addr, align 2
  store i16 %ph, ptr %ph.addr, align 2
  %0 = load ptr, ptr %ns.addr, align 8
  %endgrp = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 32
  %1 = load ptr, ptr %endgrp, align 8
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %1, i32 0, i32 1
  %rgif1 = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 4
  %2 = load i8, ptr %rgif1, align 4
  %conv = zext i8 %2 to i16
  store i16 %conv, ptr %rgif, align 2
  %3 = load i16, ptr %rgif, align 2
  %tobool = icmp ne i16 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load i16, ptr %ph.addr, align 2
  store i16 %4, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i16, ptr %rg.addr, align 2
  %conv2 = zext i16 %5 to i32
  %6 = load i16, ptr %rgif, align 2
  %conv3 = zext i16 %6 to i32
  %sub = sub i32 16, %conv3
  %shl = shl i32 %conv2, %sub
  %7 = load i16, ptr %ph.addr, align 2
  %conv4 = zext i16 %7 to i32
  %or = or i32 %shl, %conv4
  %conv5 = trunc i32 %or to i16
  store i16 %conv5, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i16, ptr %retval, align 2
  ret i16 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_io_mgmt_send_ruh_update(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %cdw10 = alloca i32, align 4
  %ret = alloca i16, align 2
  %npid = alloca i32, align 4
  %i = alloca i32, align 4
  %pids = alloca ptr, align 8
  %maxnpid = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %_a25 = alloca i32, align 4
  %_b26 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd1, ptr %cmd, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %ns2 = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %ns2, align 8
  store ptr %2, ptr %ns, align 8
  %3 = load ptr, ptr %cmd, align 8
  %cdw103 = getelementptr inbounds %struct.NvmeCmd, ptr %3, i32 0, i32 7
  %4 = load i32, ptr %cdw103, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %4)
  store i32 %call, ptr %cdw10, align 4
  store i16 0, ptr %ret, align 2
  %5 = load i32, ptr %cdw10, align 4
  %shr = lshr i32 %5, 1
  %add = add i32 %shr, 1
  store i32 %add, ptr %npid, align 4
  store i32 0, ptr %i, align 4
  store ptr null, ptr %pids, align 8
  %6 = load ptr, ptr %ns, align 8
  %endgrp = getelementptr inbounds %struct.NvmeNamespace, ptr %6, i32 0, i32 32
  %7 = load ptr, ptr %endgrp, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %8 = load ptr, ptr %ns, align 8
  %endgrp4 = getelementptr inbounds %struct.NvmeNamespace, ptr %8, i32 0, i32 32
  %9 = load ptr, ptr %endgrp4, align 8
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %9, i32 0, i32 1
  %enabled = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 9
  %10 = load i8, ptr %enabled, align 8
  %tobool5 = trunc i8 %10 to i1
  br i1 %tobool5, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i16 16425, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %11 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %11, i32 0, i32 33
  %12 = load ptr, ptr %subsys, align 8
  %endgrp6 = getelementptr inbounds %struct.NvmeSubsystem, ptr %12, i32 0, i32 6
  %fdp7 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %endgrp6, i32 0, i32 1
  %nrg = getelementptr inbounds %struct.anon.36, ptr %fdp7, i32 0, i32 3
  %13 = load i16, ptr %nrg, align 2
  %conv = zext i16 %13 to i32
  %14 = load ptr, ptr %n.addr, align 8
  %subsys8 = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 33
  %15 = load ptr, ptr %subsys8, align 8
  %endgrp9 = getelementptr inbounds %struct.NvmeSubsystem, ptr %15, i32 0, i32 6
  %fdp10 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %endgrp9, i32 0, i32 1
  %nruh = getelementptr inbounds %struct.anon.36, ptr %fdp10, i32 0, i32 2
  %16 = load i16, ptr %nruh, align 8
  %conv11 = zext i16 %16 to i32
  %mul = mul i32 %conv, %conv11
  store i32 %mul, ptr %maxnpid, align 4
  %17 = load i32, ptr %npid, align 4
  store i32 128, ptr %_a25, align 4
  %18 = load i32, ptr %maxnpid, align 4
  store i32 %18, ptr %_b26, align 4
  %19 = load i32, ptr %_a25, align 4
  %20 = load i32, ptr %_b26, align 4
  %cmp = icmp ult i32 %19, %20
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %21 = load i32, ptr %_a25, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %22 = load i32, ptr %_b26, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %21, %cond.true ], [ %22, %cond.false ]
  store i32 %cond, ptr %tmp, align 4
  %23 = load i32, ptr %tmp, align 4
  %cmp13 = icmp uge i32 %17, %23
  %lnot = xor i1 %cmp13, true
  %lnot15 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot15 to i32
  %conv16 = sext i32 %lnot.ext to i64
  %tobool17 = icmp ne i64 %conv16, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %cond.end
  store i16 16386, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end19:                                         ; preds = %cond.end
  %24 = load i32, ptr %npid, align 4
  %conv20 = zext i32 %24 to i64
  %call21 = call noalias ptr @g_malloc_n(i64 noundef %conv20, i64 noundef 2) #11
  store ptr %call21, ptr %pids, align 8
  %25 = load ptr, ptr %n.addr, align 8
  %26 = load ptr, ptr %pids, align 8
  %27 = load i32, ptr %npid, align 4
  %conv22 = zext i32 %27 to i64
  %mul23 = mul i64 %conv22, 2
  %conv24 = trunc i64 %mul23 to i32
  %28 = load ptr, ptr %req.addr, align 8
  %call25 = call zeroext i16 @nvme_h2c(ptr noundef %25, ptr noundef %26, i32 noundef %conv24, ptr noundef %28)
  store i16 %call25, ptr %ret, align 2
  %29 = load i16, ptr %ret, align 2
  %tobool26 = icmp ne i16 %29, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end19
  %30 = load i16, ptr %ret, align 2
  store i16 %30, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end28:                                         ; preds = %if.end19
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end28
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %npid, align 4
  %cmp29 = icmp ult i32 %31, %32
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %33 = load ptr, ptr %n.addr, align 8
  %34 = load ptr, ptr %ns, align 8
  %35 = load ptr, ptr %pids, align 8
  %36 = load i32, ptr %i, align 4
  %idxprom = zext i32 %36 to i64
  %arrayidx = getelementptr i16, ptr %35, i64 %idxprom
  %37 = load i16, ptr %arrayidx, align 2
  %call31 = call zeroext i1 @nvme_update_ruh(ptr noundef %33, ptr noundef %34, i16 noundef zeroext %37)
  br i1 %call31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %for.body
  store i16 16386, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end33:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end33
  %38 = load i32, ptr %i, align 4
  %inc = add i32 %38, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !43

for.end:                                          ; preds = %for.cond
  %39 = load i16, ptr %ret, align 2
  store i16 %39, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then32, %if.then27, %if.then18, %if.then
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %pids)
  %40 = load i16, ptr %retval, align 2
  ret i16 %40
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_admin_cmd(i16 noundef zeroext %cid, i16 noundef zeroext %sqid, i8 noundef zeroext %opcode, ptr noundef %opname) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %sqid.addr = alloca i16, align 2
  %opcode.addr = alloca i8, align 1
  %opname.addr = alloca ptr, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i16 %sqid, ptr %sqid.addr, align 2
  store i8 %opcode, ptr %opcode.addr, align 1
  store ptr %opname, ptr %opname.addr, align 8
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i16, ptr %sqid.addr, align 2
  %2 = load i8, ptr %opcode.addr, align 1
  %3 = load ptr, ptr %opname.addr, align 8
  call void @_nocheck__trace_pci_nvme_admin_cmd(i16 noundef zeroext %0, i16 noundef zeroext %1, i8 noundef zeroext %2, ptr noundef %3)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_adm_opc_str(i8 noundef zeroext %opc) #0 {
entry:
  %retval = alloca ptr, align 8
  %opc.addr = alloca i8, align 1
  store i8 %opc, ptr %opc.addr, align 1
  %0 = load i8, ptr %opc.addr, align 1
  %conv = zext i8 %0 to i32
  switch i32 %conv, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
    i32 4, label %sw.bb3
    i32 5, label %sw.bb4
    i32 6, label %sw.bb5
    i32 8, label %sw.bb6
    i32 9, label %sw.bb7
    i32 10, label %sw.bb8
    i32 12, label %sw.bb9
    i32 21, label %sw.bb10
    i32 25, label %sw.bb11
    i32 28, label %sw.bb12
    i32 26, label %sw.bb13
    i32 124, label %sw.bb14
    i32 128, label %sw.bb15
  ]

sw.bb:                                            ; preds = %entry
  store ptr @.str.292, ptr %retval, align 8
  br label %return

sw.bb1:                                           ; preds = %entry
  store ptr @.str.293, ptr %retval, align 8
  br label %return

sw.bb2:                                           ; preds = %entry
  store ptr @.str.294, ptr %retval, align 8
  br label %return

sw.bb3:                                           ; preds = %entry
  store ptr @.str.295, ptr %retval, align 8
  br label %return

sw.bb4:                                           ; preds = %entry
  store ptr @.str.296, ptr %retval, align 8
  br label %return

sw.bb5:                                           ; preds = %entry
  store ptr @.str.297, ptr %retval, align 8
  br label %return

sw.bb6:                                           ; preds = %entry
  store ptr @.str.298, ptr %retval, align 8
  br label %return

sw.bb7:                                           ; preds = %entry
  store ptr @.str.299, ptr %retval, align 8
  br label %return

sw.bb8:                                           ; preds = %entry
  store ptr @.str.300, ptr %retval, align 8
  br label %return

sw.bb9:                                           ; preds = %entry
  store ptr @.str.301, ptr %retval, align 8
  br label %return

sw.bb10:                                          ; preds = %entry
  store ptr @.str.302, ptr %retval, align 8
  br label %return

sw.bb11:                                          ; preds = %entry
  store ptr @.str.303, ptr %retval, align 8
  br label %return

sw.bb12:                                          ; preds = %entry
  store ptr @.str.304, ptr %retval, align 8
  br label %return

sw.bb13:                                          ; preds = %entry
  store ptr @.str.305, ptr %retval, align 8
  br label %return

sw.bb14:                                          ; preds = %entry
  store ptr @.str.306, ptr %retval, align 8
  br label %return

sw.bb15:                                          ; preds = %entry
  store ptr @.str.307, ptr %retval, align 8
  br label %return

sw.default:                                       ; preds = %entry
  store ptr @.str.308, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.default, %sw.bb15, %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_admin_opc(i8 noundef zeroext %opc) #0 {
entry:
  %opc.addr = alloca i8, align 1
  store i8 %opc, ptr %opc.addr, align 1
  %0 = load i8, ptr %opc.addr, align 1
  call void @_nocheck__trace_pci_nvme_err_invalid_admin_opc(i8 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_del_sq(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %r = alloca ptr, align 8
  %next = alloca ptr, align 8
  %sq = alloca ptr, align 8
  %cq = alloca ptr, align 8
  %qid = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %qid1 = getelementptr inbounds %struct.NvmeDeleteQ, ptr %1, i32 0, i32 4
  %2 = load i16, ptr %qid1, align 1
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %2)
  store i16 %call, ptr %qid, align 2
  %3 = load i16, ptr %qid, align 2
  %tobool = icmp ne i16 %3, 0
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %4 = load ptr, ptr %n.addr, align 8
  %5 = load i16, ptr %qid, align 2
  %call2 = call i32 @nvme_check_sqid(ptr noundef %4, i16 noundef zeroext %5)
  %tobool3 = icmp ne i32 %call2, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %6 = phi i1 [ true, %entry ], [ %tobool3, %lor.rhs ]
  %lnot = xor i1 %6, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  %7 = load i16, ptr %qid, align 2
  call void @trace_pci_nvme_err_invalid_del_sq(i16 noundef zeroext %7)
  store i16 16641, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %lor.end
  %8 = load i16, ptr %qid, align 2
  call void @trace_pci_nvme_del_sq(i16 noundef zeroext %8)
  %9 = load ptr, ptr %n.addr, align 8
  %sq6 = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 36
  %10 = load ptr, ptr %sq6, align 16
  %11 = load i16, ptr %qid, align 2
  %idxprom = zext i16 %11 to i64
  %arrayidx = getelementptr ptr, ptr %10, i64 %idxprom
  %12 = load ptr, ptr %arrayidx, align 8
  store ptr %12, ptr %sq, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end13, %if.end
  %13 = load ptr, ptr %sq, align 8
  %out_req_list = getelementptr inbounds %struct.NvmeSQueue, ptr %13, i32 0, i32 14
  %14 = load ptr, ptr %out_req_list, align 8
  %cmp = icmp eq ptr %14, null
  %lnot8 = xor i1 %cmp, true
  br i1 %lnot8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %15 = load ptr, ptr %sq, align 8
  %out_req_list10 = getelementptr inbounds %struct.NvmeSQueue, ptr %15, i32 0, i32 14
  %16 = load ptr, ptr %out_req_list10, align 8
  store ptr %16, ptr %r, align 8
  %17 = load ptr, ptr %r, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %aiocb, align 8
  %tobool11 = icmp ne ptr %18, null
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %while.body
  br label %if.end13

if.else:                                          ; preds = %while.body
  call void @__assert_fail(ptr noundef @.str.312, ptr noundef @.str.1, i32 noundef 4594, ptr noundef @__PRETTY_FUNCTION__.nvme_del_sq) #12
  unreachable

if.end13:                                         ; preds = %if.then12
  %19 = load ptr, ptr %r, align 8
  %aiocb14 = getelementptr inbounds %struct.NvmeRequest, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %aiocb14, align 8
  call void @blk_aio_cancel(ptr noundef %20)
  br label %while.cond, !llvm.loop !44

while.end:                                        ; preds = %while.cond
  %21 = load ptr, ptr %sq, align 8
  %out_req_list15 = getelementptr inbounds %struct.NvmeSQueue, ptr %21, i32 0, i32 14
  %22 = load ptr, ptr %out_req_list15, align 8
  %cmp16 = icmp eq ptr %22, null
  br i1 %cmp16, label %if.then18, label %if.else19

if.then18:                                        ; preds = %while.end
  br label %if.end20

if.else19:                                        ; preds = %while.end
  call void @__assert_fail(ptr noundef @.str.313, ptr noundef @.str.1, i32 noundef 4598, ptr noundef @__PRETTY_FUNCTION__.nvme_del_sq) #12
  unreachable

if.end20:                                         ; preds = %if.then18
  %23 = load ptr, ptr %n.addr, align 8
  %24 = load ptr, ptr %sq, align 8
  %cqid = getelementptr inbounds %struct.NvmeSQueue, ptr %24, i32 0, i32 2
  %25 = load i16, ptr %cqid, align 2
  %call21 = call i32 @nvme_check_cqid(ptr noundef %23, i16 noundef zeroext %25)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.end95, label %if.then23

if.then23:                                        ; preds = %if.end20
  %26 = load ptr, ptr %n.addr, align 8
  %cq24 = getelementptr inbounds %struct.NvmeCtrl, ptr %26, i32 0, i32 37
  %27 = load ptr, ptr %cq24, align 8
  %28 = load ptr, ptr %sq, align 8
  %cqid25 = getelementptr inbounds %struct.NvmeSQueue, ptr %28, i32 0, i32 2
  %29 = load i16, ptr %cqid25, align 2
  %idxprom26 = zext i16 %29 to i64
  %arrayidx27 = getelementptr ptr, ptr %27, i64 %idxprom26
  %30 = load ptr, ptr %arrayidx27, align 8
  store ptr %30, ptr %cq, align 8
  br label %do.body

do.body:                                          ; preds = %if.then23
  %31 = load ptr, ptr %sq, align 8
  %entry28 = getelementptr inbounds %struct.NvmeSQueue, ptr %31, i32 0, i32 15
  %32 = load ptr, ptr %entry28, align 8
  %cmp29 = icmp ne ptr %32, null
  br i1 %cmp29, label %if.then31, label %if.else36

if.then31:                                        ; preds = %do.body
  %33 = load ptr, ptr %sq, align 8
  %entry32 = getelementptr inbounds %struct.NvmeSQueue, ptr %33, i32 0, i32 15
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %entry32, i32 0, i32 1
  %34 = load ptr, ptr %tql_prev, align 8
  %35 = load ptr, ptr %sq, align 8
  %entry33 = getelementptr inbounds %struct.NvmeSQueue, ptr %35, i32 0, i32 15
  %36 = load ptr, ptr %entry33, align 8
  %entry34 = getelementptr inbounds %struct.NvmeSQueue, ptr %36, i32 0, i32 15
  %tql_prev35 = getelementptr inbounds %struct.QTailQLink, ptr %entry34, i32 0, i32 1
  store ptr %34, ptr %tql_prev35, align 8
  br label %if.end40

if.else36:                                        ; preds = %do.body
  %37 = load ptr, ptr %sq, align 8
  %entry37 = getelementptr inbounds %struct.NvmeSQueue, ptr %37, i32 0, i32 15
  %tql_prev38 = getelementptr inbounds %struct.QTailQLink, ptr %entry37, i32 0, i32 1
  %38 = load ptr, ptr %tql_prev38, align 8
  %39 = load ptr, ptr %cq, align 8
  %sq_list = getelementptr inbounds %struct.NvmeCQueue, ptr %39, i32 0, i32 14
  %tql_prev39 = getelementptr inbounds %struct.QTailQLink, ptr %sq_list, i32 0, i32 1
  store ptr %38, ptr %tql_prev39, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.else36, %if.then31
  %40 = load ptr, ptr %sq, align 8
  %entry41 = getelementptr inbounds %struct.NvmeSQueue, ptr %40, i32 0, i32 15
  %41 = load ptr, ptr %entry41, align 8
  %42 = load ptr, ptr %sq, align 8
  %entry42 = getelementptr inbounds %struct.NvmeSQueue, ptr %42, i32 0, i32 15
  %tql_prev43 = getelementptr inbounds %struct.QTailQLink, ptr %entry42, i32 0, i32 1
  %43 = load ptr, ptr %tql_prev43, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %43, i32 0, i32 0
  store ptr %41, ptr %tql_next, align 8
  %44 = load ptr, ptr %sq, align 8
  %entry44 = getelementptr inbounds %struct.NvmeSQueue, ptr %44, i32 0, i32 15
  %tql_prev45 = getelementptr inbounds %struct.QTailQLink, ptr %entry44, i32 0, i32 1
  store ptr null, ptr %tql_prev45, align 8
  %45 = load ptr, ptr %sq, align 8
  %entry46 = getelementptr inbounds %struct.NvmeSQueue, ptr %45, i32 0, i32 15
  %tql_next47 = getelementptr inbounds %struct.QTailQLink, ptr %entry46, i32 0, i32 0
  store ptr null, ptr %tql_next47, align 8
  %46 = load ptr, ptr %sq, align 8
  %entry48 = getelementptr inbounds %struct.NvmeSQueue, ptr %46, i32 0, i32 15
  store ptr null, ptr %entry48, align 8
  br label %do.end

do.end:                                           ; preds = %if.end40
  %47 = load ptr, ptr %cq, align 8
  call void @nvme_post_cqes(ptr noundef %47)
  %48 = load ptr, ptr %cq, align 8
  %req_list = getelementptr inbounds %struct.NvmeCQueue, ptr %48, i32 0, i32 15
  %49 = load ptr, ptr %req_list, align 8
  store ptr %49, ptr %r, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %50 = load ptr, ptr %r, align 8
  %tobool49 = icmp ne ptr %50, null
  br i1 %tobool49, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %51 = load ptr, ptr %r, align 8
  %entry50 = getelementptr inbounds %struct.NvmeRequest, ptr %51, i32 0, i32 9
  %52 = load ptr, ptr %entry50, align 8
  store ptr %52, ptr %next, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %53 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %53, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %54 = load ptr, ptr %r, align 8
  %sq51 = getelementptr inbounds %struct.NvmeRequest, ptr %54, i32 0, i32 0
  %55 = load ptr, ptr %sq51, align 8
  %56 = load ptr, ptr %sq, align 8
  %cmp52 = icmp eq ptr %55, %56
  br i1 %cmp52, label %if.then54, label %if.end94

if.then54:                                        ; preds = %for.body
  br label %do.body55

do.body55:                                        ; preds = %if.then54
  %57 = load ptr, ptr %r, align 8
  %entry56 = getelementptr inbounds %struct.NvmeRequest, ptr %57, i32 0, i32 9
  %58 = load ptr, ptr %entry56, align 8
  %cmp57 = icmp ne ptr %58, null
  br i1 %cmp57, label %if.then59, label %if.else65

if.then59:                                        ; preds = %do.body55
  %59 = load ptr, ptr %r, align 8
  %entry60 = getelementptr inbounds %struct.NvmeRequest, ptr %59, i32 0, i32 9
  %tql_prev61 = getelementptr inbounds %struct.QTailQLink, ptr %entry60, i32 0, i32 1
  %60 = load ptr, ptr %tql_prev61, align 8
  %61 = load ptr, ptr %r, align 8
  %entry62 = getelementptr inbounds %struct.NvmeRequest, ptr %61, i32 0, i32 9
  %62 = load ptr, ptr %entry62, align 8
  %entry63 = getelementptr inbounds %struct.NvmeRequest, ptr %62, i32 0, i32 9
  %tql_prev64 = getelementptr inbounds %struct.QTailQLink, ptr %entry63, i32 0, i32 1
  store ptr %60, ptr %tql_prev64, align 8
  br label %if.end70

if.else65:                                        ; preds = %do.body55
  %63 = load ptr, ptr %r, align 8
  %entry66 = getelementptr inbounds %struct.NvmeRequest, ptr %63, i32 0, i32 9
  %tql_prev67 = getelementptr inbounds %struct.QTailQLink, ptr %entry66, i32 0, i32 1
  %64 = load ptr, ptr %tql_prev67, align 8
  %65 = load ptr, ptr %cq, align 8
  %req_list68 = getelementptr inbounds %struct.NvmeCQueue, ptr %65, i32 0, i32 15
  %tql_prev69 = getelementptr inbounds %struct.QTailQLink, ptr %req_list68, i32 0, i32 1
  store ptr %64, ptr %tql_prev69, align 8
  br label %if.end70

if.end70:                                         ; preds = %if.else65, %if.then59
  %66 = load ptr, ptr %r, align 8
  %entry71 = getelementptr inbounds %struct.NvmeRequest, ptr %66, i32 0, i32 9
  %67 = load ptr, ptr %entry71, align 8
  %68 = load ptr, ptr %r, align 8
  %entry72 = getelementptr inbounds %struct.NvmeRequest, ptr %68, i32 0, i32 9
  %tql_prev73 = getelementptr inbounds %struct.QTailQLink, ptr %entry72, i32 0, i32 1
  %69 = load ptr, ptr %tql_prev73, align 8
  %tql_next74 = getelementptr inbounds %struct.QTailQLink, ptr %69, i32 0, i32 0
  store ptr %67, ptr %tql_next74, align 8
  %70 = load ptr, ptr %r, align 8
  %entry75 = getelementptr inbounds %struct.NvmeRequest, ptr %70, i32 0, i32 9
  %tql_prev76 = getelementptr inbounds %struct.QTailQLink, ptr %entry75, i32 0, i32 1
  store ptr null, ptr %tql_prev76, align 8
  %71 = load ptr, ptr %r, align 8
  %entry77 = getelementptr inbounds %struct.NvmeRequest, ptr %71, i32 0, i32 9
  %tql_next78 = getelementptr inbounds %struct.QTailQLink, ptr %entry77, i32 0, i32 0
  store ptr null, ptr %tql_next78, align 8
  %72 = load ptr, ptr %r, align 8
  %entry79 = getelementptr inbounds %struct.NvmeRequest, ptr %72, i32 0, i32 9
  store ptr null, ptr %entry79, align 8
  br label %do.end80

do.end80:                                         ; preds = %if.end70
  br label %do.body81

do.body81:                                        ; preds = %do.end80
  %73 = load ptr, ptr %r, align 8
  %entry82 = getelementptr inbounds %struct.NvmeRequest, ptr %73, i32 0, i32 9
  store ptr null, ptr %entry82, align 8
  %74 = load ptr, ptr %sq, align 8
  %req_list83 = getelementptr inbounds %struct.NvmeSQueue, ptr %74, i32 0, i32 13
  %tql_prev84 = getelementptr inbounds %struct.QTailQLink, ptr %req_list83, i32 0, i32 1
  %75 = load ptr, ptr %tql_prev84, align 8
  %76 = load ptr, ptr %r, align 8
  %entry85 = getelementptr inbounds %struct.NvmeRequest, ptr %76, i32 0, i32 9
  %tql_prev86 = getelementptr inbounds %struct.QTailQLink, ptr %entry85, i32 0, i32 1
  store ptr %75, ptr %tql_prev86, align 8
  %77 = load ptr, ptr %r, align 8
  %78 = load ptr, ptr %sq, align 8
  %req_list87 = getelementptr inbounds %struct.NvmeSQueue, ptr %78, i32 0, i32 13
  %tql_prev88 = getelementptr inbounds %struct.QTailQLink, ptr %req_list87, i32 0, i32 1
  %79 = load ptr, ptr %tql_prev88, align 8
  %tql_next89 = getelementptr inbounds %struct.QTailQLink, ptr %79, i32 0, i32 0
  store ptr %77, ptr %tql_next89, align 8
  %80 = load ptr, ptr %r, align 8
  %entry90 = getelementptr inbounds %struct.NvmeRequest, ptr %80, i32 0, i32 9
  %81 = load ptr, ptr %sq, align 8
  %req_list91 = getelementptr inbounds %struct.NvmeSQueue, ptr %81, i32 0, i32 13
  %tql_prev92 = getelementptr inbounds %struct.QTailQLink, ptr %req_list91, i32 0, i32 1
  store ptr %entry90, ptr %tql_prev92, align 8
  br label %do.end93

do.end93:                                         ; preds = %do.body81
  br label %if.end94

if.end94:                                         ; preds = %do.end93, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end94
  %82 = load ptr, ptr %next, align 8
  store ptr %82, ptr %r, align 8
  br label %for.cond, !llvm.loop !45

for.end:                                          ; preds = %land.end
  br label %if.end95

if.end95:                                         ; preds = %for.end, %if.end20
  %83 = load ptr, ptr %sq, align 8
  %84 = load ptr, ptr %n.addr, align 8
  call void @nvme_free_sq(ptr noundef %83, ptr noundef %84)
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end95, %if.then
  %85 = load i16, ptr %retval, align 2
  ret i16 %85
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_create_sq(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %sq = alloca ptr, align 8
  %c = alloca ptr, align 8
  %cqid = alloca i16, align 2
  %sqid = alloca i16, align 2
  %qsize = alloca i16, align 2
  %qflags = alloca i16, align 2
  %prp1 = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cqid1 = getelementptr inbounds %struct.NvmeCreateSq, ptr %1, i32 0, i32 9
  %2 = load i16, ptr %cqid1, align 1
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %2)
  store i16 %call, ptr %cqid, align 2
  %3 = load ptr, ptr %c, align 8
  %sqid2 = getelementptr inbounds %struct.NvmeCreateSq, ptr %3, i32 0, i32 6
  %4 = load i16, ptr %sqid2, align 1
  %call3 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %4)
  store i16 %call3, ptr %sqid, align 2
  %5 = load ptr, ptr %c, align 8
  %qsize4 = getelementptr inbounds %struct.NvmeCreateSq, ptr %5, i32 0, i32 7
  %6 = load i16, ptr %qsize4, align 1
  %call5 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %6)
  store i16 %call5, ptr %qsize, align 2
  %7 = load ptr, ptr %c, align 8
  %sq_flags = getelementptr inbounds %struct.NvmeCreateSq, ptr %7, i32 0, i32 8
  %8 = load i16, ptr %sq_flags, align 1
  %call6 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %8)
  store i16 %call6, ptr %qflags, align 2
  %9 = load ptr, ptr %c, align 8
  %prp17 = getelementptr inbounds %struct.NvmeCreateSq, ptr %9, i32 0, i32 4
  %10 = load i64, ptr %prp17, align 1
  %call8 = call i64 @le64_to_cpu(i64 noundef %10)
  store i64 %call8, ptr %prp1, align 8
  %11 = load i64, ptr %prp1, align 8
  %12 = load i16, ptr %sqid, align 2
  %13 = load i16, ptr %cqid, align 2
  %14 = load i16, ptr %qsize, align 2
  %15 = load i16, ptr %qflags, align 2
  call void @trace_pci_nvme_create_sq(i64 noundef %11, i16 noundef zeroext %12, i16 noundef zeroext %13, i16 noundef zeroext %14, i16 noundef zeroext %15)
  %16 = load i16, ptr %cqid, align 2
  %tobool = icmp ne i16 %16, 0
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %17 = load ptr, ptr %n.addr, align 8
  %18 = load i16, ptr %cqid, align 2
  %call9 = call i32 @nvme_check_cqid(ptr noundef %17, i16 noundef zeroext %18)
  %tobool10 = icmp ne i32 %call9, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %19 = phi i1 [ true, %entry ], [ %tobool10, %lor.rhs ]
  %lnot = xor i1 %19, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool12 = icmp ne i64 %conv, 0
  br i1 %tobool12, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  %20 = load i16, ptr %cqid, align 2
  call void @trace_pci_nvme_err_invalid_create_sq_cqid(i16 noundef zeroext %20)
  store i16 16640, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %lor.end
  %21 = load i16, ptr %sqid, align 2
  %tobool13 = icmp ne i16 %21, 0
  br i1 %tobool13, label %lor.lhs.false, label %lor.end20

lor.lhs.false:                                    ; preds = %if.end
  %22 = load i16, ptr %sqid, align 2
  %conv14 = zext i16 %22 to i32
  %23 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs = getelementptr inbounds %struct.NvmeCtrl, ptr %23, i32 0, i32 21
  %24 = load i32, ptr %conf_ioqpairs, align 8
  %cmp = icmp ugt i32 %conv14, %24
  br i1 %cmp, label %lor.end20, label %lor.rhs16

lor.rhs16:                                        ; preds = %lor.lhs.false
  %25 = load ptr, ptr %n.addr, align 8
  %sq17 = getelementptr inbounds %struct.NvmeCtrl, ptr %25, i32 0, i32 36
  %26 = load ptr, ptr %sq17, align 16
  %27 = load i16, ptr %sqid, align 2
  %idxprom = zext i16 %27 to i64
  %arrayidx = getelementptr ptr, ptr %26, i64 %idxprom
  %28 = load ptr, ptr %arrayidx, align 8
  %cmp18 = icmp ne ptr %28, null
  br label %lor.end20

lor.end20:                                        ; preds = %lor.rhs16, %lor.lhs.false, %if.end
  %29 = phi i1 [ true, %lor.lhs.false ], [ true, %if.end ], [ %cmp18, %lor.rhs16 ]
  %lnot21 = xor i1 %29, true
  %lnot23 = xor i1 %lnot21, true
  %lnot.ext24 = zext i1 %lnot23 to i32
  %conv25 = sext i32 %lnot.ext24 to i64
  %tobool26 = icmp ne i64 %conv25, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %lor.end20
  %30 = load i16, ptr %sqid, align 2
  call void @trace_pci_nvme_err_invalid_create_sq_sqid(i16 noundef zeroext %30)
  store i16 16641, ptr %retval, align 2
  br label %return

if.end28:                                         ; preds = %lor.end20
  %31 = load i16, ptr %qsize, align 2
  %tobool29 = icmp ne i16 %31, 0
  br i1 %tobool29, label %lor.rhs30, label %lor.end35

lor.rhs30:                                        ; preds = %if.end28
  %32 = load i16, ptr %qsize, align 2
  %conv31 = zext i16 %32 to i64
  %33 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %33, i32 0, i32 3
  %cap = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 0
  %call32 = call i64 @ldq_le_p(ptr noundef %cap)
  %shr = lshr i64 %call32, 0
  %and = and i64 %shr, 65535
  %cmp33 = icmp ugt i64 %conv31, %and
  br label %lor.end35

lor.end35:                                        ; preds = %lor.rhs30, %if.end28
  %34 = phi i1 [ true, %if.end28 ], [ %cmp33, %lor.rhs30 ]
  %lnot36 = xor i1 %34, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %conv40 = sext i32 %lnot.ext39 to i64
  %tobool41 = icmp ne i64 %conv40, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %lor.end35
  %35 = load i16, ptr %qsize, align 2
  call void @trace_pci_nvme_err_invalid_create_sq_size(i16 noundef zeroext %35)
  store i16 16642, ptr %retval, align 2
  br label %return

if.end43:                                         ; preds = %lor.end35
  %36 = load i64, ptr %prp1, align 8
  %37 = load ptr, ptr %n.addr, align 8
  %page_size = getelementptr inbounds %struct.NvmeCtrl, ptr %37, i32 0, i32 8
  %38 = load i32, ptr %page_size, align 4
  %sub = sub i32 %38, 1
  %conv44 = zext i32 %sub to i64
  %and45 = and i64 %36, %conv44
  %tobool46 = icmp ne i64 %and45, 0
  %lnot47 = xor i1 %tobool46, true
  %lnot49 = xor i1 %lnot47, true
  %lnot.ext50 = zext i1 %lnot49 to i32
  %conv51 = sext i32 %lnot.ext50 to i64
  %tobool52 = icmp ne i64 %conv51, 0
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end43
  %39 = load i64, ptr %prp1, align 8
  call void @trace_pci_nvme_err_invalid_create_sq_addr(i64 noundef %39)
  store i16 16403, ptr %retval, align 2
  br label %return

if.end54:                                         ; preds = %if.end43
  %40 = load i16, ptr %qflags, align 2
  %conv55 = zext i16 %40 to i32
  %and56 = and i32 %conv55, 1
  %tobool57 = icmp ne i32 %and56, 0
  %lnot58 = xor i1 %tobool57, true
  %lnot60 = xor i1 %lnot58, true
  %lnot62 = xor i1 %lnot60, true
  %lnot.ext63 = zext i1 %lnot62 to i32
  %conv64 = sext i32 %lnot.ext63 to i64
  %tobool65 = icmp ne i64 %conv64, 0
  br i1 %tobool65, label %if.then66, label %if.end70

if.then66:                                        ; preds = %if.end54
  %41 = load i16, ptr %qflags, align 2
  %conv67 = zext i16 %41 to i32
  %and68 = and i32 %conv67, 1
  %conv69 = trunc i32 %and68 to i16
  call void @trace_pci_nvme_err_invalid_create_sq_qflags(i16 noundef zeroext %conv69)
  store i16 16386, ptr %retval, align 2
  br label %return

if.end70:                                         ; preds = %if.end54
  %call71 = call noalias ptr @g_malloc0(i64 noundef 128) #14
  store ptr %call71, ptr %sq, align 8
  %42 = load ptr, ptr %sq, align 8
  %43 = load ptr, ptr %n.addr, align 8
  %44 = load i64, ptr %prp1, align 8
  %45 = load i16, ptr %sqid, align 2
  %46 = load i16, ptr %cqid, align 2
  %47 = load i16, ptr %qsize, align 2
  %conv72 = zext i16 %47 to i32
  %add = add i32 %conv72, 1
  %conv73 = trunc i32 %add to i16
  call void @nvme_init_sq(ptr noundef %42, ptr noundef %43, i64 noundef %44, i16 noundef zeroext %45, i16 noundef zeroext %46, i16 noundef zeroext %conv73)
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end70, %if.then66, %if.then53, %if.then42, %if.then27, %if.then
  %48 = load i16, ptr %retval, align 2
  ret i16 %48
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_get_log(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %dw10 = alloca i32, align 4
  %dw11 = alloca i32, align 4
  %dw12 = alloca i32, align 4
  %dw13 = alloca i32, align 4
  %lid = alloca i8, align 1
  %lsp = alloca i8, align 1
  %rae = alloca i8, align 1
  %csi = alloca i8, align 1
  %numdl = alloca i32, align 4
  %numdu = alloca i32, align 4
  %lspi = alloca i32, align 4
  %off = alloca i64, align 8
  %lpol = alloca i64, align 8
  %lpou = alloca i64, align 8
  %len = alloca i64, align 8
  %status = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd1, ptr %cmd, align 8
  %1 = load ptr, ptr %cmd, align 8
  %cdw10 = getelementptr inbounds %struct.NvmeCmd, ptr %1, i32 0, i32 7
  %2 = load i32, ptr %cdw10, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %dw10, align 4
  %3 = load ptr, ptr %cmd, align 8
  %cdw11 = getelementptr inbounds %struct.NvmeCmd, ptr %3, i32 0, i32 8
  %4 = load i32, ptr %cdw11, align 1
  %call2 = call i32 @le32_to_cpu(i32 noundef %4)
  store i32 %call2, ptr %dw11, align 4
  %5 = load ptr, ptr %cmd, align 8
  %cdw12 = getelementptr inbounds %struct.NvmeCmd, ptr %5, i32 0, i32 9
  %6 = load i32, ptr %cdw12, align 1
  %call3 = call i32 @le32_to_cpu(i32 noundef %6)
  store i32 %call3, ptr %dw12, align 4
  %7 = load ptr, ptr %cmd, align 8
  %cdw13 = getelementptr inbounds %struct.NvmeCmd, ptr %7, i32 0, i32 10
  %8 = load i32, ptr %cdw13, align 1
  %call4 = call i32 @le32_to_cpu(i32 noundef %8)
  store i32 %call4, ptr %dw13, align 4
  %9 = load i32, ptr %dw10, align 4
  %and = and i32 %9, 255
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %lid, align 1
  %10 = load i32, ptr %dw10, align 4
  %shr = lshr i32 %10, 8
  %and5 = and i32 %shr, 15
  %conv6 = trunc i32 %and5 to i8
  store i8 %conv6, ptr %lsp, align 1
  %11 = load i32, ptr %dw10, align 4
  %shr7 = lshr i32 %11, 15
  %and8 = and i32 %shr7, 1
  %conv9 = trunc i32 %and8 to i8
  store i8 %conv9, ptr %rae, align 1
  %12 = load ptr, ptr %cmd, align 8
  %cdw14 = getelementptr inbounds %struct.NvmeCmd, ptr %12, i32 0, i32 11
  %13 = load i32, ptr %cdw14, align 1
  %call10 = call i32 @le32_to_cpu(i32 noundef %13)
  %shr11 = lshr i32 %call10, 24
  %conv12 = trunc i32 %shr11 to i8
  store i8 %conv12, ptr %csi, align 1
  %14 = load i32, ptr %dw10, align 4
  %shr13 = lshr i32 %14, 16
  store i32 %shr13, ptr %numdl, align 4
  %15 = load i32, ptr %dw11, align 4
  %and14 = and i32 %15, 65535
  store i32 %and14, ptr %numdu, align 4
  %16 = load i32, ptr %dw11, align 4
  %shr15 = lshr i32 %16, 16
  store i32 %shr15, ptr %lspi, align 4
  %17 = load i32, ptr %dw12, align 4
  %conv16 = zext i32 %17 to i64
  store i64 %conv16, ptr %lpol, align 8
  %18 = load i32, ptr %dw13, align 4
  %conv17 = zext i32 %18 to i64
  store i64 %conv17, ptr %lpou, align 8
  %19 = load i32, ptr %numdu, align 4
  %shl = shl i32 %19, 16
  %20 = load i32, ptr %numdl, align 4
  %or = or i32 %shl, %20
  %add = add i32 %or, 1
  %shl18 = shl i32 %add, 2
  %conv19 = zext i32 %shl18 to i64
  store i64 %conv19, ptr %len, align 8
  %21 = load i64, ptr %lpou, align 8
  %shl20 = shl i64 %21, 32
  %22 = load i64, ptr %lpol, align 8
  %or21 = or i64 %shl20, %22
  store i64 %or21, ptr %off, align 8
  %23 = load i64, ptr %off, align 8
  %and22 = and i64 %23, 3
  %tobool = icmp ne i64 %and22, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %24 = load ptr, ptr %req.addr, align 8
  %call23 = call zeroext i16 @nvme_cid(ptr noundef %24)
  %25 = load i8, ptr %lid, align 1
  %26 = load i8, ptr %lsp, align 1
  %27 = load i8, ptr %rae, align 1
  %28 = load i64, ptr %len, align 8
  %conv24 = trunc i64 %28 to i32
  %29 = load i64, ptr %off, align 8
  call void @trace_pci_nvme_get_log(i16 noundef zeroext %call23, i8 noundef zeroext %25, i8 noundef zeroext %26, i8 noundef zeroext %27, i32 noundef %conv24, i64 noundef %29)
  %30 = load ptr, ptr %n.addr, align 8
  %31 = load i64, ptr %len, align 8
  %call25 = call zeroext i16 @nvme_check_mdts(ptr noundef %30, i64 noundef %31)
  store i16 %call25, ptr %status, align 2
  %32 = load i16, ptr %status, align 2
  %tobool26 = icmp ne i16 %32, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end
  %33 = load i16, ptr %status, align 2
  store i16 %33, ptr %retval, align 2
  br label %return

if.end28:                                         ; preds = %if.end
  %34 = load i8, ptr %lid, align 1
  %conv29 = zext i8 %34 to i32
  switch i32 %conv29, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb32
    i32 3, label %sw.bb35
    i32 4, label %sw.bb38
    i32 5, label %sw.bb41
    i32 9, label %sw.bb44
    i32 32, label %sw.bb47
    i32 33, label %sw.bb50
    i32 34, label %sw.bb53
    i32 35, label %sw.bb56
  ]

sw.bb:                                            ; preds = %if.end28
  %35 = load ptr, ptr %n.addr, align 8
  %36 = load i8, ptr %rae, align 1
  %37 = load i64, ptr %len, align 8
  %conv30 = trunc i64 %37 to i32
  %38 = load i64, ptr %off, align 8
  %39 = load ptr, ptr %req.addr, align 8
  %call31 = call zeroext i16 @nvme_error_info(ptr noundef %35, i8 noundef zeroext %36, i32 noundef %conv30, i64 noundef %38, ptr noundef %39)
  store i16 %call31, ptr %retval, align 2
  br label %return

sw.bb32:                                          ; preds = %if.end28
  %40 = load ptr, ptr %n.addr, align 8
  %41 = load i8, ptr %rae, align 1
  %42 = load i64, ptr %len, align 8
  %conv33 = trunc i64 %42 to i32
  %43 = load i64, ptr %off, align 8
  %44 = load ptr, ptr %req.addr, align 8
  %call34 = call zeroext i16 @nvme_smart_info(ptr noundef %40, i8 noundef zeroext %41, i32 noundef %conv33, i64 noundef %43, ptr noundef %44)
  store i16 %call34, ptr %retval, align 2
  br label %return

sw.bb35:                                          ; preds = %if.end28
  %45 = load ptr, ptr %n.addr, align 8
  %46 = load i64, ptr %len, align 8
  %conv36 = trunc i64 %46 to i32
  %47 = load i64, ptr %off, align 8
  %48 = load ptr, ptr %req.addr, align 8
  %call37 = call zeroext i16 @nvme_fw_log_info(ptr noundef %45, i32 noundef %conv36, i64 noundef %47, ptr noundef %48)
  store i16 %call37, ptr %retval, align 2
  br label %return

sw.bb38:                                          ; preds = %if.end28
  %49 = load ptr, ptr %n.addr, align 8
  %50 = load i8, ptr %rae, align 1
  %51 = load i64, ptr %len, align 8
  %conv39 = trunc i64 %51 to i32
  %52 = load i64, ptr %off, align 8
  %53 = load ptr, ptr %req.addr, align 8
  %call40 = call zeroext i16 @nvme_changed_nslist(ptr noundef %49, i8 noundef zeroext %50, i32 noundef %conv39, i64 noundef %52, ptr noundef %53)
  store i16 %call40, ptr %retval, align 2
  br label %return

sw.bb41:                                          ; preds = %if.end28
  %54 = load ptr, ptr %n.addr, align 8
  %55 = load i8, ptr %csi, align 1
  %56 = load i64, ptr %len, align 8
  %conv42 = trunc i64 %56 to i32
  %57 = load i64, ptr %off, align 8
  %58 = load ptr, ptr %req.addr, align 8
  %call43 = call zeroext i16 @nvme_cmd_effects(ptr noundef %54, i8 noundef zeroext %55, i32 noundef %conv42, i64 noundef %57, ptr noundef %58)
  store i16 %call43, ptr %retval, align 2
  br label %return

sw.bb44:                                          ; preds = %if.end28
  %59 = load ptr, ptr %n.addr, align 8
  %60 = load i8, ptr %rae, align 1
  %61 = load i64, ptr %len, align 8
  %conv45 = trunc i64 %61 to i32
  %62 = load i64, ptr %off, align 8
  %63 = load ptr, ptr %req.addr, align 8
  %call46 = call zeroext i16 @nvme_endgrp_info(ptr noundef %59, i8 noundef zeroext %60, i32 noundef %conv45, i64 noundef %62, ptr noundef %63)
  store i16 %call46, ptr %retval, align 2
  br label %return

sw.bb47:                                          ; preds = %if.end28
  %64 = load ptr, ptr %n.addr, align 8
  %65 = load i32, ptr %lspi, align 4
  %66 = load i64, ptr %len, align 8
  %conv48 = trunc i64 %66 to i32
  %67 = load i64, ptr %off, align 8
  %68 = load ptr, ptr %req.addr, align 8
  %call49 = call zeroext i16 @nvme_fdp_confs(ptr noundef %64, i32 noundef %65, i32 noundef %conv48, i64 noundef %67, ptr noundef %68)
  store i16 %call49, ptr %retval, align 2
  br label %return

sw.bb50:                                          ; preds = %if.end28
  %69 = load ptr, ptr %n.addr, align 8
  %70 = load i32, ptr %lspi, align 4
  %71 = load i32, ptr %dw10, align 4
  %72 = load i32, ptr %dw12, align 4
  %73 = load i64, ptr %len, align 8
  %conv51 = trunc i64 %73 to i32
  %74 = load i64, ptr %off, align 8
  %75 = load ptr, ptr %req.addr, align 8
  %call52 = call zeroext i16 @nvme_fdp_ruh_usage(ptr noundef %69, i32 noundef %70, i32 noundef %71, i32 noundef %72, i32 noundef %conv51, i64 noundef %74, ptr noundef %75)
  store i16 %call52, ptr %retval, align 2
  br label %return

sw.bb53:                                          ; preds = %if.end28
  %76 = load ptr, ptr %n.addr, align 8
  %77 = load i32, ptr %lspi, align 4
  %78 = load i64, ptr %len, align 8
  %conv54 = trunc i64 %78 to i32
  %79 = load i64, ptr %off, align 8
  %80 = load ptr, ptr %req.addr, align 8
  %call55 = call zeroext i16 @nvme_fdp_stats(ptr noundef %76, i32 noundef %77, i32 noundef %conv54, i64 noundef %79, ptr noundef %80)
  store i16 %call55, ptr %retval, align 2
  br label %return

sw.bb56:                                          ; preds = %if.end28
  %81 = load ptr, ptr %n.addr, align 8
  %82 = load i32, ptr %lspi, align 4
  %83 = load i64, ptr %len, align 8
  %conv57 = trunc i64 %83 to i32
  %84 = load i64, ptr %off, align 8
  %85 = load ptr, ptr %req.addr, align 8
  %call58 = call zeroext i16 @nvme_fdp_events(ptr noundef %81, i32 noundef %82, i32 noundef %conv57, i64 noundef %84, ptr noundef %85)
  store i16 %call58, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %if.end28
  %86 = load ptr, ptr %req.addr, align 8
  %call59 = call zeroext i16 @nvme_cid(ptr noundef %86)
  %87 = load i8, ptr %lid, align 1
  %conv60 = zext i8 %87 to i16
  call void @trace_pci_nvme_err_invalid_log_page(i16 noundef zeroext %call59, i16 noundef zeroext %conv60)
  store i16 16386, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.default, %sw.bb56, %sw.bb53, %sw.bb50, %sw.bb47, %sw.bb44, %sw.bb41, %sw.bb38, %sw.bb35, %sw.bb32, %sw.bb, %if.then27, %if.then
  %88 = load i16, ptr %retval, align 2
  ret i16 %88
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_del_cq(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %cq = alloca ptr, align 8
  %qid = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %qid1 = getelementptr inbounds %struct.NvmeDeleteQ, ptr %1, i32 0, i32 4
  %2 = load i16, ptr %qid1, align 1
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %2)
  store i16 %call, ptr %qid, align 2
  %3 = load i16, ptr %qid, align 2
  %tobool = icmp ne i16 %3, 0
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %4 = load ptr, ptr %n.addr, align 8
  %5 = load i16, ptr %qid, align 2
  %call2 = call i32 @nvme_check_cqid(ptr noundef %4, i16 noundef zeroext %5)
  %tobool3 = icmp ne i32 %call2, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %6 = phi i1 [ true, %entry ], [ %tobool3, %lor.rhs ]
  %lnot = xor i1 %6, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  %7 = load i16, ptr %qid, align 2
  call void @trace_pci_nvme_err_invalid_del_cq_cqid(i16 noundef zeroext %7)
  store i16 16640, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %lor.end
  %8 = load ptr, ptr %n.addr, align 8
  %cq6 = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 37
  %9 = load ptr, ptr %cq6, align 8
  %10 = load i16, ptr %qid, align 2
  %idxprom = zext i16 %10 to i64
  %arrayidx = getelementptr ptr, ptr %9, i64 %idxprom
  %11 = load ptr, ptr %arrayidx, align 8
  store ptr %11, ptr %cq, align 8
  %12 = load ptr, ptr %cq, align 8
  %sq_list = getelementptr inbounds %struct.NvmeCQueue, ptr %12, i32 0, i32 14
  %13 = load ptr, ptr %sq_list, align 8
  %cmp = icmp eq ptr %13, null
  %lnot8 = xor i1 %cmp, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %tobool15 = icmp ne i64 %conv14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end
  %14 = load i16, ptr %qid, align 2
  call void @trace_pci_nvme_err_invalid_del_cq_notempty(i16 noundef zeroext %14)
  store i16 268, ptr %retval, align 2
  br label %return

if.end17:                                         ; preds = %if.end
  %15 = load ptr, ptr %cq, align 8
  %irq_enabled = getelementptr inbounds %struct.NvmeCQueue, ptr %15, i32 0, i32 3
  %16 = load i16, ptr %irq_enabled, align 4
  %conv18 = zext i16 %16 to i32
  %tobool19 = icmp ne i32 %conv18, 0
  br i1 %tobool19, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %if.end17
  %17 = load ptr, ptr %cq, align 8
  %tail = getelementptr inbounds %struct.NvmeCQueue, ptr %17, i32 0, i32 5
  %18 = load i32, ptr %tail, align 4
  %19 = load ptr, ptr %cq, align 8
  %head = getelementptr inbounds %struct.NvmeCQueue, ptr %19, i32 0, i32 4
  %20 = load i32, ptr %head, align 8
  %cmp20 = icmp ne i32 %18, %20
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true
  %21 = load ptr, ptr %n.addr, align 8
  %cq_pending = getelementptr inbounds %struct.NvmeCtrl, ptr %21, i32 0, i32 14
  %22 = load i32, ptr %cq_pending, align 16
  %dec = add i32 %22, -1
  store i32 %dec, ptr %cq_pending, align 16
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %land.lhs.true, %if.end17
  %23 = load ptr, ptr %n.addr, align 8
  %24 = load ptr, ptr %cq, align 8
  call void @nvme_irq_deassert(ptr noundef %23, ptr noundef %24)
  %25 = load i16, ptr %qid, align 2
  call void @trace_pci_nvme_del_cq(i16 noundef zeroext %25)
  %26 = load ptr, ptr %cq, align 8
  %27 = load ptr, ptr %n.addr, align 8
  call void @nvme_free_cq(ptr noundef %26, ptr noundef %27)
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end23, %if.then16, %if.then
  %28 = load i16, ptr %retval, align 2
  ret i16 %28
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_create_cq(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %cq = alloca ptr, align 8
  %c = alloca ptr, align 8
  %cqid = alloca i16, align 2
  %vector = alloca i16, align 2
  %qsize = alloca i16, align 2
  %qflags = alloca i16, align 2
  %prp1 = alloca i64, align 8
  %cc = alloca i32, align 4
  %iocqes = alloca i8, align 1
  %iosqes = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cqid1 = getelementptr inbounds %struct.NvmeCreateCq, ptr %1, i32 0, i32 6
  %2 = load i16, ptr %cqid1, align 1
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %2)
  store i16 %call, ptr %cqid, align 2
  %3 = load ptr, ptr %c, align 8
  %irq_vector = getelementptr inbounds %struct.NvmeCreateCq, ptr %3, i32 0, i32 9
  %4 = load i16, ptr %irq_vector, align 1
  %call2 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %4)
  store i16 %call2, ptr %vector, align 2
  %5 = load ptr, ptr %c, align 8
  %qsize3 = getelementptr inbounds %struct.NvmeCreateCq, ptr %5, i32 0, i32 7
  %6 = load i16, ptr %qsize3, align 1
  %call4 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %6)
  store i16 %call4, ptr %qsize, align 2
  %7 = load ptr, ptr %c, align 8
  %cq_flags = getelementptr inbounds %struct.NvmeCreateCq, ptr %7, i32 0, i32 8
  %8 = load i16, ptr %cq_flags, align 1
  %call5 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %8)
  store i16 %call5, ptr %qflags, align 2
  %9 = load ptr, ptr %c, align 8
  %prp16 = getelementptr inbounds %struct.NvmeCreateCq, ptr %9, i32 0, i32 4
  %10 = load i64, ptr %prp16, align 1
  %call7 = call i64 @le64_to_cpu(i64 noundef %10)
  store i64 %call7, ptr %prp1, align 8
  %11 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %11, i32 0, i32 3
  %cc8 = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 4
  %call9 = call i64 @ldq_le_p(ptr noundef %cc8)
  %conv = trunc i64 %call9 to i32
  store i32 %conv, ptr %cc, align 4
  %12 = load i32, ptr %cc, align 4
  %shr = lshr i32 %12, 20
  %and = and i32 %shr, 15
  %conv10 = trunc i32 %and to i8
  store i8 %conv10, ptr %iocqes, align 1
  %13 = load i32, ptr %cc, align 4
  %shr11 = lshr i32 %13, 16
  %and12 = and i32 %shr11, 15
  %conv13 = trunc i32 %and12 to i8
  store i8 %conv13, ptr %iosqes, align 1
  %14 = load i64, ptr %prp1, align 8
  %15 = load i16, ptr %cqid, align 2
  %16 = load i16, ptr %vector, align 2
  %17 = load i16, ptr %qsize, align 2
  %18 = load i16, ptr %qflags, align 2
  %19 = load i16, ptr %qflags, align 2
  %conv14 = zext i16 %19 to i32
  %shr15 = ashr i32 %conv14, 1
  %and16 = and i32 %shr15, 1
  %cmp = icmp ne i32 %and16, 0
  %conv17 = zext i1 %cmp to i32
  call void @trace_pci_nvme_create_cq(i64 noundef %14, i16 noundef zeroext %15, i16 noundef zeroext %16, i16 noundef zeroext %17, i16 noundef zeroext %18, i32 noundef %conv17)
  %20 = load i8, ptr %iosqes, align 1
  %conv18 = zext i8 %20 to i32
  %cmp19 = icmp ne i32 %conv18, 6
  br i1 %cmp19, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %21 = load i8, ptr %iocqes, align 1
  %conv21 = zext i8 %21 to i32
  %cmp22 = icmp ne i32 %conv21, 4
  br i1 %cmp22, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %22 = load i8, ptr %iosqes, align 1
  %23 = load i8, ptr %iocqes, align 1
  call void @trace_pci_nvme_err_invalid_create_cq_entry_size(i8 noundef zeroext %22, i8 noundef zeroext %23)
  store i16 16642, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %24 = load i16, ptr %cqid, align 2
  %tobool = icmp ne i16 %24, 0
  br i1 %tobool, label %lor.lhs.false24, label %lor.end

lor.lhs.false24:                                  ; preds = %if.end
  %25 = load i16, ptr %cqid, align 2
  %conv25 = zext i16 %25 to i32
  %26 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs = getelementptr inbounds %struct.NvmeCtrl, ptr %26, i32 0, i32 21
  %27 = load i32, ptr %conf_ioqpairs, align 8
  %cmp26 = icmp ugt i32 %conv25, %27
  br i1 %cmp26, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false24
  %28 = load ptr, ptr %n.addr, align 8
  %cq28 = getelementptr inbounds %struct.NvmeCtrl, ptr %28, i32 0, i32 37
  %29 = load ptr, ptr %cq28, align 8
  %30 = load i16, ptr %cqid, align 2
  %idxprom = zext i16 %30 to i64
  %arrayidx = getelementptr ptr, ptr %29, i64 %idxprom
  %31 = load ptr, ptr %arrayidx, align 8
  %cmp29 = icmp ne ptr %31, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false24, %if.end
  %32 = phi i1 [ true, %lor.lhs.false24 ], [ true, %if.end ], [ %cmp29, %lor.rhs ]
  %lnot = xor i1 %32, true
  %lnot31 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot31 to i32
  %conv32 = sext i32 %lnot.ext to i64
  %tobool33 = icmp ne i64 %conv32, 0
  br i1 %tobool33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %lor.end
  %33 = load i16, ptr %cqid, align 2
  call void @trace_pci_nvme_err_invalid_create_cq_cqid(i16 noundef zeroext %33)
  store i16 16641, ptr %retval, align 2
  br label %return

if.end35:                                         ; preds = %lor.end
  %34 = load i16, ptr %qsize, align 2
  %tobool36 = icmp ne i16 %34, 0
  br i1 %tobool36, label %lor.rhs37, label %lor.end45

lor.rhs37:                                        ; preds = %if.end35
  %35 = load i16, ptr %qsize, align 2
  %conv38 = zext i16 %35 to i64
  %36 = load ptr, ptr %n.addr, align 8
  %bar39 = getelementptr inbounds %struct.NvmeCtrl, ptr %36, i32 0, i32 3
  %cap = getelementptr inbounds %struct.NvmeBar, ptr %bar39, i32 0, i32 0
  %call40 = call i64 @ldq_le_p(ptr noundef %cap)
  %shr41 = lshr i64 %call40, 0
  %and42 = and i64 %shr41, 65535
  %cmp43 = icmp ugt i64 %conv38, %and42
  br label %lor.end45

lor.end45:                                        ; preds = %lor.rhs37, %if.end35
  %37 = phi i1 [ true, %if.end35 ], [ %cmp43, %lor.rhs37 ]
  %lnot46 = xor i1 %37, true
  %lnot48 = xor i1 %lnot46, true
  %lnot.ext49 = zext i1 %lnot48 to i32
  %conv50 = sext i32 %lnot.ext49 to i64
  %tobool51 = icmp ne i64 %conv50, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %lor.end45
  %38 = load i16, ptr %qsize, align 2
  call void @trace_pci_nvme_err_invalid_create_cq_size(i16 noundef zeroext %38)
  store i16 16642, ptr %retval, align 2
  br label %return

if.end53:                                         ; preds = %lor.end45
  %39 = load i64, ptr %prp1, align 8
  %40 = load ptr, ptr %n.addr, align 8
  %page_size = getelementptr inbounds %struct.NvmeCtrl, ptr %40, i32 0, i32 8
  %41 = load i32, ptr %page_size, align 4
  %sub = sub i32 %41, 1
  %conv54 = zext i32 %sub to i64
  %and55 = and i64 %39, %conv54
  %tobool56 = icmp ne i64 %and55, 0
  %lnot57 = xor i1 %tobool56, true
  %lnot59 = xor i1 %lnot57, true
  %lnot.ext60 = zext i1 %lnot59 to i32
  %conv61 = sext i32 %lnot.ext60 to i64
  %tobool62 = icmp ne i64 %conv61, 0
  br i1 %tobool62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.end53
  %42 = load i64, ptr %prp1, align 8
  call void @trace_pci_nvme_err_invalid_create_cq_addr(i64 noundef %42)
  store i16 16403, ptr %retval, align 2
  br label %return

if.end64:                                         ; preds = %if.end53
  %43 = load ptr, ptr %n.addr, align 8
  %call65 = call ptr @PCI_DEVICE(ptr noundef %43)
  %call66 = call i32 @msix_enabled(ptr noundef %call65)
  %tobool67 = icmp ne i32 %call66, 0
  br i1 %tobool67, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end64
  %44 = load i16, ptr %vector, align 2
  %conv68 = zext i16 %44 to i32
  %tobool69 = icmp ne i32 %conv68, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end64
  %45 = phi i1 [ false, %if.end64 ], [ %tobool69, %land.rhs ]
  %lnot70 = xor i1 %45, true
  %lnot72 = xor i1 %lnot70, true
  %lnot.ext73 = zext i1 %lnot72 to i32
  %conv74 = sext i32 %lnot.ext73 to i64
  %tobool75 = icmp ne i64 %conv74, 0
  br i1 %tobool75, label %if.then76, label %if.end77

if.then76:                                        ; preds = %land.end
  %46 = load i16, ptr %vector, align 2
  call void @trace_pci_nvme_err_invalid_create_cq_vector(i16 noundef zeroext %46)
  store i16 16648, ptr %retval, align 2
  br label %return

if.end77:                                         ; preds = %land.end
  %47 = load i16, ptr %vector, align 2
  %conv78 = zext i16 %47 to i32
  %48 = load ptr, ptr %n.addr, align 8
  %conf_msix_qsize = getelementptr inbounds %struct.NvmeCtrl, ptr %48, i32 0, i32 20
  %49 = load i32, ptr %conf_msix_qsize, align 4
  %cmp79 = icmp uge i32 %conv78, %49
  %lnot81 = xor i1 %cmp79, true
  %lnot83 = xor i1 %lnot81, true
  %lnot.ext84 = zext i1 %lnot83 to i32
  %conv85 = sext i32 %lnot.ext84 to i64
  %tobool86 = icmp ne i64 %conv85, 0
  br i1 %tobool86, label %if.then87, label %if.end88

if.then87:                                        ; preds = %if.end77
  %50 = load i16, ptr %vector, align 2
  call void @trace_pci_nvme_err_invalid_create_cq_vector(i16 noundef zeroext %50)
  store i16 16648, ptr %retval, align 2
  br label %return

if.end88:                                         ; preds = %if.end77
  %51 = load i16, ptr %qflags, align 2
  %conv89 = zext i16 %51 to i32
  %and90 = and i32 %conv89, 1
  %tobool91 = icmp ne i32 %and90, 0
  %lnot92 = xor i1 %tobool91, true
  %lnot94 = xor i1 %lnot92, true
  %lnot96 = xor i1 %lnot94, true
  %lnot.ext97 = zext i1 %lnot96 to i32
  %conv98 = sext i32 %lnot.ext97 to i64
  %tobool99 = icmp ne i64 %conv98, 0
  br i1 %tobool99, label %if.then100, label %if.end104

if.then100:                                       ; preds = %if.end88
  %52 = load i16, ptr %qflags, align 2
  %conv101 = zext i16 %52 to i32
  %and102 = and i32 %conv101, 1
  %conv103 = trunc i32 %and102 to i16
  call void @trace_pci_nvme_err_invalid_create_cq_qflags(i16 noundef zeroext %conv103)
  store i16 16386, ptr %retval, align 2
  br label %return

if.end104:                                        ; preds = %if.end88
  %call105 = call noalias ptr @g_malloc0(i64 noundef 112) #14
  store ptr %call105, ptr %cq, align 8
  %53 = load ptr, ptr %cq, align 8
  %54 = load ptr, ptr %n.addr, align 8
  %55 = load i64, ptr %prp1, align 8
  %56 = load i16, ptr %cqid, align 2
  %57 = load i16, ptr %vector, align 2
  %58 = load i16, ptr %qsize, align 2
  %conv106 = zext i16 %58 to i32
  %add = add i32 %conv106, 1
  %conv107 = trunc i32 %add to i16
  %59 = load i16, ptr %qflags, align 2
  %conv108 = zext i16 %59 to i32
  %shr109 = ashr i32 %conv108, 1
  %and110 = and i32 %shr109, 1
  %conv111 = trunc i32 %and110 to i16
  call void @nvme_init_cq(ptr noundef %53, ptr noundef %54, i64 noundef %55, i16 noundef zeroext %56, i16 noundef zeroext %57, i16 noundef zeroext %conv107, i16 noundef zeroext %conv111)
  %60 = load ptr, ptr %n.addr, align 8
  %qs_created = getelementptr inbounds %struct.NvmeCtrl, ptr %60, i32 0, i32 7
  store i8 1, ptr %qs_created, align 2
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end104, %if.then100, %if.then87, %if.then76, %if.then63, %if.then52, %if.then34, %if.then
  %61 = load i16, ptr %retval, align 2
  ret i16 %61
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_identify(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_cid(ptr noundef %1)
  %2 = load ptr, ptr %c, align 8
  %cns = getelementptr inbounds %struct.NvmeIdentify, ptr %2, i32 0, i32 7
  %3 = load i8, ptr %cns, align 1
  %4 = load ptr, ptr %c, align 8
  %ctrlid = getelementptr inbounds %struct.NvmeIdentify, ptr %4, i32 0, i32 9
  %5 = load i16, ptr %ctrlid, align 1
  %call1 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %5)
  %6 = load ptr, ptr %c, align 8
  %csi = getelementptr inbounds %struct.NvmeIdentify, ptr %6, i32 0, i32 12
  %7 = load i8, ptr %csi, align 1
  call void @trace_pci_nvme_identify(i16 noundef zeroext %call, i8 noundef zeroext %3, i16 noundef zeroext %call1, i8 noundef zeroext %7)
  %8 = load ptr, ptr %c, align 8
  %cns2 = getelementptr inbounds %struct.NvmeIdentify, ptr %8, i32 0, i32 7
  %9 = load i8, ptr %cns2, align 1
  %conv = zext i8 %9 to i32
  switch i32 %conv, label %sw.default [
    i32 0, label %sw.bb
    i32 17, label %sw.bb4
    i32 18, label %sw.bb6
    i32 19, label %sw.bb8
    i32 20, label %sw.bb10
    i32 21, label %sw.bb12
    i32 5, label %sw.bb14
    i32 27, label %sw.bb16
    i32 1, label %sw.bb18
    i32 6, label %sw.bb20
    i32 2, label %sw.bb22
    i32 16, label %sw.bb24
    i32 7, label %sw.bb26
    i32 26, label %sw.bb28
    i32 3, label %sw.bb30
    i32 28, label %sw.bb32
  ]

sw.bb:                                            ; preds = %entry
  %10 = load ptr, ptr %n.addr, align 8
  %11 = load ptr, ptr %req.addr, align 8
  %call3 = call zeroext i16 @nvme_identify_ns(ptr noundef %10, ptr noundef %11, i1 noundef zeroext true)
  store i16 %call3, ptr %retval, align 2
  br label %return

sw.bb4:                                           ; preds = %entry
  %12 = load ptr, ptr %n.addr, align 8
  %13 = load ptr, ptr %req.addr, align 8
  %call5 = call zeroext i16 @nvme_identify_ns(ptr noundef %12, ptr noundef %13, i1 noundef zeroext false)
  store i16 %call5, ptr %retval, align 2
  br label %return

sw.bb6:                                           ; preds = %entry
  %14 = load ptr, ptr %n.addr, align 8
  %15 = load ptr, ptr %req.addr, align 8
  %call7 = call zeroext i16 @nvme_identify_ctrl_list(ptr noundef %14, ptr noundef %15, i1 noundef zeroext true)
  store i16 %call7, ptr %retval, align 2
  br label %return

sw.bb8:                                           ; preds = %entry
  %16 = load ptr, ptr %n.addr, align 8
  %17 = load ptr, ptr %req.addr, align 8
  %call9 = call zeroext i16 @nvme_identify_ctrl_list(ptr noundef %16, ptr noundef %17, i1 noundef zeroext false)
  store i16 %call9, ptr %retval, align 2
  br label %return

sw.bb10:                                          ; preds = %entry
  %18 = load ptr, ptr %n.addr, align 8
  %19 = load ptr, ptr %req.addr, align 8
  %call11 = call zeroext i16 @nvme_identify_pri_ctrl_cap(ptr noundef %18, ptr noundef %19)
  store i16 %call11, ptr %retval, align 2
  br label %return

sw.bb12:                                          ; preds = %entry
  %20 = load ptr, ptr %n.addr, align 8
  %21 = load ptr, ptr %req.addr, align 8
  %call13 = call zeroext i16 @nvme_identify_sec_ctrl_list(ptr noundef %20, ptr noundef %21)
  store i16 %call13, ptr %retval, align 2
  br label %return

sw.bb14:                                          ; preds = %entry
  %22 = load ptr, ptr %n.addr, align 8
  %23 = load ptr, ptr %req.addr, align 8
  %call15 = call zeroext i16 @nvme_identify_ns_csi(ptr noundef %22, ptr noundef %23, i1 noundef zeroext true)
  store i16 %call15, ptr %retval, align 2
  br label %return

sw.bb16:                                          ; preds = %entry
  %24 = load ptr, ptr %n.addr, align 8
  %25 = load ptr, ptr %req.addr, align 8
  %call17 = call zeroext i16 @nvme_identify_ns_csi(ptr noundef %24, ptr noundef %25, i1 noundef zeroext false)
  store i16 %call17, ptr %retval, align 2
  br label %return

sw.bb18:                                          ; preds = %entry
  %26 = load ptr, ptr %n.addr, align 8
  %27 = load ptr, ptr %req.addr, align 8
  %call19 = call zeroext i16 @nvme_identify_ctrl(ptr noundef %26, ptr noundef %27)
  store i16 %call19, ptr %retval, align 2
  br label %return

sw.bb20:                                          ; preds = %entry
  %28 = load ptr, ptr %n.addr, align 8
  %29 = load ptr, ptr %req.addr, align 8
  %call21 = call zeroext i16 @nvme_identify_ctrl_csi(ptr noundef %28, ptr noundef %29)
  store i16 %call21, ptr %retval, align 2
  br label %return

sw.bb22:                                          ; preds = %entry
  %30 = load ptr, ptr %n.addr, align 8
  %31 = load ptr, ptr %req.addr, align 8
  %call23 = call zeroext i16 @nvme_identify_nslist(ptr noundef %30, ptr noundef %31, i1 noundef zeroext true)
  store i16 %call23, ptr %retval, align 2
  br label %return

sw.bb24:                                          ; preds = %entry
  %32 = load ptr, ptr %n.addr, align 8
  %33 = load ptr, ptr %req.addr, align 8
  %call25 = call zeroext i16 @nvme_identify_nslist(ptr noundef %32, ptr noundef %33, i1 noundef zeroext false)
  store i16 %call25, ptr %retval, align 2
  br label %return

sw.bb26:                                          ; preds = %entry
  %34 = load ptr, ptr %n.addr, align 8
  %35 = load ptr, ptr %req.addr, align 8
  %call27 = call zeroext i16 @nvme_identify_nslist_csi(ptr noundef %34, ptr noundef %35, i1 noundef zeroext true)
  store i16 %call27, ptr %retval, align 2
  br label %return

sw.bb28:                                          ; preds = %entry
  %36 = load ptr, ptr %n.addr, align 8
  %37 = load ptr, ptr %req.addr, align 8
  %call29 = call zeroext i16 @nvme_identify_nslist_csi(ptr noundef %36, ptr noundef %37, i1 noundef zeroext false)
  store i16 %call29, ptr %retval, align 2
  br label %return

sw.bb30:                                          ; preds = %entry
  %38 = load ptr, ptr %n.addr, align 8
  %39 = load ptr, ptr %req.addr, align 8
  %call31 = call zeroext i16 @nvme_identify_ns_descr_list(ptr noundef %38, ptr noundef %39)
  store i16 %call31, ptr %retval, align 2
  br label %return

sw.bb32:                                          ; preds = %entry
  %40 = load ptr, ptr %n.addr, align 8
  %41 = load ptr, ptr %req.addr, align 8
  %call33 = call zeroext i16 @nvme_identify_cmd_set(ptr noundef %40, ptr noundef %41)
  store i16 %call33, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %entry
  %42 = load ptr, ptr %c, align 8
  %cns34 = getelementptr inbounds %struct.NvmeIdentify, ptr %42, i32 0, i32 7
  %43 = load i8, ptr %cns34, align 1
  %conv35 = zext i8 %43 to i32
  %call36 = call i32 @le32_to_cpu(i32 noundef %conv35)
  %conv37 = trunc i32 %call36 to i16
  call void @trace_pci_nvme_err_invalid_identify_cns(i16 noundef zeroext %conv37)
  store i16 16386, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.default, %sw.bb32, %sw.bb30, %sw.bb28, %sw.bb26, %sw.bb24, %sw.bb22, %sw.bb20, %sw.bb18, %sw.bb16, %sw.bb14, %sw.bb12, %sw.bb10, %sw.bb8, %sw.bb6, %sw.bb4, %sw.bb
  %44 = load i16, ptr %retval, align 2
  ret i16 %44
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_abort(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %sqid = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  %cdw10 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 7
  %1 = load i32, ptr %cdw10, align 8
  %call = call i32 @le32_to_cpu(i32 noundef %1)
  %and = and i32 %call, 65535
  %conv = trunc i32 %and to i16
  store i16 %conv, ptr %sqid, align 2
  %2 = load ptr, ptr %req.addr, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 5
  %result = getelementptr inbounds %struct.NvmeCqe, ptr %cqe, i32 0, i32 0
  store i32 1, ptr %result, align 8
  %3 = load ptr, ptr %n.addr, align 8
  %4 = load i16, ptr %sqid, align 2
  %call1 = call i32 @nvme_check_sqid(ptr noundef %3, i16 noundef zeroext %4)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i16, ptr %retval, align 2
  ret i16 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_set_feature(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %dw10 = alloca i32, align 4
  %dw11 = alloca i32, align 4
  %nsid = alloca i32, align 4
  %fid = alloca i8, align 1
  %save = alloca i8, align 1
  %status = alloca i16, align 2
  %i = alloca i32, align 4
  %_a47 = alloca i32, align 4
  %_b48 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  store ptr null, ptr %ns, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd1, ptr %cmd, align 8
  %1 = load ptr, ptr %cmd, align 8
  %cdw10 = getelementptr inbounds %struct.NvmeCmd, ptr %1, i32 0, i32 7
  %2 = load i32, ptr %cdw10, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %dw10, align 4
  %3 = load ptr, ptr %cmd, align 8
  %cdw11 = getelementptr inbounds %struct.NvmeCmd, ptr %3, i32 0, i32 8
  %4 = load i32, ptr %cdw11, align 1
  %call2 = call i32 @le32_to_cpu(i32 noundef %4)
  store i32 %call2, ptr %dw11, align 4
  %5 = load ptr, ptr %cmd, align 8
  %nsid3 = getelementptr inbounds %struct.NvmeCmd, ptr %5, i32 0, i32 3
  %6 = load i32, ptr %nsid3, align 1
  %call4 = call i32 @le32_to_cpu(i32 noundef %6)
  store i32 %call4, ptr %nsid, align 4
  %7 = load i32, ptr %dw10, align 4
  %and = and i32 %7, 255
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %fid, align 1
  %8 = load i32, ptr %dw10, align 4
  %shr = lshr i32 %8, 31
  %and5 = and i32 %shr, 1
  %conv6 = trunc i32 %and5 to i8
  store i8 %conv6, ptr %save, align 1
  %9 = load ptr, ptr %req.addr, align 8
  %call7 = call zeroext i16 @nvme_cid(ptr noundef %9)
  %10 = load i32, ptr %nsid, align 4
  %11 = load i8, ptr %fid, align 1
  %12 = load i8, ptr %save, align 1
  %13 = load i32, ptr %dw11, align 4
  call void @trace_pci_nvme_setfeat(i16 noundef zeroext %call7, i32 noundef %10, i8 noundef zeroext %11, i8 noundef zeroext %12, i32 noundef %13)
  %14 = load i8, ptr %save, align 1
  %conv8 = zext i8 %14 to i32
  %tobool = icmp ne i32 %conv8, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %15 = load i8, ptr %fid, align 1
  %idxprom = zext i8 %15 to i64
  %arrayidx = getelementptr [256 x i32], ptr @nvme_feature_cap, i64 0, i64 %idxprom
  %16 = load i32, ptr %arrayidx, align 4
  %and9 = and i32 %16, 1
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i16 16653, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %17 = load i8, ptr %fid, align 1
  %idxprom11 = zext i8 %17 to i64
  %arrayidx12 = getelementptr [256 x i8], ptr @nvme_feature_support, i64 0, i64 %idxprom11
  %18 = load i8, ptr %arrayidx12, align 1
  %tobool13 = trunc i8 %18 to i1
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  store i16 16386, ptr %retval, align 2
  br label %return

if.end15:                                         ; preds = %if.end
  %19 = load i8, ptr %fid, align 1
  %idxprom16 = zext i8 %19 to i64
  %arrayidx17 = getelementptr [256 x i32], ptr @nvme_feature_cap, i64 0, i64 %idxprom16
  %20 = load i32, ptr %arrayidx17, align 4
  %and18 = and i32 %20, 2
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.end15
  %21 = load i32, ptr %nsid, align 4
  %cmp = icmp ne i32 %21, -1
  br i1 %cmp, label %if.then22, label %if.end34

if.then22:                                        ; preds = %if.then20
  %22 = load ptr, ptr %n.addr, align 8
  %23 = load i32, ptr %nsid, align 4
  %call23 = call zeroext i1 @nvme_nsid_valid(ptr noundef %22, i32 noundef %23)
  br i1 %call23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %if.then22
  store i16 16395, ptr %retval, align 2
  br label %return

if.end25:                                         ; preds = %if.then22
  %24 = load ptr, ptr %n.addr, align 8
  %25 = load i32, ptr %nsid, align 4
  %call26 = call ptr @nvme_ns(ptr noundef %24, i32 noundef %25)
  store ptr %call26, ptr %ns, align 8
  %26 = load ptr, ptr %ns, align 8
  %tobool27 = icmp ne ptr %26, null
  %lnot = xor i1 %tobool27, true
  %lnot28 = xor i1 %lnot, true
  %lnot29 = xor i1 %lnot28, true
  %lnot.ext = zext i1 %lnot29 to i32
  %conv30 = sext i32 %lnot.ext to i64
  %tobool31 = icmp ne i64 %conv30, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end25
  store i16 16386, ptr %retval, align 2
  br label %return

if.end33:                                         ; preds = %if.end25
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.then20
  br label %if.end44

if.else:                                          ; preds = %if.end15
  %27 = load i32, ptr %nsid, align 4
  %tobool35 = icmp ne i32 %27, 0
  br i1 %tobool35, label %land.lhs.true36, label %if.end43

land.lhs.true36:                                  ; preds = %if.else
  %28 = load i32, ptr %nsid, align 4
  %cmp37 = icmp ne i32 %28, -1
  br i1 %cmp37, label %if.then39, label %if.end43

if.then39:                                        ; preds = %land.lhs.true36
  %29 = load ptr, ptr %n.addr, align 8
  %30 = load i32, ptr %nsid, align 4
  %call40 = call zeroext i1 @nvme_nsid_valid(ptr noundef %29, i32 noundef %30)
  br i1 %call40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.then39
  store i16 16395, ptr %retval, align 2
  br label %return

if.end42:                                         ; preds = %if.then39
  store i16 16655, ptr %retval, align 2
  br label %return

if.end43:                                         ; preds = %land.lhs.true36, %if.else
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.end34
  %31 = load i8, ptr %fid, align 1
  %idxprom45 = zext i8 %31 to i64
  %arrayidx46 = getelementptr [256 x i32], ptr @nvme_feature_cap, i64 0, i64 %idxprom45
  %32 = load i32, ptr %arrayidx46, align 4
  %and47 = and i32 %32, 4
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.end50, label %if.then49

if.then49:                                        ; preds = %if.end44
  store i16 16654, ptr %retval, align 2
  br label %return

if.end50:                                         ; preds = %if.end44
  %33 = load i8, ptr %fid, align 1
  %conv51 = zext i8 %33 to i32
  switch i32 %conv51, label %sw.default210 [
    i32 4, label %sw.bb
    i32 5, label %sw.bb82
    i32 6, label %sw.bb114
    i32 7, label %sw.bb140
    i32 11, label %sw.bb163
    i32 14, label %sw.bb165
    i32 22, label %sw.bb167
    i32 25, label %sw.bb201
    i32 29, label %sw.bb207
    i32 30, label %sw.bb208
  ]

sw.bb:                                            ; preds = %if.end50
  %34 = load i32, ptr %dw11, align 4
  %shr52 = lshr i32 %34, 16
  %and53 = and i32 %shr52, 15
  %cmp54 = icmp ne i32 %and53, 0
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %sw.bb
  br label %sw.epilog211

if.end57:                                         ; preds = %sw.bb
  %35 = load i32, ptr %dw11, align 4
  %shr58 = lshr i32 %35, 20
  %and59 = and i32 %shr58, 3
  switch i32 %and59, label %sw.default [
    i32 0, label %sw.bb60
    i32 1, label %sw.bb63
  ]

sw.bb60:                                          ; preds = %if.end57
  %36 = load i32, ptr %dw11, align 4
  %and61 = and i32 %36, 65535
  %conv62 = trunc i32 %and61 to i16
  %37 = load ptr, ptr %n.addr, align 8
  %features = getelementptr inbounds %struct.NvmeCtrl, ptr %37, i32 0, i32 41
  %38 = getelementptr inbounds %struct.anon.28, ptr %features, i32 0, i32 0
  %temp_thresh_hi = getelementptr inbounds %struct.anon.29, ptr %38, i32 0, i32 0
  store i16 %conv62, ptr %temp_thresh_hi, align 16
  br label %sw.epilog

sw.bb63:                                          ; preds = %if.end57
  %39 = load i32, ptr %dw11, align 4
  %and64 = and i32 %39, 65535
  %conv65 = trunc i32 %and64 to i16
  %40 = load ptr, ptr %n.addr, align 8
  %features66 = getelementptr inbounds %struct.NvmeCtrl, ptr %40, i32 0, i32 41
  %41 = getelementptr inbounds %struct.anon.28, ptr %features66, i32 0, i32 0
  %temp_thresh_low = getelementptr inbounds %struct.anon.29, ptr %41, i32 0, i32 1
  store i16 %conv65, ptr %temp_thresh_low, align 2
  br label %sw.epilog

sw.default:                                       ; preds = %if.end57
  store i16 16386, ptr %retval, align 2
  br label %return

sw.epilog:                                        ; preds = %sw.bb63, %sw.bb60
  %42 = load ptr, ptr %n.addr, align 8
  %temperature = getelementptr inbounds %struct.NvmeCtrl, ptr %42, i32 0, i32 18
  %43 = load i16, ptr %temperature, align 16
  %conv67 = zext i16 %43 to i32
  %44 = load ptr, ptr %n.addr, align 8
  %features68 = getelementptr inbounds %struct.NvmeCtrl, ptr %44, i32 0, i32 41
  %45 = getelementptr inbounds %struct.anon.28, ptr %features68, i32 0, i32 0
  %temp_thresh_hi69 = getelementptr inbounds %struct.anon.29, ptr %45, i32 0, i32 0
  %46 = load i16, ptr %temp_thresh_hi69, align 16
  %conv70 = zext i16 %46 to i32
  %cmp71 = icmp sge i32 %conv67, %conv70
  br i1 %cmp71, label %if.then80, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %47 = load ptr, ptr %n.addr, align 8
  %temperature73 = getelementptr inbounds %struct.NvmeCtrl, ptr %47, i32 0, i32 18
  %48 = load i16, ptr %temperature73, align 16
  %conv74 = zext i16 %48 to i32
  %49 = load ptr, ptr %n.addr, align 8
  %features75 = getelementptr inbounds %struct.NvmeCtrl, ptr %49, i32 0, i32 41
  %50 = getelementptr inbounds %struct.anon.28, ptr %features75, i32 0, i32 0
  %temp_thresh_low76 = getelementptr inbounds %struct.anon.29, ptr %50, i32 0, i32 1
  %51 = load i16, ptr %temp_thresh_low76, align 2
  %conv77 = zext i16 %51 to i32
  %cmp78 = icmp sle i32 %conv74, %conv77
  br i1 %cmp78, label %if.then80, label %if.end81

if.then80:                                        ; preds = %lor.lhs.false, %sw.epilog
  %52 = load ptr, ptr %n.addr, align 8
  call void @nvme_smart_event(ptr noundef %52, i8 noundef zeroext 2)
  br label %if.end81

if.end81:                                         ; preds = %if.then80, %lor.lhs.false
  br label %sw.epilog211

sw.bb82:                                          ; preds = %if.end50
  %53 = load i32, ptr %nsid, align 4
  %cmp83 = icmp eq i32 %53, -1
  br i1 %cmp83, label %if.then85, label %if.end99

if.then85:                                        ; preds = %sw.bb82
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then85
  %54 = load i32, ptr %i, align 4
  %cmp86 = icmp sle i32 %54, 256
  br i1 %cmp86, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %55 = load ptr, ptr %n.addr, align 8
  %56 = load i32, ptr %i, align 4
  %call88 = call ptr @nvme_ns(ptr noundef %55, i32 noundef %56)
  store ptr %call88, ptr %ns, align 8
  %57 = load ptr, ptr %ns, align 8
  %tobool89 = icmp ne ptr %57, null
  br i1 %tobool89, label %if.end91, label %if.then90

if.then90:                                        ; preds = %for.body
  br label %for.inc

if.end91:                                         ; preds = %for.body
  %58 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %58, i32 0, i32 5
  %nsfeat = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 3
  %59 = load i8, ptr %nsfeat, align 8
  %conv92 = zext i8 %59 to i32
  %shr93 = ashr i32 %conv92, 2
  %and94 = and i32 %shr93, 1
  %tobool95 = icmp ne i32 %and94, 0
  br i1 %tobool95, label %if.then96, label %if.end98

if.then96:                                        ; preds = %if.end91
  %60 = load i32, ptr %dw11, align 4
  %61 = load ptr, ptr %ns, align 8
  %features97 = getelementptr inbounds %struct.NvmeNamespace, ptr %61, i32 0, i32 33
  %err_rec = getelementptr inbounds %struct.anon.13, ptr %features97, i32 0, i32 0
  store i32 %60, ptr %err_rec, align 8
  br label %if.end98

if.end98:                                         ; preds = %if.then96, %if.end91
  br label %for.inc

for.inc:                                          ; preds = %if.end98, %if.then90
  %62 = load i32, ptr %i, align 4
  %inc = add i32 %62, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !46

for.end:                                          ; preds = %for.cond
  br label %sw.epilog211

if.end99:                                         ; preds = %sw.bb82
  %63 = load ptr, ptr %ns, align 8
  %tobool100 = icmp ne ptr %63, null
  br i1 %tobool100, label %if.then101, label %if.else102

if.then101:                                       ; preds = %if.end99
  br label %if.end103

if.else102:                                       ; preds = %if.end99
  call void @__assert_fail(ptr noundef @.str.387, ptr noundef @.str.1, i32 noundef 6219, ptr noundef @__PRETTY_FUNCTION__.nvme_set_feature) #12
  unreachable

if.end103:                                        ; preds = %if.then101
  %64 = load ptr, ptr %ns, align 8
  %id_ns104 = getelementptr inbounds %struct.NvmeNamespace, ptr %64, i32 0, i32 5
  %nsfeat105 = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns104, i32 0, i32 3
  %65 = load i8, ptr %nsfeat105, align 8
  %conv106 = zext i8 %65 to i32
  %shr107 = ashr i32 %conv106, 2
  %and108 = and i32 %shr107, 1
  %tobool109 = icmp ne i32 %and108, 0
  br i1 %tobool109, label %if.then110, label %if.end113

if.then110:                                       ; preds = %if.end103
  %66 = load i32, ptr %dw11, align 4
  %67 = load ptr, ptr %ns, align 8
  %features111 = getelementptr inbounds %struct.NvmeNamespace, ptr %67, i32 0, i32 33
  %err_rec112 = getelementptr inbounds %struct.anon.13, ptr %features111, i32 0, i32 0
  store i32 %66, ptr %err_rec112, align 8
  br label %if.end113

if.end113:                                        ; preds = %if.then110, %if.end103
  br label %sw.epilog211

sw.bb114:                                         ; preds = %if.end50
  store i32 1, ptr %i, align 4
  br label %for.cond115

for.cond115:                                      ; preds = %for.inc137, %sw.bb114
  %68 = load i32, ptr %i, align 4
  %cmp116 = icmp sle i32 %68, 256
  br i1 %cmp116, label %for.body118, label %for.end139

for.body118:                                      ; preds = %for.cond115
  %69 = load ptr, ptr %n.addr, align 8
  %70 = load i32, ptr %i, align 4
  %call119 = call ptr @nvme_ns(ptr noundef %69, i32 noundef %70)
  store ptr %call119, ptr %ns, align 8
  %71 = load ptr, ptr %ns, align 8
  %tobool120 = icmp ne ptr %71, null
  br i1 %tobool120, label %if.end122, label %if.then121

if.then121:                                       ; preds = %for.body118
  br label %for.inc137

if.end122:                                        ; preds = %for.body118
  %72 = load i32, ptr %dw11, align 4
  %and123 = and i32 %72, 1
  %tobool124 = icmp ne i32 %and123, 0
  br i1 %tobool124, label %if.end132, label %land.lhs.true125

land.lhs.true125:                                 ; preds = %if.end122
  %73 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %73, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %74 = load ptr, ptr %blk, align 8
  %call126 = call zeroext i1 @blk_enable_write_cache(ptr noundef %74)
  br i1 %call126, label %if.then128, label %if.end132

if.then128:                                       ; preds = %land.lhs.true125
  %75 = load ptr, ptr %ns, align 8
  %blkconf129 = getelementptr inbounds %struct.NvmeNamespace, ptr %75, i32 0, i32 1
  %blk130 = getelementptr inbounds %struct.BlockConf, ptr %blkconf129, i32 0, i32 0
  %76 = load ptr, ptr %blk130, align 8
  %call131 = call i32 @blk_flush(ptr noundef %76)
  br label %if.end132

if.end132:                                        ; preds = %if.then128, %land.lhs.true125, %if.end122
  %77 = load ptr, ptr %ns, align 8
  %blkconf133 = getelementptr inbounds %struct.NvmeNamespace, ptr %77, i32 0, i32 1
  %blk134 = getelementptr inbounds %struct.BlockConf, ptr %blkconf133, i32 0, i32 0
  %78 = load ptr, ptr %blk134, align 8
  %79 = load i32, ptr %dw11, align 4
  %and135 = and i32 %79, 1
  %tobool136 = icmp ne i32 %and135, 0
  call void @blk_set_enable_write_cache(ptr noundef %78, i1 noundef zeroext %tobool136)
  br label %for.inc137

for.inc137:                                       ; preds = %if.end132, %if.then121
  %80 = load i32, ptr %i, align 4
  %inc138 = add i32 %80, 1
  store i32 %inc138, ptr %i, align 4
  br label %for.cond115, !llvm.loop !47

for.end139:                                       ; preds = %for.cond115
  br label %sw.epilog211

sw.bb140:                                         ; preds = %if.end50
  %81 = load ptr, ptr %n.addr, align 8
  %qs_created = getelementptr inbounds %struct.NvmeCtrl, ptr %81, i32 0, i32 7
  %82 = load i8, ptr %qs_created, align 2
  %tobool141 = trunc i8 %82 to i1
  br i1 %tobool141, label %if.then142, label %if.end143

if.then142:                                       ; preds = %sw.bb140
  store i16 16396, ptr %retval, align 2
  br label %return

if.end143:                                        ; preds = %sw.bb140
  %83 = load i32, ptr %dw11, align 4
  %and144 = and i32 %83, 65535
  %cmp145 = icmp eq i32 %and144, 65535
  br i1 %cmp145, label %if.then152, label %lor.lhs.false147

lor.lhs.false147:                                 ; preds = %if.end143
  %84 = load i32, ptr %dw11, align 4
  %shr148 = lshr i32 %84, 16
  %and149 = and i32 %shr148, 65535
  %cmp150 = icmp eq i32 %and149, 65535
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %lor.lhs.false147, %if.end143
  store i16 16386, ptr %retval, align 2
  br label %return

if.end153:                                        ; preds = %lor.lhs.false147
  %85 = load i32, ptr %dw11, align 4
  %and154 = and i32 %85, 65535
  %add = add i32 %and154, 1
  %86 = load i32, ptr %dw11, align 4
  %shr155 = lshr i32 %86, 16
  %and156 = and i32 %shr155, 65535
  %add157 = add i32 %and156, 1
  %87 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs = getelementptr inbounds %struct.NvmeCtrl, ptr %87, i32 0, i32 21
  %88 = load i32, ptr %conf_ioqpairs, align 8
  %89 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs158 = getelementptr inbounds %struct.NvmeCtrl, ptr %89, i32 0, i32 21
  %90 = load i32, ptr %conf_ioqpairs158, align 8
  call void @trace_pci_nvme_setfeat_numq(i32 noundef %add, i32 noundef %add157, i32 noundef %88, i32 noundef %90)
  %91 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs159 = getelementptr inbounds %struct.NvmeCtrl, ptr %91, i32 0, i32 21
  %92 = load i32, ptr %conf_ioqpairs159, align 8
  %sub = sub i32 %92, 1
  %93 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs160 = getelementptr inbounds %struct.NvmeCtrl, ptr %93, i32 0, i32 21
  %94 = load i32, ptr %conf_ioqpairs160, align 8
  %sub161 = sub i32 %94, 1
  %shl = shl i32 %sub161, 16
  %or = or i32 %sub, %shl
  %call162 = call i32 @cpu_to_le32(i32 noundef %or)
  %95 = load ptr, ptr %req.addr, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %95, i32 0, i32 5
  %result = getelementptr inbounds %struct.NvmeCqe, ptr %cqe, i32 0, i32 0
  store i32 %call162, ptr %result, align 8
  br label %sw.epilog211

sw.bb163:                                         ; preds = %if.end50
  %96 = load i32, ptr %dw11, align 4
  %97 = load ptr, ptr %n.addr, align 8
  %features164 = getelementptr inbounds %struct.NvmeCtrl, ptr %97, i32 0, i32 41
  %async_config = getelementptr inbounds %struct.anon.28, ptr %features164, i32 0, i32 1
  store i32 %96, ptr %async_config, align 4
  br label %sw.epilog211

sw.bb165:                                         ; preds = %if.end50
  %98 = load ptr, ptr %n.addr, align 8
  %99 = load ptr, ptr %req.addr, align 8
  %call166 = call zeroext i16 @nvme_set_feature_timestamp(ptr noundef %98, ptr noundef %99)
  store i16 %call166, ptr %retval, align 2
  br label %return

sw.bb167:                                         ; preds = %if.end50
  %100 = load ptr, ptr %n.addr, align 8
  %101 = load ptr, ptr %n.addr, align 8
  %features168 = getelementptr inbounds %struct.NvmeCtrl, ptr %101, i32 0, i32 41
  %hbs = getelementptr inbounds %struct.anon.28, ptr %features168, i32 0, i32 2
  %102 = load ptr, ptr %req.addr, align 8
  %call169 = call zeroext i16 @nvme_h2c(ptr noundef %100, ptr noundef %hbs, i32 noundef 512, ptr noundef %102)
  store i16 %call169, ptr %status, align 2
  %103 = load i16, ptr %status, align 2
  %tobool170 = icmp ne i16 %103, 0
  br i1 %tobool170, label %if.then171, label %if.end172

if.then171:                                       ; preds = %sw.bb167
  %104 = load i16, ptr %status, align 2
  store i16 %104, ptr %retval, align 2
  br label %return

if.end172:                                        ; preds = %sw.bb167
  store i32 1, ptr %i, align 4
  br label %for.cond173

for.cond173:                                      ; preds = %for.inc198, %if.end172
  %105 = load i32, ptr %i, align 4
  %cmp174 = icmp sle i32 %105, 256
  br i1 %cmp174, label %for.body176, label %for.end200

for.body176:                                      ; preds = %for.cond173
  %106 = load ptr, ptr %n.addr, align 8
  %107 = load i32, ptr %i, align 4
  %call177 = call ptr @nvme_ns(ptr noundef %106, i32 noundef %107)
  store ptr %call177, ptr %ns, align 8
  %108 = load ptr, ptr %ns, align 8
  %tobool178 = icmp ne ptr %108, null
  br i1 %tobool178, label %if.end180, label %if.then179

if.then179:                                       ; preds = %for.body176
  br label %for.inc198

if.end180:                                        ; preds = %for.body176
  %109 = load ptr, ptr %ns, align 8
  %nlbaf = getelementptr inbounds %struct.NvmeNamespace, ptr %109, i32 0, i32 8
  %110 = load i32, ptr %nlbaf, align 4
  %sub181 = sub i32 %110, 1
  %conv182 = trunc i32 %sub181 to i8
  %111 = load ptr, ptr %ns, align 8
  %id_ns183 = getelementptr inbounds %struct.NvmeNamespace, ptr %111, i32 0, i32 5
  %nlbaf184 = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns183, i32 0, i32 4
  store i8 %conv182, ptr %nlbaf184, align 1
  %112 = load ptr, ptr %n.addr, align 8
  %features185 = getelementptr inbounds %struct.NvmeCtrl, ptr %112, i32 0, i32 41
  %hbs186 = getelementptr inbounds %struct.anon.28, ptr %features185, i32 0, i32 2
  %lbafee = getelementptr inbounds %struct.NvmeHostBehaviorSupport, ptr %hbs186, i32 0, i32 2
  %113 = load i8, ptr %lbafee, align 2
  %tobool187 = icmp ne i8 %113, 0
  br i1 %tobool187, label %if.end197, label %if.then188

if.then188:                                       ; preds = %if.end180
  %114 = load ptr, ptr %ns, align 8
  %id_ns189 = getelementptr inbounds %struct.NvmeNamespace, ptr %114, i32 0, i32 5
  %nlbaf190 = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns189, i32 0, i32 4
  %115 = load i8, ptr %nlbaf190, align 1
  %conv191 = zext i8 %115 to i32
  store i32 %conv191, ptr %_a47, align 4
  store i32 15, ptr %_b48, align 4
  %116 = load i32, ptr %_a47, align 4
  %117 = load i32, ptr %_b48, align 4
  %cmp192 = icmp slt i32 %116, %117
  br i1 %cmp192, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then188
  %118 = load i32, ptr %_a47, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then188
  %119 = load i32, ptr %_b48, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %118, %cond.true ], [ %119, %cond.false ]
  store i32 %cond, ptr %tmp, align 4
  %120 = load i32, ptr %tmp, align 4
  %conv194 = trunc i32 %120 to i8
  %121 = load ptr, ptr %ns, align 8
  %id_ns195 = getelementptr inbounds %struct.NvmeNamespace, ptr %121, i32 0, i32 5
  %nlbaf196 = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns195, i32 0, i32 4
  store i8 %conv194, ptr %nlbaf196, align 1
  br label %if.end197

if.end197:                                        ; preds = %cond.end, %if.end180
  br label %for.inc198

for.inc198:                                       ; preds = %if.end197, %if.then179
  %122 = load i32, ptr %i, align 4
  %inc199 = add i32 %122, 1
  store i32 %inc199, ptr %i, align 4
  br label %for.cond173, !llvm.loop !48

for.end200:                                       ; preds = %for.cond173
  %123 = load i16, ptr %status, align 2
  store i16 %123, ptr %retval, align 2
  br label %return

sw.bb201:                                         ; preds = %if.end50
  %124 = load i32, ptr %dw11, align 4
  %and202 = and i32 %124, 511
  %tobool203 = icmp ne i32 %and202, 0
  br i1 %tobool203, label %if.then204, label %if.end206

if.then204:                                       ; preds = %sw.bb201
  %125 = load i32, ptr %dw11, align 4
  %and205 = and i32 %125, 511
  call void @trace_pci_nvme_err_invalid_iocsci(i32 noundef %and205)
  store i16 16427, ptr %retval, align 2
  br label %return

if.end206:                                        ; preds = %sw.bb201
  br label %sw.epilog211

sw.bb207:                                         ; preds = %if.end50
  store i16 16396, ptr %retval, align 2
  br label %return

sw.bb208:                                         ; preds = %if.end50
  %126 = load ptr, ptr %n.addr, align 8
  %127 = load ptr, ptr %ns, align 8
  %128 = load ptr, ptr %req.addr, align 8
  %call209 = call zeroext i16 @nvme_set_feature_fdp_events(ptr noundef %126, ptr noundef %127, ptr noundef %128)
  store i16 %call209, ptr %retval, align 2
  br label %return

sw.default210:                                    ; preds = %if.end50
  store i16 16654, ptr %retval, align 2
  br label %return

sw.epilog211:                                     ; preds = %if.end206, %sw.bb163, %if.end153, %for.end139, %if.end113, %for.end, %if.end81, %if.then56
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.epilog211, %sw.default210, %sw.bb208, %sw.bb207, %if.then204, %for.end200, %if.then171, %sw.bb165, %if.then152, %if.then142, %sw.default, %if.then49, %if.end42, %if.then41, %if.then32, %if.then24, %if.then14, %if.then
  %129 = load i16, ptr %retval, align 2
  ret i16 %129
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_get_feature(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %dw10 = alloca i32, align 4
  %dw11 = alloca i32, align 4
  %nsid = alloca i32, align 4
  %result = alloca i32, align 4
  %fid = alloca i8, align 1
  %sel = alloca i32, align 4
  %iv = alloca i16, align 2
  %ns = alloca ptr, align 8
  %i = alloca i32, align 4
  %endgrpid = alloca i16, align 2
  %ret = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd1, ptr %cmd, align 8
  %1 = load ptr, ptr %cmd, align 8
  %cdw10 = getelementptr inbounds %struct.NvmeCmd, ptr %1, i32 0, i32 7
  %2 = load i32, ptr %cdw10, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %dw10, align 4
  %3 = load ptr, ptr %cmd, align 8
  %cdw11 = getelementptr inbounds %struct.NvmeCmd, ptr %3, i32 0, i32 8
  %4 = load i32, ptr %cdw11, align 1
  %call2 = call i32 @le32_to_cpu(i32 noundef %4)
  store i32 %call2, ptr %dw11, align 4
  %5 = load ptr, ptr %cmd, align 8
  %nsid3 = getelementptr inbounds %struct.NvmeCmd, ptr %5, i32 0, i32 3
  %6 = load i32, ptr %nsid3, align 1
  %call4 = call i32 @le32_to_cpu(i32 noundef %6)
  store i32 %call4, ptr %nsid, align 4
  %7 = load i32, ptr %dw10, align 4
  %and = and i32 %7, 255
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %fid, align 1
  %8 = load i32, ptr %dw10, align 4
  %shr = lshr i32 %8, 8
  %and5 = and i32 %shr, 7
  store i32 %and5, ptr %sel, align 4
  store i16 0, ptr %endgrpid, align 2
  store i16 0, ptr %ret, align 2
  %9 = load ptr, ptr %req.addr, align 8
  %call6 = call zeroext i16 @nvme_cid(ptr noundef %9)
  %10 = load i32, ptr %nsid, align 4
  %11 = load i8, ptr %fid, align 1
  %12 = load i32, ptr %sel, align 4
  %conv7 = trunc i32 %12 to i8
  %13 = load i32, ptr %dw11, align 4
  call void @trace_pci_nvme_getfeat(i16 noundef zeroext %call6, i32 noundef %10, i8 noundef zeroext %11, i8 noundef zeroext %conv7, i32 noundef %13)
  %14 = load i8, ptr %fid, align 1
  %idxprom = zext i8 %14 to i64
  %arrayidx = getelementptr [256 x i8], ptr @nvme_feature_support, i64 0, i64 %idxprom
  %15 = load i8, ptr %arrayidx, align 1
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %16 = load i8, ptr %fid, align 1
  %idxprom8 = zext i8 %16 to i64
  %arrayidx9 = getelementptr [256 x i32], ptr @nvme_feature_cap, i64 0, i64 %idxprom8
  %17 = load i32, ptr %arrayidx9, align 4
  %and10 = and i32 %17, 2
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.end21

if.then12:                                        ; preds = %if.end
  %18 = load ptr, ptr %n.addr, align 8
  %19 = load i32, ptr %nsid, align 4
  %call13 = call zeroext i1 @nvme_nsid_valid(ptr noundef %18, i32 noundef %19)
  br i1 %call13, label %lor.lhs.false, label %if.then15

lor.lhs.false:                                    ; preds = %if.then12
  %20 = load i32, ptr %nsid, align 4
  %cmp = icmp eq i32 %20, -1
  br i1 %cmp, label %if.then15, label %if.end16

if.then15:                                        ; preds = %lor.lhs.false, %if.then12
  store i16 16395, ptr %retval, align 2
  br label %return

if.end16:                                         ; preds = %lor.lhs.false
  %21 = load ptr, ptr %n.addr, align 8
  %22 = load i32, ptr %nsid, align 4
  %call17 = call ptr @nvme_ns(ptr noundef %21, i32 noundef %22)
  %tobool18 = icmp ne ptr %call17, null
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end16
  store i16 16386, ptr %retval, align 2
  br label %return

if.end20:                                         ; preds = %if.end16
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.end
  %23 = load i32, ptr %sel, align 4
  switch i32 %23, label %sw.epilog [
    i32 0, label %sw.bb
    i32 2, label %sw.bb22
    i32 1, label %sw.bb22
    i32 3, label %sw.bb23
  ]

sw.bb:                                            ; preds = %if.end21
  br label %sw.epilog

sw.bb22:                                          ; preds = %if.end21, %if.end21
  br label %defaults

sw.bb23:                                          ; preds = %if.end21
  %24 = load i8, ptr %fid, align 1
  %idxprom24 = zext i8 %24 to i64
  %arrayidx25 = getelementptr [256 x i32], ptr @nvme_feature_cap, i64 0, i64 %idxprom24
  %25 = load i32, ptr %arrayidx25, align 4
  store i32 %25, ptr %result, align 4
  br label %out

sw.epilog:                                        ; preds = %sw.bb, %if.end21
  %26 = load i8, ptr %fid, align 1
  %conv26 = zext i8 %26 to i32
  switch i32 %conv26, label %sw.default [
    i32 4, label %sw.bb27
    i32 5, label %sw.bb42
    i32 6, label %sw.bb55
    i32 11, label %sw.bb68
    i32 14, label %sw.bb70
    i32 22, label %sw.bb72
    i32 29, label %sw.bb75
    i32 30, label %sw.bb89
  ]

sw.bb27:                                          ; preds = %sw.epilog
  store i32 0, ptr %result, align 4
  %27 = load i32, ptr %dw11, align 4
  %shr28 = lshr i32 %27, 16
  %and29 = and i32 %shr28, 15
  %cmp30 = icmp ne i32 %and29, 0
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %sw.bb27
  br label %out

if.end33:                                         ; preds = %sw.bb27
  %28 = load i32, ptr %dw11, align 4
  %shr34 = lshr i32 %28, 20
  %and35 = and i32 %shr34, 3
  switch i32 %and35, label %sw.epilog41 [
    i32 0, label %sw.bb36
    i32 1, label %sw.bb38
  ]

sw.bb36:                                          ; preds = %if.end33
  %29 = load ptr, ptr %n.addr, align 8
  %features = getelementptr inbounds %struct.NvmeCtrl, ptr %29, i32 0, i32 41
  %30 = getelementptr inbounds %struct.anon.28, ptr %features, i32 0, i32 0
  %temp_thresh_hi = getelementptr inbounds %struct.anon.29, ptr %30, i32 0, i32 0
  %31 = load i16, ptr %temp_thresh_hi, align 16
  %conv37 = zext i16 %31 to i32
  store i32 %conv37, ptr %result, align 4
  br label %out

sw.bb38:                                          ; preds = %if.end33
  %32 = load ptr, ptr %n.addr, align 8
  %features39 = getelementptr inbounds %struct.NvmeCtrl, ptr %32, i32 0, i32 41
  %33 = getelementptr inbounds %struct.anon.28, ptr %features39, i32 0, i32 0
  %temp_thresh_low = getelementptr inbounds %struct.anon.29, ptr %33, i32 0, i32 1
  %34 = load i16, ptr %temp_thresh_low, align 2
  %conv40 = zext i16 %34 to i32
  store i32 %conv40, ptr %result, align 4
  br label %out

sw.epilog41:                                      ; preds = %if.end33
  store i16 16386, ptr %retval, align 2
  br label %return

sw.bb42:                                          ; preds = %sw.epilog
  %35 = load ptr, ptr %n.addr, align 8
  %36 = load i32, ptr %nsid, align 4
  %call43 = call zeroext i1 @nvme_nsid_valid(ptr noundef %35, i32 noundef %36)
  br i1 %call43, label %if.end45, label %if.then44

if.then44:                                        ; preds = %sw.bb42
  store i16 16395, ptr %retval, align 2
  br label %return

if.end45:                                         ; preds = %sw.bb42
  %37 = load ptr, ptr %n.addr, align 8
  %38 = load i32, ptr %nsid, align 4
  %call46 = call ptr @nvme_ns(ptr noundef %37, i32 noundef %38)
  store ptr %call46, ptr %ns, align 8
  %39 = load ptr, ptr %ns, align 8
  %tobool47 = icmp ne ptr %39, null
  %lnot = xor i1 %tobool47, true
  %lnot48 = xor i1 %lnot, true
  %lnot49 = xor i1 %lnot48, true
  %lnot.ext = zext i1 %lnot49 to i32
  %conv50 = sext i32 %lnot.ext to i64
  %tobool51 = icmp ne i64 %conv50, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end45
  store i16 16386, ptr %retval, align 2
  br label %return

if.end53:                                         ; preds = %if.end45
  %40 = load ptr, ptr %ns, align 8
  %features54 = getelementptr inbounds %struct.NvmeNamespace, ptr %40, i32 0, i32 33
  %err_rec = getelementptr inbounds %struct.anon.13, ptr %features54, i32 0, i32 0
  %41 = load i32, ptr %err_rec, align 8
  store i32 %41, ptr %result, align 4
  br label %out

sw.bb55:                                          ; preds = %sw.epilog
  store i32 0, ptr %result, align 4
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb55
  %42 = load i32, ptr %i, align 4
  %cmp56 = icmp sle i32 %42, 256
  br i1 %cmp56, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %43 = load ptr, ptr %n.addr, align 8
  %44 = load i32, ptr %i, align 4
  %call58 = call ptr @nvme_ns(ptr noundef %43, i32 noundef %44)
  store ptr %call58, ptr %ns, align 8
  %45 = load ptr, ptr %ns, align 8
  %tobool59 = icmp ne ptr %45, null
  br i1 %tobool59, label %if.end61, label %if.then60

if.then60:                                        ; preds = %for.body
  br label %for.inc

if.end61:                                         ; preds = %for.body
  %46 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %46, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %47 = load ptr, ptr %blk, align 8
  %call62 = call zeroext i1 @blk_enable_write_cache(ptr noundef %47)
  %conv63 = zext i1 %call62 to i32
  store i32 %conv63, ptr %result, align 4
  %48 = load i32, ptr %result, align 4
  %tobool64 = icmp ne i32 %48, 0
  br i1 %tobool64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %if.end61
  br label %for.end

if.end66:                                         ; preds = %if.end61
  br label %for.inc

for.inc:                                          ; preds = %if.end66, %if.then60
  %49 = load i32, ptr %i, align 4
  %inc = add i32 %49, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !49

for.end:                                          ; preds = %if.then65, %for.cond
  %50 = load i32, ptr %result, align 4
  %tobool67 = icmp ne i32 %50, 0
  %cond = select i1 %tobool67, ptr @.str.396, ptr @.str.397
  call void @trace_pci_nvme_getfeat_vwcache(ptr noundef %cond)
  br label %out

sw.bb68:                                          ; preds = %sw.epilog
  %51 = load ptr, ptr %n.addr, align 8
  %features69 = getelementptr inbounds %struct.NvmeCtrl, ptr %51, i32 0, i32 41
  %async_config = getelementptr inbounds %struct.anon.28, ptr %features69, i32 0, i32 1
  %52 = load i32, ptr %async_config, align 4
  store i32 %52, ptr %result, align 4
  br label %out

sw.bb70:                                          ; preds = %sw.epilog
  %53 = load ptr, ptr %n.addr, align 8
  %54 = load ptr, ptr %req.addr, align 8
  %call71 = call zeroext i16 @nvme_get_feature_timestamp(ptr noundef %53, ptr noundef %54)
  store i16 %call71, ptr %retval, align 2
  br label %return

sw.bb72:                                          ; preds = %sw.epilog
  %55 = load ptr, ptr %n.addr, align 8
  %56 = load ptr, ptr %n.addr, align 8
  %features73 = getelementptr inbounds %struct.NvmeCtrl, ptr %56, i32 0, i32 41
  %hbs = getelementptr inbounds %struct.anon.28, ptr %features73, i32 0, i32 2
  %57 = load ptr, ptr %req.addr, align 8
  %call74 = call zeroext i16 @nvme_c2h(ptr noundef %55, ptr noundef %hbs, i32 noundef 512, ptr noundef %57)
  store i16 %call74, ptr %retval, align 2
  br label %return

sw.bb75:                                          ; preds = %sw.epilog
  %58 = load i32, ptr %dw11, align 4
  %and76 = and i32 %58, 255
  %conv77 = trunc i32 %and76 to i16
  store i16 %conv77, ptr %endgrpid, align 2
  %59 = load i16, ptr %endgrpid, align 2
  %conv78 = zext i16 %59 to i32
  %cmp79 = icmp ne i32 %conv78, 1
  br i1 %cmp79, label %if.then81, label %if.end82

if.then81:                                        ; preds = %sw.bb75
  store i16 16386, ptr %retval, align 2
  br label %return

if.end82:                                         ; preds = %sw.bb75
  %60 = load ptr, ptr %n.addr, align 8
  %61 = load i16, ptr %endgrpid, align 2
  %conv83 = zext i16 %61 to i32
  %call84 = call i32 @nvme_get_feature_fdp(ptr noundef %60, i32 noundef %conv83, ptr noundef %result)
  %conv85 = trunc i32 %call84 to i16
  store i16 %conv85, ptr %ret, align 2
  %62 = load i16, ptr %ret, align 2
  %tobool86 = icmp ne i16 %62, 0
  br i1 %tobool86, label %if.then87, label %if.end88

if.then87:                                        ; preds = %if.end82
  %63 = load i16, ptr %ret, align 2
  store i16 %63, ptr %retval, align 2
  br label %return

if.end88:                                         ; preds = %if.end82
  br label %out

sw.bb89:                                          ; preds = %sw.epilog
  %64 = load ptr, ptr %n.addr, align 8
  %65 = load i32, ptr %nsid, align 4
  %call90 = call zeroext i1 @nvme_nsid_valid(ptr noundef %64, i32 noundef %65)
  br i1 %call90, label %if.end92, label %if.then91

if.then91:                                        ; preds = %sw.bb89
  store i16 16395, ptr %retval, align 2
  br label %return

if.end92:                                         ; preds = %sw.bb89
  %66 = load ptr, ptr %n.addr, align 8
  %67 = load i32, ptr %nsid, align 4
  %call93 = call ptr @nvme_ns(ptr noundef %66, i32 noundef %67)
  store ptr %call93, ptr %ns, align 8
  %68 = load ptr, ptr %ns, align 8
  %tobool94 = icmp ne ptr %68, null
  %lnot95 = xor i1 %tobool94, true
  %lnot97 = xor i1 %lnot95, true
  %lnot99 = xor i1 %lnot97, true
  %lnot.ext100 = zext i1 %lnot99 to i32
  %conv101 = sext i32 %lnot.ext100 to i64
  %tobool102 = icmp ne i64 %conv101, 0
  br i1 %tobool102, label %if.then103, label %if.end104

if.then103:                                       ; preds = %if.end92
  store i16 16386, ptr %retval, align 2
  br label %return

if.end104:                                        ; preds = %if.end92
  %69 = load ptr, ptr %n.addr, align 8
  %70 = load ptr, ptr %ns, align 8
  %71 = load ptr, ptr %req.addr, align 8
  %call105 = call zeroext i16 @nvme_get_feature_fdp_events(ptr noundef %69, ptr noundef %70, ptr noundef %71, ptr noundef %result)
  store i16 %call105, ptr %ret, align 2
  %72 = load i16, ptr %ret, align 2
  %tobool106 = icmp ne i16 %72, 0
  br i1 %tobool106, label %if.then107, label %if.end108

if.then107:                                       ; preds = %if.end104
  %73 = load i16, ptr %ret, align 2
  store i16 %73, ptr %retval, align 2
  br label %return

if.end108:                                        ; preds = %if.end104
  br label %out

sw.default:                                       ; preds = %sw.epilog
  br label %sw.epilog109

sw.epilog109:                                     ; preds = %sw.default
  br label %defaults

defaults:                                         ; preds = %sw.epilog109, %sw.bb22
  %74 = load i8, ptr %fid, align 1
  %conv110 = zext i8 %74 to i32
  switch i32 %conv110, label %sw.default157 [
    i32 4, label %sw.bb111
    i32 7, label %sw.bb124
    i32 9, label %sw.bb127
    i32 29, label %sw.bb143
  ]

sw.bb111:                                         ; preds = %defaults
  store i32 0, ptr %result, align 4
  %75 = load i32, ptr %dw11, align 4
  %shr112 = lshr i32 %75, 16
  %and113 = and i32 %shr112, 15
  %cmp114 = icmp ne i32 %and113, 0
  br i1 %cmp114, label %if.then116, label %if.end117

if.then116:                                       ; preds = %sw.bb111
  br label %sw.epilog160

if.end117:                                        ; preds = %sw.bb111
  %76 = load i32, ptr %dw11, align 4
  %shr118 = lshr i32 %76, 20
  %and119 = and i32 %shr118, 3
  %cmp120 = icmp eq i32 %and119, 0
  br i1 %cmp120, label %if.then122, label %if.end123

if.then122:                                       ; preds = %if.end117
  store i32 343, ptr %result, align 4
  br label %if.end123

if.end123:                                        ; preds = %if.then122, %if.end117
  br label %sw.epilog160

sw.bb124:                                         ; preds = %defaults
  %77 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs = getelementptr inbounds %struct.NvmeCtrl, ptr %77, i32 0, i32 21
  %78 = load i32, ptr %conf_ioqpairs, align 8
  %sub = sub i32 %78, 1
  %79 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs125 = getelementptr inbounds %struct.NvmeCtrl, ptr %79, i32 0, i32 21
  %80 = load i32, ptr %conf_ioqpairs125, align 8
  %sub126 = sub i32 %80, 1
  %shl = shl i32 %sub126, 16
  %or = or i32 %sub, %shl
  store i32 %or, ptr %result, align 4
  %81 = load i32, ptr %result, align 4
  call void @trace_pci_nvme_getfeat_numq(i32 noundef %81)
  br label %sw.epilog160

sw.bb127:                                         ; preds = %defaults
  %82 = load i32, ptr %dw11, align 4
  %and128 = and i32 %82, 65535
  %conv129 = trunc i32 %and128 to i16
  store i16 %conv129, ptr %iv, align 2
  %83 = load i16, ptr %iv, align 2
  %conv130 = zext i16 %83 to i32
  %84 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs131 = getelementptr inbounds %struct.NvmeCtrl, ptr %84, i32 0, i32 21
  %85 = load i32, ptr %conf_ioqpairs131, align 8
  %add = add i32 %85, 1
  %cmp132 = icmp uge i32 %conv130, %add
  br i1 %cmp132, label %if.then134, label %if.end135

if.then134:                                       ; preds = %sw.bb127
  store i16 16386, ptr %retval, align 2
  br label %return

if.end135:                                        ; preds = %sw.bb127
  %86 = load i16, ptr %iv, align 2
  %conv136 = zext i16 %86 to i32
  store i32 %conv136, ptr %result, align 4
  %87 = load i16, ptr %iv, align 2
  %conv137 = zext i16 %87 to i32
  %88 = load ptr, ptr %n.addr, align 8
  %admin_cq = getelementptr inbounds %struct.NvmeCtrl, ptr %88, i32 0, i32 39
  %vector = getelementptr inbounds %struct.NvmeCQueue, ptr %admin_cq, i32 0, i32 6
  %89 = load i32, ptr %vector, align 8
  %cmp138 = icmp eq i32 %conv137, %89
  br i1 %cmp138, label %if.then140, label %if.end142

if.then140:                                       ; preds = %if.end135
  %90 = load i32, ptr %result, align 4
  %or141 = or i32 %90, 65536
  store i32 %or141, ptr %result, align 4
  br label %if.end142

if.end142:                                        ; preds = %if.then140, %if.end135
  br label %sw.epilog160

sw.bb143:                                         ; preds = %defaults
  %91 = load i32, ptr %dw11, align 4
  %and144 = and i32 %91, 255
  %conv145 = trunc i32 %and144 to i16
  store i16 %conv145, ptr %endgrpid, align 2
  %92 = load i16, ptr %endgrpid, align 2
  %conv146 = zext i16 %92 to i32
  %cmp147 = icmp ne i32 %conv146, 1
  br i1 %cmp147, label %if.then149, label %if.end150

if.then149:                                       ; preds = %sw.bb143
  store i16 16386, ptr %retval, align 2
  br label %return

if.end150:                                        ; preds = %sw.bb143
  %93 = load ptr, ptr %n.addr, align 8
  %94 = load i16, ptr %endgrpid, align 2
  %conv151 = zext i16 %94 to i32
  %call152 = call i32 @nvme_get_feature_fdp(ptr noundef %93, i32 noundef %conv151, ptr noundef %result)
  %conv153 = trunc i32 %call152 to i16
  store i16 %conv153, ptr %ret, align 2
  %95 = load i16, ptr %ret, align 2
  %tobool154 = icmp ne i16 %95, 0
  br i1 %tobool154, label %if.then155, label %if.end156

if.then155:                                       ; preds = %if.end150
  %96 = load i16, ptr %ret, align 2
  store i16 %96, ptr %retval, align 2
  br label %return

if.end156:                                        ; preds = %if.end150
  br label %out

sw.default157:                                    ; preds = %defaults
  %97 = load i8, ptr %fid, align 1
  %idxprom158 = zext i8 %97 to i64
  %arrayidx159 = getelementptr [256 x i32], ptr @nvme_get_feature.nvme_feature_default, i64 0, i64 %idxprom158
  %98 = load i32, ptr %arrayidx159, align 4
  store i32 %98, ptr %result, align 4
  br label %sw.epilog160

sw.epilog160:                                     ; preds = %sw.default157, %if.end142, %sw.bb124, %if.end123, %if.then116
  br label %out

out:                                              ; preds = %sw.epilog160, %if.end156, %if.end108, %if.end88, %sw.bb68, %for.end, %if.end53, %sw.bb38, %sw.bb36, %if.then32, %sw.bb23
  %99 = load i32, ptr %result, align 4
  %call161 = call i32 @cpu_to_le32(i32 noundef %99)
  %100 = load ptr, ptr %req.addr, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %100, i32 0, i32 5
  %result162 = getelementptr inbounds %struct.NvmeCqe, ptr %cqe, i32 0, i32 0
  store i32 %call161, ptr %result162, align 8
  %101 = load i16, ptr %ret, align 2
  store i16 %101, ptr %retval, align 2
  br label %return

return:                                           ; preds = %out, %if.then155, %if.then149, %if.then134, %if.then107, %if.then103, %if.then91, %if.then87, %if.then81, %sw.bb72, %sw.bb70, %if.then52, %if.then44, %sw.epilog41, %if.then19, %if.then15, %if.then
  %102 = load i16, ptr %retval, align 2
  ret i16 %102
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_aer(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_cid(ptr noundef %0)
  call void @trace_pci_nvme_aer(i16 noundef zeroext %call)
  %1 = load ptr, ptr %n.addr, align 8
  %outstanding_aers = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 12
  %2 = load i8, ptr %outstanding_aers, align 8
  %conv = zext i8 %2 to i32
  %3 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 4
  %aerl = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 5
  %4 = load i8, ptr %aerl, align 8
  %conv1 = zext i8 %4 to i32
  %cmp = icmp sgt i32 %conv, %conv1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @trace_pci_nvme_aer_aerl_exceeded()
  store i16 261, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %req.addr, align 8
  %6 = load ptr, ptr %n.addr, align 8
  %aer_reqs = getelementptr inbounds %struct.NvmeCtrl, ptr %6, i32 0, i32 28
  %7 = load ptr, ptr %aer_reqs, align 16
  %8 = load ptr, ptr %n.addr, align 8
  %outstanding_aers3 = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 12
  %9 = load i8, ptr %outstanding_aers3, align 8
  %idxprom = zext i8 %9 to i64
  %arrayidx = getelementptr ptr, ptr %7, i64 %idxprom
  store ptr %5, ptr %arrayidx, align 8
  %10 = load ptr, ptr %n.addr, align 8
  %outstanding_aers4 = getelementptr inbounds %struct.NvmeCtrl, ptr %10, i32 0, i32 12
  %11 = load i8, ptr %outstanding_aers4, align 8
  %inc = add i8 %11, 1
  store i8 %inc, ptr %outstanding_aers4, align 8
  %12 = load ptr, ptr %n.addr, align 8
  %aer_queue = getelementptr inbounds %struct.NvmeCtrl, ptr %12, i32 0, i32 29
  %13 = load ptr, ptr %aer_queue, align 8
  %cmp5 = icmp eq ptr %13, null
  br i1 %cmp5, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end
  %14 = load ptr, ptr %n.addr, align 8
  call void @nvme_process_aers(ptr noundef %14)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end
  store i16 -1, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end8, %if.then
  %15 = load i16, ptr %retval, align 2
  ret i16 %15
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_ns_attachment(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %ctrl = alloca ptr, align 8
  %list = alloca [2048 x i16], align 16
  %nsid = alloca i32, align 4
  %dw10 = alloca i32, align 4
  %sel = alloca i8, align 1
  %nr_ids = alloca ptr, align 8
  %ids = alloca ptr, align 8
  %ret = alloca i16, align 2
  %i = alloca i32, align 4
  %_a51 = alloca i32, align 4
  %_b52 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 16 %list, i8 0, i64 4096, i1 false)
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  %nsid1 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 3
  %1 = load i32, ptr %nsid1, align 4
  %call = call i32 @le32_to_cpu(i32 noundef %1)
  store i32 %call, ptr %nsid, align 4
  %2 = load ptr, ptr %req.addr, align 8
  %cmd2 = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 6
  %cdw10 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd2, i32 0, i32 7
  %3 = load i32, ptr %cdw10, align 8
  %call3 = call i32 @le32_to_cpu(i32 noundef %3)
  store i32 %call3, ptr %dw10, align 4
  %4 = load i32, ptr %dw10, align 4
  %and = and i32 %4, 15
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %sel, align 1
  %arrayidx = getelementptr [2048 x i16], ptr %list, i64 0, i64 0
  store ptr %arrayidx, ptr %nr_ids, align 8
  %arrayidx4 = getelementptr [2048 x i16], ptr %list, i64 0, i64 1
  store ptr %arrayidx4, ptr %ids, align 8
  %5 = load ptr, ptr %req.addr, align 8
  %call5 = call zeroext i16 @nvme_cid(ptr noundef %5)
  %6 = load i32, ptr %dw10, align 4
  %and6 = and i32 %6, 15
  %conv7 = trunc i32 %and6 to i8
  call void @trace_pci_nvme_ns_attachment(i16 noundef zeroext %call5, i8 noundef zeroext %conv7)
  %7 = load ptr, ptr %n.addr, align 8
  %8 = load i32, ptr %nsid, align 4
  %call8 = call zeroext i1 @nvme_nsid_valid(ptr noundef %7, i32 noundef %8)
  br i1 %call8, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 16395, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %9 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 33
  %10 = load ptr, ptr %subsys, align 8
  %11 = load i32, ptr %nsid, align 4
  %call9 = call ptr @nvme_subsys_ns(ptr noundef %10, i32 noundef %11)
  store ptr %call9, ptr %ns, align 8
  %12 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %12, null
  br i1 %tobool, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end
  store i16 16386, ptr %retval, align 2
  br label %return

if.end11:                                         ; preds = %if.end
  %13 = load ptr, ptr %n.addr, align 8
  %arraydecay = getelementptr inbounds [2048 x i16], ptr %list, i64 0, i64 0
  %14 = load ptr, ptr %req.addr, align 8
  %call12 = call zeroext i16 @nvme_h2c(ptr noundef %13, ptr noundef %arraydecay, i32 noundef 4096, ptr noundef %14)
  store i16 %call12, ptr %ret, align 2
  %15 = load i16, ptr %ret, align 2
  %tobool13 = icmp ne i16 %15, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end11
  %16 = load i16, ptr %ret, align 2
  store i16 %16, ptr %retval, align 2
  br label %return

if.end15:                                         ; preds = %if.end11
  %17 = load ptr, ptr %nr_ids, align 8
  %18 = load i16, ptr %17, align 2
  %tobool16 = icmp ne i16 %18, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  store i16 16668, ptr %retval, align 2
  br label %return

if.end18:                                         ; preds = %if.end15
  %19 = load ptr, ptr %nr_ids, align 8
  %20 = load i16, ptr %19, align 2
  %conv19 = zext i16 %20 to i32
  store i32 %conv19, ptr %_a51, align 4
  store i32 2047, ptr %_b52, align 4
  %21 = load i32, ptr %_a51, align 4
  %22 = load i32, ptr %_b52, align 4
  %cmp = icmp slt i32 %21, %22
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end18
  %23 = load i32, ptr %_a51, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end18
  %24 = load i32, ptr %_b52, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %23, %cond.true ], [ %24, %cond.false ]
  store i32 %cond, ptr %tmp, align 4
  %25 = load i32, ptr %tmp, align 4
  %conv21 = trunc i32 %25 to i16
  %26 = load ptr, ptr %nr_ids, align 8
  store i16 %conv21, ptr %26, align 2
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %27 = load i32, ptr %i, align 4
  %28 = load ptr, ptr %nr_ids, align 8
  %29 = load i16, ptr %28, align 2
  %conv22 = zext i16 %29 to i32
  %cmp23 = icmp slt i32 %27, %conv22
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %30 = load ptr, ptr %n.addr, align 8
  %subsys25 = getelementptr inbounds %struct.NvmeCtrl, ptr %30, i32 0, i32 33
  %31 = load ptr, ptr %subsys25, align 8
  %32 = load ptr, ptr %ids, align 8
  %33 = load i32, ptr %i, align 4
  %idxprom = sext i32 %33 to i64
  %arrayidx26 = getelementptr i16, ptr %32, i64 %idxprom
  %34 = load i16, ptr %arrayidx26, align 2
  %conv27 = zext i16 %34 to i32
  %call28 = call ptr @nvme_subsys_ctrl(ptr noundef %31, i32 noundef %conv27)
  store ptr %call28, ptr %ctrl, align 8
  %35 = load ptr, ptr %ctrl, align 8
  %tobool29 = icmp ne ptr %35, null
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %for.body
  store i16 16668, ptr %retval, align 2
  br label %return

if.end31:                                         ; preds = %for.body
  %36 = load i8, ptr %sel, align 1
  %conv32 = zext i8 %36 to i32
  switch i32 %conv32, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb41
  ]

sw.bb:                                            ; preds = %if.end31
  %37 = load ptr, ptr %ctrl, align 8
  %38 = load i32, ptr %nsid, align 4
  %call33 = call ptr @nvme_ns(ptr noundef %37, i32 noundef %38)
  %tobool34 = icmp ne ptr %call33, null
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %sw.bb
  store i16 16664, ptr %retval, align 2
  br label %return

if.end36:                                         ; preds = %sw.bb
  %39 = load ptr, ptr %ns, align 8
  %attached = getelementptr inbounds %struct.NvmeNamespace, ptr %39, i32 0, i32 13
  %40 = load i32, ptr %attached, align 4
  %tobool37 = icmp ne i32 %40, 0
  br i1 %tobool37, label %land.lhs.true, label %if.end40

land.lhs.true:                                    ; preds = %if.end36
  %41 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %41, i32 0, i32 30
  %shared = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 1
  %42 = load i8, ptr %shared, align 1
  %tobool38 = trunc i8 %42 to i1
  br i1 %tobool38, label %if.end40, label %if.then39

if.then39:                                        ; preds = %land.lhs.true
  store i16 16665, ptr %retval, align 2
  br label %return

if.end40:                                         ; preds = %land.lhs.true, %if.end36
  %43 = load ptr, ptr %ctrl, align 8
  %44 = load ptr, ptr %ns, align 8
  call void @nvme_attach_ns(ptr noundef %43, ptr noundef %44)
  %45 = load ptr, ptr %ctrl, align 8
  %46 = load ptr, ptr %ns, align 8
  call void @nvme_select_iocs_ns(ptr noundef %45, ptr noundef %46)
  br label %sw.epilog

sw.bb41:                                          ; preds = %if.end31
  %47 = load ptr, ptr %ctrl, align 8
  %48 = load i32, ptr %nsid, align 4
  %call42 = call ptr @nvme_ns(ptr noundef %47, i32 noundef %48)
  %tobool43 = icmp ne ptr %call42, null
  br i1 %tobool43, label %if.end45, label %if.then44

if.then44:                                        ; preds = %sw.bb41
  store i16 16666, ptr %retval, align 2
  br label %return

if.end45:                                         ; preds = %sw.bb41
  %49 = load ptr, ptr %ctrl, align 8
  %namespaces = getelementptr inbounds %struct.NvmeCtrl, ptr %49, i32 0, i32 35
  %50 = load i32, ptr %nsid, align 4
  %idxprom46 = zext i32 %50 to i64
  %arrayidx47 = getelementptr [257 x ptr], ptr %namespaces, i64 0, i64 %idxprom46
  store ptr null, ptr %arrayidx47, align 8
  %51 = load ptr, ptr %ns, align 8
  %attached48 = getelementptr inbounds %struct.NvmeNamespace, ptr %51, i32 0, i32 13
  %52 = load i32, ptr %attached48, align 4
  %dec = add i32 %52, -1
  store i32 %dec, ptr %attached48, align 4
  %53 = load ptr, ptr %ctrl, align 8
  call void @nvme_update_dmrsl(ptr noundef %53)
  br label %sw.epilog

sw.default:                                       ; preds = %if.end31
  store i16 16386, ptr %retval, align 2
  br label %return

sw.epilog:                                        ; preds = %if.end45, %if.end40
  %54 = load i32, ptr %nsid, align 4
  %conv49 = zext i32 %54 to i64
  %55 = load ptr, ptr %ctrl, align 8
  %changed_nsids = getelementptr inbounds %struct.NvmeCtrl, ptr %55, i32 0, i32 32
  %arraydecay50 = getelementptr inbounds [5 x i64], ptr %changed_nsids, i64 0, i64 0
  %call51 = call i32 @test_and_set_bit(i64 noundef %conv49, ptr noundef %arraydecay50)
  %tobool52 = icmp ne i32 %call51, 0
  br i1 %tobool52, label %if.end54, label %if.then53

if.then53:                                        ; preds = %sw.epilog
  %56 = load ptr, ptr %ctrl, align 8
  call void @nvme_enqueue_event(ptr noundef %56, i8 noundef zeroext 2, i8 noundef zeroext 0, i8 noundef zeroext 4)
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %sw.epilog
  br label %for.inc

for.inc:                                          ; preds = %if.end54
  %57 = load i32, ptr %i, align 4
  %inc = add i32 %57, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !50

for.end:                                          ; preds = %for.cond
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %for.end, %sw.default, %if.then44, %if.then39, %if.then35, %if.then30, %if.then17, %if.then14, %if.then10, %if.then
  %58 = load i16, ptr %retval, align 2
  ret i16 %58
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_virt_mngmt(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %dw10 = alloca i32, align 4
  %dw11 = alloca i32, align 4
  %act = alloca i8, align 1
  %rt = alloca i8, align 1
  %cntlid = alloca i16, align 2
  %nr = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  %cdw10 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 7
  %1 = load i32, ptr %cdw10, align 8
  %call = call i32 @le32_to_cpu(i32 noundef %1)
  store i32 %call, ptr %dw10, align 4
  %2 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 6
  %cdw11 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd1, i32 0, i32 8
  %3 = load i32, ptr %cdw11, align 4
  %call2 = call i32 @le32_to_cpu(i32 noundef %3)
  store i32 %call2, ptr %dw11, align 4
  %4 = load i32, ptr %dw10, align 4
  %and = and i32 %4, 15
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %act, align 1
  %5 = load i32, ptr %dw10, align 4
  %shr = lshr i32 %5, 8
  %and3 = and i32 %shr, 7
  %conv4 = trunc i32 %and3 to i8
  store i8 %conv4, ptr %rt, align 1
  %6 = load i32, ptr %dw10, align 4
  %shr5 = lshr i32 %6, 16
  %and6 = and i32 %shr5, 65535
  %conv7 = trunc i32 %and6 to i16
  store i16 %conv7, ptr %cntlid, align 2
  %7 = load i32, ptr %dw11, align 4
  %and8 = and i32 %7, 65535
  store i32 %and8, ptr %nr, align 4
  %8 = load ptr, ptr %req.addr, align 8
  %call9 = call zeroext i16 @nvme_cid(ptr noundef %8)
  %9 = load i8, ptr %act, align 1
  %conv10 = zext i8 %9 to i16
  %10 = load i16, ptr %cntlid, align 2
  %11 = load i8, ptr %rt, align 1
  %conv11 = zext i8 %11 to i32
  %tobool = icmp ne i32 %conv11, 0
  %cond = select i1 %tobool, ptr @.str.412, ptr @.str.413
  %12 = load i32, ptr %nr, align 4
  %conv12 = trunc i32 %12 to i16
  call void @trace_pci_nvme_virt_mngmt(i16 noundef zeroext %call9, i16 noundef zeroext %conv10, i16 noundef zeroext %10, ptr noundef %cond, i16 noundef zeroext %conv12)
  %13 = load i8, ptr %rt, align 1
  %conv13 = zext i8 %13 to i32
  %cmp = icmp ne i32 %conv13, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %14 = load i8, ptr %rt, align 1
  %conv15 = zext i8 %14 to i32
  %cmp16 = icmp ne i32 %conv15, 1
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i16 16674, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %15 = load i8, ptr %act, align 1
  %conv18 = zext i8 %15 to i32
  switch i32 %conv18, label %sw.default [
    i32 8, label %sw.bb
    i32 1, label %sw.bb20
    i32 9, label %sw.bb22
    i32 7, label %sw.bb24
  ]

sw.bb:                                            ; preds = %if.end
  %16 = load ptr, ptr %n.addr, align 8
  %17 = load ptr, ptr %req.addr, align 8
  %18 = load i16, ptr %cntlid, align 2
  %19 = load i8, ptr %rt, align 1
  %20 = load i32, ptr %nr, align 4
  %call19 = call zeroext i16 @nvme_assign_virt_res_to_sec(ptr noundef %16, ptr noundef %17, i16 noundef zeroext %18, i8 noundef zeroext %19, i32 noundef %20)
  store i16 %call19, ptr %retval, align 2
  br label %return

sw.bb20:                                          ; preds = %if.end
  %21 = load ptr, ptr %n.addr, align 8
  %22 = load ptr, ptr %req.addr, align 8
  %23 = load i16, ptr %cntlid, align 2
  %24 = load i8, ptr %rt, align 1
  %25 = load i32, ptr %nr, align 4
  %call21 = call zeroext i16 @nvme_assign_virt_res_to_prim(ptr noundef %21, ptr noundef %22, i16 noundef zeroext %23, i8 noundef zeroext %24, i32 noundef %25)
  store i16 %call21, ptr %retval, align 2
  br label %return

sw.bb22:                                          ; preds = %if.end
  %26 = load ptr, ptr %n.addr, align 8
  %27 = load i16, ptr %cntlid, align 2
  %call23 = call zeroext i16 @nvme_virt_set_state(ptr noundef %26, i16 noundef zeroext %27, i1 noundef zeroext true)
  store i16 %call23, ptr %retval, align 2
  br label %return

sw.bb24:                                          ; preds = %if.end
  %28 = load ptr, ptr %n.addr, align 8
  %29 = load i16, ptr %cntlid, align 2
  %call25 = call zeroext i16 @nvme_virt_set_state(ptr noundef %28, i16 noundef zeroext %29, i1 noundef zeroext false)
  store i16 %call25, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %if.end
  store i16 16386, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.default, %sw.bb24, %sw.bb22, %sw.bb20, %sw.bb, %if.then
  %30 = load i16, ptr %retval, align 2
  ret i16 %30
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_dbbuf_config(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %pci = alloca ptr, align 8
  %dbs_addr = alloca i64, align 8
  %eis_addr = alloca i64, align 8
  %i = alloca i32, align 4
  %sq = alloca ptr, align 8
  %cq = alloca ptr, align 8
  %.compoundliteral = alloca %struct.MemTxAttrs, align 4
  %.compoundliteral77 = alloca %struct.MemTxAttrs, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %0)
  store ptr %call, ptr %pci, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %1, i32 0, i32 6
  %dptr = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 6
  %prp1 = getelementptr inbounds %struct.anon, ptr %dptr, i32 0, i32 0
  %2 = load i64, ptr %prp1, align 8
  %call1 = call i64 @le64_to_cpu(i64 noundef %2)
  store i64 %call1, ptr %dbs_addr, align 8
  %3 = load ptr, ptr %req.addr, align 8
  %cmd2 = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 6
  %dptr3 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd2, i32 0, i32 6
  %prp2 = getelementptr inbounds %struct.anon, ptr %dptr3, i32 0, i32 1
  %4 = load i64, ptr %prp2, align 8
  %call4 = call i64 @le64_to_cpu(i64 noundef %4)
  store i64 %call4, ptr %eis_addr, align 8
  %5 = load i64, ptr %dbs_addr, align 8
  %6 = load ptr, ptr %n.addr, align 8
  %page_size = getelementptr inbounds %struct.NvmeCtrl, ptr %6, i32 0, i32 8
  %7 = load i32, ptr %page_size, align 4
  %sub = sub i32 %7, 1
  %conv = zext i32 %sub to i64
  %and = and i64 %5, %conv
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %8 = load i64, ptr %eis_addr, align 8
  %9 = load ptr, ptr %n.addr, align 8
  %page_size5 = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 8
  %10 = load i32, ptr %page_size5, align 4
  %sub6 = sub i32 %10, 1
  %conv7 = zext i32 %sub6 to i64
  %and8 = and i64 %8, %conv7
  %tobool9 = icmp ne i64 %and8, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %11 = load i64, ptr %dbs_addr, align 8
  %12 = load ptr, ptr %n.addr, align 8
  %dbbuf_dbs = getelementptr inbounds %struct.NvmeCtrl, ptr %12, i32 0, i32 22
  store i64 %11, ptr %dbbuf_dbs, align 16
  %13 = load i64, ptr %eis_addr, align 8
  %14 = load ptr, ptr %n.addr, align 8
  %dbbuf_eis = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 23
  store i64 %13, ptr %dbbuf_eis, align 8
  %15 = load ptr, ptr %n.addr, align 8
  %dbbuf_enabled = getelementptr inbounds %struct.NvmeCtrl, ptr %15, i32 0, i32 24
  store i8 1, ptr %dbbuf_enabled, align 16
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %16 = load i32, ptr %i, align 4
  %17 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %17, i32 0, i32 4
  %max_ioqpairs = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 2
  %18 = load i32, ptr %max_ioqpairs, align 4
  %add = add i32 %18, 1
  %cmp = icmp ult i32 %16, %add
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %19 = load ptr, ptr %n.addr, align 8
  %sq11 = getelementptr inbounds %struct.NvmeCtrl, ptr %19, i32 0, i32 36
  %20 = load ptr, ptr %sq11, align 16
  %21 = load i32, ptr %i, align 4
  %idxprom = sext i32 %21 to i64
  %arrayidx = getelementptr ptr, ptr %20, i64 %idxprom
  %22 = load ptr, ptr %arrayidx, align 8
  store ptr %22, ptr %sq, align 8
  %23 = load ptr, ptr %n.addr, align 8
  %cq12 = getelementptr inbounds %struct.NvmeCtrl, ptr %23, i32 0, i32 37
  %24 = load ptr, ptr %cq12, align 8
  %25 = load i32, ptr %i, align 4
  %idxprom13 = sext i32 %25 to i64
  %arrayidx14 = getelementptr ptr, ptr %24, i64 %idxprom13
  %26 = load ptr, ptr %arrayidx14, align 8
  store ptr %26, ptr %cq, align 8
  %27 = load ptr, ptr %sq, align 8
  %tobool15 = icmp ne ptr %27, null
  br i1 %tobool15, label %if.then16, label %if.end63

if.then16:                                        ; preds = %for.body
  %28 = load i64, ptr %dbs_addr, align 8
  %29 = load i32, ptr %i, align 4
  %shl = shl i32 %29, 3
  %conv17 = sext i32 %shl to i64
  %add18 = add i64 %28, %conv17
  %30 = load ptr, ptr %sq, align 8
  %db_addr = getelementptr inbounds %struct.NvmeSQueue, ptr %30, i32 0, i32 7
  store i64 %add18, ptr %db_addr, align 8
  %31 = load i64, ptr %eis_addr, align 8
  %32 = load i32, ptr %i, align 4
  %shl19 = shl i32 %32, 3
  %conv20 = sext i32 %shl19 to i64
  %add21 = add i64 %31, %conv20
  %33 = load ptr, ptr %sq, align 8
  %ei_addr = getelementptr inbounds %struct.NvmeSQueue, ptr %33, i32 0, i32 8
  store i64 %add21, ptr %ei_addr, align 8
  %34 = load ptr, ptr %pci, align 8
  %35 = load ptr, ptr %sq, align 8
  %db_addr22 = getelementptr inbounds %struct.NvmeSQueue, ptr %35, i32 0, i32 7
  %36 = load i64, ptr %db_addr22, align 8
  %37 = load ptr, ptr %sq, align 8
  %tail = getelementptr inbounds %struct.NvmeSQueue, ptr %37, i32 0, i32 4
  %38 = load i32, ptr %tail, align 8
  %bf.load = load i32, ptr %.compoundliteral, align 4
  %bf.clear = and i32 %bf.load, -2
  %bf.set = or i32 %bf.clear, 1
  store i32 %bf.set, ptr %.compoundliteral, align 4
  %bf.load23 = load i32, ptr %.compoundliteral, align 4
  %bf.clear24 = and i32 %bf.load23, -3
  %bf.set25 = or i32 %bf.clear24, 0
  store i32 %bf.set25, ptr %.compoundliteral, align 4
  %bf.load26 = load i32, ptr %.compoundliteral, align 4
  %bf.clear27 = and i32 %bf.load26, -13
  %bf.set28 = or i32 %bf.clear27, 0
  store i32 %bf.set28, ptr %.compoundliteral, align 4
  %bf.load29 = load i32, ptr %.compoundliteral, align 4
  %bf.clear30 = and i32 %bf.load29, -17
  %bf.set31 = or i32 %bf.clear30, 0
  store i32 %bf.set31, ptr %.compoundliteral, align 4
  %bf.load32 = load i32, ptr %.compoundliteral, align 4
  %bf.clear33 = and i32 %bf.load32, -33
  %bf.set34 = or i32 %bf.clear33, 0
  store i32 %bf.set34, ptr %.compoundliteral, align 4
  %bf.load35 = load i32, ptr %.compoundliteral, align 4
  %bf.clear36 = and i32 %bf.load35, -4194241
  %bf.set37 = or i32 %bf.clear36, 0
  store i32 %bf.set37, ptr %.compoundliteral, align 4
  %bf.load38 = load i32, ptr %.compoundliteral, align 4
  %bf.clear39 = and i32 %bf.load38, -4194305
  %bf.set40 = or i32 %bf.clear39, 0
  store i32 %bf.set40, ptr %.compoundliteral, align 4
  %bf.load41 = load i32, ptr %.compoundliteral, align 4
  %bf.clear42 = and i32 %bf.load41, -8388609
  %bf.set43 = or i32 %bf.clear42, 0
  store i32 %bf.set43, ptr %.compoundliteral, align 4
  %bf.load44 = load i32, ptr %.compoundliteral, align 4
  %bf.clear45 = and i32 %bf.load44, -16777217
  %bf.set46 = or i32 %bf.clear45, 0
  store i32 %bf.set46, ptr %.compoundliteral, align 4
  %bf.load47 = load i32, ptr %.compoundliteral, align 4
  %bf.clear48 = and i32 %bf.load47, -33554433
  %bf.set49 = or i32 %bf.clear48, 0
  store i32 %bf.set49, ptr %.compoundliteral, align 4
  %coerce.dive = getelementptr inbounds %struct.MemTxAttrs, ptr %.compoundliteral, i32 0, i32 0
  %39 = load i32, ptr %coerce.dive, align 4
  %call50 = call i32 @stl_le_pci_dma(ptr noundef %34, i64 noundef %36, i32 noundef %38, i32 %39)
  %40 = load ptr, ptr %n.addr, align 8
  %params51 = getelementptr inbounds %struct.NvmeCtrl, ptr %40, i32 0, i32 4
  %ioeventfd = getelementptr inbounds %struct.NvmeParams, ptr %params51, i32 0, i32 13
  %41 = load i8, ptr %ioeventfd, align 2
  %tobool52 = trunc i8 %41 to i1
  br i1 %tobool52, label %land.lhs.true, label %if.end62

land.lhs.true:                                    ; preds = %if.then16
  %42 = load ptr, ptr %sq, align 8
  %sqid = getelementptr inbounds %struct.NvmeSQueue, ptr %42, i32 0, i32 1
  %43 = load i16, ptr %sqid, align 8
  %conv54 = zext i16 %43 to i32
  %cmp55 = icmp ne i32 %conv54, 0
  br i1 %cmp55, label %if.then57, label %if.end62

if.then57:                                        ; preds = %land.lhs.true
  %44 = load ptr, ptr %sq, align 8
  %call58 = call i32 @nvme_init_sq_ioeventfd(ptr noundef %44)
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.end61, label %if.then60

if.then60:                                        ; preds = %if.then57
  %45 = load ptr, ptr %sq, align 8
  %ioeventfd_enabled = getelementptr inbounds %struct.NvmeSQueue, ptr %45, i32 0, i32 11
  store i8 1, ptr %ioeventfd_enabled, align 4
  br label %if.end61

if.end61:                                         ; preds = %if.then60, %if.then57
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %land.lhs.true, %if.then16
  br label %if.end63

if.end63:                                         ; preds = %if.end62, %for.body
  %46 = load ptr, ptr %cq, align 8
  %tobool64 = icmp ne ptr %46, null
  br i1 %tobool64, label %if.then65, label %if.end125

if.then65:                                        ; preds = %if.end63
  %47 = load i64, ptr %dbs_addr, align 8
  %48 = load i32, ptr %i, align 4
  %shl66 = shl i32 %48, 3
  %conv67 = sext i32 %shl66 to i64
  %add68 = add i64 %47, %conv67
  %add69 = add i64 %add68, 4
  %49 = load ptr, ptr %cq, align 8
  %db_addr70 = getelementptr inbounds %struct.NvmeCQueue, ptr %49, i32 0, i32 9
  store i64 %add69, ptr %db_addr70, align 8
  %50 = load i64, ptr %eis_addr, align 8
  %51 = load i32, ptr %i, align 4
  %shl71 = shl i32 %51, 3
  %conv72 = sext i32 %shl71 to i64
  %add73 = add i64 %50, %conv72
  %add74 = add i64 %add73, 4
  %52 = load ptr, ptr %cq, align 8
  %ei_addr75 = getelementptr inbounds %struct.NvmeCQueue, ptr %52, i32 0, i32 10
  store i64 %add74, ptr %ei_addr75, align 8
  %53 = load ptr, ptr %pci, align 8
  %54 = load ptr, ptr %cq, align 8
  %db_addr76 = getelementptr inbounds %struct.NvmeCQueue, ptr %54, i32 0, i32 9
  %55 = load i64, ptr %db_addr76, align 8
  %56 = load ptr, ptr %cq, align 8
  %head = getelementptr inbounds %struct.NvmeCQueue, ptr %56, i32 0, i32 4
  %57 = load i32, ptr %head, align 8
  %bf.load78 = load i32, ptr %.compoundliteral77, align 4
  %bf.clear79 = and i32 %bf.load78, -2
  %bf.set80 = or i32 %bf.clear79, 1
  store i32 %bf.set80, ptr %.compoundliteral77, align 4
  %bf.load81 = load i32, ptr %.compoundliteral77, align 4
  %bf.clear82 = and i32 %bf.load81, -3
  %bf.set83 = or i32 %bf.clear82, 0
  store i32 %bf.set83, ptr %.compoundliteral77, align 4
  %bf.load84 = load i32, ptr %.compoundliteral77, align 4
  %bf.clear85 = and i32 %bf.load84, -13
  %bf.set86 = or i32 %bf.clear85, 0
  store i32 %bf.set86, ptr %.compoundliteral77, align 4
  %bf.load87 = load i32, ptr %.compoundliteral77, align 4
  %bf.clear88 = and i32 %bf.load87, -17
  %bf.set89 = or i32 %bf.clear88, 0
  store i32 %bf.set89, ptr %.compoundliteral77, align 4
  %bf.load90 = load i32, ptr %.compoundliteral77, align 4
  %bf.clear91 = and i32 %bf.load90, -33
  %bf.set92 = or i32 %bf.clear91, 0
  store i32 %bf.set92, ptr %.compoundliteral77, align 4
  %bf.load93 = load i32, ptr %.compoundliteral77, align 4
  %bf.clear94 = and i32 %bf.load93, -4194241
  %bf.set95 = or i32 %bf.clear94, 0
  store i32 %bf.set95, ptr %.compoundliteral77, align 4
  %bf.load96 = load i32, ptr %.compoundliteral77, align 4
  %bf.clear97 = and i32 %bf.load96, -4194305
  %bf.set98 = or i32 %bf.clear97, 0
  store i32 %bf.set98, ptr %.compoundliteral77, align 4
  %bf.load99 = load i32, ptr %.compoundliteral77, align 4
  %bf.clear100 = and i32 %bf.load99, -8388609
  %bf.set101 = or i32 %bf.clear100, 0
  store i32 %bf.set101, ptr %.compoundliteral77, align 4
  %bf.load102 = load i32, ptr %.compoundliteral77, align 4
  %bf.clear103 = and i32 %bf.load102, -16777217
  %bf.set104 = or i32 %bf.clear103, 0
  store i32 %bf.set104, ptr %.compoundliteral77, align 4
  %bf.load105 = load i32, ptr %.compoundliteral77, align 4
  %bf.clear106 = and i32 %bf.load105, -33554433
  %bf.set107 = or i32 %bf.clear106, 0
  store i32 %bf.set107, ptr %.compoundliteral77, align 4
  %coerce.dive108 = getelementptr inbounds %struct.MemTxAttrs, ptr %.compoundliteral77, i32 0, i32 0
  %58 = load i32, ptr %coerce.dive108, align 4
  %call109 = call i32 @stl_le_pci_dma(ptr noundef %53, i64 noundef %55, i32 noundef %57, i32 %58)
  %59 = load ptr, ptr %n.addr, align 8
  %params110 = getelementptr inbounds %struct.NvmeCtrl, ptr %59, i32 0, i32 4
  %ioeventfd111 = getelementptr inbounds %struct.NvmeParams, ptr %params110, i32 0, i32 13
  %60 = load i8, ptr %ioeventfd111, align 2
  %tobool112 = trunc i8 %60 to i1
  br i1 %tobool112, label %land.lhs.true114, label %if.end124

land.lhs.true114:                                 ; preds = %if.then65
  %61 = load ptr, ptr %cq, align 8
  %cqid = getelementptr inbounds %struct.NvmeCQueue, ptr %61, i32 0, i32 2
  %62 = load i16, ptr %cqid, align 2
  %conv115 = zext i16 %62 to i32
  %cmp116 = icmp ne i32 %conv115, 0
  br i1 %cmp116, label %if.then118, label %if.end124

if.then118:                                       ; preds = %land.lhs.true114
  %63 = load ptr, ptr %cq, align 8
  %call119 = call i32 @nvme_init_cq_ioeventfd(ptr noundef %63)
  %tobool120 = icmp ne i32 %call119, 0
  br i1 %tobool120, label %if.end123, label %if.then121

if.then121:                                       ; preds = %if.then118
  %64 = load ptr, ptr %cq, align 8
  %ioeventfd_enabled122 = getelementptr inbounds %struct.NvmeCQueue, ptr %64, i32 0, i32 13
  store i8 1, ptr %ioeventfd_enabled122, align 4
  br label %if.end123

if.end123:                                        ; preds = %if.then121, %if.then118
  br label %if.end124

if.end124:                                        ; preds = %if.end123, %land.lhs.true114, %if.then65
  br label %if.end125

if.end125:                                        ; preds = %if.end124, %if.end63
  br label %for.inc

for.inc:                                          ; preds = %if.end125
  %65 = load i32, ptr %i, align 4
  %inc = add i32 %65, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !51

for.end:                                          ; preds = %for.cond
  %66 = load i64, ptr %dbs_addr, align 8
  %67 = load i64, ptr %eis_addr, align 8
  call void @trace_pci_nvme_dbbuf_config(i64 noundef %66, i64 noundef %67)
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %for.end, %if.then
  %68 = load i16, ptr %retval, align 2
  ret i16 %68
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_format(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %iocb = alloca ptr, align 8
  %nsid = alloca i32, align 4
  %dw10 = alloca i32, align 4
  %lbaf = alloca i8, align 1
  %mset = alloca i8, align 1
  %pi = alloca i8, align 1
  %pil = alloca i8, align 1
  %lbafu = alloca i8, align 1
  %status = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  %nsid1 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 3
  %1 = load i32, ptr %nsid1, align 4
  %call = call i32 @le32_to_cpu(i32 noundef %1)
  store i32 %call, ptr %nsid, align 4
  %2 = load ptr, ptr %req.addr, align 8
  %cmd2 = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 6
  %cdw10 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd2, i32 0, i32 7
  %3 = load i32, ptr %cdw10, align 8
  %call3 = call i32 @le32_to_cpu(i32 noundef %3)
  store i32 %call3, ptr %dw10, align 4
  %4 = load i32, ptr %dw10, align 4
  %and = and i32 %4, 15
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %lbaf, align 1
  %5 = load i32, ptr %dw10, align 4
  %shr = lshr i32 %5, 4
  %and4 = and i32 %shr, 1
  %conv5 = trunc i32 %and4 to i8
  store i8 %conv5, ptr %mset, align 1
  %6 = load i32, ptr %dw10, align 4
  %shr6 = lshr i32 %6, 5
  %and7 = and i32 %shr6, 7
  %conv8 = trunc i32 %and7 to i8
  store i8 %conv8, ptr %pi, align 1
  %7 = load i32, ptr %dw10, align 4
  %shr9 = lshr i32 %7, 8
  %and10 = and i32 %shr9, 1
  %conv11 = trunc i32 %and10 to i8
  store i8 %conv11, ptr %pil, align 1
  %8 = load i32, ptr %dw10, align 4
  %shr12 = lshr i32 %8, 12
  %and13 = and i32 %shr12, 3
  %conv14 = trunc i32 %and13 to i8
  store i8 %conv14, ptr %lbafu, align 1
  %9 = load ptr, ptr %req.addr, align 8
  %call15 = call ptr @qemu_aio_get(ptr noundef @nvme_format_aiocb_info, ptr noundef null, ptr noundef @nvme_misc_cb, ptr noundef %9)
  store ptr %call15, ptr %iocb, align 8
  %10 = load ptr, ptr %req.addr, align 8
  %11 = load ptr, ptr %iocb, align 8
  %req16 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %11, i32 0, i32 2
  store ptr %10, ptr %req16, align 8
  %12 = load ptr, ptr %iocb, align 8
  %ret = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %12, i32 0, i32 3
  store i32 0, ptr %ret, align 8
  %13 = load ptr, ptr %iocb, align 8
  %ns = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %13, i32 0, i32 4
  store ptr null, ptr %ns, align 8
  %14 = load ptr, ptr %iocb, align 8
  %nsid17 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %14, i32 0, i32 5
  store i32 0, ptr %nsid17, align 8
  %15 = load i8, ptr %lbaf, align 1
  %16 = load ptr, ptr %iocb, align 8
  %lbaf18 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %16, i32 0, i32 8
  store i8 %15, ptr %lbaf18, align 8
  %17 = load i8, ptr %mset, align 1
  %18 = load ptr, ptr %iocb, align 8
  %mset19 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %18, i32 0, i32 9
  store i8 %17, ptr %mset19, align 1
  %19 = load i8, ptr %pi, align 1
  %20 = load ptr, ptr %iocb, align 8
  %pi20 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %20, i32 0, i32 10
  store i8 %19, ptr %pi20, align 2
  %21 = load i8, ptr %pil, align 1
  %22 = load ptr, ptr %iocb, align 8
  %pil21 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %22, i32 0, i32 11
  store i8 %21, ptr %pil21, align 1
  %23 = load i32, ptr %nsid, align 4
  %cmp = icmp eq i32 %23, -1
  %24 = load ptr, ptr %iocb, align 8
  %broadcast = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %24, i32 0, i32 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, ptr %broadcast, align 4
  %25 = load ptr, ptr %iocb, align 8
  %offset = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %25, i32 0, i32 7
  store i64 0, ptr %offset, align 8
  %26 = load ptr, ptr %n.addr, align 8
  %features = getelementptr inbounds %struct.NvmeCtrl, ptr %26, i32 0, i32 41
  %hbs = getelementptr inbounds %struct.anon.28, ptr %features, i32 0, i32 2
  %lbafee = getelementptr inbounds %struct.NvmeHostBehaviorSupport, ptr %hbs, i32 0, i32 2
  %27 = load i8, ptr %lbafee, align 2
  %tobool = icmp ne i8 %27, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %28 = load i8, ptr %lbafu, align 1
  %conv23 = zext i8 %28 to i32
  %shl = shl i32 %conv23, 4
  %29 = load ptr, ptr %iocb, align 8
  %lbaf24 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %29, i32 0, i32 8
  %30 = load i8, ptr %lbaf24, align 8
  %conv25 = zext i8 %30 to i32
  %or = or i32 %conv25, %shl
  %conv26 = trunc i32 %or to i8
  store i8 %conv26, ptr %lbaf24, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %31 = load ptr, ptr %iocb, align 8
  %broadcast27 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %31, i32 0, i32 6
  %32 = load i8, ptr %broadcast27, align 4
  %tobool28 = trunc i8 %32 to i1
  br i1 %tobool28, label %if.end39, label %if.then29

if.then29:                                        ; preds = %if.end
  %33 = load ptr, ptr %n.addr, align 8
  %34 = load i32, ptr %nsid, align 4
  %call30 = call zeroext i1 @nvme_nsid_valid(ptr noundef %33, i32 noundef %34)
  br i1 %call30, label %if.end32, label %if.then31

if.then31:                                        ; preds = %if.then29
  store i16 16395, ptr %status, align 2
  br label %out

if.end32:                                         ; preds = %if.then29
  %35 = load ptr, ptr %n.addr, align 8
  %36 = load i32, ptr %nsid, align 4
  %call33 = call ptr @nvme_ns(ptr noundef %35, i32 noundef %36)
  %37 = load ptr, ptr %iocb, align 8
  %ns34 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %37, i32 0, i32 4
  store ptr %call33, ptr %ns34, align 8
  %38 = load ptr, ptr %iocb, align 8
  %ns35 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %38, i32 0, i32 4
  %39 = load ptr, ptr %ns35, align 8
  %tobool36 = icmp ne ptr %39, null
  br i1 %tobool36, label %if.end38, label %if.then37

if.then37:                                        ; preds = %if.end32
  store i16 16386, ptr %status, align 2
  br label %out

if.end38:                                         ; preds = %if.end32
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end
  %40 = load ptr, ptr %iocb, align 8
  %common = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %40, i32 0, i32 0
  %41 = load ptr, ptr %req.addr, align 8
  %aiocb = getelementptr inbounds %struct.NvmeRequest, ptr %41, i32 0, i32 2
  store ptr %common, ptr %aiocb, align 8
  %42 = load ptr, ptr %iocb, align 8
  call void @nvme_do_format(ptr noundef %42)
  store i16 -1, ptr %retval, align 2
  br label %return

out:                                              ; preds = %if.then37, %if.then31
  %43 = load ptr, ptr %iocb, align 8
  call void @qemu_aio_unref(ptr noundef %43)
  %44 = load i16, ptr %status, align 2
  store i16 %44, ptr %retval, align 2
  br label %return

return:                                           ; preds = %out, %if.end39
  %45 = load i16, ptr %retval, align 2
  ret i16 %45
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_directive_send(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  ret i16 16386
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_directive_receive(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %dw10 = alloca i32, align 4
  %dw11 = alloca i32, align 4
  %nsid = alloca i32, align 4
  %doper = alloca i8, align 1
  %dtype = alloca i8, align 1
  %numd = alloca i32, align 4
  %trans_len = alloca i32, align 4
  %id = alloca %struct.NvmeDirectiveIdentify, align 1
  %_a55 = alloca i64, align 8
  %_b56 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  %cdw10 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 7
  %1 = load i32, ptr %cdw10, align 8
  %call = call i32 @le32_to_cpu(i32 noundef %1)
  store i32 %call, ptr %dw10, align 4
  %2 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %2, i32 0, i32 6
  %cdw11 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd1, i32 0, i32 8
  %3 = load i32, ptr %cdw11, align 4
  %call2 = call i32 @le32_to_cpu(i32 noundef %3)
  store i32 %call2, ptr %dw11, align 4
  %4 = load ptr, ptr %req.addr, align 8
  %cmd3 = getelementptr inbounds %struct.NvmeRequest, ptr %4, i32 0, i32 6
  %nsid4 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd3, i32 0, i32 3
  %5 = load i32, ptr %nsid4, align 4
  %call5 = call i32 @le32_to_cpu(i32 noundef %5)
  store i32 %call5, ptr %nsid, align 4
  call void @llvm.memset.p0.i64(ptr align 1 %id, i8 0, i64 4096, i1 false)
  %6 = getelementptr inbounds %struct.NvmeDirectiveIdentify, ptr %id, i32 0, i32 0
  store i8 1, ptr %6, align 1
  %7 = getelementptr inbounds %struct.NvmeDirectiveIdentify, ptr %id, i32 0, i32 2
  store i8 1, ptr %7, align 1
  %8 = load i32, ptr %dw10, align 4
  %add = add i32 %8, 1
  store i32 %add, ptr %numd, align 4
  %9 = load i32, ptr %dw11, align 4
  %and = and i32 %9, 255
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %doper, align 1
  %10 = load i32, ptr %dw11, align 4
  %shr = lshr i32 %10, 8
  %and6 = and i32 %shr, 255
  %conv7 = trunc i32 %and6 to i8
  store i8 %conv7, ptr %dtype, align 1
  store i64 4096, ptr %_a55, align 8
  %11 = load i32, ptr %numd, align 4
  %shl = shl i32 %11, 2
  %conv8 = zext i32 %shl to i64
  store i64 %conv8, ptr %_b56, align 8
  %12 = load i64, ptr %_a55, align 8
  %13 = load i64, ptr %_b56, align 8
  %cmp = icmp ult i64 %12, %13
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %14 = load i64, ptr %_a55, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %15 = load i64, ptr %_b56, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %14, %cond.true ], [ %15, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %16 = load i64, ptr %tmp, align 8
  %conv10 = trunc i64 %16 to i32
  store i32 %conv10, ptr %trans_len, align 4
  %17 = load i32, ptr %nsid, align 4
  %cmp11 = icmp eq i32 %17, -1
  br i1 %cmp11, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %18 = load i8, ptr %dtype, align 1
  %conv13 = zext i8 %18 to i32
  %cmp14 = icmp ne i32 %conv13, 0
  br i1 %cmp14, label %if.then, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %lor.lhs.false
  %19 = load i8, ptr %doper, align 1
  %conv17 = zext i8 %19 to i32
  %cmp18 = icmp ne i32 %conv17, 1
  br i1 %cmp18, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false16, %lor.lhs.false, %cond.end
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %lor.lhs.false16
  %20 = load ptr, ptr %n.addr, align 8
  %21 = load i32, ptr %nsid, align 4
  %call20 = call ptr @nvme_ns(ptr noundef %20, i32 noundef %21)
  store ptr %call20, ptr %ns, align 8
  %22 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %22, null
  br i1 %tobool, label %if.end22, label %if.then21

if.then21:                                        ; preds = %if.end
  store i16 16386, ptr %retval, align 2
  br label %return

if.end22:                                         ; preds = %if.end
  %23 = load i8, ptr %dtype, align 1
  %conv23 = zext i8 %23 to i32
  switch i32 %conv23, label %sw.default42 [
    i32 0, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.end22
  %24 = load i8, ptr %doper, align 1
  %conv24 = zext i8 %24 to i32
  switch i32 %conv24, label %sw.default [
    i32 1, label %sw.bb25
  ]

sw.bb25:                                          ; preds = %sw.bb
  %25 = load ptr, ptr %ns, align 8
  %endgrp = getelementptr inbounds %struct.NvmeNamespace, ptr %25, i32 0, i32 32
  %26 = load ptr, ptr %endgrp, align 8
  %tobool26 = icmp ne ptr %26, null
  br i1 %tobool26, label %land.lhs.true, label %if.end40

land.lhs.true:                                    ; preds = %sw.bb25
  %27 = load ptr, ptr %ns, align 8
  %endgrp27 = getelementptr inbounds %struct.NvmeNamespace, ptr %27, i32 0, i32 32
  %28 = load ptr, ptr %endgrp27, align 8
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %28, i32 0, i32 1
  %enabled = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 9
  %29 = load i8, ptr %enabled, align 8
  %tobool28 = trunc i8 %29 to i1
  br i1 %tobool28, label %if.then30, label %if.end40

if.then30:                                        ; preds = %land.lhs.true
  %supported = getelementptr inbounds %struct.NvmeDirectiveIdentify, ptr %id, i32 0, i32 0
  %30 = load i8, ptr %supported, align 1
  %conv31 = zext i8 %30 to i32
  %or = or i32 %conv31, 4
  %conv32 = trunc i32 %or to i8
  store i8 %conv32, ptr %supported, align 1
  %enabled33 = getelementptr inbounds %struct.NvmeDirectiveIdentify, ptr %id, i32 0, i32 2
  %31 = load i8, ptr %enabled33, align 1
  %conv34 = zext i8 %31 to i32
  %or35 = or i32 %conv34, 4
  %conv36 = trunc i32 %or35 to i8
  store i8 %conv36, ptr %enabled33, align 1
  %persistent = getelementptr inbounds %struct.NvmeDirectiveIdentify, ptr %id, i32 0, i32 4
  %32 = load i8, ptr %persistent, align 1
  %conv37 = zext i8 %32 to i32
  %or38 = or i32 %conv37, 4
  %conv39 = trunc i32 %or38 to i8
  store i8 %conv39, ptr %persistent, align 1
  br label %if.end40

if.end40:                                         ; preds = %if.then30, %land.lhs.true, %sw.bb25
  %33 = load ptr, ptr %n.addr, align 8
  %34 = load i32, ptr %trans_len, align 4
  %35 = load ptr, ptr %req.addr, align 8
  %call41 = call zeroext i16 @nvme_c2h(ptr noundef %33, ptr noundef %id, i32 noundef %34, ptr noundef %35)
  store i16 %call41, ptr %retval, align 2
  br label %return

sw.default:                                       ; preds = %sw.bb
  store i16 16386, ptr %retval, align 2
  br label %return

sw.default42:                                     ; preds = %if.end22
  store i16 2, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.default42, %sw.default, %if.end40, %if.then21, %if.then
  %36 = load i16, ptr %retval, align 2
  ret i16 %36
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_admin_cmd(i16 noundef zeroext %cid, i16 noundef zeroext %sqid, i8 noundef zeroext %opcode, ptr noundef %opname) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %sqid.addr = alloca i16, align 2
  %opcode.addr = alloca i8, align 1
  %opname.addr = alloca ptr, align 8
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i16 %sqid, ptr %sqid.addr, align 2
  store i8 %opcode, ptr %opcode.addr, align 1
  store ptr %opname, ptr %opname.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ADMIN_CMD_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end17

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end17

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i16, ptr %sqid.addr, align 2
  %conv12 = zext i16 %6 to i32
  %7 = load i8, ptr %opcode.addr, align 1
  %conv13 = zext i8 %7 to i32
  %8 = load ptr, ptr %opname.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.290, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12, i32 noundef %conv13, ptr noundef %8)
  br label %if.end

if.else:                                          ; preds = %if.then
  %9 = load i16, ptr %cid.addr, align 2
  %conv14 = zext i16 %9 to i32
  %10 = load i16, ptr %sqid.addr, align 2
  %conv15 = zext i16 %10 to i32
  %11 = load i8, ptr %opcode.addr, align 1
  %conv16 = zext i8 %11 to i32
  %12 = load ptr, ptr %opname.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.291, i32 noundef %conv14, i32 noundef %conv15, i32 noundef %conv16, ptr noundef %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end17

if.end17:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_admin_opc(i8 noundef zeroext %opc) #0 {
entry:
  %opc.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %opc, ptr %opc.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %opc.addr, align 1
  %conv11 = zext i8 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.310, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i8, ptr %opc.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.311, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_check_sqid(ptr noundef %n, i16 noundef zeroext %sqid) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %sqid.addr = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store i16 %sqid, ptr %sqid.addr, align 2
  %0 = load i16, ptr %sqid.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 21
  %2 = load i32, ptr %conf_ioqpairs, align 8
  %add = add i32 %2, 1
  %cmp = icmp ult i32 %conv, %add
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %sq = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 36
  %4 = load ptr, ptr %sq, align 16
  %5 = load i16, ptr %sqid.addr, align 2
  %idxprom = zext i16 %5 to i64
  %arrayidx = getelementptr ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  %cmp2 = icmp ne ptr %6, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %7 = phi i1 [ false, %entry ], [ %cmp2, %land.rhs ]
  %cond = select i1 %7, i32 0, i32 -1
  ret i32 %cond
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_del_sq(i16 noundef zeroext %qid) #0 {
entry:
  %qid.addr = alloca i16, align 2
  store i16 %qid, ptr %qid.addr, align 2
  %0 = load i16, ptr %qid.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_del_sq(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_del_sq(i16 noundef zeroext %qid) #0 {
entry:
  %qid.addr = alloca i16, align 2
  store i16 %qid, ptr %qid.addr, align 2
  %0 = load i16, ptr %qid.addr, align 2
  call void @_nocheck__trace_pci_nvme_del_sq(i16 noundef zeroext %0)
  ret void
}

declare void @blk_aio_cancel(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_check_cqid(ptr noundef %n, i16 noundef zeroext %cqid) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %cqid.addr = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store i16 %cqid, ptr %cqid.addr, align 2
  %0 = load i16, ptr %cqid.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 21
  %2 = load i32, ptr %conf_ioqpairs, align 8
  %add = add i32 %2, 1
  %cmp = icmp ult i32 %conv, %add
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %cq = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 37
  %4 = load ptr, ptr %cq, align 8
  %5 = load i16, ptr %cqid.addr, align 2
  %idxprom = zext i16 %5 to i64
  %arrayidx = getelementptr ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  %cmp2 = icmp ne ptr %6, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %7 = phi i1 [ false, %entry ], [ %cmp2, %land.rhs ]
  %cond = select i1 %7, i32 0, i32 -1
  ret i32 %cond
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_free_sq(ptr noundef %sq, ptr noundef %n) #0 {
entry:
  %sq.addr = alloca ptr, align 8
  %n.addr = alloca ptr, align 8
  %offset = alloca i16, align 2
  store ptr %sq, ptr %sq.addr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %sq.addr, align 8
  %sqid = getelementptr inbounds %struct.NvmeSQueue, ptr %0, i32 0, i32 1
  %1 = load i16, ptr %sqid, align 8
  %conv = zext i16 %1 to i32
  %shl = shl i32 %conv, 3
  %conv1 = trunc i32 %shl to i16
  store i16 %conv1, ptr %offset, align 2
  %2 = load ptr, ptr %n.addr, align 8
  %sq2 = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 36
  %3 = load ptr, ptr %sq2, align 16
  %4 = load ptr, ptr %sq.addr, align 8
  %sqid3 = getelementptr inbounds %struct.NvmeSQueue, ptr %4, i32 0, i32 1
  %5 = load i16, ptr %sqid3, align 8
  %idxprom = zext i16 %5 to i64
  %arrayidx = getelementptr ptr, ptr %3, i64 %idxprom
  store ptr null, ptr %arrayidx, align 8
  %6 = load ptr, ptr %sq.addr, align 8
  %bh = getelementptr inbounds %struct.NvmeSQueue, ptr %6, i32 0, i32 9
  %7 = load ptr, ptr %bh, align 8
  call void @qemu_bh_delete(ptr noundef %7)
  %8 = load ptr, ptr %sq.addr, align 8
  %ioeventfd_enabled = getelementptr inbounds %struct.NvmeSQueue, ptr %8, i32 0, i32 11
  %9 = load i8, ptr %ioeventfd_enabled, align 4
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load ptr, ptr %n.addr, align 8
  %iomem = getelementptr inbounds %struct.NvmeCtrl, ptr %10, i32 0, i32 2
  %11 = load i16, ptr %offset, align 2
  %conv4 = zext i16 %11 to i32
  %add = add i32 4096, %conv4
  %conv5 = sext i32 %add to i64
  %12 = load ptr, ptr %sq.addr, align 8
  %notifier = getelementptr inbounds %struct.NvmeSQueue, ptr %12, i32 0, i32 10
  call void @memory_region_del_eventfd(ptr noundef %iomem, i64 noundef %conv5, i32 noundef 4, i1 noundef zeroext false, i64 noundef 0, ptr noundef %notifier)
  %13 = load ptr, ptr %sq.addr, align 8
  %notifier6 = getelementptr inbounds %struct.NvmeSQueue, ptr %13, i32 0, i32 10
  call void @event_notifier_set_handler(ptr noundef %notifier6, ptr noundef null)
  %14 = load ptr, ptr %sq.addr, align 8
  %notifier7 = getelementptr inbounds %struct.NvmeSQueue, ptr %14, i32 0, i32 10
  call void @event_notifier_cleanup(ptr noundef %notifier7)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %15 = load ptr, ptr %sq.addr, align 8
  %io_req = getelementptr inbounds %struct.NvmeSQueue, ptr %15, i32 0, i32 12
  %16 = load ptr, ptr %io_req, align 8
  call void @g_free(ptr noundef %16)
  %17 = load ptr, ptr %sq.addr, align 8
  %sqid8 = getelementptr inbounds %struct.NvmeSQueue, ptr %17, i32 0, i32 1
  %18 = load i16, ptr %sqid8, align 8
  %tobool9 = icmp ne i16 %18, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  %19 = load ptr, ptr %sq.addr, align 8
  call void @g_free(ptr noundef %19)
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_del_sq(i16 noundef zeroext %qid) #0 {
entry:
  %qid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %qid, ptr %qid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_DEL_SQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %qid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.314, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %qid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.315, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_del_sq(i16 noundef zeroext %qid) #0 {
entry:
  %qid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %qid, ptr %qid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_DEL_SQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %qid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.316, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %qid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.317, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

declare void @qemu_bh_delete(ptr noundef) #1

declare void @memory_region_del_eventfd(ptr noundef, i64 noundef, i32 noundef, i1 noundef zeroext, i64 noundef, ptr noundef) #1

declare void @event_notifier_cleanup(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_create_sq(i64 noundef %addr, i16 noundef zeroext %sqid, i16 noundef zeroext %cqid, i16 noundef zeroext %qsize, i16 noundef zeroext %qflags) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %sqid.addr = alloca i16, align 2
  %cqid.addr = alloca i16, align 2
  %qsize.addr = alloca i16, align 2
  %qflags.addr = alloca i16, align 2
  store i64 %addr, ptr %addr.addr, align 8
  store i16 %sqid, ptr %sqid.addr, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  store i16 %qsize, ptr %qsize.addr, align 2
  store i16 %qflags, ptr %qflags.addr, align 2
  %0 = load i64, ptr %addr.addr, align 8
  %1 = load i16, ptr %sqid.addr, align 2
  %2 = load i16, ptr %cqid.addr, align 2
  %3 = load i16, ptr %qsize.addr, align 2
  %4 = load i16, ptr %qflags.addr, align 2
  call void @_nocheck__trace_pci_nvme_create_sq(i64 noundef %0, i16 noundef zeroext %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i16 noundef zeroext %4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_create_sq_cqid(i16 noundef zeroext %cqid) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  %0 = load i16, ptr %cqid.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_create_sq_cqid(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_create_sq_sqid(i16 noundef zeroext %sqid) #0 {
entry:
  %sqid.addr = alloca i16, align 2
  store i16 %sqid, ptr %sqid.addr, align 2
  %0 = load i16, ptr %sqid.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_create_sq_sqid(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_create_sq_size(i16 noundef zeroext %qsize) #0 {
entry:
  %qsize.addr = alloca i16, align 2
  store i16 %qsize, ptr %qsize.addr, align 2
  %0 = load i16, ptr %qsize.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_create_sq_size(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_create_sq_addr(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i64, ptr %addr.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_invalid_create_sq_addr(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_create_sq_qflags(i16 noundef zeroext %qflags) #0 {
entry:
  %qflags.addr = alloca i16, align 2
  store i16 %qflags, ptr %qflags.addr, align 2
  %0 = load i16, ptr %qflags.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_create_sq_qflags(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_create_sq(i64 noundef %addr, i16 noundef zeroext %sqid, i16 noundef zeroext %cqid, i16 noundef zeroext %qsize, i16 noundef zeroext %qflags) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %sqid.addr = alloca i16, align 2
  %cqid.addr = alloca i16, align 2
  %qsize.addr = alloca i16, align 2
  %qflags.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i16 %sqid, ptr %sqid.addr, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  store i16 %qsize, ptr %qsize.addr, align 2
  store i16 %qflags, ptr %qflags.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_CREATE_SQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end19

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  %6 = load i16, ptr %sqid.addr, align 2
  %conv11 = zext i16 %6 to i32
  %7 = load i16, ptr %cqid.addr, align 2
  %conv12 = zext i16 %7 to i32
  %8 = load i16, ptr %qsize.addr, align 2
  %conv13 = zext i16 %8 to i32
  %9 = load i16, ptr %qflags.addr, align 2
  %conv14 = zext i16 %9 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.318, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %conv11, i32 noundef %conv12, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.else:                                          ; preds = %if.then
  %10 = load i64, ptr %addr.addr, align 8
  %11 = load i16, ptr %sqid.addr, align 2
  %conv15 = zext i16 %11 to i32
  %12 = load i16, ptr %cqid.addr, align 2
  %conv16 = zext i16 %12 to i32
  %13 = load i16, ptr %qsize.addr, align 2
  %conv17 = zext i16 %13 to i32
  %14 = load i16, ptr %qflags.addr, align 2
  %conv18 = zext i16 %14 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.319, i64 noundef %10, i32 noundef %conv15, i32 noundef %conv16, i32 noundef %conv17, i32 noundef %conv18)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end19

if.end19:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_create_sq_cqid(i16 noundef zeroext %cqid) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cqid, ptr %cqid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cqid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.320, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %cqid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.321, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_create_sq_sqid(i16 noundef zeroext %sqid) #0 {
entry:
  %sqid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %sqid, ptr %sqid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %sqid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.322, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %sqid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.323, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_create_sq_size(i16 noundef zeroext %qsize) #0 {
entry:
  %qsize.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %qsize, ptr %qsize.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %qsize.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.324, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %qsize.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.325, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_create_sq_addr(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.326, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.327, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_create_sq_qflags(i16 noundef zeroext %qflags) #0 {
entry:
  %qflags.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %qflags, ptr %qflags.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %qflags.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.328, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %qflags.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.329, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_get_log(i16 noundef zeroext %cid, i8 noundef zeroext %lid, i8 noundef zeroext %lsp, i8 noundef zeroext %rae, i32 noundef %len, i64 noundef %off) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %lid.addr = alloca i8, align 1
  %lsp.addr = alloca i8, align 1
  %rae.addr = alloca i8, align 1
  %len.addr = alloca i32, align 4
  %off.addr = alloca i64, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i8 %lid, ptr %lid.addr, align 1
  store i8 %lsp, ptr %lsp.addr, align 1
  store i8 %rae, ptr %rae.addr, align 1
  store i32 %len, ptr %len.addr, align 4
  store i64 %off, ptr %off.addr, align 8
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i8, ptr %lid.addr, align 1
  %2 = load i8, ptr %lsp.addr, align 1
  %3 = load i8, ptr %rae.addr, align 1
  %4 = load i32, ptr %len.addr, align 4
  %5 = load i64, ptr %off.addr, align 8
  call void @_nocheck__trace_pci_nvme_get_log(i16 noundef zeroext %0, i8 noundef zeroext %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i32 noundef %4, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_error_info(ptr noundef %n, i8 noundef zeroext %rae, i32 noundef %buf_len, i64 noundef %off, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %rae.addr = alloca i8, align 1
  %buf_len.addr = alloca i32, align 4
  %off.addr = alloca i64, align 8
  %req.addr = alloca ptr, align 8
  %trans_len = alloca i32, align 4
  %errlog = alloca %struct.NvmeErrorLog, align 1
  %_a33 = alloca i64, align 8
  %_b34 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i8 %rae, ptr %rae.addr, align 1
  store i32 %buf_len, ptr %buf_len.addr, align 4
  store i64 %off, ptr %off.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load i64, ptr %off.addr, align 8
  %cmp = icmp uge i64 %0, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8, ptr %rae.addr, align 1
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  %2 = load ptr, ptr %n.addr, align 8
  call void @nvme_clear_events(ptr noundef %2, i8 noundef zeroext 0)
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  call void @llvm.memset.p0.i64(ptr align 1 %errlog, i8 0, i64 64, i1 false)
  %3 = load i64, ptr %off.addr, align 8
  %sub = sub i64 64, %3
  store i64 %sub, ptr %_a33, align 8
  %4 = load i32, ptr %buf_len.addr, align 4
  %conv = zext i32 %4 to i64
  store i64 %conv, ptr %_b34, align 8
  %5 = load i64, ptr %_a33, align 8
  %6 = load i64, ptr %_b34, align 8
  %cmp3 = icmp ult i64 %5, %6
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end2
  %7 = load i64, ptr %_a33, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end2
  %8 = load i64, ptr %_b34, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %7, %cond.true ], [ %8, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %9 = load i64, ptr %tmp, align 8
  %conv5 = trunc i64 %9 to i32
  store i32 %conv5, ptr %trans_len, align 4
  %10 = load ptr, ptr %n.addr, align 8
  %11 = load i32, ptr %trans_len, align 4
  %12 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_c2h(ptr noundef %10, ptr noundef %errlog, i32 noundef %11, ptr noundef %12)
  store i16 %call, ptr %retval, align 2
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %13 = load i16, ptr %retval, align 2
  ret i16 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_smart_info(ptr noundef %n, i8 noundef zeroext %rae, i32 noundef %buf_len, i64 noundef %off, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %rae.addr = alloca i8, align 1
  %buf_len.addr = alloca i32, align 4
  %off.addr = alloca i64, align 8
  %req.addr = alloca ptr, align 8
  %nsid = alloca i32, align 4
  %stats = alloca %struct.nvme_stats, align 8
  %smart = alloca %struct.NvmeSmartLog, align 1
  %trans_len = alloca i32, align 4
  %ns = alloca ptr, align 8
  %current_ms = alloca i64, align 8
  %u_read = alloca i64, align 8
  %u_written = alloca i64, align 8
  %i = alloca i32, align 4
  %_a27 = alloca i64, align 8
  %_b28 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i8 %rae, ptr %rae.addr, align 1
  store i32 %buf_len, ptr %buf_len.addr, align 4
  store i64 %off, ptr %off.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  %nsid1 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 3
  %1 = load i32, ptr %nsid1, align 4
  %call = call i32 @le32_to_cpu(i32 noundef %1)
  store i32 %call, ptr %nsid, align 4
  call void @llvm.memset.p0.i64(ptr align 8 %stats, i8 0, i64 32, i1 false)
  call void @llvm.memset.p0.i64(ptr align 1 %smart, i8 0, i64 512, i1 false)
  %2 = load i64, ptr %off.addr, align 8
  %cmp = icmp uge i64 %2, 512
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %nsid, align 4
  %cmp2 = icmp ne i32 %3, -1
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %4 = load ptr, ptr %n.addr, align 8
  %5 = load i32, ptr %nsid, align 4
  %call4 = call ptr @nvme_ns(ptr noundef %4, i32 noundef %5)
  store ptr %call4, ptr %ns, align 8
  %6 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.then3
  store i16 16395, ptr %retval, align 2
  br label %return

if.end6:                                          ; preds = %if.then3
  %7 = load ptr, ptr %ns, align 8
  call void @nvme_set_blk_stats(ptr noundef %7, ptr noundef %stats)
  br label %if.end12

if.else:                                          ; preds = %if.end
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %8 = load i32, ptr %i, align 4
  %cmp7 = icmp sle i32 %8, 256
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %n.addr, align 8
  %10 = load i32, ptr %i, align 4
  %call8 = call ptr @nvme_ns(ptr noundef %9, i32 noundef %10)
  store ptr %call8, ptr %ns, align 8
  %11 = load ptr, ptr %ns, align 8
  %tobool9 = icmp ne ptr %11, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %for.body
  br label %for.inc

if.end11:                                         ; preds = %for.body
  %12 = load ptr, ptr %ns, align 8
  call void @nvme_set_blk_stats(ptr noundef %12, ptr noundef %stats)
  br label %for.inc

for.inc:                                          ; preds = %if.end11, %if.then10
  %13 = load i32, ptr %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !52

for.end:                                          ; preds = %for.cond
  br label %if.end12

if.end12:                                         ; preds = %for.end, %if.end6
  %14 = load i64, ptr %off.addr, align 8
  %sub = sub i64 512, %14
  store i64 %sub, ptr %_a27, align 8
  %15 = load i32, ptr %buf_len.addr, align 4
  %conv = zext i32 %15 to i64
  store i64 %conv, ptr %_b28, align 8
  %16 = load i64, ptr %_a27, align 8
  %17 = load i64, ptr %_b28, align 8
  %cmp13 = icmp ult i64 %16, %17
  br i1 %cmp13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end12
  %18 = load i64, ptr %_a27, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end12
  %19 = load i64, ptr %_b28, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %18, %cond.true ], [ %19, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %20 = load i64, ptr %tmp, align 8
  %conv15 = trunc i64 %20 to i32
  store i32 %conv15, ptr %trans_len, align 4
  %21 = load ptr, ptr %n.addr, align 8
  %smart_critical_warning = getelementptr inbounds %struct.NvmeCtrl, ptr %21, i32 0, i32 19
  %22 = load i8, ptr %smart_critical_warning, align 2
  %critical_warning = getelementptr inbounds %struct.NvmeSmartLog, ptr %smart, i32 0, i32 0
  store i8 %22, ptr %critical_warning, align 1
  %units_read = getelementptr inbounds %struct.nvme_stats, ptr %stats, i32 0, i32 0
  %23 = load i64, ptr %units_read, align 8
  %shr = lshr i64 %23, 9
  %add = add i64 %shr, 1000
  %sub16 = sub i64 %add, 1
  %div = udiv i64 %sub16, 1000
  store i64 %div, ptr %u_read, align 8
  %units_written = getelementptr inbounds %struct.nvme_stats, ptr %stats, i32 0, i32 1
  %24 = load i64, ptr %units_written, align 8
  %shr17 = lshr i64 %24, 9
  %add18 = add i64 %shr17, 1000
  %sub19 = sub i64 %add18, 1
  %div20 = udiv i64 %sub19, 1000
  store i64 %div20, ptr %u_written, align 8
  %25 = load i64, ptr %u_read, align 8
  %call21 = call i64 @cpu_to_le64(i64 noundef %25)
  %data_units_read = getelementptr inbounds %struct.NvmeSmartLog, ptr %smart, i32 0, i32 6
  %arrayidx = getelementptr [2 x i64], ptr %data_units_read, i64 0, i64 0
  store i64 %call21, ptr %arrayidx, align 1
  %26 = load i64, ptr %u_written, align 8
  %call22 = call i64 @cpu_to_le64(i64 noundef %26)
  %data_units_written = getelementptr inbounds %struct.NvmeSmartLog, ptr %smart, i32 0, i32 7
  %arrayidx23 = getelementptr [2 x i64], ptr %data_units_written, i64 0, i64 0
  store i64 %call22, ptr %arrayidx23, align 1
  %read_commands = getelementptr inbounds %struct.nvme_stats, ptr %stats, i32 0, i32 2
  %27 = load i64, ptr %read_commands, align 8
  %call24 = call i64 @cpu_to_le64(i64 noundef %27)
  %host_read_commands = getelementptr inbounds %struct.NvmeSmartLog, ptr %smart, i32 0, i32 8
  %arrayidx25 = getelementptr [2 x i64], ptr %host_read_commands, i64 0, i64 0
  store i64 %call24, ptr %arrayidx25, align 1
  %write_commands = getelementptr inbounds %struct.nvme_stats, ptr %stats, i32 0, i32 3
  %28 = load i64, ptr %write_commands, align 8
  %call26 = call i64 @cpu_to_le64(i64 noundef %28)
  %host_write_commands = getelementptr inbounds %struct.NvmeSmartLog, ptr %smart, i32 0, i32 9
  %arrayidx27 = getelementptr [2 x i64], ptr %host_write_commands, i64 0, i64 0
  store i64 %call26, ptr %arrayidx27, align 1
  %29 = load ptr, ptr %n.addr, align 8
  %temperature = getelementptr inbounds %struct.NvmeCtrl, ptr %29, i32 0, i32 18
  %30 = load i16, ptr %temperature, align 16
  %call28 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %30)
  %temperature29 = getelementptr inbounds %struct.NvmeSmartLog, ptr %smart, i32 0, i32 1
  store i16 %call28, ptr %temperature29, align 1
  %31 = load ptr, ptr %n.addr, align 8
  %temperature30 = getelementptr inbounds %struct.NvmeCtrl, ptr %31, i32 0, i32 18
  %32 = load i16, ptr %temperature30, align 16
  %conv31 = zext i16 %32 to i32
  %33 = load ptr, ptr %n.addr, align 8
  %features = getelementptr inbounds %struct.NvmeCtrl, ptr %33, i32 0, i32 41
  %34 = getelementptr inbounds %struct.anon.28, ptr %features, i32 0, i32 0
  %temp_thresh_hi = getelementptr inbounds %struct.anon.29, ptr %34, i32 0, i32 0
  %35 = load i16, ptr %temp_thresh_hi, align 16
  %conv32 = zext i16 %35 to i32
  %cmp33 = icmp sge i32 %conv31, %conv32
  br i1 %cmp33, label %if.then41, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %36 = load ptr, ptr %n.addr, align 8
  %temperature35 = getelementptr inbounds %struct.NvmeCtrl, ptr %36, i32 0, i32 18
  %37 = load i16, ptr %temperature35, align 16
  %conv36 = zext i16 %37 to i32
  %38 = load ptr, ptr %n.addr, align 8
  %features37 = getelementptr inbounds %struct.NvmeCtrl, ptr %38, i32 0, i32 41
  %39 = getelementptr inbounds %struct.anon.28, ptr %features37, i32 0, i32 0
  %temp_thresh_low = getelementptr inbounds %struct.anon.29, ptr %39, i32 0, i32 1
  %40 = load i16, ptr %temp_thresh_low, align 2
  %conv38 = zext i16 %40 to i32
  %cmp39 = icmp sle i32 %conv36, %conv38
  br i1 %cmp39, label %if.then41, label %if.end45

if.then41:                                        ; preds = %lor.lhs.false, %cond.end
  %critical_warning42 = getelementptr inbounds %struct.NvmeSmartLog, ptr %smart, i32 0, i32 0
  %41 = load i8, ptr %critical_warning42, align 1
  %conv43 = zext i8 %41 to i32
  %or = or i32 %conv43, 2
  %conv44 = trunc i32 %or to i8
  store i8 %conv44, ptr %critical_warning42, align 1
  br label %if.end45

if.end45:                                         ; preds = %if.then41, %lor.lhs.false
  %call46 = call i64 @qemu_clock_get_ms(i32 noundef 1)
  store i64 %call46, ptr %current_ms, align 8
  %42 = load i64, ptr %current_ms, align 8
  %43 = load ptr, ptr %n.addr, align 8
  %starttime_ms = getelementptr inbounds %struct.NvmeCtrl, ptr %43, i32 0, i32 17
  %44 = load i64, ptr %starttime_ms, align 8
  %sub47 = sub i64 %42, %44
  %div48 = udiv i64 %sub47, 1000
  %div49 = udiv i64 %div48, 60
  %div50 = udiv i64 %div49, 60
  %call51 = call i64 @cpu_to_le64(i64 noundef %div50)
  %power_on_hours = getelementptr inbounds %struct.NvmeSmartLog, ptr %smart, i32 0, i32 12
  %arrayidx52 = getelementptr [2 x i64], ptr %power_on_hours, i64 0, i64 0
  store i64 %call51, ptr %arrayidx52, align 1
  %45 = load i8, ptr %rae.addr, align 1
  %tobool53 = icmp ne i8 %45, 0
  br i1 %tobool53, label %if.end55, label %if.then54

if.then54:                                        ; preds = %if.end45
  %46 = load ptr, ptr %n.addr, align 8
  call void @nvme_clear_events(ptr noundef %46, i8 noundef zeroext 1)
  br label %if.end55

if.end55:                                         ; preds = %if.then54, %if.end45
  %47 = load ptr, ptr %n.addr, align 8
  %48 = load i64, ptr %off.addr, align 8
  %add.ptr = getelementptr i8, ptr %smart, i64 %48
  %49 = load i32, ptr %trans_len, align 4
  %50 = load ptr, ptr %req.addr, align 8
  %call56 = call zeroext i16 @nvme_c2h(ptr noundef %47, ptr noundef %add.ptr, i32 noundef %49, ptr noundef %50)
  store i16 %call56, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end55, %if.then5, %if.then
  %51 = load i16, ptr %retval, align 2
  ret i16 %51
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_fw_log_info(ptr noundef %n, i32 noundef %buf_len, i64 noundef %off, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %buf_len.addr = alloca i32, align 4
  %off.addr = alloca i64, align 8
  %req.addr = alloca ptr, align 8
  %trans_len = alloca i32, align 4
  %fw_log = alloca %struct.NvmeFwSlotInfoLog, align 1
  %_a31 = alloca i64, align 8
  %_b32 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i32 %buf_len, ptr %buf_len.addr, align 4
  store i64 %off, ptr %off.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %fw_log, i8 0, i64 512, i1 false)
  %0 = getelementptr inbounds %struct.NvmeFwSlotInfoLog, ptr %fw_log, i32 0, i32 0
  store i8 1, ptr %0, align 1
  %1 = load i64, ptr %off.addr, align 8
  %cmp = icmp uge i64 %1, 512
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %frs1 = getelementptr inbounds %struct.NvmeFwSlotInfoLog, ptr %fw_log, i32 0, i32 2
  call void @strpadcpy(ptr noundef %frs1, i32 noundef 8, ptr noundef @.str.332, i8 noundef signext 32)
  %2 = load i64, ptr %off.addr, align 8
  %sub = sub i64 512, %2
  store i64 %sub, ptr %_a31, align 8
  %3 = load i32, ptr %buf_len.addr, align 4
  %conv = zext i32 %3 to i64
  store i64 %conv, ptr %_b32, align 8
  %4 = load i64, ptr %_a31, align 8
  %5 = load i64, ptr %_b32, align 8
  %cmp1 = icmp ult i64 %4, %5
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %6 = load i64, ptr %_a31, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %7 = load i64, ptr %_b32, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %6, %cond.true ], [ %7, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %8 = load i64, ptr %tmp, align 8
  %conv3 = trunc i64 %8 to i32
  store i32 %conv3, ptr %trans_len, align 4
  %9 = load ptr, ptr %n.addr, align 8
  %10 = load i64, ptr %off.addr, align 8
  %add.ptr = getelementptr i8, ptr %fw_log, i64 %10
  %11 = load i32, ptr %trans_len, align 4
  %12 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_c2h(ptr noundef %9, ptr noundef %add.ptr, i32 noundef %11, ptr noundef %12)
  store i16 %call, ptr %retval, align 2
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %13 = load i16, ptr %retval, align 2
  ret i16 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_changed_nslist(ptr noundef %n, i8 noundef zeroext %rae, i32 noundef %buf_len, i64 noundef %off, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %rae.addr = alloca i8, align 1
  %buf_len.addr = alloca i32, align 4
  %off.addr = alloca i64, align 8
  %req.addr = alloca ptr, align 8
  %nslist = alloca [1024 x i32], align 16
  %trans_len = alloca i32, align 4
  %i = alloca i32, align 4
  %nsid = alloca i32, align 4
  %_a35 = alloca i64, align 8
  %_b36 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i8 %rae, ptr %rae.addr, align 1
  store i32 %buf_len, ptr %buf_len.addr, align 4
  store i64 %off, ptr %off.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  store i32 0, ptr %i, align 4
  %0 = load i64, ptr %off.addr, align 8
  %cmp = icmp uge i64 %0, 4096
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %off.addr, align 8
  call void @trace_pci_nvme_err_invalid_log_page_offset(i64 noundef %1, i64 noundef 4096)
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1024 x i32], ptr %nslist, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 16 %arraydecay, i8 0, i64 4096, i1 false)
  %2 = load i64, ptr %off.addr, align 8
  %sub = sub i64 4096, %2
  store i64 %sub, ptr %_a35, align 8
  %3 = load i32, ptr %buf_len.addr, align 4
  %conv = zext i32 %3 to i64
  store i64 %conv, ptr %_b36, align 8
  %4 = load i64, ptr %_a35, align 8
  %5 = load i64, ptr %_b36, align 8
  %cmp1 = icmp ult i64 %4, %5
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %6 = load i64, ptr %_a35, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %7 = load i64, ptr %_b36, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %6, %cond.true ], [ %7, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %8 = load i64, ptr %tmp, align 8
  %conv3 = trunc i64 %8 to i32
  store i32 %conv3, ptr %trans_len, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end13, %cond.end
  %9 = load ptr, ptr %n.addr, align 8
  %changed_nsids = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 32
  %arraydecay4 = getelementptr inbounds [5 x i64], ptr %changed_nsids, i64 0, i64 0
  %call = call i64 @find_first_bit(ptr noundef %arraydecay4, i64 noundef 257)
  %conv5 = trunc i64 %call to i32
  store i32 %conv5, ptr %nsid, align 4
  %cmp6 = icmp ne i32 %conv5, 257
  br i1 %cmp6, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load i32, ptr %i, align 4
  %conv8 = sext i32 %10 to i64
  %cmp9 = icmp eq i64 %conv8, 1024
  br i1 %cmp9, label %if.then11, label %if.end13

if.then11:                                        ; preds = %while.body
  %arraydecay12 = getelementptr inbounds [1024 x i32], ptr %nslist, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 16 %arraydecay12, i8 0, i64 4096, i1 false)
  %arrayidx = getelementptr [1024 x i32], ptr %nslist, i64 0, i64 0
  store i32 -1, ptr %arrayidx, align 16
  br label %while.end

if.end13:                                         ; preds = %while.body
  %11 = load i32, ptr %nsid, align 4
  %12 = load i32, ptr %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, ptr %i, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx14 = getelementptr [1024 x i32], ptr %nslist, i64 0, i64 %idxprom
  store i32 %11, ptr %arrayidx14, align 4
  %13 = load i32, ptr %nsid, align 4
  %conv15 = zext i32 %13 to i64
  %14 = load ptr, ptr %n.addr, align 8
  %changed_nsids16 = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 32
  %arraydecay17 = getelementptr inbounds [5 x i64], ptr %changed_nsids16, i64 0, i64 0
  call void @clear_bit(i64 noundef %conv15, ptr noundef %arraydecay17)
  br label %while.cond, !llvm.loop !53

while.end:                                        ; preds = %if.then11, %while.cond
  %arrayidx18 = getelementptr [1024 x i32], ptr %nslist, i64 0, i64 0
  %15 = load i32, ptr %arrayidx18, align 16
  %cmp19 = icmp eq i32 %15, -1
  br i1 %cmp19, label %if.then21, label %if.end24

if.then21:                                        ; preds = %while.end
  %16 = load ptr, ptr %n.addr, align 8
  %changed_nsids22 = getelementptr inbounds %struct.NvmeCtrl, ptr %16, i32 0, i32 32
  %arraydecay23 = getelementptr inbounds [5 x i64], ptr %changed_nsids22, i64 0, i64 0
  call void @bitmap_zero(ptr noundef %arraydecay23, i64 noundef 257)
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %while.end
  %17 = load i8, ptr %rae.addr, align 1
  %tobool = icmp ne i8 %17, 0
  br i1 %tobool, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end24
  %18 = load ptr, ptr %n.addr, align 8
  call void @nvme_clear_events(ptr noundef %18, i8 noundef zeroext 2)
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %if.end24
  %19 = load ptr, ptr %n.addr, align 8
  %arraydecay27 = getelementptr inbounds [1024 x i32], ptr %nslist, i64 0, i64 0
  %20 = load i64, ptr %off.addr, align 8
  %add.ptr = getelementptr i8, ptr %arraydecay27, i64 %20
  %21 = load i32, ptr %trans_len, align 4
  %22 = load ptr, ptr %req.addr, align 8
  %call28 = call zeroext i16 @nvme_c2h(ptr noundef %19, ptr noundef %add.ptr, i32 noundef %21, ptr noundef %22)
  store i16 %call28, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end26, %if.then
  %23 = load i16, ptr %retval, align 2
  ret i16 %23
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_cmd_effects(ptr noundef %n, i8 noundef zeroext %csi, i32 noundef %buf_len, i64 noundef %off, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %csi.addr = alloca i8, align 1
  %buf_len.addr = alloca i32, align 4
  %off.addr = alloca i64, align 8
  %req.addr = alloca ptr, align 8
  %log = alloca %struct.NvmeEffectsLog, align 4
  %src_iocs = alloca ptr, align 8
  %trans_len = alloca i32, align 4
  %_a37 = alloca i64, align 8
  %_b38 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i8 %csi, ptr %csi.addr, align 1
  store i32 %buf_len, ptr %buf_len.addr, align 4
  store i64 %off, ptr %off.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 4 %log, i8 0, i64 4096, i1 false)
  store ptr null, ptr %src_iocs, align 8
  %0 = load i64, ptr %off.addr, align 8
  %cmp = icmp uge i64 %0, 4096
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %off.addr, align 8
  call void @trace_pci_nvme_err_invalid_log_page_offset(i64 noundef %1, i64 noundef 4096)
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 3
  %cc = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 4
  %call = call i32 @ldl_le_p(ptr noundef %cc)
  %shr = ashr i32 %call, 4
  %and = and i32 %shr, 7
  switch i32 %and, label %sw.epilog5 [
    i32 0, label %sw.bb
    i32 7, label %sw.bb1
    i32 6, label %sw.bb2
  ]

sw.bb:                                            ; preds = %if.end
  store ptr @nvme_cse_iocs_nvm, ptr %src_iocs, align 8
  br label %sw.bb1

sw.bb1:                                           ; preds = %sw.bb, %if.end
  br label %sw.epilog5

sw.bb2:                                           ; preds = %if.end
  %3 = load i8, ptr %csi.addr, align 1
  %conv = zext i8 %3 to i32
  switch i32 %conv, label %sw.epilog [
    i32 0, label %sw.bb3
    i32 2, label %sw.bb4
  ]

sw.bb3:                                           ; preds = %sw.bb2
  store ptr @nvme_cse_iocs_nvm, ptr %src_iocs, align 8
  br label %sw.epilog

sw.bb4:                                           ; preds = %sw.bb2
  store ptr @nvme_cse_iocs_zoned, ptr %src_iocs, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb4, %sw.bb3, %sw.bb2
  br label %sw.epilog5

sw.epilog5:                                       ; preds = %sw.epilog, %sw.bb1, %if.end
  %acs = getelementptr inbounds %struct.NvmeEffectsLog, ptr %log, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i32], ptr %acs, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arraydecay, ptr align 16 @nvme_cse_acs, i64 1024, i1 false)
  %4 = load ptr, ptr %src_iocs, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.then6, label %if.end8

if.then6:                                         ; preds = %sw.epilog5
  %iocs = getelementptr inbounds %struct.NvmeEffectsLog, ptr %log, i32 0, i32 1
  %arraydecay7 = getelementptr inbounds [256 x i32], ptr %iocs, i64 0, i64 0
  %5 = load ptr, ptr %src_iocs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arraydecay7, ptr align 4 %5, i64 1024, i1 false)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %sw.epilog5
  %6 = load i64, ptr %off.addr, align 8
  %sub = sub i64 4096, %6
  store i64 %sub, ptr %_a37, align 8
  %7 = load i32, ptr %buf_len.addr, align 4
  %conv9 = zext i32 %7 to i64
  store i64 %conv9, ptr %_b38, align 8
  %8 = load i64, ptr %_a37, align 8
  %9 = load i64, ptr %_b38, align 8
  %cmp10 = icmp ult i64 %8, %9
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end8
  %10 = load i64, ptr %_a37, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end8
  %11 = load i64, ptr %_b38, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %10, %cond.true ], [ %11, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %12 = load i64, ptr %tmp, align 8
  %conv12 = trunc i64 %12 to i32
  store i32 %conv12, ptr %trans_len, align 4
  %13 = load ptr, ptr %n.addr, align 8
  %14 = load i64, ptr %off.addr, align 8
  %add.ptr = getelementptr i8, ptr %log, i64 %14
  %15 = load i32, ptr %trans_len, align 4
  %16 = load ptr, ptr %req.addr, align 8
  %call13 = call zeroext i16 @nvme_c2h(ptr noundef %13, ptr noundef %add.ptr, i32 noundef %15, ptr noundef %16)
  store i16 %call13, ptr %retval, align 2
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %17 = load i16, ptr %retval, align 2
  ret i16 %17
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_endgrp_info(ptr noundef %n, i8 noundef zeroext %rae, i32 noundef %buf_len, i64 noundef %off, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %rae.addr = alloca i8, align 1
  %buf_len.addr = alloca i32, align 4
  %off.addr = alloca i64, align 8
  %req.addr = alloca ptr, align 8
  %dw11 = alloca i32, align 4
  %endgrpid = alloca i16, align 2
  %stats = alloca %struct.nvme_stats, align 8
  %info = alloca %struct.NvmeEndGrpLog, align 1
  %i = alloca i32, align 4
  %ns = alloca ptr, align 8
  %_a29 = alloca i64, align 8
  %_b30 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i8 %rae, ptr %rae.addr, align 1
  store i32 %buf_len, ptr %buf_len.addr, align 4
  store i64 %off, ptr %off.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  %cdw11 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 8
  %1 = load i32, ptr %cdw11, align 4
  %call = call i32 @le32_to_cpu(i32 noundef %1)
  store i32 %call, ptr %dw11, align 4
  %2 = load i32, ptr %dw11, align 4
  %shr = lshr i32 %2, 16
  %and = and i32 %shr, 65535
  %conv = trunc i32 %and to i16
  store i16 %conv, ptr %endgrpid, align 2
  call void @llvm.memset.p0.i64(ptr align 8 %stats, i8 0, i64 32, i1 false)
  call void @llvm.memset.p0.i64(ptr align 1 %info, i8 0, i64 512, i1 false)
  %3 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 33
  %4 = load ptr, ptr %subsys, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %5 = load i16, ptr %endgrpid, align 2
  %conv1 = zext i16 %5 to i32
  %cmp = icmp ne i32 %conv1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %6 = load i64, ptr %off.addr, align 8
  %cmp3 = icmp uge i64 %6, 512
  br i1 %cmp3, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store i16 16386, ptr %retval, align 2
  br label %return

if.end6:                                          ; preds = %if.end
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %7 = load i32, ptr %i, align 4
  %cmp7 = icmp sle i32 %7, 256
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr %n.addr, align 8
  %subsys9 = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 33
  %9 = load ptr, ptr %subsys9, align 8
  %10 = load i32, ptr %i, align 4
  %call10 = call ptr @nvme_subsys_ns(ptr noundef %9, i32 noundef %10)
  store ptr %call10, ptr %ns, align 8
  %11 = load ptr, ptr %ns, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %for.body
  br label %for.inc

if.end13:                                         ; preds = %for.body
  %12 = load ptr, ptr %ns, align 8
  call void @nvme_set_blk_stats(ptr noundef %12, ptr noundef %stats)
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then12
  %13 = load i32, ptr %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !54

for.end:                                          ; preds = %for.cond
  %units_read = getelementptr inbounds %struct.nvme_stats, ptr %stats, i32 0, i32 0
  %14 = load i64, ptr %units_read, align 8
  %div = udiv i64 %14, 1000000000
  %add = add i64 %div, 1000000000
  %sub = sub i64 %add, 1
  %div14 = udiv i64 %sub, 1000000000
  %call15 = call i64 @cpu_to_le64(i64 noundef %div14)
  %data_units_read = getelementptr inbounds %struct.NvmeEndGrpLog, ptr %info, i32 0, i32 7
  %arrayidx = getelementptr [2 x i64], ptr %data_units_read, i64 0, i64 0
  store i64 %call15, ptr %arrayidx, align 1
  %units_written = getelementptr inbounds %struct.nvme_stats, ptr %stats, i32 0, i32 1
  %15 = load i64, ptr %units_written, align 8
  %div16 = udiv i64 %15, 1000000000
  %add17 = add i64 %div16, 1000000000
  %sub18 = sub i64 %add17, 1
  %div19 = udiv i64 %sub18, 1000000000
  %call20 = call i64 @cpu_to_le64(i64 noundef %div19)
  %data_units_written = getelementptr inbounds %struct.NvmeEndGrpLog, ptr %info, i32 0, i32 8
  %arrayidx21 = getelementptr [2 x i64], ptr %data_units_written, i64 0, i64 0
  store i64 %call20, ptr %arrayidx21, align 1
  %units_written22 = getelementptr inbounds %struct.nvme_stats, ptr %stats, i32 0, i32 1
  %16 = load i64, ptr %units_written22, align 8
  %div23 = udiv i64 %16, 1000000000
  %add24 = add i64 %div23, 1000000000
  %sub25 = sub i64 %add24, 1
  %div26 = udiv i64 %sub25, 1000000000
  %call27 = call i64 @cpu_to_le64(i64 noundef %div26)
  %media_units_written = getelementptr inbounds %struct.NvmeEndGrpLog, ptr %info, i32 0, i32 9
  %arrayidx28 = getelementptr [2 x i64], ptr %media_units_written, i64 0, i64 0
  store i64 %call27, ptr %arrayidx28, align 1
  %read_commands = getelementptr inbounds %struct.nvme_stats, ptr %stats, i32 0, i32 2
  %17 = load i64, ptr %read_commands, align 8
  %call29 = call i64 @cpu_to_le64(i64 noundef %17)
  %host_read_commands = getelementptr inbounds %struct.NvmeEndGrpLog, ptr %info, i32 0, i32 10
  %arrayidx30 = getelementptr [2 x i64], ptr %host_read_commands, i64 0, i64 0
  store i64 %call29, ptr %arrayidx30, align 1
  %write_commands = getelementptr inbounds %struct.nvme_stats, ptr %stats, i32 0, i32 3
  %18 = load i64, ptr %write_commands, align 8
  %call31 = call i64 @cpu_to_le64(i64 noundef %18)
  %host_write_commands = getelementptr inbounds %struct.NvmeEndGrpLog, ptr %info, i32 0, i32 11
  %arrayidx32 = getelementptr [2 x i64], ptr %host_write_commands, i64 0, i64 0
  store i64 %call31, ptr %arrayidx32, align 1
  %19 = load i64, ptr %off.addr, align 8
  %sub33 = sub i64 512, %19
  store i64 %sub33, ptr %_a29, align 8
  %20 = load i32, ptr %buf_len.addr, align 4
  %conv34 = zext i32 %20 to i64
  store i64 %conv34, ptr %_b30, align 8
  %21 = load i64, ptr %_a29, align 8
  %22 = load i64, ptr %_b30, align 8
  %cmp35 = icmp ult i64 %21, %22
  br i1 %cmp35, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %23 = load i64, ptr %_a29, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.end
  %24 = load i64, ptr %_b30, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %23, %cond.true ], [ %24, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %25 = load i64, ptr %tmp, align 8
  %conv37 = trunc i64 %25 to i32
  store i32 %conv37, ptr %buf_len.addr, align 4
  %26 = load ptr, ptr %n.addr, align 8
  %27 = load i64, ptr %off.addr, align 8
  %add.ptr = getelementptr i8, ptr %info, i64 %27
  %28 = load i32, ptr %buf_len.addr, align 4
  %29 = load ptr, ptr %req.addr, align 8
  %call38 = call zeroext i16 @nvme_c2h(ptr noundef %26, ptr noundef %add.ptr, i32 noundef %28, ptr noundef %29)
  store i16 %call38, ptr %retval, align 2
  br label %return

return:                                           ; preds = %cond.end, %if.then5, %if.then
  %30 = load i16, ptr %retval, align 2
  ret i16 %30
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_fdp_confs(ptr noundef %n, i32 noundef %endgrpid, i32 noundef %buf_len, i64 noundef %off, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %endgrpid.addr = alloca i32, align 4
  %buf_len.addr = alloca i32, align 4
  %off.addr = alloca i64, align 8
  %req.addr = alloca ptr, align 8
  %log_size = alloca i32, align 4
  %trans_len = alloca i32, align 4
  %buf = alloca ptr, align 8
  %hdr = alloca ptr, align 8
  %ruhd = alloca ptr, align 8
  %endgrp = alloca ptr, align 8
  %log = alloca ptr, align 8
  %nruh = alloca i64, align 8
  %fdp_descr_size = alloca i64, align 8
  %i = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %_a39 = alloca i64, align 8
  %_b40 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %_v = alloca %struct.anon.45, align 4
  %_d = alloca i8, align 1
  %tmp34 = alloca i8, align 1
  %_v36 = alloca %struct.anon.46, align 4
  %_d41 = alloca i8, align 1
  %tmp49 = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store i32 %endgrpid, ptr %endgrpid.addr, align 4
  store i32 %buf_len, ptr %buf_len.addr, align 4
  store i64 %off, ptr %off.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  store ptr null, ptr %buf, align 8
  %0 = load i32, ptr %endgrpid.addr, align 4
  %cmp = icmp ne i32 %0, 1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 33
  %2 = load ptr, ptr %subsys, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i16 16386, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %n.addr, align 8
  %subsys1 = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 33
  %4 = load ptr, ptr %subsys1, align 8
  %endgrp2 = getelementptr inbounds %struct.NvmeSubsystem, ptr %4, i32 0, i32 6
  store ptr %endgrp2, ptr %endgrp, align 8
  %5 = load ptr, ptr %endgrp, align 8
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %5, i32 0, i32 1
  %enabled = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 9
  %6 = load i8, ptr %enabled, align 8
  %tobool3 = trunc i8 %6 to i1
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %7 = load ptr, ptr %endgrp, align 8
  %fdp5 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %7, i32 0, i32 1
  %nruh6 = getelementptr inbounds %struct.anon.36, ptr %fdp5, i32 0, i32 2
  %8 = load i16, ptr %nruh6, align 8
  %conv = zext i16 %8 to i64
  store i64 %conv, ptr %nruh, align 8
  br label %if.end7

if.else:                                          ; preds = %if.end
  store i64 1, ptr %nruh, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then4
  %9 = load i64, ptr %nruh, align 8
  %call = call i64 @sizeof_fdp_conf_descr(i64 noundef %9, i64 noundef 0)
  store i64 %call, ptr %fdp_descr_size, align 8
  %10 = load i64, ptr %fdp_descr_size, align 8
  %add = add i64 16, %10
  %conv8 = trunc i64 %add to i32
  store i32 %conv8, ptr %log_size, align 4
  %11 = load i64, ptr %off.addr, align 8
  %12 = load i32, ptr %log_size, align 4
  %conv9 = zext i32 %12 to i64
  %cmp10 = icmp uge i64 %11, %conv9
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end7
  store i16 16386, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end13:                                         ; preds = %if.end7
  %13 = load i32, ptr %log_size, align 4
  %conv14 = zext i32 %13 to i64
  %14 = load i64, ptr %off.addr, align 8
  %sub = sub i64 %conv14, %14
  store i64 %sub, ptr %_a39, align 8
  %15 = load i32, ptr %buf_len.addr, align 4
  %conv15 = zext i32 %15 to i64
  store i64 %conv15, ptr %_b40, align 8
  %16 = load i64, ptr %_a39, align 8
  %17 = load i64, ptr %_b40, align 8
  %cmp16 = icmp ult i64 %16, %17
  br i1 %cmp16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end13
  %18 = load i64, ptr %_a39, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end13
  %19 = load i64, ptr %_b40, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %18, %cond.true ], [ %19, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %20 = load i64, ptr %tmp, align 8
  %conv18 = trunc i64 %20 to i32
  store i32 %conv18, ptr %trans_len, align 4
  %21 = load i32, ptr %log_size, align 4
  %conv19 = zext i32 %21 to i64
  %call20 = call noalias ptr @g_malloc0(i64 noundef %conv19) #14
  store ptr %call20, ptr %buf, align 8
  %22 = load ptr, ptr %buf, align 8
  store ptr %22, ptr %log, align 8
  %23 = load ptr, ptr %log, align 8
  %add.ptr = getelementptr %struct.NvmeFdpConfsHdr, ptr %23, i64 1
  store ptr %add.ptr, ptr %hdr, align 8
  %24 = load ptr, ptr %buf, align 8
  %add.ptr21 = getelementptr i8, ptr %24, i64 16
  %add.ptr22 = getelementptr i8, ptr %add.ptr21, i64 64
  store ptr %add.ptr22, ptr %ruhd, align 8
  %call23 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 0)
  %25 = load ptr, ptr %log, align 8
  %num_confs = getelementptr inbounds %struct.NvmeFdpConfsHdr, ptr %25, i32 0, i32 0
  store i16 %call23, ptr %num_confs, align 1
  %26 = load i32, ptr %log_size, align 4
  %call24 = call i32 @cpu_to_le32(i32 noundef %26)
  %27 = load ptr, ptr %log, align 8
  %size = getelementptr inbounds %struct.NvmeFdpConfsHdr, ptr %27, i32 0, i32 3
  store i32 %call24, ptr %size, align 1
  %28 = load i64, ptr %fdp_descr_size, align 8
  %conv25 = trunc i64 %28 to i16
  %call26 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv25)
  %29 = load ptr, ptr %hdr, align 8
  %descr_size = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %29, i32 0, i32 0
  store i16 %call26, ptr %descr_size, align 1
  %30 = load ptr, ptr %endgrp, align 8
  %fdp27 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %30, i32 0, i32 1
  %enabled28 = getelementptr inbounds %struct.anon.36, ptr %fdp27, i32 0, i32 9
  %31 = load i8, ptr %enabled28, align 8
  %tobool29 = trunc i8 %31 to i1
  br i1 %tobool29, label %if.then30, label %if.else67

if.then30:                                        ; preds = %cond.end
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %_v, ptr align 4 @__const.nvme_fdp_confs._v, i64 4, i1 false)
  %32 = load ptr, ptr %hdr, align 8
  %fdpa = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %32, i32 0, i32 1
  %33 = load i8, ptr %fdpa, align 1
  %conv31 = zext i8 %33 to i32
  %bf.load = load i8, ptr %_v, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %call32 = call i32 @deposit32(i32 noundef %conv31, i32 noundef 7, i32 noundef 1, i32 noundef %bf.cast)
  %conv33 = trunc i32 %call32 to i8
  store i8 %conv33, ptr %_d, align 1
  %34 = load i8, ptr %_d, align 1
  store i8 %34, ptr %tmp34, align 1
  %35 = load i8, ptr %tmp34, align 1
  %36 = load ptr, ptr %hdr, align 8
  %fdpa35 = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %36, i32 0, i32 1
  store i8 %35, ptr %fdpa35, align 1
  %37 = load ptr, ptr %endgrp, align 8
  %fdp37 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %37, i32 0, i32 1
  %rgif = getelementptr inbounds %struct.anon.36, ptr %fdp37, i32 0, i32 4
  %38 = load i8, ptr %rgif, align 4
  %conv38 = zext i8 %38 to i32
  %39 = trunc i32 %conv38 to i8
  %bf.load39 = load i8, ptr %_v36, align 4
  %bf.value = and i8 %39, 15
  %bf.clear40 = and i8 %bf.load39, -16
  %bf.set = or i8 %bf.clear40, %bf.value
  store i8 %bf.set, ptr %_v36, align 4
  %40 = load ptr, ptr %hdr, align 8
  %fdpa42 = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %40, i32 0, i32 1
  %41 = load i8, ptr %fdpa42, align 1
  %conv43 = zext i8 %41 to i32
  %bf.load44 = load i8, ptr %_v36, align 4
  %bf.clear45 = and i8 %bf.load44, 15
  %bf.cast46 = zext i8 %bf.clear45 to i32
  %call47 = call i32 @deposit32(i32 noundef %conv43, i32 noundef 0, i32 noundef 4, i32 noundef %bf.cast46)
  %conv48 = trunc i32 %call47 to i8
  store i8 %conv48, ptr %_d41, align 1
  %42 = load i8, ptr %_d41, align 1
  store i8 %42, ptr %tmp49, align 1
  %43 = load i8, ptr %tmp49, align 1
  %44 = load ptr, ptr %hdr, align 8
  %fdpa50 = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %44, i32 0, i32 1
  store i8 %43, ptr %fdpa50, align 1
  %45 = load ptr, ptr %endgrp, align 8
  %fdp51 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %45, i32 0, i32 1
  %nrg = getelementptr inbounds %struct.anon.36, ptr %fdp51, i32 0, i32 3
  %46 = load i16, ptr %nrg, align 2
  %call52 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %46)
  %conv53 = zext i16 %call52 to i32
  %47 = load ptr, ptr %hdr, align 8
  %nrg54 = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %47, i32 0, i32 3
  store i32 %conv53, ptr %nrg54, align 1
  %48 = load ptr, ptr %endgrp, align 8
  %fdp55 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %48, i32 0, i32 1
  %nruh56 = getelementptr inbounds %struct.anon.36, ptr %fdp55, i32 0, i32 2
  %49 = load i16, ptr %nruh56, align 8
  %call57 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %49)
  %50 = load ptr, ptr %hdr, align 8
  %nruh58 = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %50, i32 0, i32 4
  store i16 %call57, ptr %nruh58, align 1
  %call59 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 127)
  %51 = load ptr, ptr %hdr, align 8
  %maxpids = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %51, i32 0, i32 5
  store i16 %call59, ptr %maxpids, align 1
  %call60 = call i32 @cpu_to_le32(i32 noundef 256)
  %52 = load ptr, ptr %hdr, align 8
  %nnss = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %52, i32 0, i32 6
  store i32 %call60, ptr %nnss, align 1
  %53 = load ptr, ptr %endgrp, align 8
  %fdp61 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %53, i32 0, i32 1
  %runs = getelementptr inbounds %struct.anon.36, ptr %fdp61, i32 0, i32 5
  %54 = load i64, ptr %runs, align 8
  %call62 = call i64 @cpu_to_le64(i64 noundef %54)
  %55 = load ptr, ptr %hdr, align 8
  %runs63 = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %55, i32 0, i32 7
  store i64 %call62, ptr %runs63, align 1
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then30
  %56 = load i32, ptr %i, align 4
  %conv64 = sext i32 %56 to i64
  %57 = load i64, ptr %nruh, align 8
  %cmp65 = icmp ult i64 %conv64, %57
  br i1 %cmp65, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %58 = load ptr, ptr %ruhd, align 8
  %ruht = getelementptr inbounds %struct.NvmeRuhDescr, ptr %58, i32 0, i32 0
  store i8 1, ptr %ruht, align 1
  %59 = load ptr, ptr %ruhd, align 8
  %incdec.ptr = getelementptr %struct.NvmeRuhDescr, ptr %59, i32 1
  store ptr %incdec.ptr, ptr %ruhd, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %60 = load i32, ptr %i, align 4
  %inc = add i32 %60, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !55

for.end:                                          ; preds = %for.cond
  br label %if.end80

if.else67:                                        ; preds = %cond.end
  %call68 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 1)
  %conv69 = zext i16 %call68 to i32
  %61 = load ptr, ptr %hdr, align 8
  %nrg70 = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %61, i32 0, i32 3
  store i32 %conv69, ptr %nrg70, align 1
  %call71 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 1)
  %62 = load ptr, ptr %hdr, align 8
  %nruh72 = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %62, i32 0, i32 4
  store i16 %call71, ptr %nruh72, align 1
  %call73 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext 127)
  %63 = load ptr, ptr %hdr, align 8
  %maxpids74 = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %63, i32 0, i32 5
  store i16 %call73, ptr %maxpids74, align 1
  %call75 = call i32 @cpu_to_le32(i32 noundef 1)
  %64 = load ptr, ptr %hdr, align 8
  %nnss76 = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %64, i32 0, i32 6
  store i32 %call75, ptr %nnss76, align 1
  %call77 = call i64 @cpu_to_le64(i64 noundef 100663296)
  %65 = load ptr, ptr %hdr, align 8
  %runs78 = getelementptr inbounds %struct.NvmeFdpDescrHdr, ptr %65, i32 0, i32 7
  store i64 %call77, ptr %runs78, align 1
  %66 = load ptr, ptr %ruhd, align 8
  %ruht79 = getelementptr inbounds %struct.NvmeRuhDescr, ptr %66, i32 0, i32 0
  store i8 1, ptr %ruht79, align 1
  br label %if.end80

if.end80:                                         ; preds = %if.else67, %for.end
  %67 = load ptr, ptr %n.addr, align 8
  %68 = load ptr, ptr %buf, align 8
  %69 = load i64, ptr %off.addr, align 8
  %add.ptr81 = getelementptr i8, ptr %68, i64 %69
  %70 = load i32, ptr %trans_len, align 4
  %71 = load ptr, ptr %req.addr, align 8
  %call82 = call zeroext i16 @nvme_c2h(ptr noundef %67, ptr noundef %add.ptr81, i32 noundef %70, ptr noundef %71)
  store i16 %call82, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end80, %if.then12, %if.then
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %buf)
  %72 = load i16, ptr %retval, align 2
  ret i16 %72
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_fdp_ruh_usage(ptr noundef %n, i32 noundef %endgrpid, i32 noundef %dw10, i32 noundef %dw12, i32 noundef %buf_len, i64 noundef %off, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %endgrpid.addr = alloca i32, align 4
  %dw10.addr = alloca i32, align 4
  %dw12.addr = alloca i32, align 4
  %buf_len.addr = alloca i32, align 4
  %off.addr = alloca i64, align 8
  %req.addr = alloca ptr, align 8
  %ruh = alloca ptr, align 8
  %hdr = alloca ptr, align 8
  %ruhud = alloca ptr, align 8
  %endgrp = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %log_size = alloca i32, align 4
  %trans_len = alloca i32, align 4
  %i = alloca i16, align 2
  %cleanup.dest.slot = alloca i32, align 4
  %_a41 = alloca i64, align 8
  %_b42 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i32 %endgrpid, ptr %endgrpid.addr, align 4
  store i32 %dw10, ptr %dw10.addr, align 4
  store i32 %dw12, ptr %dw12.addr, align 4
  store i32 %buf_len, ptr %buf_len.addr, align 4
  store i64 %off, ptr %off.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  store ptr null, ptr %buf, align 8
  %0 = load i32, ptr %endgrpid.addr, align 4
  %cmp = icmp ne i32 %0, 1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 33
  %2 = load ptr, ptr %subsys, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i16 16386, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %n.addr, align 8
  %subsys1 = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 33
  %4 = load ptr, ptr %subsys1, align 8
  %endgrp2 = getelementptr inbounds %struct.NvmeSubsystem, ptr %4, i32 0, i32 6
  store ptr %endgrp2, ptr %endgrp, align 8
  %5 = load ptr, ptr %endgrp, align 8
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %5, i32 0, i32 1
  %enabled = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 9
  %6 = load i8, ptr %enabled, align 8
  %tobool3 = trunc i8 %6 to i1
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  store i16 16425, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %7 = load ptr, ptr %endgrp, align 8
  %fdp6 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %7, i32 0, i32 1
  %nruh = getelementptr inbounds %struct.anon.36, ptr %fdp6, i32 0, i32 2
  %8 = load i16, ptr %nruh, align 8
  %conv = zext i16 %8 to i64
  %mul = mul i64 %conv, 8
  %add = add i64 8, %mul
  %conv7 = trunc i64 %add to i32
  store i32 %conv7, ptr %log_size, align 4
  %9 = load i64, ptr %off.addr, align 8
  %10 = load i32, ptr %log_size, align 4
  %conv8 = zext i32 %10 to i64
  %cmp9 = icmp uge i64 %9, %conv8
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end5
  store i16 16386, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end12:                                         ; preds = %if.end5
  %11 = load i32, ptr %log_size, align 4
  %conv13 = zext i32 %11 to i64
  %12 = load i64, ptr %off.addr, align 8
  %sub = sub i64 %conv13, %12
  store i64 %sub, ptr %_a41, align 8
  %13 = load i32, ptr %buf_len.addr, align 4
  %conv14 = zext i32 %13 to i64
  store i64 %conv14, ptr %_b42, align 8
  %14 = load i64, ptr %_a41, align 8
  %15 = load i64, ptr %_b42, align 8
  %cmp15 = icmp ult i64 %14, %15
  br i1 %cmp15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end12
  %16 = load i64, ptr %_a41, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end12
  %17 = load i64, ptr %_b42, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %16, %cond.true ], [ %17, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %18 = load i64, ptr %tmp, align 8
  %conv17 = trunc i64 %18 to i32
  store i32 %conv17, ptr %trans_len, align 4
  %19 = load i32, ptr %log_size, align 4
  %conv18 = zext i32 %19 to i64
  %call = call noalias ptr @g_malloc0(i64 noundef %conv18) #14
  store ptr %call, ptr %buf, align 8
  %20 = load ptr, ptr %buf, align 8
  store ptr %20, ptr %hdr, align 8
  %21 = load ptr, ptr %hdr, align 8
  %add.ptr = getelementptr %struct.NvmeRuhuLog, ptr %21, i64 1
  store ptr %add.ptr, ptr %ruhud, align 8
  %22 = load ptr, ptr %endgrp, align 8
  %fdp19 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %22, i32 0, i32 1
  %ruhs = getelementptr inbounds %struct.anon.36, ptr %fdp19, i32 0, i32 10
  %23 = load ptr, ptr %ruhs, align 8
  store ptr %23, ptr %ruh, align 8
  %24 = load ptr, ptr %endgrp, align 8
  %fdp20 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %24, i32 0, i32 1
  %nruh21 = getelementptr inbounds %struct.anon.36, ptr %fdp20, i32 0, i32 2
  %25 = load i16, ptr %nruh21, align 8
  %call22 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %25)
  %26 = load ptr, ptr %hdr, align 8
  %nruh23 = getelementptr inbounds %struct.NvmeRuhuLog, ptr %26, i32 0, i32 0
  store i16 %call22, ptr %nruh23, align 1
  store i16 0, ptr %i, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %27 = load i16, ptr %i, align 2
  %conv24 = zext i16 %27 to i32
  %28 = load ptr, ptr %endgrp, align 8
  %fdp25 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %28, i32 0, i32 1
  %nruh26 = getelementptr inbounds %struct.anon.36, ptr %fdp25, i32 0, i32 2
  %29 = load i16, ptr %nruh26, align 8
  %conv27 = zext i16 %29 to i32
  %cmp28 = icmp slt i32 %conv24, %conv27
  br i1 %cmp28, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %30 = load ptr, ptr %ruh, align 8
  %ruha = getelementptr inbounds %struct.NvmeRuHandle, ptr %30, i32 0, i32 1
  %31 = load i8, ptr %ruha, align 1
  %32 = load ptr, ptr %ruhud, align 8
  %ruha30 = getelementptr inbounds %struct.NvmeRuhuDescr, ptr %32, i32 0, i32 0
  store i8 %31, ptr %ruha30, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %33 = load i16, ptr %i, align 2
  %inc = add i16 %33, 1
  store i16 %inc, ptr %i, align 2
  %34 = load ptr, ptr %ruhud, align 8
  %incdec.ptr = getelementptr %struct.NvmeRuhuDescr, ptr %34, i32 1
  store ptr %incdec.ptr, ptr %ruhud, align 8
  %35 = load ptr, ptr %ruh, align 8
  %incdec.ptr31 = getelementptr %struct.NvmeRuHandle, ptr %35, i32 1
  store ptr %incdec.ptr31, ptr %ruh, align 8
  br label %for.cond, !llvm.loop !56

for.end:                                          ; preds = %for.cond
  %36 = load ptr, ptr %n.addr, align 8
  %37 = load ptr, ptr %buf, align 8
  %38 = load i64, ptr %off.addr, align 8
  %add.ptr32 = getelementptr i8, ptr %37, i64 %38
  %39 = load i32, ptr %trans_len, align 4
  %40 = load ptr, ptr %req.addr, align 8
  %call33 = call zeroext i16 @nvme_c2h(ptr noundef %36, ptr noundef %add.ptr32, i32 noundef %39, ptr noundef %40)
  store i16 %call33, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then11, %if.then4, %if.then
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %buf)
  %41 = load i16, ptr %retval, align 2
  ret i16 %41
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_fdp_stats(ptr noundef %n, i32 noundef %endgrpid, i32 noundef %buf_len, i64 noundef %off, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %endgrpid.addr = alloca i32, align 4
  %buf_len.addr = alloca i32, align 4
  %off.addr = alloca i64, align 8
  %req.addr = alloca ptr, align 8
  %endgrp = alloca ptr, align 8
  %log = alloca %struct.NvmeFdpStatsLog, align 1
  %trans_len = alloca i32, align 4
  %_a43 = alloca i64, align 8
  %_b44 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i32 %endgrpid, ptr %endgrpid.addr, align 4
  store i32 %buf_len, ptr %buf_len.addr, align 4
  store i64 %off, ptr %off.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %log, i8 0, i64 64, i1 false)
  %0 = load i64, ptr %off.addr, align 8
  %cmp = icmp uge i64 %0, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %endgrpid.addr, align 4
  %cmp1 = icmp ne i32 %1, 1
  br i1 %cmp1, label %if.then2, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %2 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 33
  %3 = load ptr, ptr %subsys, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  store i16 16386, ptr %retval, align 2
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %4 = load ptr, ptr %n.addr, align 8
  %subsys4 = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 33
  %5 = load ptr, ptr %subsys4, align 8
  %endgrp5 = getelementptr inbounds %struct.NvmeSubsystem, ptr %5, i32 0, i32 6
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %endgrp5, i32 0, i32 1
  %enabled = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 9
  %6 = load i8, ptr %enabled, align 8
  %tobool6 = trunc i8 %6 to i1
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end3
  store i16 16425, ptr %retval, align 2
  br label %return

if.end8:                                          ; preds = %if.end3
  %7 = load ptr, ptr %n.addr, align 8
  %subsys9 = getelementptr inbounds %struct.NvmeCtrl, ptr %7, i32 0, i32 33
  %8 = load ptr, ptr %subsys9, align 8
  %endgrp10 = getelementptr inbounds %struct.NvmeSubsystem, ptr %8, i32 0, i32 6
  store ptr %endgrp10, ptr %endgrp, align 8
  %9 = load i64, ptr %off.addr, align 8
  %sub = sub i64 64, %9
  store i64 %sub, ptr %_a43, align 8
  %10 = load i32, ptr %buf_len.addr, align 4
  %conv = zext i32 %10 to i64
  store i64 %conv, ptr %_b44, align 8
  %11 = load i64, ptr %_a43, align 8
  %12 = load i64, ptr %_b44, align 8
  %cmp11 = icmp ult i64 %11, %12
  br i1 %cmp11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end8
  %13 = load i64, ptr %_a43, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end8
  %14 = load i64, ptr %_b44, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %13, %cond.true ], [ %14, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %15 = load i64, ptr %tmp, align 8
  %conv13 = trunc i64 %15 to i32
  store i32 %conv13, ptr %trans_len, align 4
  %16 = load ptr, ptr %endgrp, align 8
  %fdp14 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %16, i32 0, i32 1
  %hbmw = getelementptr inbounds %struct.anon.36, ptr %fdp14, i32 0, i32 6
  %17 = load i64, ptr %hbmw, align 8
  %call = call i64 @cpu_to_le64(i64 noundef %17)
  %hbmw15 = getelementptr inbounds %struct.NvmeFdpStatsLog, ptr %log, i32 0, i32 0
  %arrayidx = getelementptr [2 x i64], ptr %hbmw15, i64 0, i64 0
  store i64 %call, ptr %arrayidx, align 1
  %18 = load ptr, ptr %endgrp, align 8
  %fdp16 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %18, i32 0, i32 1
  %mbmw = getelementptr inbounds %struct.anon.36, ptr %fdp16, i32 0, i32 7
  %19 = load i64, ptr %mbmw, align 8
  %call17 = call i64 @cpu_to_le64(i64 noundef %19)
  %mbmw18 = getelementptr inbounds %struct.NvmeFdpStatsLog, ptr %log, i32 0, i32 1
  %arrayidx19 = getelementptr [2 x i64], ptr %mbmw18, i64 0, i64 0
  store i64 %call17, ptr %arrayidx19, align 1
  %20 = load ptr, ptr %endgrp, align 8
  %fdp20 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %20, i32 0, i32 1
  %mbe = getelementptr inbounds %struct.anon.36, ptr %fdp20, i32 0, i32 8
  %21 = load i64, ptr %mbe, align 8
  %call21 = call i64 @cpu_to_le64(i64 noundef %21)
  %mbe22 = getelementptr inbounds %struct.NvmeFdpStatsLog, ptr %log, i32 0, i32 2
  %arrayidx23 = getelementptr [2 x i64], ptr %mbe22, i64 0, i64 0
  store i64 %call21, ptr %arrayidx23, align 1
  %22 = load ptr, ptr %n.addr, align 8
  %23 = load i64, ptr %off.addr, align 8
  %add.ptr = getelementptr i8, ptr %log, i64 %23
  %24 = load i32, ptr %trans_len, align 4
  %25 = load ptr, ptr %req.addr, align 8
  %call24 = call zeroext i16 @nvme_c2h(ptr noundef %22, ptr noundef %add.ptr, i32 noundef %24, ptr noundef %25)
  store i16 %call24, ptr %retval, align 2
  br label %return

return:                                           ; preds = %cond.end, %if.then7, %if.then2, %if.then
  %26 = load i16, ptr %retval, align 2
  ret i16 %26
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_fdp_events(ptr noundef %n, i32 noundef %endgrpid, i32 noundef %buf_len, i64 noundef %off, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %endgrpid.addr = alloca i32, align 4
  %buf_len.addr = alloca i32, align 4
  %off.addr = alloca i64, align 8
  %req.addr = alloca ptr, align 8
  %endgrp = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %host_events = alloca i8, align 1
  %log_size = alloca i32, align 4
  %trans_len = alloca i32, align 4
  %ebuf = alloca ptr, align 8
  %elog = alloca ptr, align 8
  %event = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %_a45 = alloca i64, align 8
  %_b46 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %nelems33 = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store i32 %endgrpid, ptr %endgrpid.addr, align 4
  store i32 %buf_len, ptr %buf_len.addr, align 4
  store i64 %off, ptr %off.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd1, ptr %cmd, align 8
  %1 = load ptr, ptr %cmd, align 8
  %cdw10 = getelementptr inbounds %struct.NvmeCmd, ptr %1, i32 0, i32 7
  %2 = load i32, ptr %cdw10, align 1
  %shr = lshr i32 %2, 8
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %host_events, align 1
  store ptr null, ptr %elog, align 8
  %3 = load i32, ptr %endgrpid.addr, align 4
  %cmp = icmp ne i32 %3, 1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 33
  %5 = load ptr, ptr %subsys, align 8
  %tobool2 = icmp ne ptr %5, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i16 16386, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %6 = load ptr, ptr %n.addr, align 8
  %subsys3 = getelementptr inbounds %struct.NvmeCtrl, ptr %6, i32 0, i32 33
  %7 = load ptr, ptr %subsys3, align 8
  %endgrp4 = getelementptr inbounds %struct.NvmeSubsystem, ptr %7, i32 0, i32 6
  store ptr %endgrp4, ptr %endgrp, align 8
  %8 = load ptr, ptr %endgrp, align 8
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %8, i32 0, i32 1
  %enabled = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 9
  %9 = load i8, ptr %enabled, align 8
  %tobool5 = trunc i8 %9 to i1
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  store i16 16425, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %10 = load i8, ptr %host_events, align 1
  %tobool8 = trunc i8 %10 to i1
  br i1 %tobool8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end7
  %11 = load ptr, ptr %endgrp, align 8
  %fdp10 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %11, i32 0, i32 1
  %host_events11 = getelementptr inbounds %struct.anon.36, ptr %fdp10, i32 0, i32 0
  store ptr %host_events11, ptr %ebuf, align 8
  br label %if.end13

if.else:                                          ; preds = %if.end7
  %12 = load ptr, ptr %endgrp, align 8
  %fdp12 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %12, i32 0, i32 1
  %ctrl_events = getelementptr inbounds %struct.anon.36, ptr %fdp12, i32 0, i32 1
  store ptr %ctrl_events, ptr %ebuf, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then9
  %13 = load ptr, ptr %ebuf, align 8
  %nelems = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %13, i32 0, i32 1
  %14 = load i32, ptr %nelems, align 4
  %conv = zext i32 %14 to i64
  %mul = mul i64 %conv, 64
  %add = add i64 64, %mul
  %conv14 = trunc i64 %add to i32
  store i32 %conv14, ptr %log_size, align 4
  %15 = load i64, ptr %off.addr, align 8
  %16 = load i32, ptr %log_size, align 4
  %conv15 = zext i32 %16 to i64
  %cmp16 = icmp uge i64 %15, %conv15
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end13
  store i16 16386, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end19:                                         ; preds = %if.end13
  %17 = load i32, ptr %log_size, align 4
  %conv20 = zext i32 %17 to i64
  %18 = load i64, ptr %off.addr, align 8
  %sub = sub i64 %conv20, %18
  store i64 %sub, ptr %_a45, align 8
  %19 = load i32, ptr %buf_len.addr, align 4
  %conv21 = zext i32 %19 to i64
  store i64 %conv21, ptr %_b46, align 8
  %20 = load i64, ptr %_a45, align 8
  %21 = load i64, ptr %_b46, align 8
  %cmp22 = icmp ult i64 %20, %21
  br i1 %cmp22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end19
  %22 = load i64, ptr %_a45, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end19
  %23 = load i64, ptr %_b46, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %22, %cond.true ], [ %23, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %24 = load i64, ptr %tmp, align 8
  %conv24 = trunc i64 %24 to i32
  store i32 %conv24, ptr %trans_len, align 4
  %25 = load i32, ptr %log_size, align 4
  %conv25 = zext i32 %25 to i64
  %call = call noalias ptr @g_malloc0(i64 noundef %conv25) #14
  store ptr %call, ptr %elog, align 8
  %26 = load ptr, ptr %ebuf, align 8
  %nelems26 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %26, i32 0, i32 1
  %27 = load i32, ptr %nelems26, align 4
  %call27 = call i32 @cpu_to_le32(i32 noundef %27)
  %28 = load ptr, ptr %elog, align 8
  %num_events = getelementptr inbounds %struct.NvmeFdpEventsLog, ptr %28, i32 0, i32 0
  store i32 %call27, ptr %num_events, align 1
  %29 = load ptr, ptr %elog, align 8
  %add.ptr = getelementptr %struct.NvmeFdpEventsLog, ptr %29, i64 1
  store ptr %add.ptr, ptr %event, align 8
  %30 = load ptr, ptr %ebuf, align 8
  %nelems28 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %30, i32 0, i32 1
  %31 = load i32, ptr %nelems28, align 4
  %tobool29 = icmp ne i32 %31, 0
  br i1 %tobool29, label %land.lhs.true, label %if.else44

land.lhs.true:                                    ; preds = %cond.end
  %32 = load ptr, ptr %ebuf, align 8
  %start = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %32, i32 0, i32 2
  %33 = load i32, ptr %start, align 4
  %34 = load ptr, ptr %ebuf, align 8
  %next = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %34, i32 0, i32 3
  %35 = load i32, ptr %next, align 4
  %cmp30 = icmp eq i32 %33, %35
  br i1 %cmp30, label %if.then32, label %if.else44

if.then32:                                        ; preds = %land.lhs.true
  %36 = load ptr, ptr %ebuf, align 8
  %start34 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %36, i32 0, i32 2
  %37 = load i32, ptr %start34, align 4
  %sub35 = sub i32 63, %37
  store i32 %sub35, ptr %nelems33, align 4
  %38 = load ptr, ptr %event, align 8
  %39 = load ptr, ptr %ebuf, align 8
  %events = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %39, i32 0, i32 0
  %40 = load ptr, ptr %ebuf, align 8
  %start36 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %40, i32 0, i32 2
  %41 = load i32, ptr %start36, align 4
  %idxprom = zext i32 %41 to i64
  %arrayidx = getelementptr [63 x %struct.NvmeFdpEvent], ptr %events, i64 0, i64 %idxprom
  %42 = load i32, ptr %nelems33, align 4
  %conv37 = zext i32 %42 to i64
  %mul38 = mul i64 64, %conv37
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %38, ptr align 4 %arrayidx, i64 %mul38, i1 false)
  %43 = load ptr, ptr %event, align 8
  %44 = load i32, ptr %nelems33, align 4
  %idx.ext = zext i32 %44 to i64
  %add.ptr39 = getelementptr %struct.NvmeFdpEvent, ptr %43, i64 %idx.ext
  %45 = load ptr, ptr %ebuf, align 8
  %events40 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %45, i32 0, i32 0
  %arraydecay = getelementptr inbounds [63 x %struct.NvmeFdpEvent], ptr %events40, i64 0, i64 0
  %46 = load ptr, ptr %ebuf, align 8
  %next41 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %46, i32 0, i32 3
  %47 = load i32, ptr %next41, align 4
  %conv42 = zext i32 %47 to i64
  %mul43 = mul i64 64, %conv42
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr39, ptr align 4 %arraydecay, i64 %mul43, i1 false)
  br label %if.end60

if.else44:                                        ; preds = %land.lhs.true, %cond.end
  %48 = load ptr, ptr %ebuf, align 8
  %start45 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %48, i32 0, i32 2
  %49 = load i32, ptr %start45, align 4
  %50 = load ptr, ptr %ebuf, align 8
  %next46 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %50, i32 0, i32 3
  %51 = load i32, ptr %next46, align 4
  %cmp47 = icmp ult i32 %49, %51
  br i1 %cmp47, label %if.then49, label %if.end59

if.then49:                                        ; preds = %if.else44
  %52 = load ptr, ptr %event, align 8
  %53 = load ptr, ptr %ebuf, align 8
  %events50 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %53, i32 0, i32 0
  %54 = load ptr, ptr %ebuf, align 8
  %start51 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %54, i32 0, i32 2
  %55 = load i32, ptr %start51, align 4
  %idxprom52 = zext i32 %55 to i64
  %arrayidx53 = getelementptr [63 x %struct.NvmeFdpEvent], ptr %events50, i64 0, i64 %idxprom52
  %56 = load ptr, ptr %ebuf, align 8
  %next54 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %56, i32 0, i32 3
  %57 = load i32, ptr %next54, align 4
  %58 = load ptr, ptr %ebuf, align 8
  %start55 = getelementptr inbounds %struct.NvmeFdpEventBuffer, ptr %58, i32 0, i32 2
  %59 = load i32, ptr %start55, align 4
  %sub56 = sub i32 %57, %59
  %conv57 = zext i32 %sub56 to i64
  %mul58 = mul i64 64, %conv57
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %52, ptr align 4 %arrayidx53, i64 %mul58, i1 false)
  br label %if.end59

if.end59:                                         ; preds = %if.then49, %if.else44
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.then32
  %60 = load ptr, ptr %n.addr, align 8
  %61 = load ptr, ptr %elog, align 8
  %62 = load i64, ptr %off.addr, align 8
  %add.ptr61 = getelementptr i8, ptr %61, i64 %62
  %63 = load i32, ptr %trans_len, align 4
  %64 = load ptr, ptr %req.addr, align 8
  %call62 = call zeroext i16 @nvme_c2h(ptr noundef %60, ptr noundef %add.ptr61, i32 noundef %63, ptr noundef %64)
  store i16 %call62, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end60, %if.then18, %if.then6, %if.then
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %elog)
  %65 = load i16, ptr %retval, align 2
  ret i16 %65
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_log_page(i16 noundef zeroext %cid, i16 noundef zeroext %lid) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %lid.addr = alloca i16, align 2
  store i16 %cid, ptr %cid.addr, align 2
  store i16 %lid, ptr %lid.addr, align 2
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i16, ptr %lid.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_log_page(i16 noundef zeroext %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_get_log(i16 noundef zeroext %cid, i8 noundef zeroext %lid, i8 noundef zeroext %lsp, i8 noundef zeroext %rae, i32 noundef %len, i64 noundef %off) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %lid.addr = alloca i8, align 1
  %lsp.addr = alloca i8, align 1
  %rae.addr = alloca i8, align 1
  %len.addr = alloca i32, align 4
  %off.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i8 %lid, ptr %lid.addr, align 1
  store i8 %lsp, ptr %lsp.addr, align 1
  store i8 %rae, ptr %rae.addr, align 1
  store i32 %len, ptr %len.addr, align 4
  store i64 %off, ptr %off.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_GET_LOG_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end19

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i8, ptr %lid.addr, align 1
  %conv12 = zext i8 %6 to i32
  %7 = load i8, ptr %lsp.addr, align 1
  %conv13 = zext i8 %7 to i32
  %8 = load i8, ptr %rae.addr, align 1
  %conv14 = zext i8 %8 to i32
  %9 = load i32, ptr %len.addr, align 4
  %10 = load i64, ptr %off.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.330, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12, i32 noundef %conv13, i32 noundef %conv14, i32 noundef %9, i64 noundef %10)
  br label %if.end

if.else:                                          ; preds = %if.then
  %11 = load i16, ptr %cid.addr, align 2
  %conv15 = zext i16 %11 to i32
  %12 = load i8, ptr %lid.addr, align 1
  %conv16 = zext i8 %12 to i32
  %13 = load i8, ptr %lsp.addr, align 1
  %conv17 = zext i8 %13 to i32
  %14 = load i8, ptr %rae.addr, align 1
  %conv18 = zext i8 %14 to i32
  %15 = load i32, ptr %len.addr, align 4
  %16 = load i64, ptr %off.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.331, i32 noundef %conv15, i32 noundef %conv16, i32 noundef %conv17, i32 noundef %conv18, i32 noundef %15, i64 noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end19

if.end19:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_clear_events(ptr noundef %n, i8 noundef zeroext %event_type) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %event_type.addr = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store i8 %event_type, ptr %event_type.addr, align 1
  %0 = load i8, ptr %event_type.addr, align 1
  %conv = zext i8 %0 to i32
  %shl = shl i32 1, %conv
  %not = xor i32 %shl, -1
  %1 = load ptr, ptr %n.addr, align 8
  %aer_mask = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 27
  %2 = load i8, ptr %aer_mask, align 8
  %conv1 = zext i8 %2 to i32
  %and = and i32 %conv1, %not
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, ptr %aer_mask, align 8
  %3 = load ptr, ptr %n.addr, align 8
  %aer_queue = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 29
  %4 = load ptr, ptr %aer_queue, align 8
  %cmp = icmp eq ptr %4, null
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %n.addr, align 8
  call void @nvme_process_aers(ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_set_blk_stats(ptr noundef %ns, ptr noundef %stats) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %stats.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %stats, ptr %stats.addr, align 8
  %0 = load ptr, ptr %ns.addr, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %1 = load ptr, ptr %blk, align 8
  %call = call ptr @blk_get_stats(ptr noundef %1)
  store ptr %call, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %nr_bytes = getelementptr inbounds %struct.BlockAcctStats, ptr %2, i32 0, i32 1
  %arrayidx = getelementptr [6 x i64], ptr %nr_bytes, i64 0, i64 1
  %3 = load i64, ptr %arrayidx, align 8
  %4 = load ptr, ptr %stats.addr, align 8
  %units_read = getelementptr inbounds %struct.nvme_stats, ptr %4, i32 0, i32 0
  %5 = load i64, ptr %units_read, align 8
  %add = add i64 %5, %3
  store i64 %add, ptr %units_read, align 8
  %6 = load ptr, ptr %s, align 8
  %nr_bytes1 = getelementptr inbounds %struct.BlockAcctStats, ptr %6, i32 0, i32 1
  %arrayidx2 = getelementptr [6 x i64], ptr %nr_bytes1, i64 0, i64 2
  %7 = load i64, ptr %arrayidx2, align 8
  %8 = load ptr, ptr %stats.addr, align 8
  %units_written = getelementptr inbounds %struct.nvme_stats, ptr %8, i32 0, i32 1
  %9 = load i64, ptr %units_written, align 8
  %add3 = add i64 %9, %7
  store i64 %add3, ptr %units_written, align 8
  %10 = load ptr, ptr %s, align 8
  %nr_ops = getelementptr inbounds %struct.BlockAcctStats, ptr %10, i32 0, i32 2
  %arrayidx4 = getelementptr [6 x i64], ptr %nr_ops, i64 0, i64 1
  %11 = load i64, ptr %arrayidx4, align 8
  %12 = load ptr, ptr %stats.addr, align 8
  %read_commands = getelementptr inbounds %struct.nvme_stats, ptr %12, i32 0, i32 2
  %13 = load i64, ptr %read_commands, align 8
  %add5 = add i64 %13, %11
  store i64 %add5, ptr %read_commands, align 8
  %14 = load ptr, ptr %s, align 8
  %nr_ops6 = getelementptr inbounds %struct.BlockAcctStats, ptr %14, i32 0, i32 2
  %arrayidx7 = getelementptr [6 x i64], ptr %nr_ops6, i64 0, i64 2
  %15 = load i64, ptr %arrayidx7, align 8
  %16 = load ptr, ptr %stats.addr, align 8
  %write_commands = getelementptr inbounds %struct.nvme_stats, ptr %16, i32 0, i32 3
  %17 = load i64, ptr %write_commands, align 8
  %add8 = add i64 %17, %15
  store i64 %add8, ptr %write_commands, align 8
  ret void
}

declare void @strpadcpy(ptr noundef, i32 noundef, ptr noundef, i8 noundef signext) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_log_page_offset(i64 noundef %ofs, i64 noundef %size) #0 {
entry:
  %ofs.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  store i64 %ofs, ptr %ofs.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %ofs.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_invalid_log_page_offset(i64 noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @find_first_bit(ptr noundef %addr, i64 noundef %size) #0 {
entry:
  %retval = alloca i64, align 8
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %result = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 0, ptr %result, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %result, align 8
  %1 = load i64, ptr %size.addr, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %addr.addr, align 8
  %incdec.ptr = getelementptr i64, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %addr.addr, align 8
  %3 = load i64, ptr %2, align 8
  store i64 %3, ptr %tmp, align 8
  %4 = load i64, ptr %tmp, align 8
  %tobool = icmp ne i64 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %5 = load i64, ptr %tmp, align 8
  %call = call i32 @ctz64(i64 noundef %5)
  %conv = sext i32 %call to i64
  %6 = load i64, ptr %result, align 8
  %add = add i64 %6, %conv
  store i64 %add, ptr %result, align 8
  %7 = load i64, ptr %result, align 8
  %8 = load i64, ptr %size.addr, align 8
  %cmp1 = icmp ult i64 %7, %8
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %9 = load i64, ptr %result, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %10 = load i64, ptr %size.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %9, %cond.true ], [ %10, %cond.false ]
  store i64 %cond, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %11 = load i64, ptr %result, align 8
  %add3 = add i64 %11, 64
  store i64 %add3, ptr %result, align 8
  br label %for.cond, !llvm.loop !57

for.end:                                          ; preds = %for.cond
  %12 = load i64, ptr %size.addr, align 8
  store i64 %12, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %cond.end
  %13 = load i64, ptr %retval, align 8
  ret i64 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @clear_bit(i64 noundef %nr, ptr noundef %addr) #0 {
entry:
  %nr.addr = alloca i64, align 8
  %addr.addr = alloca ptr, align 8
  %mask = alloca i64, align 8
  %p = alloca ptr, align 8
  store i64 %nr, ptr %nr.addr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  %0 = load i64, ptr %nr.addr, align 8
  %rem = urem i64 %0, 64
  %shl = shl i64 1, %rem
  store i64 %shl, ptr %mask, align 8
  %1 = load ptr, ptr %addr.addr, align 8
  %2 = load i64, ptr %nr.addr, align 8
  %div = udiv i64 %2, 64
  %add.ptr = getelementptr i64, ptr %1, i64 %div
  store ptr %add.ptr, ptr %p, align 8
  %3 = load i64, ptr %mask, align 8
  %not = xor i64 %3, -1
  %4 = load ptr, ptr %p, align 8
  %5 = load i64, ptr %4, align 8
  %and = and i64 %5, %not
  store i64 %and, ptr %4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bitmap_zero(ptr noundef %dst, i64 noundef %nbits) #0 {
entry:
  %dst.addr = alloca ptr, align 8
  %nbits.addr = alloca i64, align 8
  %len = alloca i64, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i64 %nbits, ptr %nbits.addr, align 8
  %0 = load i64, ptr %nbits.addr, align 8
  %cmp = icmp ule i64 %0, 64
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %dst.addr, align 8
  store i64 0, ptr %1, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %nbits.addr, align 8
  %add = add i64 %2, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %mul = mul i64 %div, 8
  store i64 %mul, ptr %len, align 8
  %3 = load ptr, ptr %dst.addr, align 8
  %4 = load i64, ptr %len, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %3, i8 0, i64 %4, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_log_page_offset(i64 noundef %ofs, i64 noundef %size) #0 {
entry:
  %ofs.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %ofs, ptr %ofs.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %ofs.addr, align 8
  %6 = load i64, ptr %size.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.333, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %ofs.addr, align 8
  %8 = load i64, ptr %size.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.334, i64 noundef %7, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ctz64(i64 noundef %val) #0 {
entry:
  %val.addr = alloca i64, align 8
  store i64 %val, ptr %val.addr, align 8
  %0 = load i64, ptr %val.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %val.addr, align 8
  %2 = call i64 @llvm.cttz.i64(i64 %1, i1 true)
  %cast = trunc i64 %2 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %cast, %cond.true ], [ 64, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.cttz.i64(i64, i1 immarg) #7

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_subsys_ns(ptr noundef %subsys, i32 noundef %nsid) #0 {
entry:
  %retval = alloca ptr, align 8
  %subsys.addr = alloca ptr, align 8
  %nsid.addr = alloca i32, align 4
  store ptr %subsys, ptr %subsys.addr, align 8
  store i32 %nsid, ptr %nsid.addr, align 4
  %0 = load ptr, ptr %subsys.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %nsid.addr, align 4
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %lor.lhs.false2, label %if.then

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, ptr %nsid.addr, align 4
  %cmp = icmp ugt i32 %2, 256
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  %3 = load ptr, ptr %subsys.addr, align 8
  %namespaces = getelementptr inbounds %struct.NvmeSubsystem, ptr %3, i32 0, i32 5
  %4 = load i32, ptr %nsid.addr, align 4
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [257 x ptr], ptr %namespaces, i64 0, i64 %idxprom
  %5 = load ptr, ptr %arrayidx, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @sizeof_fdp_conf_descr(i64 noundef %nruh, i64 noundef %vss) #0 {
entry:
  %nruh.addr = alloca i64, align 8
  %vss.addr = alloca i64, align 8
  %entry_siz = alloca i64, align 8
  store i64 %nruh, ptr %nruh.addr, align 8
  store i64 %vss, ptr %vss.addr, align 8
  %0 = load i64, ptr %nruh.addr, align 8
  %mul = mul i64 %0, 4
  %add = add i64 64, %mul
  %1 = load i64, ptr %vss.addr, align 8
  %add1 = add i64 %add, %1
  store i64 %add1, ptr %entry_siz, align 8
  %2 = load i64, ptr %entry_siz, align 8
  %add2 = add i64 %2, 8
  %sub = sub i64 %add2, 1
  %and = and i64 %sub, -8
  ret i64 %and
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @deposit32(i32 noundef %value, i32 noundef %start, i32 noundef %length, i32 noundef %fieldval) #0 {
entry:
  %value.addr = alloca i32, align 4
  %start.addr = alloca i32, align 4
  %length.addr = alloca i32, align 4
  %fieldval.addr = alloca i32, align 4
  %mask = alloca i32, align 4
  store i32 %value, ptr %value.addr, align 4
  store i32 %start, ptr %start.addr, align 4
  store i32 %length, ptr %length.addr, align 4
  store i32 %fieldval, ptr %fieldval.addr, align 4
  %0 = load i32, ptr %start.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %length.addr, align 4
  %cmp1 = icmp sgt i32 %1, 0
  br i1 %cmp1, label %land.lhs.true2, label %if.else

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i32, ptr %length.addr, align 4
  %3 = load i32, ptr %start.addr, align 4
  %sub = sub i32 32, %3
  %cmp3 = icmp sle i32 %2, %sub
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true2
  br label %if.end

if.else:                                          ; preds = %land.lhs.true2, %land.lhs.true, %entry
  call void @__assert_fail(ptr noundef @.str.337, ptr noundef @.str.338, i32 noundef 470, ptr noundef @__PRETTY_FUNCTION__.deposit32) #12
  unreachable

if.end:                                           ; preds = %if.then
  %4 = load i32, ptr %length.addr, align 4
  %sub4 = sub i32 32, %4
  %shr = lshr i32 -1, %sub4
  %5 = load i32, ptr %start.addr, align 4
  %shl = shl i32 %shr, %5
  store i32 %shl, ptr %mask, align 4
  %6 = load i32, ptr %value.addr, align 4
  %7 = load i32, ptr %mask, align 4
  %not = xor i32 %7, -1
  %and = and i32 %6, %not
  %8 = load i32, ptr %fieldval.addr, align 4
  %9 = load i32, ptr %start.addr, align 4
  %shl5 = shl i32 %8, %9
  %10 = load i32, ptr %mask, align 4
  %and6 = and i32 %shl5, %10
  %or = or i32 %and, %and6
  ret i32 %or
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_log_page(i16 noundef zeroext %cid, i16 noundef zeroext %lid) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %lid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i16 %lid, ptr %lid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i16, ptr %lid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.339, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %cid.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i16, ptr %lid.addr, align 2
  %conv14 = zext i16 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.340, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_del_cq_cqid(i16 noundef zeroext %cqid) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  %0 = load i16, ptr %cqid.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_del_cq_cqid(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_del_cq_notempty(i16 noundef zeroext %cqid) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  %0 = load i16, ptr %cqid.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_del_cq_notempty(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_del_cq(i16 noundef zeroext %cqid) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  %0 = load i16, ptr %cqid.addr, align 2
  call void @_nocheck__trace_pci_nvme_del_cq(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_free_cq(ptr noundef %cq, ptr noundef %n) #0 {
entry:
  %cq.addr = alloca ptr, align 8
  %n.addr = alloca ptr, align 8
  %pci = alloca ptr, align 8
  %offset = alloca i16, align 2
  store ptr %cq, ptr %cq.addr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %0)
  store ptr %call, ptr %pci, align 8
  %1 = load ptr, ptr %cq.addr, align 8
  %cqid = getelementptr inbounds %struct.NvmeCQueue, ptr %1, i32 0, i32 2
  %2 = load i16, ptr %cqid, align 2
  %conv = zext i16 %2 to i32
  %shl = shl i32 %conv, 3
  %add = add i32 %shl, 4
  %conv1 = trunc i32 %add to i16
  store i16 %conv1, ptr %offset, align 2
  %3 = load ptr, ptr %n.addr, align 8
  %cq2 = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 37
  %4 = load ptr, ptr %cq2, align 8
  %5 = load ptr, ptr %cq.addr, align 8
  %cqid3 = getelementptr inbounds %struct.NvmeCQueue, ptr %5, i32 0, i32 2
  %6 = load i16, ptr %cqid3, align 2
  %idxprom = zext i16 %6 to i64
  %arrayidx = getelementptr ptr, ptr %4, i64 %idxprom
  store ptr null, ptr %arrayidx, align 8
  %7 = load ptr, ptr %cq.addr, align 8
  %bh = getelementptr inbounds %struct.NvmeCQueue, ptr %7, i32 0, i32 11
  %8 = load ptr, ptr %bh, align 8
  call void @qemu_bh_delete(ptr noundef %8)
  %9 = load ptr, ptr %cq.addr, align 8
  %ioeventfd_enabled = getelementptr inbounds %struct.NvmeCQueue, ptr %9, i32 0, i32 13
  %10 = load i8, ptr %ioeventfd_enabled, align 4
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load ptr, ptr %n.addr, align 8
  %iomem = getelementptr inbounds %struct.NvmeCtrl, ptr %11, i32 0, i32 2
  %12 = load i16, ptr %offset, align 2
  %conv4 = zext i16 %12 to i32
  %add5 = add i32 4096, %conv4
  %conv6 = sext i32 %add5 to i64
  %13 = load ptr, ptr %cq.addr, align 8
  %notifier = getelementptr inbounds %struct.NvmeCQueue, ptr %13, i32 0, i32 12
  call void @memory_region_del_eventfd(ptr noundef %iomem, i64 noundef %conv6, i32 noundef 4, i1 noundef zeroext false, i64 noundef 0, ptr noundef %notifier)
  %14 = load ptr, ptr %cq.addr, align 8
  %notifier7 = getelementptr inbounds %struct.NvmeCQueue, ptr %14, i32 0, i32 12
  call void @event_notifier_set_handler(ptr noundef %notifier7, ptr noundef null)
  %15 = load ptr, ptr %cq.addr, align 8
  %notifier8 = getelementptr inbounds %struct.NvmeCQueue, ptr %15, i32 0, i32 12
  call void @event_notifier_cleanup(ptr noundef %notifier8)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %16 = load ptr, ptr %pci, align 8
  %call9 = call i32 @msix_enabled(ptr noundef %16)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end
  %17 = load ptr, ptr %pci, align 8
  %18 = load ptr, ptr %cq.addr, align 8
  %vector = getelementptr inbounds %struct.NvmeCQueue, ptr %18, i32 0, i32 6
  %19 = load i32, ptr %vector, align 8
  call void @msix_vector_unuse(ptr noundef %17, i32 noundef %19)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end
  %20 = load ptr, ptr %cq.addr, align 8
  %cqid13 = getelementptr inbounds %struct.NvmeCQueue, ptr %20, i32 0, i32 2
  %21 = load i16, ptr %cqid13, align 2
  %tobool14 = icmp ne i16 %21, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end12
  %22 = load ptr, ptr %cq.addr, align 8
  call void @g_free(ptr noundef %22)
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.end12
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_del_cq_cqid(i16 noundef zeroext %cqid) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cqid, ptr %cqid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cqid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.341, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %cqid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.342, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_del_cq_notempty(i16 noundef zeroext %cqid) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cqid, ptr %cqid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cqid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.343, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %cqid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.344, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_del_cq(i16 noundef zeroext %cqid) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cqid, ptr %cqid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_DEL_CQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cqid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.345, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %cqid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.346, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

declare void @msix_vector_unuse(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_create_cq(i64 noundef %addr, i16 noundef zeroext %cqid, i16 noundef zeroext %vector, i16 noundef zeroext %size, i16 noundef zeroext %qflags, i32 noundef %ien) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %cqid.addr = alloca i16, align 2
  %vector.addr = alloca i16, align 2
  %size.addr = alloca i16, align 2
  %qflags.addr = alloca i16, align 2
  %ien.addr = alloca i32, align 4
  store i64 %addr, ptr %addr.addr, align 8
  store i16 %cqid, ptr %cqid.addr, align 2
  store i16 %vector, ptr %vector.addr, align 2
  store i16 %size, ptr %size.addr, align 2
  store i16 %qflags, ptr %qflags.addr, align 2
  store i32 %ien, ptr %ien.addr, align 4
  %0 = load i64, ptr %addr.addr, align 8
  %1 = load i16, ptr %cqid.addr, align 2
  %2 = load i16, ptr %vector.addr, align 2
  %3 = load i16, ptr %size.addr, align 2
  %4 = load i16, ptr %qflags.addr, align 2
  %5 = load i32, ptr %ien.addr, align 4
  call void @_nocheck__trace_pci_nvme_create_cq(i64 noundef %0, i16 noundef zeroext %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i16 noundef zeroext %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_create_cq_entry_size(i8 noundef zeroext %iosqes, i8 noundef zeroext %iocqes) #0 {
entry:
  %iosqes.addr = alloca i8, align 1
  %iocqes.addr = alloca i8, align 1
  store i8 %iosqes, ptr %iosqes.addr, align 1
  store i8 %iocqes, ptr %iocqes.addr, align 1
  %0 = load i8, ptr %iosqes.addr, align 1
  %1 = load i8, ptr %iocqes.addr, align 1
  call void @_nocheck__trace_pci_nvme_err_invalid_create_cq_entry_size(i8 noundef zeroext %0, i8 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_create_cq_cqid(i16 noundef zeroext %cqid) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  %0 = load i16, ptr %cqid.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_create_cq_cqid(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_create_cq_size(i16 noundef zeroext %size) #0 {
entry:
  %size.addr = alloca i16, align 2
  store i16 %size, ptr %size.addr, align 2
  %0 = load i16, ptr %size.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_create_cq_size(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_create_cq_addr(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i64, ptr %addr.addr, align 8
  call void @_nocheck__trace_pci_nvme_err_invalid_create_cq_addr(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_create_cq_vector(i16 noundef zeroext %vector) #0 {
entry:
  %vector.addr = alloca i16, align 2
  store i16 %vector, ptr %vector.addr, align 2
  %0 = load i16, ptr %vector.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_create_cq_vector(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_create_cq_qflags(i16 noundef zeroext %qflags) #0 {
entry:
  %qflags.addr = alloca i16, align 2
  store i16 %qflags, ptr %qflags.addr, align 2
  %0 = load i16, ptr %qflags.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_create_cq_qflags(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_create_cq(i64 noundef %addr, i16 noundef zeroext %cqid, i16 noundef zeroext %vector, i16 noundef zeroext %size, i16 noundef zeroext %qflags, i32 noundef %ien) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %cqid.addr = alloca i16, align 2
  %vector.addr = alloca i16, align 2
  %size.addr = alloca i16, align 2
  %qflags.addr = alloca i16, align 2
  %ien.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i16 %cqid, ptr %cqid.addr, align 2
  store i16 %vector, ptr %vector.addr, align 2
  store i16 %size, ptr %size.addr, align 2
  store i16 %qflags, ptr %qflags.addr, align 2
  store i32 %ien, ptr %ien.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_CREATE_CQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end19

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  %6 = load i16, ptr %cqid.addr, align 2
  %conv11 = zext i16 %6 to i32
  %7 = load i16, ptr %vector.addr, align 2
  %conv12 = zext i16 %7 to i32
  %8 = load i16, ptr %size.addr, align 2
  %conv13 = zext i16 %8 to i32
  %9 = load i16, ptr %qflags.addr, align 2
  %conv14 = zext i16 %9 to i32
  %10 = load i32, ptr %ien.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.347, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef %conv11, i32 noundef %conv12, i32 noundef %conv13, i32 noundef %conv14, i32 noundef %10)
  br label %if.end

if.else:                                          ; preds = %if.then
  %11 = load i64, ptr %addr.addr, align 8
  %12 = load i16, ptr %cqid.addr, align 2
  %conv15 = zext i16 %12 to i32
  %13 = load i16, ptr %vector.addr, align 2
  %conv16 = zext i16 %13 to i32
  %14 = load i16, ptr %size.addr, align 2
  %conv17 = zext i16 %14 to i32
  %15 = load i16, ptr %qflags.addr, align 2
  %conv18 = zext i16 %15 to i32
  %16 = load i32, ptr %ien.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.348, i64 noundef %11, i32 noundef %conv15, i32 noundef %conv16, i32 noundef %conv17, i32 noundef %conv18, i32 noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end19

if.end19:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_create_cq_entry_size(i8 noundef zeroext %iosqes, i8 noundef zeroext %iocqes) #0 {
entry:
  %iosqes.addr = alloca i8, align 1
  %iocqes.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %iosqes, ptr %iosqes.addr, align 1
  store i8 %iocqes, ptr %iocqes.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ENTRY_SIZE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %iosqes.addr, align 1
  %conv11 = zext i8 %5 to i32
  %6 = load i8, ptr %iocqes.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.349, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i8, ptr %iosqes.addr, align 1
  %conv13 = zext i8 %7 to i32
  %8 = load i8, ptr %iocqes.addr, align 1
  %conv14 = zext i8 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.350, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_create_cq_cqid(i16 noundef zeroext %cqid) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cqid, ptr %cqid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cqid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.351, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %cqid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.352, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_create_cq_size(i16 noundef zeroext %size) #0 {
entry:
  %size.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %size, ptr %size.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %size.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.353, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %size.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.354, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_create_cq_addr(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %addr, ptr %addr.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.355, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.356, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_create_cq_vector(i16 noundef zeroext %vector) #0 {
entry:
  %vector.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %vector, ptr %vector.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %vector.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.357, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %vector.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.358, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_create_cq_qflags(i16 noundef zeroext %qflags) #0 {
entry:
  %qflags.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %qflags, ptr %qflags.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %qflags.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.359, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %qflags.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.360, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_identify(i16 noundef zeroext %cid, i8 noundef zeroext %cns, i16 noundef zeroext %ctrlid, i8 noundef zeroext %csi) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %cns.addr = alloca i8, align 1
  %ctrlid.addr = alloca i16, align 2
  %csi.addr = alloca i8, align 1
  store i16 %cid, ptr %cid.addr, align 2
  store i8 %cns, ptr %cns.addr, align 1
  store i16 %ctrlid, ptr %ctrlid.addr, align 2
  store i8 %csi, ptr %csi.addr, align 1
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i8, ptr %cns.addr, align 1
  %2 = load i16, ptr %ctrlid.addr, align 2
  %3 = load i8, ptr %csi.addr, align 1
  call void @_nocheck__trace_pci_nvme_identify(i16 noundef zeroext %0, i8 noundef zeroext %1, i16 noundef zeroext %2, i8 noundef zeroext %3)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_identify_ns(ptr noundef %n, ptr noundef %req, i1 noundef zeroext %active) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %active.addr = alloca i8, align 1
  %ns = alloca ptr, align 8
  %c = alloca ptr, align 8
  %nsid = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %frombool = zext i1 %active to i8
  store i8 %frombool, ptr %active.addr, align 1
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %nsid1 = getelementptr inbounds %struct.NvmeIdentify, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %nsid1, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %nsid, align 4
  %3 = load i32, ptr %nsid, align 4
  call void @trace_pci_nvme_identify_ns(i32 noundef %3)
  %4 = load ptr, ptr %n.addr, align 8
  %5 = load i32, ptr %nsid, align 4
  %call2 = call zeroext i1 @nvme_nsid_valid(ptr noundef %4, i32 noundef %5)
  br i1 %call2, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %6 = load i32, ptr %nsid, align 4
  %cmp = icmp eq i32 %6, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i16 16395, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %7 = load ptr, ptr %n.addr, align 8
  %8 = load i32, ptr %nsid, align 4
  %call3 = call ptr @nvme_ns(ptr noundef %7, i32 noundef %8)
  store ptr %call3, ptr %ns, align 8
  %9 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %9, null
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then7, label %if.end17

if.then7:                                         ; preds = %if.end
  %10 = load i8, ptr %active.addr, align 1
  %tobool8 = trunc i8 %10 to i1
  br i1 %tobool8, label %if.else, label %if.then9

if.then9:                                         ; preds = %if.then7
  %11 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %11, i32 0, i32 33
  %12 = load ptr, ptr %subsys, align 8
  %13 = load i32, ptr %nsid, align 4
  %call10 = call ptr @nvme_subsys_ns(ptr noundef %12, i32 noundef %13)
  store ptr %call10, ptr %ns, align 8
  %14 = load ptr, ptr %ns, align 8
  %tobool11 = icmp ne ptr %14, null
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.then9
  %15 = load ptr, ptr %n.addr, align 8
  %16 = load ptr, ptr %req.addr, align 8
  %call13 = call zeroext i16 @nvme_rpt_empty_id_struct(ptr noundef %15, ptr noundef %16)
  store i16 %call13, ptr %retval, align 2
  br label %return

if.end14:                                         ; preds = %if.then9
  br label %if.end16

if.else:                                          ; preds = %if.then7
  %17 = load ptr, ptr %n.addr, align 8
  %18 = load ptr, ptr %req.addr, align 8
  %call15 = call zeroext i16 @nvme_rpt_empty_id_struct(ptr noundef %17, ptr noundef %18)
  store i16 %call15, ptr %retval, align 2
  br label %return

if.end16:                                         ; preds = %if.end14
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end
  %19 = load i8, ptr %active.addr, align 1
  %tobool18 = trunc i8 %19 to i1
  br i1 %tobool18, label %if.then24, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %if.end17
  %20 = load ptr, ptr %ns, align 8
  %csi = getelementptr inbounds %struct.NvmeNamespace, ptr %20, i32 0, i32 11
  %21 = load i8, ptr %csi, align 8
  %conv21 = zext i8 %21 to i32
  %cmp22 = icmp eq i32 %conv21, 0
  br i1 %cmp22, label %if.then24, label %if.end26

if.then24:                                        ; preds = %lor.lhs.false20, %if.end17
  %22 = load ptr, ptr %n.addr, align 8
  %23 = load ptr, ptr %ns, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %23, i32 0, i32 5
  %24 = load ptr, ptr %req.addr, align 8
  %call25 = call zeroext i16 @nvme_c2h(ptr noundef %22, ptr noundef %id_ns, i32 noundef 4096, ptr noundef %24)
  store i16 %call25, ptr %retval, align 2
  br label %return

if.end26:                                         ; preds = %lor.lhs.false20
  store i16 16428, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end26, %if.then24, %if.else, %if.then12, %if.then
  %25 = load i16, ptr %retval, align 2
  ret i16 %25
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_identify_ctrl_list(ptr noundef %n, ptr noundef %req, i1 noundef zeroext %attached) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %attached.addr = alloca i8, align 1
  %c = alloca ptr, align 8
  %nsid = alloca i32, align 4
  %min_id = alloca i16, align 2
  %list = alloca [2048 x i16], align 16
  %ids = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %ctrl = alloca ptr, align 8
  %cntlid = alloca i32, align 4
  %nr_ids = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %frombool = zext i1 %attached to i8
  store i8 %frombool, ptr %attached.addr, align 1
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %nsid1 = getelementptr inbounds %struct.NvmeIdentify, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %nsid1, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %nsid, align 4
  %3 = load ptr, ptr %c, align 8
  %ctrlid = getelementptr inbounds %struct.NvmeIdentify, ptr %3, i32 0, i32 9
  %4 = load i16, ptr %ctrlid, align 1
  %call2 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %4)
  store i16 %call2, ptr %min_id, align 2
  call void @llvm.memset.p0.i64(ptr align 16 %list, i8 0, i64 4096, i1 false)
  %arrayidx = getelementptr [2048 x i16], ptr %list, i64 0, i64 1
  store ptr %arrayidx, ptr %ids, align 8
  store i32 0, ptr %nr_ids, align 4
  %5 = load ptr, ptr %c, align 8
  %cns = getelementptr inbounds %struct.NvmeIdentify, ptr %5, i32 0, i32 7
  %6 = load i8, ptr %cns, align 1
  %7 = load i16, ptr %min_id, align 2
  call void @trace_pci_nvme_identify_ctrl_list(i8 noundef zeroext %6, i16 noundef zeroext %7)
  %8 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 33
  %9 = load ptr, ptr %subsys, align 8
  %tobool = icmp ne ptr %9, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 16386, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i8, ptr %attached.addr, align 1
  %tobool3 = trunc i8 %10 to i1
  br i1 %tobool3, label %if.then4, label %if.end12

if.then4:                                         ; preds = %if.end
  %11 = load i32, ptr %nsid, align 4
  %cmp = icmp eq i32 %11, -1
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then4
  store i16 16386, ptr %retval, align 2
  br label %return

if.end6:                                          ; preds = %if.then4
  %12 = load ptr, ptr %n.addr, align 8
  %subsys7 = getelementptr inbounds %struct.NvmeCtrl, ptr %12, i32 0, i32 33
  %13 = load ptr, ptr %subsys7, align 8
  %14 = load i32, ptr %nsid, align 4
  %call8 = call ptr @nvme_subsys_ns(ptr noundef %13, i32 noundef %14)
  store ptr %call8, ptr %ns, align 8
  %15 = load ptr, ptr %ns, align 8
  %tobool9 = icmp ne ptr %15, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end6
  store i16 16386, ptr %retval, align 2
  br label %return

if.end11:                                         ; preds = %if.end6
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end
  %16 = load i16, ptr %min_id, align 2
  %conv = zext i16 %16 to i32
  store i32 %conv, ptr %cntlid, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end12
  %17 = load i32, ptr %cntlid, align 4
  %conv13 = sext i32 %17 to i64
  %cmp14 = icmp ult i64 %conv13, 256
  br i1 %cmp14, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load ptr, ptr %n.addr, align 8
  %subsys16 = getelementptr inbounds %struct.NvmeCtrl, ptr %18, i32 0, i32 33
  %19 = load ptr, ptr %subsys16, align 8
  %20 = load i32, ptr %cntlid, align 4
  %call17 = call ptr @nvme_subsys_ctrl(ptr noundef %19, i32 noundef %20)
  store ptr %call17, ptr %ctrl, align 8
  %21 = load ptr, ptr %ctrl, align 8
  %tobool18 = icmp ne ptr %21, null
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %for.body
  br label %for.inc

if.end20:                                         ; preds = %for.body
  %22 = load i8, ptr %attached.addr, align 1
  %tobool21 = trunc i8 %22 to i1
  br i1 %tobool21, label %land.lhs.true, label %if.end26

land.lhs.true:                                    ; preds = %if.end20
  %23 = load ptr, ptr %ctrl, align 8
  %24 = load i32, ptr %nsid, align 4
  %call23 = call ptr @nvme_ns(ptr noundef %23, i32 noundef %24)
  %tobool24 = icmp ne ptr %call23, null
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %land.lhs.true
  br label %for.inc

if.end26:                                         ; preds = %land.lhs.true, %if.end20
  %25 = load i32, ptr %cntlid, align 4
  %conv27 = trunc i32 %25 to i16
  %26 = load ptr, ptr %ids, align 8
  %27 = load i32, ptr %nr_ids, align 4
  %inc = add i32 %27, 1
  store i32 %inc, ptr %nr_ids, align 4
  %idxprom = sext i32 %27 to i64
  %arrayidx28 = getelementptr i16, ptr %26, i64 %idxprom
  store i16 %conv27, ptr %arrayidx28, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end26, %if.then25, %if.then19
  %28 = load i32, ptr %cntlid, align 4
  %inc29 = add i32 %28, 1
  store i32 %inc29, ptr %cntlid, align 4
  br label %for.cond, !llvm.loop !58

for.end:                                          ; preds = %for.cond
  %29 = load i32, ptr %nr_ids, align 4
  %conv30 = trunc i32 %29 to i16
  %arrayidx31 = getelementptr [2048 x i16], ptr %list, i64 0, i64 0
  store i16 %conv30, ptr %arrayidx31, align 16
  %30 = load ptr, ptr %n.addr, align 8
  %arraydecay = getelementptr inbounds [2048 x i16], ptr %list, i64 0, i64 0
  %31 = load ptr, ptr %req.addr, align 8
  %call32 = call zeroext i16 @nvme_c2h(ptr noundef %30, ptr noundef %arraydecay, i32 noundef 4096, ptr noundef %31)
  store i16 %call32, ptr %retval, align 2
  br label %return

return:                                           ; preds = %for.end, %if.then10, %if.then5, %if.then
  %32 = load i16, ptr %retval, align 2
  ret i16 %32
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_identify_pri_ctrl_cap(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 42
  %cntlid = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap, i32 0, i32 0
  %1 = load i16, ptr %cntlid, align 8
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %1)
  call void @trace_pci_nvme_identify_pri_ctrl_cap(i16 noundef zeroext %call)
  %2 = load ptr, ptr %n.addr, align 8
  %3 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap1 = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 42
  %4 = load ptr, ptr %req.addr, align 8
  %call2 = call zeroext i16 @nvme_c2h(ptr noundef %2, ptr noundef %pri_ctrl_cap1, i32 noundef 4096, ptr noundef %4)
  ret i16 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_identify_sec_ctrl_list(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %pri_ctrl_id = alloca i16, align 2
  %min_id = alloca i16, align 2
  %num_sec_ctrl = alloca i8, align 1
  %list = alloca %struct.NvmeSecCtrlList, align 1
  %i = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 42
  %cntlid = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap, i32 0, i32 0
  %2 = load i16, ptr %cntlid, align 8
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %2)
  store i16 %call, ptr %pri_ctrl_id, align 2
  %3 = load ptr, ptr %c, align 8
  %ctrlid = getelementptr inbounds %struct.NvmeIdentify, ptr %3, i32 0, i32 9
  %4 = load i16, ptr %ctrlid, align 1
  %call1 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %4)
  store i16 %call1, ptr %min_id, align 2
  %5 = load ptr, ptr %n.addr, align 8
  %sec_ctrl_list = getelementptr inbounds %struct.NvmeCtrl, ptr %5, i32 0, i32 43
  %numcntl = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %sec_ctrl_list, i32 0, i32 0
  %6 = load i8, ptr %numcntl, align 8
  store i8 %6, ptr %num_sec_ctrl, align 1
  call void @llvm.memset.p0.i64(ptr align 1 %list, i8 0, i64 4096, i1 false)
  store i8 0, ptr %i, align 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i8, ptr %i, align 1
  %conv = zext i8 %7 to i32
  %8 = load i8, ptr %num_sec_ctrl, align 1
  %conv2 = zext i8 %8 to i32
  %cmp = icmp slt i32 %conv, %conv2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %n.addr, align 8
  %sec_ctrl_list4 = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 43
  %sec = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %sec_ctrl_list4, i32 0, i32 2
  %10 = load i8, ptr %i, align 1
  %idxprom = zext i8 %10 to i64
  %arrayidx = getelementptr [127 x %struct.NvmeSecCtrlEntry], ptr %sec, i64 0, i64 %idxprom
  %scid = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %arrayidx, i32 0, i32 0
  %11 = load i16, ptr %scid, align 8
  %conv5 = zext i16 %11 to i32
  %12 = load i16, ptr %min_id, align 2
  %conv6 = zext i16 %12 to i32
  %cmp7 = icmp sge i32 %conv5, %conv6
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %13 = load i8, ptr %num_sec_ctrl, align 1
  %conv9 = zext i8 %13 to i32
  %14 = load i8, ptr %i, align 1
  %conv10 = zext i8 %14 to i32
  %sub = sub i32 %conv9, %conv10
  %conv11 = trunc i32 %sub to i8
  %numcntl12 = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %list, i32 0, i32 0
  store i8 %conv11, ptr %numcntl12, align 1
  %sec13 = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %list, i32 0, i32 2
  %15 = load ptr, ptr %n.addr, align 8
  %sec_ctrl_list14 = getelementptr inbounds %struct.NvmeCtrl, ptr %15, i32 0, i32 43
  %sec15 = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %sec_ctrl_list14, i32 0, i32 2
  %arraydecay = getelementptr inbounds [127 x %struct.NvmeSecCtrlEntry], ptr %sec15, i64 0, i64 0
  %16 = load i8, ptr %i, align 1
  %conv16 = zext i8 %16 to i32
  %idx.ext = sext i32 %conv16 to i64
  %add.ptr = getelementptr %struct.NvmeSecCtrlEntry, ptr %arraydecay, i64 %idx.ext
  %numcntl17 = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %list, i32 0, i32 0
  %17 = load i8, ptr %numcntl17, align 1
  %conv18 = zext i8 %17 to i64
  %mul = mul i64 %conv18, 32
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %sec13, ptr align 1 %add.ptr, i64 %mul, i1 false)
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %18 = load i8, ptr %i, align 1
  %inc = add i8 %18, 1
  store i8 %inc, ptr %i, align 1
  br label %for.cond, !llvm.loop !59

for.end:                                          ; preds = %if.then, %for.cond
  %19 = load i16, ptr %pri_ctrl_id, align 2
  %numcntl19 = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %list, i32 0, i32 0
  %20 = load i8, ptr %numcntl19, align 1
  call void @trace_pci_nvme_identify_sec_ctrl_list(i16 noundef zeroext %19, i8 noundef zeroext %20)
  %21 = load ptr, ptr %n.addr, align 8
  %22 = load ptr, ptr %req.addr, align 8
  %call20 = call zeroext i16 @nvme_c2h(ptr noundef %21, ptr noundef %list, i32 noundef 4096, ptr noundef %22)
  ret i16 %call20
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_identify_ns_csi(ptr noundef %n, ptr noundef %req, i1 noundef zeroext %active) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %active.addr = alloca i8, align 1
  %ns = alloca ptr, align 8
  %c = alloca ptr, align 8
  %nsid = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %frombool = zext i1 %active to i8
  store i8 %frombool, ptr %active.addr, align 1
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %nsid1 = getelementptr inbounds %struct.NvmeIdentify, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %nsid1, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %nsid, align 4
  %3 = load i32, ptr %nsid, align 4
  %4 = load ptr, ptr %c, align 8
  %csi = getelementptr inbounds %struct.NvmeIdentify, ptr %4, i32 0, i32 12
  %5 = load i8, ptr %csi, align 1
  call void @trace_pci_nvme_identify_ns_csi(i32 noundef %3, i8 noundef zeroext %5)
  %6 = load ptr, ptr %n.addr, align 8
  %7 = load i32, ptr %nsid, align 4
  %call2 = call zeroext i1 @nvme_nsid_valid(ptr noundef %6, i32 noundef %7)
  br i1 %call2, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %8 = load i32, ptr %nsid, align 4
  %cmp = icmp eq i32 %8, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i16 16395, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %9 = load ptr, ptr %n.addr, align 8
  %10 = load i32, ptr %nsid, align 4
  %call3 = call ptr @nvme_ns(ptr noundef %9, i32 noundef %10)
  store ptr %call3, ptr %ns, align 8
  %11 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %11, null
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then7, label %if.end17

if.then7:                                         ; preds = %if.end
  %12 = load i8, ptr %active.addr, align 1
  %tobool8 = trunc i8 %12 to i1
  br i1 %tobool8, label %if.else, label %if.then9

if.then9:                                         ; preds = %if.then7
  %13 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %13, i32 0, i32 33
  %14 = load ptr, ptr %subsys, align 8
  %15 = load i32, ptr %nsid, align 4
  %call10 = call ptr @nvme_subsys_ns(ptr noundef %14, i32 noundef %15)
  store ptr %call10, ptr %ns, align 8
  %16 = load ptr, ptr %ns, align 8
  %tobool11 = icmp ne ptr %16, null
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.then9
  %17 = load ptr, ptr %n.addr, align 8
  %18 = load ptr, ptr %req.addr, align 8
  %call13 = call zeroext i16 @nvme_rpt_empty_id_struct(ptr noundef %17, ptr noundef %18)
  store i16 %call13, ptr %retval, align 2
  br label %return

if.end14:                                         ; preds = %if.then9
  br label %if.end16

if.else:                                          ; preds = %if.then7
  %19 = load ptr, ptr %n.addr, align 8
  %20 = load ptr, ptr %req.addr, align 8
  %call15 = call zeroext i16 @nvme_rpt_empty_id_struct(ptr noundef %19, ptr noundef %20)
  store i16 %call15, ptr %retval, align 2
  br label %return

if.end16:                                         ; preds = %if.end14
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end
  %21 = load ptr, ptr %c, align 8
  %csi18 = getelementptr inbounds %struct.NvmeIdentify, ptr %21, i32 0, i32 12
  %22 = load i8, ptr %csi18, align 1
  %conv19 = zext i8 %22 to i32
  %cmp20 = icmp eq i32 %conv19, 0
  br i1 %cmp20, label %if.then22, label %if.else24

if.then22:                                        ; preds = %if.end17
  %23 = load ptr, ptr %n.addr, align 8
  %24 = load ptr, ptr %ns, align 8
  %id_ns_nvm = getelementptr inbounds %struct.NvmeNamespace, ptr %24, i32 0, i32 6
  %25 = load ptr, ptr %req.addr, align 8
  %call23 = call zeroext i16 @nvme_c2h(ptr noundef %23, ptr noundef %id_ns_nvm, i32 noundef 4096, ptr noundef %25)
  store i16 %call23, ptr %retval, align 2
  br label %return

if.else24:                                        ; preds = %if.end17
  %26 = load ptr, ptr %c, align 8
  %csi25 = getelementptr inbounds %struct.NvmeIdentify, ptr %26, i32 0, i32 12
  %27 = load i8, ptr %csi25, align 1
  %conv26 = zext i8 %27 to i32
  %cmp27 = icmp eq i32 %conv26, 2
  br i1 %cmp27, label %land.lhs.true, label %if.end35

land.lhs.true:                                    ; preds = %if.else24
  %28 = load ptr, ptr %ns, align 8
  %csi29 = getelementptr inbounds %struct.NvmeNamespace, ptr %28, i32 0, i32 11
  %29 = load i8, ptr %csi29, align 8
  %conv30 = zext i8 %29 to i32
  %cmp31 = icmp eq i32 %conv30, 2
  br i1 %cmp31, label %if.then33, label %if.end35

if.then33:                                        ; preds = %land.lhs.true
  %30 = load ptr, ptr %n.addr, align 8
  %31 = load ptr, ptr %ns, align 8
  %id_ns_zoned = getelementptr inbounds %struct.NvmeNamespace, ptr %31, i32 0, i32 17
  %32 = load ptr, ptr %id_ns_zoned, align 8
  %33 = load ptr, ptr %req.addr, align 8
  %call34 = call zeroext i16 @nvme_c2h(ptr noundef %30, ptr noundef %32, i32 noundef 4096, ptr noundef %33)
  store i16 %call34, ptr %retval, align 2
  br label %return

if.end35:                                         ; preds = %land.lhs.true, %if.else24
  br label %if.end36

if.end36:                                         ; preds = %if.end35
  store i16 16386, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end36, %if.then33, %if.then22, %if.else, %if.then12, %if.then
  %34 = load i16, ptr %retval, align 2
  ret i16 %34
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_identify_ctrl(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  call void @trace_pci_nvme_identify_ctrl()
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %id_ctrl = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 40
  %2 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_c2h(ptr noundef %0, ptr noundef %id_ctrl, i32 noundef 4096, ptr noundef %2)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_identify_ctrl_csi(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %id = alloca [4096 x i8], align 16
  %id_nvm = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  call void @llvm.memset.p0.i64(ptr align 16 %id, i8 0, i64 4096, i1 false)
  store ptr %id, ptr %id_nvm, align 8
  %1 = load ptr, ptr %c, align 8
  %csi = getelementptr inbounds %struct.NvmeIdentify, ptr %1, i32 0, i32 12
  %2 = load i8, ptr %csi, align 1
  call void @trace_pci_nvme_identify_ctrl_csi(i8 noundef zeroext %2)
  %3 = load ptr, ptr %c, align 8
  %csi1 = getelementptr inbounds %struct.NvmeIdentify, ptr %3, i32 0, i32 12
  %4 = load i8, ptr %csi1, align 1
  %conv = zext i8 %4 to i32
  switch i32 %conv, label %sw.default [
    i32 0, label %sw.bb
    i32 2, label %sw.bb4
  ]

sw.bb:                                            ; preds = %entry
  %5 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %5, i32 0, i32 4
  %vsl = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 8
  %6 = load i8, ptr %vsl, align 1
  %7 = load ptr, ptr %id_nvm, align 8
  %vsl2 = getelementptr inbounds %struct.NvmeIdCtrlNvm, ptr %7, i32 0, i32 0
  store i8 %6, ptr %vsl2, align 8
  %8 = load ptr, ptr %n.addr, align 8
  %dmrsl = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 31
  %9 = load i32, ptr %dmrsl, align 4
  %call = call i32 @cpu_to_le32(i32 noundef %9)
  %10 = load ptr, ptr %id_nvm, align 8
  %dmrsl3 = getelementptr inbounds %struct.NvmeIdCtrlNvm, ptr %10, i32 0, i32 4
  store i32 %call, ptr %dmrsl3, align 4
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %11 = load ptr, ptr %n.addr, align 8
  %params5 = getelementptr inbounds %struct.NvmeCtrl, ptr %11, i32 0, i32 4
  %zasl = getelementptr inbounds %struct.NvmeParams, ptr %params5, i32 0, i32 10
  %12 = load i8, ptr %zasl, align 1
  %zasl6 = getelementptr inbounds %struct.NvmeIdCtrlZoned, ptr %id, i32 0, i32 0
  store i8 %12, ptr %zasl6, align 16
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i16 16386, ptr %retval, align 2
  br label %return

sw.epilog:                                        ; preds = %sw.bb4, %sw.bb
  %13 = load ptr, ptr %n.addr, align 8
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %id, i64 0, i64 0
  %14 = load ptr, ptr %req.addr, align 8
  %call7 = call zeroext i16 @nvme_c2h(ptr noundef %13, ptr noundef %arraydecay, i32 noundef 4096, ptr noundef %14)
  store i16 %call7, ptr %retval, align 2
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default
  %15 = load i16, ptr %retval, align 2
  ret i16 %15
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_identify_nslist(ptr noundef %n, ptr noundef %req, i1 noundef zeroext %active) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %active.addr = alloca i8, align 1
  %ns = alloca ptr, align 8
  %c = alloca ptr, align 8
  %min_nsid = alloca i32, align 4
  %list = alloca [4096 x i8], align 16
  %list_ptr = alloca ptr, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %frombool = zext i1 %active to i8
  store i8 %frombool, ptr %active.addr, align 1
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %nsid = getelementptr inbounds %struct.NvmeIdentify, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %nsid, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %min_nsid, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %list, i8 0, i64 4096, i1 false)
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %list, i64 0, i64 0
  store ptr %arraydecay, ptr %list_ptr, align 8
  store i32 0, ptr %j, align 4
  %3 = load i32, ptr %min_nsid, align 4
  call void @trace_pci_nvme_identify_nslist(i32 noundef %3)
  %4 = load i32, ptr %min_nsid, align 4
  %cmp = icmp uge i32 %4, -2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 16395, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, ptr %i, align 4
  %cmp1 = icmp sle i32 %5, 256
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %n.addr, align 8
  %7 = load i32, ptr %i, align 4
  %call2 = call ptr @nvme_ns(ptr noundef %6, i32 noundef %7)
  store ptr %call2, ptr %ns, align 8
  %8 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end11, label %if.then3

if.then3:                                         ; preds = %for.body
  %9 = load i8, ptr %active.addr, align 1
  %tobool4 = trunc i8 %9 to i1
  br i1 %tobool4, label %if.else, label %if.then5

if.then5:                                         ; preds = %if.then3
  %10 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %10, i32 0, i32 33
  %11 = load ptr, ptr %subsys, align 8
  %12 = load i32, ptr %i, align 4
  %call6 = call ptr @nvme_subsys_ns(ptr noundef %11, i32 noundef %12)
  store ptr %call6, ptr %ns, align 8
  %13 = load ptr, ptr %ns, align 8
  %tobool7 = icmp ne ptr %13, null
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.then5
  br label %for.inc

if.end9:                                          ; preds = %if.then5
  br label %if.end10

if.else:                                          ; preds = %if.then3
  br label %for.inc

if.end10:                                         ; preds = %if.end9
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %for.body
  %14 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %14, i32 0, i32 30
  %nsid12 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 2
  %15 = load i32, ptr %nsid12, align 4
  %16 = load i32, ptr %min_nsid, align 4
  %cmp13 = icmp ule i32 %15, %16
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end11
  br label %for.inc

if.end15:                                         ; preds = %if.end11
  %17 = load ptr, ptr %ns, align 8
  %params16 = getelementptr inbounds %struct.NvmeNamespace, ptr %17, i32 0, i32 30
  %nsid17 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params16, i32 0, i32 2
  %18 = load i32, ptr %nsid17, align 4
  %call18 = call i32 @cpu_to_le32(i32 noundef %18)
  %19 = load ptr, ptr %list_ptr, align 8
  %20 = load i32, ptr %j, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %j, align 4
  %idxprom = sext i32 %20 to i64
  %arrayidx = getelementptr i32, ptr %19, i64 %idxprom
  store i32 %call18, ptr %arrayidx, align 4
  %21 = load i32, ptr %j, align 4
  %conv = sext i32 %21 to i64
  %cmp19 = icmp eq i64 %conv, 1024
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end15
  br label %for.end

if.end22:                                         ; preds = %if.end15
  br label %for.inc

for.inc:                                          ; preds = %if.end22, %if.then14, %if.else, %if.then8
  %22 = load i32, ptr %i, align 4
  %inc23 = add i32 %22, 1
  store i32 %inc23, ptr %i, align 4
  br label %for.cond, !llvm.loop !60

for.end:                                          ; preds = %if.then21, %for.cond
  %23 = load ptr, ptr %n.addr, align 8
  %arraydecay24 = getelementptr inbounds [4096 x i8], ptr %list, i64 0, i64 0
  %24 = load ptr, ptr %req.addr, align 8
  %call25 = call zeroext i16 @nvme_c2h(ptr noundef %23, ptr noundef %arraydecay24, i32 noundef 4096, ptr noundef %24)
  store i16 %call25, ptr %retval, align 2
  br label %return

return:                                           ; preds = %for.end, %if.then
  %25 = load i16, ptr %retval, align 2
  ret i16 %25
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_identify_nslist_csi(ptr noundef %n, ptr noundef %req, i1 noundef zeroext %active) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %active.addr = alloca i8, align 1
  %ns = alloca ptr, align 8
  %c = alloca ptr, align 8
  %min_nsid = alloca i32, align 4
  %list = alloca [4096 x i8], align 16
  %list_ptr = alloca ptr, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %frombool = zext i1 %active to i8
  store i8 %frombool, ptr %active.addr, align 1
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %nsid = getelementptr inbounds %struct.NvmeIdentify, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %nsid, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %min_nsid, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %list, i8 0, i64 4096, i1 false)
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %list, i64 0, i64 0
  store ptr %arraydecay, ptr %list_ptr, align 8
  store i32 0, ptr %j, align 4
  %3 = load i32, ptr %min_nsid, align 4
  %conv = trunc i32 %3 to i16
  %4 = load ptr, ptr %c, align 8
  %csi = getelementptr inbounds %struct.NvmeIdentify, ptr %4, i32 0, i32 12
  %5 = load i8, ptr %csi, align 1
  call void @trace_pci_nvme_identify_nslist_csi(i16 noundef zeroext %conv, i8 noundef zeroext %5)
  %6 = load i32, ptr %min_nsid, align 4
  %cmp = icmp uge i32 %6, -2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 16395, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %7 = load ptr, ptr %c, align 8
  %csi2 = getelementptr inbounds %struct.NvmeIdentify, ptr %7, i32 0, i32 12
  %8 = load i8, ptr %csi2, align 1
  %conv3 = zext i8 %8 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.end
  %9 = load ptr, ptr %c, align 8
  %csi6 = getelementptr inbounds %struct.NvmeIdentify, ptr %9, i32 0, i32 12
  %10 = load i8, ptr %csi6, align 1
  %conv7 = zext i8 %10 to i32
  %cmp8 = icmp ne i32 %conv7, 2
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %land.lhs.true
  store i16 16386, ptr %retval, align 2
  br label %return

if.end11:                                         ; preds = %land.lhs.true, %if.end
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end11
  %11 = load i32, ptr %i, align 4
  %cmp12 = icmp sle i32 %11, 256
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load ptr, ptr %n.addr, align 8
  %13 = load i32, ptr %i, align 4
  %call14 = call ptr @nvme_ns(ptr noundef %12, i32 noundef %13)
  store ptr %call14, ptr %ns, align 8
  %14 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %14, null
  br i1 %tobool, label %if.end23, label %if.then15

if.then15:                                        ; preds = %for.body
  %15 = load i8, ptr %active.addr, align 1
  %tobool16 = trunc i8 %15 to i1
  br i1 %tobool16, label %if.else, label %if.then17

if.then17:                                        ; preds = %if.then15
  %16 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %16, i32 0, i32 33
  %17 = load ptr, ptr %subsys, align 8
  %18 = load i32, ptr %i, align 4
  %call18 = call ptr @nvme_subsys_ns(ptr noundef %17, i32 noundef %18)
  store ptr %call18, ptr %ns, align 8
  %19 = load ptr, ptr %ns, align 8
  %tobool19 = icmp ne ptr %19, null
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.then17
  br label %for.inc

if.end21:                                         ; preds = %if.then17
  br label %if.end22

if.else:                                          ; preds = %if.then15
  br label %for.inc

if.end22:                                         ; preds = %if.end21
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %for.body
  %20 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %20, i32 0, i32 30
  %nsid24 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 2
  %21 = load i32, ptr %nsid24, align 4
  %22 = load i32, ptr %min_nsid, align 4
  %cmp25 = icmp ule i32 %21, %22
  br i1 %cmp25, label %if.then33, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end23
  %23 = load ptr, ptr %c, align 8
  %csi27 = getelementptr inbounds %struct.NvmeIdentify, ptr %23, i32 0, i32 12
  %24 = load i8, ptr %csi27, align 1
  %conv28 = zext i8 %24 to i32
  %25 = load ptr, ptr %ns, align 8
  %csi29 = getelementptr inbounds %struct.NvmeNamespace, ptr %25, i32 0, i32 11
  %26 = load i8, ptr %csi29, align 8
  %conv30 = zext i8 %26 to i32
  %cmp31 = icmp ne i32 %conv28, %conv30
  br i1 %cmp31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %lor.lhs.false, %if.end23
  br label %for.inc

if.end34:                                         ; preds = %lor.lhs.false
  %27 = load ptr, ptr %ns, align 8
  %params35 = getelementptr inbounds %struct.NvmeNamespace, ptr %27, i32 0, i32 30
  %nsid36 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params35, i32 0, i32 2
  %28 = load i32, ptr %nsid36, align 4
  %call37 = call i32 @cpu_to_le32(i32 noundef %28)
  %29 = load ptr, ptr %list_ptr, align 8
  %30 = load i32, ptr %j, align 4
  %inc = add i32 %30, 1
  store i32 %inc, ptr %j, align 4
  %idxprom = sext i32 %30 to i64
  %arrayidx = getelementptr i32, ptr %29, i64 %idxprom
  store i32 %call37, ptr %arrayidx, align 4
  %31 = load i32, ptr %j, align 4
  %conv38 = sext i32 %31 to i64
  %cmp39 = icmp eq i64 %conv38, 1024
  br i1 %cmp39, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.end34
  br label %for.end

if.end42:                                         ; preds = %if.end34
  br label %for.inc

for.inc:                                          ; preds = %if.end42, %if.then33, %if.else, %if.then20
  %32 = load i32, ptr %i, align 4
  %inc43 = add i32 %32, 1
  store i32 %inc43, ptr %i, align 4
  br label %for.cond, !llvm.loop !61

for.end:                                          ; preds = %if.then41, %for.cond
  %33 = load ptr, ptr %n.addr, align 8
  %arraydecay44 = getelementptr inbounds [4096 x i8], ptr %list, i64 0, i64 0
  %34 = load ptr, ptr %req.addr, align 8
  %call45 = call zeroext i16 @nvme_c2h(ptr noundef %33, ptr noundef %arraydecay44, i32 noundef 4096, ptr noundef %34)
  store i16 %call45, ptr %retval, align 2
  br label %return

return:                                           ; preds = %for.end, %if.then10, %if.then
  %35 = load i16, ptr %retval, align 2
  ret i16 %35
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_identify_ns_descr_list(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %c = alloca ptr, align 8
  %nsid = alloca i32, align 4
  %list = alloca [4096 x i8], align 16
  %pos = alloca ptr, align 8
  %uuid = alloca %struct.anon.47, align 1
  %eui64 = alloca %struct.anon.48, align 1
  %csi = alloca %struct.anon.49, align 1
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %nsid1 = getelementptr inbounds %struct.NvmeIdentify, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %nsid1, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %nsid, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %list, i8 0, i64 4096, i1 false)
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %list, i64 0, i64 0
  store ptr %arraydecay, ptr %pos, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %uuid, i8 0, i64 20, i1 false)
  call void @llvm.memset.p0.i64(ptr align 1 %eui64, i8 0, i64 12, i1 false)
  call void @llvm.memset.p0.i64(ptr align 1 %csi, i8 0, i64 5, i1 false)
  %3 = load i32, ptr %nsid, align 4
  call void @trace_pci_nvme_identify_ns_descr_list(i32 noundef %3)
  %4 = load ptr, ptr %n.addr, align 8
  %5 = load i32, ptr %nsid, align 4
  %call2 = call zeroext i1 @nvme_nsid_valid(ptr noundef %4, i32 noundef %5)
  br i1 %call2, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %6 = load i32, ptr %nsid, align 4
  %cmp = icmp eq i32 %6, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i16 16395, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %7 = load ptr, ptr %n.addr, align 8
  %8 = load i32, ptr %nsid, align 4
  %call3 = call ptr @nvme_ns(ptr noundef %7, i32 noundef %8)
  store ptr %call3, ptr %ns, align 8
  %9 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %9, null
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  store i16 16386, ptr %retval, align 2
  br label %return

if.end8:                                          ; preds = %if.end
  %10 = load ptr, ptr %ns, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %10, i32 0, i32 30
  %uuid9 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 3
  %call10 = call i32 @qemu_uuid_is_null(ptr noundef %uuid9)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end18, label %if.then12

if.then12:                                        ; preds = %if.end8
  %hdr = getelementptr inbounds %struct.anon.47, ptr %uuid, i32 0, i32 0
  %nidt = getelementptr inbounds %struct.NvmeIdNsDescr, ptr %hdr, i32 0, i32 0
  store i8 3, ptr %nidt, align 1
  %hdr13 = getelementptr inbounds %struct.anon.47, ptr %uuid, i32 0, i32 0
  %nidl = getelementptr inbounds %struct.NvmeIdNsDescr, ptr %hdr13, i32 0, i32 1
  store i8 16, ptr %nidl, align 1
  %v = getelementptr inbounds %struct.anon.47, ptr %uuid, i32 0, i32 1
  %arraydecay14 = getelementptr inbounds [16 x i8], ptr %v, i64 0, i64 0
  %11 = load ptr, ptr %ns, align 8
  %params15 = getelementptr inbounds %struct.NvmeNamespace, ptr %11, i32 0, i32 30
  %uuid16 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params15, i32 0, i32 3
  %12 = getelementptr inbounds %struct.QemuUUID, ptr %uuid16, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [16 x i8], ptr %12, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %arraydecay14, ptr align 8 %arraydecay17, i64 16, i1 false)
  %13 = load ptr, ptr %pos, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %13, ptr align 1 %uuid, i64 20, i1 false)
  %14 = load ptr, ptr %pos, align 8
  %add.ptr = getelementptr i8, ptr %14, i64 20
  store ptr %add.ptr, ptr %pos, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then12, %if.end8
  %15 = load ptr, ptr %ns, align 8
  %params19 = getelementptr inbounds %struct.NvmeNamespace, ptr %15, i32 0, i32 30
  %eui6420 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params19, i32 0, i32 4
  %16 = load i64, ptr %eui6420, align 8
  %tobool21 = icmp ne i64 %16, 0
  br i1 %tobool21, label %if.then22, label %if.end32

if.then22:                                        ; preds = %if.end18
  %hdr23 = getelementptr inbounds %struct.anon.48, ptr %eui64, i32 0, i32 0
  %nidt24 = getelementptr inbounds %struct.NvmeIdNsDescr, ptr %hdr23, i32 0, i32 0
  store i8 1, ptr %nidt24, align 1
  %hdr25 = getelementptr inbounds %struct.anon.48, ptr %eui64, i32 0, i32 0
  %nidl26 = getelementptr inbounds %struct.NvmeIdNsDescr, ptr %hdr25, i32 0, i32 1
  store i8 8, ptr %nidl26, align 1
  %17 = load ptr, ptr %ns, align 8
  %params27 = getelementptr inbounds %struct.NvmeNamespace, ptr %17, i32 0, i32 30
  %eui6428 = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params27, i32 0, i32 4
  %18 = load i64, ptr %eui6428, align 8
  %call29 = call i64 @cpu_to_be64(i64 noundef %18)
  %v30 = getelementptr inbounds %struct.anon.48, ptr %eui64, i32 0, i32 1
  store i64 %call29, ptr %v30, align 1
  %19 = load ptr, ptr %pos, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %19, ptr align 1 %eui64, i64 12, i1 false)
  %20 = load ptr, ptr %pos, align 8
  %add.ptr31 = getelementptr i8, ptr %20, i64 12
  store ptr %add.ptr31, ptr %pos, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then22, %if.end18
  %hdr33 = getelementptr inbounds %struct.anon.49, ptr %csi, i32 0, i32 0
  %nidt34 = getelementptr inbounds %struct.NvmeIdNsDescr, ptr %hdr33, i32 0, i32 0
  store i8 4, ptr %nidt34, align 1
  %hdr35 = getelementptr inbounds %struct.anon.49, ptr %csi, i32 0, i32 0
  %nidl36 = getelementptr inbounds %struct.NvmeIdNsDescr, ptr %hdr35, i32 0, i32 1
  store i8 1, ptr %nidl36, align 1
  %21 = load ptr, ptr %ns, align 8
  %csi37 = getelementptr inbounds %struct.NvmeNamespace, ptr %21, i32 0, i32 11
  %22 = load i8, ptr %csi37, align 8
  %v38 = getelementptr inbounds %struct.anon.49, ptr %csi, i32 0, i32 1
  store i8 %22, ptr %v38, align 1
  %23 = load ptr, ptr %pos, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %23, ptr align 1 %csi, i64 5, i1 false)
  %24 = load ptr, ptr %pos, align 8
  %add.ptr39 = getelementptr i8, ptr %24, i64 5
  store ptr %add.ptr39, ptr %pos, align 8
  %25 = load ptr, ptr %n.addr, align 8
  %arraydecay40 = getelementptr inbounds [4096 x i8], ptr %list, i64 0, i64 0
  %26 = load ptr, ptr %req.addr, align 8
  %call41 = call zeroext i16 @nvme_c2h(ptr noundef %25, ptr noundef %arraydecay40, i32 noundef 4096, ptr noundef %26)
  store i16 %call41, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end32, %if.then7, %if.then
  %27 = load i16, ptr %retval, align 2
  ret i16 %27
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_identify_cmd_set(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %list = alloca [4096 x i8], align 16
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 16 %list, i8 0, i64 4096, i1 false)
  call void @trace_pci_nvme_identify_cmd_set()
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %list, i64 0, i64 0
  %0 = load i8, ptr %arraydecay, align 16
  %conv = zext i8 %0 to i32
  %or = or i32 %conv, 1
  %conv1 = trunc i32 %or to i8
  store i8 %conv1, ptr %arraydecay, align 16
  %arraydecay2 = getelementptr inbounds [4096 x i8], ptr %list, i64 0, i64 0
  %1 = load i8, ptr %arraydecay2, align 16
  %conv3 = zext i8 %1 to i32
  %or4 = or i32 %conv3, 4
  %conv5 = trunc i32 %or4 to i8
  store i8 %conv5, ptr %arraydecay2, align 16
  %2 = load ptr, ptr %n.addr, align 8
  %arraydecay6 = getelementptr inbounds [4096 x i8], ptr %list, i64 0, i64 0
  %3 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_c2h(ptr noundef %2, ptr noundef %arraydecay6, i32 noundef 4096, ptr noundef %3)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_identify_cns(i16 noundef zeroext %cns) #0 {
entry:
  %cns.addr = alloca i16, align 2
  store i16 %cns, ptr %cns.addr, align 2
  %0 = load i16, ptr %cns.addr, align 2
  call void @_nocheck__trace_pci_nvme_err_invalid_identify_cns(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_identify(i16 noundef zeroext %cid, i8 noundef zeroext %cns, i16 noundef zeroext %ctrlid, i8 noundef zeroext %csi) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %cns.addr = alloca i8, align 1
  %ctrlid.addr = alloca i16, align 2
  %csi.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i8 %cns, ptr %cns.addr, align 1
  store i16 %ctrlid, ptr %ctrlid.addr, align 2
  store i8 %csi, ptr %csi.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IDENTIFY_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end19

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i8, ptr %cns.addr, align 1
  %conv12 = zext i8 %6 to i32
  %7 = load i16, ptr %ctrlid.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i8, ptr %csi.addr, align 1
  %conv14 = zext i8 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.361, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.else:                                          ; preds = %if.then
  %9 = load i16, ptr %cid.addr, align 2
  %conv15 = zext i16 %9 to i32
  %10 = load i8, ptr %cns.addr, align 1
  %conv16 = zext i8 %10 to i32
  %11 = load i16, ptr %ctrlid.addr, align 2
  %conv17 = zext i16 %11 to i32
  %12 = load i8, ptr %csi.addr, align 1
  %conv18 = zext i8 %12 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.362, i32 noundef %conv15, i32 noundef %conv16, i32 noundef %conv17, i32 noundef %conv18)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end19

if.end19:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_identify_ns(i32 noundef %ns) #0 {
entry:
  %ns.addr = alloca i32, align 4
  store i32 %ns, ptr %ns.addr, align 4
  %0 = load i32, ptr %ns.addr, align 4
  call void @_nocheck__trace_pci_nvme_identify_ns(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_rpt_empty_id_struct(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %id = alloca [4096 x i8], align 16
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 16 %id, i8 0, i64 4096, i1 false)
  %0 = load ptr, ptr %n.addr, align 8
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %id, i64 0, i64 0
  %1 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_c2h(ptr noundef %0, ptr noundef %arraydecay, i32 noundef 4096, ptr noundef %1)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_identify_ns(i32 noundef %ns) #0 {
entry:
  %ns.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %ns, ptr %ns.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IDENTIFY_NS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %ns.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.363, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %ns.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.364, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_identify_ctrl_list(i8 noundef zeroext %cns, i16 noundef zeroext %cntid) #0 {
entry:
  %cns.addr = alloca i8, align 1
  %cntid.addr = alloca i16, align 2
  store i8 %cns, ptr %cns.addr, align 1
  store i16 %cntid, ptr %cntid.addr, align 2
  %0 = load i8, ptr %cns.addr, align 1
  %1 = load i16, ptr %cntid.addr, align 2
  call void @_nocheck__trace_pci_nvme_identify_ctrl_list(i8 noundef zeroext %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_subsys_ctrl(ptr noundef %subsys, i32 noundef %cntlid) #0 {
entry:
  %retval = alloca ptr, align 8
  %subsys.addr = alloca ptr, align 8
  %cntlid.addr = alloca i32, align 4
  store ptr %subsys, ptr %subsys.addr, align 8
  store i32 %cntlid, ptr %cntlid.addr, align 4
  %0 = load ptr, ptr %subsys.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %cntlid.addr, align 4
  %cmp = icmp uge i32 %1, 256
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %subsys.addr, align 8
  %ctrls = getelementptr inbounds %struct.NvmeSubsystem, ptr %2, i32 0, i32 4
  %3 = load i32, ptr %cntlid.addr, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr [256 x ptr], ptr %ctrls, i64 0, i64 %idxprom
  %4 = load ptr, ptr %arrayidx, align 8
  %cmp1 = icmp eq ptr %4, inttoptr (i64 65535 to ptr)
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load ptr, ptr %subsys.addr, align 8
  %ctrls4 = getelementptr inbounds %struct.NvmeSubsystem, ptr %5, i32 0, i32 4
  %6 = load i32, ptr %cntlid.addr, align 4
  %idxprom5 = zext i32 %6 to i64
  %arrayidx6 = getelementptr [256 x ptr], ptr %ctrls4, i64 0, i64 %idxprom5
  %7 = load ptr, ptr %arrayidx6, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_identify_ctrl_list(i8 noundef zeroext %cns, i16 noundef zeroext %cntid) #0 {
entry:
  %cns.addr = alloca i8, align 1
  %cntid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i8 %cns, ptr %cns.addr, align 1
  store i16 %cntid, ptr %cntid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IDENTIFY_CTRL_LIST_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %cns.addr, align 1
  %conv11 = zext i8 %5 to i32
  %6 = load i16, ptr %cntid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.365, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i8, ptr %cns.addr, align 1
  %conv13 = zext i8 %7 to i32
  %8 = load i16, ptr %cntid.addr, align 2
  %conv14 = zext i16 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.366, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_identify_pri_ctrl_cap(i16 noundef zeroext %cntlid) #0 {
entry:
  %cntlid.addr = alloca i16, align 2
  store i16 %cntlid, ptr %cntlid.addr, align 2
  %0 = load i16, ptr %cntlid.addr, align 2
  call void @_nocheck__trace_pci_nvme_identify_pri_ctrl_cap(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_identify_pri_ctrl_cap(i16 noundef zeroext %cntlid) #0 {
entry:
  %cntlid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cntlid, ptr %cntlid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IDENTIFY_PRI_CTRL_CAP_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cntlid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.367, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %cntlid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.368, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_identify_sec_ctrl_list(i16 noundef zeroext %cntlid, i8 noundef zeroext %numcntl) #0 {
entry:
  %cntlid.addr = alloca i16, align 2
  %numcntl.addr = alloca i8, align 1
  store i16 %cntlid, ptr %cntlid.addr, align 2
  store i8 %numcntl, ptr %numcntl.addr, align 1
  %0 = load i16, ptr %cntlid.addr, align 2
  %1 = load i8, ptr %numcntl.addr, align 1
  call void @_nocheck__trace_pci_nvme_identify_sec_ctrl_list(i16 noundef zeroext %0, i8 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_identify_sec_ctrl_list(i16 noundef zeroext %cntlid, i8 noundef zeroext %numcntl) #0 {
entry:
  %cntlid.addr = alloca i16, align 2
  %numcntl.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i16 %cntlid, ptr %cntlid.addr, align 2
  store i8 %numcntl, ptr %numcntl.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IDENTIFY_SEC_CTRL_LIST_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cntlid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i8, ptr %numcntl.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.369, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %cntlid.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i8, ptr %numcntl.addr, align 1
  %conv14 = zext i8 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.370, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_identify_ns_csi(i32 noundef %ns, i8 noundef zeroext %csi) #0 {
entry:
  %ns.addr = alloca i32, align 4
  %csi.addr = alloca i8, align 1
  store i32 %ns, ptr %ns.addr, align 4
  store i8 %csi, ptr %csi.addr, align 1
  %0 = load i32, ptr %ns.addr, align 4
  %1 = load i8, ptr %csi.addr, align 1
  call void @_nocheck__trace_pci_nvme_identify_ns_csi(i32 noundef %0, i8 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_identify_ns_csi(i32 noundef %ns, i8 noundef zeroext %csi) #0 {
entry:
  %ns.addr = alloca i32, align 4
  %csi.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i32 %ns, ptr %ns.addr, align 4
  store i8 %csi, ptr %csi.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IDENTIFY_NS_CSI_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %ns.addr, align 4
  %6 = load i8, ptr %csi.addr, align 1
  %conv11 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.371, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i32, ptr %ns.addr, align 4
  %8 = load i8, ptr %csi.addr, align 1
  %conv12 = zext i8 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.372, i32 noundef %7, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_identify_ctrl() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_identify_ctrl()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_identify_ctrl() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IDENTIFY_CTRL_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.373, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.374)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_identify_ctrl_csi(i8 noundef zeroext %csi) #0 {
entry:
  %csi.addr = alloca i8, align 1
  store i8 %csi, ptr %csi.addr, align 1
  %0 = load i8, ptr %csi.addr, align 1
  call void @_nocheck__trace_pci_nvme_identify_ctrl_csi(i8 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_identify_ctrl_csi(i8 noundef zeroext %csi) #0 {
entry:
  %csi.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i8 %csi, ptr %csi.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IDENTIFY_CTRL_CSI_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i8, ptr %csi.addr, align 1
  %conv11 = zext i8 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.375, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i8, ptr %csi.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.376, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_identify_nslist(i32 noundef %ns) #0 {
entry:
  %ns.addr = alloca i32, align 4
  store i32 %ns, ptr %ns.addr, align 4
  %0 = load i32, ptr %ns.addr, align 4
  call void @_nocheck__trace_pci_nvme_identify_nslist(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_identify_nslist(i32 noundef %ns) #0 {
entry:
  %ns.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %ns, ptr %ns.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IDENTIFY_NSLIST_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %ns.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.377, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %ns.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.378, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_identify_nslist_csi(i16 noundef zeroext %ns, i8 noundef zeroext %csi) #0 {
entry:
  %ns.addr = alloca i16, align 2
  %csi.addr = alloca i8, align 1
  store i16 %ns, ptr %ns.addr, align 2
  store i8 %csi, ptr %csi.addr, align 1
  %0 = load i16, ptr %ns.addr, align 2
  %1 = load i8, ptr %csi.addr, align 1
  call void @_nocheck__trace_pci_nvme_identify_nslist_csi(i16 noundef zeroext %0, i8 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_identify_nslist_csi(i16 noundef zeroext %ns, i8 noundef zeroext %csi) #0 {
entry:
  %ns.addr = alloca i16, align 2
  %csi.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i16 %ns, ptr %ns.addr, align 2
  store i8 %csi, ptr %csi.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %ns.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i8, ptr %csi.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.379, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %ns.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i8, ptr %csi.addr, align 1
  %conv14 = zext i8 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.380, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_identify_ns_descr_list(i32 noundef %ns) #0 {
entry:
  %ns.addr = alloca i32, align 4
  store i32 %ns, ptr %ns.addr, align 4
  %0 = load i32, ptr %ns.addr, align 4
  call void @_nocheck__trace_pci_nvme_identify_ns_descr_list(i32 noundef %0)
  ret void
}

declare i32 @qemu_uuid_is_null(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @cpu_to_be64(i64 noundef %v) #0 {
entry:
  %v.addr = alloca i64, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load i64, ptr %v.addr, align 8
  %1 = call i64 @llvm.bswap.i64(i64 %0)
  ret i64 %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_identify_ns_descr_list(i32 noundef %ns) #0 {
entry:
  %ns.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %ns, ptr %ns.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %ns.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.381, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %ns.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.382, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.bswap.i64(i64) #7

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_identify_cmd_set() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_identify_cmd_set()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_identify_cmd_set() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_IDENTIFY_CMD_SET_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.383, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.384)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_identify_cns(i16 noundef zeroext %cns) #0 {
entry:
  %cns.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cns, ptr %cns.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cns.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.385, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %cns.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.386, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_setfeat(i16 noundef zeroext %cid, i32 noundef %nsid, i8 noundef zeroext %fid, i8 noundef zeroext %save, i32 noundef %cdw11) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %fid.addr = alloca i8, align 1
  %save.addr = alloca i8, align 1
  %cdw11.addr = alloca i32, align 4
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i8 %fid, ptr %fid.addr, align 1
  store i8 %save, ptr %save.addr, align 1
  store i32 %cdw11, ptr %cdw11.addr, align 4
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i32, ptr %nsid.addr, align 4
  %2 = load i8, ptr %fid.addr, align 1
  %3 = load i8, ptr %save.addr, align 1
  %4 = load i32, ptr %cdw11.addr, align 4
  call void @_nocheck__trace_pci_nvme_setfeat(i16 noundef zeroext %0, i32 noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i32 noundef %4)
  ret void
}

declare zeroext i1 @blk_enable_write_cache(ptr noundef) #1

declare i32 @blk_flush(ptr noundef) #1

declare void @blk_set_enable_write_cache(ptr noundef, i1 noundef zeroext) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_setfeat_numq(i32 noundef %reqcq, i32 noundef %reqsq, i32 noundef %gotcq, i32 noundef %gotsq) #0 {
entry:
  %reqcq.addr = alloca i32, align 4
  %reqsq.addr = alloca i32, align 4
  %gotcq.addr = alloca i32, align 4
  %gotsq.addr = alloca i32, align 4
  store i32 %reqcq, ptr %reqcq.addr, align 4
  store i32 %reqsq, ptr %reqsq.addr, align 4
  store i32 %gotcq, ptr %gotcq.addr, align 4
  store i32 %gotsq, ptr %gotsq.addr, align 4
  %0 = load i32, ptr %reqcq.addr, align 4
  %1 = load i32, ptr %reqsq.addr, align 4
  %2 = load i32, ptr %gotcq.addr, align 4
  %3 = load i32, ptr %gotsq.addr, align 4
  call void @_nocheck__trace_pci_nvme_setfeat_numq(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_set_feature_timestamp(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %ret = alloca i16, align 2
  %timestamp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load ptr, ptr %req.addr, align 8
  %call = call zeroext i16 @nvme_h2c(ptr noundef %0, ptr noundef %timestamp, i32 noundef 8, ptr noundef %1)
  store i16 %call, ptr %ret, align 2
  %2 = load i16, ptr %ret, align 2
  %tobool = icmp ne i16 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i16, ptr %ret, align 2
  store i16 %3, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %n.addr, align 8
  %5 = load i64, ptr %timestamp, align 8
  call void @nvme_set_timestamp(ptr noundef %4, i64 noundef %5)
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i16, ptr %retval, align 2
  ret i16 %6
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_err_invalid_iocsci(i32 noundef %idx) #0 {
entry:
  %idx.addr = alloca i32, align 4
  store i32 %idx, ptr %idx.addr, align 4
  %0 = load i32, ptr %idx.addr, align 4
  call void @_nocheck__trace_pci_nvme_err_invalid_iocsci(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_set_feature_fdp_events(ptr noundef %n, ptr noundef %ns, ptr noundef %req) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %ns.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %cdw11 = alloca i32, align 4
  %ph = alloca i16, align 2
  %noet = alloca i8, align 1
  %ret = alloca i16, align 2
  %ruhid = alloca i16, align 2
  %enable = alloca i8, align 1
  %event_mask = alloca i8, align 1
  %i = alloca i32, align 4
  %events = alloca ptr, align 8
  %ruh = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd1, ptr %cmd, align 8
  %1 = load ptr, ptr %cmd, align 8
  %cdw112 = getelementptr inbounds %struct.NvmeCmd, ptr %1, i32 0, i32 8
  %2 = load i32, ptr %cdw112, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %cdw11, align 4
  %3 = load i32, ptr %cdw11, align 4
  %and = and i32 %3, 65535
  %conv = trunc i32 %and to i16
  store i16 %conv, ptr %ph, align 2
  %4 = load i32, ptr %cdw11, align 4
  %shr = lshr i32 %4, 16
  %and3 = and i32 %shr, 255
  %conv4 = trunc i32 %and3 to i8
  store i8 %conv4, ptr %noet, align 1
  %5 = load ptr, ptr %cmd, align 8
  %cdw12 = getelementptr inbounds %struct.NvmeCmd, ptr %5, i32 0, i32 9
  %6 = load i32, ptr %cdw12, align 1
  %call5 = call i32 @le32_to_cpu(i32 noundef %6)
  %and6 = and i32 %call5, 1
  %conv7 = trunc i32 %and6 to i8
  store i8 %conv7, ptr %enable, align 1
  store i8 0, ptr %event_mask, align 1
  %7 = load i8, ptr %noet, align 1
  %conv8 = zext i8 %7 to i64
  %call9 = call noalias ptr @g_malloc0(i64 noundef %conv8) #14
  store ptr %call9, ptr %events, align 8
  store ptr null, ptr %ruh, align 8
  %8 = load ptr, ptr %ns.addr, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.387, ptr noundef @.str.1, i32 noundef 6102, ptr noundef @__PRETTY_FUNCTION__.nvme_set_feature_fdp_events) #12
  unreachable

if.end:                                           ; preds = %if.then
  %9 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 33
  %10 = load ptr, ptr %subsys, align 8
  %tobool10 = icmp ne ptr %10, null
  br i1 %tobool10, label %lor.lhs.false, label %if.then13

lor.lhs.false:                                    ; preds = %if.end
  %11 = load ptr, ptr %n.addr, align 8
  %subsys11 = getelementptr inbounds %struct.NvmeCtrl, ptr %11, i32 0, i32 33
  %12 = load ptr, ptr %subsys11, align 8
  %endgrp = getelementptr inbounds %struct.NvmeSubsystem, ptr %12, i32 0, i32 6
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %endgrp, i32 0, i32 1
  %enabled = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 9
  %13 = load i8, ptr %enabled, align 8
  %tobool12 = trunc i8 %13 to i1
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %lor.lhs.false, %if.end
  store i16 16425, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end14:                                         ; preds = %lor.lhs.false
  %14 = load ptr, ptr %ns.addr, align 8
  %15 = load i16, ptr %ph, align 2
  %call15 = call zeroext i1 @nvme_ph_valid(ptr noundef %14, i16 noundef zeroext %15)
  br i1 %call15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %if.end14
  store i16 16386, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end17:                                         ; preds = %if.end14
  %16 = load ptr, ptr %ns.addr, align 8
  %fdp18 = getelementptr inbounds %struct.NvmeNamespace, ptr %16, i32 0, i32 34
  %phs = getelementptr inbounds %struct.anon.14, ptr %fdp18, i32 0, i32 1
  %17 = load ptr, ptr %phs, align 8
  %18 = load i16, ptr %ph, align 2
  %idxprom = zext i16 %18 to i64
  %arrayidx = getelementptr i16, ptr %17, i64 %idxprom
  %19 = load i16, ptr %arrayidx, align 2
  store i16 %19, ptr %ruhid, align 2
  %20 = load ptr, ptr %n.addr, align 8
  %subsys19 = getelementptr inbounds %struct.NvmeCtrl, ptr %20, i32 0, i32 33
  %21 = load ptr, ptr %subsys19, align 8
  %endgrp20 = getelementptr inbounds %struct.NvmeSubsystem, ptr %21, i32 0, i32 6
  %fdp21 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %endgrp20, i32 0, i32 1
  %ruhs = getelementptr inbounds %struct.anon.36, ptr %fdp21, i32 0, i32 10
  %22 = load ptr, ptr %ruhs, align 8
  %23 = load i16, ptr %ruhid, align 2
  %idxprom22 = zext i16 %23 to i64
  %arrayidx23 = getelementptr %struct.NvmeRuHandle, ptr %22, i64 %idxprom22
  store ptr %arrayidx23, ptr %ruh, align 8
  %24 = load ptr, ptr %n.addr, align 8
  %25 = load ptr, ptr %events, align 8
  %26 = load i8, ptr %noet, align 1
  %conv24 = zext i8 %26 to i32
  %27 = load ptr, ptr %req.addr, align 8
  %call25 = call zeroext i16 @nvme_h2c(ptr noundef %24, ptr noundef %25, i32 noundef %conv24, ptr noundef %27)
  store i16 %call25, ptr %ret, align 2
  %28 = load i16, ptr %ret, align 2
  %tobool26 = icmp ne i16 %28, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end17
  %29 = load i16, ptr %ret, align 2
  store i16 %29, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end28:                                         ; preds = %if.end17
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end28
  %30 = load i32, ptr %i, align 4
  %31 = load i8, ptr %noet, align 1
  %conv29 = zext i8 %31 to i32
  %cmp = icmp ult i32 %30, %conv29
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %32 = load ptr, ptr %events, align 8
  %33 = load i32, ptr %i, align 4
  %idxprom31 = zext i32 %33 to i64
  %arrayidx32 = getelementptr i8, ptr %32, i64 %idxprom31
  %34 = load i8, ptr %arrayidx32, align 1
  %idxprom33 = zext i8 %34 to i64
  %arrayidx34 = getelementptr [255 x i8], ptr @nvme_fdp_evf_shifts, i64 0, i64 %idxprom33
  %35 = load i8, ptr %arrayidx34, align 1
  %conv35 = zext i8 %35 to i32
  %shl = shl i32 1, %conv35
  %36 = load i8, ptr %event_mask, align 1
  %conv36 = zext i8 %36 to i32
  %or = or i32 %conv36, %shl
  %conv37 = trunc i32 %or to i8
  store i8 %conv37, ptr %event_mask, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %37 = load i32, ptr %i, align 4
  %inc = add i32 %37, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !62

for.end:                                          ; preds = %for.cond
  %38 = load i8, ptr %enable, align 1
  %tobool38 = icmp ne i8 %38, 0
  br i1 %tobool38, label %if.then39, label %if.else42

if.then39:                                        ; preds = %for.end
  %39 = load i8, ptr %event_mask, align 1
  %conv40 = zext i8 %39 to i64
  %40 = load ptr, ptr %ruh, align 8
  %event_filter = getelementptr inbounds %struct.NvmeRuHandle, ptr %40, i32 0, i32 2
  %41 = load i64, ptr %event_filter, align 8
  %or41 = or i64 %41, %conv40
  store i64 %or41, ptr %event_filter, align 8
  br label %if.end48

if.else42:                                        ; preds = %for.end
  %42 = load ptr, ptr %ruh, align 8
  %event_filter43 = getelementptr inbounds %struct.NvmeRuHandle, ptr %42, i32 0, i32 2
  %43 = load i64, ptr %event_filter43, align 8
  %44 = load i8, ptr %event_mask, align 1
  %conv44 = zext i8 %44 to i32
  %not = xor i32 %conv44, -1
  %conv45 = sext i32 %not to i64
  %and46 = and i64 %43, %conv45
  %45 = load ptr, ptr %ruh, align 8
  %event_filter47 = getelementptr inbounds %struct.NvmeRuHandle, ptr %45, i32 0, i32 2
  store i64 %and46, ptr %event_filter47, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.else42, %if.then39
  store i16 0, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end48, %if.then27, %if.then16, %if.then13
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %events)
  %46 = load i16, ptr %retval, align 2
  ret i16 %46
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_setfeat(i16 noundef zeroext %cid, i32 noundef %nsid, i8 noundef zeroext %fid, i8 noundef zeroext %save, i32 noundef %cdw11) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %fid.addr = alloca i8, align 1
  %save.addr = alloca i8, align 1
  %cdw11.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i8 %fid, ptr %fid.addr, align 1
  store i8 %save, ptr %save.addr, align 1
  store i32 %cdw11, ptr %cdw11.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_SETFEAT_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end17

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end17

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i32, ptr %nsid.addr, align 4
  %7 = load i8, ptr %fid.addr, align 1
  %conv12 = zext i8 %7 to i32
  %8 = load i8, ptr %save.addr, align 1
  %conv13 = zext i8 %8 to i32
  %9 = load i32, ptr %cdw11.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.388, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %6, i32 noundef %conv12, i32 noundef %conv13, i32 noundef %9)
  br label %if.end

if.else:                                          ; preds = %if.then
  %10 = load i16, ptr %cid.addr, align 2
  %conv14 = zext i16 %10 to i32
  %11 = load i32, ptr %nsid.addr, align 4
  %12 = load i8, ptr %fid.addr, align 1
  %conv15 = zext i8 %12 to i32
  %13 = load i8, ptr %save.addr, align 1
  %conv16 = zext i8 %13 to i32
  %14 = load i32, ptr %cdw11.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.389, i32 noundef %conv14, i32 noundef %11, i32 noundef %conv15, i32 noundef %conv16, i32 noundef %14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end17

if.end17:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_setfeat_numq(i32 noundef %reqcq, i32 noundef %reqsq, i32 noundef %gotcq, i32 noundef %gotsq) #0 {
entry:
  %reqcq.addr = alloca i32, align 4
  %reqsq.addr = alloca i32, align 4
  %gotcq.addr = alloca i32, align 4
  %gotsq.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %reqcq, ptr %reqcq.addr, align 4
  store i32 %reqsq, ptr %reqsq.addr, align 4
  store i32 %gotcq, ptr %gotcq.addr, align 4
  store i32 %gotsq, ptr %gotsq.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_SETFEAT_NUMQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %reqcq.addr, align 4
  %6 = load i32, ptr %reqsq.addr, align 4
  %7 = load i32, ptr %gotcq.addr, align 4
  %8 = load i32, ptr %gotsq.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.392, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %7, i32 noundef %8)
  br label %if.end

if.else:                                          ; preds = %if.then
  %9 = load i32, ptr %reqcq.addr, align 4
  %10 = load i32, ptr %reqsq.addr, align 4
  %11 = load i32, ptr %gotcq.addr, align 4
  %12 = load i32, ptr %gotsq.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.393, i32 noundef %9, i32 noundef %10, i32 noundef %11, i32 noundef %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_invalid_iocsci(i32 noundef %idx) #0 {
entry:
  %idx.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %idx, ptr %idx.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_INVALID_IOCSCI_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %idx.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.394, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %idx.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.395, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_getfeat(i16 noundef zeroext %cid, i32 noundef %nsid, i8 noundef zeroext %fid, i8 noundef zeroext %sel, i32 noundef %cdw11) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %fid.addr = alloca i8, align 1
  %sel.addr = alloca i8, align 1
  %cdw11.addr = alloca i32, align 4
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i8 %fid, ptr %fid.addr, align 1
  store i8 %sel, ptr %sel.addr, align 1
  store i32 %cdw11, ptr %cdw11.addr, align 4
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i32, ptr %nsid.addr, align 4
  %2 = load i8, ptr %fid.addr, align 1
  %3 = load i8, ptr %sel.addr, align 1
  %4 = load i32, ptr %cdw11.addr, align 4
  call void @_nocheck__trace_pci_nvme_getfeat(i16 noundef zeroext %0, i32 noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i32 noundef %4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_getfeat_vwcache(ptr noundef %result) #0 {
entry:
  %result.addr = alloca ptr, align 8
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %result.addr, align 8
  call void @_nocheck__trace_pci_nvme_getfeat_vwcache(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_get_feature_timestamp(ptr noundef %n, ptr noundef %req) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %timestamp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %call = call i64 @nvme_get_timestamp(ptr noundef %0)
  store i64 %call, ptr %timestamp, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %2 = load ptr, ptr %req.addr, align 8
  %call1 = call zeroext i16 @nvme_c2h(ptr noundef %1, ptr noundef %timestamp, i32 noundef 8, ptr noundef %2)
  ret i16 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @nvme_get_feature_fdp(ptr noundef %n, i32 noundef %endgrpid, ptr noundef %result) #0 {
entry:
  %retval = alloca i32, align 4
  %n.addr = alloca ptr, align 8
  %endgrpid.addr = alloca i32, align 4
  %result.addr = alloca ptr, align 8
  %_v = alloca %struct.anon.50, align 4
  %_d = alloca i16, align 2
  %tmp = alloca i16, align 2
  %_v4 = alloca %struct.anon.51, align 4
  %_d5 = alloca i16, align 2
  %tmp10 = alloca i16, align 2
  store ptr %n, ptr %n.addr, align 8
  store i32 %endgrpid, ptr %endgrpid.addr, align 4
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %result.addr, align 8
  store i32 0, ptr %0, align 4
  %1 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 33
  %2 = load ptr, ptr %subsys, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %subsys1 = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 33
  %4 = load ptr, ptr %subsys1, align 8
  %endgrp = getelementptr inbounds %struct.NvmeSubsystem, ptr %4, i32 0, i32 6
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %endgrp, i32 0, i32 1
  %enabled = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 9
  %5 = load i8, ptr %enabled, align 8
  %tobool2 = trunc i8 %5 to i1
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 16386, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %_v, ptr align 4 @__const.nvme_get_feature_fdp._v, i64 4, i1 false)
  %bf.load = load i8, ptr %_v, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %call = call i32 @deposit32(i32 noundef 0, i32 noundef 0, i32 noundef 1, i32 noundef %bf.cast)
  %conv = trunc i32 %call to i16
  store i16 %conv, ptr %_d, align 2
  %6 = load i16, ptr %_d, align 2
  store i16 %6, ptr %tmp, align 2
  %7 = load i16, ptr %tmp, align 2
  %conv3 = zext i16 %7 to i32
  %8 = load ptr, ptr %result.addr, align 8
  store i32 %conv3, ptr %8, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %_v4, ptr align 4 @__const.nvme_get_feature_fdp._v.402, i64 4, i1 false)
  %9 = load ptr, ptr %result.addr, align 8
  %10 = load i32, ptr %9, align 4
  %bf.load6 = load i8, ptr %_v4, align 4
  %bf.cast7 = zext i8 %bf.load6 to i32
  %call8 = call i32 @deposit32(i32 noundef %10, i32 noundef 8, i32 noundef 8, i32 noundef %bf.cast7)
  %conv9 = trunc i32 %call8 to i16
  store i16 %conv9, ptr %_d5, align 2
  %11 = load i16, ptr %_d5, align 2
  store i16 %11, ptr %tmp10, align 2
  %12 = load i16, ptr %tmp10, align 2
  %conv11 = zext i16 %12 to i32
  %13 = load ptr, ptr %result.addr, align 8
  store i32 %conv11, ptr %13, align 4
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_get_feature_fdp_events(ptr noundef %n, ptr noundef %ns, ptr noundef %req, ptr noundef %result) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %ns.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %cdw11 = alloca i32, align 4
  %ph = alloca i16, align 2
  %noet = alloca i8, align 1
  %ruhid = alloca i16, align 2
  %ret = alloca i16, align 2
  %nentries = alloca i32, align 4
  %s_events_ndx = alloca i8, align 1
  %s_events_siz = alloca i64, align 8
  %s_events = alloca ptr, align 8
  %ruh = alloca ptr, align 8
  %s_event = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %event_type = alloca i8, align 1
  %shift = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %req.addr, align 8
  %cmd1 = getelementptr inbounds %struct.NvmeRequest, ptr %0, i32 0, i32 6
  store ptr %cmd1, ptr %cmd, align 8
  %1 = load ptr, ptr %cmd, align 8
  %cdw112 = getelementptr inbounds %struct.NvmeCmd, ptr %1, i32 0, i32 8
  %2 = load i32, ptr %cdw112, align 1
  %call = call i32 @le32_to_cpu(i32 noundef %2)
  store i32 %call, ptr %cdw11, align 4
  %3 = load i32, ptr %cdw11, align 4
  %and = and i32 %3, 65535
  %conv = trunc i32 %and to i16
  store i16 %conv, ptr %ph, align 2
  %4 = load i32, ptr %cdw11, align 4
  %shr = lshr i32 %4, 16
  %and3 = and i32 %shr, 255
  %conv4 = trunc i32 %and3 to i8
  store i8 %conv4, ptr %noet, align 1
  store i32 0, ptr %nentries, align 4
  store i8 0, ptr %s_events_ndx, align 1
  %5 = load i8, ptr %noet, align 1
  %conv5 = zext i8 %5 to i64
  %mul = mul i64 2, %conv5
  store i64 %mul, ptr %s_events_siz, align 8
  %6 = load i64, ptr %s_events_siz, align 8
  %call6 = call noalias ptr @g_malloc0(i64 noundef %6) #14
  store ptr %call6, ptr %s_events, align 8
  %7 = load ptr, ptr %n.addr, align 8
  %subsys = getelementptr inbounds %struct.NvmeCtrl, ptr %7, i32 0, i32 33
  %8 = load ptr, ptr %subsys, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %9 = load ptr, ptr %n.addr, align 8
  %subsys7 = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 33
  %10 = load ptr, ptr %subsys7, align 8
  %endgrp = getelementptr inbounds %struct.NvmeSubsystem, ptr %10, i32 0, i32 6
  %fdp = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %endgrp, i32 0, i32 1
  %enabled = getelementptr inbounds %struct.anon.36, ptr %fdp, i32 0, i32 9
  %11 = load i8, ptr %enabled, align 8
  %tobool8 = trunc i8 %11 to i1
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i16 16425, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %12 = load ptr, ptr %ns.addr, align 8
  %13 = load i16, ptr %ph, align 2
  %call9 = call zeroext i1 @nvme_ph_valid(ptr noundef %12, i16 noundef zeroext %13)
  br i1 %call9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end
  store i16 16386, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end11:                                         ; preds = %if.end
  %14 = load ptr, ptr %ns.addr, align 8
  %fdp12 = getelementptr inbounds %struct.NvmeNamespace, ptr %14, i32 0, i32 34
  %phs = getelementptr inbounds %struct.anon.14, ptr %fdp12, i32 0, i32 1
  %15 = load ptr, ptr %phs, align 8
  %16 = load i16, ptr %ph, align 2
  %idxprom = zext i16 %16 to i64
  %arrayidx = getelementptr i16, ptr %15, i64 %idxprom
  %17 = load i16, ptr %arrayidx, align 2
  store i16 %17, ptr %ruhid, align 2
  %18 = load ptr, ptr %n.addr, align 8
  %subsys13 = getelementptr inbounds %struct.NvmeCtrl, ptr %18, i32 0, i32 33
  %19 = load ptr, ptr %subsys13, align 8
  %endgrp14 = getelementptr inbounds %struct.NvmeSubsystem, ptr %19, i32 0, i32 6
  %fdp15 = getelementptr inbounds %struct.NvmeEnduranceGroup, ptr %endgrp14, i32 0, i32 1
  %ruhs = getelementptr inbounds %struct.anon.36, ptr %fdp15, i32 0, i32 10
  %20 = load ptr, ptr %ruhs, align 8
  %21 = load i16, ptr %ruhid, align 2
  %idxprom16 = zext i16 %21 to i64
  %arrayidx17 = getelementptr %struct.NvmeRuHandle, ptr %20, i64 %idxprom16
  store ptr %arrayidx17, ptr %ruh, align 8
  %22 = load ptr, ptr %ruh, align 8
  %tobool18 = icmp ne ptr %22, null
  br i1 %tobool18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end11
  br label %if.end20

if.else:                                          ; preds = %if.end11
  call void @__assert_fail(ptr noundef @.str.403, ptr noundef @.str.1, i32 noundef 5842, ptr noundef @__PRETTY_FUNCTION__.nvme_get_feature_fdp_events) #12
  unreachable

if.end20:                                         ; preds = %if.then19
  %23 = load i8, ptr %noet, align 1
  %conv21 = zext i8 %23 to i32
  %cmp = icmp eq i32 %conv21, 0
  %lnot = xor i1 %cmp, true
  %lnot23 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot23 to i32
  %conv24 = sext i32 %lnot.ext to i64
  %tobool25 = icmp ne i64 %conv24, 0
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end20
  store i16 16386, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end27:                                         ; preds = %if.end20
  store i8 0, ptr %event_type, align 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end27
  %24 = load i8, ptr %event_type, align 1
  %conv28 = zext i8 %24 to i32
  %cmp29 = icmp slt i32 %conv28, 255
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %25 = load i8, ptr %event_type, align 1
  %idxprom31 = zext i8 %25 to i64
  %arrayidx32 = getelementptr [255 x i8], ptr @nvme_fdp_evf_shifts, i64 0, i64 %idxprom31
  %26 = load i8, ptr %arrayidx32, align 1
  store i8 %26, ptr %shift, align 1
  %27 = load i8, ptr %shift, align 1
  %tobool33 = icmp ne i8 %27, 0
  br i1 %tobool33, label %if.end37, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %28 = load i8, ptr %event_type, align 1
  %conv34 = zext i8 %28 to i32
  %tobool35 = icmp ne i32 %conv34, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %land.lhs.true
  br label %for.inc

if.end37:                                         ; preds = %land.lhs.true, %for.body
  %29 = load i32, ptr %nentries, align 4
  %inc = add i32 %29, 1
  store i32 %inc, ptr %nentries, align 4
  %30 = load ptr, ptr %s_events, align 8
  %31 = load i8, ptr %s_events_ndx, align 1
  %idxprom38 = zext i8 %31 to i64
  %arrayidx39 = getelementptr %struct.NvmeFdpEventDescr, ptr %30, i64 %idxprom38
  store ptr %arrayidx39, ptr %s_event, align 8
  %32 = load i8, ptr %event_type, align 1
  %33 = load ptr, ptr %s_event, align 8
  %evt = getelementptr inbounds %struct.NvmeFdpEventDescr, ptr %33, i32 0, i32 0
  store i8 %32, ptr %evt, align 1
  %34 = load ptr, ptr %ruh, align 8
  %event_filter = getelementptr inbounds %struct.NvmeRuHandle, ptr %34, i32 0, i32 2
  %35 = load i64, ptr %event_filter, align 8
  %36 = load i8, ptr %shift, align 1
  %conv40 = zext i8 %36 to i32
  %sh_prom = zext i32 %conv40 to i64
  %shr41 = lshr i64 %35, %sh_prom
  %and42 = and i64 %shr41, 1
  %conv43 = trunc i64 %and42 to i8
  %37 = load ptr, ptr %s_event, align 8
  %evta = getelementptr inbounds %struct.NvmeFdpEventDescr, ptr %37, i32 0, i32 1
  store i8 %conv43, ptr %evta, align 1
  %38 = load i8, ptr %s_events_ndx, align 1
  %inc44 = add i8 %38, 1
  store i8 %inc44, ptr %s_events_ndx, align 1
  %conv45 = zext i8 %inc44 to i32
  %39 = load i8, ptr %noet, align 1
  %conv46 = zext i8 %39 to i32
  %cmp47 = icmp eq i32 %conv45, %conv46
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end37
  br label %for.end

if.end50:                                         ; preds = %if.end37
  br label %for.inc

for.inc:                                          ; preds = %if.end50, %if.then36
  %40 = load i8, ptr %event_type, align 1
  %inc51 = add i8 %40, 1
  store i8 %inc51, ptr %event_type, align 1
  br label %for.cond, !llvm.loop !63

for.end:                                          ; preds = %if.then49, %for.cond
  %41 = load ptr, ptr %n.addr, align 8
  %42 = load ptr, ptr %s_events, align 8
  %43 = load i64, ptr %s_events_siz, align 8
  %conv52 = trunc i64 %43 to i32
  %44 = load ptr, ptr %req.addr, align 8
  %call53 = call zeroext i16 @nvme_c2h(ptr noundef %41, ptr noundef %42, i32 noundef %conv52, ptr noundef %44)
  store i16 %call53, ptr %ret, align 2
  %45 = load i16, ptr %ret, align 2
  %tobool54 = icmp ne i16 %45, 0
  br i1 %tobool54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %for.end
  %46 = load i16, ptr %ret, align 2
  store i16 %46, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end56:                                         ; preds = %for.end
  %47 = load i32, ptr %nentries, align 4
  %48 = load ptr, ptr %result.addr, align 8
  store i32 %47, ptr %48, align 4
  store i16 0, ptr %retval, align 2
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end56, %if.then55, %if.then26, %if.then10, %if.then
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %s_events)
  %49 = load i16, ptr %retval, align 2
  ret i16 %49
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_getfeat_numq(i32 noundef %result) #0 {
entry:
  %result.addr = alloca i32, align 4
  store i32 %result, ptr %result.addr, align 4
  %0 = load i32, ptr %result.addr, align 4
  call void @_nocheck__trace_pci_nvme_getfeat_numq(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_getfeat(i16 noundef zeroext %cid, i32 noundef %nsid, i8 noundef zeroext %fid, i8 noundef zeroext %sel, i32 noundef %cdw11) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %nsid.addr = alloca i32, align 4
  %fid.addr = alloca i8, align 1
  %sel.addr = alloca i8, align 1
  %cdw11.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i32 %nsid, ptr %nsid.addr, align 4
  store i8 %fid, ptr %fid.addr, align 1
  store i8 %sel, ptr %sel.addr, align 1
  store i32 %cdw11, ptr %cdw11.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_GETFEAT_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end17

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end17

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i32, ptr %nsid.addr, align 4
  %7 = load i8, ptr %fid.addr, align 1
  %conv12 = zext i8 %7 to i32
  %8 = load i8, ptr %sel.addr, align 1
  %conv13 = zext i8 %8 to i32
  %9 = load i32, ptr %cdw11.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.398, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %6, i32 noundef %conv12, i32 noundef %conv13, i32 noundef %9)
  br label %if.end

if.else:                                          ; preds = %if.then
  %10 = load i16, ptr %cid.addr, align 2
  %conv14 = zext i16 %10 to i32
  %11 = load i32, ptr %nsid.addr, align 4
  %12 = load i8, ptr %fid.addr, align 1
  %conv15 = zext i8 %12 to i32
  %13 = load i8, ptr %sel.addr, align 1
  %conv16 = zext i8 %13 to i32
  %14 = load i32, ptr %cdw11.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.399, i32 noundef %conv14, i32 noundef %11, i32 noundef %conv15, i32 noundef %conv16, i32 noundef %14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end17

if.end17:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_getfeat_vwcache(ptr noundef %result) #0 {
entry:
  %result.addr = alloca ptr, align 8
  %_now = alloca %struct.timeval, align 8
  store ptr %result, ptr %result.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_GETFEAT_VWCACHE_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load ptr, ptr %result.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.400, i32 noundef %call10, i64 noundef %3, i64 noundef %4, ptr noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load ptr, ptr %result.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.401, ptr noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_getfeat_numq(i32 noundef %result) #0 {
entry:
  %result.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %result, ptr %result.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_GETFEAT_NUMQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %result.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.404, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %result.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.405, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_aer(i16 noundef zeroext %cid) #0 {
entry:
  %cid.addr = alloca i16, align 2
  store i16 %cid, ptr %cid.addr, align 2
  %0 = load i16, ptr %cid.addr, align 2
  call void @_nocheck__trace_pci_nvme_aer(i16 noundef zeroext %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_aer_aerl_exceeded() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_aer_aerl_exceeded()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_aer(i16 noundef zeroext %cid) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_AER_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.406, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i16, ptr %cid.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.407, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_aer_aerl_exceeded() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_AER_AERL_EXCEEDED_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.408, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.409)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ns_attachment(i16 noundef zeroext %cid, i8 noundef zeroext %sel) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %sel.addr = alloca i8, align 1
  store i16 %cid, ptr %cid.addr, align 2
  store i8 %sel, ptr %sel.addr, align 1
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i8, ptr %sel.addr, align 1
  call void @_nocheck__trace_pci_nvme_ns_attachment(i16 noundef zeroext %0, i8 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_select_iocs_ns(ptr noundef %n, ptr noundef %ns) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %ns.addr = alloca ptr, align 8
  %cc = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %ns, ptr %ns.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %bar = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 3
  %cc1 = getelementptr inbounds %struct.NvmeBar, ptr %bar, i32 0, i32 4
  %call = call i32 @ldl_le_p(ptr noundef %cc1)
  store i32 %call, ptr %cc, align 4
  %1 = load ptr, ptr %ns.addr, align 8
  %iocs = getelementptr inbounds %struct.NvmeNamespace, ptr %1, i32 0, i32 10
  store ptr @nvme_cse_iocs_none, ptr %iocs, align 8
  %2 = load ptr, ptr %ns.addr, align 8
  %csi = getelementptr inbounds %struct.NvmeNamespace, ptr %2, i32 0, i32 11
  %3 = load i8, ptr %csi, align 8
  %conv = zext i8 %3 to i32
  switch i32 %conv, label %sw.epilog [
    i32 0, label %sw.bb
    i32 2, label %sw.bb4
  ]

sw.bb:                                            ; preds = %entry
  %4 = load i32, ptr %cc, align 4
  %shr = lshr i32 %4, 4
  %and = and i32 %shr, 7
  %cmp = icmp ne i32 %and, 7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %5 = load ptr, ptr %ns.addr, align 8
  %iocs3 = getelementptr inbounds %struct.NvmeNamespace, ptr %5, i32 0, i32 10
  store ptr @nvme_cse_iocs_nvm, ptr %iocs3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %6 = load i32, ptr %cc, align 4
  %shr5 = lshr i32 %6, 4
  %and6 = and i32 %shr5, 7
  %cmp7 = icmp eq i32 %and6, 6
  br i1 %cmp7, label %if.then9, label %if.else

if.then9:                                         ; preds = %sw.bb4
  %7 = load ptr, ptr %ns.addr, align 8
  %iocs10 = getelementptr inbounds %struct.NvmeNamespace, ptr %7, i32 0, i32 10
  store ptr @nvme_cse_iocs_zoned, ptr %iocs10, align 8
  br label %if.end18

if.else:                                          ; preds = %sw.bb4
  %8 = load i32, ptr %cc, align 4
  %shr11 = lshr i32 %8, 4
  %and12 = and i32 %shr11, 7
  %cmp13 = icmp eq i32 %and12, 0
  br i1 %cmp13, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.else
  %9 = load ptr, ptr %ns.addr, align 8
  %iocs16 = getelementptr inbounds %struct.NvmeNamespace, ptr %9, i32 0, i32 10
  store ptr @nvme_cse_iocs_nvm, ptr %iocs16, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.else
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.then9
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end18, %if.end, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_update_dmrsl(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %nsid = alloca i32, align 4
  %ns = alloca ptr, align 8
  %_a49 = alloca i64, align 8
  %_b50 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store i32 1, ptr %nsid, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %nsid, align 4
  %cmp = icmp sle i32 %0, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %n.addr, align 8
  %2 = load i32, ptr %nsid, align 4
  %call = call ptr @nvme_ns(ptr noundef %1, i32 noundef %2)
  store ptr %call, ptr %ns, align 8
  %3 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %4 = load ptr, ptr %n.addr, align 8
  %dmrsl = getelementptr inbounds %struct.NvmeCtrl, ptr %4, i32 0, i32 31
  %5 = load i32, ptr %dmrsl, align 4
  %conv = zext i32 %5 to i64
  store i64 %conv, ptr %_a49, align 8
  %6 = load ptr, ptr %ns, align 8
  %call1 = call i64 @nvme_l2b(ptr noundef %6, i64 noundef 1)
  %div = udiv i64 2147483136, %call1
  store i64 %div, ptr %_b50, align 8
  %7 = load i64, ptr %_a49, align 8
  %cmp2 = icmp eq i64 %7, 0
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %8 = load i64, ptr %_b50, align 8
  br label %cond.end10

cond.false:                                       ; preds = %if.end
  %9 = load i64, ptr %_b50, align 8
  %cmp4 = icmp eq i64 %9, 0
  br i1 %cmp4, label %cond.true8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.false
  %10 = load i64, ptr %_b50, align 8
  %11 = load i64, ptr %_a49, align 8
  %cmp6 = icmp ugt i64 %10, %11
  br i1 %cmp6, label %cond.true8, label %cond.false9

cond.true8:                                       ; preds = %lor.lhs.false, %cond.false
  %12 = load i64, ptr %_a49, align 8
  br label %cond.end

cond.false9:                                      ; preds = %lor.lhs.false
  %13 = load i64, ptr %_b50, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false9, %cond.true8
  %cond = phi i64 [ %12, %cond.true8 ], [ %13, %cond.false9 ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end, %cond.true
  %cond11 = phi i64 [ %8, %cond.true ], [ %cond, %cond.end ]
  store i64 %cond11, ptr %tmp, align 8
  %14 = load i64, ptr %tmp, align 8
  %conv12 = trunc i64 %14 to i32
  %15 = load ptr, ptr %n.addr, align 8
  %dmrsl13 = getelementptr inbounds %struct.NvmeCtrl, ptr %15, i32 0, i32 31
  store i32 %conv12, ptr %dmrsl13, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end10, %if.then
  %16 = load i32, ptr %nsid, align 4
  %inc = add i32 %16, 1
  store i32 %inc, ptr %nsid, align 4
  br label %for.cond, !llvm.loop !64

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @test_and_set_bit(i64 noundef %nr, ptr noundef %addr) #0 {
entry:
  %nr.addr = alloca i64, align 8
  %addr.addr = alloca ptr, align 8
  %mask = alloca i64, align 8
  %p = alloca ptr, align 8
  %old = alloca i64, align 8
  store i64 %nr, ptr %nr.addr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  %0 = load i64, ptr %nr.addr, align 8
  %rem = urem i64 %0, 64
  %shl = shl i64 1, %rem
  store i64 %shl, ptr %mask, align 8
  %1 = load ptr, ptr %addr.addr, align 8
  %2 = load i64, ptr %nr.addr, align 8
  %div = udiv i64 %2, 64
  %add.ptr = getelementptr i64, ptr %1, i64 %div
  store ptr %add.ptr, ptr %p, align 8
  %3 = load ptr, ptr %p, align 8
  %4 = load i64, ptr %3, align 8
  store i64 %4, ptr %old, align 8
  %5 = load i64, ptr %old, align 8
  %6 = load i64, ptr %mask, align 8
  %or = or i64 %5, %6
  %7 = load ptr, ptr %p, align 8
  store i64 %or, ptr %7, align 8
  %8 = load i64, ptr %old, align 8
  %9 = load i64, ptr %mask, align 8
  %and = and i64 %8, %9
  %cmp = icmp ne i64 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ns_attachment(i16 noundef zeroext %cid, i8 noundef zeroext %sel) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %sel.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i8 %sel, ptr %sel.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_NS_ATTACHMENT_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i8, ptr %sel.addr, align 1
  %conv12 = zext i8 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.410, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %cid.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i8, ptr %sel.addr, align 1
  %conv14 = zext i8 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.411, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_virt_mngmt(i16 noundef zeroext %cid, i16 noundef zeroext %act, i16 noundef zeroext %cntlid, ptr noundef %rt, i16 noundef zeroext %nr) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %act.addr = alloca i16, align 2
  %cntlid.addr = alloca i16, align 2
  %rt.addr = alloca ptr, align 8
  %nr.addr = alloca i16, align 2
  store i16 %cid, ptr %cid.addr, align 2
  store i16 %act, ptr %act.addr, align 2
  store i16 %cntlid, ptr %cntlid.addr, align 2
  store ptr %rt, ptr %rt.addr, align 8
  store i16 %nr, ptr %nr.addr, align 2
  %0 = load i16, ptr %cid.addr, align 2
  %1 = load i16, ptr %act.addr, align 2
  %2 = load i16, ptr %cntlid.addr, align 2
  %3 = load ptr, ptr %rt.addr, align 8
  %4 = load i16, ptr %nr.addr, align 2
  call void @_nocheck__trace_pci_nvme_virt_mngmt(i16 noundef zeroext %0, i16 noundef zeroext %1, i16 noundef zeroext %2, ptr noundef %3, i16 noundef zeroext %4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_assign_virt_res_to_sec(ptr noundef %n, ptr noundef %req, i16 noundef zeroext %cntlid, i8 noundef zeroext %rt, i32 noundef %nr) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %cntlid.addr = alloca i16, align 2
  %rt.addr = alloca i8, align 1
  %nr.addr = alloca i32, align 4
  %num_total = alloca i32, align 4
  %num_prim = alloca i32, align 4
  %num_sec = alloca i32, align 4
  %num_free = alloca i32, align 4
  %diff = alloca i32, align 4
  %limit = alloca i32, align 4
  %sctrl = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  store i16 %cntlid, ptr %cntlid.addr, align 2
  store i8 %rt, ptr %rt.addr, align 1
  store i32 %nr, ptr %nr.addr, align 4
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load i16, ptr %cntlid.addr, align 2
  %call = call ptr @nvme_sctrl_for_cntlid(ptr noundef %0, i16 noundef zeroext %1)
  store ptr %call, ptr %sctrl, align 8
  %2 = load ptr, ptr %sctrl, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 16671, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %sctrl, align 8
  %scs = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %3, i32 0, i32 2
  %4 = load i8, ptr %scs, align 1
  %tobool1 = icmp ne i8 %4, 0
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i16 16672, ptr %retval, align 2
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load i8, ptr %rt.addr, align 1
  %conv = zext i8 %5 to i32
  %tobool4 = icmp ne i32 %conv, 0
  br i1 %tobool4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end3
  %6 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap = getelementptr inbounds %struct.NvmeCtrl, ptr %6, i32 0, i32 42
  %vifrsm = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap, i32 0, i32 15
  %7 = load i16, ptr %vifrsm, align 4
  %conv5 = zext i16 %7 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end3
  %8 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap6 = getelementptr inbounds %struct.NvmeCtrl, ptr %8, i32 0, i32 42
  %vqfrsm = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap6, i32 0, i32 8
  %9 = load i16, ptr %vqfrsm, align 4
  %conv7 = zext i16 %9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ %conv7, %cond.false ]
  %conv8 = trunc i32 %cond to i16
  %call9 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %conv8)
  %conv10 = zext i16 %call9 to i32
  store i32 %conv10, ptr %limit, align 4
  %10 = load i32, ptr %nr.addr, align 4
  %11 = load i32, ptr %limit, align 4
  %cmp = icmp sgt i32 %10, %11
  br i1 %cmp, label %if.then12, label %if.end13

if.then12:                                        ; preds = %cond.end
  store i16 16673, ptr %retval, align 2
  br label %return

if.end13:                                         ; preds = %cond.end
  %12 = load ptr, ptr %n.addr, align 8
  %13 = load i8, ptr %rt.addr, align 1
  call void @nvme_get_virt_res_num(ptr noundef %12, i8 noundef zeroext %13, ptr noundef %num_total, ptr noundef %num_prim, ptr noundef %num_sec)
  %14 = load i32, ptr %num_total, align 4
  %15 = load i32, ptr %num_prim, align 4
  %sub = sub i32 %14, %15
  %16 = load i32, ptr %num_sec, align 4
  %sub14 = sub i32 %sub, %16
  store i32 %sub14, ptr %num_free, align 4
  %17 = load i32, ptr %nr.addr, align 4
  %18 = load i8, ptr %rt.addr, align 1
  %conv15 = zext i8 %18 to i32
  %tobool16 = icmp ne i32 %conv15, 0
  br i1 %tobool16, label %cond.true17, label %cond.false19

cond.true17:                                      ; preds = %if.end13
  %19 = load ptr, ptr %sctrl, align 8
  %nvi = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %19, i32 0, i32 6
  %20 = load i16, ptr %nvi, align 1
  %conv18 = zext i16 %20 to i32
  br label %cond.end21

cond.false19:                                     ; preds = %if.end13
  %21 = load ptr, ptr %sctrl, align 8
  %nvq = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %21, i32 0, i32 5
  %22 = load i16, ptr %nvq, align 1
  %conv20 = zext i16 %22 to i32
  br label %cond.end21

cond.end21:                                       ; preds = %cond.false19, %cond.true17
  %cond22 = phi i32 [ %conv18, %cond.true17 ], [ %conv20, %cond.false19 ]
  %conv23 = trunc i32 %cond22 to i16
  %call24 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %conv23)
  %conv25 = zext i16 %call24 to i32
  %sub26 = sub i32 %17, %conv25
  store i32 %sub26, ptr %diff, align 4
  %23 = load i32, ptr %diff, align 4
  %24 = load i32, ptr %num_free, align 4
  %cmp27 = icmp sgt i32 %23, %24
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %cond.end21
  store i16 16674, ptr %retval, align 2
  br label %return

if.end30:                                         ; preds = %cond.end21
  %25 = load ptr, ptr %n.addr, align 8
  %26 = load ptr, ptr %sctrl, align 8
  %27 = load i8, ptr %rt.addr, align 1
  %28 = load i32, ptr %nr.addr, align 4
  call void @nvme_update_virt_res(ptr noundef %25, ptr noundef %26, i8 noundef zeroext %27, i32 noundef %28)
  %29 = load i32, ptr %nr.addr, align 4
  %call31 = call i32 @cpu_to_le32(i32 noundef %29)
  %30 = load ptr, ptr %req.addr, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %30, i32 0, i32 5
  %result = getelementptr inbounds %struct.NvmeCqe, ptr %cqe, i32 0, i32 0
  store i32 %call31, ptr %result, align 8
  %31 = load ptr, ptr %req.addr, align 8
  %status = getelementptr inbounds %struct.NvmeRequest, ptr %31, i32 0, i32 3
  %32 = load i16, ptr %status, align 8
  store i16 %32, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end30, %if.then29, %if.then12, %if.then2, %if.then
  %33 = load i16, ptr %retval, align 2
  ret i16 %33
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_assign_virt_res_to_prim(ptr noundef %n, ptr noundef %req, i16 noundef zeroext %cntlid, i8 noundef zeroext %rt, i32 noundef %nr) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %req.addr = alloca ptr, align 8
  %cntlid.addr = alloca i16, align 2
  %rt.addr = alloca i8, align 1
  %nr.addr = alloca i32, align 4
  %num_total = alloca i32, align 4
  %num_prim = alloca i32, align 4
  %num_sec = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %req, ptr %req.addr, align 8
  store i16 %cntlid, ptr %cntlid.addr, align 2
  store i8 %rt, ptr %rt.addr, align 1
  store i32 %nr, ptr %nr.addr, align 4
  %0 = load i16, ptr %cntlid.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load ptr, ptr %n.addr, align 8
  %cntlid1 = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 6
  %2 = load i16, ptr %cntlid1, align 8
  %conv2 = zext i16 %2 to i32
  %cmp = icmp ne i32 %conv, %conv2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 16671, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %4 = load i8, ptr %rt.addr, align 1
  call void @nvme_get_virt_res_num(ptr noundef %3, i8 noundef zeroext %4, ptr noundef %num_total, ptr noundef %num_prim, ptr noundef %num_sec)
  %5 = load i32, ptr %nr.addr, align 4
  %6 = load i32, ptr %num_total, align 4
  %cmp4 = icmp sgt i32 %5, %6
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i16 16673, ptr %retval, align 2
  br label %return

if.end7:                                          ; preds = %if.end
  %7 = load i32, ptr %nr.addr, align 4
  %8 = load i32, ptr %num_total, align 4
  %9 = load i32, ptr %num_sec, align 4
  %sub = sub i32 %8, %9
  %cmp8 = icmp sgt i32 %7, %sub
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  store i16 16674, ptr %retval, align 2
  br label %return

if.end11:                                         ; preds = %if.end7
  %10 = load i8, ptr %rt.addr, align 1
  %tobool = icmp ne i8 %10, 0
  br i1 %tobool, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end11
  %11 = load i32, ptr %nr.addr, align 4
  %conv13 = trunc i32 %11 to i16
  %call = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv13)
  %12 = load ptr, ptr %n.addr, align 8
  %next_pri_ctrl_cap = getelementptr inbounds %struct.NvmeCtrl, ptr %12, i32 0, i32 44
  %virfap = getelementptr inbounds %struct.anon.30, ptr %next_pri_ctrl_cap, i32 0, i32 1
  store i16 %call, ptr %virfap, align 2
  br label %if.end17

if.else:                                          ; preds = %if.end11
  %13 = load i32, ptr %nr.addr, align 4
  %conv14 = trunc i32 %13 to i16
  %call15 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv14)
  %14 = load ptr, ptr %n.addr, align 8
  %next_pri_ctrl_cap16 = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 44
  %vqrfap = getelementptr inbounds %struct.anon.30, ptr %next_pri_ctrl_cap16, i32 0, i32 0
  store i16 %call15, ptr %vqrfap, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then12
  %15 = load i32, ptr %nr.addr, align 4
  %call18 = call i32 @cpu_to_le32(i32 noundef %15)
  %16 = load ptr, ptr %req.addr, align 8
  %cqe = getelementptr inbounds %struct.NvmeRequest, ptr %16, i32 0, i32 5
  %result = getelementptr inbounds %struct.NvmeCqe, ptr %cqe, i32 0, i32 0
  store i32 %call18, ptr %result, align 8
  %17 = load ptr, ptr %req.addr, align 8
  %status = getelementptr inbounds %struct.NvmeRequest, ptr %17, i32 0, i32 3
  %18 = load i16, ptr %status, align 8
  store i16 %18, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end17, %if.then10, %if.then6, %if.then
  %19 = load i16, ptr %retval, align 2
  ret i16 %19
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_virt_set_state(ptr noundef %n, i16 noundef zeroext %cntlid, i1 noundef zeroext %online) #0 {
entry:
  %retval = alloca i16, align 2
  %n.addr = alloca ptr, align 8
  %cntlid.addr = alloca i16, align 2
  %online.addr = alloca i8, align 1
  %pci = alloca ptr, align 8
  %sn = alloca ptr, align 8
  %sctrl = alloca ptr, align 8
  %vf_index = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store i16 %cntlid, ptr %cntlid.addr, align 2
  %frombool = zext i1 %online to i8
  store i8 %frombool, ptr %online.addr, align 1
  %0 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %0)
  store ptr %call, ptr %pci, align 8
  store ptr null, ptr %sn, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %2 = load i16, ptr %cntlid.addr, align 2
  %call1 = call ptr @nvme_sctrl_for_cntlid(ptr noundef %1, i16 noundef zeroext %2)
  store ptr %call1, ptr %sctrl, align 8
  %3 = load ptr, ptr %sctrl, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i16 16671, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %pci, align 8
  %call2 = call i32 @pci_is_vf(ptr noundef %4)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end8, label %if.then4

if.then4:                                         ; preds = %if.end
  %5 = load ptr, ptr %sctrl, align 8
  %vfn = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %5, i32 0, i32 4
  %6 = load i16, ptr %vfn, align 1
  %call5 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %6)
  %conv = zext i16 %call5 to i32
  %sub = sub i32 %conv, 1
  store i32 %sub, ptr %vf_index, align 4
  %7 = load ptr, ptr %pci, align 8
  %8 = load i32, ptr %vf_index, align 4
  %call6 = call ptr @pcie_sriov_get_vf_at_index(ptr noundef %7, i32 noundef %8)
  %call7 = call ptr @object_dynamic_cast_assert(ptr noundef %call6, ptr noundef @.str.49, ptr noundef @.str.1, i32 noundef 6751, ptr noundef @__func__.nvme_virt_set_state)
  store ptr %call7, ptr %sn, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %if.end
  %9 = load i8, ptr %online.addr, align 1
  %tobool9 = trunc i8 %9 to i1
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end8
  %10 = load ptr, ptr %sctrl, align 8
  %nvi = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %10, i32 0, i32 6
  %11 = load i16, ptr %nvi, align 1
  %tobool11 = icmp ne i16 %11, 0
  br i1 %tobool11, label %lor.lhs.false, label %if.then17

lor.lhs.false:                                    ; preds = %if.then10
  %12 = load ptr, ptr %sctrl, align 8
  %nvq = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %12, i32 0, i32 5
  %13 = load i16, ptr %nvq, align 1
  %call12 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %13)
  %conv13 = zext i16 %call12 to i32
  %cmp = icmp slt i32 %conv13, 2
  br i1 %cmp, label %if.then17, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %lor.lhs.false
  %14 = load ptr, ptr %sn, align 8
  %tobool16 = icmp ne ptr %14, null
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %lor.lhs.false15, %lor.lhs.false, %if.then10
  store i16 16672, ptr %retval, align 2
  br label %return

if.end18:                                         ; preds = %lor.lhs.false15
  %15 = load ptr, ptr %sctrl, align 8
  %scs = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %15, i32 0, i32 2
  %16 = load i8, ptr %scs, align 1
  %tobool19 = icmp ne i8 %16, 0
  br i1 %tobool19, label %if.end22, label %if.then20

if.then20:                                        ; preds = %if.end18
  %17 = load ptr, ptr %sctrl, align 8
  %scs21 = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %17, i32 0, i32 2
  store i8 1, ptr %scs21, align 1
  %18 = load ptr, ptr %sn, align 8
  call void @nvme_ctrl_reset(ptr noundef %18, i32 noundef 0)
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %if.end18
  br label %if.end31

if.else:                                          ; preds = %if.end8
  %19 = load ptr, ptr %n.addr, align 8
  %20 = load ptr, ptr %sctrl, align 8
  call void @nvme_update_virt_res(ptr noundef %19, ptr noundef %20, i8 noundef zeroext 1, i32 noundef 0)
  %21 = load ptr, ptr %n.addr, align 8
  %22 = load ptr, ptr %sctrl, align 8
  call void @nvme_update_virt_res(ptr noundef %21, ptr noundef %22, i8 noundef zeroext 0, i32 noundef 0)
  %23 = load ptr, ptr %sctrl, align 8
  %scs23 = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %23, i32 0, i32 2
  %24 = load i8, ptr %scs23, align 1
  %tobool24 = icmp ne i8 %24, 0
  br i1 %tobool24, label %if.then25, label %if.end30

if.then25:                                        ; preds = %if.else
  %25 = load ptr, ptr %sctrl, align 8
  %scs26 = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %25, i32 0, i32 2
  store i8 0, ptr %scs26, align 1
  %26 = load ptr, ptr %sn, align 8
  %tobool27 = icmp ne ptr %26, null
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.then25
  %27 = load ptr, ptr %sn, align 8
  call void @nvme_ctrl_reset(ptr noundef %27, i32 noundef 0)
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.then25
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %if.else
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.end22
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end31, %if.then17, %if.then
  %28 = load i16, ptr %retval, align 2
  ret i16 %28
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_virt_mngmt(i16 noundef zeroext %cid, i16 noundef zeroext %act, i16 noundef zeroext %cntlid, ptr noundef %rt, i16 noundef zeroext %nr) #0 {
entry:
  %cid.addr = alloca i16, align 2
  %act.addr = alloca i16, align 2
  %cntlid.addr = alloca i16, align 2
  %rt.addr = alloca ptr, align 8
  %nr.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cid, ptr %cid.addr, align 2
  store i16 %act, ptr %act.addr, align 2
  store i16 %cntlid, ptr %cntlid.addr, align 2
  store ptr %rt, ptr %rt.addr, align 8
  store i16 %nr, ptr %nr.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_VIRT_MNGMT_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end19

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i16, ptr %act.addr, align 2
  %conv12 = zext i16 %6 to i32
  %7 = load i16, ptr %cntlid.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load ptr, ptr %rt.addr, align 8
  %9 = load i16, ptr %nr.addr, align 2
  %conv14 = zext i16 %9 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.414, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12, i32 noundef %conv13, ptr noundef %8, i32 noundef %conv14)
  br label %if.end

if.else:                                          ; preds = %if.then
  %10 = load i16, ptr %cid.addr, align 2
  %conv15 = zext i16 %10 to i32
  %11 = load i16, ptr %act.addr, align 2
  %conv16 = zext i16 %11 to i32
  %12 = load i16, ptr %cntlid.addr, align 2
  %conv17 = zext i16 %12 to i32
  %13 = load ptr, ptr %rt.addr, align 8
  %14 = load i16, ptr %nr.addr, align 2
  %conv18 = zext i16 %14 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.415, i32 noundef %conv15, i32 noundef %conv16, i32 noundef %conv17, ptr noundef %13, i32 noundef %conv18)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end19

if.end19:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @nvme_sctrl_for_cntlid(ptr noundef %n, i16 noundef zeroext %cntlid) #0 {
entry:
  %retval = alloca ptr, align 8
  %n.addr = alloca ptr, align 8
  %cntlid.addr = alloca i16, align 2
  %list = alloca ptr, align 8
  %i = alloca i8, align 1
  store ptr %n, ptr %n.addr, align 8
  store i16 %cntlid, ptr %cntlid.addr, align 2
  %0 = load ptr, ptr %n.addr, align 8
  %sec_ctrl_list = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 43
  store ptr %sec_ctrl_list, ptr %list, align 8
  store i8 0, ptr %i, align 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8, ptr %i, align 1
  %conv = zext i8 %1 to i32
  %2 = load ptr, ptr %list, align 8
  %numcntl = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %2, i32 0, i32 0
  %3 = load i8, ptr %numcntl, align 1
  %conv1 = zext i8 %3 to i32
  %cmp = icmp slt i32 %conv, %conv1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %list, align 8
  %sec = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %4, i32 0, i32 2
  %5 = load i8, ptr %i, align 1
  %idxprom = zext i8 %5 to i64
  %arrayidx = getelementptr [127 x %struct.NvmeSecCtrlEntry], ptr %sec, i64 0, i64 %idxprom
  %scid = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %arrayidx, i32 0, i32 0
  %6 = load i16, ptr %scid, align 1
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %6)
  %conv3 = zext i16 %call to i32
  %7 = load i16, ptr %cntlid.addr, align 2
  %conv4 = zext i16 %7 to i32
  %cmp5 = icmp eq i32 %conv3, %conv4
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load ptr, ptr %list, align 8
  %sec7 = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %8, i32 0, i32 2
  %9 = load i8, ptr %i, align 1
  %idxprom8 = zext i8 %9 to i64
  %arrayidx9 = getelementptr [127 x %struct.NvmeSecCtrlEntry], ptr %sec7, i64 0, i64 %idxprom8
  store ptr %arrayidx9, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i8, ptr %i, align 1
  %inc = add i8 %10, 1
  store i8 %inc, ptr %i, align 1
  br label %for.cond, !llvm.loop !65

for.end:                                          ; preds = %for.cond
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_get_virt_res_num(ptr noundef %n, i8 noundef zeroext %rt, ptr noundef %num_total, ptr noundef %num_prim, ptr noundef %num_sec) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %rt.addr = alloca i8, align 1
  %num_total.addr = alloca ptr, align 8
  %num_prim.addr = alloca ptr, align 8
  %num_sec.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store i8 %rt, ptr %rt.addr, align 1
  store ptr %num_total, ptr %num_total.addr, align 8
  store ptr %num_prim, ptr %num_prim.addr, align 8
  store ptr %num_sec, ptr %num_sec.addr, align 8
  %0 = load i8, ptr %rt.addr, align 1
  %conv = zext i8 %0 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 42
  %vifrt = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap, i32 0, i32 11
  %2 = load i32, ptr %vifrt, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap1 = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 42
  %vqfrt = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap1, i32 0, i32 4
  %4 = load i32, ptr %vqfrt, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ %4, %cond.false ]
  %call = call i32 @le32_to_cpu(i32 noundef %cond)
  %5 = load ptr, ptr %num_total.addr, align 8
  store i32 %call, ptr %5, align 4
  %6 = load i8, ptr %rt.addr, align 1
  %conv2 = zext i8 %6 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br i1 %tobool3, label %cond.true4, label %cond.false7

cond.true4:                                       ; preds = %cond.end
  %7 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap5 = getelementptr inbounds %struct.NvmeCtrl, ptr %7, i32 0, i32 42
  %virfap = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap5, i32 0, i32 13
  %8 = load i16, ptr %virfap, align 8
  %conv6 = zext i16 %8 to i32
  br label %cond.end10

cond.false7:                                      ; preds = %cond.end
  %9 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap8 = getelementptr inbounds %struct.NvmeCtrl, ptr %9, i32 0, i32 42
  %vqrfap = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap8, i32 0, i32 6
  %10 = load i16, ptr %vqrfap, align 8
  %conv9 = zext i16 %10 to i32
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false7, %cond.true4
  %cond11 = phi i32 [ %conv6, %cond.true4 ], [ %conv9, %cond.false7 ]
  %conv12 = trunc i32 %cond11 to i16
  %call13 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %conv12)
  %conv14 = zext i16 %call13 to i32
  %11 = load ptr, ptr %num_prim.addr, align 8
  store i32 %conv14, ptr %11, align 4
  %12 = load i8, ptr %rt.addr, align 1
  %conv15 = zext i8 %12 to i32
  %tobool16 = icmp ne i32 %conv15, 0
  br i1 %tobool16, label %cond.true17, label %cond.false19

cond.true17:                                      ; preds = %cond.end10
  %13 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap18 = getelementptr inbounds %struct.NvmeCtrl, ptr %13, i32 0, i32 42
  %virfa = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap18, i32 0, i32 12
  %14 = load i32, ptr %virfa, align 4
  br label %cond.end21

cond.false19:                                     ; preds = %cond.end10
  %15 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap20 = getelementptr inbounds %struct.NvmeCtrl, ptr %15, i32 0, i32 42
  %vqrfa = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap20, i32 0, i32 5
  %16 = load i32, ptr %vqrfa, align 4
  br label %cond.end21

cond.end21:                                       ; preds = %cond.false19, %cond.true17
  %cond22 = phi i32 [ %14, %cond.true17 ], [ %16, %cond.false19 ]
  %conv23 = trunc i32 %cond22 to i16
  %call24 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %conv23)
  %conv25 = zext i16 %call24 to i32
  %17 = load ptr, ptr %num_sec.addr, align 8
  store i32 %conv25, ptr %17, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_update_virt_res(ptr noundef %n, ptr noundef %sctrl, i8 noundef zeroext %rt, i32 noundef %nr) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %sctrl.addr = alloca ptr, align 8
  %rt.addr = alloca i8, align 1
  %nr.addr = alloca i32, align 4
  %prev_nr = alloca i32, align 4
  %prev_total = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %sctrl, ptr %sctrl.addr, align 8
  store i8 %rt, ptr %rt.addr, align 1
  store i32 %nr, ptr %nr.addr, align 4
  %0 = load i8, ptr %rt.addr, align 1
  %tobool = icmp ne i8 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %sctrl.addr, align 8
  %nvi = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %1, i32 0, i32 6
  %2 = load i16, ptr %nvi, align 1
  %call = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %2)
  %conv = zext i16 %call to i32
  store i32 %conv, ptr %prev_nr, align 4
  %3 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap = getelementptr inbounds %struct.NvmeCtrl, ptr %3, i32 0, i32 42
  %virfa = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap, i32 0, i32 12
  %4 = load i32, ptr %virfa, align 4
  %call1 = call i32 @le32_to_cpu(i32 noundef %4)
  store i32 %call1, ptr %prev_total, align 4
  %5 = load i32, ptr %nr.addr, align 4
  %conv2 = trunc i32 %5 to i16
  %call3 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv2)
  %6 = load ptr, ptr %sctrl.addr, align 8
  %nvi4 = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %6, i32 0, i32 6
  store i16 %call3, ptr %nvi4, align 1
  %7 = load i32, ptr %prev_total, align 4
  %8 = load i32, ptr %nr.addr, align 4
  %add = add i32 %7, %8
  %9 = load i32, ptr %prev_nr, align 4
  %sub = sub i32 %add, %9
  %call5 = call i32 @cpu_to_le32(i32 noundef %sub)
  %10 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap6 = getelementptr inbounds %struct.NvmeCtrl, ptr %10, i32 0, i32 42
  %virfa7 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap6, i32 0, i32 12
  store i32 %call5, ptr %virfa7, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %11 = load ptr, ptr %sctrl.addr, align 8
  %nvq = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %11, i32 0, i32 5
  %12 = load i16, ptr %nvq, align 1
  %call8 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %12)
  %conv9 = zext i16 %call8 to i32
  store i32 %conv9, ptr %prev_nr, align 4
  %13 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap10 = getelementptr inbounds %struct.NvmeCtrl, ptr %13, i32 0, i32 42
  %vqrfa = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap10, i32 0, i32 5
  %14 = load i32, ptr %vqrfa, align 4
  %call11 = call i32 @le32_to_cpu(i32 noundef %14)
  store i32 %call11, ptr %prev_total, align 4
  %15 = load i32, ptr %nr.addr, align 4
  %conv12 = trunc i32 %15 to i16
  %call13 = call zeroext i16 @cpu_to_le16(i16 noundef zeroext %conv12)
  %16 = load ptr, ptr %sctrl.addr, align 8
  %nvq14 = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %16, i32 0, i32 5
  store i16 %call13, ptr %nvq14, align 1
  %17 = load i32, ptr %prev_total, align 4
  %18 = load i32, ptr %nr.addr, align 4
  %add15 = add i32 %17, %18
  %19 = load i32, ptr %prev_nr, align 4
  %sub16 = sub i32 %add15, %19
  %call17 = call i32 @cpu_to_le32(i32 noundef %sub16)
  %20 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap18 = getelementptr inbounds %struct.NvmeCtrl, ptr %20, i32 0, i32 42
  %vqrfa19 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %pri_ctrl_cap18, i32 0, i32 5
  store i32 %call17, ptr %vqrfa19, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

declare ptr @pcie_sriov_get_vf_at_index(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_dbbuf_config(i64 noundef %dbs_addr, i64 noundef %eis_addr) #0 {
entry:
  %dbs_addr.addr = alloca i64, align 8
  %eis_addr.addr = alloca i64, align 8
  store i64 %dbs_addr, ptr %dbs_addr.addr, align 8
  store i64 %eis_addr, ptr %eis_addr.addr, align 8
  %0 = load i64, ptr %dbs_addr.addr, align 8
  %1 = load i64, ptr %eis_addr.addr, align 8
  call void @_nocheck__trace_pci_nvme_dbbuf_config(i64 noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_dbbuf_config(i64 noundef %dbs_addr, i64 noundef %eis_addr) #0 {
entry:
  %dbs_addr.addr = alloca i64, align 8
  %eis_addr.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %dbs_addr, ptr %dbs_addr.addr, align 8
  store i64 %eis_addr, ptr %eis_addr.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_DBBUF_CONFIG_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %dbs_addr.addr, align 8
  %6 = load i64, ptr %eis_addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.416, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %dbs_addr.addr, align 8
  %8 = load i64, ptr %eis_addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.417, i64 noundef %7, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_do_format(ptr noundef %iocb) #0 {
entry:
  %iocb.addr = alloca ptr, align 8
  %req = alloca ptr, align 8
  %n = alloca ptr, align 8
  %dw10 = alloca i32, align 4
  %lbaf = alloca i8, align 1
  %pi = alloca i8, align 1
  %status = alloca i16, align 2
  %i = alloca i32, align 4
  store ptr %iocb, ptr %iocb.addr, align 8
  %0 = load ptr, ptr %iocb.addr, align 8
  %req1 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %req1, align 8
  store ptr %1, ptr %req, align 8
  %2 = load ptr, ptr %req, align 8
  %call = call ptr @nvme_ctrl(ptr noundef %2)
  store ptr %call, ptr %n, align 8
  %3 = load ptr, ptr %req, align 8
  %cmd = getelementptr inbounds %struct.NvmeRequest, ptr %3, i32 0, i32 6
  %cdw10 = getelementptr inbounds %struct.NvmeCmd, ptr %cmd, i32 0, i32 7
  %4 = load i32, ptr %cdw10, align 8
  %call2 = call i32 @le32_to_cpu(i32 noundef %4)
  store i32 %call2, ptr %dw10, align 4
  %5 = load i32, ptr %dw10, align 4
  %and = and i32 %5, 15
  %conv = trunc i32 %and to i8
  store i8 %conv, ptr %lbaf, align 1
  %6 = load i32, ptr %dw10, align 4
  %shr = lshr i32 %6, 5
  %and3 = and i32 %shr, 7
  %conv4 = trunc i32 %and3 to i8
  store i8 %conv4, ptr %pi, align 1
  %7 = load ptr, ptr %iocb.addr, align 8
  %ret = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %7, i32 0, i32 3
  %8 = load i32, ptr %ret, align 8
  %cmp = icmp slt i32 %8, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %done

if.end:                                           ; preds = %entry
  %9 = load ptr, ptr %iocb.addr, align 8
  %broadcast = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %9, i32 0, i32 6
  %10 = load i8, ptr %broadcast, align 4
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.then6, label %if.end15

if.then6:                                         ; preds = %if.end
  %11 = load ptr, ptr %iocb.addr, align 8
  %nsid = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %11, i32 0, i32 5
  %12 = load i32, ptr %nsid, align 8
  %add = add i32 %12, 1
  store i32 %add, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then6
  %13 = load i32, ptr %i, align 4
  %cmp7 = icmp sle i32 %13, 256
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load ptr, ptr %n, align 8
  %15 = load i32, ptr %i, align 4
  %call9 = call ptr @nvme_ns(ptr noundef %14, i32 noundef %15)
  %16 = load ptr, ptr %iocb.addr, align 8
  %ns = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %16, i32 0, i32 4
  store ptr %call9, ptr %ns, align 8
  %17 = load ptr, ptr %iocb.addr, align 8
  %ns10 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %17, i32 0, i32 4
  %18 = load ptr, ptr %ns10, align 8
  %tobool11 = icmp ne ptr %18, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %for.body
  %19 = load i32, ptr %i, align 4
  %20 = load ptr, ptr %iocb.addr, align 8
  %nsid13 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %20, i32 0, i32 5
  store i32 %19, ptr %nsid13, align 8
  br label %for.end

if.end14:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %21 = load i32, ptr %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !66

for.end:                                          ; preds = %if.then12, %for.cond
  br label %if.end15

if.end15:                                         ; preds = %for.end, %if.end
  %22 = load ptr, ptr %iocb.addr, align 8
  %ns16 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %22, i32 0, i32 4
  %23 = load ptr, ptr %ns16, align 8
  %tobool17 = icmp ne ptr %23, null
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end15
  br label %done

if.end19:                                         ; preds = %if.end15
  %24 = load ptr, ptr %iocb.addr, align 8
  %ns20 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %24, i32 0, i32 4
  %25 = load ptr, ptr %ns20, align 8
  %26 = load i8, ptr %lbaf, align 1
  %27 = load i8, ptr %pi, align 1
  %call21 = call zeroext i16 @nvme_format_check(ptr noundef %25, i8 noundef zeroext %26, i8 noundef zeroext %27)
  store i16 %call21, ptr %status, align 2
  %28 = load i16, ptr %status, align 2
  %tobool22 = icmp ne i16 %28, 0
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end19
  %29 = load i16, ptr %status, align 2
  %30 = load ptr, ptr %req, align 8
  %status24 = getelementptr inbounds %struct.NvmeRequest, ptr %30, i32 0, i32 3
  store i16 %29, ptr %status24, align 8
  br label %done

if.end25:                                         ; preds = %if.end19
  %31 = load ptr, ptr %iocb.addr, align 8
  %ns26 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %31, i32 0, i32 4
  %32 = load ptr, ptr %ns26, align 8
  %status27 = getelementptr inbounds %struct.NvmeNamespace, ptr %32, i32 0, i32 12
  store i16 132, ptr %status27, align 2
  %33 = load ptr, ptr %iocb.addr, align 8
  call void @nvme_format_ns_cb(ptr noundef %33, i32 noundef 0)
  br label %return

done:                                             ; preds = %if.then23, %if.then18, %if.then
  %34 = load ptr, ptr %iocb.addr, align 8
  %common = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %34, i32 0, i32 0
  %cb = getelementptr inbounds %struct.BlockAIOCB, ptr %common, i32 0, i32 2
  %35 = load ptr, ptr %cb, align 8
  %36 = load ptr, ptr %iocb.addr, align 8
  %common28 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %36, i32 0, i32 0
  %opaque = getelementptr inbounds %struct.BlockAIOCB, ptr %common28, i32 0, i32 3
  %37 = load ptr, ptr %opaque, align 8
  %38 = load ptr, ptr %iocb.addr, align 8
  %ret29 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %38, i32 0, i32 3
  %39 = load i32, ptr %ret29, align 8
  call void %35(ptr noundef %37, i32 noundef %39)
  %40 = load ptr, ptr %iocb.addr, align 8
  call void @qemu_aio_unref(ptr noundef %40)
  br label %return

return:                                           ; preds = %done, %if.end25
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_format_cancel(ptr noundef %aiocb) #0 {
entry:
  %aiocb.addr = alloca ptr, align 8
  %iocb = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  store ptr %aiocb, ptr %aiocb.addr, align 8
  %0 = load ptr, ptr %aiocb.addr, align 8
  store ptr %0, ptr %__mptr, align 8
  %1 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 0
  store ptr %add.ptr, ptr %tmp, align 8
  %2 = load ptr, ptr %tmp, align 8
  store ptr %2, ptr %iocb, align 8
  %3 = load ptr, ptr %iocb, align 8
  %ret = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %3, i32 0, i32 3
  store i32 -125, ptr %ret, align 8
  %4 = load ptr, ptr %iocb, align 8
  %aiocb1 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %aiocb1, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %iocb, align 8
  %aiocb2 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %aiocb2, align 8
  call void @blk_aio_cancel_async(ptr noundef %7)
  %8 = load ptr, ptr %iocb, align 8
  %aiocb3 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %8, i32 0, i32 1
  store ptr null, ptr %aiocb3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @nvme_format_check(ptr noundef %ns, i8 noundef zeroext %lbaf, i8 noundef zeroext %pi) #0 {
entry:
  %retval = alloca i16, align 2
  %ns.addr = alloca ptr, align 8
  %lbaf.addr = alloca i8, align 1
  %pi.addr = alloca i8, align 1
  store ptr %ns, ptr %ns.addr, align 8
  store i8 %lbaf, ptr %lbaf.addr, align 1
  store i8 %pi, ptr %pi.addr, align 1
  %0 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %0, i32 0, i32 30
  %zoned = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 14
  %1 = load i8, ptr %zoned, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 16650, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i8, ptr %lbaf.addr, align 1
  %conv = zext i8 %2 to i32
  %3 = load ptr, ptr %ns.addr, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %3, i32 0, i32 5
  %nlbaf = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 4
  %4 = load i8, ptr %nlbaf, align 1
  %conv1 = zext i8 %4 to i32
  %cmp = icmp sgt i32 %conv, %conv1
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i16 16650, ptr %retval, align 2
  br label %return

if.end4:                                          ; preds = %if.end
  %5 = load i8, ptr %pi.addr, align 1
  %conv5 = zext i8 %5 to i32
  %tobool6 = icmp ne i32 %conv5, 0
  br i1 %tobool6, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %if.end4
  %6 = load ptr, ptr %ns.addr, align 8
  %id_ns7 = getelementptr inbounds %struct.NvmeNamespace, ptr %6, i32 0, i32 5
  %lbaf8 = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns7, i32 0, i32 35
  %7 = load i8, ptr %lbaf.addr, align 1
  %idxprom = zext i8 %7 to i64
  %arrayidx = getelementptr [64 x %struct.NvmeLBAF], ptr %lbaf8, i64 0, i64 %idxprom
  %ms = getelementptr inbounds %struct.NvmeLBAF, ptr %arrayidx, i32 0, i32 0
  %8 = load i16, ptr %ms, align 4
  %conv9 = zext i16 %8 to i64
  %9 = load ptr, ptr %ns.addr, align 8
  %call = call i64 @nvme_pi_tuple_size(ptr noundef %9)
  %cmp10 = icmp ult i64 %conv9, %call
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %land.lhs.true
  store i16 16650, ptr %retval, align 2
  br label %return

if.end13:                                         ; preds = %land.lhs.true, %if.end4
  %10 = load i8, ptr %pi.addr, align 1
  %conv14 = zext i8 %10 to i32
  %tobool15 = icmp ne i32 %conv14, 0
  br i1 %tobool15, label %land.lhs.true16, label %if.end21

land.lhs.true16:                                  ; preds = %if.end13
  %11 = load i8, ptr %pi.addr, align 1
  %conv17 = zext i8 %11 to i32
  %cmp18 = icmp sgt i32 %conv17, 3
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true16
  store i16 16386, ptr %retval, align 2
  br label %return

if.end21:                                         ; preds = %land.lhs.true16, %if.end13
  store i16 0, ptr %retval, align 2
  br label %return

return:                                           ; preds = %if.end21, %if.then20, %if.then12, %if.then3, %if.then
  %12 = load i16, ptr %retval, align 2
  ret i16 %12
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_format_ns_cb(ptr noundef %opaque, i32 noundef %ret) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  %iocb = alloca ptr, align 8
  %ns = alloca ptr, align 8
  %bytes = alloca i32, align 4
  %_a53 = alloca i64, align 8
  %_b54 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %iocb, align 8
  %1 = load ptr, ptr %iocb, align 8
  %ns1 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %ns1, align 8
  store ptr %2, ptr %ns, align 8
  %3 = load ptr, ptr %iocb, align 8
  %ret2 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %3, i32 0, i32 3
  %4 = load i32, ptr %ret2, align 8
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %done

if.else:                                          ; preds = %entry
  %5 = load i32, ptr %ret.addr, align 4
  %cmp3 = icmp slt i32 %5, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %6 = load i32, ptr %ret.addr, align 4
  %7 = load ptr, ptr %iocb, align 8
  %ret5 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %7, i32 0, i32 3
  store i32 %6, ptr %ret5, align 8
  br label %done

if.end:                                           ; preds = %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  %8 = load ptr, ptr %ns, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.then7, label %if.else8

if.then7:                                         ; preds = %if.end6
  br label %if.end9

if.else8:                                         ; preds = %if.end6
  call void @__assert_fail(ptr noundef @.str.387, ptr noundef @.str.1, i32 noundef 6506, ptr noundef @__PRETTY_FUNCTION__.nvme_format_ns_cb) #12
  unreachable

if.end9:                                          ; preds = %if.then7
  %9 = load ptr, ptr %iocb, align 8
  %offset = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %9, i32 0, i32 7
  %10 = load i64, ptr %offset, align 8
  %11 = load ptr, ptr %ns, align 8
  %size = getelementptr inbounds %struct.NvmeNamespace, ptr %11, i32 0, i32 3
  %12 = load i64, ptr %size, align 8
  %cmp10 = icmp slt i64 %10, %12
  br i1 %cmp10, label %if.then11, label %if.end19

if.then11:                                        ; preds = %if.end9
  store i64 2147483136, ptr %_a53, align 8
  %13 = load ptr, ptr %ns, align 8
  %size12 = getelementptr inbounds %struct.NvmeNamespace, ptr %13, i32 0, i32 3
  %14 = load i64, ptr %size12, align 8
  %15 = load ptr, ptr %iocb, align 8
  %offset13 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %15, i32 0, i32 7
  %16 = load i64, ptr %offset13, align 8
  %sub = sub i64 %14, %16
  store i64 %sub, ptr %_b54, align 8
  %17 = load i64, ptr %_a53, align 8
  %18 = load i64, ptr %_b54, align 8
  %cmp14 = icmp ult i64 %17, %18
  br i1 %cmp14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then11
  %19 = load i64, ptr %_a53, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then11
  %20 = load i64, ptr %_b54, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %19, %cond.true ], [ %20, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %21 = load i64, ptr %tmp, align 8
  %conv = trunc i64 %21 to i32
  store i32 %conv, ptr %bytes, align 4
  %22 = load ptr, ptr %ns, align 8
  %blkconf = getelementptr inbounds %struct.NvmeNamespace, ptr %22, i32 0, i32 1
  %blk = getelementptr inbounds %struct.BlockConf, ptr %blkconf, i32 0, i32 0
  %23 = load ptr, ptr %blk, align 8
  %24 = load ptr, ptr %iocb, align 8
  %offset15 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %24, i32 0, i32 7
  %25 = load i64, ptr %offset15, align 8
  %26 = load i32, ptr %bytes, align 4
  %conv16 = sext i32 %26 to i64
  %27 = load ptr, ptr %iocb, align 8
  %call = call ptr @blk_aio_pwrite_zeroes(ptr noundef %23, i64 noundef %25, i64 noundef %conv16, i32 noundef 4, ptr noundef @nvme_format_ns_cb, ptr noundef %27)
  %28 = load ptr, ptr %iocb, align 8
  %aiocb = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %28, i32 0, i32 1
  store ptr %call, ptr %aiocb, align 8
  %29 = load i32, ptr %bytes, align 4
  %conv17 = sext i32 %29 to i64
  %30 = load ptr, ptr %iocb, align 8
  %offset18 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %30, i32 0, i32 7
  %31 = load i64, ptr %offset18, align 8
  %add = add i64 %31, %conv17
  store i64 %add, ptr %offset18, align 8
  br label %return

if.end19:                                         ; preds = %if.end9
  %32 = load ptr, ptr %ns, align 8
  %33 = load ptr, ptr %iocb, align 8
  %lbaf = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %33, i32 0, i32 8
  %34 = load i8, ptr %lbaf, align 8
  %35 = load ptr, ptr %iocb, align 8
  %mset = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %35, i32 0, i32 9
  %36 = load i8, ptr %mset, align 1
  %37 = load ptr, ptr %iocb, align 8
  %pi = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %37, i32 0, i32 10
  %38 = load i8, ptr %pi, align 2
  %39 = load ptr, ptr %iocb, align 8
  %pil = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %39, i32 0, i32 11
  %40 = load i8, ptr %pil, align 1
  call void @nvme_format_set(ptr noundef %32, i8 noundef zeroext %34, i8 noundef zeroext %36, i8 noundef zeroext %38, i8 noundef zeroext %40)
  %41 = load ptr, ptr %ns, align 8
  %status = getelementptr inbounds %struct.NvmeNamespace, ptr %41, i32 0, i32 12
  store i16 0, ptr %status, align 2
  %42 = load ptr, ptr %iocb, align 8
  %ns20 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %42, i32 0, i32 4
  store ptr null, ptr %ns20, align 8
  %43 = load ptr, ptr %iocb, align 8
  %offset21 = getelementptr inbounds %struct.NvmeFormatAIOCB, ptr %43, i32 0, i32 7
  store i64 0, ptr %offset21, align 8
  br label %done

done:                                             ; preds = %if.end19, %if.then4, %if.then
  %44 = load ptr, ptr %iocb, align 8
  call void @nvme_do_format(ptr noundef %44)
  br label %return

return:                                           ; preds = %done, %cond.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_format_set(ptr noundef %ns, i8 noundef zeroext %lbaf, i8 noundef zeroext %mset, i8 noundef zeroext %pi, i8 noundef zeroext %pil) #0 {
entry:
  %ns.addr = alloca ptr, align 8
  %lbaf.addr = alloca i8, align 1
  %mset.addr = alloca i8, align 1
  %pi.addr = alloca i8, align 1
  %pil.addr = alloca i8, align 1
  %lbafl = alloca i8, align 1
  %lbafu = alloca i8, align 1
  store ptr %ns, ptr %ns.addr, align 8
  store i8 %lbaf, ptr %lbaf.addr, align 1
  store i8 %mset, ptr %mset.addr, align 1
  store i8 %pi, ptr %pi.addr, align 1
  store i8 %pil, ptr %pil.addr, align 1
  %0 = load i8, ptr %lbaf.addr, align 1
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, ptr %lbafl, align 1
  %1 = load i8, ptr %lbaf.addr, align 1
  %conv2 = zext i8 %1 to i32
  %shr = ashr i32 %conv2, 4
  %conv3 = trunc i32 %shr to i8
  store i8 %conv3, ptr %lbafu, align 1
  %2 = load ptr, ptr %ns.addr, align 8
  %params = getelementptr inbounds %struct.NvmeNamespace, ptr %2, i32 0, i32 30
  %nsid = getelementptr inbounds %struct.NvmeNamespaceParams, ptr %params, i32 0, i32 2
  %3 = load i32, ptr %nsid, align 4
  %4 = load i8, ptr %lbaf.addr, align 1
  %5 = load i8, ptr %mset.addr, align 1
  %6 = load i8, ptr %pi.addr, align 1
  %7 = load i8, ptr %pil.addr, align 1
  call void @trace_pci_nvme_format_set(i32 noundef %3, i8 noundef zeroext %4, i8 noundef zeroext %5, i8 noundef zeroext %6, i8 noundef zeroext %7)
  %8 = load i8, ptr %pil.addr, align 1
  %conv4 = zext i8 %8 to i32
  %shl = shl i32 %conv4, 3
  %9 = load i8, ptr %pi.addr, align 1
  %conv5 = zext i8 %9 to i32
  %or = or i32 %shl, %conv5
  %conv6 = trunc i32 %or to i8
  %10 = load ptr, ptr %ns.addr, align 8
  %id_ns = getelementptr inbounds %struct.NvmeNamespace, ptr %10, i32 0, i32 5
  %dps = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns, i32 0, i32 8
  store i8 %conv6, ptr %dps, align 1
  %11 = load i8, ptr %lbafu, align 1
  %conv7 = zext i8 %11 to i32
  %shl8 = shl i32 %conv7, 5
  %12 = load i8, ptr %mset.addr, align 1
  %conv9 = zext i8 %12 to i32
  %shl10 = shl i32 %conv9, 4
  %or11 = or i32 %shl8, %shl10
  %13 = load i8, ptr %lbafl, align 1
  %conv12 = zext i8 %13 to i32
  %or13 = or i32 %or11, %conv12
  %conv14 = trunc i32 %or13 to i8
  %14 = load ptr, ptr %ns.addr, align 8
  %id_ns15 = getelementptr inbounds %struct.NvmeNamespace, ptr %14, i32 0, i32 5
  %flbas = getelementptr inbounds %struct.NvmeIdNs, ptr %id_ns15, i32 0, i32 5
  store i8 %conv14, ptr %flbas, align 2
  %15 = load ptr, ptr %ns.addr, align 8
  call void @nvme_ns_init_format(ptr noundef %15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_format_set(i32 noundef %nsid, i8 noundef zeroext %lbaf, i8 noundef zeroext %mset, i8 noundef zeroext %pi, i8 noundef zeroext %pil) #0 {
entry:
  %nsid.addr = alloca i32, align 4
  %lbaf.addr = alloca i8, align 1
  %mset.addr = alloca i8, align 1
  %pi.addr = alloca i8, align 1
  %pil.addr = alloca i8, align 1
  store i32 %nsid, ptr %nsid.addr, align 4
  store i8 %lbaf, ptr %lbaf.addr, align 1
  store i8 %mset, ptr %mset.addr, align 1
  store i8 %pi, ptr %pi.addr, align 1
  store i8 %pil, ptr %pil.addr, align 1
  %0 = load i32, ptr %nsid.addr, align 4
  %1 = load i8, ptr %lbaf.addr, align 1
  %2 = load i8, ptr %mset.addr, align 1
  %3 = load i8, ptr %pi.addr, align 1
  %4 = load i8, ptr %pil.addr, align 1
  call void @_nocheck__trace_pci_nvme_format_set(i32 noundef %0, i8 noundef zeroext %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i8 noundef zeroext %4)
  ret void
}

declare void @nvme_ns_init_format(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_format_set(i32 noundef %nsid, i8 noundef zeroext %lbaf, i8 noundef zeroext %mset, i8 noundef zeroext %pi, i8 noundef zeroext %pil) #0 {
entry:
  %nsid.addr = alloca i32, align 4
  %lbaf.addr = alloca i8, align 1
  %mset.addr = alloca i8, align 1
  %pi.addr = alloca i8, align 1
  %pil.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store i32 %nsid, ptr %nsid.addr, align 4
  store i8 %lbaf, ptr %lbaf.addr, align 1
  store i8 %mset, ptr %mset.addr, align 1
  store i8 %pi, ptr %pi.addr, align 1
  store i8 %pil, ptr %pil.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_FORMAT_SET_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end19

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %nsid.addr, align 4
  %6 = load i8, ptr %lbaf.addr, align 1
  %conv11 = zext i8 %6 to i32
  %7 = load i8, ptr %mset.addr, align 1
  %conv12 = zext i8 %7 to i32
  %8 = load i8, ptr %pi.addr, align 1
  %conv13 = zext i8 %8 to i32
  %9 = load i8, ptr %pil.addr, align 1
  %conv14 = zext i8 %9 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.418, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5, i32 noundef %conv11, i32 noundef %conv12, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.else:                                          ; preds = %if.then
  %10 = load i32, ptr %nsid.addr, align 4
  %11 = load i8, ptr %lbaf.addr, align 1
  %conv15 = zext i8 %11 to i32
  %12 = load i8, ptr %mset.addr, align 1
  %conv16 = zext i8 %12 to i32
  %13 = load i8, ptr %pi.addr, align 1
  %conv17 = zext i8 %13 to i32
  %14 = load i8, ptr %pil.addr, align 1
  %conv18 = zext i8 %14 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.419, i32 noundef %10, i32 noundef %conv15, i32 noundef %conv16, i32 noundef %conv17, i32 noundef %conv18)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end19

if.end19:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_update_sq_eventidx(i16 noundef zeroext %sqid, i16 noundef zeroext %new_eventidx) #0 {
entry:
  %sqid.addr = alloca i16, align 2
  %new_eventidx.addr = alloca i16, align 2
  store i16 %sqid, ptr %sqid.addr, align 2
  store i16 %new_eventidx, ptr %new_eventidx.addr, align 2
  %0 = load i16, ptr %sqid.addr, align 2
  %1 = load i16, ptr %new_eventidx.addr, align 2
  call void @_nocheck__trace_pci_nvme_update_sq_eventidx(i16 noundef zeroext %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_update_sq_eventidx(i16 noundef zeroext %sqid, i16 noundef zeroext %new_eventidx) #0 {
entry:
  %sqid.addr = alloca i16, align 2
  %new_eventidx.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %sqid, ptr %sqid.addr, align 2
  store i16 %new_eventidx, ptr %new_eventidx.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UPDATE_SQ_EVENTIDX_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %sqid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i16, ptr %new_eventidx.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.420, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %sqid.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i16, ptr %new_eventidx.addr, align 2
  %conv14 = zext i16 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.421, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_sq_notifier(ptr noundef %e) #0 {
entry:
  %e.addr = alloca ptr, align 8
  %sq = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  store ptr %e, ptr %e.addr, align 8
  %0 = load ptr, ptr %e.addr, align 8
  store ptr %0, ptr %__mptr, align 8
  %1 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 -56
  store ptr %add.ptr, ptr %tmp, align 8
  %2 = load ptr, ptr %tmp, align 8
  store ptr %2, ptr %sq, align 8
  %3 = load ptr, ptr %e.addr, align 8
  %call = call i32 @event_notifier_test_and_clear(ptr noundef %3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %sq, align 8
  call void @nvme_process_sq(ptr noundef %4)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_setfeat_timestamp(i64 noundef %ts) #0 {
entry:
  %ts.addr = alloca i64, align 8
  store i64 %ts, ptr %ts.addr, align 8
  %0 = load i64, ptr %ts.addr, align 8
  call void @_nocheck__trace_pci_nvme_setfeat_timestamp(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_setfeat_timestamp(i64 noundef %ts) #0 {
entry:
  %ts.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %ts, ptr %ts.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_SETFEAT_TIMESTAMP_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %ts.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.422, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %ts.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.423, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_err_startfail() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_ERR_STARTFAIL_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.424, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.425)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_start_success() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_START_SUCCESS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.426, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.427)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_stopped() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_STOPPED_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.428, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.429)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

declare void @nvme_ns_drain(ptr noundef) #1

declare void @pcie_sriov_pf_disable_vfs(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_activate_virt_res(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %pci_dev = alloca ptr, align 8
  %cap = alloca ptr, align 8
  %sctrl = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %call = call ptr @PCI_DEVICE(ptr noundef %0)
  store ptr %call, ptr %pci_dev, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %pri_ctrl_cap = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 42
  store ptr %pri_ctrl_cap, ptr %cap, align 8
  %2 = load ptr, ptr %pci_dev, align 8
  %call1 = call i32 @pci_is_vf(ptr noundef %2)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %call2 = call ptr @nvme_sctrl(ptr noundef %3)
  store ptr %call2, ptr %sctrl, align 8
  %4 = load ptr, ptr %sctrl, align 8
  %nvq = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %4, i32 0, i32 5
  %5 = load i16, ptr %nvq, align 1
  %6 = load ptr, ptr %cap, align 8
  %vqprt = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %6, i32 0, i32 7
  store i16 %5, ptr %vqprt, align 1
  %7 = load ptr, ptr %sctrl, align 8
  %nvi = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %7, i32 0, i32 6
  %8 = load i16, ptr %nvi, align 1
  %9 = load ptr, ptr %cap, align 8
  %viprt = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %9, i32 0, i32 14
  store i16 %8, ptr %viprt, align 1
  %10 = load ptr, ptr %sctrl, align 8
  %nvq3 = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %10, i32 0, i32 5
  %11 = load i16, ptr %nvq3, align 1
  %conv = zext i16 %11 to i32
  %tobool4 = icmp ne i32 %conv, 0
  br i1 %tobool4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %12 = load ptr, ptr %sctrl, align 8
  %nvq5 = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %12, i32 0, i32 5
  %13 = load i16, ptr %nvq5, align 1
  %call6 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %13)
  %conv7 = zext i16 %call6 to i32
  %sub = sub i32 %conv7, 1
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ 0, %cond.false ]
  %14 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 21
  store i32 %cond, ptr %conf_ioqpairs, align 8
  %15 = load ptr, ptr %sctrl, align 8
  %nvi8 = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %15, i32 0, i32 6
  %16 = load i16, ptr %nvi8, align 1
  %conv9 = zext i16 %16 to i32
  %tobool10 = icmp ne i32 %conv9, 0
  br i1 %tobool10, label %cond.true11, label %cond.false15

cond.true11:                                      ; preds = %cond.end
  %17 = load ptr, ptr %sctrl, align 8
  %nvi12 = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %17, i32 0, i32 6
  %18 = load i16, ptr %nvi12, align 1
  %call13 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %18)
  %conv14 = zext i16 %call13 to i32
  br label %cond.end16

cond.false15:                                     ; preds = %cond.end
  br label %cond.end16

cond.end16:                                       ; preds = %cond.false15, %cond.true11
  %cond17 = phi i32 [ %conv14, %cond.true11 ], [ 1, %cond.false15 ]
  %19 = load ptr, ptr %n.addr, align 8
  %conf_msix_qsize = getelementptr inbounds %struct.NvmeCtrl, ptr %19, i32 0, i32 20
  store i32 %cond17, ptr %conf_msix_qsize, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %20 = load ptr, ptr %n.addr, align 8
  %next_pri_ctrl_cap = getelementptr inbounds %struct.NvmeCtrl, ptr %20, i32 0, i32 44
  %vqrfap = getelementptr inbounds %struct.anon.30, ptr %next_pri_ctrl_cap, i32 0, i32 0
  %21 = load i16, ptr %vqrfap, align 8
  %22 = load ptr, ptr %cap, align 8
  %vqrfap18 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %22, i32 0, i32 6
  store i16 %21, ptr %vqrfap18, align 1
  %23 = load ptr, ptr %n.addr, align 8
  %next_pri_ctrl_cap19 = getelementptr inbounds %struct.NvmeCtrl, ptr %23, i32 0, i32 44
  %virfap = getelementptr inbounds %struct.anon.30, ptr %next_pri_ctrl_cap19, i32 0, i32 1
  %24 = load i16, ptr %virfap, align 2
  %25 = load ptr, ptr %cap, align 8
  %virfap20 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %25, i32 0, i32 13
  store i16 %24, ptr %virfap20, align 1
  %26 = load ptr, ptr %cap, align 8
  %vqprt21 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %26, i32 0, i32 7
  %27 = load i16, ptr %vqprt21, align 1
  %call22 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %27)
  %conv23 = zext i16 %call22 to i32
  %28 = load ptr, ptr %cap, align 8
  %vqrfap24 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %28, i32 0, i32 6
  %29 = load i16, ptr %vqrfap24, align 1
  %call25 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %29)
  %conv26 = zext i16 %call25 to i32
  %add = add i32 %conv23, %conv26
  %sub27 = sub i32 %add, 1
  %30 = load ptr, ptr %n.addr, align 8
  %conf_ioqpairs28 = getelementptr inbounds %struct.NvmeCtrl, ptr %30, i32 0, i32 21
  store i32 %sub27, ptr %conf_ioqpairs28, align 8
  %31 = load ptr, ptr %cap, align 8
  %viprt29 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %31, i32 0, i32 14
  %32 = load i16, ptr %viprt29, align 1
  %call30 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %32)
  %conv31 = zext i16 %call30 to i32
  %33 = load ptr, ptr %cap, align 8
  %virfap32 = getelementptr inbounds %struct.NvmePriCtrlCap, ptr %33, i32 0, i32 13
  %34 = load i16, ptr %virfap32, align 1
  %call33 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %34)
  %conv34 = zext i16 %call33 to i32
  %add35 = add i32 %conv31, %conv34
  %35 = load ptr, ptr %n.addr, align 8
  %conf_msix_qsize36 = getelementptr inbounds %struct.NvmeCtrl, ptr %35, i32 0, i32 20
  store i32 %add35, ptr %conf_msix_qsize36, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end16
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_ssreset_w1c_unsupported() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.430, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.431)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_ro_csts() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.432, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.433)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_ssreset_unsupported() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.434, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.435)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_aqattr(i64 noundef %data) #0 {
entry:
  %data.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %data, ptr %data.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_AQATTR_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %data.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.436, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %data.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.437, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stb_p(ptr noundef %ptr, i8 noundef zeroext %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i8, align 1
  store ptr %ptr, ptr %ptr.addr, align 8
  store i8 %v, ptr %v.addr, align 1
  %0 = load i8, ptr %v.addr, align 1
  %1 = load ptr, ptr %ptr.addr, align 8
  store i8 %0, ptr %1, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stq_le_p(ptr noundef %ptr, i64 noundef %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i64, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i64, ptr %v.addr, align 8
  call void @stq_he_p(ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @stq_he_p(ptr noundef %ptr, i64 noundef %v) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %v.addr = alloca i64, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %0, ptr align 8 %v.addr, i64 8, i1 false)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_asqaddr(i64 noundef %data) #0 {
entry:
  %data.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %data, ptr %data.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_ASQADDR_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %data.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.438, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %data.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.439, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_asqaddr_hi(i64 noundef %data, i64 noundef %new_addr) #0 {
entry:
  %data.addr = alloca i64, align 8
  %new_addr.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %data, ptr %data.addr, align 8
  store i64 %new_addr, ptr %new_addr.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_ASQADDR_HI_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %data.addr, align 8
  %6 = load i64, ptr %new_addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.440, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %data.addr, align 8
  %8 = load i64, ptr %new_addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.441, i64 noundef %7, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_acqaddr(i64 noundef %data) #0 {
entry:
  %data.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %data, ptr %data.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_ACQADDR_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %data.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.442, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %data.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.443, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_acqaddr_hi(i64 noundef %data, i64 noundef %new_addr) #0 {
entry:
  %data.addr = alloca i64, align 8
  %new_addr.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %data, ptr %data.addr, align 8
  store i64 %new_addr, ptr %new_addr.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_ACQADDR_HI_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %data.addr, align 8
  %6 = load i64, ptr %new_addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.444, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %data.addr, align 8
  %8 = load i64, ptr %new_addr.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.445, i64 noundef %7, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_cmbloc_reserved() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.446, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.447)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_cmbsz_readonly() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.448, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.449)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_pmrcap_readonly() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.450, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.451)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_pmrsts_readonly() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.452, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.453)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_pmrebs_readonly() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.454, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.455)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_pmrswtp_readonly() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.456, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.457)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_mmiowr_invalid(i64 noundef %offset, i64 noundef %data) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %data.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %data, ptr %data.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_MMIOWR_INVALID_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %offset.addr, align 8
  %6 = load i64, ptr %data.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.458, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5, i64 noundef %6)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, ptr %offset.addr, align 8
  %8 = load i64, ptr %data.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.459, i64 noundef %7, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_db_wr_misaligned(i64 noundef %offset) #0 {
entry:
  %offset.addr = alloca i64, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  call void @_nocheck__trace_pci_nvme_ub_db_wr_misaligned(i64 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_db_wr_invalid_cq(i32 noundef %qid) #0 {
entry:
  %qid.addr = alloca i32, align 4
  store i32 %qid, ptr %qid.addr, align 4
  %0 = load i32, ptr %qid.addr, align 4
  call void @_nocheck__trace_pci_nvme_ub_db_wr_invalid_cq(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_db_wr_invalid_cqhead(i32 noundef %qid, i16 noundef zeroext %new_head) #0 {
entry:
  %qid.addr = alloca i32, align 4
  %new_head.addr = alloca i16, align 2
  store i32 %qid, ptr %qid.addr, align 4
  store i16 %new_head, ptr %new_head.addr, align 2
  %0 = load i32, ptr %qid.addr, align 4
  %1 = load i16, ptr %new_head.addr, align 2
  call void @_nocheck__trace_pci_nvme_ub_db_wr_invalid_cqhead(i32 noundef %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_doorbell_cq(i16 noundef zeroext %cqid, i16 noundef zeroext %new_head) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  %new_head.addr = alloca i16, align 2
  store i16 %cqid, ptr %cqid.addr, align 2
  store i16 %new_head, ptr %new_head.addr, align 2
  %0 = load i16, ptr %cqid.addr, align 2
  %1 = load i16, ptr %new_head.addr, align 2
  call void @_nocheck__trace_pci_nvme_mmio_doorbell_cq(i16 noundef zeroext %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_db_wr_invalid_sq(i32 noundef %qid) #0 {
entry:
  %qid.addr = alloca i32, align 4
  store i32 %qid, ptr %qid.addr, align 4
  %0 = load i32, ptr %qid.addr, align 4
  call void @_nocheck__trace_pci_nvme_ub_db_wr_invalid_sq(i32 noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_ub_db_wr_invalid_sqtail(i32 noundef %qid, i16 noundef zeroext %new_tail) #0 {
entry:
  %qid.addr = alloca i32, align 4
  %new_tail.addr = alloca i16, align 2
  store i32 %qid, ptr %qid.addr, align 4
  store i16 %new_tail, ptr %new_tail.addr, align 2
  %0 = load i32, ptr %qid.addr, align 4
  %1 = load i16, ptr %new_tail.addr, align 2
  call void @_nocheck__trace_pci_nvme_ub_db_wr_invalid_sqtail(i32 noundef %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_mmio_doorbell_sq(i16 noundef zeroext %sqid, i16 noundef zeroext %new_tail) #0 {
entry:
  %sqid.addr = alloca i16, align 2
  %new_tail.addr = alloca i16, align 2
  store i16 %sqid, ptr %sqid.addr, align 2
  store i16 %new_tail, ptr %new_tail.addr, align 2
  %0 = load i16, ptr %sqid.addr, align 2
  %1 = load i16, ptr %new_tail.addr, align 2
  call void @_nocheck__trace_pci_nvme_mmio_doorbell_sq(i16 noundef zeroext %0, i16 noundef zeroext %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_db_wr_misaligned(i64 noundef %offset) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %_now = alloca %struct.timeval, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_DB_WR_MISALIGNED_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i64, ptr %offset.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.465, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i64, ptr %offset.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.466, i64 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_db_wr_invalid_cq(i32 noundef %qid) #0 {
entry:
  %qid.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %qid, ptr %qid.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %qid.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.467, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %qid.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.468, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_db_wr_invalid_cqhead(i32 noundef %qid, i16 noundef zeroext %new_head) #0 {
entry:
  %qid.addr = alloca i32, align 4
  %new_head.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i32 %qid, ptr %qid.addr, align 4
  store i16 %new_head, ptr %new_head.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %qid.addr, align 4
  %6 = load i16, ptr %new_head.addr, align 2
  %conv11 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.469, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i32, ptr %qid.addr, align 4
  %8 = load i16, ptr %new_head.addr, align 2
  %conv12 = zext i16 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.470, i32 noundef %7, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_doorbell_cq(i16 noundef zeroext %cqid, i16 noundef zeroext %new_head) #0 {
entry:
  %cqid.addr = alloca i16, align 2
  %new_head.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %cqid, ptr %cqid.addr, align 2
  store i16 %new_head, ptr %new_head.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_DOORBELL_CQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %cqid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i16, ptr %new_head.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.471, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %cqid.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i16, ptr %new_head.addr, align 2
  %conv14 = zext i16 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.472, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_db_wr_invalid_sq(i32 noundef %qid) #0 {
entry:
  %qid.addr = alloca i32, align 4
  %_now = alloca %struct.timeval, align 8
  store i32 %qid, ptr %qid.addr, align 4
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %qid.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.473, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load i32, ptr %qid.addr, align 4
  call void (ptr, ...) @qemu_log(ptr noundef @.str.474, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_ub_db_wr_invalid_sqtail(i32 noundef %qid, i16 noundef zeroext %new_tail) #0 {
entry:
  %qid.addr = alloca i32, align 4
  %new_tail.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i32 %qid, ptr %qid.addr, align 4
  store i16 %new_tail, ptr %new_tail.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end13

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i32, ptr %qid.addr, align 4
  %6 = load i16, ptr %new_tail.addr, align 2
  %conv11 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.475, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %5, i32 noundef %conv11)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i32, ptr %qid.addr, align 4
  %8 = load i16, ptr %new_tail.addr, align 2
  %conv12 = zext i16 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.476, i32 noundef %7, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_mmio_doorbell_sq(i16 noundef zeroext %sqid, i16 noundef zeroext %new_tail) #0 {
entry:
  %sqid.addr = alloca i16, align 2
  %new_tail.addr = alloca i16, align 2
  %_now = alloca %struct.timeval, align 8
  store i16 %sqid, ptr %sqid.addr, align 2
  store i16 %new_tail, ptr %new_tail.addr, align 2
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_MMIO_DOORBELL_SQ_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load i16, ptr %sqid.addr, align 2
  %conv11 = zext i16 %5 to i32
  %6 = load i16, ptr %new_tail.addr, align 2
  %conv12 = zext i16 %6 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.477, i32 noundef %call10, i64 noundef %3, i64 noundef %4, i32 noundef %conv11, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i16, ptr %sqid.addr, align 2
  %conv13 = zext i16 %7 to i32
  %8 = load i16, ptr %new_tail.addr, align 2
  %conv14 = zext i16 %8 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.478, i32 noundef %conv13, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

declare i32 @msix_present(ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @pci_set_word_by_mask(ptr noundef %config, i16 noundef zeroext %mask, i16 noundef zeroext %reg) #0 {
entry:
  %config.addr = alloca ptr, align 8
  %mask.addr = alloca i16, align 2
  %reg.addr = alloca i16, align 2
  %val = alloca i16, align 2
  %rval = alloca i16, align 2
  store ptr %config, ptr %config.addr, align 8
  store i16 %mask, ptr %mask.addr, align 2
  store i16 %reg, ptr %reg.addr, align 2
  %0 = load ptr, ptr %config.addr, align 8
  %call = call zeroext i16 @pci_get_word(ptr noundef %0)
  store i16 %call, ptr %val, align 2
  %1 = load i16, ptr %mask.addr, align 2
  %tobool = icmp ne i16 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.480, ptr noundef @.str.481, i32 noundef 585, ptr noundef @__PRETTY_FUNCTION__.pci_set_word_by_mask) #12
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load i16, ptr %reg.addr, align 2
  %conv = zext i16 %2 to i32
  %3 = load i16, ptr %mask.addr, align 2
  %conv1 = zext i16 %3 to i32
  %call2 = call i32 @ctz32(i32 noundef %conv1)
  %shl = shl i32 %conv, %call2
  %conv3 = trunc i32 %shl to i16
  store i16 %conv3, ptr %rval, align 2
  %4 = load ptr, ptr %config.addr, align 8
  %5 = load i16, ptr %mask.addr, align 2
  %conv4 = zext i16 %5 to i32
  %not = xor i32 %conv4, -1
  %6 = load i16, ptr %val, align 2
  %conv5 = zext i16 %6 to i32
  %and = and i32 %not, %conv5
  %7 = load i16, ptr %mask.addr, align 2
  %conv6 = zext i16 %7 to i32
  %8 = load i16, ptr %rval, align 2
  %conv7 = zext i16 %8 to i32
  %and8 = and i32 %conv6, %conv7
  %or = or i32 %and, %and8
  %conv9 = trunc i32 %or to i16
  call void @pci_set_word(ptr noundef %4, i16 noundef zeroext %conv9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i16 @pci_get_word(ptr noundef %config) #0 {
entry:
  %config.addr = alloca ptr, align 8
  store ptr %config, ptr %config.addr, align 8
  %0 = load ptr, ptr %config.addr, align 8
  %call = call i32 @lduw_le_p(ptr noundef %0)
  %conv = trunc i32 %call to i16
  ret i16 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ctz32(i32 noundef %val) #0 {
entry:
  %val.addr = alloca i32, align 4
  store i32 %val, ptr %val.addr, align 4
  %0 = load i32, ptr %val.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i32, ptr %val.addr, align 4
  %2 = call i32 @llvm.cttz.i32(i32 %1, i1 true)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ 32, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.cttz.i32(i32, i1 immarg) #7

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @nvme_cmb_read(ptr noundef %opaque, i64 noundef %addr, i32 noundef %size) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  %n = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %n, align 8
  %1 = load ptr, ptr %n, align 8
  %cmb = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 25
  %buf = getelementptr inbounds %struct.anon.20, ptr %cmb, i32 0, i32 1
  %2 = load ptr, ptr %buf, align 16
  %3 = load i64, ptr %addr.addr, align 8
  %arrayidx = getelementptr i8, ptr %2, i64 %3
  %4 = load i32, ptr %size.addr, align 4
  %call = call i64 @ldn_le_p(ptr noundef %arrayidx, i32 noundef %4)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_cmb_write(ptr noundef %opaque, i64 noundef %addr, i64 noundef %data, i32 noundef %size) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %addr.addr = alloca i64, align 8
  %data.addr = alloca i64, align 8
  %size.addr = alloca i32, align 4
  %n = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store i64 %addr, ptr %addr.addr, align 8
  store i64 %data, ptr %data.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %n, align 8
  %1 = load ptr, ptr %n, align 8
  %cmb = getelementptr inbounds %struct.NvmeCtrl, ptr %1, i32 0, i32 25
  %buf = getelementptr inbounds %struct.anon.20, ptr %cmb, i32 0, i32 1
  %2 = load ptr, ptr %buf, align 16
  %3 = load i64, ptr %addr.addr, align 8
  %arrayidx = getelementptr i8, ptr %2, i64 %3
  %4 = load i32, ptr %size.addr, align 4
  %5 = load i64, ptr %data.addr, align 8
  call void @stn_le_p(ptr noundef %arrayidx, i32 noundef %4, i64 noundef %5)
  ret void
}

declare void @pcie_sriov_pf_init(ptr noundef, i16 noundef zeroext, ptr noundef, i16 noundef zeroext, i16 noundef zeroext, i16 noundef zeroext, i16 noundef zeroext, i16 noundef zeroext) #1

declare void @pcie_sriov_pf_init_vf_bar(ptr noundef, i32 noundef, i8 noundef zeroext, i64 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_init_subnqn(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %subsys = alloca ptr, align 8
  %id = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %subsys1 = getelementptr inbounds %struct.NvmeCtrl, ptr %0, i32 0, i32 33
  %1 = load ptr, ptr %subsys1, align 8
  store ptr %1, ptr %subsys, align 8
  %2 = load ptr, ptr %n.addr, align 8
  %id_ctrl = getelementptr inbounds %struct.NvmeCtrl, ptr %2, i32 0, i32 40
  store ptr %id_ctrl, ptr %id, align 8
  %3 = load ptr, ptr %subsys, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %id, align 8
  %subnqn = getelementptr inbounds %struct.NvmeIdCtrl, ptr %4, i32 0, i32 64
  %arraydecay = getelementptr inbounds [256 x i8], ptr %subnqn, i64 0, i64 0
  %5 = load ptr, ptr %n.addr, align 8
  %params = getelementptr inbounds %struct.NvmeCtrl, ptr %5, i32 0, i32 4
  %serial = getelementptr inbounds %struct.NvmeParams, ptr %params, i32 0, i32 0
  %6 = load ptr, ptr %serial, align 16
  %call = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay, i64 noundef 256, ptr noundef @.str.485, ptr noundef %6) #13
  br label %if.end

if.else:                                          ; preds = %entry
  %7 = load ptr, ptr %id, align 8
  %subnqn2 = getelementptr inbounds %struct.NvmeIdCtrl, ptr %7, i32 0, i32 64
  %arraydecay3 = getelementptr inbounds [256 x i8], ptr %subnqn2, i64 0, i64 0
  %8 = load ptr, ptr %subsys, align 8
  %subnqn4 = getelementptr inbounds %struct.NvmeSubsystem, ptr %8, i32 0, i32 2
  %arraydecay5 = getelementptr inbounds [256 x i8], ptr %subnqn4, i64 0, i64 0
  call void @pstrcpy(ptr noundef %arraydecay3, i32 noundef 256, ptr noundef %arraydecay5)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind
declare i32 @snprintf(ptr noundef, i64 noundef, ptr noundef, ...) #4

declare void @pstrcpy(ptr noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @nvme_sriov_pre_write_ctrl(ptr noundef %dev, i32 noundef %address, i32 noundef %val, i32 noundef %len) #0 {
entry:
  %dev.addr = alloca ptr, align 8
  %address.addr = alloca i32, align 4
  %val.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  %n = alloca ptr, align 8
  %sctrl = alloca ptr, align 8
  %sriov_cap = alloca i16, align 2
  %off = alloca i32, align 4
  %i = alloca i32, align 4
  %num_vfs = alloca i32, align 4
  store ptr %dev, ptr %dev.addr, align 8
  store i32 %address, ptr %address.addr, align 4
  store i32 %val, ptr %val.addr, align 4
  store i32 %len, ptr %len.addr, align 4
  %0 = load ptr, ptr %dev.addr, align 8
  %call = call ptr @object_dynamic_cast_assert(ptr noundef %0, ptr noundef @.str.49, ptr noundef @.str.1, i32 noundef 8472, ptr noundef @__func__.nvme_sriov_pre_write_ctrl)
  store ptr %call, ptr %n, align 8
  %1 = load ptr, ptr %dev.addr, align 8
  %exp = getelementptr inbounds %struct.PCIDevice, ptr %1, i32 0, i32 36
  %sriov_cap1 = getelementptr inbounds %struct.PCIExpressDevice, ptr %exp, i32 0, i32 7
  %2 = load i16, ptr %sriov_cap1, align 4
  store i16 %2, ptr %sriov_cap, align 2
  %3 = load i32, ptr %address.addr, align 4
  %4 = load i16, ptr %sriov_cap, align 2
  %conv = zext i16 %4 to i32
  %sub = sub i32 %3, %conv
  store i32 %sub, ptr %off, align 4
  %5 = load i16, ptr %sriov_cap, align 2
  %tobool = icmp ne i16 %5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end17

if.end:                                           ; preds = %entry
  %6 = load i32, ptr %off, align 4
  %conv2 = zext i32 %6 to i64
  %7 = load i32, ptr %len.addr, align 4
  %conv3 = sext i32 %7 to i64
  %call4 = call i32 @range_covers_byte(i64 noundef %conv2, i64 noundef %conv3, i64 noundef 8)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end17

if.then6:                                         ; preds = %if.end
  %8 = load i32, ptr %val.addr, align 4
  %and = and i32 %8, 1
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %if.end16, label %if.then8

if.then8:                                         ; preds = %if.then6
  %9 = load ptr, ptr %dev.addr, align 8
  %config = getelementptr inbounds %struct.PCIDevice, ptr %9, i32 0, i32 3
  %10 = load ptr, ptr %config, align 8
  %11 = load i16, ptr %sriov_cap, align 2
  %conv9 = zext i16 %11 to i32
  %idx.ext = sext i32 %conv9 to i64
  %add.ptr = getelementptr i8, ptr %10, i64 %idx.ext
  %add.ptr10 = getelementptr i8, ptr %add.ptr, i64 16
  %call11 = call zeroext i16 @pci_get_word(ptr noundef %add.ptr10)
  %conv12 = zext i16 %call11 to i32
  store i32 %conv12, ptr %num_vfs, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then8
  %12 = load i32, ptr %i, align 4
  %13 = load i32, ptr %num_vfs, align 4
  %cmp = icmp slt i32 %12, %13
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load ptr, ptr %n, align 8
  %sec_ctrl_list = getelementptr inbounds %struct.NvmeCtrl, ptr %14, i32 0, i32 43
  %sec = getelementptr inbounds %struct.NvmeSecCtrlList, ptr %sec_ctrl_list, i32 0, i32 2
  %15 = load i32, ptr %i, align 4
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr [127 x %struct.NvmeSecCtrlEntry], ptr %sec, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %sctrl, align 8
  %16 = load ptr, ptr %n, align 8
  %17 = load ptr, ptr %sctrl, align 8
  %scid = getelementptr inbounds %struct.NvmeSecCtrlEntry, ptr %17, i32 0, i32 0
  %18 = load i16, ptr %scid, align 1
  %call14 = call zeroext i16 @le16_to_cpu(i16 noundef zeroext %18)
  %call15 = call zeroext i16 @nvme_virt_set_state(ptr noundef %16, i16 noundef zeroext %call14, i1 noundef zeroext false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !67

for.end:                                          ; preds = %for.cond
  br label %if.end16

if.end16:                                         ; preds = %for.end, %if.then6
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end, %if.then
  ret void
}

declare void @pci_default_write_config(ptr noundef, i32 noundef, i32 noundef, i32 noundef) #1

declare void @pcie_cap_flr_write_config(ptr noundef, i32 noundef, i32 noundef, i32 noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @range_covers_byte(i64 noundef %offset, i64 noundef %len, i64 noundef %byte) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %byte.addr = alloca i64, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i64 %byte, ptr %byte.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  %1 = load i64, ptr %byte.addr, align 8
  %cmp = icmp ule i64 %0, %1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load i64, ptr %byte.addr, align 8
  %3 = load i64, ptr %offset.addr, align 8
  %4 = load i64, ptr %len.addr, align 8
  %call = call i64 @range_get_last(i64 noundef %3, i64 noundef %4)
  %cmp1 = icmp ule i64 %2, %call
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %5 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  %land.ext = zext i1 %5 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @range_get_last(i64 noundef %offset, i64 noundef %len) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  %add = add i64 %0, %1
  %sub = sub i64 %add, 1
  ret i64 %sub
}

declare void @nvme_subsys_unregister_ctrl(ptr noundef, ptr noundef) #1

declare void @pcie_sriov_pf_exit(ptr noundef) #1

declare void @msix_uninit(ptr noundef, ptr noundef, ptr noundef) #1

declare void @memory_region_del_subregion(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_pci_nvme_pci_reset() #0 {
entry:
  call void @_nocheck__trace_pci_nvme_pci_reset()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_pci_nvme_pci_reset() #0 {
entry:
  %_now = alloca %struct.timeval, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_PCI_NVME_PCI_RESET_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #13
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.520, i32 noundef %call10, i64 noundef %3, i64 noundef %4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (ptr, ...) @qemu_log(ptr noundef @.str.521)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

attributes #0 = { nounwind sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { allocsize(0,1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #6 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #7 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #8 = { noreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { allocsize(0,1) }
attributes #12 = { noreturn nounwind }
attributes #13 = { nounwind }
attributes #14 = { allocsize(0) }
attributes #15 = { noreturn }
attributes #16 = { nounwind willreturn memory(read) }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = !{i64 2152351320}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
