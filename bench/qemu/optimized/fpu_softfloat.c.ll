; ModuleID = 'bench/qemu/original/fpu_softfloat.c.ll'
source_filename = "bench/qemu/original/fpu_softfloat.c.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.floatx80 = type { i64, i16 }
%struct.FloatFmt = type { i32, i32, i32, i32, i32, i32, i8, i8, i64 }
%struct.FloatParts64 = type { i8, i8, i32, %union.anon }
%union.anon = type { i64 }
%struct.FloatParts128 = type { i8, i8, i32, i64, i64 }
%struct.FloatParts256 = type { i8, i8, i32, i64, i64, i64, i64 }

@floatx80_infinity = dso_local local_unnamed_addr constant %struct.floatx80 { i64 -9223372036854775808, i16 32767 }, align 8
@float16_params = internal constant %struct.FloatFmt { i32 5, i32 15, i32 24, i32 31, i32 10, i32 53, i8 0, i8 0, i64 9007199254740991 }, align 8
@float16_params_ahp = internal constant %struct.FloatFmt { i32 5, i32 15, i32 24, i32 31, i32 10, i32 53, i8 1, i8 0, i64 9007199254740991 }, align 8
@float32_params = internal constant %struct.FloatFmt { i32 8, i32 127, i32 192, i32 255, i32 23, i32 40, i8 0, i8 0, i64 1099511627775 }, align 8
@float64_params = internal constant %struct.FloatFmt { i32 11, i32 1023, i32 1536, i32 2047, i32 52, i32 11, i8 0, i8 0, i64 2047 }, align 8
@bfloat16_params = internal constant %struct.FloatFmt { i32 8, i32 127, i32 192, i32 255, i32 7, i32 56, i8 0, i8 0, i64 72057594037927935 }, align 8
@float128_params = internal constant %struct.FloatFmt { i32 15, i32 16383, i32 24576, i32 32767, i32 112, i32 15, i8 0, i8 0, i64 32767 }, align 8
@floatx80_params = internal constant [3 x %struct.FloatFmt] [%struct.FloatFmt { i32 15, i32 16383, i32 24576, i32 32767, i32 63, i32 0, i8 0, i8 0, i64 -1 }, %struct.FloatFmt { i32 15, i32 16383, i32 24576, i32 32767, i32 52, i32 0, i8 0, i8 0, i64 2047 }, %struct.FloatFmt { i32 15, i32 16383, i32 24576, i32 32767, i32 23, i32 0, i8 0, i8 0, i64 1099511627775 }], align 16
@.str.2 = private unnamed_addr constant [24 x i8] c"../qemu/fpu/softfloat.c\00", align 1
@__func__.roundAndPackFloatx80 = private unnamed_addr constant [21 x i8] c"roundAndPackFloatx80\00", align 1
@float32_exp2_coefficients = internal unnamed_addr constant [15 x i64] [i64 4607182418800017408, i64 4602678819172646912, i64 4595172819793696085, i64 4586165620538955093, i64 4575957461383581969, i64 4564047942368979991, i64 4551452160554016794, i64 4537941361671905306, i64 4523617214285662004, i64 4508805057796939612, i64 4493156764026750180, i64 4477122120089393304, i64 4460272573143870729, i64 4443145680587881629, i64 4425604618586929183], align 16
@.str.3 = private unnamed_addr constant [34 x i8] c"../qemu/fpu/softfloat-parts.c.inc\00", align 1
@__func__.parts64_addsub = private unnamed_addr constant [15 x i8] c"parts64_addsub\00", align 1
@.str.4 = private unnamed_addr constant [29 x i8] c"a->cls == float_class_normal\00", align 1
@.str.5 = private unnamed_addr constant [27 x i8] c"a->cls == float_class_zero\00", align 1
@.str.6 = private unnamed_addr constant [29 x i8] c"b->cls == float_class_normal\00", align 1
@__func__.parts128_addsub = private unnamed_addr constant [16 x i8] c"parts128_addsub\00", align 1
@__func__.parts64_mul = private unnamed_addr constant [12 x i8] c"parts64_mul\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"ab_mask & float_cmask_zero\00", align 1
@__func__.float64r32_round_pack_canonical = private unnamed_addr constant [32 x i8] c"float64r32_round_pack_canonical\00", align 1
@__func__.parts64_uncanon = private unnamed_addr constant [16 x i8] c"parts64_uncanon\00", align 1
@.str.10 = private unnamed_addr constant [16 x i8] c"!fmt->arm_althp\00", align 1
@__func__.parts64_uncanon_normal = private unnamed_addr constant [23 x i8] c"parts64_uncanon_normal\00", align 1
@__func__.parts128_mul = private unnamed_addr constant [13 x i8] c"parts128_mul\00", align 1
@__func__.parts128_uncanon = private unnamed_addr constant [17 x i8] c"parts128_uncanon\00", align 1
@__func__.parts128_uncanon_normal = private unnamed_addr constant [24 x i8] c"parts128_uncanon_normal\00", align 1
@__func__.floatx80_unpack_canonical = private unnamed_addr constant [26 x i8] c"floatx80_unpack_canonical\00", align 1
@__func__.floatx80_round_pack_canonical = private unnamed_addr constant [30 x i8] c"floatx80_round_pack_canonical\00", align 1
@__func__.parts64_muladd = private unnamed_addr constant [15 x i8] c"parts64_muladd\00", align 1
@.str.12 = private unnamed_addr constant [26 x i8] c"c->cls == float_class_inf\00", align 1
@__func__.parts128_muladd = private unnamed_addr constant [16 x i8] c"parts128_muladd\00", align 1
@__func__.parts64_div = private unnamed_addr constant [12 x i8] c"parts64_div\00", align 1
@.str.13 = private unnamed_addr constant [27 x i8] c"b->cls == float_class_zero\00", align 1
@__func__.parts128_div = private unnamed_addr constant [13 x i8] c"parts128_div\00", align 1
@__func__.parts64_modrem = private unnamed_addr constant [15 x i8] c"parts64_modrem\00", align 1
@.str.14 = private unnamed_addr constant [56 x i8] c"b->cls == float_class_inf || a->cls == float_class_zero\00", align 1
@__func__.parts128_modrem = private unnamed_addr constant [16 x i8] c"parts128_modrem\00", align 1
@__func__.parts_float_to_ahp = private unnamed_addr constant [19 x i8] c"parts_float_to_ahp\00", align 1
@__func__.parts128_return_nan = private unnamed_addr constant [20 x i8] c"parts128_return_nan\00", align 1
@__func__.parts64_round_to_int_normal = private unnamed_addr constant [28 x i8] c"parts64_round_to_int_normal\00", align 1
@__func__.parts128_round_to_int = private unnamed_addr constant [22 x i8] c"parts128_round_to_int\00", align 1
@__func__.parts128_round_to_int_normal = private unnamed_addr constant [29 x i8] c"parts128_round_to_int_normal\00", align 1
@__func__.parts128_float_to_sint = private unnamed_addr constant [23 x i8] c"parts128_float_to_sint\00", align 1
@__func__.float128_to_int128_scalbn = private unnamed_addr constant [26 x i8] c"float128_to_int128_scalbn\00", align 1
@__func__.parts64_float_to_sint_modulo = private unnamed_addr constant [29 x i8] c"parts64_float_to_sint_modulo\00", align 1
@__func__.parts128_float_to_uint = private unnamed_addr constant [23 x i8] c"parts128_float_to_uint\00", align 1
@__func__.float128_to_uint128_scalbn = private unnamed_addr constant [27 x i8] c"float128_to_uint128_scalbn\00", align 1
@__func__.parts64_minmax = private unnamed_addr constant [15 x i8] c"parts64_minmax\00", align 1
@__func__.parts128_minmax = private unnamed_addr constant [16 x i8] c"parts128_minmax\00", align 1
@__func__.parts64_compare = private unnamed_addr constant [16 x i8] c"parts64_compare\00", align 1
@.str.15 = private unnamed_addr constant [26 x i8] c"a->cls == float_class_inf\00", align 1
@__func__.parts128_compare = private unnamed_addr constant [17 x i8] c"parts128_compare\00", align 1
@__func__.parts128_scalbn = private unnamed_addr constant [16 x i8] c"parts128_scalbn\00", align 1
@rsqrt_tab = internal unnamed_addr constant [128 x i16] [i16 -19375, i16 -19728, i16 -20074, i16 -20412, i16 -20743, i16 -21066, i16 -21383, i16 -21693, i16 -21996, i16 -22293, i16 -22584, i16 -22870, i16 -23150, i16 -23424, i16 -23693, i16 -23957, i16 -24216, i16 -24470, i16 -24720, i16 -24965, i16 -25206, i16 -25443, i16 -25675, i16 -25903, i16 -26128, i16 -26349, i16 -26566, i16 -26779, i16 -26989, i16 -27196, i16 -27400, i16 -27600, i16 -27797, i16 -27991, i16 -28182, i16 -28370, i16 -28555, i16 -28738, i16 -28918, i16 -29095, i16 -29270, i16 -29442, i16 -29612, i16 -29780, i16 -29945, i16 -30108, i16 -30268, i16 -30427, i16 -30583, i16 -30738, i16 -30890, i16 -31040, i16 -31189, i16 -31335, i16 -31480, i16 -31623, i16 -31764, i16 -31903, i16 -32040, i16 -32176, i16 -32311, i16 -32443, i16 -32574, i16 -32704, i16 -254, i16 -754, i16 -1243, i16 -1721, i16 -2189, i16 -2646, i16 -3094, i16 -3532, i16 -3961, i16 -4381, i16 -4793, i16 -5197, i16 -5593, i16 -5981, i16 -6361, i16 -6734, i16 -7101, i16 -7460, i16 -7814, i16 -8160, i16 -8501, i16 -8835, i16 -9164, i16 -9487, i16 -9805, i16 -10117, i16 -10424, i16 -10726, i16 -11023, i16 -11315, i16 -11603, i16 -11886, i16 -12165, i16 -12439, i16 -12709, i16 -12975, i16 -13238, i16 -13496, i16 -13750, i16 -14001, i16 -14248, i16 -14492, i16 -14732, i16 -14969, i16 -15203, i16 -15433, i16 -15660, i16 -15884, i16 -16106, i16 -16324, i16 -16539, i16 -16752, i16 -16962, i16 -17169, i16 -17373, i16 -17575, i16 -17775, i16 -17972, i16 -18166, i16 -18358, i16 -18548, i16 -18736, i16 -18921, i16 -19104], align 16
@__func__.parts128_sqrt = private unnamed_addr constant [14 x i8] c"parts128_sqrt\00", align 1
@__func__.parts64_log2 = private unnamed_addr constant [13 x i8] c"parts64_log2\00", align 1
@__func__.parts64_return_nan = private unnamed_addr constant [19 x i8] c"parts64_return_nan\00", align 1
@llvm.global_ctors = appending global [0 x { i32, ptr, ptr }] zeroinitializer

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local { i64, i16 } @floatx80_default_nan(ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  ret { i64, i16 } { i64 -4611686018427387904, i16 -1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i1 @float16_is_quiet_nan(i16 noundef zeroext %a_, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %0 = and i16 %a_, 32256
  %cmp11 = icmp eq i16 %0, 32256
  ret i1 %cmp11
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i1 @bfloat16_is_quiet_nan(i16 noundef zeroext %a_, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %0 = and i16 %a_, 32704
  %cmp11 = icmp eq i16 %0, 32704
  ret i1 %cmp11
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i1 @float16_is_signaling_nan(i16 noundef zeroext %a_, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %conv5 = zext i16 %a_ to i32
  %0 = and i32 %conv5, 32256
  %cmp8 = icmp eq i32 %0, 31744
  %and11 = and i32 %conv5, 511
  %tobool = icmp ne i32 %and11, 0
  %1 = and i1 %cmp8, %tobool
  ret i1 %1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i1 @bfloat16_is_signaling_nan(i16 noundef zeroext %a_, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %conv5 = zext i16 %a_ to i32
  %0 = and i32 %conv5, 32704
  %cmp8 = icmp eq i32 %0, 32640
  %and11 = and i32 %conv5, 63
  %tobool = icmp ne i32 %and11, 0
  %1 = and i1 %cmp8, %tobool
  ret i1 %1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i1 @float32_is_quiet_nan(i32 noundef %a_, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %shl = shl i32 %a_, 1
  %cmp6 = icmp ugt i32 %shl, -8388609
  ret i1 %cmp6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i1 @float32_is_signaling_nan(i32 noundef %a_, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %0 = and i32 %a_, 2143289344
  %cmp4 = icmp eq i32 %0, 2139095040
  %and5 = and i32 %a_, 4194303
  %tobool = icmp ne i32 %and5, 0
  %1 = and i1 %cmp4, %tobool
  ret i1 %1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i1 @float64_is_quiet_nan(i64 noundef %a_, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %shl = shl i64 %a_, 1
  %cmp6 = icmp ugt i64 %shl, -4503599627370497
  ret i1 %cmp6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i1 @float64_is_signaling_nan(i64 noundef %a_, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %0 = and i64 %a_, 9221120237041090560
  %cmp4 = icmp eq i64 %0, 9218868437227405312
  %and5 = and i64 %a_, 2251799813685247
  %tobool = icmp ne i64 %and5, 0
  %1 = and i1 %cmp4, %tobool
  ret i1 %1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local i32 @floatx80_is_quiet_nan(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %0 = and i16 %a.coerce1, 32767
  %cmp14 = icmp eq i16 %0, 32767
  %shl18.mask = and i64 %a.coerce0, 4611686018427387904
  %cmp19 = icmp ne i64 %shl18.mask, 0
  %1 = select i1 %cmp14, i1 %cmp19, i1 false
  %land.ext22 = zext i1 %1 to i32
  ret i32 %land.ext22
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local i32 @floatx80_is_signaling_nan(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %0 = and i16 %a.coerce1, 32767
  %cmp12 = icmp eq i16 %0, 32767
  %shl14.mask = and i64 %a.coerce0, 4611686018427387903
  %tobool.not = icmp ne i64 %shl14.mask, 0
  %or.cond.not = select i1 %cmp12, i1 %tobool.not, i1 false
  %1 = and i64 %a.coerce0, 4611686018427387904
  %cmp17 = icmp eq i64 %1, 0
  %narrow = select i1 %or.cond.not, i1 %cmp17, i1 false
  %land.ext20 = zext i1 %narrow to i32
  ret i32 %land.ext20
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local { i64, i16 } @floatx80_silence_nan(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %or = or i64 %a.coerce0, -4611686018427387904
  %.fca.0.insert = insertvalue { i64, i16 } poison, i64 %or, 0
  %.fca.1.insert = insertvalue { i64, i16 } %.fca.0.insert, i16 %a.coerce1, 1
  ret { i64, i16 } %.fca.1.insert
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: readwrite) uwtable
define dso_local { i64, i16 } @propagateFloatx80NaN(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr nocapture noundef %status) local_unnamed_addr #2 {
entry:
  %0 = and i16 %a.coerce1, 32767
  %cmp.i = icmp eq i16 %0, 32767
  %shl.mask.i = and i64 %a.coerce0, 9223372036854775807
  %tobool.i = icmp ne i64 %shl.mask.i, 0
  %1 = select i1 %cmp.i, i1 %tobool.i, i1 false
  br i1 %1, label %cond.end, label %cond.end.thread

cond.end:                                         ; preds = %entry
  %shl14.mask.i = and i64 %a.coerce0, 4611686018427387903
  %tobool.not.i = icmp ne i64 %shl14.mask.i, 0
  %2 = and i64 %a.coerce0, 4611686018427387904
  %cmp17.i = icmp eq i64 %2, 0
  %narrow.i.not.not = and i1 %tobool.not.i, %cmp17.i
  %3 = select i1 %narrow.i.not.not, i8 5, i8 4
  %4 = and i16 %b.coerce1, 32767
  %cmp.i26 = icmp eq i16 %4, 32767
  %shl.mask.i27 = and i64 %b.coerce0, 9223372036854775807
  %tobool.i28 = icmp ne i64 %shl.mask.i27, 0
  %5 = select i1 %cmp.i26, i1 %tobool.i28, i1 false
  br i1 %5, label %cond.end9, label %cond.end9.thread

cond.end.thread:                                  ; preds = %entry
  %6 = and i16 %b.coerce1, 32767
  %cmp.i2662 = icmp eq i16 %6, 32767
  %shl.mask.i2763 = and i64 %b.coerce0, 9223372036854775807
  %tobool.i2864 = icmp ne i64 %shl.mask.i2763, 0
  %7 = select i1 %cmp.i2662, i1 %tobool.i2864, i1 false
  br i1 %7, label %cond.end9, label %if.end

cond.end9:                                        ; preds = %cond.end.thread, %cond.end
  %cond265 = phi i8 [ 2, %cond.end.thread ], [ %3, %cond.end ]
  %shl14.mask.i30 = and i64 %b.coerce0, 4611686018427387903
  %tobool.not.i31 = icmp ne i64 %shl14.mask.i30, 0
  %8 = and i64 %b.coerce0, 4611686018427387904
  %cmp17.i33 = icmp eq i64 %8, 0
  %narrow.i34.not.not = and i1 %tobool.not.i31, %cmp17.i33
  %9 = select i1 %narrow.i34.not.not, i8 5, i8 4
  %cmp.i36 = icmp eq i8 %cond265, 5
  %brmerge = select i1 %cmp.i36, i1 true, i1 %narrow.i34.not.not
  %.mux76 = select i1 %cmp.i36, i8 %9, i8 5
  br i1 %brmerge, label %if.then, label %if.end

cond.end9.thread:                                 ; preds = %cond.end
  br i1 %narrow.i.not.not, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end9, %cond.end9.thread
  %cond267 = phi i8 [ 5, %cond.end9.thread ], [ %cond265, %cond.end9 ]
  %cmp.i3650 = phi i1 [ true, %cond.end9.thread ], [ %cmp.i36, %cond.end9 ]
  %cond1047 = phi i8 [ 2, %cond.end9.thread ], [ %.mux76, %cond.end9 ]
  %10 = load i16, ptr %status, align 2
  %or1.i = or i16 %10, 1
  store i16 %or1.i, ptr %status, align 2
  br label %if.end

if.end:                                           ; preds = %cond.end9, %cond.end.thread, %cond.end9.thread, %if.then
  %cond266 = phi i8 [ %cond267, %if.then ], [ 4, %cond.end9.thread ], [ 2, %cond.end.thread ], [ %cond265, %cond.end9 ]
  %cmp.i3648 = phi i1 [ %cmp.i3650, %if.then ], [ false, %cond.end9.thread ], [ false, %cond.end.thread ], [ false, %cond.end9 ]
  %cond1046 = phi i8 [ %cond1047, %if.then ], [ 2, %cond.end9.thread ], [ 2, %cond.end.thread ], [ 4, %cond.end9 ]
  %default_nan_mode = getelementptr inbounds i8, ptr %status, i64 7
  %11 = load i8, ptr %default_nan_mode, align 1
  %12 = and i8 %11, 1
  %tobool16.not = icmp eq i8 %12, 0
  br i1 %tobool16.not, label %if.end19, label %return

if.end19:                                         ; preds = %if.end
  %cmp = icmp ult i64 %a.coerce0, %b.coerce0
  br i1 %cmp, label %if.end37, label %if.else

if.else:                                          ; preds = %if.end19
  %cmp25 = icmp uge i64 %b.coerce0, %a.coerce0
  %cmp32 = icmp uge i16 %a.coerce1, %b.coerce1
  %spec.select.not = select i1 %cmp25, i1 %cmp32, i1 false
  br label %if.end37

if.end37:                                         ; preds = %if.else, %if.end19
  %aIsLargerSignificand.0 = phi i1 [ true, %if.end19 ], [ %spec.select.not, %if.else ]
  switch i8 %cond266, label %if.then41 [
    i8 5, label %pickNaN.exit
    i8 4, label %if.then6.i
  ]

if.then6.i:                                       ; preds = %if.end37
  %cmp.i10.i = icmp ne i8 %cond1046, 5
  %cmp.i11.i = icmp eq i8 %cond1046, 4
  %spec.select.i = and i1 %cmp.i11.i, %aIsLargerSignificand.0
  %or.cond = select i1 %cmp.i10.i, i1 %spec.select.i, i1 false
  br i1 %or.cond, label %if.then41, label %if.else46

pickNaN.exit:                                     ; preds = %if.end37
  %cmp.i7.i = icmp eq i8 %cond1046, 5
  %cmp.i8.i = icmp eq i8 %cond1046, 4
  %spec.select = select i1 %cmp.i7.i, i1 %aIsLargerSignificand.0, i1 %cmp.i8.i
  br i1 %spec.select, label %if.then41, label %if.else46

if.then41:                                        ; preds = %if.then6.i, %if.end37, %pickNaN.exit
  %cmp.i38 = icmp eq i8 %cond1046, 5
  %or.i = or i64 %b.coerce0, -4611686018427387904
  %spec.select73 = select i1 %cmp.i38, i64 %or.i, i64 %b.coerce0
  br label %return

if.else46:                                        ; preds = %if.then6.i, %pickNaN.exit
  %or.i40 = or i64 %a.coerce0, -4611686018427387904
  %spec.select74 = select i1 %cmp.i3648, i64 %or.i40, i64 %a.coerce0
  br label %return

return:                                           ; preds = %if.else46, %if.then41, %if.end
  %retval.sroa.0.0 = phi i64 [ -4611686018427387904, %if.end ], [ %spec.select73, %if.then41 ], [ %spec.select74, %if.else46 ]
  %retval.sroa.6.0 = phi i16 [ -1, %if.end ], [ %b.coerce1, %if.then41 ], [ %a.coerce1, %if.else46 ]
  %.fca.0.insert = insertvalue { i64, i16 } poison, i64 %retval.sroa.0.0, 0
  %.fca.1.insert = insertvalue { i64, i16 } %.fca.0.insert, i16 %retval.sroa.6.0, 1
  ret { i64, i16 } %.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i1 @float128_is_quiet_nan(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %shl = shl i64 %a.coerce1, 1
  %cmp9 = icmp ugt i64 %shl, -281474976710657
  %and15 = and i64 %a.coerce1, 281474976710655
  %0 = or i64 %and15, %a.coerce0
  %1 = icmp ne i64 %0, 0
  %2 = select i1 %cmp9, i1 %1, i1 false
  ret i1 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i1 @float128_is_signaling_nan(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %0 = and i64 %a.coerce1, 9223231299366420480
  %cmp8 = icmp eq i64 %0, 9223090561878065152
  %and14 = and i64 %a.coerce1, 140737488355327
  %1 = or i64 %and14, %a.coerce0
  %2 = icmp ne i64 %1, 0
  %3 = select i1 %cmp8, i1 %2, i1 false
  ret i1 %3
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_add(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @float16_addsub(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %status, i1 noundef zeroext false)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc zeroext i16 @float16_addsub(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %status, i1 noundef zeroext %subtract) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts64, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %conv.i.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i16 %1, label %if.then33.i.i [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float16a_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float16a_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float16a_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit:                   ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %a.val.i106 = phi i64 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i.i, %if.then33.i.i ], [ 0, %if.then47.i.i ], [ %shl.i31.i.i, %if.else49.i.i ]
  %7 = phi i32 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %add.i.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ 31, %if.then47.i.i ], [ 31, %if.else49.i.i ]
  %8 = phi i8 [ 1, %if.then8.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ], [ 3, %if.then47.i.i ], [ %conv53.i.i, %if.else49.i.i ]
  %f.lobit.i.i42 = lshr i16 %b, 15
  %frombool.i.i.i43 = trunc i16 %f.lobit.i.i42 to i8
  %9 = lshr i16 %b, 10
  %10 = and i16 %9, 31
  %conv.i.i.i44 = zext nneg i16 %10 to i32
  %11 = and i16 %b, 1023
  %and.i10.i.i45 = zext nneg i16 %11 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i46 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i43, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i46, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i47 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i.i44, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i47, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i48 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i10.i.i45, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i48, align 8
  switch i16 %10, label %if.then33.i.i59 [
    i16 0, label %if.then.i.i63
    i16 31, label %lor.lhs.false.i.i52
  ]

if.then.i.i63:                                    ; preds = %float16a_unpack_canonical.exit
  %cmp.i.i.i64 = icmp eq i16 %11, 0
  br i1 %cmp.i.i.i64, label %if.then8.i.i75, label %if.else.i.i65

if.then8.i.i75:                                   ; preds = %if.then.i.i63
  store i8 1, ptr %pb, align 8
  br label %float16a_unpack_canonical.exit76

if.else.i.i65:                                    ; preds = %if.then.i.i63
  %flush_inputs_to_zero.i.i66 = getelementptr inbounds i8, ptr %status, i64 6
  %12 = load i8, ptr %flush_inputs_to_zero.i.i66, align 2
  %13 = and i8 %12, 1
  %tobool9.not.i.i67 = icmp eq i8 %13, 0
  br i1 %tobool9.not.i.i67, label %frac64_normalize.exit.i.i70, label %if.then10.i.i68

if.then10.i.i68:                                  ; preds = %if.else.i.i65
  %14 = load i16, ptr %status, align 2
  %or1.i.i.i69 = or i16 %14, 32
  store i16 %or1.i.i.i69, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i48, align 8
  br label %float16a_unpack_canonical.exit76

frac64_normalize.exit.i.i70:                      ; preds = %if.else.i.i65
  %15 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i45, i1 true), !range !5
  %cast.i.i.i.i71 = trunc i64 %15 to i32
  %shl.i.i.i72 = shl i64 %and.i10.i.i45, %15
  store i64 %shl.i.i.i72, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i48, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i74 = sub nsw i32 39, %cast.i.i.i.i71
  store i32 %add.i.i74, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i47, align 4
  br label %float16a_unpack_canonical.exit76

lor.lhs.false.i.i52:                              ; preds = %float16a_unpack_canonical.exit
  %cmp.i29.i.i53 = icmp eq i16 %11, 0
  br i1 %cmp.i29.i.i53, label %if.then47.i.i58, label %if.else49.i.i54

if.then33.i.i59:                                  ; preds = %float16a_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i60 = add nsw i32 %conv.i.i.i44, -15
  store i32 %sub37.i.i60, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i47, align 4
  %shl.i28.i.i61 = shl nuw nsw i64 %and.i10.i.i45, 53
  %or.i.i62 = or disjoint i64 %shl.i28.i.i61, -9223372036854775808
  store i64 %or.i.i62, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i48, align 8
  br label %float16a_unpack_canonical.exit76

if.then47.i.i58:                                  ; preds = %lor.lhs.false.i.i52
  store i8 3, ptr %pb, align 8
  br label %float16a_unpack_canonical.exit76

if.else49.i.i54:                                  ; preds = %lor.lhs.false.i.i52
  %shl.i31.i.i55 = shl nuw nsw i64 %and.i10.i.i45, 53
  store i64 %shl.i31.i.i55, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i48, align 8
  %tobool.not.i32.i.i56 = icmp ult i16 %11, 512
  %conv53.i.i57 = select i1 %tobool.not.i32.i.i56, i8 5, i8 4
  store i8 %conv53.i.i57, ptr %pb, align 8
  br label %float16a_unpack_canonical.exit76

float16a_unpack_canonical.exit76:                 ; preds = %if.then8.i.i75, %if.then10.i.i68, %frac64_normalize.exit.i.i70, %if.then33.i.i59, %if.then47.i.i58, %if.else49.i.i54
  %b.val.i107 = phi i64 [ 0, %if.then8.i.i75 ], [ 0, %if.then10.i.i68 ], [ %shl.i.i.i72, %frac64_normalize.exit.i.i70 ], [ %or.i.i62, %if.then33.i.i59 ], [ 0, %if.then47.i.i58 ], [ %shl.i31.i.i55, %if.else49.i.i54 ]
  %16 = phi i32 [ 0, %if.then8.i.i75 ], [ 0, %if.then10.i.i68 ], [ %add.i.i74, %frac64_normalize.exit.i.i70 ], [ %sub37.i.i60, %if.then33.i.i59 ], [ 31, %if.then47.i.i58 ], [ 31, %if.else49.i.i54 ]
  %.pr.i.pre = phi i8 [ 1, %if.then8.i.i75 ], [ 1, %if.then10.i.i68 ], [ 2, %frac64_normalize.exit.i.i70 ], [ 2, %if.then33.i.i59 ], [ 3, %if.then47.i.i58 ], [ %conv53.i.i57, %if.else49.i.i54 ]
  %17 = icmp slt i16 %b, 0
  %tobool3.i = xor i1 %17, %subtract
  %frombool4.i = zext i1 %tobool3.i to i8
  %conv5.i = zext nneg i8 %8 to i32
  %shl.i = shl nuw nsw i32 1, %conv5.i
  %conv7.i = zext nneg i8 %.pr.i.pre to i32
  %shl8.i = shl nuw nsw i32 1, %conv7.i
  %or.i = or i32 %shl8.i, %shl.i
  %18 = icmp sgt i16 %a, -1
  %cmp.i.not = xor i1 %18, %tobool3.i
  %trunc120 = trunc i32 %or.i to i8
  br i1 %cmp.i.not, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %float16a_unpack_canonical.exit76
  switch i8 %trunc120, label %if.end31.i [
    i8 4, label %if.then20.i
    i8 2, label %if.then25.i
  ]

if.then20.i:                                      ; preds = %if.then.i
  %sub.i = sub nsw i32 %7, %16
  %cmp.i = icmp sgt i32 %sub.i, 0
  br i1 %cmp.i, label %frac64_shrjam.exit.i, label %if.else.i77

frac64_shrjam.exit.i:                             ; preds = %if.then20.i
  %sh_prom.i.i = zext nneg i32 %sub.i to i64
  %shr.i.i = lshr i64 %b.val.i107, %sh_prom.i.i
  %19 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %b.val.i107, i32 %sub.i, i64 0) #15, !srcloc !6
  %cmp11.i.i = icmp ne i64 %19, 0
  %conv13.i.i = zext i1 %cmp11.i.i to i64
  %or.i.i82 = or i64 %shr.i.i, %conv13.i.i
  store i64 %or.i.i82, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i48, align 8
  %20 = sub i64 %a.val.i106, %or.i.i82
  store i64 %20, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %if.end19.i

if.else.i77:                                      ; preds = %if.then20.i
  %cmp2.i = icmp slt i32 %sub.i, 0
  br i1 %cmp2.i, label %frac64_shrjam.exit42.i, label %if.else9.i

frac64_shrjam.exit42.i:                           ; preds = %if.else.i77
  store i32 %16, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %frombool.i = xor i8 %frombool.i.i.i, 1
  store i8 %frombool.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %sub7.i = sub nsw i32 0, %sub.i
  %21 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.val.i106, i32 %sub7.i, i64 0) #15, !srcloc !6
  %sh_prom.i37.i = zext nneg i32 %sub7.i to i64
  %shr.i38.i = lshr i64 %a.val.i106, %sh_prom.i37.i
  %cmp11.i39.i = icmp ne i64 %21, 0
  %conv13.i40.i = zext i1 %cmp11.i39.i to i64
  %or.i41.i = or i64 %shr.i38.i, %conv13.i40.i
  %22 = sub i64 %b.val.i107, %or.i41.i
  store i64 %22, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %if.end19.i

if.else9.i:                                       ; preds = %if.else.i77
  %23 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a.val.i106, i64 %b.val.i107)
  %24 = extractvalue { i64, i1 } %23, 1
  %25 = extractvalue { i64, i1 } %23, 0
  store i64 %25, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br i1 %24, label %if.then11.i, label %if.end19.i

if.then11.i:                                      ; preds = %if.else9.i
  %sub.i.i = sub i64 0, %25
  store i64 %sub.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %frombool17.i = xor i8 %frombool.i.i.i, 1
  store i8 %frombool17.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %if.end19.i

if.end19.i:                                       ; preds = %if.then11.i, %if.else9.i, %frac64_shrjam.exit42.i, %frac64_shrjam.exit.i
  %26 = phi i32 [ %16, %frac64_shrjam.exit42.i ], [ %7, %if.then11.i ], [ %7, %if.else9.i ], [ %7, %frac64_shrjam.exit.i ]
  %27 = phi i64 [ %22, %frac64_shrjam.exit42.i ], [ %sub.i.i, %if.then11.i ], [ %25, %if.else9.i ], [ %20, %frac64_shrjam.exit.i ]
  %tobool.not.i.i.not = icmp eq i64 %27, 0
  br i1 %tobool.not.i.i.not, label %if.end22.i.thread, label %parts64_sub_normal.exit.thread

parts64_sub_normal.exit.thread:                   ; preds = %if.end19.i
  %28 = tail call i64 @llvm.ctlz.i64(i64 %27, i1 true), !range !5
  %cast.i.i.i = trunc i64 %28 to i32
  %shl.i.i = shl i64 %27, %28
  store i64 %shl.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub28.i = sub nsw i32 %26, %cast.i.i.i
  store i32 %sub28.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_addsub.exit

if.end22.i.thread:                                ; preds = %if.end19.i
  store i8 1, ptr %pa, align 8
  br label %if.then25.i

if.then25.i:                                      ; preds = %if.then.i, %if.end22.i.thread
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %29 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp27.i = icmp eq i8 %29, 1
  %frombool30.i = zext i1 %cmp27.i to i8
  store i8 %frombool30.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %parts64_addsub.exit

if.end31.i:                                       ; preds = %if.then.i
  %and.i = and i32 %or.i, 48
  %tobool32.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool32.i.not, label %if.end40.i, label %p_nan.i

if.end40.i:                                       ; preds = %if.end31.i
  %and41.i = and i32 %or.i, 8
  %tobool42.i.not = icmp eq i32 %and41.i, 0
  br i1 %tobool42.i.not, label %if.end86.i, label %if.then43.i

if.then43.i:                                      ; preds = %if.end40.i
  %cmp46.i.not = icmp eq i8 %8, 3
  br i1 %cmp46.i.not, label %if.end49.i, label %return_b.i

if.end49.i:                                       ; preds = %if.then43.i
  %cmp52.i.not = icmp eq i8 %.pr.i.pre, 3
  br i1 %cmp52.i.not, label %if.end55.i, label %parts64_addsub.exit

if.end55.i:                                       ; preds = %if.end49.i
  %30 = load i16, ptr %status, align 2
  %or1.i = or i16 %30, 129
  store i16 %or1.i, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_addsub.exit

if.else.i:                                        ; preds = %float16a_unpack_canonical.exit76
  switch i8 %trunc120, label %if.end70.i [
    i8 4, label %if.then65.i
    i8 2, label %parts64_addsub.exit
  ]

if.then65.i:                                      ; preds = %if.else.i
  %sub.i85 = sub nsw i32 %7, %16
  %cmp.i86 = icmp sgt i32 %sub.i85, 0
  br i1 %cmp.i86, label %frac64_shrjam.exit.i96, label %if.else.i87

frac64_shrjam.exit.i96:                           ; preds = %if.then65.i
  %sh_prom.i.i99 = zext nneg i32 %sub.i85 to i64
  %shr.i.i100 = lshr i64 %b.val.i107, %sh_prom.i.i99
  %31 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %b.val.i107, i32 %sub.i85, i64 0) #15, !srcloc !6
  %cmp11.i.i101 = icmp ne i64 %31, 0
  %conv13.i.i102 = zext i1 %cmp11.i.i101 to i64
  %or.i.i103 = or i64 %shr.i.i100, %conv13.i.i102
  store i64 %or.i.i103, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i48, align 8
  br label %if.end7.i

if.else.i87:                                      ; preds = %if.then65.i
  %cmp2.i88 = icmp slt i32 %sub.i85, 0
  br i1 %cmp2.i88, label %frac64_shrjam.exit28.i, label %if.end7.i

frac64_shrjam.exit28.i:                           ; preds = %if.else.i87
  %sub4.i = sub nsw i32 0, %sub.i85
  %32 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.val.i106, i32 %sub4.i, i64 0) #15, !srcloc !6
  %sh_prom.i23.i = zext nneg i32 %sub4.i to i64
  %shr.i24.i = lshr i64 %a.val.i106, %sh_prom.i23.i
  %cmp11.i25.i = icmp ne i64 %32, 0
  %conv13.i26.i = zext i1 %cmp11.i25.i to i64
  %or.i27.i = or i64 %shr.i24.i, %conv13.i26.i
  store i32 %16, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %if.end7.i

if.end7.i:                                        ; preds = %frac64_shrjam.exit28.i, %if.else.i87, %frac64_shrjam.exit.i96
  %33 = phi i32 [ %16, %frac64_shrjam.exit28.i ], [ %7, %if.else.i87 ], [ %7, %frac64_shrjam.exit.i96 ]
  %b.val.i = phi i64 [ %b.val.i107, %frac64_shrjam.exit28.i ], [ %b.val.i107, %if.else.i87 ], [ %or.i.i103, %frac64_shrjam.exit.i96 ]
  %a.val.i89 = phi i64 [ %or.i27.i, %frac64_shrjam.exit28.i ], [ %a.val.i106, %if.else.i87 ], [ %a.val.i106, %frac64_shrjam.exit.i96 ]
  %34 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %a.val.i89, i64 %b.val.i)
  %35 = extractvalue { i64, i1 } %34, 1
  %36 = extractvalue { i64, i1 } %34, 0
  store i64 %36, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br i1 %35, label %if.then8.i, label %parts64_addsub.exit

if.then8.i:                                       ; preds = %if.end7.i
  %shr.i31.i = lshr i64 %36, 1
  %37 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %36, i32 1, i64 0) #15, !srcloc !6
  %cmp11.i32.i = icmp ne i64 %37, 0
  %conv13.i33.i = zext i1 %cmp11.i32.i to i64
  %or.i34.i = or i64 %shr.i31.i, %conv13.i33.i
  %or.i90 = or disjoint i64 %or.i34.i, -9223372036854775808
  store i64 %or.i90, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %add.i = add nsw i32 %33, 1
  store i32 %add.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_addsub.exit

if.end70.i:                                       ; preds = %if.else.i
  %and71.i = and i32 %or.i, 48
  %tobool72.i.not = icmp eq i32 %and71.i, 0
  br i1 %tobool72.i.not, label %if.end80.i, label %p_nan.i

if.end80.i:                                       ; preds = %if.end70.i
  %and81.i = and i32 %or.i, 8
  %tobool82.i.not = icmp eq i32 %and81.i, 0
  br i1 %tobool82.i.not, label %if.end86.i, label %if.then83.i

if.then83.i:                                      ; preds = %if.end80.i
  store i8 3, ptr %pa, align 8
  br label %parts64_addsub.exit

if.end86.i:                                       ; preds = %if.end80.i, %if.end40.i
  %cmp89.i = icmp eq i8 %.pr.i.pre, 1
  br i1 %cmp89.i, label %if.then91.i, label %if.end99.i

if.then91.i:                                      ; preds = %if.end86.i
  %cmp94.i = icmp eq i8 %8, 2
  br i1 %cmp94.i, label %parts64_addsub.exit, label %if.else97.i

if.else97.i:                                      ; preds = %if.then91.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 401, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.4) #16
  unreachable

if.end99.i:                                       ; preds = %if.end86.i
  %cmp103.i = icmp eq i8 %8, 1
  br i1 %cmp103.i, label %if.then105.i, label %if.else106.i

if.then105.i:                                     ; preds = %if.end99.i
  %cmp112.i = icmp eq i8 %.pr.i.pre, 2
  br i1 %cmp112.i, label %return_b.i, label %if.else115.i

if.else106.i:                                     ; preds = %if.end99.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 405, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.5) #16
  unreachable

if.else115.i:                                     ; preds = %if.then105.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 406, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.6) #16
  unreachable

return_b.i:                                       ; preds = %if.then105.i, %if.then43.i
  store i8 %frombool4.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i46, align 1
  br label %parts64_addsub.exit

p_nan.i:                                          ; preds = %if.end70.i, %if.end31.i
  %cmp.i.i104 = icmp eq i8 %8, 5
  %cmp.i17.i = icmp eq i8 %.pr.i.pre, 5
  %or.cond = or i1 %cmp.i.i104, %cmp.i17.i
  br i1 %or.cond, label %if.then.i110, label %if.end.i

if.then.i110:                                     ; preds = %p_nan.i
  %38 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %38, 8193
  store i16 %or1.i.i, ptr %status, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %p_nan.i, %if.then.i110
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %39 = load i8, ptr %default_nan_mode.i, align 1
  %40 = and i8 %39, 1
  %tobool.not.i = icmp eq i8 %40, 0
  br i1 %tobool.not.i, label %if.else.i105, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_addsub.exit

if.else.i105:                                     ; preds = %if.end.i
  %cmp.i18.i = icmp eq i64 %a.val.i106, %b.val.i107
  %cmp1.i.i = icmp ult i64 %a.val.i106, %b.val.i107
  %cmp11.i = icmp uge i16 %f.lobit.i.i, %f.lobit.i.i42
  %cmp.0.i = select i1 %cmp.i18.i, i1 %cmp11.i, i1 %cmp1.i.i
  %cmp.0.i.fr = freeze i1 %cmp.0.i
  switch i8 %8, label %41 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.else.i105
  br i1 %cmp.i17.i, label %parts64_addsub.exit, label %lor.lhs.false.i.i108

lor.lhs.false.i.i108:                             ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select.i.i = and i1 %cmp.i11.i.i, %cmp.0.i.fr
  %spec.select = select i1 %spec.select.i.i, ptr %pb, ptr %pa
  br label %parts64_addsub.exit

pickNaN.exit.i:                                   ; preds = %if.else.i105
  %cmp.i8.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select20.i = select i1 %cmp.i17.i, i1 %cmp.0.i.fr, i1 %cmp.i8.i.i
  br i1 %spec.select20.i, label %41, label %if.then24.i

41:                                               ; preds = %if.else.i105, %pickNaN.exit.i
  %42 = icmp eq i8 %.pr.i.pre, 5
  br i1 %42, label %if.then24.i, label %parts64_addsub.exit

if.then24.i:                                      ; preds = %pickNaN.exit.i, %41
  %.ph.i123 = phi ptr [ %pb, %41 ], [ %pa, %pickNaN.exit.i ]
  %.ph.i123.sroa.phi = phi ptr [ %pb.sroa.gep, %41 ], [ %pa.sroa.gep, %pickNaN.exit.i ]
  %43 = load i64, ptr %.ph.i123.sroa.phi, align 8
  %or4.i.i.i = or i64 %43, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.ph.i123.sroa.phi, align 8
  store i8 4, ptr %.ph.i123, align 8
  br label %parts64_addsub.exit

parts64_addsub.exit:                              ; preds = %lor.lhs.false.i.i108, %if.then24.i, %41, %if.then6.i.i, %if.then3.i, %if.then8.i, %if.end7.i, %parts64_sub_normal.exit.thread, %if.then91.i, %if.else.i, %if.end49.i, %return_b.i, %if.then83.i, %if.end55.i, %if.then25.i
  %retval.i.0 = phi ptr [ %pa, %if.then25.i ], [ %pb, %return_b.i ], [ %pa, %if.end55.i ], [ %pa, %if.then83.i ], [ %pa, %if.end49.i ], [ %pa, %if.else.i ], [ %pa, %if.then91.i ], [ %pa, %parts64_sub_normal.exit.thread ], [ %pa, %if.end7.i ], [ %pa, %if.then8.i ], [ %pa, %if.then3.i ], [ %.ph.i123, %if.then24.i ], [ %pb, %41 ], [ %pa, %if.then6.i.i ], [ %spec.select, %lor.lhs.false.i.i108 ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %retval.i.0, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 1
  %44 = load i8, ptr %sign.i.i.i, align 1
  %conv.i.i.i111 = zext i8 %44 to i64
  %shl.i.i.i112 = shl nuw nsw i64 %conv.i.i.i111, 15
  %exp.i.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 4
  %45 = load i32, ptr %exp.i.i.i, align 4
  %46 = shl i32 %45, 10
  %47 = and i32 %46, 31744
  %and8.i.i.i = zext nneg i32 %47 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i112, %and8.i.i.i
  %48 = getelementptr inbounds i8, ptr %retval.i.0, i64 8
  %49 = load i64, ptr %48, align 8
  %shl77.i9.i.i = and i64 %49, 1023
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i16
  ret i16 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_sub(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @float16_addsub(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %status, i1 noundef zeroext true)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_add(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %0 = load i16, ptr %s, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %soft39.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %s, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i.i = icmp eq i8 %2, 0
  br i1 %cmp.i.i, label %if.end.i, label %soft39.i

if.end.i:                                         ; preds = %can_use_fpu.exit.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool.not.i5.i = icmp eq i8 %4, 0
  br i1 %tobool.not.i5.i, label %float32_input_flush2.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end.i
  %and.i.i.i.i.i = and i32 %a, 2139095040
  %cmp.i.i.i.i.i = icmp eq i32 %and.i.i.i.i.i, 0
  %and.i2.i.i.i.i = and i32 %a, 2147483647
  %cmp.i3.i.i.i.i = icmp ne i32 %and.i2.i.i.i.i, 0
  %5 = and i1 %cmp.i.i.i.i.i, %cmp.i3.i.i.i.i
  %.lobit.i.i.i = and i32 %a, -2147483648
  %ua.sroa.0.0.i = select i1 %5, i32 %.lobit.i.i.i, i32 %a
  %and.i.i.i3.i.i = and i32 %b, 2139095040
  %cmp.i.i.i4.i.i = icmp eq i32 %and.i.i.i3.i.i, 0
  %and.i2.i.i5.i.i = and i32 %b, 2147483647
  %cmp.i3.i.i6.i.i = icmp ne i32 %and.i2.i.i5.i.i, 0
  %6 = and i1 %cmp.i.i.i4.i.i, %cmp.i3.i.i6.i.i
  %.lobit.i8.i.i = and i32 %b, -2147483648
  %ub.sroa.0.0.ph.i = select i1 %6, i32 %.lobit.i8.i.i, i32 %b
  %7 = or i1 %5, %6
  br i1 %7, label %8, label %float32_input_flush2.exit.i

8:                                                ; preds = %if.end.i.i
  %or1.i.i.i.i = or i16 %0, 32
  store i16 %or1.i.i.i.i, ptr %s, align 2
  br label %float32_input_flush2.exit.i

float32_input_flush2.exit.i:                      ; preds = %8, %if.end.i.i, %if.end.i
  %9 = phi i16 [ %0, %if.end.i ], [ %0, %if.end.i.i ], [ %or1.i.i.i.i, %8 ]
  %ua.sroa.0.1.i = phi i32 [ %a, %if.end.i ], [ %ua.sroa.0.0.i, %if.end.i.i ], [ %ua.sroa.0.0.i, %8 ]
  %ub.sroa.0.0.i = phi i32 [ %b, %if.end.i ], [ %ub.sroa.0.0.ph.i, %if.end.i.i ], [ %ub.sroa.0.0.ph.i, %8 ]
  %shr.i.i.i.i = lshr i32 %ua.sroa.0.1.i, 23
  %add.i.i.i.i = add nuw nsw i32 %shr.i.i.i.i, 1
  %and.i.i.i.i = and i32 %add.i.i.i.i, 254
  %cmp.i.i.i.i = icmp ne i32 %and.i.i.i.i, 0
  %and.i2.i.i.i = and i32 %ua.sroa.0.1.i, 2147483647
  %cmp.i3.i.i.i = icmp eq i32 %and.i2.i.i.i, 0
  %10 = or i1 %cmp.i3.i.i.i, %cmp.i.i.i.i
  br i1 %10, label %f32_is_zon2.exit.i, label %soft39.i

f32_is_zon2.exit.i:                               ; preds = %float32_input_flush2.exit.i
  %shr.i.i1.i.i = lshr i32 %ub.sroa.0.0.i, 23
  %add.i.i2.i.i = add nuw nsw i32 %shr.i.i1.i.i, 1
  %and.i.i3.i.i = and i32 %add.i.i2.i.i, 254
  %cmp.i.i4.i.i = icmp ne i32 %and.i.i3.i.i, 0
  %and.i2.i5.i.i = and i32 %ub.sroa.0.0.i, 2147483647
  %cmp.i3.i6.i.i = icmp eq i32 %and.i2.i5.i.i, 0
  %11 = or i1 %cmp.i3.i6.i.i, %cmp.i.i4.i.i
  br i1 %11, label %if.end14.i, label %soft39.i

if.end14.i:                                       ; preds = %f32_is_zon2.exit.i
  %12 = bitcast i32 %ua.sroa.0.1.i to float
  %13 = bitcast i32 %ub.sroa.0.0.i to float
  %add.i = fadd float %12, %13
  %14 = bitcast float %add.i to i32
  %15 = tail call float @llvm.fabs.f32(float %add.i) #17
  %isinf.i.i = fcmp oeq float %15, 0x7FF0000000000000
  br i1 %isinf.i.i, label %if.then24.i, label %if.else.i

if.then24.i:                                      ; preds = %if.end14.i
  %or1.i.i = or i16 %9, 4
  store i16 %or1.i.i, ptr %s, align 2
  br label %float32_gen2.exit

if.else.i:                                        ; preds = %if.end14.i
  %cmp.i = fcmp ugt float %15, 0x3810000000000000
  br i1 %cmp.i, label %float32_gen2.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.else.i
  %16 = or i32 %ub.sroa.0.0.i, %ua.sroa.0.1.i
  %17 = and i32 %16, 2147483647
  %lnot.i.not.i = icmp eq i32 %17, 0
  br i1 %lnot.i.not.i, label %float32_gen2.exit, label %soft39.i

soft39.i:                                         ; preds = %land.lhs.true.i, %f32_is_zon2.exit.i, %float32_input_flush2.exit.i, %can_use_fpu.exit.i, %entry
  %ua.sroa.0.2.i = phi i32 [ %ua.sroa.0.1.i, %land.lhs.true.i ], [ %ua.sroa.0.1.i, %f32_is_zon2.exit.i ], [ %a, %can_use_fpu.exit.i ], [ %a, %entry ], [ %ua.sroa.0.1.i, %float32_input_flush2.exit.i ]
  %ub.sroa.0.1.i = phi i32 [ %ub.sroa.0.0.i, %land.lhs.true.i ], [ %ub.sroa.0.0.i, %f32_is_zon2.exit.i ], [ %b, %can_use_fpu.exit.i ], [ %b, %entry ], [ %ub.sroa.0.0.i, %float32_input_flush2.exit.i ]
  %call.i = tail call fastcc i32 @soft_f32_addsub(i32 noundef %ua.sroa.0.2.i, i32 noundef %ub.sroa.0.1.i, ptr noundef nonnull %s, i1 noundef zeroext false)
  br label %float32_gen2.exit

float32_gen2.exit:                                ; preds = %if.then24.i, %if.else.i, %land.lhs.true.i, %soft39.i
  %retval.0.i = phi i32 [ %call.i, %soft39.i ], [ %14, %if.else.i ], [ %14, %land.lhs.true.i ], [ %14, %if.then24.i ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_sub(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %0 = load i16, ptr %s, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %soft39.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %s, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i.i = icmp eq i8 %2, 0
  br i1 %cmp.i.i, label %if.end.i, label %soft39.i

if.end.i:                                         ; preds = %can_use_fpu.exit.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool.not.i5.i = icmp eq i8 %4, 0
  br i1 %tobool.not.i5.i, label %float32_input_flush2.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end.i
  %and.i.i.i.i.i = and i32 %a, 2139095040
  %cmp.i.i.i.i.i = icmp eq i32 %and.i.i.i.i.i, 0
  %and.i2.i.i.i.i = and i32 %a, 2147483647
  %cmp.i3.i.i.i.i = icmp ne i32 %and.i2.i.i.i.i, 0
  %5 = and i1 %cmp.i.i.i.i.i, %cmp.i3.i.i.i.i
  %.lobit.i.i.i = and i32 %a, -2147483648
  %ua.sroa.0.0.i = select i1 %5, i32 %.lobit.i.i.i, i32 %a
  %and.i.i.i3.i.i = and i32 %b, 2139095040
  %cmp.i.i.i4.i.i = icmp eq i32 %and.i.i.i3.i.i, 0
  %and.i2.i.i5.i.i = and i32 %b, 2147483647
  %cmp.i3.i.i6.i.i = icmp ne i32 %and.i2.i.i5.i.i, 0
  %6 = and i1 %cmp.i.i.i4.i.i, %cmp.i3.i.i6.i.i
  %.lobit.i8.i.i = and i32 %b, -2147483648
  %ub.sroa.0.0.ph.i = select i1 %6, i32 %.lobit.i8.i.i, i32 %b
  %7 = or i1 %5, %6
  br i1 %7, label %8, label %float32_input_flush2.exit.i

8:                                                ; preds = %if.end.i.i
  %or1.i.i.i.i = or i16 %0, 32
  store i16 %or1.i.i.i.i, ptr %s, align 2
  br label %float32_input_flush2.exit.i

float32_input_flush2.exit.i:                      ; preds = %8, %if.end.i.i, %if.end.i
  %9 = phi i16 [ %0, %if.end.i ], [ %0, %if.end.i.i ], [ %or1.i.i.i.i, %8 ]
  %ua.sroa.0.1.i = phi i32 [ %a, %if.end.i ], [ %ua.sroa.0.0.i, %if.end.i.i ], [ %ua.sroa.0.0.i, %8 ]
  %ub.sroa.0.0.i = phi i32 [ %b, %if.end.i ], [ %ub.sroa.0.0.ph.i, %if.end.i.i ], [ %ub.sroa.0.0.ph.i, %8 ]
  %shr.i.i.i.i = lshr i32 %ua.sroa.0.1.i, 23
  %add.i.i.i.i = add nuw nsw i32 %shr.i.i.i.i, 1
  %and.i.i.i.i = and i32 %add.i.i.i.i, 254
  %cmp.i.i.i.i = icmp ne i32 %and.i.i.i.i, 0
  %and.i2.i.i.i = and i32 %ua.sroa.0.1.i, 2147483647
  %cmp.i3.i.i.i = icmp eq i32 %and.i2.i.i.i, 0
  %10 = or i1 %cmp.i3.i.i.i, %cmp.i.i.i.i
  br i1 %10, label %f32_is_zon2.exit.i, label %soft39.i

f32_is_zon2.exit.i:                               ; preds = %float32_input_flush2.exit.i
  %shr.i.i1.i.i = lshr i32 %ub.sroa.0.0.i, 23
  %add.i.i2.i.i = add nuw nsw i32 %shr.i.i1.i.i, 1
  %and.i.i3.i.i = and i32 %add.i.i2.i.i, 254
  %cmp.i.i4.i.i = icmp ne i32 %and.i.i3.i.i, 0
  %and.i2.i5.i.i = and i32 %ub.sroa.0.0.i, 2147483647
  %cmp.i3.i6.i.i = icmp eq i32 %and.i2.i5.i.i, 0
  %11 = or i1 %cmp.i3.i6.i.i, %cmp.i.i4.i.i
  br i1 %11, label %if.end14.i, label %soft39.i

if.end14.i:                                       ; preds = %f32_is_zon2.exit.i
  %12 = bitcast i32 %ua.sroa.0.1.i to float
  %13 = bitcast i32 %ub.sroa.0.0.i to float
  %sub.i = fsub float %12, %13
  %14 = bitcast float %sub.i to i32
  %15 = tail call float @llvm.fabs.f32(float %sub.i) #17
  %isinf.i.i = fcmp oeq float %15, 0x7FF0000000000000
  br i1 %isinf.i.i, label %if.then24.i, label %if.else.i

if.then24.i:                                      ; preds = %if.end14.i
  %or1.i.i = or i16 %9, 4
  store i16 %or1.i.i, ptr %s, align 2
  br label %float32_gen2.exit

if.else.i:                                        ; preds = %if.end14.i
  %cmp.i = fcmp ugt float %15, 0x3810000000000000
  br i1 %cmp.i, label %float32_gen2.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.else.i
  %16 = or i32 %ub.sroa.0.0.i, %ua.sroa.0.1.i
  %17 = and i32 %16, 2147483647
  %lnot.i.not.i = icmp eq i32 %17, 0
  br i1 %lnot.i.not.i, label %float32_gen2.exit, label %soft39.i

soft39.i:                                         ; preds = %land.lhs.true.i, %f32_is_zon2.exit.i, %float32_input_flush2.exit.i, %can_use_fpu.exit.i, %entry
  %ua.sroa.0.2.i = phi i32 [ %ua.sroa.0.1.i, %land.lhs.true.i ], [ %ua.sroa.0.1.i, %f32_is_zon2.exit.i ], [ %a, %can_use_fpu.exit.i ], [ %a, %entry ], [ %ua.sroa.0.1.i, %float32_input_flush2.exit.i ]
  %ub.sroa.0.1.i = phi i32 [ %ub.sroa.0.0.i, %land.lhs.true.i ], [ %ub.sroa.0.0.i, %f32_is_zon2.exit.i ], [ %b, %can_use_fpu.exit.i ], [ %b, %entry ], [ %ub.sroa.0.0.i, %float32_input_flush2.exit.i ]
  %call.i = tail call fastcc i32 @soft_f32_addsub(i32 noundef %ua.sroa.0.2.i, i32 noundef %ub.sroa.0.1.i, ptr noundef nonnull %s, i1 noundef zeroext true)
  br label %float32_gen2.exit

float32_gen2.exit:                                ; preds = %if.then24.i, %if.else.i, %land.lhs.true.i, %soft39.i
  %retval.0.i = phi i32 [ %call.i, %soft39.i ], [ %14, %if.else.i ], [ %14, %land.lhs.true.i ], [ %14, %if.then24.i ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_add(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %0 = load i16, ptr %s, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %soft39.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %s, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i.i = icmp eq i8 %2, 0
  br i1 %cmp.i.i, label %if.end.i, label %soft39.i

if.end.i:                                         ; preds = %can_use_fpu.exit.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool.not.i5.i = icmp eq i8 %4, 0
  br i1 %tobool.not.i5.i, label %float64_input_flush2.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end.i
  %and.i.i.i.i.i = and i64 %a, 9218868437227405312
  %cmp.i.i.i.i.i = icmp eq i64 %and.i.i.i.i.i, 0
  %and.i2.i.i.i.i = and i64 %a, 9223372036854775807
  %cmp.i3.i.i.i.i = icmp ne i64 %and.i2.i.i.i.i, 0
  %5 = and i1 %cmp.i.i.i.i.i, %cmp.i3.i.i.i.i
  %.lobit.i.i.i = and i64 %a, -9223372036854775808
  %ua.sroa.0.0.i = select i1 %5, i64 %.lobit.i.i.i, i64 %a
  %and.i.i.i3.i.i = and i64 %b, 9218868437227405312
  %cmp.i.i.i4.i.i = icmp eq i64 %and.i.i.i3.i.i, 0
  %and.i2.i.i5.i.i = and i64 %b, 9223372036854775807
  %cmp.i3.i.i6.i.i = icmp ne i64 %and.i2.i.i5.i.i, 0
  %6 = and i1 %cmp.i.i.i4.i.i, %cmp.i3.i.i6.i.i
  %.lobit.i8.i.i = and i64 %b, -9223372036854775808
  %ub.sroa.0.0.ph.i = select i1 %6, i64 %.lobit.i8.i.i, i64 %b
  %7 = or i1 %5, %6
  br i1 %7, label %8, label %float64_input_flush2.exit.i

8:                                                ; preds = %if.end.i.i
  %or1.i.i.i.i = or i16 %0, 32
  store i16 %or1.i.i.i.i, ptr %s, align 2
  br label %float64_input_flush2.exit.i

float64_input_flush2.exit.i:                      ; preds = %8, %if.end.i.i, %if.end.i
  %9 = phi i16 [ %0, %if.end.i ], [ %0, %if.end.i.i ], [ %or1.i.i.i.i, %8 ]
  %ua.sroa.0.1.i = phi i64 [ %a, %if.end.i ], [ %ua.sroa.0.0.i, %if.end.i.i ], [ %ua.sroa.0.0.i, %8 ]
  %ub.sroa.0.0.i = phi i64 [ %b, %if.end.i ], [ %ub.sroa.0.0.ph.i, %if.end.i.i ], [ %ub.sroa.0.0.ph.i, %8 ]
  %10 = bitcast i64 %ua.sroa.0.1.i to double
  %or.cond.i.i = fcmp ueq double %10, 0.000000e+00
  br i1 %or.cond.i.i, label %lor.lhs.false.i.i, label %fpclassify_not_nan.i.i

lor.lhs.false.i.i:                                ; preds = %float64_input_flush2.exit.i
  %iszero.i.i = fcmp oeq double %10, 0.000000e+00
  br i1 %iszero.i.i, label %land.rhs.i6.i, label %soft39.i

fpclassify_not_nan.i.i:                           ; preds = %float64_input_flush2.exit.i
  %or.cond13.i.i = tail call i1 @llvm.is.fpclass.f64(double %10, i32 267)
  br i1 %or.cond13.i.i, label %land.rhs.i6.i, label %soft39.i

land.rhs.i6.i:                                    ; preds = %fpclassify_not_nan.i.i, %lor.lhs.false.i.i
  %11 = bitcast i64 %ub.sroa.0.0.i to double
  %iszero15.i.i = fcmp oeq double %11, 0.000000e+00
  %or.cond10.i.i = fcmp ueq double %11, 0.000000e+00
  br i1 %or.cond10.i.i, label %f64_is_zon2.exit.i, label %fpclassify_not_nan18.i.i

fpclassify_not_nan18.i.i:                         ; preds = %land.rhs.i6.i
  %or.cond14.i.i = tail call i1 @llvm.is.fpclass.f64(double %11, i32 267)
  %brmerge.i = or i1 %or.cond14.i.i, %iszero15.i.i
  br i1 %brmerge.i, label %if.end14.i, label %soft39.i

f64_is_zon2.exit.i:                               ; preds = %land.rhs.i6.i
  br i1 %iszero15.i.i, label %if.end14.i, label %soft39.i

if.end14.i:                                       ; preds = %f64_is_zon2.exit.i, %fpclassify_not_nan18.i.i
  %add.i = fadd double %10, %11
  %12 = bitcast double %add.i to i64
  %13 = tail call double @llvm.fabs.f64(double %add.i) #17
  %isinf.i.i = fcmp oeq double %13, 0x7FF0000000000000
  br i1 %isinf.i.i, label %if.then24.i, label %if.else.i

if.then24.i:                                      ; preds = %if.end14.i
  %or1.i.i = or i16 %9, 4
  store i16 %or1.i.i, ptr %s, align 2
  br label %float64_gen2.exit

if.else.i:                                        ; preds = %if.end14.i
  %cmp.i = fcmp ugt double %13, 0x10000000000000
  br i1 %cmp.i, label %float64_gen2.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.else.i
  %14 = or i64 %ub.sroa.0.0.i, %ua.sroa.0.1.i
  %15 = and i64 %14, 9223372036854775807
  %lnot.i.not.i = icmp eq i64 %15, 0
  br i1 %lnot.i.not.i, label %float64_gen2.exit, label %soft39.i

soft39.i:                                         ; preds = %land.lhs.true.i, %f64_is_zon2.exit.i, %fpclassify_not_nan18.i.i, %fpclassify_not_nan.i.i, %lor.lhs.false.i.i, %can_use_fpu.exit.i, %entry
  %ua.sroa.0.2.i = phi i64 [ %ua.sroa.0.1.i, %land.lhs.true.i ], [ %ua.sroa.0.1.i, %f64_is_zon2.exit.i ], [ %a, %can_use_fpu.exit.i ], [ %a, %entry ], [ %ua.sroa.0.1.i, %fpclassify_not_nan.i.i ], [ %ua.sroa.0.1.i, %lor.lhs.false.i.i ], [ %ua.sroa.0.1.i, %fpclassify_not_nan18.i.i ]
  %ub.sroa.0.1.i = phi i64 [ %ub.sroa.0.0.i, %land.lhs.true.i ], [ %ub.sroa.0.0.i, %f64_is_zon2.exit.i ], [ %b, %can_use_fpu.exit.i ], [ %b, %entry ], [ %ub.sroa.0.0.i, %fpclassify_not_nan.i.i ], [ %ub.sroa.0.0.i, %lor.lhs.false.i.i ], [ %ub.sroa.0.0.i, %fpclassify_not_nan18.i.i ]
  %call.i = tail call fastcc i64 @soft_f64_addsub(i64 noundef %ua.sroa.0.2.i, i64 noundef %ub.sroa.0.1.i, ptr noundef nonnull %s, i1 noundef zeroext false)
  br label %float64_gen2.exit

float64_gen2.exit:                                ; preds = %if.then24.i, %if.else.i, %land.lhs.true.i, %soft39.i
  %retval.0.i = phi i64 [ %call.i, %soft39.i ], [ %12, %if.else.i ], [ %12, %land.lhs.true.i ], [ %12, %if.then24.i ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_sub(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %0 = load i16, ptr %s, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %soft39.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %s, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i.i = icmp eq i8 %2, 0
  br i1 %cmp.i.i, label %if.end.i, label %soft39.i

if.end.i:                                         ; preds = %can_use_fpu.exit.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool.not.i5.i = icmp eq i8 %4, 0
  br i1 %tobool.not.i5.i, label %float64_input_flush2.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end.i
  %and.i.i.i.i.i = and i64 %a, 9218868437227405312
  %cmp.i.i.i.i.i = icmp eq i64 %and.i.i.i.i.i, 0
  %and.i2.i.i.i.i = and i64 %a, 9223372036854775807
  %cmp.i3.i.i.i.i = icmp ne i64 %and.i2.i.i.i.i, 0
  %5 = and i1 %cmp.i.i.i.i.i, %cmp.i3.i.i.i.i
  %.lobit.i.i.i = and i64 %a, -9223372036854775808
  %ua.sroa.0.0.i = select i1 %5, i64 %.lobit.i.i.i, i64 %a
  %and.i.i.i3.i.i = and i64 %b, 9218868437227405312
  %cmp.i.i.i4.i.i = icmp eq i64 %and.i.i.i3.i.i, 0
  %and.i2.i.i5.i.i = and i64 %b, 9223372036854775807
  %cmp.i3.i.i6.i.i = icmp ne i64 %and.i2.i.i5.i.i, 0
  %6 = and i1 %cmp.i.i.i4.i.i, %cmp.i3.i.i6.i.i
  %.lobit.i8.i.i = and i64 %b, -9223372036854775808
  %ub.sroa.0.0.ph.i = select i1 %6, i64 %.lobit.i8.i.i, i64 %b
  %7 = or i1 %5, %6
  br i1 %7, label %8, label %float64_input_flush2.exit.i

8:                                                ; preds = %if.end.i.i
  %or1.i.i.i.i = or i16 %0, 32
  store i16 %or1.i.i.i.i, ptr %s, align 2
  br label %float64_input_flush2.exit.i

float64_input_flush2.exit.i:                      ; preds = %8, %if.end.i.i, %if.end.i
  %9 = phi i16 [ %0, %if.end.i ], [ %0, %if.end.i.i ], [ %or1.i.i.i.i, %8 ]
  %ua.sroa.0.1.i = phi i64 [ %a, %if.end.i ], [ %ua.sroa.0.0.i, %if.end.i.i ], [ %ua.sroa.0.0.i, %8 ]
  %ub.sroa.0.0.i = phi i64 [ %b, %if.end.i ], [ %ub.sroa.0.0.ph.i, %if.end.i.i ], [ %ub.sroa.0.0.ph.i, %8 ]
  %10 = bitcast i64 %ua.sroa.0.1.i to double
  %or.cond.i.i = fcmp ueq double %10, 0.000000e+00
  br i1 %or.cond.i.i, label %lor.lhs.false.i.i, label %fpclassify_not_nan.i.i

lor.lhs.false.i.i:                                ; preds = %float64_input_flush2.exit.i
  %iszero.i.i = fcmp oeq double %10, 0.000000e+00
  br i1 %iszero.i.i, label %land.rhs.i6.i, label %soft39.i

fpclassify_not_nan.i.i:                           ; preds = %float64_input_flush2.exit.i
  %or.cond13.i.i = tail call i1 @llvm.is.fpclass.f64(double %10, i32 267)
  br i1 %or.cond13.i.i, label %land.rhs.i6.i, label %soft39.i

land.rhs.i6.i:                                    ; preds = %fpclassify_not_nan.i.i, %lor.lhs.false.i.i
  %11 = bitcast i64 %ub.sroa.0.0.i to double
  %iszero15.i.i = fcmp oeq double %11, 0.000000e+00
  %or.cond10.i.i = fcmp ueq double %11, 0.000000e+00
  br i1 %or.cond10.i.i, label %f64_is_zon2.exit.i, label %fpclassify_not_nan18.i.i

fpclassify_not_nan18.i.i:                         ; preds = %land.rhs.i6.i
  %or.cond14.i.i = tail call i1 @llvm.is.fpclass.f64(double %11, i32 267)
  %brmerge.i = or i1 %or.cond14.i.i, %iszero15.i.i
  br i1 %brmerge.i, label %if.end14.i, label %soft39.i

f64_is_zon2.exit.i:                               ; preds = %land.rhs.i6.i
  br i1 %iszero15.i.i, label %if.end14.i, label %soft39.i

if.end14.i:                                       ; preds = %f64_is_zon2.exit.i, %fpclassify_not_nan18.i.i
  %sub.i = fsub double %10, %11
  %12 = bitcast double %sub.i to i64
  %13 = tail call double @llvm.fabs.f64(double %sub.i) #17
  %isinf.i.i = fcmp oeq double %13, 0x7FF0000000000000
  br i1 %isinf.i.i, label %if.then24.i, label %if.else.i

if.then24.i:                                      ; preds = %if.end14.i
  %or1.i.i = or i16 %9, 4
  store i16 %or1.i.i, ptr %s, align 2
  br label %float64_gen2.exit

if.else.i:                                        ; preds = %if.end14.i
  %cmp.i = fcmp ugt double %13, 0x10000000000000
  br i1 %cmp.i, label %float64_gen2.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.else.i
  %14 = or i64 %ub.sroa.0.0.i, %ua.sroa.0.1.i
  %15 = and i64 %14, 9223372036854775807
  %lnot.i.not.i = icmp eq i64 %15, 0
  br i1 %lnot.i.not.i, label %float64_gen2.exit, label %soft39.i

soft39.i:                                         ; preds = %land.lhs.true.i, %f64_is_zon2.exit.i, %fpclassify_not_nan18.i.i, %fpclassify_not_nan.i.i, %lor.lhs.false.i.i, %can_use_fpu.exit.i, %entry
  %ua.sroa.0.2.i = phi i64 [ %ua.sroa.0.1.i, %land.lhs.true.i ], [ %ua.sroa.0.1.i, %f64_is_zon2.exit.i ], [ %a, %can_use_fpu.exit.i ], [ %a, %entry ], [ %ua.sroa.0.1.i, %fpclassify_not_nan.i.i ], [ %ua.sroa.0.1.i, %lor.lhs.false.i.i ], [ %ua.sroa.0.1.i, %fpclassify_not_nan18.i.i ]
  %ub.sroa.0.1.i = phi i64 [ %ub.sroa.0.0.i, %land.lhs.true.i ], [ %ub.sroa.0.0.i, %f64_is_zon2.exit.i ], [ %b, %can_use_fpu.exit.i ], [ %b, %entry ], [ %ub.sroa.0.0.i, %fpclassify_not_nan.i.i ], [ %ub.sroa.0.0.i, %lor.lhs.false.i.i ], [ %ub.sroa.0.0.i, %fpclassify_not_nan18.i.i ]
  %call.i = tail call fastcc i64 @soft_f64_addsub(i64 noundef %ua.sroa.0.2.i, i64 noundef %ub.sroa.0.1.i, ptr noundef nonnull %s, i1 noundef zeroext true)
  br label %float64_gen2.exit

float64_gen2.exit:                                ; preds = %if.then24.i, %if.else.i, %land.lhs.true.i, %soft39.i
  %retval.0.i = phi i64 [ %call.i, %soft39.i ], [ %12, %if.else.i ], [ %12, %land.lhs.true.i ], [ %12, %if.then24.i ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64r32_add(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @float64r32_addsub(i64 noundef %a, i64 noundef %b, ptr noundef %status, i1 noundef zeroext false)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i64 @float64r32_addsub(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %status, i1 noundef zeroext %subtract) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts64, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 %and.i9.i.i, ptr %pa.sroa.gep, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %pa.sroa.gep, align 8
  br label %float64_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %pa.sroa.gep, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float64_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %pa.sroa.gep, align 8
  br label %float64_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %pa.sroa.gep, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

float64_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %a.val.i40.i = phi i64 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i.i, %if.then33.i.i ], [ 0, %if.then47.i.i ], [ %shl.i31.i.i, %if.else49.i.i ]
  %5 = phi i32 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %add.i.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ 2047, %if.then47.i.i ], [ 2047, %if.else49.i.i ]
  %6 = phi i8 [ 1, %if.then8.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ], [ 3, %if.then47.i.i ], [ %conv53.i.i, %if.else49.i.i ]
  %f.lobit.i.i4 = lshr i64 %b, 63
  %frombool.i.i.i5 = trunc i64 %f.lobit.i.i4 to i8
  %shr.i8.i.i6 = lshr i64 %b, 52
  %7 = trunc i64 %shr.i8.i.i6 to i32
  %conv.i.i.i7 = and i32 %7, 2047
  %and.i9.i.i8 = and i64 %b, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i5, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i.i7, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  store i64 %and.i9.i.i8, ptr %pb.sroa.gep, align 8
  switch i32 %conv.i.i.i7, label %if.then33.i.i31 [
    i32 0, label %if.then.i.i19
    i32 2047, label %lor.lhs.false.i.i12
  ]

if.then.i.i19:                                    ; preds = %float64_unpack_canonical.exit
  %cmp.i.i.i20 = icmp eq i64 %and.i9.i.i8, 0
  br i1 %cmp.i.i.i20, label %if.then8.i.i30, label %if.else.i.i21

if.then8.i.i30:                                   ; preds = %if.then.i.i19
  store i8 1, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

if.else.i.i21:                                    ; preds = %if.then.i.i19
  %flush_inputs_to_zero.i.i22 = getelementptr inbounds i8, ptr %status, i64 6
  %8 = load i8, ptr %flush_inputs_to_zero.i.i22, align 2
  %9 = and i8 %8, 1
  %tobool9.not.i.i23 = icmp eq i8 %9, 0
  br i1 %tobool9.not.i.i23, label %frac64_normalize.exit.i.i26, label %if.then10.i.i24

if.then10.i.i24:                                  ; preds = %if.else.i.i21
  %10 = load i16, ptr %status, align 2
  %or1.i.i.i25 = or i16 %10, 32
  store i16 %or1.i.i.i25, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %pb.sroa.gep, align 8
  br label %float64_unpack_canonical.exit35

frac64_normalize.exit.i.i26:                      ; preds = %if.else.i.i21
  %11 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i8, i1 true), !range !5
  %cast.i.i.i.i27 = trunc i64 %11 to i32
  %shl.i.i.i28 = shl i64 %and.i9.i.i8, %11
  store i64 %shl.i.i.i28, ptr %pb.sroa.gep, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i29 = sub nuw nsw i32 -1011, %cast.i.i.i.i27
  store i32 %add.i.i29, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  br label %float64_unpack_canonical.exit35

lor.lhs.false.i.i12:                              ; preds = %float64_unpack_canonical.exit
  %cmp.i29.i.i13 = icmp eq i64 %and.i9.i.i8, 0
  br i1 %cmp.i29.i.i13, label %if.then47.i.i18, label %if.else49.i.i14

if.then33.i.i31:                                  ; preds = %float64_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i32 = add nsw i32 %conv.i.i.i7, -1023
  store i32 %sub37.i.i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %shl.i28.i.i33 = shl nuw nsw i64 %and.i9.i.i8, 11
  %or.i.i34 = or disjoint i64 %shl.i28.i.i33, -9223372036854775808
  store i64 %or.i.i34, ptr %pb.sroa.gep, align 8
  br label %float64_unpack_canonical.exit35

if.then47.i.i18:                                  ; preds = %lor.lhs.false.i.i12
  store i8 3, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

if.else49.i.i14:                                  ; preds = %lor.lhs.false.i.i12
  %shl.i31.i.i15 = shl nuw nsw i64 %and.i9.i.i8, 11
  store i64 %shl.i31.i.i15, ptr %pb.sroa.gep, align 8
  %tobool.not.i32.i.i16 = icmp ult i64 %and.i9.i.i8, 2251799813685248
  %conv53.i.i17 = select i1 %tobool.not.i32.i.i16, i8 5, i8 4
  store i8 %conv53.i.i17, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

float64_unpack_canonical.exit35:                  ; preds = %if.then8.i.i30, %if.then10.i.i24, %frac64_normalize.exit.i.i26, %if.then33.i.i31, %if.then47.i.i18, %if.else49.i.i14
  %b.val.i41.i = phi i64 [ 0, %if.then8.i.i30 ], [ 0, %if.then10.i.i24 ], [ %shl.i.i.i28, %frac64_normalize.exit.i.i26 ], [ %or.i.i34, %if.then33.i.i31 ], [ 0, %if.then47.i.i18 ], [ %shl.i31.i.i15, %if.else49.i.i14 ]
  %12 = phi i32 [ 0, %if.then8.i.i30 ], [ 0, %if.then10.i.i24 ], [ %add.i.i29, %frac64_normalize.exit.i.i26 ], [ %sub37.i.i32, %if.then33.i.i31 ], [ 2047, %if.then47.i.i18 ], [ 2047, %if.else49.i.i14 ]
  %13 = phi i8 [ 1, %if.then8.i.i30 ], [ 1, %if.then10.i.i24 ], [ 2, %frac64_normalize.exit.i.i26 ], [ 2, %if.then33.i.i31 ], [ 3, %if.then47.i.i18 ], [ %conv53.i.i17, %if.else49.i.i14 ]
  %14 = icmp slt i64 %b, 0
  %tobool3.i = xor i1 %14, %subtract
  %frombool4.i = zext i1 %tobool3.i to i8
  %conv5.i = zext nneg i8 %6 to i32
  %shl.i = shl nuw nsw i32 1, %conv5.i
  %conv7.i = zext nneg i8 %13 to i32
  %shl8.i = shl nuw nsw i32 1, %conv7.i
  %or.i = or i32 %shl8.i, %shl.i
  %15 = icmp sgt i64 %a, -1
  %cmp.not.i = xor i1 %15, %tobool3.i
  %trunc57 = trunc i32 %or.i to i8
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %float64_unpack_canonical.exit35
  switch i8 %trunc57, label %if.end31.i [
    i8 4, label %if.then20.i
    i8 2, label %if.then25.i
  ]

if.then20.i:                                      ; preds = %if.then.i
  %sub.i = sub nsw i32 %5, %12
  %cmp.i = icmp sgt i32 %sub.i, 0
  br i1 %cmp.i, label %if.then.i.i47, label %if.else.i43

if.then.i.i47:                                    ; preds = %if.then20.i
  %cmp2.i.i48 = icmp ult i32 %sub.i, 64
  br i1 %cmp2.i.i48, label %if.then10.i.i50, label %if.else.i.i49

if.then10.i.i50:                                  ; preds = %if.then.i.i47
  %sh_prom.i.i = zext nneg i32 %sub.i to i64
  %shr.i.i = lshr i64 %b.val.i41.i, %sh_prom.i.i
  %16 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %b.val.i41.i, i32 %sub.i, i64 0) #15, !srcloc !6
  %cmp11.i.i51 = icmp ne i64 %16, 0
  %conv13.i.i = zext i1 %cmp11.i.i51 to i64
  %or.i.i52 = or i64 %shr.i.i, %conv13.i.i
  br label %frac64_shrjam.exit.i

if.else.i.i49:                                    ; preds = %if.then.i.i47
  %cmp14.i.i = icmp ne i64 %b.val.i41.i, 0
  %conv16.i.i = zext i1 %cmp14.i.i to i64
  br label %frac64_shrjam.exit.i

frac64_shrjam.exit.i:                             ; preds = %if.else.i.i49, %if.then10.i.i50
  %a0.0.i.i = phi i64 [ %or.i.i52, %if.then10.i.i50 ], [ %conv16.i.i, %if.else.i.i49 ]
  store i64 %a0.0.i.i, ptr %pb.sroa.gep, align 8
  %17 = sub i64 %a.val.i40.i, %a0.0.i.i
  store i64 %17, ptr %pa.sroa.gep, align 8
  br label %if.end19.i

if.else.i43:                                      ; preds = %if.then20.i
  %cmp2.i = icmp slt i32 %sub.i, 0
  br i1 %cmp2.i, label %if.then.i29.i, label %if.else9.i

if.then.i29.i:                                    ; preds = %if.else.i43
  store i32 %12, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %frombool.i = xor i8 %frombool.i.i.i, 1
  store i8 %frombool.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %cmp2.i30.i = icmp ugt i32 %sub.i, -64
  br i1 %cmp2.i30.i, label %if.then10.i36.i, label %if.else.i31.i

if.then10.i36.i:                                  ; preds = %if.then.i29.i
  %sub7.i = sub nsw i32 0, %sub.i
  %sh_prom.i37.i = zext nneg i32 %sub7.i to i64
  %shr.i38.i = lshr i64 %a.val.i40.i, %sh_prom.i37.i
  %18 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.val.i40.i, i32 %sub7.i, i64 0) #15, !srcloc !6
  %cmp11.i39.i = icmp ne i64 %18, 0
  %conv13.i40.i = zext i1 %cmp11.i39.i to i64
  %or.i41.i = or i64 %shr.i38.i, %conv13.i40.i
  br label %frac64_shrjam.exit42.i

if.else.i31.i:                                    ; preds = %if.then.i29.i
  %cmp14.i32.i = icmp ne i64 %a.val.i40.i, 0
  %conv16.i33.i = zext i1 %cmp14.i32.i to i64
  br label %frac64_shrjam.exit42.i

frac64_shrjam.exit42.i:                           ; preds = %if.else.i31.i, %if.then10.i36.i
  %a0.0.i35.i = phi i64 [ %or.i41.i, %if.then10.i36.i ], [ %conv16.i33.i, %if.else.i31.i ]
  %19 = sub i64 %b.val.i41.i, %a0.0.i35.i
  store i64 %19, ptr %pa.sroa.gep, align 8
  br label %if.end19.i

if.else9.i:                                       ; preds = %if.else.i43
  %20 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a.val.i40.i, i64 %b.val.i41.i)
  %21 = extractvalue { i64, i1 } %20, 1
  %22 = extractvalue { i64, i1 } %20, 0
  store i64 %22, ptr %pa.sroa.gep, align 8
  br i1 %21, label %if.then11.i, label %if.end19.i

if.then11.i:                                      ; preds = %if.else9.i
  %sub.i.i45 = sub i64 0, %22
  store i64 %sub.i.i45, ptr %pa.sroa.gep, align 8
  %frombool17.i = xor i8 %frombool.i.i.i, 1
  store i8 %frombool17.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %if.end19.i

if.end19.i:                                       ; preds = %if.then11.i, %if.else9.i, %frac64_shrjam.exit42.i, %frac64_shrjam.exit.i
  %23 = phi i32 [ %12, %frac64_shrjam.exit42.i ], [ %5, %if.then11.i ], [ %5, %if.else9.i ], [ %5, %frac64_shrjam.exit.i ]
  %24 = phi i64 [ %19, %frac64_shrjam.exit42.i ], [ %sub.i.i45, %if.then11.i ], [ %22, %if.else9.i ], [ %17, %frac64_shrjam.exit.i ]
  %tobool.not.i.i44.not = icmp eq i64 %24, 0
  br i1 %tobool.not.i.i44.not, label %parts64_sub_normal.exit, label %parts64_sub_normal.exit.thread

parts64_sub_normal.exit.thread:                   ; preds = %if.end19.i
  %25 = tail call i64 @llvm.ctlz.i64(i64 %24, i1 true), !range !5
  %cast.i.i.i = trunc i64 %25 to i32
  %shl.i.i = shl i64 %24, %25
  store i64 %shl.i.i, ptr %pa.sroa.gep, align 8
  %sub28.i = sub nsw i32 %23, %cast.i.i.i
  store i32 %sub28.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_addsub.exit

parts64_sub_normal.exit:                          ; preds = %if.end19.i
  store i8 1, ptr %pa, align 8
  br label %if.then25.i

if.then25.i:                                      ; preds = %parts64_sub_normal.exit, %if.then.i
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %26 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp27.i = icmp eq i8 %26, 1
  %frombool30.i = zext i1 %cmp27.i to i8
  store i8 %frombool30.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %parts64_addsub.exit

if.end31.i:                                       ; preds = %if.then.i
  %and.i = and i32 %or.i, 48
  %tobool32.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool32.not.i, label %if.end40.i, label %p_nan.i

if.end40.i:                                       ; preds = %if.end31.i
  %and41.i = and i32 %or.i, 8
  %tobool42.not.i = icmp eq i32 %and41.i, 0
  br i1 %tobool42.not.i, label %if.end86.i, label %if.then43.i

if.then43.i:                                      ; preds = %if.end40.i
  %cmp46.not.i = icmp eq i8 %6, 3
  br i1 %cmp46.not.i, label %if.end49.i, label %return_b.i

if.end49.i:                                       ; preds = %if.then43.i
  %cmp52.not.i = icmp eq i8 %13, 3
  br i1 %cmp52.not.i, label %if.end55.i, label %parts64_addsub.exit

if.end55.i:                                       ; preds = %if.end49.i
  %27 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %27, 129
  store i16 %or1.i.i, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep, align 8
  br label %parts64_addsub.exit

if.else.i:                                        ; preds = %float64_unpack_canonical.exit35
  switch i8 %trunc57, label %if.end70.i [
    i8 4, label %if.then65.i
    i8 2, label %parts64_addsub.exit
  ]

if.then65.i:                                      ; preds = %if.else.i
  %sub.i.i = sub nsw i32 %5, %12
  %cmp.i.i = icmp sgt i32 %sub.i.i, 0
  br i1 %cmp.i.i, label %if.then.i.i.i, label %if.else.i.i39

if.then.i.i.i:                                    ; preds = %if.then65.i
  %cmp2.i.i.i = icmp ult i32 %sub.i.i, 64
  br i1 %cmp2.i.i.i, label %if.then10.i.i.i, label %if.else.i.i.i

if.then10.i.i.i:                                  ; preds = %if.then.i.i.i
  %sh_prom.i.i.i = zext nneg i32 %sub.i.i to i64
  %shr.i.i.i = lshr i64 %b.val.i41.i, %sh_prom.i.i.i
  %28 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %b.val.i41.i, i32 %sub.i.i, i64 0) #15, !srcloc !6
  %cmp11.i.i.i = icmp ne i64 %28, 0
  %conv13.i.i.i = zext i1 %cmp11.i.i.i to i64
  %or.i.i.i = or i64 %shr.i.i.i, %conv13.i.i.i
  br label %frac64_shrjam.exit.i.i

if.else.i.i.i:                                    ; preds = %if.then.i.i.i
  %cmp14.i.i.i = icmp ne i64 %b.val.i41.i, 0
  %conv16.i.i.i = zext i1 %cmp14.i.i.i to i64
  br label %frac64_shrjam.exit.i.i

frac64_shrjam.exit.i.i:                           ; preds = %if.else.i.i.i, %if.then10.i.i.i
  %a0.0.i.i.i = phi i64 [ %or.i.i.i, %if.then10.i.i.i ], [ %conv16.i.i.i, %if.else.i.i.i ]
  store i64 %a0.0.i.i.i, ptr %pb.sroa.gep, align 8
  br label %if.end7.i.i

if.else.i.i39:                                    ; preds = %if.then65.i
  %cmp2.i.i = icmp slt i32 %sub.i.i, 0
  br i1 %cmp2.i.i, label %if.then.i15.i.i, label %if.end7.i.i

if.then.i15.i.i:                                  ; preds = %if.else.i.i39
  %cmp2.i16.i.i = icmp ugt i32 %sub.i.i, -64
  br i1 %cmp2.i16.i.i, label %if.then10.i22.i.i, label %if.else.i17.i.i

if.then10.i22.i.i:                                ; preds = %if.then.i15.i.i
  %sub4.i.i = sub nsw i32 0, %sub.i.i
  %sh_prom.i23.i.i = zext nneg i32 %sub4.i.i to i64
  %shr.i24.i.i = lshr i64 %a.val.i40.i, %sh_prom.i23.i.i
  %29 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.val.i40.i, i32 %sub4.i.i, i64 0) #15, !srcloc !6
  %cmp11.i25.i.i = icmp ne i64 %29, 0
  %conv13.i26.i.i = zext i1 %cmp11.i25.i.i to i64
  %or.i27.i.i = or i64 %shr.i24.i.i, %conv13.i26.i.i
  br label %frac64_shrjam.exit28.i.i

if.else.i17.i.i:                                  ; preds = %if.then.i15.i.i
  %cmp14.i18.i.i = icmp ne i64 %a.val.i40.i, 0
  %conv16.i19.i.i = zext i1 %cmp14.i18.i.i to i64
  br label %frac64_shrjam.exit28.i.i

frac64_shrjam.exit28.i.i:                         ; preds = %if.else.i17.i.i, %if.then10.i22.i.i
  %a0.0.i21.i.i = phi i64 [ %or.i27.i.i, %if.then10.i22.i.i ], [ %conv16.i19.i.i, %if.else.i17.i.i ]
  store i32 %12, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %if.end7.i.i

if.end7.i.i:                                      ; preds = %frac64_shrjam.exit28.i.i, %if.else.i.i39, %frac64_shrjam.exit.i.i
  %30 = phi i32 [ %12, %frac64_shrjam.exit28.i.i ], [ %5, %if.else.i.i39 ], [ %5, %frac64_shrjam.exit.i.i ]
  %b.val.i.i = phi i64 [ %b.val.i41.i, %frac64_shrjam.exit28.i.i ], [ %b.val.i41.i, %if.else.i.i39 ], [ %a0.0.i.i.i, %frac64_shrjam.exit.i.i ]
  %a.val.i.i = phi i64 [ %a0.0.i21.i.i, %frac64_shrjam.exit28.i.i ], [ %a.val.i40.i, %if.else.i.i39 ], [ %a.val.i40.i, %frac64_shrjam.exit.i.i ]
  %31 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %a.val.i.i, i64 %b.val.i.i)
  %32 = extractvalue { i64, i1 } %31, 1
  %33 = extractvalue { i64, i1 } %31, 0
  store i64 %33, ptr %pa.sroa.gep, align 8
  br i1 %32, label %if.then8.i.i40, label %parts64_addsub.exit

if.then8.i.i40:                                   ; preds = %if.end7.i.i
  %shr.i31.i.i = lshr i64 %33, 1
  %34 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %33, i32 1, i64 0) #15, !srcloc !6
  %cmp11.i32.i.i = icmp ne i64 %34, 0
  %conv13.i33.i.i = zext i1 %cmp11.i32.i.i to i64
  %or.i34.i.i = or i64 %shr.i31.i.i, %conv13.i33.i.i
  %or.i.i41 = or disjoint i64 %or.i34.i.i, -9223372036854775808
  store i64 %or.i.i41, ptr %pa.sroa.gep, align 8
  %add.i.i42 = add nsw i32 %30, 1
  store i32 %add.i.i42, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_addsub.exit

if.end70.i:                                       ; preds = %if.else.i
  %and71.i = and i32 %or.i, 48
  %tobool72.not.i = icmp eq i32 %and71.i, 0
  br i1 %tobool72.not.i, label %if.end80.i, label %p_nan.i

if.end80.i:                                       ; preds = %if.end70.i
  %and81.i = and i32 %or.i, 8
  %tobool82.not.i = icmp eq i32 %and81.i, 0
  br i1 %tobool82.not.i, label %if.end86.i, label %if.then83.i

if.then83.i:                                      ; preds = %if.end80.i
  store i8 3, ptr %pa, align 8
  br label %parts64_addsub.exit

if.end86.i:                                       ; preds = %if.end80.i, %if.end40.i
  %cmp89.i = icmp eq i8 %13, 1
  br i1 %cmp89.i, label %do.body.i, label %do.body100.i

do.body.i:                                        ; preds = %if.end86.i
  %cmp94.i = icmp eq i8 %6, 2
  br i1 %cmp94.i, label %parts64_addsub.exit, label %if.else97.i

if.else97.i:                                      ; preds = %do.body.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 401, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.4) #16
  unreachable

do.body100.i:                                     ; preds = %if.end86.i
  %cmp103.i = icmp eq i8 %6, 1
  br i1 %cmp103.i, label %do.body109.i, label %if.else106.i

if.else106.i:                                     ; preds = %do.body100.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 405, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.5) #16
  unreachable

do.body109.i:                                     ; preds = %do.body100.i
  %cmp112.i = icmp eq i8 %13, 2
  br i1 %cmp112.i, label %return_b.i, label %if.else115.i

if.else115.i:                                     ; preds = %do.body109.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 406, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.6) #16
  unreachable

return_b.i:                                       ; preds = %do.body109.i, %if.then43.i
  store i8 %frombool4.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9, align 1
  br label %parts64_addsub.exit

p_nan.i:                                          ; preds = %if.end70.i, %if.end31.i
  %cmp.i.i.i36 = icmp eq i8 %6, 5
  %cmp.i17.i.i = icmp eq i8 %13, 5
  %or.cond.i = or i1 %cmp.i.i.i36, %cmp.i17.i.i
  br i1 %or.cond.i, label %if.then.i.i37, label %if.end.i.i

if.then.i.i37:                                    ; preds = %p_nan.i
  %35 = load i16, ptr %status, align 2
  %or1.i.i.i38 = or i16 %35, 8193
  store i16 %or1.i.i.i38, ptr %status, align 2
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i.i37, %p_nan.i
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %36 = load i8, ptr %default_nan_mode.i.i, align 1
  %37 = and i8 %36, 1
  %tobool.not.i.i = icmp eq i8 %37, 0
  br i1 %tobool.not.i.i, label %if.else.i39.i, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep, align 8
  br label %parts64_addsub.exit

if.else.i39.i:                                    ; preds = %if.end.i.i
  %cmp.i18.i.i = icmp eq i64 %a.val.i40.i, %b.val.i41.i
  %cmp1.i.i.i = icmp ult i64 %a.val.i40.i, %b.val.i41.i
  %cmp11.i.i = icmp uge i64 %f.lobit.i.i, %f.lobit.i.i4
  %spec.select = select i1 %cmp.i18.i.i, i1 %cmp11.i.i, i1 %cmp1.i.i.i
  %spec.select.fr = freeze i1 %spec.select
  switch i8 %6, label %38 [
    i8 5, label %pickNaN.exit.i.i
    i8 4, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.else.i39.i
  br i1 %cmp.i17.i.i, label %parts64_addsub.exit, label %lor.lhs.false.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %if.then6.i.i.i
  %cmp.i11.i.i.i = icmp eq i8 %13, 4
  %spec.select.i.i.i = and i1 %cmp.i11.i.i.i, %spec.select.fr
  %spec.select.i = select i1 %spec.select.i.i.i, ptr %pb, ptr %pa
  br label %parts64_addsub.exit

pickNaN.exit.i.i:                                 ; preds = %if.else.i39.i
  %cmp.i8.i.i.i = icmp eq i8 %13, 4
  %spec.select20.i.i = select i1 %cmp.i17.i.i, i1 %spec.select.fr, i1 %cmp.i8.i.i.i
  %cond.fr.i.i.not = xor i1 %spec.select20.i.i, true
  %brmerge = or i1 %cmp.i17.i.i, %cond.fr.i.i.not
  br i1 %brmerge, label %pickNaN.exit.i.i.if.then24.i.i_crit_edge, label %parts64_addsub.exit

pickNaN.exit.i.i.if.then24.i.i_crit_edge:         ; preds = %pickNaN.exit.i.i
  %pa.sroa.gep.mux = select i1 %spec.select20.i.i, ptr %pb.sroa.gep, ptr %pa.sroa.gep
  %pa.mux = select i1 %spec.select20.i.i, ptr %pb, ptr %pa
  %.pre = load i64, ptr %pa.sroa.gep.mux, align 8
  br label %if.then24.i.i

38:                                               ; preds = %if.else.i39.i
  br i1 %cmp.i17.i.i, label %if.then24.i.i, label %parts64_addsub.exit

if.then24.i.i:                                    ; preds = %pickNaN.exit.i.i.if.then24.i.i_crit_edge, %38
  %39 = phi i64 [ %b.val.i41.i, %38 ], [ %.pre, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i47.i = phi ptr [ %pb, %38 ], [ %pa.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i47.i.sroa.phi = phi ptr [ %pb.sroa.gep, %38 ], [ %pa.sroa.gep.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %or4.i.i.i.i = or i64 %39, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.ph.i47.i.sroa.phi, align 8
  store i8 4, ptr %.ph.i47.i, align 8
  br label %parts64_addsub.exit

parts64_addsub.exit:                              ; preds = %pickNaN.exit.i.i, %parts64_sub_normal.exit.thread, %if.then25.i, %if.end49.i, %if.end55.i, %if.else.i, %if.end7.i.i, %if.then8.i.i40, %if.then83.i, %do.body.i, %return_b.i, %if.then3.i.i, %if.then6.i.i.i, %lor.lhs.false.i.i.i, %38, %if.then24.i.i
  %retval.0.i = phi ptr [ %pa, %if.then25.i ], [ %pb, %return_b.i ], [ %pa, %if.end55.i ], [ %pa, %if.then83.i ], [ %pa, %if.end49.i ], [ %pa, %if.else.i ], [ %pa, %do.body.i ], [ %pa, %if.end7.i.i ], [ %pa, %if.then8.i.i40 ], [ %pa, %if.then3.i.i ], [ %.ph.i47.i, %if.then24.i.i ], [ %pb, %38 ], [ %pa, %if.then6.i.i.i ], [ %spec.select.i, %lor.lhs.false.i.i.i ], [ %pa, %parts64_sub_normal.exit.thread ], [ %pb, %pickNaN.exit.i.i ]
  %call1 = call fastcc i64 @float64r32_round_pack_canonical(ptr noundef nonnull %retval.0.i, ptr noundef %status)
  ret i64 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64r32_sub(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @float64r32_addsub(i64 noundef %a, i64 noundef %b, ptr noundef %status, i1 noundef zeroext true)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_add(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @bfloat16_addsub(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %status, i1 noundef zeroext false)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc zeroext i16 @bfloat16_addsub(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %status, i1 noundef zeroext %subtract) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts64, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %f.lobit.i = lshr i16 %a, 15
  %frombool.i.i = trunc i16 %f.lobit.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %0, 255
  %conv.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 127
  %and.i10.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i10.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %trunc = trunc i16 %0 to i8
  switch i8 %trunc, label %if.then33.i [
    i8 0, label %if.then.i47
    i8 -1, label %lor.lhs.false.i
  ]

if.then.i47:                                      ; preds = %entry
  %cmp.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i, label %if.then8.i, label %if.else.i48

if.then8.i:                                       ; preds = %if.then.i47
  store i8 1, ptr %pa, align 8
  br label %parts64_canonicalize.exit

if.else.i48:                                      ; preds = %if.then.i47
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i, label %frac64_normalize.exit.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.else.i48
  %5 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %5, 32
  store i16 %or1.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_canonicalize.exit

frac64_normalize.exit.i:                          ; preds = %if.else.i48
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i, i1 true), !range !5
  %cast.i.i.i = trunc i64 %6 to i32
  %shl.i.i = shl i64 %and.i10.i, %6
  store i64 %shl.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i = sub nuw nsw i32 -70, %cast.i.i.i
  store i32 %add.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_canonicalize.exit

lor.lhs.false.i:                                  ; preds = %entry
  %cmp.i29.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i, label %if.then47.i, label %if.else49.i

if.then33.i:                                      ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i = add nsw i32 %conv.i.i, -127
  store i32 %sub37.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %shl.i28.i = shl nuw nsw i64 %and.i10.i, 56
  %or.i46 = or disjoint i64 %shl.i28.i, -9223372036854775808
  store i64 %or.i46, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_canonicalize.exit

if.then47.i:                                      ; preds = %lor.lhs.false.i
  store i8 3, ptr %pa, align 8
  br label %parts64_canonicalize.exit

if.else49.i:                                      ; preds = %lor.lhs.false.i
  %shl.i31.i = shl nuw nsw i64 %and.i10.i, 56
  store i64 %shl.i31.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %tobool.not.i32.i = icmp ult i16 %2, 64
  %conv53.i = select i1 %tobool.not.i32.i, i8 5, i8 4
  store i8 %conv53.i, ptr %pa, align 8
  br label %parts64_canonicalize.exit

parts64_canonicalize.exit:                        ; preds = %if.then8.i, %if.then10.i, %frac64_normalize.exit.i, %if.then33.i, %if.then47.i, %if.else49.i
  %a.val.i119 = phi i64 [ 0, %if.then8.i ], [ 0, %if.then10.i ], [ %shl.i.i, %frac64_normalize.exit.i ], [ %or.i46, %if.then33.i ], [ 0, %if.then47.i ], [ %shl.i31.i, %if.else49.i ]
  %7 = phi i32 [ %conv.i.i, %if.then8.i ], [ %conv.i.i, %if.then10.i ], [ %add.i, %frac64_normalize.exit.i ], [ %sub37.i, %if.then33.i ], [ %conv.i.i, %if.then47.i ], [ %conv.i.i, %if.else49.i ]
  %8 = phi i8 [ 1, %if.then8.i ], [ 1, %if.then10.i ], [ 2, %frac64_normalize.exit.i ], [ 2, %if.then33.i ], [ 3, %if.then47.i ], [ %conv53.i, %if.else49.i ]
  %f.lobit.i49 = lshr i16 %b, 15
  %frombool.i.i50 = trunc i16 %f.lobit.i49 to i8
  %9 = lshr i16 %b, 7
  %10 = and i16 %9, 255
  %conv.i.i51 = zext nneg i16 %10 to i32
  %11 = and i16 %b, 127
  %and.i10.i52 = zext nneg i16 %11 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i53 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i50, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i53, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i54 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i51, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i54, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i55 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i10.i52, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i55, align 8
  %trunc129 = trunc i16 %9 to i8
  switch i8 %trunc129, label %if.then33.i68 [
    i8 0, label %if.then.i72
    i8 -1, label %lor.lhs.false.i60
  ]

if.then.i72:                                      ; preds = %parts64_canonicalize.exit
  %cmp.i.i74 = icmp eq i16 %11, 0
  br i1 %cmp.i.i74, label %if.then8.i85, label %if.else.i75

if.then8.i85:                                     ; preds = %if.then.i72
  store i8 1, ptr %pb, align 8
  br label %parts64_canonicalize.exit86

if.else.i75:                                      ; preds = %if.then.i72
  %flush_inputs_to_zero.i76 = getelementptr inbounds i8, ptr %status, i64 6
  %12 = load i8, ptr %flush_inputs_to_zero.i76, align 2
  %13 = and i8 %12, 1
  %tobool9.not.i77 = icmp eq i8 %13, 0
  br i1 %tobool9.not.i77, label %frac64_normalize.exit.i80, label %if.then10.i78

if.then10.i78:                                    ; preds = %if.else.i75
  %14 = load i16, ptr %status, align 2
  %or1.i.i79 = or i16 %14, 32
  store i16 %or1.i.i79, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i55, align 8
  br label %parts64_canonicalize.exit86

frac64_normalize.exit.i80:                        ; preds = %if.else.i75
  %15 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i52, i1 true), !range !5
  %cast.i.i.i81 = trunc i64 %15 to i32
  %shl.i.i82 = shl i64 %and.i10.i52, %15
  store i64 %shl.i.i82, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i55, align 8
  store i8 2, ptr %pb, align 8
  %add.i84 = sub nuw nsw i32 -70, %cast.i.i.i81
  store i32 %add.i84, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i54, align 4
  br label %parts64_canonicalize.exit86

lor.lhs.false.i60:                                ; preds = %parts64_canonicalize.exit
  %cmp.i29.i62 = icmp eq i16 %11, 0
  br i1 %cmp.i29.i62, label %if.then47.i67, label %if.else49.i63

if.then33.i68:                                    ; preds = %parts64_canonicalize.exit
  store i8 2, ptr %pb, align 8
  %sub37.i69 = add nsw i32 %conv.i.i51, -127
  store i32 %sub37.i69, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i54, align 4
  %shl.i28.i70 = shl nuw nsw i64 %and.i10.i52, 56
  %or.i71 = or disjoint i64 %shl.i28.i70, -9223372036854775808
  store i64 %or.i71, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i55, align 8
  br label %parts64_canonicalize.exit86

if.then47.i67:                                    ; preds = %lor.lhs.false.i60
  store i8 3, ptr %pb, align 8
  br label %parts64_canonicalize.exit86

if.else49.i63:                                    ; preds = %lor.lhs.false.i60
  %shl.i31.i64 = shl nuw nsw i64 %and.i10.i52, 56
  store i64 %shl.i31.i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i55, align 8
  %tobool.not.i32.i65 = icmp ult i16 %11, 64
  %conv53.i66 = select i1 %tobool.not.i32.i65, i8 5, i8 4
  store i8 %conv53.i66, ptr %pb, align 8
  br label %parts64_canonicalize.exit86

parts64_canonicalize.exit86:                      ; preds = %if.then8.i85, %if.then10.i78, %frac64_normalize.exit.i80, %if.then33.i68, %if.then47.i67, %if.else49.i63
  %b.val.i120 = phi i64 [ 0, %if.then8.i85 ], [ 0, %if.then10.i78 ], [ %shl.i.i82, %frac64_normalize.exit.i80 ], [ %or.i71, %if.then33.i68 ], [ 0, %if.then47.i67 ], [ %shl.i31.i64, %if.else49.i63 ]
  %16 = phi i32 [ %conv.i.i51, %if.then8.i85 ], [ %conv.i.i51, %if.then10.i78 ], [ %add.i84, %frac64_normalize.exit.i80 ], [ %sub37.i69, %if.then33.i68 ], [ %conv.i.i51, %if.then47.i67 ], [ %conv.i.i51, %if.else49.i63 ]
  %.pr.i.pre = phi i8 [ 1, %if.then8.i85 ], [ 1, %if.then10.i78 ], [ 2, %frac64_normalize.exit.i80 ], [ 2, %if.then33.i68 ], [ 3, %if.then47.i67 ], [ %conv53.i66, %if.else49.i63 ]
  %17 = icmp slt i16 %b, 0
  %tobool3.i = xor i1 %17, %subtract
  %frombool4.i = zext i1 %tobool3.i to i8
  %conv5.i = zext nneg i8 %8 to i32
  %shl.i = shl nuw nsw i32 1, %conv5.i
  %conv7.i = zext nneg i8 %.pr.i.pre to i32
  %shl8.i = shl nuw nsw i32 1, %conv7.i
  %or.i = or i32 %shl8.i, %shl.i
  %18 = icmp sgt i16 %a, -1
  %cmp.i.not = xor i1 %18, %tobool3.i
  %trunc136 = trunc i32 %or.i to i8
  br i1 %cmp.i.not, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %parts64_canonicalize.exit86
  switch i8 %trunc136, label %if.end31.i [
    i8 4, label %if.then20.i
    i8 2, label %if.then25.i
  ]

if.then20.i:                                      ; preds = %if.then.i
  %sub.i = sub nsw i32 %7, %16
  %cmp.i88 = icmp sgt i32 %sub.i, 0
  br i1 %cmp.i88, label %if.then.i.i, label %if.else.i89

if.then.i.i:                                      ; preds = %if.then20.i
  %cmp2.i.i = icmp ult i32 %sub.i, 64
  br i1 %cmp2.i.i, label %if.then10.i.i, label %if.else.i.i

if.then10.i.i:                                    ; preds = %if.then.i.i
  %sh_prom.i.i = zext nneg i32 %sub.i to i64
  %shr.i.i = lshr i64 %b.val.i120, %sh_prom.i.i
  %19 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %b.val.i120, i32 %sub.i, i64 0) #15, !srcloc !6
  %cmp11.i.i = icmp ne i64 %19, 0
  %conv13.i.i = zext i1 %cmp11.i.i to i64
  %or.i.i = or i64 %shr.i.i, %conv13.i.i
  br label %frac64_shrjam.exit.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %cmp14.i.i = icmp ne i64 %b.val.i120, 0
  %conv16.i.i = zext i1 %cmp14.i.i to i64
  br label %frac64_shrjam.exit.i

frac64_shrjam.exit.i:                             ; preds = %if.else.i.i, %if.then10.i.i
  %a0.0.i.i = phi i64 [ %or.i.i, %if.then10.i.i ], [ %conv16.i.i, %if.else.i.i ]
  store i64 %a0.0.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i55, align 8
  %20 = sub i64 %a.val.i119, %a0.0.i.i
  store i64 %20, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %if.end19.i

if.else.i89:                                      ; preds = %if.then20.i
  %cmp2.i = icmp slt i32 %sub.i, 0
  br i1 %cmp2.i, label %if.then.i29.i, label %if.else9.i

if.then.i29.i:                                    ; preds = %if.else.i89
  store i32 %16, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %frombool.i = xor i8 %frombool.i.i, 1
  store i8 %frombool.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  %cmp2.i30.i = icmp ugt i32 %sub.i, -64
  br i1 %cmp2.i30.i, label %if.then10.i36.i, label %if.else.i31.i

if.then10.i36.i:                                  ; preds = %if.then.i29.i
  %sub7.i = sub nsw i32 0, %sub.i
  %sh_prom.i37.i = zext nneg i32 %sub7.i to i64
  %shr.i38.i = lshr i64 %a.val.i119, %sh_prom.i37.i
  %21 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.val.i119, i32 %sub7.i, i64 0) #15, !srcloc !6
  %cmp11.i39.i = icmp ne i64 %21, 0
  %conv13.i40.i = zext i1 %cmp11.i39.i to i64
  %or.i41.i = or i64 %shr.i38.i, %conv13.i40.i
  br label %frac64_shrjam.exit42.i

if.else.i31.i:                                    ; preds = %if.then.i29.i
  %cmp14.i32.i = icmp ne i64 %a.val.i119, 0
  %conv16.i33.i = zext i1 %cmp14.i32.i to i64
  br label %frac64_shrjam.exit42.i

frac64_shrjam.exit42.i:                           ; preds = %if.else.i31.i, %if.then10.i36.i
  %a0.0.i35.i = phi i64 [ %or.i41.i, %if.then10.i36.i ], [ %conv16.i33.i, %if.else.i31.i ]
  %22 = sub i64 %b.val.i120, %a0.0.i35.i
  store i64 %22, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %if.end19.i

if.else9.i:                                       ; preds = %if.else.i89
  %23 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a.val.i119, i64 %b.val.i120)
  %24 = extractvalue { i64, i1 } %23, 1
  %25 = extractvalue { i64, i1 } %23, 0
  store i64 %25, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br i1 %24, label %if.then11.i, label %if.end19.i

if.then11.i:                                      ; preds = %if.else9.i
  %sub.i.i = sub i64 0, %25
  store i64 %sub.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %frombool17.i = xor i8 %frombool.i.i, 1
  store i8 %frombool17.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  br label %if.end19.i

if.end19.i:                                       ; preds = %if.then11.i, %if.else9.i, %frac64_shrjam.exit42.i, %frac64_shrjam.exit.i
  %26 = phi i32 [ %16, %frac64_shrjam.exit42.i ], [ %7, %if.then11.i ], [ %7, %if.else9.i ], [ %7, %frac64_shrjam.exit.i ]
  %27 = phi i64 [ %22, %frac64_shrjam.exit42.i ], [ %sub.i.i, %if.then11.i ], [ %25, %if.else9.i ], [ %20, %frac64_shrjam.exit.i ]
  %tobool.not.i.i.not = icmp eq i64 %27, 0
  br i1 %tobool.not.i.i.not, label %if.end22.i.thread, label %parts64_sub_normal.exit.thread

parts64_sub_normal.exit.thread:                   ; preds = %if.end19.i
  %28 = tail call i64 @llvm.ctlz.i64(i64 %27, i1 true), !range !5
  %cast.i.i.i90 = trunc i64 %28 to i32
  %shl.i.i91 = shl i64 %27, %28
  store i64 %shl.i.i91, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %sub28.i = sub nsw i32 %26, %cast.i.i.i90
  store i32 %sub28.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_addsub.exit

if.end22.i.thread:                                ; preds = %if.end19.i
  store i8 1, ptr %pa, align 8
  br label %if.then25.i

if.then25.i:                                      ; preds = %if.then.i, %if.end22.i.thread
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %29 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp27.i = icmp eq i8 %29, 1
  %frombool30.i = zext i1 %cmp27.i to i8
  store i8 %frombool30.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  br label %parts64_addsub.exit

if.end31.i:                                       ; preds = %if.then.i
  %and.i = and i32 %or.i, 48
  %tobool32.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool32.i.not, label %if.end40.i, label %p_nan.i

if.end40.i:                                       ; preds = %if.end31.i
  %and41.i = and i32 %or.i, 8
  %tobool42.i.not = icmp eq i32 %and41.i, 0
  br i1 %tobool42.i.not, label %if.end86.i, label %if.then43.i

if.then43.i:                                      ; preds = %if.end40.i
  %cmp46.i.not = icmp eq i8 %8, 3
  br i1 %cmp46.i.not, label %if.end49.i, label %return_b.i

if.end49.i:                                       ; preds = %if.then43.i
  %cmp52.i.not = icmp eq i8 %.pr.i.pre, 3
  br i1 %cmp52.i.not, label %if.end55.i, label %parts64_addsub.exit

if.end55.i:                                       ; preds = %if.end49.i
  %30 = load i16, ptr %status, align 2
  %or1.i = or i16 %30, 129
  store i16 %or1.i, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_addsub.exit

if.else.i:                                        ; preds = %parts64_canonicalize.exit86
  switch i8 %trunc136, label %if.end70.i [
    i8 4, label %if.then65.i
    i8 2, label %parts64_addsub.exit
  ]

if.then65.i:                                      ; preds = %if.else.i
  %sub.i95 = sub nsw i32 %7, %16
  %cmp.i96 = icmp sgt i32 %sub.i95, 0
  br i1 %cmp.i96, label %if.then.i.i103, label %if.else.i97

if.then.i.i103:                                   ; preds = %if.then65.i
  %cmp2.i.i104 = icmp ult i32 %sub.i95, 64
  br i1 %cmp2.i.i104, label %if.then10.i.i110, label %if.else.i.i105

if.then10.i.i110:                                 ; preds = %if.then.i.i103
  %sh_prom.i.i111 = zext nneg i32 %sub.i95 to i64
  %shr.i.i112 = lshr i64 %b.val.i120, %sh_prom.i.i111
  %31 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %b.val.i120, i32 %sub.i95, i64 0) #15, !srcloc !6
  %cmp11.i.i113 = icmp ne i64 %31, 0
  %conv13.i.i114 = zext i1 %cmp11.i.i113 to i64
  %or.i.i115 = or i64 %shr.i.i112, %conv13.i.i114
  br label %frac64_shrjam.exit.i108

if.else.i.i105:                                   ; preds = %if.then.i.i103
  %cmp14.i.i106 = icmp ne i64 %b.val.i120, 0
  %conv16.i.i107 = zext i1 %cmp14.i.i106 to i64
  br label %frac64_shrjam.exit.i108

frac64_shrjam.exit.i108:                          ; preds = %if.else.i.i105, %if.then10.i.i110
  %a0.0.i.i109 = phi i64 [ %or.i.i115, %if.then10.i.i110 ], [ %conv16.i.i107, %if.else.i.i105 ]
  store i64 %a0.0.i.i109, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i55, align 8
  br label %if.end7.i

if.else.i97:                                      ; preds = %if.then65.i
  %cmp2.i98 = icmp slt i32 %sub.i95, 0
  br i1 %cmp2.i98, label %if.then.i15.i, label %if.end7.i

if.then.i15.i:                                    ; preds = %if.else.i97
  %cmp2.i16.i = icmp ugt i32 %sub.i95, -64
  br i1 %cmp2.i16.i, label %if.then10.i22.i, label %if.else.i17.i

if.then10.i22.i:                                  ; preds = %if.then.i15.i
  %sub4.i = sub nsw i32 0, %sub.i95
  %sh_prom.i23.i = zext nneg i32 %sub4.i to i64
  %shr.i24.i = lshr i64 %a.val.i119, %sh_prom.i23.i
  %32 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.val.i119, i32 %sub4.i, i64 0) #15, !srcloc !6
  %cmp11.i25.i = icmp ne i64 %32, 0
  %conv13.i26.i = zext i1 %cmp11.i25.i to i64
  %or.i27.i = or i64 %shr.i24.i, %conv13.i26.i
  br label %frac64_shrjam.exit28.i

if.else.i17.i:                                    ; preds = %if.then.i15.i
  %cmp14.i18.i = icmp ne i64 %a.val.i119, 0
  %conv16.i19.i = zext i1 %cmp14.i18.i to i64
  br label %frac64_shrjam.exit28.i

frac64_shrjam.exit28.i:                           ; preds = %if.else.i17.i, %if.then10.i22.i
  %a0.0.i21.i = phi i64 [ %or.i27.i, %if.then10.i22.i ], [ %conv16.i19.i, %if.else.i17.i ]
  store i32 %16, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %if.end7.i

if.end7.i:                                        ; preds = %frac64_shrjam.exit28.i, %if.else.i97, %frac64_shrjam.exit.i108
  %33 = phi i32 [ %16, %frac64_shrjam.exit28.i ], [ %7, %if.else.i97 ], [ %7, %frac64_shrjam.exit.i108 ]
  %b.val.i = phi i64 [ %b.val.i120, %frac64_shrjam.exit28.i ], [ %b.val.i120, %if.else.i97 ], [ %a0.0.i.i109, %frac64_shrjam.exit.i108 ]
  %a.val.i99 = phi i64 [ %a0.0.i21.i, %frac64_shrjam.exit28.i ], [ %a.val.i119, %if.else.i97 ], [ %a.val.i119, %frac64_shrjam.exit.i108 ]
  %34 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %a.val.i99, i64 %b.val.i)
  %35 = extractvalue { i64, i1 } %34, 1
  %36 = extractvalue { i64, i1 } %34, 0
  store i64 %36, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br i1 %35, label %if.then8.i100, label %parts64_addsub.exit

if.then8.i100:                                    ; preds = %if.end7.i
  %shr.i31.i = lshr i64 %36, 1
  %37 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %36, i32 1, i64 0) #15, !srcloc !6
  %cmp11.i32.i = icmp ne i64 %37, 0
  %conv13.i33.i = zext i1 %cmp11.i32.i to i64
  %or.i34.i = or i64 %shr.i31.i, %conv13.i33.i
  %or.i101 = or disjoint i64 %or.i34.i, -9223372036854775808
  store i64 %or.i101, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %add.i102 = add nsw i32 %33, 1
  store i32 %add.i102, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_addsub.exit

if.end70.i:                                       ; preds = %if.else.i
  %and71.i = and i32 %or.i, 48
  %tobool72.i.not = icmp eq i32 %and71.i, 0
  br i1 %tobool72.i.not, label %if.end80.i, label %p_nan.i

if.end80.i:                                       ; preds = %if.end70.i
  %and81.i = and i32 %or.i, 8
  %tobool82.i.not = icmp eq i32 %and81.i, 0
  br i1 %tobool82.i.not, label %if.end86.i, label %if.then83.i

if.then83.i:                                      ; preds = %if.end80.i
  store i8 3, ptr %pa, align 8
  br label %parts64_addsub.exit

if.end86.i:                                       ; preds = %if.end80.i, %if.end40.i
  %cmp89.i = icmp eq i8 %.pr.i.pre, 1
  br i1 %cmp89.i, label %if.then91.i, label %if.end99.i

if.then91.i:                                      ; preds = %if.end86.i
  %cmp94.i = icmp eq i8 %8, 2
  br i1 %cmp94.i, label %parts64_addsub.exit, label %if.else97.i

if.else97.i:                                      ; preds = %if.then91.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 401, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.4) #16
  unreachable

if.end99.i:                                       ; preds = %if.end86.i
  %cmp103.i = icmp eq i8 %8, 1
  br i1 %cmp103.i, label %if.then105.i, label %if.else106.i

if.then105.i:                                     ; preds = %if.end99.i
  %cmp112.i = icmp eq i8 %.pr.i.pre, 2
  br i1 %cmp112.i, label %return_b.i, label %if.else115.i

if.else106.i:                                     ; preds = %if.end99.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 405, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.5) #16
  unreachable

if.else115.i:                                     ; preds = %if.then105.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 406, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.6) #16
  unreachable

return_b.i:                                       ; preds = %if.then105.i, %if.then43.i
  store i8 %frombool4.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i53, align 1
  br label %parts64_addsub.exit

p_nan.i:                                          ; preds = %if.end70.i, %if.end31.i
  %cmp.i.i116 = icmp eq i8 %8, 5
  %cmp.i17.i = icmp eq i8 %.pr.i.pre, 5
  %or.cond = or i1 %cmp.i.i116, %cmp.i17.i
  br i1 %or.cond, label %if.then.i122, label %if.end.i

if.then.i122:                                     ; preds = %p_nan.i
  %38 = load i16, ptr %status, align 2
  %or1.i.i123 = or i16 %38, 8193
  store i16 %or1.i.i123, ptr %status, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %p_nan.i, %if.then.i122
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %39 = load i8, ptr %default_nan_mode.i, align 1
  %40 = and i8 %39, 1
  %tobool.not.i = icmp eq i8 %40, 0
  br i1 %tobool.not.i, label %if.else.i118, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_addsub.exit

if.else.i118:                                     ; preds = %if.end.i
  %cmp.i18.i = icmp eq i64 %a.val.i119, %b.val.i120
  %cmp1.i.i = icmp ult i64 %a.val.i119, %b.val.i120
  %cmp11.i = icmp uge i16 %f.lobit.i, %f.lobit.i49
  %cmp.0.i = select i1 %cmp.i18.i, i1 %cmp11.i, i1 %cmp1.i.i
  %cmp.0.i.fr = freeze i1 %cmp.0.i
  switch i8 %8, label %41 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.else.i118
  br i1 %cmp.i17.i, label %parts64_addsub.exit, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select.i.i = and i1 %cmp.i11.i.i, %cmp.0.i.fr
  %spec.select = select i1 %spec.select.i.i, ptr %pb, ptr %pa
  br label %parts64_addsub.exit

pickNaN.exit.i:                                   ; preds = %if.else.i118
  %cmp.i8.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select20.i = select i1 %cmp.i17.i, i1 %cmp.0.i.fr, i1 %cmp.i8.i.i
  br i1 %spec.select20.i, label %41, label %if.then24.i

41:                                               ; preds = %if.else.i118, %pickNaN.exit.i
  %42 = icmp eq i8 %.pr.i.pre, 5
  br i1 %42, label %if.then24.i, label %parts64_addsub.exit

if.then24.i:                                      ; preds = %pickNaN.exit.i, %41
  %.ph.i139 = phi ptr [ %pb, %41 ], [ %pa, %pickNaN.exit.i ]
  %.ph.i139.sroa.phi = phi ptr [ %pb.sroa.gep, %41 ], [ %pa.sroa.gep, %pickNaN.exit.i ]
  %43 = load i64, ptr %.ph.i139.sroa.phi, align 8
  %or4.i.i.i = or i64 %43, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.ph.i139.sroa.phi, align 8
  store i8 4, ptr %.ph.i139, align 8
  br label %parts64_addsub.exit

parts64_addsub.exit:                              ; preds = %lor.lhs.false.i.i, %if.then24.i, %41, %if.then6.i.i, %if.then3.i, %if.then8.i100, %if.end7.i, %parts64_sub_normal.exit.thread, %if.then91.i, %if.else.i, %if.end49.i, %return_b.i, %if.then83.i, %if.end55.i, %if.then25.i
  %retval.i.0 = phi ptr [ %pa, %if.then25.i ], [ %pb, %return_b.i ], [ %pa, %if.end55.i ], [ %pa, %if.then83.i ], [ %pa, %if.end49.i ], [ %pa, %if.else.i ], [ %pa, %if.then91.i ], [ %pa, %parts64_sub_normal.exit.thread ], [ %pa, %if.end7.i ], [ %pa, %if.then8.i100 ], [ %pa, %if.then3.i ], [ %.ph.i139, %if.then24.i ], [ %pb, %41 ], [ %pa, %if.then6.i.i ], [ %spec.select, %lor.lhs.false.i.i ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %retval.i.0, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 1
  %44 = load i8, ptr %sign.i.i, align 1
  %conv.i.i124 = zext i8 %44 to i64
  %shl.i.i125 = shl nuw nsw i64 %conv.i.i124, 15
  %exp.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 4
  %45 = load i32, ptr %exp.i.i, align 4
  %46 = shl i32 %45, 7
  %47 = and i32 %46, 32640
  %and8.i.i = zext nneg i32 %47 to i64
  %or.i.i126 = or disjoint i64 %shl.i.i125, %and8.i.i
  %48 = getelementptr inbounds i8, ptr %retval.i.0, i64 8
  %49 = load i64, ptr %48, align 8
  %shl77.i9.i = and i64 %49, 127
  %or.i10.i = or disjoint i64 %or.i.i126, %shl77.i9.i
  %conv.i = trunc i64 %or.i10.i to i16
  ret i16 %conv.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_sub(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @bfloat16_addsub(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %status, i1 noundef zeroext true)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_add(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i64 } @float128_addsub(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr noundef %status, i1 noundef zeroext false)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc { i64, i64 } @float128_addsub(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %status, i1 noundef zeroext %subtract) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts128, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts128, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %shr.i16.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i to i32
  %conv.i = and i32 %0, 32767
  %f.coerce1.lobit.i = lshr i64 %a.coerce1, 63
  %frombool.i = trunc i64 %f.coerce1.lobit.i to i8
  %and.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %pa, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pa, ptr noundef %status, ptr noundef nonnull @float128_params)
  %shr.i16.i47 = lshr i64 %b.coerce1, 48
  %1 = trunc i64 %shr.i16.i47 to i32
  %conv.i48 = and i32 %1, 32767
  %f.coerce1.lobit.i49 = lshr i64 %b.coerce1, 63
  %frombool.i50 = trunc i64 %f.coerce1.lobit.i49 to i8
  %and.i.i51 = and i64 %b.coerce1, 281474976710655
  store i8 0, ptr %pb, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i52 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i50, ptr %.compoundliteral.sroa.2.0..sroa_idx.i52, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i53 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i48, ptr %.compoundliteral.sroa.33.0..sroa_idx.i53, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i54 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i.i51, ptr %.compoundliteral.sroa.4.0..sroa_idx.i54, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i55 = getelementptr inbounds i8, ptr %pb, i64 16
  store i64 %b.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i55, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pb, ptr noundef %status, ptr noundef nonnull @float128_params)
  %2 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i52, align 1
  %3 = and i8 %2, 1
  %4 = icmp ne i8 %3, 0
  %tobool3.i = xor i1 %4, %subtract
  %frombool4.i = zext i1 %tobool3.i to i8
  %5 = load i8, ptr %pa, align 8
  %conv5.i = zext nneg i8 %5 to i32
  %shl.i = shl nuw i32 1, %conv5.i
  %6 = load i8, ptr %pb, align 8
  %conv7.i = zext nneg i8 %6 to i32
  %shl8.i = shl nuw i32 1, %conv7.i
  %or.i = or i32 %shl8.i, %shl.i
  %7 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %8 = and i8 %7, 1
  %9 = icmp eq i8 %8, 0
  %cmp.i.not = xor i1 %tobool3.i, %9
  br i1 %cmp.i.not, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  switch i32 %or.i, label %if.end31.i [
    i32 4, label %if.then20.i
    i32 2, label %if.then25.i
  ]

if.then20.i:                                      ; preds = %if.then.i
  %call.i9 = call fastcc zeroext i1 @parts128_sub_normal(ptr noundef nonnull %pa, ptr noundef nonnull %pb)
  br i1 %call.i9, label %parts128_addsub.exitthread-pre-split, label %if.then25.i

if.then25.i:                                      ; preds = %if.then.i, %if.then20.i
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %10 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp27.i = icmp eq i8 %10, 1
  %frombool30.i = zext i1 %cmp27.i to i8
  store i8 %frombool30.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  br label %parts128_addsub.exitthread-pre-split

if.end31.i:                                       ; preds = %if.then.i
  %and.i = and i32 %or.i, 48
  %tobool32.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool32.i.not, label %if.end40.i, label %p_nan.i

if.end40.i:                                       ; preds = %if.end31.i
  %and41.i = and i32 %or.i, 8
  %tobool42.i.not = icmp eq i32 %and41.i, 0
  br i1 %tobool42.i.not, label %if.end86.i, label %if.then43.i

if.then43.i:                                      ; preds = %if.end40.i
  %cmp46.i.not = icmp eq i8 %5, 3
  br i1 %cmp46.i.not, label %if.end49.i, label %return_b.i

if.end49.i:                                       ; preds = %if.then43.i
  %cmp52.i.not = icmp eq i8 %6, 3
  br i1 %cmp52.i.not, label %if.end55.i, label %do.end.i

if.end55.i:                                       ; preds = %if.end49.i
  %11 = load i16, ptr %status, align 2
  %or1.i = or i16 %11, 129
  store i16 %or1.i, ptr %status, align 2
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %do.end18.i

if.else.i:                                        ; preds = %entry
  switch i32 %or.i, label %if.end70.i [
    i32 4, label %if.then65.i
    i32 2, label %parts128_addsub.exitthread-pre-split
  ]

if.then65.i:                                      ; preds = %if.else.i
  call fastcc void @parts128_add_normal(ptr noundef nonnull %pa, ptr noundef nonnull %pb)
  br label %parts128_addsub.exitthread-pre-split

if.end70.i:                                       ; preds = %if.else.i
  %and71.i = and i32 %or.i, 48
  %tobool72.i.not = icmp eq i32 %and71.i, 0
  br i1 %tobool72.i.not, label %if.end80.i, label %p_nan.i

if.end80.i:                                       ; preds = %if.end70.i
  %and81.i = and i32 %or.i, 8
  %tobool82.i.not = icmp eq i32 %and81.i, 0
  br i1 %tobool82.i.not, label %if.end86.i, label %do.end.i

if.end86.i:                                       ; preds = %if.end80.i, %if.end40.i
  %cmp89.i = icmp eq i8 %6, 1
  br i1 %cmp89.i, label %if.then91.i, label %if.end99.i

if.then91.i:                                      ; preds = %if.end86.i
  %cmp94.i = icmp eq i8 %5, 2
  br i1 %cmp94.i, label %if.then.i63, label %if.else97.i

if.else97.i:                                      ; preds = %if.then91.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 401, ptr noundef nonnull @__func__.parts128_addsub, ptr noundef nonnull @.str.4) #16
  unreachable

if.end99.i:                                       ; preds = %if.end86.i
  %cmp103.i = icmp eq i8 %5, 1
  br i1 %cmp103.i, label %if.then105.i, label %if.else106.i

if.then105.i:                                     ; preds = %if.end99.i
  %cmp112.i = icmp eq i8 %6, 2
  br i1 %cmp112.i, label %return_b.i, label %if.else115.i

if.else106.i:                                     ; preds = %if.end99.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 405, ptr noundef nonnull @__func__.parts128_addsub, ptr noundef nonnull @.str.5) #16
  unreachable

if.else115.i:                                     ; preds = %if.then105.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 406, ptr noundef nonnull @__func__.parts128_addsub, ptr noundef nonnull @.str.6) #16
  unreachable

return_b.i:                                       ; preds = %if.then105.i, %if.then43.i
  store i8 %frombool4.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i52, align 1
  br label %parts128_addsub.exitthread-pre-split

p_nan.i:                                          ; preds = %if.end70.i, %if.end31.i
  %cmp.i.i = icmp eq i8 %5, 5
  %cmp.i17.i = icmp eq i8 %6, 5
  %or.cond = select i1 %cmp.i.i, i1 true, i1 %cmp.i17.i
  br i1 %or.cond, label %if.then.i61, label %if.end.i

if.then.i61:                                      ; preds = %p_nan.i
  %12 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %12, 8193
  store i16 %or1.i.i, ptr %status, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %p_nan.i, %if.then.i61
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %13 = load i8, ptr %default_nan_mode.i, align 1
  %14 = and i8 %13, 1
  %tobool.not.i = icmp eq i8 %14, 0
  br i1 %tobool.not.i, label %if.else.i59, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %do.end18.i

if.else.i59:                                      ; preds = %if.end.i
  %15 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %16 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i54, align 8
  %cmp.i18.i = icmp eq i64 %15, %16
  br i1 %cmp.i18.i, label %if.then.i.i, label %frac128_cmp.exit.i

if.then.i.i:                                      ; preds = %if.else.i59
  %17 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %18 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i55, align 8
  %cmp3.i.i = icmp eq i64 %17, %18
  br i1 %cmp3.i.i, label %if.then6.i, label %frac128_cmp.exit.i

frac128_cmp.exit.i:                               ; preds = %if.then.i.i, %if.else.i59
  %ta.0.i.i = phi i64 [ %17, %if.then.i.i ], [ %15, %if.else.i59 ]
  %tb.0.i.i = phi i64 [ %18, %if.then.i.i ], [ %16, %if.else.i59 ]
  %cmp6.i.i = icmp ult i64 %ta.0.i.i, %tb.0.i.i
  br label %if.end13.i

if.then6.i:                                       ; preds = %if.then.i.i
  %cmp11.i = icmp uge i8 %8, %3
  br label %if.end13.i

if.end13.i:                                       ; preds = %if.then6.i, %frac128_cmp.exit.i
  %cmp.0.i = phi i1 [ %cmp11.i, %if.then6.i ], [ %cmp6.i.i, %frac128_cmp.exit.i ]
  switch i8 %5, label %19 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end13.i
  br i1 %cmp.i17.i, label %parts128_addsub.exitthread-pre-split, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %6, 4
  %spec.select.i.i = and i1 %cmp.0.i, %cmp.i11.i.i
  %cond.fr31.i = freeze i1 %spec.select.i.i
  br i1 %cond.fr31.i, label %19, label %do.end18.i

pickNaN.exit.i:                                   ; preds = %if.end13.i
  %cmp.i8.i.i = icmp eq i8 %6, 4
  %spec.select25.i = select i1 %cmp.i17.i, i1 %cmp.0.i, i1 %cmp.i8.i.i
  %cond.fr.i = freeze i1 %spec.select25.i
  br i1 %cond.fr.i, label %19, label %if.then24.i

19:                                               ; preds = %if.end13.i, %lor.lhs.false.i.i, %pickNaN.exit.i
  %.pr.i.pre = load i8, ptr %pb, align 8
  %cmp.i21.i = icmp eq i8 %.pr.i.pre, 5
  br i1 %cmp.i21.i, label %if.then24.i, label %parts128_addsub.exit

if.then24.i:                                      ; preds = %pickNaN.exit.i, %19
  %.ph.i87 = phi ptr [ %pb, %19 ], [ %pa, %pickNaN.exit.i ]
  %.ph.i87.sroa.phi = phi ptr [ %pb.sroa.gep, %19 ], [ %pa.sroa.gep, %pickNaN.exit.i ]
  %20 = load i64, ptr %.ph.i87.sroa.phi, align 8
  %or4.i.i.i = or i64 %20, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.ph.i87.sroa.phi, align 8
  store i8 4, ptr %.ph.i87, align 8
  br label %do.end18.i

parts128_addsub.exitthread-pre-split:             ; preds = %if.then25.i, %if.then65.i, %return_b.i, %if.then20.i, %if.else.i, %if.then6.i.i
  %retval.i7.0.ph = phi ptr [ %pa, %if.then6.i.i ], [ %pa, %if.else.i ], [ %pa, %if.then20.i ], [ %pa, %if.then65.i ], [ %pb, %return_b.i ], [ %pa, %if.then25.i ]
  %.pr = load i8, ptr %retval.i7.0.ph, align 8
  br label %parts128_addsub.exit

parts128_addsub.exit:                             ; preds = %parts128_addsub.exitthread-pre-split, %19
  %21 = phi i8 [ %.pr, %parts128_addsub.exitthread-pre-split ], [ %.pr.i.pre, %19 ]
  %retval.i7.0 = phi ptr [ %retval.i7.0.ph, %parts128_addsub.exitthread-pre-split ], [ %pb, %19 ]
  switch i8 %21, label %do.body21.i [
    i8 2, label %if.then.i63
    i8 1, label %sw.bb.i
    i8 3, label %do.end.i
    i8 4, label %do.end18.i
    i8 5, label %do.end18.i
  ]

if.then.i63:                                      ; preds = %if.then91.i, %parts128_addsub.exit
  %retval.i7.082 = phi ptr [ %retval.i7.0, %parts128_addsub.exit ], [ %pa, %if.then91.i ]
  call fastcc void @parts128_uncanon_normal(ptr noundef nonnull %retval.i7.082, ptr noundef %status, ptr noundef nonnull @float128_params)
  %exp.i65.phi.trans.insert = getelementptr inbounds i8, ptr %retval.i7.082, i64 4
  %.pre = load i32, ptr %exp.i65.phi.trans.insert, align 4
  %22 = zext i32 %.pre to i64
  %23 = shl i64 %22, 48
  %24 = and i64 %23, 9223090561878065152
  br label %parts128_uncanon.exit

sw.bb.i:                                          ; preds = %parts128_addsub.exit
  %exp.i = getelementptr inbounds i8, ptr %retval.i7.0, i64 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(20) %exp.i, i8 0, i64 20, i1 false)
  br label %parts128_uncanon.exit

do.end.i:                                         ; preds = %if.end80.i, %if.end49.i, %parts128_addsub.exit
  %retval.i7.079 = phi ptr [ %retval.i7.0, %parts128_addsub.exit ], [ %pa, %if.end49.i ], [ %pa, %if.end80.i ]
  %exp10.i = getelementptr inbounds i8, ptr %retval.i7.079, i64 4
  store i32 32767, ptr %exp10.i, align 4
  %frac_hi.i14.i = getelementptr inbounds i8, ptr %retval.i7.079, i64 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %frac_hi.i14.i, i8 0, i64 16, i1 false)
  br label %parts128_uncanon.exit

do.end18.i:                                       ; preds = %lor.lhs.false.i.i, %if.end55.i, %if.then3.i, %if.then24.i, %parts128_addsub.exit, %parts128_addsub.exit
  %retval.i7.074 = phi ptr [ %retval.i7.0, %parts128_addsub.exit ], [ %retval.i7.0, %parts128_addsub.exit ], [ %.ph.i87, %if.then24.i ], [ %pa, %if.then3.i ], [ %pa, %if.end55.i ], [ %pa, %lor.lhs.false.i.i ]
  %exp20.i = getelementptr inbounds i8, ptr %retval.i7.074, i64 4
  store i32 32767, ptr %exp20.i, align 4
  %frac_hi.i15.i = getelementptr inbounds i8, ptr %retval.i7.074, i64 8
  %25 = load i64, ptr %frac_hi.i15.i, align 8
  %frac_lo.i.i62 = getelementptr inbounds i8, ptr %retval.i7.074, i64 16
  %26 = load i64, ptr %frac_lo.i.i62, align 8
  %27 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %25, i32 15, i64 %26) #15, !srcloc !6
  %shr.i.i = lshr i64 %25, 15
  store i64 %shr.i.i, ptr %frac_hi.i15.i, align 8
  store i64 %27, ptr %frac_lo.i.i62, align 8
  br label %parts128_uncanon.exit

do.body21.i:                                      ; preds = %parts128_addsub.exit
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 330, ptr noundef nonnull @__func__.parts128_uncanon, ptr noundef null) #16
  unreachable

parts128_uncanon.exit:                            ; preds = %if.then.i63, %sw.bb.i, %do.end.i, %do.end18.i
  %conv1.i = phi i64 [ %24, %if.then.i63 ], [ 0, %sw.bb.i ], [ 9223090561878065152, %do.end.i ], [ 9223090561878065152, %do.end18.i ]
  %retval.i7.075 = phi ptr [ %retval.i7.082, %if.then.i63 ], [ %retval.i7.0, %sw.bb.i ], [ %retval.i7.079, %do.end.i ], [ %retval.i7.074, %do.end18.i ]
  %sign.i64 = getelementptr inbounds i8, ptr %retval.i7.075, i64 1
  %28 = load i8, ptr %sign.i64, align 1
  %frac_hi.i = getelementptr inbounds i8, ptr %retval.i7.075, i64 8
  %29 = load i64, ptr %frac_hi.i, align 8
  %30 = and i8 %28, 1
  %conv.i66 = zext nneg i8 %30 to i64
  %shl.i67 = shl nuw i64 %conv.i66, 63
  %or.i25.i = or disjoint i64 %conv1.i, %shl.i67
  %and8.i.i = and i64 %29, 281474976710655
  %or.i.i = or disjoint i64 %or.i25.i, %and8.i.i
  %frac_lo.i = getelementptr inbounds i8, ptr %retval.i7.075, i64 16
  %31 = load i64, ptr %frac_lo.i, align 8
  %.fca.0.insert.i = insertvalue { i64, i64 } poison, i64 %31, 0
  %.fca.1.insert.i = insertvalue { i64, i64 } %.fca.0.insert.i, i64 %or.i.i, 1
  ret { i64, i64 } %.fca.1.insert.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_sub(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i64 } @float128_addsub(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr noundef %status, i1 noundef zeroext true)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @floatx80_add(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i16 } @floatx80_addsub(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr noundef %status, i1 noundef zeroext false)
  ret { i64, i16 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc { i64, i16 } @floatx80_addsub(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr nocapture noundef %status, i1 noundef zeroext %subtract) unnamed_addr #3 {
entry:
  %p64.i = alloca %struct.FloatParts64, align 8
  %pa = alloca %struct.FloatParts128, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts128, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %floatx80_rounding_precision.i12 = getelementptr inbounds i8, ptr %status, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i12, align 1
  %switch = icmp ult i8 %0, 3
  br i1 %switch, label %sw.bb.i14, label %sw.default.i41

sw.bb.i14:                                        ; preds = %entry
  %cmp.i = icmp sgt i64 %a.coerce0, -1
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i = icmp ne i16 %1, 0
  %2 = select i1 %cmp.i, i1 %cmp2.i, i1 false
  br i1 %2, label %floatx80_unpack_canonical.exit42, label %if.end.i19

sw.default.i41:                                   ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

if.end.i19:                                       ; preds = %sw.bb.i14
  %f.coerce1.lobit.i = lshr i16 %a.coerce1, 15
  %frombool.i = trunc i16 %f.coerce1.lobit.i to i8
  %and.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %pa, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %and.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %cmp.i21.not = icmp eq i16 %1, 32767
  br i1 %cmp.i21.not, label %lor.lhs.false.thread, label %lor.lhs.false

lor.lhs.false.thread:                             ; preds = %if.end.i19
  %and.i27 = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i27, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %cmp12.i29 = icmp eq i64 %and.i27, 0
  %3 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i = icmp eq i64 %3, 0
  %cond.i33 = select i1 %tobool.not.i, i8 5, i8 4
  %cond17.i35 = select i1 %cmp12.i29, i8 3, i8 %cond.i33
  store i8 %cond17.i35, ptr %pa, align 8
  br label %sw.bb.i

floatx80_unpack_canonical.exit42:                 ; preds = %sw.bb.i14
  %4 = load i16, ptr %status, align 2
  %or1.i = or i16 %4, 1
  store i16 %or1.i, ptr %status, align 2
  br label %return

lor.lhs.false:                                    ; preds = %if.end.i19
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pa, ptr noundef nonnull %status, ptr noundef nonnull @floatx80_params)
  %.pre = load i8, ptr %floatx80_rounding_precision.i12, align 1
  %switch85 = icmp ult i8 %.pre, 3
  br i1 %switch85, label %sw.bb.i, label %sw.default.i

sw.bb.i:                                          ; preds = %lor.lhs.false.thread, %lor.lhs.false
  %cmp.i87 = icmp sgt i64 %b.coerce0, -1
  %5 = and i16 %b.coerce1, 32767
  %cmp2.i88 = icmp ne i16 %5, 0
  %6 = select i1 %cmp.i87, i1 %cmp2.i88, i1 false
  br i1 %6, label %floatx80_unpack_canonical.exit, label %if.end.i

sw.default.i:                                     ; preds = %lor.lhs.false
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

if.end.i:                                         ; preds = %sw.bb.i
  %f.coerce1.lobit.i90 = lshr i16 %b.coerce1, 15
  %frombool.i91 = trunc i16 %f.coerce1.lobit.i90 to i8
  %and.i.i92 = zext nneg i16 %5 to i32
  store i8 0, ptr %pb, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i93 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i91, ptr %.compoundliteral.sroa.2.0..sroa_idx.i93, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i94 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %and.i.i92, ptr %.compoundliteral.sroa.32.0..sroa_idx.i94, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i95 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %b.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i95, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i96 = getelementptr inbounds i8, ptr %pb, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i96, align 8
  %cmp.i.not = icmp eq i16 %5, 32767
  br i1 %cmp.i.not, label %if.else.i7, label %if.then10.i

if.then10.i:                                      ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pb, ptr noundef nonnull %status, ptr noundef nonnull @floatx80_params)
  %.pre129 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i93, align 1
  %.pre130 = load i8, ptr %pb, align 8
  br label %if.end

if.else.i7:                                       ; preds = %if.end.i
  %and.i = and i64 %b.coerce0, 9223372036854775807
  store i64 %and.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i95, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %7 = and i64 %b.coerce0, 4611686018427387904
  %tobool.not.i97 = icmp eq i64 %7, 0
  %cond.i = select i1 %tobool.not.i97, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %cond.i
  store i8 %cond17.i, ptr %pb, align 8
  br label %if.end

floatx80_unpack_canonical.exit:                   ; preds = %sw.bb.i
  %8 = load i16, ptr %status, align 2
  %or1.i89 = or i16 %8, 1
  store i16 %or1.i89, ptr %status, align 2
  br label %return

if.end:                                           ; preds = %if.then10.i, %if.else.i7
  %9 = phi i8 [ %.pre130, %if.then10.i ], [ %cond17.i, %if.else.i7 ]
  %10 = phi i8 [ %.pre129, %if.then10.i ], [ %frombool.i91, %if.else.i7 ]
  %11 = and i8 %10, 1
  %12 = icmp ne i8 %11, 0
  %tobool3.i = xor i1 %12, %subtract
  %frombool4.i = zext i1 %tobool3.i to i8
  %13 = load i8, ptr %pa, align 8
  %conv5.i = zext nneg i8 %13 to i32
  %shl.i = shl nuw i32 1, %conv5.i
  %conv7.i = zext nneg i8 %9 to i32
  %shl8.i = shl nuw i32 1, %conv7.i
  %or.i65 = or i32 %shl8.i, %shl.i
  %14 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %15 = and i8 %14, 1
  %16 = icmp eq i8 %15, 0
  %cmp.i66.not = xor i1 %tobool3.i, %16
  br i1 %cmp.i66.not, label %if.else.i67, label %if.then.i68

if.then.i68:                                      ; preds = %if.end
  switch i32 %or.i65, label %if.end31.i [
    i32 4, label %if.then20.i
    i32 2, label %if.then25.i
  ]

if.then20.i:                                      ; preds = %if.then.i68
  %call.i73 = call fastcc zeroext i1 @parts128_sub_normal(ptr noundef nonnull %pa, ptr noundef nonnull %pb)
  br i1 %call.i73, label %parts128_addsub.exitthread-pre-split, label %if.then25.i

if.then25.i:                                      ; preds = %if.then.i68, %if.then20.i
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %17 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp27.i = icmp eq i8 %17, 1
  %frombool30.i = zext i1 %cmp27.i to i8
  store i8 %frombool30.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  br label %parts128_addsub.exitthread-pre-split

if.end31.i:                                       ; preds = %if.then.i68
  %and.i72 = and i32 %or.i65, 48
  %tobool32.i.not = icmp eq i32 %and.i72, 0
  br i1 %tobool32.i.not, label %if.end40.i, label %p_nan.i

if.end40.i:                                       ; preds = %if.end31.i
  %and41.i = and i32 %or.i65, 8
  %tobool42.i.not = icmp eq i32 %and41.i, 0
  br i1 %tobool42.i.not, label %if.end86.i, label %if.then43.i

if.then43.i:                                      ; preds = %if.end40.i
  %cmp46.i.not = icmp eq i8 %13, 3
  br i1 %cmp46.i.not, label %if.end49.i, label %return_b.i

if.end49.i:                                       ; preds = %if.then43.i
  %cmp52.i.not = icmp eq i8 %9, 3
  br i1 %cmp52.i.not, label %if.end55.i, label %parts128_addsub.exit.thread

if.end55.i:                                       ; preds = %if.end49.i
  %18 = load i16, ptr %status, align 2
  %or1.i98 = or i16 %18, 129
  store i16 %or1.i98, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %parts128_addsub.exitthread-pre-split

if.else.i67:                                      ; preds = %if.end
  switch i32 %or.i65, label %if.end70.i [
    i32 4, label %if.then65.i
    i32 2, label %parts128_addsub.exitthread-pre-split
  ]

if.then65.i:                                      ; preds = %if.else.i67
  call fastcc void @parts128_add_normal(ptr noundef nonnull %pa, ptr noundef nonnull %pb)
  br label %parts128_addsub.exitthread-pre-split

if.end70.i:                                       ; preds = %if.else.i67
  %and71.i = and i32 %or.i65, 48
  %tobool72.i.not = icmp eq i32 %and71.i, 0
  br i1 %tobool72.i.not, label %if.end80.i, label %p_nan.i

if.end80.i:                                       ; preds = %if.end70.i
  %and81.i = and i32 %or.i65, 8
  %tobool82.i.not = icmp eq i32 %and81.i, 0
  br i1 %tobool82.i.not, label %if.end86.i, label %parts128_addsub.exit.thread

if.end86.i:                                       ; preds = %if.end80.i, %if.end40.i
  %cmp89.i = icmp eq i8 %9, 1
  br i1 %cmp89.i, label %if.then91.i, label %if.end99.i

if.then91.i:                                      ; preds = %if.end86.i
  %cmp94.i = icmp eq i8 %13, 2
  br i1 %cmp94.i, label %parts128_addsub.exit.thread117, label %if.else97.i

parts128_addsub.exit.thread117:                   ; preds = %if.then91.i
  %19 = load i8, ptr %floatx80_rounding_precision.i12, align 1
  %idxprom.i119 = zext i8 %19 to i64
  %arrayidx.i120 = getelementptr [3 x %struct.FloatFmt], ptr @floatx80_params, i64 0, i64 %idxprom.i119
  br label %sw.bb.i50

if.else97.i:                                      ; preds = %if.then91.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 401, ptr noundef nonnull @__func__.parts128_addsub, ptr noundef nonnull @.str.4) #16
  unreachable

if.end99.i:                                       ; preds = %if.end86.i
  %cmp103.i = icmp eq i8 %13, 1
  br i1 %cmp103.i, label %if.then105.i, label %if.else106.i

if.then105.i:                                     ; preds = %if.end99.i
  %cmp112.i = icmp eq i8 %9, 2
  br i1 %cmp112.i, label %return_b.i, label %if.else115.i

if.else106.i:                                     ; preds = %if.end99.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 405, ptr noundef nonnull @__func__.parts128_addsub, ptr noundef nonnull @.str.5) #16
  unreachable

if.else115.i:                                     ; preds = %if.then105.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 406, ptr noundef nonnull @__func__.parts128_addsub, ptr noundef nonnull @.str.6) #16
  unreachable

return_b.i:                                       ; preds = %if.then105.i, %if.then43.i
  store i8 %frombool4.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i93, align 1
  br label %parts128_addsub.exitthread-pre-split

p_nan.i:                                          ; preds = %if.end70.i, %if.end31.i
  %cmp.i.i = icmp eq i8 %13, 5
  %cmp.i17.i = icmp eq i8 %9, 5
  %or.cond = select i1 %cmp.i.i, i1 true, i1 %cmp.i17.i
  br i1 %or.cond, label %if.then.i105, label %if.end.i102

if.then.i105:                                     ; preds = %p_nan.i
  %20 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %20, 8193
  store i16 %or1.i.i, ptr %status, align 2
  br label %if.end.i102

if.end.i102:                                      ; preds = %p_nan.i, %if.then.i105
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %21 = load i8, ptr %default_nan_mode.i, align 1
  %22 = and i8 %21, 1
  %tobool.not.i103 = icmp eq i8 %22, 0
  br i1 %tobool.not.i103, label %if.else.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i102
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %parts128_addsub.exitthread-pre-split

if.else.i:                                        ; preds = %if.end.i102
  %23 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %24 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i95, align 8
  %cmp.i18.i = icmp eq i64 %23, %24
  br i1 %cmp.i18.i, label %if.then.i.i, label %frac128_cmp.exit.i

if.then.i.i:                                      ; preds = %if.else.i
  %25 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %26 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i96, align 8
  %cmp3.i.i = icmp eq i64 %25, %26
  br i1 %cmp3.i.i, label %if.then6.i, label %frac128_cmp.exit.i

frac128_cmp.exit.i:                               ; preds = %if.then.i.i, %if.else.i
  %ta.0.i.i = phi i64 [ %25, %if.then.i.i ], [ %23, %if.else.i ]
  %tb.0.i.i = phi i64 [ %26, %if.then.i.i ], [ %24, %if.else.i ]
  %cmp6.i.i = icmp ult i64 %ta.0.i.i, %tb.0.i.i
  br label %if.end13.i

if.then6.i:                                       ; preds = %if.then.i.i
  %cmp11.i = icmp uge i8 %15, %11
  br label %if.end13.i

if.end13.i:                                       ; preds = %if.then6.i, %frac128_cmp.exit.i
  %cmp.0.i = phi i1 [ %cmp11.i, %if.then6.i ], [ %cmp6.i.i, %frac128_cmp.exit.i ]
  switch i8 %13, label %27 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end13.i
  br i1 %cmp.i17.i, label %parts128_addsub.exitthread-pre-split, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %9, 4
  %spec.select.i.i = and i1 %cmp.0.i, %cmp.i11.i.i
  %cond.fr31.i = freeze i1 %spec.select.i.i
  br i1 %cond.fr31.i, label %27, label %parts128_addsub.exit.thread146

parts128_addsub.exit.thread146:                   ; preds = %lor.lhs.false.i.i
  %.pre133145 = load i8, ptr %floatx80_rounding_precision.i12, align 1
  %idxprom.i148 = zext i8 %.pre133145 to i64
  %arrayidx.i149 = getelementptr [3 x %struct.FloatFmt], ptr @floatx80_params, i64 0, i64 %idxprom.i148
  br label %sw.bb16.i

pickNaN.exit.i:                                   ; preds = %if.end13.i
  %cmp.i8.i.i = icmp eq i8 %9, 4
  %spec.select25.i = select i1 %cmp.i17.i, i1 %cmp.0.i, i1 %cmp.i8.i.i
  %cond.fr.i = freeze i1 %spec.select25.i
  br i1 %cond.fr.i, label %27, label %.thread

.thread:                                          ; preds = %pickNaN.exit.i
  %.pre133138 = load i8, ptr %floatx80_rounding_precision.i12, align 1
  br label %parts128_addsub.exit.thread123

27:                                               ; preds = %if.end13.i, %lor.lhs.false.i.i, %pickNaN.exit.i
  %.pr.i.pre = load i8, ptr %pb, align 8
  %cmp.i21.i = icmp eq i8 %.pr.i.pre, 5
  %.pre133 = load i8, ptr %floatx80_rounding_precision.i12, align 1
  br i1 %cmp.i21.i, label %parts128_addsub.exit.thread123, label %parts128_addsub.exit

parts128_addsub.exit.thread123:                   ; preds = %.thread, %27
  %.pre133140 = phi i8 [ %.pre133138, %.thread ], [ %.pre133, %27 ]
  %.ph.i139 = phi ptr [ %pa, %.thread ], [ %pb, %27 ]
  %.ph.i139.sroa.phi = phi ptr [ %pa.sroa.gep, %.thread ], [ %pb.sroa.gep, %27 ]
  %28 = load i64, ptr %.ph.i139.sroa.phi, align 8
  %or4.i.i.i = or i64 %28, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.ph.i139.sroa.phi, align 8
  store i8 4, ptr %.ph.i139, align 8
  %idxprom.i125 = zext i8 %.pre133140 to i64
  %arrayidx.i126 = getelementptr [3 x %struct.FloatFmt], ptr @floatx80_params, i64 0, i64 %idxprom.i125
  br label %sw.bb16.i

parts128_addsub.exitthread-pre-split:             ; preds = %if.then25.i, %if.end55.i, %if.then65.i, %return_b.i, %if.then20.i, %if.else.i67, %if.then3.i, %if.then6.i.i
  %retval.i58.0.ph = phi ptr [ %pa, %if.then6.i.i ], [ %pa, %if.then3.i ], [ %pa, %if.else.i67 ], [ %pa, %if.then20.i ], [ %pa, %if.then65.i ], [ %pa, %if.end55.i ], [ %pb, %return_b.i ], [ %pa, %if.then25.i ]
  %.pr = load i8, ptr %retval.i58.0.ph, align 8
  %.pre132 = load i8, ptr %floatx80_rounding_precision.i12, align 1
  br label %parts128_addsub.exit

parts128_addsub.exit.thread:                      ; preds = %if.end80.i, %if.end49.i
  %29 = load i8, ptr %floatx80_rounding_precision.i12, align 1
  %idxprom.i112 = zext i8 %29 to i64
  %arrayidx.i113 = getelementptr [3 x %struct.FloatFmt], ptr @floatx80_params, i64 0, i64 %idxprom.i112
  br label %floatx80_round_pack_canonical.exit.sink.split

parts128_addsub.exit:                             ; preds = %parts128_addsub.exitthread-pre-split, %27
  %30 = phi i8 [ %.pre132, %parts128_addsub.exitthread-pre-split ], [ %.pre133, %27 ]
  %31 = phi i8 [ %.pr, %parts128_addsub.exitthread-pre-split ], [ %.pr.i.pre, %27 ]
  %retval.i58.0 = phi ptr [ %retval.i58.0.ph, %parts128_addsub.exitthread-pre-split ], [ %pb, %27 ]
  %idxprom.i = zext i8 %30 to i64
  %arrayidx.i = getelementptr [3 x %struct.FloatFmt], ptr @floatx80_params, i64 0, i64 %idxprom.i
  switch i8 %31, label %sw.default.i57 [
    i8 2, label %sw.bb.i50
    i8 3, label %floatx80_round_pack_canonical.exit.sink.split
    i8 1, label %floatx80_round_pack_canonical.exit
    i8 5, label %sw.bb16.i
    i8 4, label %sw.bb16.i
  ]

sw.bb.i50:                                        ; preds = %parts128_addsub.exit.thread117, %parts128_addsub.exit
  %arrayidx.i122 = phi ptr [ %arrayidx.i120, %parts128_addsub.exit.thread117 ], [ %arrayidx.i, %parts128_addsub.exit ]
  %32 = phi i8 [ %19, %parts128_addsub.exit.thread117 ], [ %30, %parts128_addsub.exit ]
  %retval.i58.0121 = phi ptr [ %pa, %parts128_addsub.exit.thread117 ], [ %retval.i58.0, %parts128_addsub.exit ]
  %cmp.i52 = icmp eq i8 %32, 0
  br i1 %cmp.i52, label %if.then.i55, label %if.else.i53

if.then.i55:                                      ; preds = %sw.bb.i50
  call fastcc void @parts128_uncanon_normal(ptr noundef nonnull %retval.i58.0121, ptr noundef nonnull %status, ptr noundef %arrayidx.i122)
  %frac_hi.i56 = getelementptr inbounds i8, ptr %retval.i58.0121, i64 8
  %33 = load i64, ptr %frac_hi.i56, align 8
  %exp4.i = getelementptr inbounds i8, ptr %retval.i58.0121, i64 4
  br label %if.end.i54

if.else.i53:                                      ; preds = %sw.bb.i50
  %sign.i = getelementptr inbounds i8, ptr %retval.i58.0121, i64 1
  %34 = load i8, ptr %sign.i, align 1
  %35 = and i8 %34, 1
  %sign5.i = getelementptr inbounds i8, ptr %p64.i, i64 1
  store i8 %35, ptr %sign5.i, align 1
  %exp6.i = getelementptr inbounds i8, ptr %retval.i58.0121, i64 4
  %36 = load i32, ptr %exp6.i, align 4
  %exp7.i = getelementptr inbounds i8, ptr %p64.i, i64 4
  store i32 %36, ptr %exp7.i, align 4
  %37 = getelementptr i8, ptr %retval.i58.0121, i64 8
  %retval.i58.0.val = load i64, ptr %37, align 8
  %38 = getelementptr i8, ptr %retval.i58.0121, i64 16
  %retval.i58.0.val86 = load i64, ptr %38, align 8
  %cmp.i106 = icmp ne i64 %retval.i58.0.val86, 0
  %conv1.i = zext i1 %cmp.i106 to i64
  %or.i107 = or i64 %retval.i58.0.val, %conv1.i
  %39 = getelementptr inbounds i8, ptr %p64.i, i64 8
  store i64 %or.i107, ptr %39, align 8
  call fastcc void @parts64_uncanon_normal(ptr noundef nonnull %p64.i, ptr noundef nonnull %status, ptr noundef %arrayidx.i122)
  %40 = load i64, ptr %39, align 8
  br label %if.end.i54

if.end.i54:                                       ; preds = %if.else.i53, %if.then.i55
  %exp7.i.sink = phi ptr [ %exp7.i, %if.else.i53 ], [ %exp4.i, %if.then.i55 ]
  %frac.i.0 = phi i64 [ %40, %if.else.i53 ], [ %33, %if.then.i55 ]
  %41 = load i32, ptr %exp7.i.sink, align 4
  %exp_max.i = getelementptr inbounds i8, ptr %arrayidx.i122, i64 12
  %42 = load i32, ptr %exp_max.i, align 4
  %cmp9.i.not = icmp eq i32 %41, %42
  br i1 %cmp9.i.not, label %floatx80_round_pack_canonical.exit.sink.split, label %floatx80_round_pack_canonical.exit

sw.bb16.i:                                        ; preds = %parts128_addsub.exit.thread146, %parts128_addsub.exit.thread123, %parts128_addsub.exit, %parts128_addsub.exit
  %arrayidx.i128 = phi ptr [ %arrayidx.i126, %parts128_addsub.exit.thread123 ], [ %arrayidx.i, %parts128_addsub.exit ], [ %arrayidx.i, %parts128_addsub.exit ], [ %arrayidx.i149, %parts128_addsub.exit.thread146 ]
  %retval.i58.0127 = phi ptr [ %.ph.i139, %parts128_addsub.exit.thread123 ], [ %retval.i58.0, %parts128_addsub.exit ], [ %retval.i58.0, %parts128_addsub.exit ], [ %pa, %parts128_addsub.exit.thread146 ]
  %frac_hi17.i = getelementptr inbounds i8, ptr %retval.i58.0127, i64 8
  %43 = load i64, ptr %frac_hi17.i, align 8
  %or.i = or i64 %43, -9223372036854775808
  br label %floatx80_round_pack_canonical.exit.sink.split

sw.default.i57:                                   ; preds = %parts128_addsub.exit
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1858, ptr noundef nonnull @__func__.floatx80_round_pack_canonical, ptr noundef null) #16
  unreachable

floatx80_round_pack_canonical.exit.sink.split:    ; preds = %parts128_addsub.exit, %if.end.i54, %parts128_addsub.exit.thread, %sw.bb16.i
  %arrayidx.i128.sink = phi ptr [ %arrayidx.i128, %sw.bb16.i ], [ %arrayidx.i113, %parts128_addsub.exit.thread ], [ %arrayidx.i122, %if.end.i54 ], [ %arrayidx.i, %parts128_addsub.exit ]
  %retval.i58.0114.ph = phi ptr [ %retval.i58.0127, %sw.bb16.i ], [ %pa, %parts128_addsub.exit.thread ], [ %retval.i58.0121, %if.end.i54 ], [ %retval.i58.0, %parts128_addsub.exit ]
  %frac.i.1.ph = phi i64 [ %or.i, %sw.bb16.i ], [ -9223372036854775808, %parts128_addsub.exit.thread ], [ -9223372036854775808, %if.end.i54 ], [ -9223372036854775808, %parts128_addsub.exit ]
  %exp_max18.i = getelementptr inbounds i8, ptr %arrayidx.i128.sink, i64 12
  %44 = load i32, ptr %exp_max18.i, align 4
  br label %floatx80_round_pack_canonical.exit

floatx80_round_pack_canonical.exit:               ; preds = %floatx80_round_pack_canonical.exit.sink.split, %parts128_addsub.exit, %if.end.i54
  %retval.i58.0114 = phi ptr [ %retval.i58.0121, %if.end.i54 ], [ %retval.i58.0, %parts128_addsub.exit ], [ %retval.i58.0114.ph, %floatx80_round_pack_canonical.exit.sink.split ]
  %exp.i46.1 = phi i32 [ %41, %if.end.i54 ], [ 0, %parts128_addsub.exit ], [ %44, %floatx80_round_pack_canonical.exit.sink.split ]
  %frac.i.1 = phi i64 [ %frac.i.0, %if.end.i54 ], [ 0, %parts128_addsub.exit ], [ %frac.i.1.ph, %floatx80_round_pack_canonical.exit.sink.split ]
  %sign19.i = getelementptr inbounds i8, ptr %retval.i58.0114, i64 1
  %45 = load i8, ptr %sign19.i, align 1
  %46 = zext i8 %45 to i32
  %shl.i108 = shl nuw nsw i32 %46, 15
  %add.i = add i32 %shl.i108, %exp.i46.1
  %conv2.i = trunc i32 %add.i to i16
  br label %return

return:                                           ; preds = %floatx80_unpack_canonical.exit42, %floatx80_unpack_canonical.exit, %floatx80_round_pack_canonical.exit
  %retval.sroa.0.0 = phi i64 [ %frac.i.1, %floatx80_round_pack_canonical.exit ], [ -4611686018427387904, %floatx80_unpack_canonical.exit ], [ -4611686018427387904, %floatx80_unpack_canonical.exit42 ]
  %retval.sroa.3.0 = phi i16 [ %conv2.i, %floatx80_round_pack_canonical.exit ], [ -1, %floatx80_unpack_canonical.exit ], [ -1, %floatx80_unpack_canonical.exit42 ]
  %.fca.0.insert = insertvalue { i64, i16 } poison, i64 %retval.sroa.0.0, 0
  %.fca.1.insert = insertvalue { i64, i16 } %.fca.0.insert, i16 %retval.sroa.3.0, 1
  ret { i64, i16 } %.fca.1.insert
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @floatx80_sub(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i16 } @floatx80_addsub(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr noundef %status, i1 noundef zeroext true)
  ret { i64, i16 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_mul(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts64, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %conv.i.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i16 %1, label %if.then33.i.i [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float16a_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float16a_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float16a_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit:                   ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %7 = phi i32 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %add.i.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ 31, %if.then47.i.i ], [ 31, %if.else49.i.i ]
  %a.val.i = phi i64 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i.i, %if.then33.i.i ], [ 0, %if.then47.i.i ], [ %shl.i31.i.i, %if.else49.i.i ]
  %8 = phi i8 [ 1, %if.then8.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ], [ 3, %if.then47.i.i ], [ %conv53.i.i, %if.else49.i.i ]
  %f.lobit.i.i40 = lshr i16 %b, 15
  %frombool.i.i.i41 = trunc i16 %f.lobit.i.i40 to i8
  %9 = lshr i16 %b, 10
  %10 = and i16 %9, 31
  %conv.i.i.i42 = zext nneg i16 %10 to i32
  %11 = and i16 %b, 1023
  %and.i10.i.i43 = zext nneg i16 %11 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i44 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i41, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i44, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i45 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i.i42, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i45, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i46 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i10.i.i43, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i46, align 8
  switch i16 %10, label %if.then33.i.i57 [
    i16 0, label %if.then.i.i61
    i16 31, label %lor.lhs.false.i.i50
  ]

if.then.i.i61:                                    ; preds = %float16a_unpack_canonical.exit
  %cmp.i.i.i62 = icmp eq i16 %11, 0
  br i1 %cmp.i.i.i62, label %if.then8.i.i73, label %if.else.i.i63

if.then8.i.i73:                                   ; preds = %if.then.i.i61
  store i8 1, ptr %pb, align 8
  br label %float16a_unpack_canonical.exit74

if.else.i.i63:                                    ; preds = %if.then.i.i61
  %flush_inputs_to_zero.i.i64 = getelementptr inbounds i8, ptr %status, i64 6
  %12 = load i8, ptr %flush_inputs_to_zero.i.i64, align 2
  %13 = and i8 %12, 1
  %tobool9.not.i.i65 = icmp eq i8 %13, 0
  br i1 %tobool9.not.i.i65, label %frac64_normalize.exit.i.i68, label %if.then10.i.i66

if.then10.i.i66:                                  ; preds = %if.else.i.i63
  %14 = load i16, ptr %status, align 2
  %or1.i.i.i67 = or i16 %14, 32
  store i16 %or1.i.i.i67, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i46, align 8
  br label %float16a_unpack_canonical.exit74

frac64_normalize.exit.i.i68:                      ; preds = %if.else.i.i63
  %15 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i43, i1 true), !range !5
  %cast.i.i.i.i69 = trunc i64 %15 to i32
  %shl.i.i.i70 = shl i64 %and.i10.i.i43, %15
  store i64 %shl.i.i.i70, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i46, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i72 = sub nsw i32 39, %cast.i.i.i.i69
  store i32 %add.i.i72, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i45, align 4
  br label %float16a_unpack_canonical.exit74

lor.lhs.false.i.i50:                              ; preds = %float16a_unpack_canonical.exit
  %cmp.i29.i.i51 = icmp eq i16 %11, 0
  br i1 %cmp.i29.i.i51, label %if.then47.i.i56, label %if.else49.i.i52

if.then33.i.i57:                                  ; preds = %float16a_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i58 = add nsw i32 %conv.i.i.i42, -15
  store i32 %sub37.i.i58, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i45, align 4
  %shl.i28.i.i59 = shl nuw nsw i64 %and.i10.i.i43, 53
  %or.i.i60 = or disjoint i64 %shl.i28.i.i59, -9223372036854775808
  store i64 %or.i.i60, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i46, align 8
  br label %float16a_unpack_canonical.exit74

if.then47.i.i56:                                  ; preds = %lor.lhs.false.i.i50
  store i8 3, ptr %pb, align 8
  br label %float16a_unpack_canonical.exit74

if.else49.i.i52:                                  ; preds = %lor.lhs.false.i.i50
  %shl.i31.i.i53 = shl nuw nsw i64 %and.i10.i.i43, 53
  store i64 %shl.i31.i.i53, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i46, align 8
  %tobool.not.i32.i.i54 = icmp ult i16 %11, 512
  %conv53.i.i55 = select i1 %tobool.not.i32.i.i54, i8 5, i8 4
  store i8 %conv53.i.i55, ptr %pb, align 8
  br label %float16a_unpack_canonical.exit74

float16a_unpack_canonical.exit74:                 ; preds = %if.then8.i.i73, %if.then10.i.i66, %frac64_normalize.exit.i.i68, %if.then33.i.i57, %if.then47.i.i56, %if.else49.i.i52
  %16 = phi i32 [ 0, %if.then8.i.i73 ], [ 0, %if.then10.i.i66 ], [ %add.i.i72, %frac64_normalize.exit.i.i68 ], [ %sub37.i.i58, %if.then33.i.i57 ], [ 31, %if.then47.i.i56 ], [ 31, %if.else49.i.i52 ]
  %b.val.i = phi i64 [ 0, %if.then8.i.i73 ], [ 0, %if.then10.i.i66 ], [ %shl.i.i.i70, %frac64_normalize.exit.i.i68 ], [ %or.i.i60, %if.then33.i.i57 ], [ 0, %if.then47.i.i56 ], [ %shl.i31.i.i53, %if.else49.i.i52 ]
  %.pr.i.pre = phi i8 [ 1, %if.then8.i.i73 ], [ 1, %if.then10.i.i66 ], [ 2, %frac64_normalize.exit.i.i68 ], [ 2, %if.then33.i.i57 ], [ 3, %if.then47.i.i56 ], [ %conv53.i.i55, %if.else49.i.i52 ]
  %conv.i = zext nneg i8 %8 to i32
  %shl.i = shl nuw nsw i32 1, %conv.i
  %conv2.i = zext nneg i8 %.pr.i.pre to i32
  %shl3.i = shl nuw nsw i32 1, %conv2.i
  %or.i = or i32 %shl.i, %shl3.i
  %17 = xor i8 %frombool.i.i.i41, %frombool.i.i.i
  %trunc = trunc i32 %or.i to i8
  switch i8 %trunc, label %if.end32.i [
    i8 4, label %if.then.i
    i8 10, label %if.then31.i
  ]

if.then.i:                                        ; preds = %float16a_unpack_canonical.exit74
  %conv.i.i = zext i64 %a.val.i to i128
  %conv1.i.i = zext i64 %b.val.i to i128
  %mul.i.i = mul nuw i128 %conv1.i.i, %conv.i.i
  %conv2.i.i = trunc i128 %mul.i.i to i64
  %shr.i.i = lshr i128 %mul.i.i, 64
  %conv3.i.i = trunc i128 %shr.i.i to i64
  %cmp.i = icmp ne i64 %conv2.i.i, 0
  %conv1.i = zext i1 %cmp.i to i64
  %or.i75 = or i64 %conv1.i, %conv3.i.i
  store i64 %or.i75, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %add.i = add nsw i32 %7, %16
  %add15.i = add nsw i32 %add.i, 1
  store i32 %add15.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %tobool16.i.not = icmp sgt i64 %or.i75, -1
  br i1 %tobool16.i.not, label %if.then17.i, label %if.end.i

if.then17.i:                                      ; preds = %if.then.i
  %18 = shl nuw i64 %or.i75, 1
  store i64 %18, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i32 %add.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then17.i, %if.then.i
  store i8 %17, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %parts64_mul.exit

if.then31.i:                                      ; preds = %float16a_unpack_canonical.exit74
  %19 = load i16, ptr %status, align 2
  %or1.i = or i16 %19, 257
  store i16 %or1.i, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_mul.exit

if.end32.i:                                       ; preds = %float16a_unpack_canonical.exit74
  %and33.i = and i32 %or.i, 48
  %tobool34.i.not = icmp eq i32 %and33.i, 0
  br i1 %tobool34.i.not, label %if.end43.i, label %if.then41.i

if.then41.i:                                      ; preds = %if.end32.i
  %cmp.i.i76 = icmp eq i8 %8, 5
  %cmp.i17.i = icmp eq i8 %.pr.i.pre, 5
  %or.cond = or i1 %cmp.i17.i, %cmp.i.i76
  br i1 %or.cond, label %if.then.i80, label %if.end.i77

if.then.i80:                                      ; preds = %if.then41.i
  %20 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %20, 8193
  store i16 %or1.i.i, ptr %status, align 2
  br label %if.end.i77

if.end.i77:                                       ; preds = %if.then41.i, %if.then.i80
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %21 = load i8, ptr %default_nan_mode.i, align 1
  %22 = and i8 %21, 1
  %tobool.not.i = icmp eq i8 %22, 0
  br i1 %tobool.not.i, label %if.else.i78, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i77
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_mul.exit

if.else.i78:                                      ; preds = %if.end.i77
  %cmp.i18.i = icmp eq i64 %a.val.i, %b.val.i
  %cmp1.i.i = icmp ult i64 %a.val.i, %b.val.i
  %cmp11.i = icmp uge i16 %f.lobit.i.i, %f.lobit.i.i40
  %spec.select = select i1 %cmp.i18.i, i1 %cmp11.i, i1 %cmp1.i.i
  %spec.select.fr = freeze i1 %spec.select
  switch i8 %8, label %23 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.else.i78
  br i1 %cmp.i17.i, label %parts64_mul.exit, label %lor.lhs.false.i.i79

lor.lhs.false.i.i79:                              ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select.i.i = and i1 %cmp.i11.i.i, %spec.select.fr
  %spec.select94 = select i1 %spec.select.i.i, ptr %pb, ptr %pa
  br label %parts64_mul.exit

pickNaN.exit.i:                                   ; preds = %if.else.i78
  %cmp.i8.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select20.i = select i1 %cmp.i17.i, i1 %spec.select.fr, i1 %cmp.i8.i.i
  br i1 %spec.select20.i, label %23, label %if.then24.i

23:                                               ; preds = %if.else.i78, %pickNaN.exit.i
  %24 = icmp eq i8 %.pr.i.pre, 5
  br i1 %24, label %if.then24.i, label %parts64_mul.exit

if.then24.i:                                      ; preds = %pickNaN.exit.i, %23
  %.ph.i89 = phi ptr [ %pb, %23 ], [ %pa, %pickNaN.exit.i ]
  %.ph.i89.sroa.phi = phi ptr [ %pb.sroa.gep, %23 ], [ %pa.sroa.gep, %pickNaN.exit.i ]
  %25 = load i64, ptr %.ph.i89.sroa.phi, align 8
  %or4.i.i.i = or i64 %25, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.ph.i89.sroa.phi, align 8
  store i8 4, ptr %.ph.i89, align 8
  br label %parts64_mul.exit

if.end43.i:                                       ; preds = %if.end32.i
  %and44.i = and i32 %or.i, 8
  %tobool45.i.not = icmp eq i32 %and44.i, 0
  br i1 %tobool45.i.not, label %if.end51.i, label %if.then46.i

if.then46.i:                                      ; preds = %if.end43.i
  store i8 3, ptr %pa, align 8
  store i8 %17, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %parts64_mul.exit

if.end51.i:                                       ; preds = %if.end43.i
  %and52.i = and i32 %or.i, 2
  %tobool53.i.not = icmp eq i32 %and52.i, 0
  br i1 %tobool53.i.not, label %if.else.i, label %if.then54.i

if.then54.i:                                      ; preds = %if.end51.i
  store i8 1, ptr %pa, align 8
  store i8 %17, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %parts64_mul.exit

if.else.i:                                        ; preds = %if.end51.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 460, ptr noundef nonnull @__func__.parts64_mul, ptr noundef nonnull @.str.7) #16
  unreachable

parts64_mul.exit:                                 ; preds = %lor.lhs.false.i.i79, %if.then24.i, %23, %if.then6.i.i, %if.then3.i, %if.then54.i, %if.then46.i, %if.then31.i, %if.end.i
  %retval.i.0 = phi ptr [ %pa, %if.end.i ], [ %pa, %if.then31.i ], [ %pa, %if.then46.i ], [ %pa, %if.then54.i ], [ %pa, %if.then3.i ], [ %.ph.i89, %if.then24.i ], [ %pb, %23 ], [ %pa, %if.then6.i.i ], [ %spec.select94, %lor.lhs.false.i.i79 ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %retval.i.0, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 1
  %26 = load i8, ptr %sign.i.i.i, align 1
  %conv.i.i.i81 = zext i8 %26 to i64
  %shl.i.i.i82 = shl nuw nsw i64 %conv.i.i.i81, 15
  %exp.i.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 4
  %27 = load i32, ptr %exp.i.i.i, align 4
  %28 = shl i32 %27, 10
  %29 = and i32 %28, 31744
  %and8.i.i.i = zext nneg i32 %29 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i82, %and8.i.i.i
  %30 = getelementptr inbounds i8, ptr %retval.i.0, i64 8
  %31 = load i64, ptr %30, align 8
  %shl77.i9.i.i = and i64 %31, 1023
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i83 = trunc i64 %or.i10.i.i to i16
  ret i16 %conv.i.i83
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @parts64_mul(ptr noundef %a, ptr noundef %b, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %0 = load i8, ptr %a, align 8
  %conv = zext nneg i8 %0 to i32
  %shl = shl nuw i32 1, %conv
  %1 = load i8, ptr %b, align 8
  %conv2 = zext nneg i8 %1 to i32
  %shl3 = shl nuw i32 1, %conv2
  %or = or i32 %shl3, %shl
  %sign4 = getelementptr inbounds i8, ptr %a, i64 1
  %2 = load i8, ptr %sign4, align 1
  %sign6 = getelementptr inbounds i8, ptr %b, i64 1
  %3 = load i8, ptr %sign6, align 1
  %4 = xor i8 %3, %2
  %xor33 = and i8 %4, 1
  switch i32 %or, label %if.end32 [
    i32 4, label %if.then
    i32 10, label %if.then31
  ]

if.then:                                          ; preds = %entry
  %5 = getelementptr i8, ptr %a, i64 8
  %a.val36 = load i64, ptr %5, align 8
  %6 = getelementptr i8, ptr %b, i64 8
  %b.val = load i64, ptr %6, align 8
  %conv.i.i = zext i64 %a.val36 to i128
  %conv1.i.i = zext i64 %b.val to i128
  %mul.i.i = mul nuw i128 %conv1.i.i, %conv.i.i
  %conv2.i.i = trunc i128 %mul.i.i to i64
  %shr.i.i = lshr i128 %mul.i.i, 64
  %conv3.i.i = trunc i128 %shr.i.i to i64
  %cmp.i = icmp ne i64 %conv2.i.i, 0
  %conv1.i = zext i1 %cmp.i to i64
  %or.i = or i64 %conv1.i, %conv3.i.i
  store i64 %or.i, ptr %5, align 8
  %exp = getelementptr inbounds i8, ptr %b, i64 4
  %7 = load i32, ptr %exp, align 4
  %exp14 = getelementptr inbounds i8, ptr %a, i64 4
  %8 = load i32, ptr %exp14, align 4
  %add = add i32 %8, %7
  %add15 = add i32 %add, 1
  store i32 %add15, ptr %exp14, align 4
  %tobool16.not = icmp sgt i64 %or.i, -1
  br i1 %tobool16.not, label %if.then17, label %if.end

if.then17:                                        ; preds = %if.then
  %9 = shl nuw i64 %or.i, 1
  store i64 %9, ptr %5, align 8
  store i32 %add, ptr %exp14, align 4
  br label %if.end

if.end:                                           ; preds = %if.then17, %if.then
  store i8 %xor33, ptr %sign4, align 1
  br label %return

if.then31:                                        ; preds = %entry
  %10 = load i16, ptr %s, align 2
  %or1.i = or i16 %10, 257
  store i16 %or1.i, ptr %s, align 2
  store i8 4, ptr %a, align 8
  store i8 0, ptr %sign4, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  br label %return

if.end32:                                         ; preds = %entry
  %and33 = and i32 %or, 48
  %tobool34.not = icmp eq i32 %and33, 0
  br i1 %tobool34.not, label %if.end43, label %if.then41

if.then41:                                        ; preds = %if.end32
  %cmp.i.i = icmp eq i8 %0, 5
  %cmp.i17.i = icmp eq i8 %1, 5
  %or.cond = or i1 %cmp.i.i, %cmp.i17.i
  br i1 %or.cond, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then41
  %11 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %11, 8193
  store i16 %or1.i.i, ptr %s, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %if.then41, %if.then.i
  %default_nan_mode.i = getelementptr inbounds i8, ptr %s, i64 7
  %12 = load i8, ptr %default_nan_mode.i, align 1
  %13 = and i8 %12, 1
  %tobool.not.i = icmp eq i8 %13, 0
  br i1 %tobool.not.i, label %if.else.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  store i8 4, ptr %a, align 8
  store i8 0, ptr %sign4, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  br label %return

if.else.i:                                        ; preds = %if.end.i
  %14 = getelementptr i8, ptr %a, i64 8
  %a.val.i = load i64, ptr %14, align 8
  %15 = getelementptr i8, ptr %b, i64 8
  %b.val.i = load i64, ptr %15, align 8
  %cmp.i18.i = icmp eq i64 %a.val.i, %b.val.i
  %cmp1.i.i = icmp ult i64 %a.val.i, %b.val.i
  br i1 %cmp.i18.i, label %if.then6.i, label %if.end13.i

if.then6.i:                                       ; preds = %if.else.i
  %16 = load i8, ptr %sign4, align 1
  %17 = and i8 %16, 1
  %18 = load i8, ptr %sign6, align 1
  %19 = and i8 %18, 1
  %cmp11.i = icmp uge i8 %17, %19
  br label %if.end13.i

if.end13.i:                                       ; preds = %if.then6.i, %if.else.i
  %cmp.0.i = phi i1 [ %cmp11.i, %if.then6.i ], [ %cmp1.i.i, %if.else.i ]
  %20 = load i8, ptr %a, align 8
  %21 = load i8, ptr %b, align 8
  switch i8 %20, label %22 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end13.i
  %cmp.i10.i.i = icmp eq i8 %21, 5
  br i1 %cmp.i10.i.i, label %return, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %21, 4
  %spec.select.i.i = and i1 %cmp.0.i, %cmp.i11.i.i
  %cond.fr26.i = freeze i1 %spec.select.i.i
  %spec.select = select i1 %cond.fr26.i, ptr %b, ptr %a
  br label %return

pickNaN.exit.i:                                   ; preds = %if.end13.i
  %cmp.i7.i.i = icmp eq i8 %21, 5
  %cmp.i8.i.i = icmp eq i8 %21, 4
  %spec.select20.i = select i1 %cmp.i7.i.i, i1 %cmp.0.i, i1 %cmp.i8.i.i
  %cond.fr.i = freeze i1 %spec.select20.i
  br i1 %cond.fr.i, label %22, label %if.then24.i

22:                                               ; preds = %if.end13.i, %pickNaN.exit.i
  %23 = icmp eq i8 %21, 5
  br i1 %23, label %if.then24.i, label %return

if.then24.i:                                      ; preds = %pickNaN.exit.i, %22
  %.ph.i40 = phi ptr [ %b, %22 ], [ %a, %pickNaN.exit.i ]
  %24 = getelementptr inbounds i8, ptr %.ph.i40, i64 8
  %25 = load i64, ptr %24, align 8
  %or4.i.i.i = or i64 %25, 4611686018427387904
  store i64 %or4.i.i.i, ptr %24, align 8
  store i8 4, ptr %.ph.i40, align 8
  br label %return

if.end43:                                         ; preds = %if.end32
  %and44 = and i32 %or, 8
  %tobool45.not = icmp eq i32 %and44, 0
  br i1 %tobool45.not, label %do.body, label %if.then46

if.then46:                                        ; preds = %if.end43
  store i8 3, ptr %a, align 8
  store i8 %xor33, ptr %sign4, align 1
  br label %return

do.body:                                          ; preds = %if.end43
  %and52 = and i32 %or, 2
  %tobool53.not = icmp eq i32 %and52, 0
  br i1 %tobool53.not, label %if.else, label %do.end

if.else:                                          ; preds = %do.body
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 460, ptr noundef nonnull @__func__.parts64_mul, ptr noundef nonnull @.str.7) #16
  unreachable

do.end:                                           ; preds = %do.body
  store i8 1, ptr %a, align 8
  store i8 %xor33, ptr %sign4, align 1
  br label %return

return:                                           ; preds = %lor.lhs.false.i.i, %if.then24.i, %22, %if.then6.i.i, %if.then3.i, %do.end, %if.then46, %if.then31, %if.end
  %retval.0 = phi ptr [ %a, %if.end ], [ %a, %if.then31 ], [ %a, %if.then46 ], [ %a, %do.end ], [ %a, %if.then3.i ], [ %.ph.i40, %if.then24.i ], [ %b, %22 ], [ %a, %if.then6.i.i ], [ %spec.select, %lor.lhs.false.i.i ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_mul(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %pa.i = alloca %struct.FloatParts64, align 8
  %pa.i.sroa.gep = getelementptr inbounds i8, ptr %pa.i, i64 8
  %pb.i = alloca %struct.FloatParts64, align 8
  %pb.i.sroa.gep = getelementptr inbounds i8, ptr %pb.i, i64 8
  %0 = load i16, ptr %s, align 2
  %1 = and i16 %0, 16
  %tobool.not.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i, label %soft39.i, label %can_use_fpu.exit

can_use_fpu.exit:                                 ; preds = %entry
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %s, i64 2
  %2 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp.i5 = icmp eq i8 %2, 0
  br i1 %cmp.i5, label %if.end.i, label %soft39.i

if.end.i:                                         ; preds = %can_use_fpu.exit
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool.not.i6 = icmp eq i8 %4, 0
  br i1 %tobool.not.i6, label %float32_input_flush2.exit, label %if.end.i7

if.end.i7:                                        ; preds = %if.end.i
  %and.i.i.i.i = and i32 %a, 2139095040
  %cmp.i.i.i.i = icmp eq i32 %and.i.i.i.i, 0
  %and.i2.i.i.i = and i32 %a, 2147483647
  %cmp.i3.i.i.i = icmp ne i32 %and.i2.i.i.i, 0
  %5 = and i1 %cmp.i.i.i.i, %cmp.i3.i.i.i
  %.lobit.i.i = and i32 %a, -2147483648
  %or1.i.i.i = or i16 %0, 32
  %ua.i.sroa.0.0 = select i1 %5, i32 %.lobit.i.i, i32 %a
  %and.i.i.i3.i = and i32 %b, 2139095040
  %cmp.i.i.i4.i = icmp eq i32 %and.i.i.i3.i, 0
  %and.i2.i.i5.i = and i32 %b, 2147483647
  %cmp.i3.i.i6.i = icmp ne i32 %and.i2.i.i5.i, 0
  %6 = and i1 %cmp.i.i.i4.i, %cmp.i3.i.i6.i
  %.lobit.i8.i = and i32 %b, -2147483648
  %7 = or i1 %6, %5
  %.ph = select i1 %7, i16 %or1.i.i.i, i16 %0
  %ub.i.sroa.0.0.ph = select i1 %6, i32 %.lobit.i8.i, i32 %b
  %8 = or i1 %5, %6
  br i1 %8, label %9, label %float32_input_flush2.exit

9:                                                ; preds = %if.end.i7
  store i16 %.ph, ptr %s, align 2
  br label %float32_input_flush2.exit

float32_input_flush2.exit:                        ; preds = %9, %if.end.i7, %if.end.i
  %10 = phi i16 [ %0, %if.end.i ], [ %.ph, %if.end.i7 ], [ %.ph, %9 ]
  %ua.i.sroa.0.1 = phi i32 [ %a, %if.end.i ], [ %ua.i.sroa.0.0, %if.end.i7 ], [ %ua.i.sroa.0.0, %9 ]
  %ub.i.sroa.0.0 = phi i32 [ %b, %if.end.i ], [ %ub.i.sroa.0.0.ph, %if.end.i7 ], [ %ub.i.sroa.0.0.ph, %9 ]
  %shr.i.i.i = lshr i32 %ua.i.sroa.0.1, 23
  %add.i.i.i = add nuw nsw i32 %shr.i.i.i, 1
  %and.i.i.i = and i32 %add.i.i.i, 254
  %cmp.i.i.i = icmp ne i32 %and.i.i.i, 0
  %and.i2.i.i = and i32 %ua.i.sroa.0.1, 2147483647
  %cmp.i3.i.i = icmp eq i32 %and.i2.i.i, 0
  %11 = or i1 %cmp.i3.i.i, %cmp.i.i.i
  br i1 %11, label %f32_is_zon2.exit, label %soft39.i

f32_is_zon2.exit:                                 ; preds = %float32_input_flush2.exit
  %shr.i.i1.i = lshr i32 %ub.i.sroa.0.0, 23
  %add.i.i2.i = add nuw nsw i32 %shr.i.i1.i, 1
  %and.i.i3.i = and i32 %add.i.i2.i, 254
  %cmp.i.i4.i = icmp ne i32 %and.i.i3.i, 0
  %and.i2.i5.i = and i32 %ub.i.sroa.0.0, 2147483647
  %cmp.i3.i6.i = icmp eq i32 %and.i2.i5.i, 0
  %12 = or i1 %cmp.i3.i6.i, %cmp.i.i4.i
  br i1 %12, label %if.end14.i, label %soft39.i

if.end14.i:                                       ; preds = %f32_is_zon2.exit
  %13 = bitcast i32 %ua.i.sroa.0.1 to float
  %14 = bitcast i32 %ub.i.sroa.0.0 to float
  %mul.i = fmul float %13, %14
  %15 = bitcast float %mul.i to i32
  %16 = tail call float @llvm.fabs.f32(float %mul.i) #17
  %isinf.i = fcmp oeq float %16, 0x7FF0000000000000
  br i1 %isinf.i, label %if.then24.i, label %if.else.i

if.then24.i:                                      ; preds = %if.end14.i
  %or1.i = or i16 %10, 4
  store i16 %or1.i, ptr %s, align 2
  br label %float32_gen2.exit

if.else.i:                                        ; preds = %if.end14.i
  %cmp.i = fcmp ugt float %16, 0x3810000000000000
  br i1 %cmp.i, label %float32_gen2.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.else.i
  %17 = or i32 %ub.i.sroa.0.0, %ua.i.sroa.0.1
  %18 = and i32 %17, 2147483647
  %lnot.i.not = icmp eq i32 %18, 0
  br i1 %lnot.i.not, label %float32_gen2.exit, label %soft39.i

soft39.i:                                         ; preds = %float32_input_flush2.exit, %entry, %land.lhs.true.i, %f32_is_zon2.exit, %can_use_fpu.exit
  %19 = phi i16 [ %10, %land.lhs.true.i ], [ %10, %f32_is_zon2.exit ], [ %0, %can_use_fpu.exit ], [ %0, %entry ], [ %10, %float32_input_flush2.exit ]
  %ua.i.sroa.0.2 = phi i32 [ %ua.i.sroa.0.1, %land.lhs.true.i ], [ %ua.i.sroa.0.1, %f32_is_zon2.exit ], [ %a, %can_use_fpu.exit ], [ %a, %entry ], [ %ua.i.sroa.0.1, %float32_input_flush2.exit ]
  %ub.i.sroa.0.1 = phi i32 [ %ub.i.sroa.0.0, %land.lhs.true.i ], [ %ub.i.sroa.0.0, %f32_is_zon2.exit ], [ %b, %can_use_fpu.exit ], [ %b, %entry ], [ %ub.i.sroa.0.0, %float32_input_flush2.exit ]
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %pa.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %pb.i)
  %f.lobit.i.i = lshr i32 %ua.i.sroa.0.2, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %ua.i.sroa.0.2, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %20 = and i32 %ua.i.sroa.0.2, 8388607
  %and.i10.i.i = zext nneg i32 %20 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa.i, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa.i, i64 4
  store i32 %and.i9.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 %and.i10.i.i, ptr %pa.i.sroa.gep, align 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %if.then33.i.i [
    i8 0, label %if.then.i45.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i45.i:                                    ; preds = %soft39.i
  %cmp.i.i.i11 = icmp eq i32 %20, 0
  br i1 %cmp.i.i.i11, label %if.then8.i.i, label %if.else.i46.i

if.then8.i.i:                                     ; preds = %if.then.i45.i
  store i8 1, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

if.else.i46.i:                                    ; preds = %if.then.i45.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %21 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %22 = and i8 %21, 1
  %tobool9.not.i.i = icmp eq i8 %22, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i46.i
  %or1.i.i.i12 = or i16 %19, 32
  store i16 %or1.i.i.i12, ptr %s, align 2
  store i8 1, ptr %pa.i, align 8
  store i64 0, ptr %pa.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit.i

frac64_normalize.exit.i.i:                        ; preds = %if.else.i46.i
  %23 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %23 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %23
  store i64 %shl.i.i.i, ptr %pa.i.sroa.gep, align 8
  store i8 2, ptr %pa.i, align 8
  %add.i47.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i47.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_canonicalize.exit.i

lor.lhs.false.i.i:                                ; preds = %soft39.i
  %cmp.i29.i.i = icmp eq i32 %20, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %soft39.i
  store i8 2, ptr %pa.i, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i44.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i44.i, ptr %pa.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %pa.i.sroa.gep, align 8
  %tobool.not.i32.i.i = icmp ult i32 %20, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

parts64_canonicalize.exit.i:                      ; preds = %if.else49.i.i, %if.then47.i.i, %if.then33.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then8.i.i
  %24 = phi i16 [ %19, %if.then8.i.i ], [ %or1.i.i.i12, %if.then10.i.i ], [ %19, %frac64_normalize.exit.i.i ], [ %19, %if.then33.i.i ], [ %19, %if.then47.i.i ], [ %19, %if.else49.i.i ]
  %25 = phi i32 [ %and.i9.i.i, %if.then8.i.i ], [ %and.i9.i.i, %if.then10.i.i ], [ %add.i47.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ %and.i9.i.i, %if.then47.i.i ], [ %and.i9.i.i, %if.else49.i.i ]
  %a.val.i.i = phi i64 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i44.i, %if.then33.i.i ], [ 0, %if.then47.i.i ], [ %shl.i31.i.i, %if.else49.i.i ]
  %26 = phi i8 [ 1, %if.then8.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ], [ 3, %if.then47.i.i ], [ %conv53.i.i, %if.else49.i.i ]
  %f.lobit.i48.i = lshr i32 %ub.i.sroa.0.1, 31
  %frombool.i.i49.i = trunc i32 %f.lobit.i48.i to i8
  %shr.i8.i50.i = lshr i32 %ub.i.sroa.0.1, 23
  %and.i9.i51.i = and i32 %shr.i8.i50.i, 255
  %27 = and i32 %ub.i.sroa.0.1, 8388607
  %and.i10.i52.i = zext nneg i32 %27 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i53.i = getelementptr inbounds i8, ptr %pb.i, i64 1
  store i8 %frombool.i.i49.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i53.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i54.i = getelementptr inbounds i8, ptr %pb.i, i64 4
  store i32 %and.i9.i51.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i54.i, align 4
  store i64 %and.i10.i52.i, ptr %pb.i.sroa.gep, align 8
  %trunc98.i = trunc i32 %shr.i8.i50.i to i8
  switch i8 %trunc98.i, label %if.then33.i68.i [
    i8 0, label %if.then.i72.i
    i8 -1, label %lor.lhs.false.i60.i
  ]

if.then.i72.i:                                    ; preds = %parts64_canonicalize.exit.i
  %cmp.i.i74.i = icmp eq i32 %27, 0
  br i1 %cmp.i.i74.i, label %if.then8.i85.i, label %if.else.i75.i

if.then8.i85.i:                                   ; preds = %if.then.i72.i
  store i8 1, ptr %pb.i, align 8
  br label %parts64_canonicalize.exit86.i

if.else.i75.i:                                    ; preds = %if.then.i72.i
  %flush_inputs_to_zero.i76.i = getelementptr inbounds i8, ptr %s, i64 6
  %28 = load i8, ptr %flush_inputs_to_zero.i76.i, align 2
  %29 = and i8 %28, 1
  %tobool9.not.i77.i = icmp eq i8 %29, 0
  br i1 %tobool9.not.i77.i, label %frac64_normalize.exit.i80.i, label %if.then10.i78.i

if.then10.i78.i:                                  ; preds = %if.else.i75.i
  %or1.i.i79.i = or i16 %24, 32
  store i16 %or1.i.i79.i, ptr %s, align 2
  store i8 1, ptr %pb.i, align 8
  store i64 0, ptr %pb.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit86.i

frac64_normalize.exit.i80.i:                      ; preds = %if.else.i75.i
  %30 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i52.i, i1 true), !range !5
  %cast.i.i.i81.i = trunc i64 %30 to i32
  %shl.i.i82.i = shl i64 %and.i10.i52.i, %30
  store i64 %shl.i.i82.i, ptr %pb.i.sroa.gep, align 8
  store i8 2, ptr %pb.i, align 8
  %add.i84.i = sub nuw nsw i32 -86, %cast.i.i.i81.i
  store i32 %add.i84.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i54.i, align 4
  br label %parts64_canonicalize.exit86.i

lor.lhs.false.i60.i:                              ; preds = %parts64_canonicalize.exit.i
  %cmp.i29.i62.i = icmp eq i32 %27, 0
  br i1 %cmp.i29.i62.i, label %if.then47.i67.i, label %if.else49.i63.i

if.then33.i68.i:                                  ; preds = %parts64_canonicalize.exit.i
  store i8 2, ptr %pb.i, align 8
  %sub37.i69.i = add nsw i32 %and.i9.i51.i, -127
  store i32 %sub37.i69.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i54.i, align 4
  %shl.i28.i70.i = shl nuw nsw i64 %and.i10.i52.i, 40
  %or.i71.i = or disjoint i64 %shl.i28.i70.i, -9223372036854775808
  store i64 %or.i71.i, ptr %pb.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit86.i

if.then47.i67.i:                                  ; preds = %lor.lhs.false.i60.i
  store i8 3, ptr %pb.i, align 8
  br label %parts64_canonicalize.exit86.i

if.else49.i63.i:                                  ; preds = %lor.lhs.false.i60.i
  %shl.i31.i64.i = shl nuw nsw i64 %and.i10.i52.i, 40
  store i64 %shl.i31.i64.i, ptr %pb.i.sroa.gep, align 8
  %tobool.not.i32.i65.i = icmp ult i32 %27, 4194304
  %conv53.i66.i = select i1 %tobool.not.i32.i65.i, i8 5, i8 4
  store i8 %conv53.i66.i, ptr %pb.i, align 8
  br label %parts64_canonicalize.exit86.i

parts64_canonicalize.exit86.i:                    ; preds = %if.else49.i63.i, %if.then47.i67.i, %if.then33.i68.i, %frac64_normalize.exit.i80.i, %if.then10.i78.i, %if.then8.i85.i
  %31 = phi i64 [ 0, %if.then8.i85.i ], [ 0, %if.then10.i78.i ], [ %shl.i.i82.i, %frac64_normalize.exit.i80.i ], [ %or.i71.i, %if.then33.i68.i ], [ 0, %if.then47.i67.i ], [ %shl.i31.i64.i, %if.else49.i63.i ]
  %32 = phi i16 [ %24, %if.then8.i85.i ], [ %or1.i.i79.i, %if.then10.i78.i ], [ %24, %frac64_normalize.exit.i80.i ], [ %24, %if.then33.i68.i ], [ %24, %if.then47.i67.i ], [ %24, %if.else49.i63.i ]
  %33 = phi i32 [ %and.i9.i51.i, %if.then8.i85.i ], [ %and.i9.i51.i, %if.then10.i78.i ], [ %add.i84.i, %frac64_normalize.exit.i80.i ], [ %sub37.i69.i, %if.then33.i68.i ], [ %and.i9.i51.i, %if.then47.i67.i ], [ %and.i9.i51.i, %if.else49.i63.i ]
  %.pr.i.pre.i = phi i8 [ 1, %if.then8.i85.i ], [ 1, %if.then10.i78.i ], [ 2, %frac64_normalize.exit.i80.i ], [ 2, %if.then33.i68.i ], [ 3, %if.then47.i67.i ], [ %conv53.i66.i, %if.else49.i63.i ]
  %conv.i.i = zext nneg i8 %26 to i32
  %shl.i.i = shl nuw nsw i32 1, %conv.i.i
  %conv2.i.i = zext nneg i8 %.pr.i.pre.i to i32
  %shl3.i.i = shl nuw nsw i32 1, %conv2.i.i
  %or.i.i = or i32 %shl3.i.i, %shl.i.i
  %34 = xor i8 %frombool.i.i49.i, %frombool.i.i.i
  %trunc102.i = trunc i32 %or.i.i to i8
  switch i8 %trunc102.i, label %if.end32.i.i [
    i8 4, label %if.then.i.i9
    i8 10, label %if.then31.i.i
  ]

if.then.i.i9:                                     ; preds = %parts64_canonicalize.exit86.i
  %conv.i.i.i = zext i64 %a.val.i.i to i128
  %conv1.i.i.i = zext i64 %31 to i128
  %mul.i.i.i = mul nuw i128 %conv1.i.i.i, %conv.i.i.i
  %conv2.i.i.i = trunc i128 %mul.i.i.i to i64
  %shr.i.i.i10 = lshr i128 %mul.i.i.i, 64
  %conv3.i.i.i = trunc i128 %shr.i.i.i10 to i64
  %cmp.i87.i = icmp ne i64 %conv2.i.i.i, 0
  %conv1.i.i = zext i1 %cmp.i87.i to i64
  %or.i88.i = or i64 %conv1.i.i, %conv3.i.i.i
  store i64 %or.i88.i, ptr %pa.i.sroa.gep, align 8
  %add.i.i = add nsw i32 %33, %25
  %add15.i.i = add nsw i32 %add.i.i, 1
  store i32 %add15.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %tobool16.i.not.i = icmp sgt i64 %or.i88.i, -1
  br i1 %tobool16.i.not.i, label %if.then17.i.i, label %if.end.i.i

if.then17.i.i:                                    ; preds = %if.then.i.i9
  %35 = shl nuw i64 %or.i88.i, 1
  store i64 %35, ptr %pa.i.sroa.gep, align 8
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then17.i.i, %if.then.i.i9
  store i8 %34, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %soft_f32_mul.exit

if.then31.i.i:                                    ; preds = %parts64_canonicalize.exit86.i
  %or1.i.i = or i16 %32, 257
  store i16 %or1.i.i, ptr %s, align 2
  store i8 4, ptr %pa.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.i.sroa.gep, align 8
  br label %soft_f32_mul.exit

if.end32.i.i:                                     ; preds = %parts64_canonicalize.exit86.i
  %and33.i.i = and i32 %or.i.i, 48
  %tobool34.i.not.i = icmp eq i32 %and33.i.i, 0
  br i1 %tobool34.i.not.i, label %if.end43.i.i, label %if.then41.i.i

if.then41.i.i:                                    ; preds = %if.end32.i.i
  %cmp.i.i89.i = icmp eq i8 %26, 5
  %cmp.i17.i.i = icmp eq i8 %.pr.i.pre.i, 5
  %or.cond.i = or i1 %cmp.i.i89.i, %cmp.i17.i.i
  br i1 %or.cond.i, label %if.then.i93.i, label %if.end.i91.i

if.then.i93.i:                                    ; preds = %if.then41.i.i
  %or1.i.i94.i = or i16 %32, 8193
  store i16 %or1.i.i94.i, ptr %s, align 2
  br label %if.end.i91.i

if.end.i91.i:                                     ; preds = %if.then.i93.i, %if.then41.i.i
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %36 = load i8, ptr %default_nan_mode.i.i, align 1
  %37 = and i8 %36, 1
  %tobool.not.i.i = icmp eq i8 %37, 0
  br i1 %tobool.not.i.i, label %if.else.i92.i, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.end.i91.i
  store i8 4, ptr %pa.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.i.sroa.gep, align 8
  br label %soft_f32_mul.exit

if.else.i92.i:                                    ; preds = %if.end.i91.i
  %cmp.i18.i.i = icmp eq i64 %a.val.i.i, %31
  %cmp1.i.i.i = icmp ult i64 %a.val.i.i, %31
  %cmp11.i.i = icmp uge i32 %f.lobit.i.i, %f.lobit.i48.i
  %spec.select.i = select i1 %cmp.i18.i.i, i1 %cmp11.i.i, i1 %cmp1.i.i.i
  %spec.select.fr.i = freeze i1 %spec.select.i
  switch i8 %26, label %38 [
    i8 5, label %pickNaN.exit.i.i
    i8 4, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.else.i92.i
  br i1 %cmp.i17.i.i, label %soft_f32_mul.exit, label %lor.lhs.false.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %if.then6.i.i.i
  %cmp.i11.i.i.i = icmp eq i8 %.pr.i.pre.i, 4
  %spec.select.i.i.i = and i1 %cmp.i11.i.i.i, %spec.select.fr.i
  %spec.select110.i = select i1 %spec.select.i.i.i, ptr %pb.i, ptr %pa.i
  br label %soft_f32_mul.exit

pickNaN.exit.i.i:                                 ; preds = %if.else.i92.i
  %cmp.i8.i.i.i = icmp eq i8 %.pr.i.pre.i, 4
  %spec.select20.i.i = select i1 %cmp.i17.i.i, i1 %spec.select.fr.i, i1 %cmp.i8.i.i.i
  %spec.select20.i.i.not = xor i1 %spec.select20.i.i, true
  %brmerge = or i1 %cmp.i17.i.i, %spec.select20.i.i.not
  br i1 %brmerge, label %pickNaN.exit.i.i.if.then24.i.i_crit_edge, label %soft_f32_mul.exit

pickNaN.exit.i.i.if.then24.i.i_crit_edge:         ; preds = %pickNaN.exit.i.i
  %pa.i.sroa.gep.mux = select i1 %spec.select20.i.i, ptr %pb.i.sroa.gep, ptr %pa.i.sroa.gep
  %pa.i.mux = select i1 %spec.select20.i.i, ptr %pb.i, ptr %pa.i
  %.pre = load i64, ptr %pa.i.sroa.gep.mux, align 8
  br label %if.then24.i.i

38:                                               ; preds = %if.else.i92.i
  br i1 %cmp.i17.i.i, label %if.then24.i.i, label %soft_f32_mul.exit

if.then24.i.i:                                    ; preds = %pickNaN.exit.i.i.if.then24.i.i_crit_edge, %38
  %39 = phi i64 [ %31, %38 ], [ %.pre, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i105.i = phi ptr [ %pb.i, %38 ], [ %pa.i.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i105.i.sroa.phi = phi ptr [ %pb.i.sroa.gep, %38 ], [ %pa.i.sroa.gep.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %or4.i.i.i.i = or i64 %39, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.ph.i105.i.sroa.phi, align 8
  store i8 4, ptr %.ph.i105.i, align 8
  br label %soft_f32_mul.exit

if.end43.i.i:                                     ; preds = %if.end32.i.i
  %and44.i.i = and i32 %or.i.i, 8
  %tobool45.i.not.i = icmp eq i32 %and44.i.i, 0
  br i1 %tobool45.i.not.i, label %if.end51.i.i, label %if.then46.i.i

if.then46.i.i:                                    ; preds = %if.end43.i.i
  store i8 3, ptr %pa.i, align 8
  store i8 %34, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %soft_f32_mul.exit

if.end51.i.i:                                     ; preds = %if.end43.i.i
  %and52.i.i = and i32 %or.i.i, 2
  %tobool53.i.not.i = icmp eq i32 %and52.i.i, 0
  br i1 %tobool53.i.not.i, label %if.else.i.i, label %if.then54.i.i

if.then54.i.i:                                    ; preds = %if.end51.i.i
  store i8 1, ptr %pa.i, align 8
  store i8 %34, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %soft_f32_mul.exit

if.else.i.i:                                      ; preds = %if.end51.i.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 460, ptr noundef nonnull @__func__.parts64_mul, ptr noundef nonnull @.str.7) #16
  unreachable

soft_f32_mul.exit:                                ; preds = %pickNaN.exit.i.i, %if.end.i.i, %if.then31.i.i, %if.then3.i.i, %if.then6.i.i.i, %lor.lhs.false.i.i.i, %38, %if.then24.i.i, %if.then46.i.i, %if.then54.i.i
  %retval.i.0.i = phi ptr [ %pa.i, %if.end.i.i ], [ %pa.i, %if.then31.i.i ], [ %pa.i, %if.then46.i.i ], [ %pa.i, %if.then54.i.i ], [ %pa.i, %if.then3.i.i ], [ %.ph.i105.i, %if.then24.i.i ], [ %pb.i, %38 ], [ %pa.i, %if.then6.i.i.i ], [ %spec.select110.i, %lor.lhs.false.i.i.i ], [ %pb.i, %pickNaN.exit.i.i ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %retval.i.0.i, ptr noundef nonnull %s, ptr noundef nonnull @float32_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %retval.i.0.i, i64 1
  %40 = load i8, ptr %sign.i.i.i, align 1
  %conv.i.i95.i = zext i8 %40 to i64
  %shl.i.i96.i = shl nuw nsw i64 %conv.i.i95.i, 31
  %exp.i.i.i = getelementptr inbounds i8, ptr %retval.i.0.i, i64 4
  %41 = load i32, ptr %exp.i.i.i, align 4
  %42 = shl i32 %41, 23
  %43 = and i32 %42, 2139095040
  %and8.i.i.i = zext nneg i32 %43 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i96.i, %and8.i.i.i
  %44 = getelementptr inbounds i8, ptr %retval.i.0.i, i64 8
  %45 = load i64, ptr %44, align 8
  %shl77.i9.i.i = and i64 %45, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i97.i = trunc i64 %or.i10.i.i to i32
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %pa.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %pb.i)
  br label %float32_gen2.exit

float32_gen2.exit:                                ; preds = %if.then24.i, %land.lhs.true.i, %if.else.i, %soft_f32_mul.exit
  %retval.i.0 = phi i32 [ %conv.i97.i, %soft_f32_mul.exit ], [ %15, %if.else.i ], [ %15, %land.lhs.true.i ], [ %15, %if.then24.i ]
  ret i32 %retval.i.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_mul(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %pa.i = alloca %struct.FloatParts64, align 8
  %pa.i.sroa.gep = getelementptr inbounds i8, ptr %pa.i, i64 8
  %pb.i = alloca %struct.FloatParts64, align 8
  %pb.i.sroa.gep = getelementptr inbounds i8, ptr %pb.i, i64 8
  %0 = load i16, ptr %s, align 2
  %1 = and i16 %0, 16
  %tobool.not.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i, label %soft39.i, label %can_use_fpu.exit

can_use_fpu.exit:                                 ; preds = %entry
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %s, i64 2
  %2 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp.i5 = icmp eq i8 %2, 0
  br i1 %cmp.i5, label %if.end.i, label %soft39.i

if.end.i:                                         ; preds = %can_use_fpu.exit
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool.not.i6 = icmp eq i8 %4, 0
  br i1 %tobool.not.i6, label %float64_input_flush2.exit, label %if.end.i7

if.end.i7:                                        ; preds = %if.end.i
  %and.i.i.i.i = and i64 %a, 9218868437227405312
  %cmp.i.i.i.i = icmp eq i64 %and.i.i.i.i, 0
  %and.i2.i.i.i = and i64 %a, 9223372036854775807
  %cmp.i3.i.i.i = icmp ne i64 %and.i2.i.i.i, 0
  %5 = and i1 %cmp.i.i.i.i, %cmp.i3.i.i.i
  %.lobit.i.i = and i64 %a, -9223372036854775808
  %or1.i.i.i = or i16 %0, 32
  %ua.i.sroa.0.0 = select i1 %5, i64 %.lobit.i.i, i64 %a
  %and.i.i.i3.i = and i64 %b, 9218868437227405312
  %cmp.i.i.i4.i = icmp eq i64 %and.i.i.i3.i, 0
  %and.i2.i.i5.i = and i64 %b, 9223372036854775807
  %cmp.i3.i.i6.i = icmp ne i64 %and.i2.i.i5.i, 0
  %6 = and i1 %cmp.i.i.i4.i, %cmp.i3.i.i6.i
  %.lobit.i8.i = and i64 %b, -9223372036854775808
  %7 = or i1 %6, %5
  %.ph = select i1 %7, i16 %or1.i.i.i, i16 %0
  %ub.i.sroa.0.0.ph = select i1 %6, i64 %.lobit.i8.i, i64 %b
  %8 = or i1 %5, %6
  br i1 %8, label %9, label %float64_input_flush2.exit

9:                                                ; preds = %if.end.i7
  store i16 %.ph, ptr %s, align 2
  br label %float64_input_flush2.exit

float64_input_flush2.exit:                        ; preds = %9, %if.end.i7, %if.end.i
  %10 = phi i16 [ %0, %if.end.i ], [ %.ph, %if.end.i7 ], [ %.ph, %9 ]
  %ua.i.sroa.0.1 = phi i64 [ %a, %if.end.i ], [ %ua.i.sroa.0.0, %if.end.i7 ], [ %ua.i.sroa.0.0, %9 ]
  %ub.i.sroa.0.0 = phi i64 [ %b, %if.end.i ], [ %ub.i.sroa.0.0.ph, %if.end.i7 ], [ %ub.i.sroa.0.0.ph, %9 ]
  %11 = bitcast i64 %ua.i.sroa.0.1 to double
  %or.cond.i = fcmp ueq double %11, 0.000000e+00
  br i1 %or.cond.i, label %lor.lhs.false.i, label %fpclassify_not_nan.i

lor.lhs.false.i:                                  ; preds = %float64_input_flush2.exit
  %iszero.i = fcmp oeq double %11, 0.000000e+00
  br i1 %iszero.i, label %land.rhs.i8, label %soft39.i

fpclassify_not_nan.i:                             ; preds = %float64_input_flush2.exit
  %or.cond13.i = tail call i1 @llvm.is.fpclass.f64(double %11, i32 267)
  br i1 %or.cond13.i, label %land.rhs.i8, label %soft39.i

land.rhs.i8:                                      ; preds = %fpclassify_not_nan.i, %lor.lhs.false.i
  %12 = bitcast i64 %ub.i.sroa.0.0 to double
  %iszero15.i = fcmp oeq double %12, 0.000000e+00
  %or.cond10.i = fcmp ueq double %12, 0.000000e+00
  br i1 %or.cond10.i, label %f64_is_zon2.exit, label %fpclassify_not_nan18.i

fpclassify_not_nan18.i:                           ; preds = %land.rhs.i8
  %or.cond14.i = tail call i1 @llvm.is.fpclass.f64(double %12, i32 267)
  %brmerge = or i1 %or.cond14.i, %iszero15.i
  br i1 %brmerge, label %if.end14.i, label %soft39.i

f64_is_zon2.exit:                                 ; preds = %land.rhs.i8
  br i1 %iszero15.i, label %if.end14.i, label %soft39.i

if.end14.i:                                       ; preds = %fpclassify_not_nan18.i, %f64_is_zon2.exit
  %mul.i = fmul double %11, %12
  %13 = bitcast double %mul.i to i64
  %14 = tail call double @llvm.fabs.f64(double %mul.i) #17
  %isinf.i = fcmp oeq double %14, 0x7FF0000000000000
  br i1 %isinf.i, label %if.then24.i, label %if.else.i

if.then24.i:                                      ; preds = %if.end14.i
  %or1.i = or i16 %10, 4
  store i16 %or1.i, ptr %s, align 2
  br label %float64_gen2.exit

if.else.i:                                        ; preds = %if.end14.i
  %cmp.i = fcmp ugt double %14, 0x10000000000000
  br i1 %cmp.i, label %float64_gen2.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.else.i
  %15 = or i64 %ub.i.sroa.0.0, %ua.i.sroa.0.1
  %16 = and i64 %15, 9223372036854775807
  %lnot.i.not = icmp eq i64 %16, 0
  br i1 %lnot.i.not, label %float64_gen2.exit, label %soft39.i

soft39.i:                                         ; preds = %fpclassify_not_nan18.i, %lor.lhs.false.i, %fpclassify_not_nan.i, %entry, %land.lhs.true.i, %f64_is_zon2.exit, %can_use_fpu.exit
  %17 = phi i16 [ %10, %land.lhs.true.i ], [ %10, %f64_is_zon2.exit ], [ %0, %can_use_fpu.exit ], [ %0, %entry ], [ %10, %fpclassify_not_nan.i ], [ %10, %lor.lhs.false.i ], [ %10, %fpclassify_not_nan18.i ]
  %ua.i.sroa.0.2 = phi i64 [ %ua.i.sroa.0.1, %land.lhs.true.i ], [ %ua.i.sroa.0.1, %f64_is_zon2.exit ], [ %a, %can_use_fpu.exit ], [ %a, %entry ], [ %ua.i.sroa.0.1, %fpclassify_not_nan.i ], [ %ua.i.sroa.0.1, %lor.lhs.false.i ], [ %ua.i.sroa.0.1, %fpclassify_not_nan18.i ]
  %ub.i.sroa.0.1 = phi i64 [ %ub.i.sroa.0.0, %land.lhs.true.i ], [ %ub.i.sroa.0.0, %f64_is_zon2.exit ], [ %b, %can_use_fpu.exit ], [ %b, %entry ], [ %ub.i.sroa.0.0, %fpclassify_not_nan.i ], [ %ub.i.sroa.0.0, %lor.lhs.false.i ], [ %ub.i.sroa.0.0, %fpclassify_not_nan18.i ]
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %pa.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %pb.i)
  %f.lobit.i.i = lshr i64 %ua.i.sroa.0.2, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %ua.i.sroa.0.2, 52
  %18 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %18, 2047
  %and.i9.i.i = and i64 %ua.i.sroa.0.2, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa.i, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa.i, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 %and.i9.i.i, ptr %pa.i.sroa.gep, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i45.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i45.i:                                    ; preds = %soft39.i
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i46.i

if.then8.i.i:                                     ; preds = %if.then.i45.i
  store i8 1, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

if.else.i46.i:                                    ; preds = %if.then.i45.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %19 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %20 = and i8 %19, 1
  %tobool9.not.i.i = icmp eq i8 %20, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i46.i
  %or1.i.i.i12 = or i16 %17, 32
  store i16 %or1.i.i.i12, ptr %s, align 2
  store i8 1, ptr %pa.i, align 8
  store i64 0, ptr %pa.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit.i

frac64_normalize.exit.i.i:                        ; preds = %if.else.i46.i
  %21 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %21 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %21
  store i64 %shl.i.i.i, ptr %pa.i.sroa.gep, align 8
  store i8 2, ptr %pa.i, align 8
  %add.i47.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i47.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_canonicalize.exit.i

lor.lhs.false.i.i:                                ; preds = %soft39.i
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %soft39.i
  store i8 2, ptr %pa.i, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i44.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i44.i, ptr %pa.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %pa.i.sroa.gep, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

parts64_canonicalize.exit.i:                      ; preds = %if.else49.i.i, %if.then47.i.i, %if.then33.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then8.i.i
  %22 = phi i16 [ %17, %if.then8.i.i ], [ %or1.i.i.i12, %if.then10.i.i ], [ %17, %frac64_normalize.exit.i.i ], [ %17, %if.then33.i.i ], [ %17, %if.then47.i.i ], [ %17, %if.else49.i.i ]
  %23 = phi i32 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %add.i47.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ 2047, %if.then47.i.i ], [ 2047, %if.else49.i.i ]
  %a.val.i.i = phi i64 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i44.i, %if.then33.i.i ], [ 0, %if.then47.i.i ], [ %shl.i31.i.i, %if.else49.i.i ]
  %24 = phi i8 [ 1, %if.then8.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ], [ 3, %if.then47.i.i ], [ %conv53.i.i, %if.else49.i.i ]
  %f.lobit.i48.i = lshr i64 %ub.i.sroa.0.1, 63
  %frombool.i.i49.i = trunc i64 %f.lobit.i48.i to i8
  %shr.i8.i50.i = lshr i64 %ub.i.sroa.0.1, 52
  %25 = trunc i64 %shr.i8.i50.i to i32
  %conv.i.i51.i = and i32 %25, 2047
  %and.i9.i52.i = and i64 %ub.i.sroa.0.1, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i53.i = getelementptr inbounds i8, ptr %pb.i, i64 1
  store i8 %frombool.i.i49.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i53.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i54.i = getelementptr inbounds i8, ptr %pb.i, i64 4
  store i32 %conv.i.i51.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i54.i, align 4
  store i64 %and.i9.i52.i, ptr %pb.i.sroa.gep, align 8
  switch i32 %conv.i.i51.i, label %if.then33.i68.i [
    i32 0, label %if.then.i72.i
    i32 2047, label %lor.lhs.false.i60.i
  ]

if.then.i72.i:                                    ; preds = %parts64_canonicalize.exit.i
  %cmp.i.i74.i = icmp eq i64 %and.i9.i52.i, 0
  br i1 %cmp.i.i74.i, label %if.then8.i85.i, label %if.else.i75.i

if.then8.i85.i:                                   ; preds = %if.then.i72.i
  store i8 1, ptr %pb.i, align 8
  br label %parts64_canonicalize.exit86.i

if.else.i75.i:                                    ; preds = %if.then.i72.i
  %flush_inputs_to_zero.i76.i = getelementptr inbounds i8, ptr %s, i64 6
  %26 = load i8, ptr %flush_inputs_to_zero.i76.i, align 2
  %27 = and i8 %26, 1
  %tobool9.not.i77.i = icmp eq i8 %27, 0
  br i1 %tobool9.not.i77.i, label %frac64_normalize.exit.i80.i, label %if.then10.i78.i

if.then10.i78.i:                                  ; preds = %if.else.i75.i
  %or1.i.i79.i = or i16 %22, 32
  store i16 %or1.i.i79.i, ptr %s, align 2
  store i8 1, ptr %pb.i, align 8
  store i64 0, ptr %pb.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit86.i

frac64_normalize.exit.i80.i:                      ; preds = %if.else.i75.i
  %28 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i52.i, i1 true), !range !5
  %cast.i.i.i81.i = trunc i64 %28 to i32
  %shl.i.i82.i = shl i64 %and.i9.i52.i, %28
  store i64 %shl.i.i82.i, ptr %pb.i.sroa.gep, align 8
  store i8 2, ptr %pb.i, align 8
  %add.i84.i = sub nuw nsw i32 -1011, %cast.i.i.i81.i
  store i32 %add.i84.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i54.i, align 4
  br label %parts64_canonicalize.exit86.i

lor.lhs.false.i60.i:                              ; preds = %parts64_canonicalize.exit.i
  %cmp.i29.i62.i = icmp eq i64 %and.i9.i52.i, 0
  br i1 %cmp.i29.i62.i, label %if.then47.i67.i, label %if.else49.i63.i

if.then33.i68.i:                                  ; preds = %parts64_canonicalize.exit.i
  store i8 2, ptr %pb.i, align 8
  %sub37.i69.i = add nsw i32 %conv.i.i51.i, -1023
  store i32 %sub37.i69.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i54.i, align 4
  %shl.i28.i70.i = shl nuw nsw i64 %and.i9.i52.i, 11
  %or.i71.i = or disjoint i64 %shl.i28.i70.i, -9223372036854775808
  store i64 %or.i71.i, ptr %pb.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit86.i

if.then47.i67.i:                                  ; preds = %lor.lhs.false.i60.i
  store i8 3, ptr %pb.i, align 8
  br label %parts64_canonicalize.exit86.i

if.else49.i63.i:                                  ; preds = %lor.lhs.false.i60.i
  %shl.i31.i64.i = shl nuw nsw i64 %and.i9.i52.i, 11
  store i64 %shl.i31.i64.i, ptr %pb.i.sroa.gep, align 8
  %tobool.not.i32.i65.i = icmp ult i64 %and.i9.i52.i, 2251799813685248
  %conv53.i66.i = select i1 %tobool.not.i32.i65.i, i8 5, i8 4
  store i8 %conv53.i66.i, ptr %pb.i, align 8
  br label %parts64_canonicalize.exit86.i

parts64_canonicalize.exit86.i:                    ; preds = %if.else49.i63.i, %if.then47.i67.i, %if.then33.i68.i, %frac64_normalize.exit.i80.i, %if.then10.i78.i, %if.then8.i85.i
  %29 = phi i64 [ 0, %if.then8.i85.i ], [ 0, %if.then10.i78.i ], [ %shl.i.i82.i, %frac64_normalize.exit.i80.i ], [ %or.i71.i, %if.then33.i68.i ], [ 0, %if.then47.i67.i ], [ %shl.i31.i64.i, %if.else49.i63.i ]
  %30 = phi i16 [ %22, %if.then8.i85.i ], [ %or1.i.i79.i, %if.then10.i78.i ], [ %22, %frac64_normalize.exit.i80.i ], [ %22, %if.then33.i68.i ], [ %22, %if.then47.i67.i ], [ %22, %if.else49.i63.i ]
  %31 = phi i32 [ 0, %if.then8.i85.i ], [ 0, %if.then10.i78.i ], [ %add.i84.i, %frac64_normalize.exit.i80.i ], [ %sub37.i69.i, %if.then33.i68.i ], [ 2047, %if.then47.i67.i ], [ 2047, %if.else49.i63.i ]
  %.pr.i.pre.i = phi i8 [ 1, %if.then8.i85.i ], [ 1, %if.then10.i78.i ], [ 2, %frac64_normalize.exit.i80.i ], [ 2, %if.then33.i68.i ], [ 3, %if.then47.i67.i ], [ %conv53.i66.i, %if.else49.i63.i ]
  %conv.i.i = zext nneg i8 %24 to i32
  %shl.i.i = shl nuw nsw i32 1, %conv.i.i
  %conv2.i.i = zext nneg i8 %.pr.i.pre.i to i32
  %shl3.i.i = shl nuw nsw i32 1, %conv2.i.i
  %or.i.i = or i32 %shl3.i.i, %shl.i.i
  %32 = xor i8 %frombool.i.i49.i, %frombool.i.i.i
  %trunc.i = trunc i32 %or.i.i to i8
  switch i8 %trunc.i, label %if.end32.i.i [
    i8 4, label %if.then.i.i10
    i8 10, label %if.then31.i.i
  ]

if.then.i.i10:                                    ; preds = %parts64_canonicalize.exit86.i
  %conv.i.i87.i = zext i64 %a.val.i.i to i128
  %conv1.i.i.i = zext i64 %29 to i128
  %mul.i.i.i = mul nuw i128 %conv1.i.i.i, %conv.i.i87.i
  %conv2.i.i.i = trunc i128 %mul.i.i.i to i64
  %shr.i.i.i = lshr i128 %mul.i.i.i, 64
  %conv3.i.i.i = trunc i128 %shr.i.i.i to i64
  %cmp.i88.i = icmp ne i64 %conv2.i.i.i, 0
  %conv1.i.i = zext i1 %cmp.i88.i to i64
  %or.i89.i = or i64 %conv1.i.i, %conv3.i.i.i
  store i64 %or.i89.i, ptr %pa.i.sroa.gep, align 8
  %add.i.i = add nsw i32 %31, %23
  %add15.i.i = add nsw i32 %add.i.i, 1
  store i32 %add15.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %tobool16.i.not.i = icmp sgt i64 %or.i89.i, -1
  br i1 %tobool16.i.not.i, label %if.then17.i.i, label %if.end.i.i

if.then17.i.i:                                    ; preds = %if.then.i.i10
  %33 = shl nuw i64 %or.i89.i, 1
  store i64 %33, ptr %pa.i.sroa.gep, align 8
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then17.i.i, %if.then.i.i10
  store i8 %32, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %soft_f64_mul.exit

if.then31.i.i:                                    ; preds = %parts64_canonicalize.exit86.i
  %or1.i.i = or i16 %30, 257
  store i16 %or1.i.i, ptr %s, align 2
  store i8 4, ptr %pa.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.i.sroa.gep, align 8
  br label %soft_f64_mul.exit

if.end32.i.i:                                     ; preds = %parts64_canonicalize.exit86.i
  %and33.i.i = and i32 %or.i.i, 48
  %tobool34.i.not.i = icmp eq i32 %and33.i.i, 0
  br i1 %tobool34.i.not.i, label %if.end43.i.i, label %if.then41.i.i

if.then41.i.i:                                    ; preds = %if.end32.i.i
  %cmp.i.i90.i = icmp eq i8 %24, 5
  %cmp.i17.i.i = icmp eq i8 %.pr.i.pre.i, 5
  %or.cond.i11 = or i1 %cmp.i.i90.i, %cmp.i17.i.i
  br i1 %or.cond.i11, label %if.then.i94.i, label %if.end.i92.i

if.then.i94.i:                                    ; preds = %if.then41.i.i
  %or1.i.i95.i = or i16 %30, 8193
  store i16 %or1.i.i95.i, ptr %s, align 2
  br label %if.end.i92.i

if.end.i92.i:                                     ; preds = %if.then.i94.i, %if.then41.i.i
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %34 = load i8, ptr %default_nan_mode.i.i, align 1
  %35 = and i8 %34, 1
  %tobool.not.i.i = icmp eq i8 %35, 0
  br i1 %tobool.not.i.i, label %if.else.i93.i, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.end.i92.i
  store i8 4, ptr %pa.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.i.sroa.gep, align 8
  br label %soft_f64_mul.exit

if.else.i93.i:                                    ; preds = %if.end.i92.i
  %cmp.i18.i.i = icmp eq i64 %a.val.i.i, %29
  %cmp1.i.i.i = icmp ult i64 %a.val.i.i, %29
  %cmp11.i.i = icmp uge i64 %f.lobit.i.i, %f.lobit.i48.i
  %spec.select.i = select i1 %cmp.i18.i.i, i1 %cmp11.i.i, i1 %cmp1.i.i.i
  %spec.select.fr.i = freeze i1 %spec.select.i
  switch i8 %24, label %36 [
    i8 5, label %pickNaN.exit.i.i
    i8 4, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.else.i93.i
  br i1 %cmp.i17.i.i, label %soft_f64_mul.exit, label %lor.lhs.false.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %if.then6.i.i.i
  %cmp.i11.i.i.i = icmp eq i8 %.pr.i.pre.i, 4
  %spec.select.i.i.i = and i1 %cmp.i11.i.i.i, %spec.select.fr.i
  %spec.select108.i = select i1 %spec.select.i.i.i, ptr %pb.i, ptr %pa.i
  br label %soft_f64_mul.exit

pickNaN.exit.i.i:                                 ; preds = %if.else.i93.i
  %cmp.i8.i.i.i = icmp eq i8 %.pr.i.pre.i, 4
  %spec.select20.i.i = select i1 %cmp.i17.i.i, i1 %spec.select.fr.i, i1 %cmp.i8.i.i.i
  %spec.select20.i.i.not = xor i1 %spec.select20.i.i, true
  %brmerge20 = or i1 %cmp.i17.i.i, %spec.select20.i.i.not
  br i1 %brmerge20, label %pickNaN.exit.i.i.if.then24.i.i_crit_edge, label %soft_f64_mul.exit

pickNaN.exit.i.i.if.then24.i.i_crit_edge:         ; preds = %pickNaN.exit.i.i
  %pa.i.sroa.gep.mux = select i1 %spec.select20.i.i, ptr %pb.i.sroa.gep, ptr %pa.i.sroa.gep
  %pa.i.mux = select i1 %spec.select20.i.i, ptr %pb.i, ptr %pa.i
  %.pre = load i64, ptr %pa.i.sroa.gep.mux, align 8
  br label %if.then24.i.i

36:                                               ; preds = %if.else.i93.i
  br i1 %cmp.i17.i.i, label %if.then24.i.i, label %soft_f64_mul.exit

if.then24.i.i:                                    ; preds = %pickNaN.exit.i.i.if.then24.i.i_crit_edge, %36
  %37 = phi i64 [ %29, %36 ], [ %.pre, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i103.i = phi ptr [ %pb.i, %36 ], [ %pa.i.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i103.i.sroa.phi = phi ptr [ %pb.i.sroa.gep, %36 ], [ %pa.i.sroa.gep.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %or4.i.i.i.i = or i64 %37, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.ph.i103.i.sroa.phi, align 8
  store i8 4, ptr %.ph.i103.i, align 8
  br label %soft_f64_mul.exit

if.end43.i.i:                                     ; preds = %if.end32.i.i
  %and44.i.i = and i32 %or.i.i, 8
  %tobool45.i.not.i = icmp eq i32 %and44.i.i, 0
  br i1 %tobool45.i.not.i, label %if.end51.i.i, label %if.then46.i.i

if.then46.i.i:                                    ; preds = %if.end43.i.i
  store i8 3, ptr %pa.i, align 8
  store i8 %32, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %soft_f64_mul.exit

if.end51.i.i:                                     ; preds = %if.end43.i.i
  %and52.i.i = and i32 %or.i.i, 2
  %tobool53.i.not.i = icmp eq i32 %and52.i.i, 0
  br i1 %tobool53.i.not.i, label %if.else.i.i, label %if.then54.i.i

if.then54.i.i:                                    ; preds = %if.end51.i.i
  store i8 1, ptr %pa.i, align 8
  store i8 %32, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  br label %soft_f64_mul.exit

if.else.i.i:                                      ; preds = %if.end51.i.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 460, ptr noundef nonnull @__func__.parts64_mul, ptr noundef nonnull @.str.7) #16
  unreachable

soft_f64_mul.exit:                                ; preds = %pickNaN.exit.i.i, %if.end.i.i, %if.then31.i.i, %if.then3.i.i, %if.then6.i.i.i, %lor.lhs.false.i.i.i, %36, %if.then24.i.i, %if.then46.i.i, %if.then54.i.i
  %retval.i.0.i = phi ptr [ %pa.i, %if.end.i.i ], [ %pa.i, %if.then31.i.i ], [ %pa.i, %if.then46.i.i ], [ %pa.i, %if.then54.i.i ], [ %pa.i, %if.then3.i.i ], [ %.ph.i103.i, %if.then24.i.i ], [ %pb.i, %36 ], [ %pa.i, %if.then6.i.i.i ], [ %spec.select108.i, %lor.lhs.false.i.i.i ], [ %pb.i, %pickNaN.exit.i.i ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %retval.i.0.i, ptr noundef nonnull %s, ptr noundef nonnull @float64_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %retval.i.0.i, i64 1
  %38 = load i8, ptr %sign.i.i.i, align 1
  %39 = and i8 %38, 1
  %conv.i.i96.i = zext nneg i8 %39 to i64
  %shl.i.i97.i = shl nuw i64 %conv.i.i96.i, 63
  %exp.i.i.i = getelementptr inbounds i8, ptr %retval.i.0.i, i64 4
  %40 = load i32, ptr %exp.i.i.i, align 4
  %41 = and i32 %40, 2047
  %shl77.i.i.i = zext nneg i32 %41 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i97.i
  %42 = getelementptr inbounds i8, ptr %retval.i.0.i, i64 8
  %43 = load i64, ptr %42, align 8
  %shl77.i9.i.i = and i64 %43, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %pa.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %pb.i)
  br label %float64_gen2.exit

float64_gen2.exit:                                ; preds = %if.then24.i, %land.lhs.true.i, %if.else.i, %soft_f64_mul.exit
  %retval.i.0 = phi i64 [ %or.i10.i.i, %soft_f64_mul.exit ], [ %13, %if.else.i ], [ %13, %land.lhs.true.i ], [ %13, %if.then24.i ]
  ret i64 %retval.i.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64r32_mul(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pb = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float64_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

float64_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %f.lobit.i.i4 = lshr i64 %b, 63
  %frombool.i.i.i5 = trunc i64 %f.lobit.i.i4 to i8
  %shr.i8.i.i6 = lshr i64 %b, 52
  %5 = trunc i64 %shr.i8.i.i6 to i32
  %conv.i.i.i7 = and i32 %5, 2047
  %and.i9.i.i8 = and i64 %b, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i5, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i.i7, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i9.i.i8, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  switch i32 %conv.i.i.i7, label %if.then33.i.i31 [
    i32 0, label %if.then.i.i19
    i32 2047, label %lor.lhs.false.i.i12
  ]

if.then.i.i19:                                    ; preds = %float64_unpack_canonical.exit
  %cmp.i.i.i20 = icmp eq i64 %and.i9.i.i8, 0
  br i1 %cmp.i.i.i20, label %if.then8.i.i30, label %if.else.i.i21

if.then8.i.i30:                                   ; preds = %if.then.i.i19
  store i8 1, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

if.else.i.i21:                                    ; preds = %if.then.i.i19
  %flush_inputs_to_zero.i.i22 = getelementptr inbounds i8, ptr %status, i64 6
  %6 = load i8, ptr %flush_inputs_to_zero.i.i22, align 2
  %7 = and i8 %6, 1
  %tobool9.not.i.i23 = icmp eq i8 %7, 0
  br i1 %tobool9.not.i.i23, label %frac64_normalize.exit.i.i26, label %if.then10.i.i24

if.then10.i.i24:                                  ; preds = %if.else.i.i21
  %8 = load i16, ptr %status, align 2
  %or1.i.i.i25 = or i16 %8, 32
  store i16 %or1.i.i.i25, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float64_unpack_canonical.exit35

frac64_normalize.exit.i.i26:                      ; preds = %if.else.i.i21
  %9 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i8, i1 true), !range !5
  %cast.i.i.i.i27 = trunc i64 %9 to i32
  %shl.i.i.i28 = shl i64 %and.i9.i.i8, %9
  store i64 %shl.i.i.i28, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i29 = sub nuw nsw i32 -1011, %cast.i.i.i.i27
  store i32 %add.i.i29, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  br label %float64_unpack_canonical.exit35

lor.lhs.false.i.i12:                              ; preds = %float64_unpack_canonical.exit
  %cmp.i29.i.i13 = icmp eq i64 %and.i9.i.i8, 0
  br i1 %cmp.i29.i.i13, label %if.then47.i.i18, label %if.else49.i.i14

if.then33.i.i31:                                  ; preds = %float64_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i32 = add nsw i32 %conv.i.i.i7, -1023
  store i32 %sub37.i.i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %shl.i28.i.i33 = shl nuw nsw i64 %and.i9.i.i8, 11
  %or.i.i34 = or disjoint i64 %shl.i28.i.i33, -9223372036854775808
  store i64 %or.i.i34, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float64_unpack_canonical.exit35

if.then47.i.i18:                                  ; preds = %lor.lhs.false.i.i12
  store i8 3, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

if.else49.i.i14:                                  ; preds = %lor.lhs.false.i.i12
  %shl.i31.i.i15 = shl nuw nsw i64 %and.i9.i.i8, 11
  store i64 %shl.i31.i.i15, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  %tobool.not.i32.i.i16 = icmp ult i64 %and.i9.i.i8, 2251799813685248
  %conv53.i.i17 = select i1 %tobool.not.i32.i.i16, i8 5, i8 4
  store i8 %conv53.i.i17, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

float64_unpack_canonical.exit35:                  ; preds = %if.then8.i.i30, %if.then10.i.i24, %frac64_normalize.exit.i.i26, %if.then33.i.i31, %if.then47.i.i18, %if.else49.i.i14
  %call = call fastcc ptr @parts64_mul(ptr noundef nonnull %pa, ptr noundef nonnull %pb, ptr noundef %status)
  %call1 = call fastcc i64 @float64r32_round_pack_canonical(ptr noundef %call, ptr noundef %status)
  ret i64 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i64 @float64r32_round_pack_canonical(ptr nocapture noundef %p, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  tail call fastcc void @parts64_uncanon(ptr noundef %p, ptr noundef %s, ptr noundef nonnull @float32_params)
  %0 = load i8, ptr %p, align 8
  switch i8 %0, label %do.body [
    i8 2, label %sw.bb
    i8 5, label %sw.bb8
    i8 4, label %sw.bb8
    i8 3, label %sw.bb10
    i8 1, label %entry.sw.epilog_crit_edge
  ]

entry.sw.epilog_crit_edge:                        ; preds = %entry
  %exp.i.i.phi.trans.insert = getelementptr inbounds i8, ptr %p, i64 4
  %.pre = load i32, ptr %exp.i.i.phi.trans.insert, align 4
  br label %sw.epilog

sw.bb:                                            ; preds = %entry
  %exp = getelementptr inbounds i8, ptr %p, i64 4
  %1 = load i32, ptr %exp, align 4
  %cmp = icmp eq i32 %1, 0
  %2 = getelementptr inbounds i8, ptr %p, i64 8
  %3 = load i64, ptr %2, align 8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %tobool.not.i = icmp eq i64 %3, 0
  %4 = tail call i64 @llvm.ctlz.i64(i64 %3, i1 true), !range !5
  %cast.i.i = trunc i64 %4 to i32
  %shl.i = shl i64 %3, %4
  %5 = sub nuw nsw i32 937, %cast.i.i
  %6 = lshr i64 %shl.i, 11
  %shr.i = select i1 %tobool.not.i, i64 0, i64 %6
  %retval.0.i = select i1 %tobool.not.i, i32 873, i32 %5
  store i32 %retval.0.i, ptr %exp, align 4
  store i64 %shr.i, ptr %2, align 8
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb
  %shl.i12 = shl i64 %3, 29
  store i64 %shl.i12, ptr %2, align 8
  %add7 = add i32 %1, 896
  store i32 %add7, ptr %exp, align 4
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry, %entry
  %7 = getelementptr inbounds i8, ptr %p, i64 8
  %8 = load i64, ptr %7, align 8
  %shl.i13 = shl i64 %8, 29
  store i64 %shl.i13, ptr %7, align 8
  %exp9 = getelementptr inbounds i8, ptr %p, i64 4
  store i32 2047, ptr %exp9, align 4
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry
  %exp11 = getelementptr inbounds i8, ptr %p, i64 4
  store i32 2047, ptr %exp11, align 4
  br label %sw.epilog

do.body:                                          ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1758, ptr noundef nonnull @__func__.float64r32_round_pack_canonical, ptr noundef null) #16
  unreachable

sw.epilog:                                        ; preds = %entry.sw.epilog_crit_edge, %if.then, %if.else, %sw.bb10, %sw.bb8
  %9 = phi i32 [ %.pre, %entry.sw.epilog_crit_edge ], [ %retval.0.i, %if.then ], [ %add7, %if.else ], [ 2047, %sw.bb10 ], [ 2047, %sw.bb8 ]
  %sign.i.i = getelementptr inbounds i8, ptr %p, i64 1
  %10 = load i8, ptr %sign.i.i, align 1
  %11 = and i8 %10, 1
  %conv.i.i = zext nneg i8 %11 to i64
  %shl.i.i = shl nuw i64 %conv.i.i, 63
  %12 = and i32 %9, 2047
  %shl77.i.i = zext nneg i32 %12 to i64
  %and8.i.i = shl nuw nsw i64 %shl77.i.i, 52
  %or.i.i = or disjoint i64 %and8.i.i, %shl.i.i
  %13 = getelementptr inbounds i8, ptr %p, i64 8
  %14 = load i64, ptr %13, align 8
  %shl77.i9.i = and i64 %14, 4503599627370495
  %or.i10.i = or disjoint i64 %or.i.i, %shl77.i9.i
  ret i64 %or.i10.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_mul(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts64, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %f.lobit.i = lshr i16 %a, 15
  %frombool.i.i = trunc i16 %f.lobit.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %0, 255
  %conv.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 127
  %and.i10.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i10.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %trunc = trunc i16 %0 to i8
  switch i8 %trunc, label %if.then33.i [
    i8 0, label %if.then.i45
    i8 -1, label %lor.lhs.false.i
  ]

if.then.i45:                                      ; preds = %entry
  %cmp.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i, label %if.then8.i, label %if.else.i46

if.then8.i:                                       ; preds = %if.then.i45
  store i8 1, ptr %pa, align 8
  br label %parts64_canonicalize.exit

if.else.i46:                                      ; preds = %if.then.i45
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i, label %frac64_normalize.exit.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.else.i46
  %5 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %5, 32
  store i16 %or1.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_canonicalize.exit

frac64_normalize.exit.i:                          ; preds = %if.else.i46
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i, i1 true), !range !5
  %cast.i.i.i = trunc i64 %6 to i32
  %shl.i.i = shl i64 %and.i10.i, %6
  store i64 %shl.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i47 = sub nuw nsw i32 -70, %cast.i.i.i
  store i32 %add.i47, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_canonicalize.exit

lor.lhs.false.i:                                  ; preds = %entry
  %cmp.i29.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i, label %if.then47.i, label %if.else49.i

if.then33.i:                                      ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i = add nsw i32 %conv.i.i, -127
  store i32 %sub37.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %shl.i28.i = shl nuw nsw i64 %and.i10.i, 56
  %or.i44 = or disjoint i64 %shl.i28.i, -9223372036854775808
  store i64 %or.i44, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_canonicalize.exit

if.then47.i:                                      ; preds = %lor.lhs.false.i
  store i8 3, ptr %pa, align 8
  br label %parts64_canonicalize.exit

if.else49.i:                                      ; preds = %lor.lhs.false.i
  %shl.i31.i = shl nuw nsw i64 %and.i10.i, 56
  store i64 %shl.i31.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %tobool.not.i32.i = icmp ult i16 %2, 64
  %conv53.i = select i1 %tobool.not.i32.i, i8 5, i8 4
  store i8 %conv53.i, ptr %pa, align 8
  br label %parts64_canonicalize.exit

parts64_canonicalize.exit:                        ; preds = %if.then8.i, %if.then10.i, %frac64_normalize.exit.i, %if.then33.i, %if.then47.i, %if.else49.i
  %7 = phi i32 [ %conv.i.i, %if.then8.i ], [ %conv.i.i, %if.then10.i ], [ %add.i47, %frac64_normalize.exit.i ], [ %sub37.i, %if.then33.i ], [ %conv.i.i, %if.then47.i ], [ %conv.i.i, %if.else49.i ]
  %a.val.i = phi i64 [ 0, %if.then8.i ], [ 0, %if.then10.i ], [ %shl.i.i, %frac64_normalize.exit.i ], [ %or.i44, %if.then33.i ], [ 0, %if.then47.i ], [ %shl.i31.i, %if.else49.i ]
  %8 = phi i8 [ 1, %if.then8.i ], [ 1, %if.then10.i ], [ 2, %frac64_normalize.exit.i ], [ 2, %if.then33.i ], [ 3, %if.then47.i ], [ %conv53.i, %if.else49.i ]
  %f.lobit.i48 = lshr i16 %b, 15
  %frombool.i.i49 = trunc i16 %f.lobit.i48 to i8
  %9 = lshr i16 %b, 7
  %10 = and i16 %9, 255
  %conv.i.i50 = zext nneg i16 %10 to i32
  %11 = and i16 %b, 127
  %and.i10.i51 = zext nneg i16 %11 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i52 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i49, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i52, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i53 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i50, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i53, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i54 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i10.i51, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i54, align 8
  %trunc98 = trunc i16 %9 to i8
  switch i8 %trunc98, label %if.then33.i67 [
    i8 0, label %if.then.i71
    i8 -1, label %lor.lhs.false.i59
  ]

if.then.i71:                                      ; preds = %parts64_canonicalize.exit
  %cmp.i.i73 = icmp eq i16 %11, 0
  br i1 %cmp.i.i73, label %if.then8.i84, label %if.else.i74

if.then8.i84:                                     ; preds = %if.then.i71
  store i8 1, ptr %pb, align 8
  br label %parts64_canonicalize.exit85

if.else.i74:                                      ; preds = %if.then.i71
  %flush_inputs_to_zero.i75 = getelementptr inbounds i8, ptr %status, i64 6
  %12 = load i8, ptr %flush_inputs_to_zero.i75, align 2
  %13 = and i8 %12, 1
  %tobool9.not.i76 = icmp eq i8 %13, 0
  br i1 %tobool9.not.i76, label %frac64_normalize.exit.i79, label %if.then10.i77

if.then10.i77:                                    ; preds = %if.else.i74
  %14 = load i16, ptr %status, align 2
  %or1.i.i78 = or i16 %14, 32
  store i16 %or1.i.i78, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i54, align 8
  br label %parts64_canonicalize.exit85

frac64_normalize.exit.i79:                        ; preds = %if.else.i74
  %15 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i51, i1 true), !range !5
  %cast.i.i.i80 = trunc i64 %15 to i32
  %shl.i.i81 = shl i64 %and.i10.i51, %15
  store i64 %shl.i.i81, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i54, align 8
  store i8 2, ptr %pb, align 8
  %add.i83 = sub nuw nsw i32 -70, %cast.i.i.i80
  store i32 %add.i83, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i53, align 4
  br label %parts64_canonicalize.exit85

lor.lhs.false.i59:                                ; preds = %parts64_canonicalize.exit
  %cmp.i29.i61 = icmp eq i16 %11, 0
  br i1 %cmp.i29.i61, label %if.then47.i66, label %if.else49.i62

if.then33.i67:                                    ; preds = %parts64_canonicalize.exit
  store i8 2, ptr %pb, align 8
  %sub37.i68 = add nsw i32 %conv.i.i50, -127
  store i32 %sub37.i68, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i53, align 4
  %shl.i28.i69 = shl nuw nsw i64 %and.i10.i51, 56
  %or.i70 = or disjoint i64 %shl.i28.i69, -9223372036854775808
  store i64 %or.i70, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i54, align 8
  br label %parts64_canonicalize.exit85

if.then47.i66:                                    ; preds = %lor.lhs.false.i59
  store i8 3, ptr %pb, align 8
  br label %parts64_canonicalize.exit85

if.else49.i62:                                    ; preds = %lor.lhs.false.i59
  %shl.i31.i63 = shl nuw nsw i64 %and.i10.i51, 56
  store i64 %shl.i31.i63, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i54, align 8
  %tobool.not.i32.i64 = icmp ult i16 %11, 64
  %conv53.i65 = select i1 %tobool.not.i32.i64, i8 5, i8 4
  store i8 %conv53.i65, ptr %pb, align 8
  br label %parts64_canonicalize.exit85

parts64_canonicalize.exit85:                      ; preds = %if.then8.i84, %if.then10.i77, %frac64_normalize.exit.i79, %if.then33.i67, %if.then47.i66, %if.else49.i62
  %16 = phi i32 [ %conv.i.i50, %if.then8.i84 ], [ %conv.i.i50, %if.then10.i77 ], [ %add.i83, %frac64_normalize.exit.i79 ], [ %sub37.i68, %if.then33.i67 ], [ %conv.i.i50, %if.then47.i66 ], [ %conv.i.i50, %if.else49.i62 ]
  %b.val.i = phi i64 [ 0, %if.then8.i84 ], [ 0, %if.then10.i77 ], [ %shl.i.i81, %frac64_normalize.exit.i79 ], [ %or.i70, %if.then33.i67 ], [ 0, %if.then47.i66 ], [ %shl.i31.i63, %if.else49.i62 ]
  %.pr.i.pre = phi i8 [ 1, %if.then8.i84 ], [ 1, %if.then10.i77 ], [ 2, %frac64_normalize.exit.i79 ], [ 2, %if.then33.i67 ], [ 3, %if.then47.i66 ], [ %conv53.i65, %if.else49.i62 ]
  %conv.i = zext nneg i8 %8 to i32
  %shl.i = shl nuw nsw i32 1, %conv.i
  %conv2.i = zext nneg i8 %.pr.i.pre to i32
  %shl3.i = shl nuw nsw i32 1, %conv2.i
  %or.i = or i32 %shl.i, %shl3.i
  %17 = xor i8 %frombool.i.i49, %frombool.i.i
  %trunc102 = trunc i32 %or.i to i8
  switch i8 %trunc102, label %if.end32.i [
    i8 4, label %if.then.i
    i8 10, label %if.then31.i
  ]

if.then.i:                                        ; preds = %parts64_canonicalize.exit85
  %conv.i.i86 = zext i64 %a.val.i to i128
  %conv1.i.i = zext i64 %b.val.i to i128
  %mul.i.i = mul nuw i128 %conv1.i.i, %conv.i.i86
  %conv2.i.i = trunc i128 %mul.i.i to i64
  %shr.i.i = lshr i128 %mul.i.i, 64
  %conv3.i.i = trunc i128 %shr.i.i to i64
  %cmp.i87 = icmp ne i64 %conv2.i.i, 0
  %conv1.i = zext i1 %cmp.i87 to i64
  %or.i88 = or i64 %conv1.i, %conv3.i.i
  store i64 %or.i88, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %add.i = add nsw i32 %7, %16
  %add15.i = add nsw i32 %add.i, 1
  store i32 %add15.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %tobool16.i.not = icmp sgt i64 %or.i88, -1
  br i1 %tobool16.i.not, label %if.then17.i, label %if.end.i

if.then17.i:                                      ; preds = %if.then.i
  %18 = shl nuw i64 %or.i88, 1
  store i64 %18, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  store i32 %add.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then17.i, %if.then.i
  store i8 %17, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  br label %parts64_mul.exit

if.then31.i:                                      ; preds = %parts64_canonicalize.exit85
  %19 = load i16, ptr %status, align 2
  %or1.i = or i16 %19, 257
  store i16 %or1.i, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_mul.exit

if.end32.i:                                       ; preds = %parts64_canonicalize.exit85
  %and33.i = and i32 %or.i, 48
  %tobool34.i.not = icmp eq i32 %and33.i, 0
  br i1 %tobool34.i.not, label %if.end43.i, label %if.then41.i

if.then41.i:                                      ; preds = %if.end32.i
  %cmp.i.i89 = icmp eq i8 %8, 5
  %cmp.i17.i = icmp eq i8 %.pr.i.pre, 5
  %or.cond = or i1 %cmp.i17.i, %cmp.i.i89
  br i1 %or.cond, label %if.then.i93, label %if.end.i91

if.then.i93:                                      ; preds = %if.then41.i
  %20 = load i16, ptr %status, align 2
  %or1.i.i94 = or i16 %20, 8193
  store i16 %or1.i.i94, ptr %status, align 2
  br label %if.end.i91

if.end.i91:                                       ; preds = %if.then41.i, %if.then.i93
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %21 = load i8, ptr %default_nan_mode.i, align 1
  %22 = and i8 %21, 1
  %tobool.not.i = icmp eq i8 %22, 0
  br i1 %tobool.not.i, label %if.else.i92, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i91
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_mul.exit

if.else.i92:                                      ; preds = %if.end.i91
  %cmp.i18.i = icmp eq i64 %a.val.i, %b.val.i
  %cmp1.i.i = icmp ult i64 %a.val.i, %b.val.i
  %cmp11.i = icmp uge i16 %f.lobit.i, %f.lobit.i48
  %spec.select = select i1 %cmp.i18.i, i1 %cmp11.i, i1 %cmp1.i.i
  %spec.select.fr = freeze i1 %spec.select
  switch i8 %8, label %23 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.else.i92
  br i1 %cmp.i17.i, label %parts64_mul.exit, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select.i.i = and i1 %cmp.i11.i.i, %spec.select.fr
  %spec.select110 = select i1 %spec.select.i.i, ptr %pb, ptr %pa
  br label %parts64_mul.exit

pickNaN.exit.i:                                   ; preds = %if.else.i92
  %cmp.i8.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select20.i = select i1 %cmp.i17.i, i1 %spec.select.fr, i1 %cmp.i8.i.i
  br i1 %spec.select20.i, label %23, label %if.then24.i

23:                                               ; preds = %if.else.i92, %pickNaN.exit.i
  %24 = icmp eq i8 %.pr.i.pre, 5
  br i1 %24, label %if.then24.i, label %parts64_mul.exit

if.then24.i:                                      ; preds = %pickNaN.exit.i, %23
  %.ph.i105 = phi ptr [ %pb, %23 ], [ %pa, %pickNaN.exit.i ]
  %.ph.i105.sroa.phi = phi ptr [ %pb.sroa.gep, %23 ], [ %pa.sroa.gep, %pickNaN.exit.i ]
  %25 = load i64, ptr %.ph.i105.sroa.phi, align 8
  %or4.i.i.i = or i64 %25, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.ph.i105.sroa.phi, align 8
  store i8 4, ptr %.ph.i105, align 8
  br label %parts64_mul.exit

if.end43.i:                                       ; preds = %if.end32.i
  %and44.i = and i32 %or.i, 8
  %tobool45.i.not = icmp eq i32 %and44.i, 0
  br i1 %tobool45.i.not, label %if.end51.i, label %if.then46.i

if.then46.i:                                      ; preds = %if.end43.i
  store i8 3, ptr %pa, align 8
  store i8 %17, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  br label %parts64_mul.exit

if.end51.i:                                       ; preds = %if.end43.i
  %and52.i = and i32 %or.i, 2
  %tobool53.i.not = icmp eq i32 %and52.i, 0
  br i1 %tobool53.i.not, label %if.else.i, label %if.then54.i

if.then54.i:                                      ; preds = %if.end51.i
  store i8 1, ptr %pa, align 8
  store i8 %17, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  br label %parts64_mul.exit

if.else.i:                                        ; preds = %if.end51.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 460, ptr noundef nonnull @__func__.parts64_mul, ptr noundef nonnull @.str.7) #16
  unreachable

parts64_mul.exit:                                 ; preds = %lor.lhs.false.i.i, %if.then24.i, %23, %if.then6.i.i, %if.then3.i, %if.then54.i, %if.then46.i, %if.then31.i, %if.end.i
  %retval.i.0 = phi ptr [ %pa, %if.end.i ], [ %pa, %if.then31.i ], [ %pa, %if.then46.i ], [ %pa, %if.then54.i ], [ %pa, %if.then3.i ], [ %.ph.i105, %if.then24.i ], [ %pb, %23 ], [ %pa, %if.then6.i.i ], [ %spec.select110, %lor.lhs.false.i.i ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %retval.i.0, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 1
  %26 = load i8, ptr %sign.i.i, align 1
  %conv.i.i95 = zext i8 %26 to i64
  %shl.i.i96 = shl nuw nsw i64 %conv.i.i95, 15
  %exp.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 4
  %27 = load i32, ptr %exp.i.i, align 4
  %28 = shl i32 %27, 7
  %29 = and i32 %28, 32640
  %and8.i.i = zext nneg i32 %29 to i64
  %or.i.i = or disjoint i64 %shl.i.i96, %and8.i.i
  %30 = getelementptr inbounds i8, ptr %retval.i.0, i64 8
  %31 = load i64, ptr %30, align 8
  %shl77.i9.i = and i64 %31, 127
  %or.i10.i = or disjoint i64 %or.i.i, %shl77.i9.i
  %conv.i97 = trunc i64 %or.i10.i to i16
  ret i16 %conv.i97
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_mul(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts128, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts128, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %shr.i16.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i to i32
  %conv.i44 = and i32 %0, 32767
  %f.coerce1.lobit.i = lshr i64 %a.coerce1, 63
  %frombool.i = trunc i64 %f.coerce1.lobit.i to i8
  %and.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %pa, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i44, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pa, ptr noundef %status, ptr noundef nonnull @float128_params)
  %shr.i16.i45 = lshr i64 %b.coerce1, 48
  %1 = trunc i64 %shr.i16.i45 to i32
  %conv.i46 = and i32 %1, 32767
  %f.coerce1.lobit.i47 = lshr i64 %b.coerce1, 63
  %frombool.i48 = trunc i64 %f.coerce1.lobit.i47 to i8
  %and.i.i49 = and i64 %b.coerce1, 281474976710655
  store i8 0, ptr %pb, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i50 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i48, ptr %.compoundliteral.sroa.2.0..sroa_idx.i50, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i51 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i46, ptr %.compoundliteral.sroa.33.0..sroa_idx.i51, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i52 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i.i49, ptr %.compoundliteral.sroa.4.0..sroa_idx.i52, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i53 = getelementptr inbounds i8, ptr %pb, i64 16
  store i64 %b.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i53, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pb, ptr noundef %status, ptr noundef nonnull @float128_params)
  %2 = load i8, ptr %pa, align 8
  %conv.i = zext nneg i8 %2 to i32
  %shl.i = shl nuw i32 1, %conv.i
  %3 = load i8, ptr %pb, align 8
  %conv2.i = zext nneg i8 %3 to i32
  %shl3.i = shl nuw i32 1, %conv2.i
  %or.i = or i32 %shl3.i, %shl.i
  %4 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %5 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i50, align 1
  %6 = xor i8 %5, %4
  %xor.i41 = and i8 %6, 1
  switch i32 %or.i, label %if.end32.i [
    i32 4, label %if.then.i
    i32 10, label %if.then31.i
  ]

if.then.i:                                        ; preds = %entry
  %pa.val = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %pa.val42 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %pb.val = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i52, align 8
  %pb.val43 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i53, align 8
  %conv.i.i.i.i = zext i64 %pa.val42 to i128
  %conv1.i.i.i.i = zext i64 %pb.val to i128
  %mul.i.i.i.i = mul nuw i128 %conv1.i.i.i.i, %conv.i.i.i.i
  %conv2.i.i.i.i = trunc i128 %mul.i.i.i.i to i64
  %shr.i.i.i.i = lshr i128 %mul.i.i.i.i, 64
  %conv3.i.i.i.i = trunc i128 %shr.i.i.i.i to i64
  %conv.i.i5.i.i = zext i64 %pa.val to i128
  %conv1.i.i6.i.i = zext i64 %pb.val43 to i128
  %mul.i.i7.i.i = mul nuw i128 %conv1.i.i6.i.i, %conv.i.i5.i.i
  %conv2.i.i8.i.i = trunc i128 %mul.i.i7.i.i to i64
  %shr.i.i9.i.i = lshr i128 %mul.i.i7.i.i, 64
  %conv3.i.i10.i.i = trunc i128 %shr.i.i9.i.i to i64
  %mul.i.i13.i.i = mul nuw i128 %conv1.i.i6.i.i, %conv.i.i.i.i
  %conv2.i.i14.i.i = trunc i128 %mul.i.i13.i.i to i64
  %shr.i.i15.i.i = lshr i128 %mul.i.i13.i.i, 64
  %conv3.i.i16.i.i = trunc i128 %shr.i.i15.i.i to i64
  %mul.i.i19.i.i = mul nuw i128 %conv1.i.i.i.i, %conv.i.i5.i.i
  %conv2.i.i20.i.i = trunc i128 %mul.i.i19.i.i to i64
  %shr.i.i21.i.i = lshr i128 %mul.i.i19.i.i, 64
  %conv3.i.i22.i.i = trunc i128 %shr.i.i21.i.i to i64
  %7 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i.i.i, i64 %conv2.i.i8.i.i)
  %8 = extractvalue { i64, i1 } %7, 1
  %9 = extractvalue { i64, i1 } %7, 0
  %conv.i1.i.i.i = zext i1 %8 to i64
  %10 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv3.i.i.i.i, i64 %conv3.i.i10.i.i)
  %11 = extractvalue { i64, i1 } %10, 1
  %12 = extractvalue { i64, i1 } %10, 0
  %13 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %12, i64 %conv.i1.i.i.i)
  %14 = extractvalue { i64, i1 } %13, 1
  %15 = extractvalue { i64, i1 } %13, 0
  %16 = or i1 %11, %14
  %conv.i3.i.i.i = zext i1 %16 to i64
  %17 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %9, i64 %conv3.i.i16.i.i)
  %18 = extractvalue { i64, i1 } %17, 1
  %19 = extractvalue { i64, i1 } %17, 0
  %conv.i1.i23.i.i = zext i1 %18 to i64
  %20 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %15, i64 %conv2.i.i20.i.i)
  %21 = extractvalue { i64, i1 } %20, 1
  %22 = extractvalue { i64, i1 } %20, 0
  %23 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %22, i64 %conv.i1.i23.i.i)
  %24 = extractvalue { i64, i1 } %23, 1
  %25 = extractvalue { i64, i1 } %23, 0
  %26 = or i1 %21, %24
  %conv.i3.i24.i.i = zext i1 %26 to i64
  %27 = add nuw i64 %conv.i3.i.i.i, %conv3.i.i22.i.i
  %28 = add i64 %27, %conv.i3.i24.i.i
  store i64 %28, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %or.i57 = or i64 %19, %conv2.i.i14.i.i
  %cmp.i = icmp ne i64 %or.i57, 0
  %conv2.i58 = zext i1 %cmp.i to i64
  %or3.i = or i64 %25, %conv2.i58
  store i64 %or3.i, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %29 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i51, align 4
  %30 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %add.i = add i32 %30, %29
  %add15.i = add i32 %add.i, 1
  store i32 %add15.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %tobool16.i.not = icmp sgt i64 %28, -1
  br i1 %tobool16.i.not, label %if.then17.i, label %if.end.i

if.then17.i:                                      ; preds = %if.then.i
  %31 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %or3.i, i64 %or3.i)
  %32 = extractvalue { i64, i1 } %31, 1
  %33 = extractvalue { i64, i1 } %31, 0
  store i64 %33, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %conv.i4.i = zext i1 %32 to i64
  %34 = shl nuw i64 %28, 1
  %35 = or disjoint i64 %34, %conv.i4.i
  store i64 %35, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i32 %add.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then17.i, %if.then.i
  store i8 %xor.i41, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  br label %parts128_mul.exit

if.then31.i:                                      ; preds = %entry
  %36 = load i16, ptr %status, align 2
  %or1.i = or i16 %36, 257
  store i16 %or1.i, ptr %status, align 2
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %do.end18.i

if.end32.i:                                       ; preds = %entry
  %and33.i = and i32 %or.i, 48
  %tobool34.i.not = icmp eq i32 %and33.i, 0
  br i1 %tobool34.i.not, label %if.end43.i, label %if.then41.i

if.then41.i:                                      ; preds = %if.end32.i
  %cmp.i.i = icmp eq i8 %2, 5
  %cmp.i17.i = icmp eq i8 %3, 5
  %or.cond = or i1 %cmp.i.i, %cmp.i17.i
  br i1 %or.cond, label %if.then.i68, label %if.end.i66

if.then.i68:                                      ; preds = %if.then41.i
  %37 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %37, 8193
  store i16 %or1.i.i, ptr %status, align 2
  br label %if.end.i66

if.end.i66:                                       ; preds = %if.then41.i, %if.then.i68
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %38 = load i8, ptr %default_nan_mode.i, align 1
  %39 = and i8 %38, 1
  %tobool.not.i = icmp eq i8 %39, 0
  br i1 %tobool.not.i, label %if.else.i67, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i66
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %do.end18.i

if.else.i67:                                      ; preds = %if.end.i66
  %40 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %41 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i52, align 8
  %cmp.i18.i = icmp eq i64 %40, %41
  br i1 %cmp.i18.i, label %if.then.i.i, label %frac128_cmp.exit.i

if.then.i.i:                                      ; preds = %if.else.i67
  %42 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %43 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i53, align 8
  %cmp3.i.i = icmp eq i64 %42, %43
  br i1 %cmp3.i.i, label %if.then6.i, label %frac128_cmp.exit.i

frac128_cmp.exit.i:                               ; preds = %if.then.i.i, %if.else.i67
  %ta.0.i.i = phi i64 [ %42, %if.then.i.i ], [ %40, %if.else.i67 ]
  %tb.0.i.i = phi i64 [ %43, %if.then.i.i ], [ %41, %if.else.i67 ]
  %cmp6.i.i = icmp ult i64 %ta.0.i.i, %tb.0.i.i
  br label %if.end13.i

if.then6.i:                                       ; preds = %if.then.i.i
  %44 = and i8 %4, 1
  %45 = and i8 %5, 1
  %cmp11.i = icmp uge i8 %44, %45
  br label %if.end13.i

if.end13.i:                                       ; preds = %if.then6.i, %frac128_cmp.exit.i
  %cmp.0.i = phi i1 [ %cmp11.i, %if.then6.i ], [ %cmp6.i.i, %frac128_cmp.exit.i ]
  switch i8 %2, label %46 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end13.i
  br i1 %cmp.i17.i, label %do.end18.i, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %3, 4
  %spec.select.i.i = and i1 %cmp.i11.i.i, %cmp.0.i
  %cond.fr31.i = freeze i1 %spec.select.i.i
  br i1 %cond.fr31.i, label %parts128_mul.exit, label %do.end18.i

pickNaN.exit.i:                                   ; preds = %if.end13.i
  %cmp.i8.i.i = icmp eq i8 %3, 4
  %spec.select25.i = select i1 %cmp.i17.i, i1 %cmp.0.i, i1 %cmp.i8.i.i
  %cond.fr.i = freeze i1 %spec.select25.i
  br i1 %cond.fr.i, label %46, label %if.then24.i

46:                                               ; preds = %if.end13.i, %pickNaN.exit.i
  %cmp.i21.i = icmp eq i8 %3, 5
  br i1 %cmp.i21.i, label %if.then24.i, label %parts128_mul.exit

if.then24.i:                                      ; preds = %pickNaN.exit.i, %46
  %.ph.i93 = phi ptr [ %pb, %46 ], [ %pa, %pickNaN.exit.i ]
  %.ph.i93.sroa.phi = phi ptr [ %pb.sroa.gep, %46 ], [ %pa.sroa.gep, %pickNaN.exit.i ]
  %47 = load i64, ptr %.ph.i93.sroa.phi, align 8
  %or4.i.i.i = or i64 %47, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.ph.i93.sroa.phi, align 8
  store i8 4, ptr %.ph.i93, align 8
  br label %do.end18.i

if.end43.i:                                       ; preds = %if.end32.i
  %and44.i = and i32 %or.i, 8
  %tobool45.i.not = icmp eq i32 %and44.i, 0
  br i1 %tobool45.i.not, label %if.end51.i, label %parts128_mul.exit.thread86

parts128_mul.exit.thread86:                       ; preds = %if.end43.i
  store i8 %xor.i41, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  br label %do.end.i

if.end51.i:                                       ; preds = %if.end43.i
  %and52.i = and i32 %or.i, 2
  %tobool53.i.not = icmp eq i32 %and52.i, 0
  br i1 %tobool53.i.not, label %if.else.i, label %parts128_mul.exit.thread83

parts128_mul.exit.thread83:                       ; preds = %if.end51.i
  store i8 %xor.i41, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  br label %sw.bb.i

if.else.i:                                        ; preds = %if.end51.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 460, ptr noundef nonnull @__func__.parts128_mul, ptr noundef nonnull @.str.7) #16
  unreachable

parts128_mul.exit:                                ; preds = %lor.lhs.false.i.i, %if.end.i, %46
  %48 = phi i8 [ %3, %46 ], [ %2, %if.end.i ], [ %3, %lor.lhs.false.i.i ]
  %retval.i.0 = phi ptr [ %pb, %46 ], [ %pa, %if.end.i ], [ %pb, %lor.lhs.false.i.i ]
  switch i8 %48, label %do.body21.i [
    i8 2, label %if.then.i71
    i8 1, label %sw.bb.i
    i8 3, label %do.end.i
    i8 4, label %do.end18.i
    i8 5, label %do.end18.i
  ]

if.then.i71:                                      ; preds = %parts128_mul.exit
  call fastcc void @parts128_uncanon_normal(ptr noundef nonnull %retval.i.0, ptr noundef %status, ptr noundef nonnull @float128_params)
  %exp.i73.phi.trans.insert = getelementptr inbounds i8, ptr %retval.i.0, i64 4
  %.pre = load i32, ptr %exp.i73.phi.trans.insert, align 4
  %49 = zext i32 %.pre to i64
  %50 = shl i64 %49, 48
  %51 = and i64 %50, 9223090561878065152
  br label %parts128_uncanon.exit

sw.bb.i:                                          ; preds = %parts128_mul.exit.thread83, %parts128_mul.exit
  %retval.i.085 = phi ptr [ %pa, %parts128_mul.exit.thread83 ], [ %retval.i.0, %parts128_mul.exit ]
  %exp.i70 = getelementptr inbounds i8, ptr %retval.i.085, i64 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(20) %exp.i70, i8 0, i64 20, i1 false)
  br label %parts128_uncanon.exit

do.end.i:                                         ; preds = %parts128_mul.exit.thread86, %parts128_mul.exit
  %retval.i.088 = phi ptr [ %pa, %parts128_mul.exit.thread86 ], [ %retval.i.0, %parts128_mul.exit ]
  %exp10.i = getelementptr inbounds i8, ptr %retval.i.088, i64 4
  store i32 32767, ptr %exp10.i, align 4
  %frac_hi.i14.i = getelementptr inbounds i8, ptr %retval.i.088, i64 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %frac_hi.i14.i, i8 0, i64 16, i1 false)
  br label %parts128_uncanon.exit

do.end18.i:                                       ; preds = %lor.lhs.false.i.i, %if.then6.i.i, %if.then31.i, %if.then3.i, %if.then24.i, %parts128_mul.exit, %parts128_mul.exit
  %retval.i.081 = phi ptr [ %retval.i.0, %parts128_mul.exit ], [ %retval.i.0, %parts128_mul.exit ], [ %.ph.i93, %if.then24.i ], [ %pa, %if.then3.i ], [ %pa, %if.then31.i ], [ %pa, %if.then6.i.i ], [ %pa, %lor.lhs.false.i.i ]
  %exp20.i = getelementptr inbounds i8, ptr %retval.i.081, i64 4
  store i32 32767, ptr %exp20.i, align 4
  %frac_hi.i15.i = getelementptr inbounds i8, ptr %retval.i.081, i64 8
  %52 = load i64, ptr %frac_hi.i15.i, align 8
  %frac_lo.i.i69 = getelementptr inbounds i8, ptr %retval.i.081, i64 16
  %53 = load i64, ptr %frac_lo.i.i69, align 8
  %54 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %52, i32 15, i64 %53) #15, !srcloc !6
  %shr.i.i = lshr i64 %52, 15
  store i64 %shr.i.i, ptr %frac_hi.i15.i, align 8
  store i64 %54, ptr %frac_lo.i.i69, align 8
  br label %parts128_uncanon.exit

do.body21.i:                                      ; preds = %parts128_mul.exit
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 330, ptr noundef nonnull @__func__.parts128_uncanon, ptr noundef null) #16
  unreachable

parts128_uncanon.exit:                            ; preds = %if.then.i71, %sw.bb.i, %do.end.i, %do.end18.i
  %conv1.i = phi i64 [ %51, %if.then.i71 ], [ 0, %sw.bb.i ], [ 9223090561878065152, %do.end.i ], [ 9223090561878065152, %do.end18.i ]
  %retval.i.082 = phi ptr [ %retval.i.0, %if.then.i71 ], [ %retval.i.085, %sw.bb.i ], [ %retval.i.088, %do.end.i ], [ %retval.i.081, %do.end18.i ]
  %sign.i72 = getelementptr inbounds i8, ptr %retval.i.082, i64 1
  %55 = load i8, ptr %sign.i72, align 1
  %frac_hi.i74 = getelementptr inbounds i8, ptr %retval.i.082, i64 8
  %56 = load i64, ptr %frac_hi.i74, align 8
  %57 = and i8 %55, 1
  %conv.i75 = zext nneg i8 %57 to i64
  %shl.i76 = shl nuw i64 %conv.i75, 63
  %or.i25.i = or disjoint i64 %conv1.i, %shl.i76
  %and8.i.i = and i64 %56, 281474976710655
  %or.i.i = or disjoint i64 %or.i25.i, %and8.i.i
  %frac_lo.i77 = getelementptr inbounds i8, ptr %retval.i.082, i64 16
  %58 = load i64, ptr %frac_lo.i77, align 8
  %.fca.0.insert.i = insertvalue { i64, i64 } poison, i64 %58, 0
  %.fca.1.insert.i = insertvalue { i64, i64 } %.fca.0.insert.i, i64 %or.i.i, 1
  ret { i64, i64 } %.fca.1.insert.i
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc { i64, i64 } @float128_round_pack_canonical(ptr nocapture noundef %p, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %0 = load i8, ptr %p, align 8
  switch i8 %0, label %do.body21.i [
    i8 2, label %if.then.i
    i8 1, label %sw.bb.i
    i8 3, label %do.end.i
    i8 4, label %do.end18.i
    i8 5, label %do.end18.i
  ]

if.then.i:                                        ; preds = %entry
  tail call fastcc void @parts128_uncanon_normal(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float128_params)
  %exp.i2.phi.trans.insert = getelementptr inbounds i8, ptr %p, i64 4
  %.pre = load i32, ptr %exp.i2.phi.trans.insert, align 4
  %frac_hi.i.phi.trans.insert = getelementptr inbounds i8, ptr %p, i64 8
  %.pre3 = load i64, ptr %frac_hi.i.phi.trans.insert, align 8
  %frac_lo.i.phi.trans.insert = getelementptr inbounds i8, ptr %p, i64 16
  %.pre4 = load i64, ptr %frac_lo.i.phi.trans.insert, align 8
  %1 = zext i32 %.pre to i64
  %2 = shl i64 %1, 48
  %3 = and i64 %2, 9223090561878065152
  br label %parts128_uncanon.exit

sw.bb.i:                                          ; preds = %entry
  %exp.i = getelementptr inbounds i8, ptr %p, i64 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(20) %exp.i, i8 0, i64 20, i1 false)
  br label %parts128_uncanon.exit

do.end.i:                                         ; preds = %entry
  %exp10.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 32767, ptr %exp10.i, align 4
  %frac_hi.i14.i = getelementptr inbounds i8, ptr %p, i64 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %frac_hi.i14.i, i8 0, i64 16, i1 false)
  br label %parts128_uncanon.exit

do.end18.i:                                       ; preds = %entry, %entry
  %exp20.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 32767, ptr %exp20.i, align 4
  %frac_hi.i15.i = getelementptr inbounds i8, ptr %p, i64 8
  %4 = load i64, ptr %frac_hi.i15.i, align 8
  %frac_lo.i.i = getelementptr inbounds i8, ptr %p, i64 16
  %5 = load i64, ptr %frac_lo.i.i, align 8
  %6 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %4, i32 15, i64 %5) #15, !srcloc !6
  %shr.i.i = lshr i64 %4, 15
  store i64 %shr.i.i, ptr %frac_hi.i15.i, align 8
  store i64 %6, ptr %frac_lo.i.i, align 8
  br label %parts128_uncanon.exit

do.body21.i:                                      ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 330, ptr noundef nonnull @__func__.parts128_uncanon, ptr noundef null) #16
  unreachable

parts128_uncanon.exit:                            ; preds = %if.then.i, %sw.bb.i, %do.end.i, %do.end18.i
  %7 = phi i64 [ %.pre4, %if.then.i ], [ 0, %sw.bb.i ], [ 0, %do.end.i ], [ %6, %do.end18.i ]
  %8 = phi i64 [ %.pre3, %if.then.i ], [ 0, %sw.bb.i ], [ 0, %do.end.i ], [ %shr.i.i, %do.end18.i ]
  %conv1.i = phi i64 [ %3, %if.then.i ], [ 0, %sw.bb.i ], [ 9223090561878065152, %do.end.i ], [ 9223090561878065152, %do.end18.i ]
  %sign.i = getelementptr inbounds i8, ptr %p, i64 1
  %9 = load i8, ptr %sign.i, align 1
  %10 = and i8 %9, 1
  %conv.i = zext nneg i8 %10 to i64
  %shl.i = shl nuw i64 %conv.i, 63
  %or.i25.i = or disjoint i64 %conv1.i, %shl.i
  %and8.i.i = and i64 %8, 281474976710655
  %or.i.i = or disjoint i64 %or.i25.i, %and8.i.i
  %.fca.0.insert.i = insertvalue { i64, i64 } poison, i64 %7, 0
  %.fca.1.insert.i = insertvalue { i64, i64 } %.fca.0.insert.i, i64 %or.i.i, 1
  ret { i64, i64 } %.fca.1.insert.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @floatx80_mul(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p64.i = alloca %struct.FloatParts64, align 8
  %pa = alloca %struct.FloatParts128, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts128, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %floatx80_rounding_precision.i27 = getelementptr inbounds i8, ptr %status, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i27, align 1
  %switch = icmp ult i8 %0, 3
  br i1 %switch, label %sw.bb.i29, label %sw.default.i56

sw.bb.i29:                                        ; preds = %entry
  %cmp.i = icmp sgt i64 %a.coerce0, -1
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i = icmp ne i16 %1, 0
  %2 = select i1 %cmp.i, i1 %cmp2.i, i1 false
  br i1 %2, label %floatx80_unpack_canonical.exit57, label %if.end.i34

sw.default.i56:                                   ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

if.end.i34:                                       ; preds = %sw.bb.i29
  %f.coerce1.lobit.i = lshr i16 %a.coerce1, 15
  %frombool.i = trunc i16 %f.coerce1.lobit.i to i8
  %and.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %pa, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %and.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %cmp.i36.not = icmp eq i16 %1, 32767
  br i1 %cmp.i36.not, label %lor.lhs.false.thread, label %lor.lhs.false

lor.lhs.false.thread:                             ; preds = %if.end.i34
  %and.i42 = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i42, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %cmp12.i44 = icmp eq i64 %and.i42, 0
  %3 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i = icmp eq i64 %3, 0
  %cond.i48 = select i1 %tobool.not.i, i8 5, i8 4
  %cond17.i50 = select i1 %cmp12.i44, i8 3, i8 %cond.i48
  store i8 %cond17.i50, ptr %pa, align 8
  br label %sw.bb.i

floatx80_unpack_canonical.exit57:                 ; preds = %sw.bb.i29
  %4 = load i16, ptr %status, align 2
  %or1.i = or i16 %4, 1
  store i16 %or1.i, ptr %status, align 2
  br label %return

lor.lhs.false:                                    ; preds = %if.end.i34
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pa, ptr noundef nonnull %status, ptr noundef nonnull @floatx80_params)
  %.pre = load i8, ptr %floatx80_rounding_precision.i27, align 1
  %switch80 = icmp ult i8 %.pre, 3
  br i1 %switch80, label %sw.bb.i, label %sw.default.i

sw.bb.i:                                          ; preds = %lor.lhs.false.thread, %lor.lhs.false
  %cmp.i84 = icmp sgt i64 %b.coerce0, -1
  %5 = and i16 %b.coerce1, 32767
  %cmp2.i85 = icmp ne i16 %5, 0
  %6 = select i1 %cmp.i84, i1 %cmp2.i85, i1 false
  br i1 %6, label %floatx80_unpack_canonical.exit, label %if.end.i15

sw.default.i:                                     ; preds = %lor.lhs.false
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

if.end.i15:                                       ; preds = %sw.bb.i
  %f.coerce1.lobit.i87 = lshr i16 %b.coerce1, 15
  %frombool.i88 = trunc i16 %f.coerce1.lobit.i87 to i8
  %and.i.i89 = zext nneg i16 %5 to i32
  store i8 0, ptr %pb, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i90 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i88, ptr %.compoundliteral.sroa.2.0..sroa_idx.i90, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i91 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %and.i.i89, ptr %.compoundliteral.sroa.32.0..sroa_idx.i91, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i92 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %b.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i92, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i93 = getelementptr inbounds i8, ptr %pb, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i93, align 8
  %cmp.i17.not = icmp eq i16 %5, 32767
  br i1 %cmp.i17.not, label %if.else.i19, label %if.then10.i

if.then10.i:                                      ; preds = %if.end.i15
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pb, ptr noundef nonnull %status, ptr noundef nonnull @floatx80_params)
  %.pr = load i8, ptr %pb, align 8
  %.pre134 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i90, align 1
  br label %if.end

if.else.i19:                                      ; preds = %if.end.i15
  %and.i21 = and i64 %b.coerce0, 9223372036854775807
  store i64 %and.i21, ptr %.compoundliteral.sroa.4.0..sroa_idx.i92, align 8
  %cmp12.i = icmp eq i64 %and.i21, 0
  %7 = and i64 %b.coerce0, 4611686018427387904
  %tobool.not.i94 = icmp eq i64 %7, 0
  %8 = select i1 %tobool.not.i94, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %8
  store i8 %cond17.i, ptr %pb, align 8
  br label %if.end

floatx80_unpack_canonical.exit:                   ; preds = %sw.bb.i
  %9 = load i16, ptr %status, align 2
  %or1.i86 = or i16 %9, 1
  store i16 %or1.i86, ptr %status, align 2
  br label %return

if.end:                                           ; preds = %if.then10.i, %if.else.i19
  %10 = phi i8 [ %.pre134, %if.then10.i ], [ %frombool.i88, %if.else.i19 ]
  %.pr.i.pre = phi i8 [ %.pr, %if.then10.i ], [ %cond17.i, %if.else.i19 ]
  %11 = load i8, ptr %pa, align 8
  %conv.i = zext nneg i8 %11 to i32
  %shl.i = shl nuw i32 1, %conv.i
  %conv2.i = zext nneg i8 %.pr.i.pre to i32
  %shl3.i = shl nuw i32 1, %conv2.i
  %or.i = or i32 %shl.i, %shl3.i
  %12 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %13 = xor i8 %10, %12
  %xor.i79 = and i8 %13, 1
  switch i32 %or.i, label %if.end32.i [
    i32 4, label %if.then.i
    i32 10, label %if.then31.i
  ]

if.then.i:                                        ; preds = %if.end
  %pa.val = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %pa.val82 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %pb.val = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i92, align 8
  %pb.val83 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i93, align 8
  %conv.i.i.i.i = zext i64 %pa.val82 to i128
  %conv1.i.i.i.i = zext i64 %pb.val to i128
  %mul.i.i.i.i = mul nuw i128 %conv1.i.i.i.i, %conv.i.i.i.i
  %conv2.i.i.i.i = trunc i128 %mul.i.i.i.i to i64
  %shr.i.i.i.i = lshr i128 %mul.i.i.i.i, 64
  %conv3.i.i.i.i = trunc i128 %shr.i.i.i.i to i64
  %conv.i.i5.i.i = zext i64 %pa.val to i128
  %conv1.i.i6.i.i = zext i64 %pb.val83 to i128
  %mul.i.i7.i.i = mul nuw i128 %conv1.i.i6.i.i, %conv.i.i5.i.i
  %conv2.i.i8.i.i = trunc i128 %mul.i.i7.i.i to i64
  %shr.i.i9.i.i = lshr i128 %mul.i.i7.i.i, 64
  %conv3.i.i10.i.i = trunc i128 %shr.i.i9.i.i to i64
  %mul.i.i13.i.i = mul nuw i128 %conv1.i.i6.i.i, %conv.i.i.i.i
  %conv2.i.i14.i.i = trunc i128 %mul.i.i13.i.i to i64
  %shr.i.i15.i.i = lshr i128 %mul.i.i13.i.i, 64
  %conv3.i.i16.i.i = trunc i128 %shr.i.i15.i.i to i64
  %mul.i.i19.i.i = mul nuw i128 %conv1.i.i.i.i, %conv.i.i5.i.i
  %conv2.i.i20.i.i = trunc i128 %mul.i.i19.i.i to i64
  %shr.i.i21.i.i = lshr i128 %mul.i.i19.i.i, 64
  %conv3.i.i22.i.i = trunc i128 %shr.i.i21.i.i to i64
  %14 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i.i.i, i64 %conv2.i.i8.i.i)
  %15 = extractvalue { i64, i1 } %14, 1
  %16 = extractvalue { i64, i1 } %14, 0
  %conv.i1.i.i.i = zext i1 %15 to i64
  %17 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv3.i.i.i.i, i64 %conv3.i.i10.i.i)
  %18 = extractvalue { i64, i1 } %17, 1
  %19 = extractvalue { i64, i1 } %17, 0
  %20 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %19, i64 %conv.i1.i.i.i)
  %21 = extractvalue { i64, i1 } %20, 1
  %22 = extractvalue { i64, i1 } %20, 0
  %23 = or i1 %18, %21
  %conv.i3.i.i.i = zext i1 %23 to i64
  %24 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %16, i64 %conv3.i.i16.i.i)
  %25 = extractvalue { i64, i1 } %24, 1
  %26 = extractvalue { i64, i1 } %24, 0
  %conv.i1.i23.i.i = zext i1 %25 to i64
  %27 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %22, i64 %conv2.i.i20.i.i)
  %28 = extractvalue { i64, i1 } %27, 1
  %29 = extractvalue { i64, i1 } %27, 0
  %30 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %29, i64 %conv.i1.i23.i.i)
  %31 = extractvalue { i64, i1 } %30, 1
  %32 = extractvalue { i64, i1 } %30, 0
  %33 = or i1 %28, %31
  %conv.i3.i24.i.i = zext i1 %33 to i64
  %34 = add nuw i64 %conv.i3.i.i.i, %conv3.i.i22.i.i
  %35 = add i64 %34, %conv.i3.i24.i.i
  store i64 %35, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %or.i98 = or i64 %26, %conv2.i.i14.i.i
  %cmp.i99 = icmp ne i64 %or.i98, 0
  %conv2.i100 = zext i1 %cmp.i99 to i64
  %or3.i = or i64 %32, %conv2.i100
  store i64 %or3.i, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %36 = load i32, ptr %.compoundliteral.sroa.32.0..sroa_idx.i91, align 4
  %37 = load i32, ptr %.compoundliteral.sroa.32.0..sroa_idx.i, align 4
  %add.i = add i32 %37, %36
  %add15.i = add i32 %add.i, 1
  store i32 %add15.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i, align 4
  %tobool16.i.not = icmp sgt i64 %35, -1
  br i1 %tobool16.i.not, label %if.then17.i, label %if.end.i

if.then17.i:                                      ; preds = %if.then.i
  %38 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %or3.i, i64 %or3.i)
  %39 = extractvalue { i64, i1 } %38, 1
  %40 = extractvalue { i64, i1 } %38, 0
  store i64 %40, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %conv.i4.i = zext i1 %39 to i64
  %41 = shl nuw i64 %35, 1
  %42 = or disjoint i64 %41, %conv.i4.i
  store i64 %42, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i32 %add.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i, align 4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then17.i, %if.then.i
  store i8 %xor.i79, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  br label %parts128_mul.exitthread-pre-split

if.then31.i:                                      ; preds = %if.end
  %43 = load i16, ptr %status, align 2
  %or1.i105 = or i16 %43, 257
  store i16 %or1.i105, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %parts128_mul.exitthread-pre-split

if.end32.i:                                       ; preds = %if.end
  %and33.i = and i32 %or.i, 48
  %tobool34.i.not = icmp eq i32 %and33.i, 0
  br i1 %tobool34.i.not, label %if.end43.i, label %if.then41.i

if.then41.i:                                      ; preds = %if.end32.i
  %cmp.i.i = icmp eq i8 %11, 5
  %cmp.i17.i = icmp eq i8 %.pr.i.pre, 5
  %or.cond = or i1 %cmp.i17.i, %cmp.i.i
  br i1 %or.cond, label %if.then.i111, label %if.end.i109

if.then.i111:                                     ; preds = %if.then41.i
  %44 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %44, 8193
  store i16 %or1.i.i, ptr %status, align 2
  br label %if.end.i109

if.end.i109:                                      ; preds = %if.then41.i, %if.then.i111
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %45 = load i8, ptr %default_nan_mode.i, align 1
  %46 = and i8 %45, 1
  %tobool.not.i110 = icmp eq i8 %46, 0
  br i1 %tobool.not.i110, label %if.else.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i109
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %parts128_mul.exitthread-pre-split

if.else.i:                                        ; preds = %if.end.i109
  %47 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %48 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i92, align 8
  %cmp.i18.i = icmp eq i64 %47, %48
  br i1 %cmp.i18.i, label %if.then.i.i, label %frac128_cmp.exit.i

if.then.i.i:                                      ; preds = %if.else.i
  %49 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %50 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i93, align 8
  %cmp3.i.i = icmp eq i64 %49, %50
  br i1 %cmp3.i.i, label %if.then6.i, label %frac128_cmp.exit.i

frac128_cmp.exit.i:                               ; preds = %if.then.i.i, %if.else.i
  %ta.0.i.i = phi i64 [ %49, %if.then.i.i ], [ %47, %if.else.i ]
  %tb.0.i.i = phi i64 [ %50, %if.then.i.i ], [ %48, %if.else.i ]
  %cmp6.i.i = icmp ult i64 %ta.0.i.i, %tb.0.i.i
  br label %if.end13.i

if.then6.i:                                       ; preds = %if.then.i.i
  %51 = and i8 %12, 1
  %52 = and i8 %10, 1
  %cmp11.i = icmp uge i8 %51, %52
  br label %if.end13.i

if.end13.i:                                       ; preds = %if.then6.i, %frac128_cmp.exit.i
  %cmp.0.i = phi i1 [ %cmp11.i, %if.then6.i ], [ %cmp6.i.i, %frac128_cmp.exit.i ]
  switch i8 %11, label %53 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end13.i
  br i1 %cmp.i17.i, label %parts128_mul.exitthread-pre-split, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select.i.i = and i1 %cmp.i11.i.i, %cmp.0.i
  %cond.fr31.i = freeze i1 %spec.select.i.i
  %.pre138153 = load i8, ptr %floatx80_rounding_precision.i27, align 1
  br i1 %cond.fr31.i, label %parts128_mul.exit, label %parts128_mul.exit.thread154

parts128_mul.exit.thread154:                      ; preds = %lor.lhs.false.i.i
  %idxprom.i156 = zext i8 %.pre138153 to i64
  %arrayidx.i157 = getelementptr [3 x %struct.FloatFmt], ptr @floatx80_params, i64 0, i64 %idxprom.i156
  br label %sw.bb16.i

pickNaN.exit.i:                                   ; preds = %if.end13.i
  %cmp.i8.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select25.i = select i1 %cmp.i17.i, i1 %cmp.0.i, i1 %cmp.i8.i.i
  %cond.fr.i = freeze i1 %spec.select25.i
  br i1 %cond.fr.i, label %53, label %.thread

.thread:                                          ; preds = %pickNaN.exit.i
  %.pre138143 = load i8, ptr %floatx80_rounding_precision.i27, align 1
  br label %parts128_mul.exit.thread128

53:                                               ; preds = %if.end13.i, %pickNaN.exit.i
  %cmp.i21.i = icmp eq i8 %.pr.i.pre, 5
  %.pre138 = load i8, ptr %floatx80_rounding_precision.i27, align 1
  br i1 %cmp.i21.i, label %parts128_mul.exit.thread128, label %parts128_mul.exit

parts128_mul.exit.thread128:                      ; preds = %.thread, %53
  %.pre138145 = phi i8 [ %.pre138143, %.thread ], [ %.pre138, %53 ]
  %.ph.i144 = phi ptr [ %pa, %.thread ], [ %pb, %53 ]
  %.ph.i144.sroa.phi = phi ptr [ %pa.sroa.gep, %.thread ], [ %pb.sroa.gep, %53 ]
  %54 = load i64, ptr %.ph.i144.sroa.phi, align 8
  %or4.i.i.i = or i64 %54, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.ph.i144.sroa.phi, align 8
  store i8 4, ptr %.ph.i144, align 8
  %idxprom.i130 = zext i8 %.pre138145 to i64
  %arrayidx.i131 = getelementptr [3 x %struct.FloatFmt], ptr @floatx80_params, i64 0, i64 %idxprom.i130
  br label %sw.bb16.i

if.end43.i:                                       ; preds = %if.end32.i
  %and44.i = and i32 %or.i, 8
  %tobool45.i.not = icmp eq i32 %and44.i, 0
  br i1 %tobool45.i.not, label %if.end51.i, label %parts128_mul.exit.thread

parts128_mul.exit.thread:                         ; preds = %if.end43.i
  store i8 %xor.i79, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %55 = load i8, ptr %floatx80_rounding_precision.i27, align 1
  %idxprom.i119 = zext i8 %55 to i64
  %arrayidx.i120 = getelementptr [3 x %struct.FloatFmt], ptr @floatx80_params, i64 0, i64 %idxprom.i119
  br label %sw.bb13.i

if.end51.i:                                       ; preds = %if.end43.i
  %and52.i = and i32 %or.i, 2
  %tobool53.i.not = icmp eq i32 %and52.i, 0
  br i1 %tobool53.i.not, label %if.else.i6, label %parts128_mul.exit.thread124

parts128_mul.exit.thread124:                      ; preds = %if.end51.i
  store i8 %xor.i79, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  br label %floatx80_round_pack_canonical.exit

if.else.i6:                                       ; preds = %if.end51.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 460, ptr noundef nonnull @__func__.parts128_mul, ptr noundef nonnull @.str.7) #16
  unreachable

parts128_mul.exitthread-pre-split:                ; preds = %if.end.i, %if.then31.i, %if.then3.i, %if.then6.i.i
  %.pr117 = phi i8 [ %11, %if.end.i ], [ 4, %if.then31.i ], [ 4, %if.then3.i ], [ 4, %if.then6.i.i ]
  %.pre137 = load i8, ptr %floatx80_rounding_precision.i27, align 1
  br label %parts128_mul.exit

parts128_mul.exit:                                ; preds = %lor.lhs.false.i.i, %parts128_mul.exitthread-pre-split, %53
  %56 = phi i8 [ %.pre137, %parts128_mul.exitthread-pre-split ], [ %.pre138, %53 ], [ %.pre138153, %lor.lhs.false.i.i ]
  %57 = phi i8 [ %.pr117, %parts128_mul.exitthread-pre-split ], [ %.pr.i.pre, %53 ], [ %.pr.i.pre, %lor.lhs.false.i.i ]
  %retval.i5.0 = phi ptr [ %pa, %parts128_mul.exitthread-pre-split ], [ %pb, %53 ], [ %pb, %lor.lhs.false.i.i ]
  %idxprom.i = zext i8 %56 to i64
  %arrayidx.i = getelementptr [3 x %struct.FloatFmt], ptr @floatx80_params, i64 0, i64 %idxprom.i
  switch i8 %57, label %sw.default.i76 [
    i8 2, label %sw.bb.i66
    i8 3, label %sw.bb13.i
    i8 1, label %floatx80_round_pack_canonical.exit
    i8 5, label %sw.bb16.i
    i8 4, label %sw.bb16.i
  ]

sw.bb.i66:                                        ; preds = %parts128_mul.exit
  %cmp.i68 = icmp eq i8 %56, 0
  br i1 %cmp.i68, label %if.then.i74, label %if.else.i69

if.then.i74:                                      ; preds = %sw.bb.i66
  call fastcc void @parts128_uncanon_normal(ptr noundef nonnull %retval.i5.0, ptr noundef nonnull %status, ptr noundef %arrayidx.i)
  %frac_hi.i75 = getelementptr inbounds i8, ptr %retval.i5.0, i64 8
  %58 = load i64, ptr %frac_hi.i75, align 8
  %exp4.i = getelementptr inbounds i8, ptr %retval.i5.0, i64 4
  br label %if.end.i73

if.else.i69:                                      ; preds = %sw.bb.i66
  %sign.i70 = getelementptr inbounds i8, ptr %retval.i5.0, i64 1
  %59 = load i8, ptr %sign.i70, align 1
  %60 = and i8 %59, 1
  %sign5.i = getelementptr inbounds i8, ptr %p64.i, i64 1
  store i8 %60, ptr %sign5.i, align 1
  %exp6.i = getelementptr inbounds i8, ptr %retval.i5.0, i64 4
  %61 = load i32, ptr %exp6.i, align 4
  %exp7.i = getelementptr inbounds i8, ptr %p64.i, i64 4
  store i32 %61, ptr %exp7.i, align 4
  %62 = getelementptr i8, ptr %retval.i5.0, i64 8
  %retval.i5.0.val = load i64, ptr %62, align 8
  %63 = getelementptr i8, ptr %retval.i5.0, i64 16
  %retval.i5.0.val81 = load i64, ptr %63, align 8
  %cmp.i112 = icmp ne i64 %retval.i5.0.val81, 0
  %conv1.i = zext i1 %cmp.i112 to i64
  %or.i113 = or i64 %retval.i5.0.val, %conv1.i
  %64 = getelementptr inbounds i8, ptr %p64.i, i64 8
  store i64 %or.i113, ptr %64, align 8
  call fastcc void @parts64_uncanon_normal(ptr noundef nonnull %p64.i, ptr noundef nonnull %status, ptr noundef %arrayidx.i)
  %65 = load i64, ptr %64, align 8
  br label %if.end.i73

if.end.i73:                                       ; preds = %if.else.i69, %if.then.i74
  %exp7.i.sink = phi ptr [ %exp7.i, %if.else.i69 ], [ %exp4.i, %if.then.i74 ]
  %frac.i.0 = phi i64 [ %65, %if.else.i69 ], [ %58, %if.then.i74 ]
  %66 = load i32, ptr %exp7.i.sink, align 4
  %exp_max.i = getelementptr inbounds i8, ptr %arrayidx.i, i64 12
  %67 = load i32, ptr %exp_max.i, align 4
  %cmp9.i.not = icmp eq i32 %66, %67
  br i1 %cmp9.i.not, label %sw.bb13.i, label %floatx80_round_pack_canonical.exit

sw.bb13.i:                                        ; preds = %parts128_mul.exit.thread, %if.end.i73, %parts128_mul.exit
  %arrayidx.i123 = phi ptr [ %arrayidx.i120, %parts128_mul.exit.thread ], [ %arrayidx.i, %if.end.i73 ], [ %arrayidx.i, %parts128_mul.exit ]
  %retval.i5.0122 = phi ptr [ %pa, %parts128_mul.exit.thread ], [ %retval.i5.0, %if.end.i73 ], [ %retval.i5.0, %parts128_mul.exit ]
  %exp_max14.i = getelementptr inbounds i8, ptr %arrayidx.i123, i64 12
  %68 = load i32, ptr %exp_max14.i, align 4
  br label %floatx80_round_pack_canonical.exit

sw.bb16.i:                                        ; preds = %parts128_mul.exit.thread154, %parts128_mul.exit.thread128, %parts128_mul.exit, %parts128_mul.exit
  %arrayidx.i133 = phi ptr [ %arrayidx.i131, %parts128_mul.exit.thread128 ], [ %arrayidx.i, %parts128_mul.exit ], [ %arrayidx.i, %parts128_mul.exit ], [ %arrayidx.i157, %parts128_mul.exit.thread154 ]
  %retval.i5.0132 = phi ptr [ %.ph.i144, %parts128_mul.exit.thread128 ], [ %retval.i5.0, %parts128_mul.exit ], [ %retval.i5.0, %parts128_mul.exit ], [ %pa, %parts128_mul.exit.thread154 ]
  %frac_hi17.i = getelementptr inbounds i8, ptr %retval.i5.0132, i64 8
  %69 = load i64, ptr %frac_hi17.i, align 8
  %or.i64 = or i64 %69, -9223372036854775808
  %exp_max18.i = getelementptr inbounds i8, ptr %arrayidx.i133, i64 12
  %70 = load i32, ptr %exp_max18.i, align 4
  br label %floatx80_round_pack_canonical.exit

sw.default.i76:                                   ; preds = %parts128_mul.exit
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1858, ptr noundef nonnull @__func__.floatx80_round_pack_canonical, ptr noundef null) #16
  unreachable

floatx80_round_pack_canonical.exit:               ; preds = %parts128_mul.exit.thread124, %parts128_mul.exit, %if.end.i73, %sw.bb16.i, %sw.bb13.i
  %retval.i5.0121 = phi ptr [ %retval.i5.0132, %sw.bb16.i ], [ %retval.i5.0122, %sw.bb13.i ], [ %retval.i5.0, %if.end.i73 ], [ %retval.i5.0, %parts128_mul.exit ], [ %pa, %parts128_mul.exit.thread124 ]
  %exp.i61.1 = phi i32 [ %70, %sw.bb16.i ], [ %68, %sw.bb13.i ], [ %66, %if.end.i73 ], [ 0, %parts128_mul.exit ], [ 0, %parts128_mul.exit.thread124 ]
  %frac.i.1 = phi i64 [ %or.i64, %sw.bb16.i ], [ -9223372036854775808, %sw.bb13.i ], [ %frac.i.0, %if.end.i73 ], [ 0, %parts128_mul.exit ], [ 0, %parts128_mul.exit.thread124 ]
  %sign19.i = getelementptr inbounds i8, ptr %retval.i5.0121, i64 1
  %71 = load i8, ptr %sign19.i, align 1
  %72 = zext i8 %71 to i32
  %shl.i114 = shl nuw nsw i32 %72, 15
  %add.i115 = add i32 %shl.i114, %exp.i61.1
  %conv2.i116 = trunc i32 %add.i115 to i16
  br label %return

return:                                           ; preds = %floatx80_unpack_canonical.exit57, %floatx80_unpack_canonical.exit, %floatx80_round_pack_canonical.exit
  %retval.sroa.0.0 = phi i64 [ %frac.i.1, %floatx80_round_pack_canonical.exit ], [ -4611686018427387904, %floatx80_unpack_canonical.exit ], [ -4611686018427387904, %floatx80_unpack_canonical.exit57 ]
  %retval.sroa.3.0 = phi i16 [ %conv2.i116, %floatx80_round_pack_canonical.exit ], [ -1, %floatx80_unpack_canonical.exit ], [ -1, %floatx80_unpack_canonical.exit57 ]
  %.fca.0.insert = insertvalue { i64, i16 } poison, i64 %retval.sroa.0.0, 0
  %.fca.1.insert = insertvalue { i64, i16 } %.fca.0.insert, i16 %retval.sroa.3.0, 1
  ret { i64, i16 } %.fca.1.insert
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc { i64, i16 } @floatx80_round_pack_canonical(ptr nocapture noundef %p, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %p64 = alloca %struct.FloatParts64, align 8
  %floatx80_rounding_precision = getelementptr inbounds i8, ptr %s, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision, align 1
  %idxprom = zext i8 %0 to i64
  %arrayidx = getelementptr [3 x %struct.FloatFmt], ptr @floatx80_params, i64 0, i64 %idxprom
  %1 = load i8, ptr %p, align 8
  switch i8 %1, label %do.body [
    i8 2, label %sw.bb
    i8 3, label %sw.epilog.sink.split
    i8 1, label %sw.epilog
    i8 5, label %sw.bb16
    i8 4, label %sw.bb16
  ]

sw.bb:                                            ; preds = %entry
  %cmp = icmp eq i8 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  tail call fastcc void @parts128_uncanon_normal(ptr noundef nonnull %p, ptr noundef nonnull %s, ptr noundef %arrayidx)
  %frac_hi = getelementptr inbounds i8, ptr %p, i64 8
  %2 = load i64, ptr %frac_hi, align 8
  %exp4 = getelementptr inbounds i8, ptr %p, i64 4
  br label %if.end

if.else:                                          ; preds = %sw.bb
  %sign = getelementptr inbounds i8, ptr %p, i64 1
  %3 = load i8, ptr %sign, align 1
  %4 = and i8 %3, 1
  %sign5 = getelementptr inbounds i8, ptr %p64, i64 1
  store i8 %4, ptr %sign5, align 1
  %exp6 = getelementptr inbounds i8, ptr %p, i64 4
  %5 = load i32, ptr %exp6, align 4
  %exp7 = getelementptr inbounds i8, ptr %p64, i64 4
  store i32 %5, ptr %exp7, align 4
  %6 = getelementptr i8, ptr %p, i64 8
  %p.val = load i64, ptr %6, align 8
  %7 = getelementptr i8, ptr %p, i64 16
  %p.val17 = load i64, ptr %7, align 8
  %cmp.i = icmp ne i64 %p.val17, 0
  %conv1.i = zext i1 %cmp.i to i64
  %or.i = or i64 %p.val, %conv1.i
  %8 = getelementptr inbounds i8, ptr %p64, i64 8
  store i64 %or.i, ptr %8, align 8
  call fastcc void @parts64_uncanon_normal(ptr noundef nonnull %p64, ptr noundef nonnull %s, ptr noundef %arrayidx)
  %9 = load i64, ptr %8, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %exp7.sink = phi ptr [ %exp7, %if.else ], [ %exp4, %if.then ]
  %frac.0 = phi i64 [ %9, %if.else ], [ %2, %if.then ]
  %10 = load i32, ptr %exp7.sink, align 4
  %exp_max = getelementptr inbounds i8, ptr %arrayidx, i64 12
  %11 = load i32, ptr %exp_max, align 4
  %cmp9.not = icmp eq i32 %10, %11
  %spec.select = select i1 %cmp9.not, i64 -9223372036854775808, i64 %frac.0
  br label %sw.epilog

sw.bb16:                                          ; preds = %entry, %entry
  %frac_hi17 = getelementptr inbounds i8, ptr %p, i64 8
  %12 = load i64, ptr %frac_hi17, align 8
  %or = or i64 %12, -9223372036854775808
  br label %sw.epilog.sink.split

do.body:                                          ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1858, ptr noundef nonnull @__func__.floatx80_round_pack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.sink.split:                             ; preds = %entry, %sw.bb16
  %frac.1.ph = phi i64 [ %or, %sw.bb16 ], [ -9223372036854775808, %entry ]
  %exp_max14.phi.trans.insert = getelementptr inbounds i8, ptr %arrayidx, i64 12
  %.pre = load i32, ptr %exp_max14.phi.trans.insert, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end, %sw.epilog.sink.split, %entry
  %frac.1 = phi i64 [ 0, %entry ], [ %spec.select, %if.end ], [ %frac.1.ph, %sw.epilog.sink.split ]
  %exp.1 = phi i32 [ 0, %entry ], [ %10, %if.end ], [ %.pre, %sw.epilog.sink.split ]
  %sign19 = getelementptr inbounds i8, ptr %p, i64 1
  %13 = load i8, ptr %sign19, align 1
  %14 = zext i8 %13 to i32
  %shl.i = shl nuw nsw i32 %14, 15
  %add.i = add i32 %shl.i, %exp.1
  %conv2.i = trunc i32 %add.i to i16
  %.fca.0.insert.i = insertvalue { i64, i16 } poison, i64 %frac.1, 0
  %.fca.1.insert.i = insertvalue { i64, i16 } %.fca.0.insert.i, i16 %conv2.i, 1
  ret { i64, i16 } %.fca.1.insert.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_muladd(i16 noundef zeroext %a, i16 noundef zeroext %b, i16 noundef zeroext %c, i32 noundef %flags, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p_widen.i = alloca %struct.FloatParts128, align 8
  %c_widen.i = alloca %struct.FloatParts128, align 8
  %pa = alloca %struct.FloatParts64, align 8
  %pa.sroa.gep168 = getelementptr inbounds i8, ptr %pa, i64 8
  %pa.sroa.gep163 = getelementptr inbounds i8, ptr %pa, i64 4
  %pa.sroa.gep158 = getelementptr inbounds i8, ptr %pa, i64 1
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %conv.i.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  store i32 %conv.i.i.i, ptr %pa.sroa.gep163, align 4
  store i64 %and.i10.i.i, ptr %pa.sroa.gep168, align 8
  switch i16 %1, label %if.then33.i.i [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %pa.sroa.gep168, align 8
  br label %float16a_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %pa.sroa.gep168, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %pa.sroa.gep163, align 4
  br label %float16a_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %pa.sroa.gep163, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %pa.sroa.gep168, align 8
  br label %float16a_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  store i64 %shl.i31.i.i, ptr %pa.sroa.gep168, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit:                   ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %pa.val = phi i64 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i.i, %if.then33.i.i ], [ 0, %if.then47.i.i ], [ %shl.i31.i.i, %if.else49.i.i ]
  %7 = phi i32 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %add.i.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ 31, %if.then47.i.i ], [ 31, %if.else49.i.i ]
  %8 = phi i8 [ 1, %if.then8.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ], [ 3, %if.then47.i.i ], [ %conv53.i.i, %if.else49.i.i ]
  %9 = lshr i16 %b, 10
  %10 = and i16 %9, 31
  %11 = and i16 %b, 1023
  %and.i10.i.i64 = zext nneg i16 %11 to i64
  switch i16 %10, label %if.then33.i.i78 [
    i16 0, label %if.then.i.i82
    i16 31, label %lor.lhs.false.i.i71
  ]

if.then.i.i82:                                    ; preds = %float16a_unpack_canonical.exit
  %cmp.i.i.i83 = icmp eq i16 %11, 0
  br i1 %cmp.i.i.i83, label %float16a_unpack_canonical.exit95, label %if.else.i.i84

if.else.i.i84:                                    ; preds = %if.then.i.i82
  %flush_inputs_to_zero.i.i85 = getelementptr inbounds i8, ptr %status, i64 6
  %12 = load i8, ptr %flush_inputs_to_zero.i.i85, align 2
  %13 = and i8 %12, 1
  %tobool9.not.i.i86 = icmp eq i8 %13, 0
  br i1 %tobool9.not.i.i86, label %frac64_normalize.exit.i.i89, label %if.then10.i.i87

if.then10.i.i87:                                  ; preds = %if.else.i.i84
  %14 = load i16, ptr %status, align 2
  %or1.i.i.i88 = or i16 %14, 32
  store i16 %or1.i.i.i88, ptr %status, align 2
  br label %float16a_unpack_canonical.exit95

frac64_normalize.exit.i.i89:                      ; preds = %if.else.i.i84
  %15 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i64, i1 true), !range !5
  %cast.i.i.i.i90 = trunc i64 %15 to i32
  %shl.i.i.i91 = shl i64 %and.i10.i.i64, %15
  %add.i.i93 = sub nsw i32 39, %cast.i.i.i.i90
  br label %float16a_unpack_canonical.exit95

lor.lhs.false.i.i71:                              ; preds = %float16a_unpack_canonical.exit
  %cmp.i29.i.i72 = icmp eq i16 %11, 0
  br i1 %cmp.i29.i.i72, label %float16a_unpack_canonical.exit95, label %if.else49.i.i73

if.then33.i.i78:                                  ; preds = %float16a_unpack_canonical.exit
  %conv.i.i.i63 = zext nneg i16 %10 to i32
  %sub37.i.i79 = add nsw i32 %conv.i.i.i63, -15
  %shl.i28.i.i80 = shl nuw nsw i64 %and.i10.i.i64, 53
  %or.i.i81 = or disjoint i64 %shl.i28.i.i80, -9223372036854775808
  br label %float16a_unpack_canonical.exit95

if.else49.i.i73:                                  ; preds = %lor.lhs.false.i.i71
  %shl.i31.i.i74 = shl nuw nsw i64 %and.i10.i.i64, 53
  %tobool.not.i32.i.i75 = icmp ult i16 %11, 512
  %conv53.i.i76 = select i1 %tobool.not.i32.i.i75, i32 5, i32 4
  br label %float16a_unpack_canonical.exit95

float16a_unpack_canonical.exit95:                 ; preds = %lor.lhs.false.i.i71, %if.then.i.i82, %if.then10.i.i87, %frac64_normalize.exit.i.i89, %if.then33.i.i78, %if.else49.i.i73
  %pb.sroa.10.0 = phi i32 [ %add.i.i93, %frac64_normalize.exit.i.i89 ], [ 0, %if.then10.i.i87 ], [ %sub37.i.i79, %if.then33.i.i78 ], [ 31, %if.else49.i.i73 ], [ 0, %if.then.i.i82 ], [ 31, %lor.lhs.false.i.i71 ]
  %pb.sroa.0.0 = phi i32 [ 2, %frac64_normalize.exit.i.i89 ], [ 1, %if.then10.i.i87 ], [ 2, %if.then33.i.i78 ], [ %conv53.i.i76, %if.else49.i.i73 ], [ 1, %if.then.i.i82 ], [ 3, %lor.lhs.false.i.i71 ]
  %pb.sroa.14.0 = phi i64 [ %shl.i.i.i91, %frac64_normalize.exit.i.i89 ], [ 0, %if.then10.i.i87 ], [ %or.i.i81, %if.then33.i.i78 ], [ %shl.i31.i.i74, %if.else49.i.i73 ], [ 0, %if.then.i.i82 ], [ 0, %lor.lhs.false.i.i71 ]
  %f.lobit.i.i96 = lshr i16 %c, 15
  %frombool.i.i.i97 = trunc i16 %f.lobit.i.i96 to i8
  %16 = lshr i16 %c, 10
  %17 = and i16 %16, 31
  %18 = and i16 %c, 1023
  %and.i10.i.i99 = zext nneg i16 %18 to i64
  switch i16 %17, label %if.then33.i.i113 [
    i16 0, label %if.then.i.i117
    i16 31, label %lor.lhs.false.i.i106
  ]

if.then.i.i117:                                   ; preds = %float16a_unpack_canonical.exit95
  %cmp.i.i.i118 = icmp eq i16 %18, 0
  br i1 %cmp.i.i.i118, label %float16a_unpack_canonical.exit130, label %if.else.i.i119

if.else.i.i119:                                   ; preds = %if.then.i.i117
  %flush_inputs_to_zero.i.i120 = getelementptr inbounds i8, ptr %status, i64 6
  %19 = load i8, ptr %flush_inputs_to_zero.i.i120, align 2
  %20 = and i8 %19, 1
  %tobool9.not.i.i121 = icmp eq i8 %20, 0
  br i1 %tobool9.not.i.i121, label %frac64_normalize.exit.i.i124, label %if.then10.i.i122

if.then10.i.i122:                                 ; preds = %if.else.i.i119
  %21 = load i16, ptr %status, align 2
  %or1.i.i.i123 = or i16 %21, 32
  store i16 %or1.i.i.i123, ptr %status, align 2
  br label %float16a_unpack_canonical.exit130

frac64_normalize.exit.i.i124:                     ; preds = %if.else.i.i119
  %22 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i99, i1 true), !range !5
  %cast.i.i.i.i125 = trunc i64 %22 to i32
  %shl.i.i.i126 = shl i64 %and.i10.i.i99, %22
  %add.i.i128 = sub nsw i32 39, %cast.i.i.i.i125
  br label %float16a_unpack_canonical.exit130

lor.lhs.false.i.i106:                             ; preds = %float16a_unpack_canonical.exit95
  %cmp.i29.i.i107 = icmp eq i16 %18, 0
  br i1 %cmp.i29.i.i107, label %float16a_unpack_canonical.exit130, label %if.else49.i.i108

if.then33.i.i113:                                 ; preds = %float16a_unpack_canonical.exit95
  %conv.i.i.i98 = zext nneg i16 %17 to i32
  %sub37.i.i114 = add nsw i32 %conv.i.i.i98, -15
  %shl.i28.i.i115 = shl nuw nsw i64 %and.i10.i.i99, 53
  %or.i.i116 = or disjoint i64 %shl.i28.i.i115, -9223372036854775808
  br label %float16a_unpack_canonical.exit130

if.else49.i.i108:                                 ; preds = %lor.lhs.false.i.i106
  %shl.i31.i.i109 = shl nuw nsw i64 %and.i10.i.i99, 53
  %tobool.not.i32.i.i110 = icmp ult i16 %18, 512
  %conv53.i.i111 = select i1 %tobool.not.i32.i.i110, i8 5, i8 4
  br label %float16a_unpack_canonical.exit130

float16a_unpack_canonical.exit130:                ; preds = %lor.lhs.false.i.i106, %if.then.i.i117, %if.then10.i.i122, %frac64_normalize.exit.i.i124, %if.then33.i.i113, %if.else49.i.i108
  %pc.sroa.24.0 = phi i64 [ %shl.i.i.i126, %frac64_normalize.exit.i.i124 ], [ 0, %if.then10.i.i122 ], [ %or.i.i116, %if.then33.i.i113 ], [ %shl.i31.i.i109, %if.else49.i.i108 ], [ 0, %if.then.i.i117 ], [ 0, %lor.lhs.false.i.i106 ]
  %pc.sroa.20155.0 = phi i32 [ %add.i.i128, %frac64_normalize.exit.i.i124 ], [ 0, %if.then10.i.i122 ], [ %sub37.i.i114, %if.then33.i.i113 ], [ 31, %if.else49.i.i108 ], [ 0, %if.then.i.i117 ], [ 31, %lor.lhs.false.i.i106 ]
  %pc.sroa.0.0 = phi i8 [ 2, %frac64_normalize.exit.i.i124 ], [ 1, %if.then10.i.i122 ], [ 2, %if.then33.i.i113 ], [ %conv53.i.i111, %if.else49.i.i108 ], [ 1, %if.then.i.i117 ], [ 3, %lor.lhs.false.i.i106 ]
  %conv.i = zext nneg i8 %8 to i32
  %shl.i = shl nuw nsw i32 1, %conv.i
  %shl3.i = shl nuw nsw i32 1, %pb.sroa.0.0
  %or.i = or i32 %shl.i, %shl3.i
  %conv5.i = zext nneg i8 %pc.sroa.0.0 to i32
  %shl6.i = shl nuw nsw i32 1, %conv5.i
  %or7.i = or i32 %or.i, %shl6.i
  %and.i = and i32 %or7.i, 48
  %tobool.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool.i.not, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %float16a_unpack_canonical.exit130
  %and.i131 = and i32 %or7.i, 32
  %tobool.not.i = icmp eq i32 %and.i131, 0
  br i1 %tobool.not.i, label %if.end.i133, label %if.then.i132

if.then.i132:                                     ; preds = %if.then.i
  %23 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %23, 8193
  store i16 %or1.i.i, ptr %status, align 2
  br label %if.end.i133

if.end.i133:                                      ; preds = %if.then.i132, %if.then.i
  %cmp.i = icmp eq i32 %or.i, 10
  br i1 %cmp.i, label %if.then.i.i134, label %parts64_pick_nan_muladd.exit

if.then.i.i134:                                   ; preds = %if.end.i133
  %24 = load i16, ptr %status, align 2
  %or1.i.i.i135 = or i16 %24, 257
  store i16 %or1.i.i.i135, ptr %status, align 2
  br label %parts64_pick_nan_muladd.exit

parts64_pick_nan_muladd.exit:                     ; preds = %if.end.i133, %if.then.i.i134
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %pa.sroa.gep158, align 1
  store i32 2147483647, ptr %pa.sroa.gep163, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep168, align 8
  br label %parts64_muladd.exit

if.end.i:                                         ; preds = %float16a_unpack_canonical.exit130
  %25 = trunc i32 %flags to i8
  %26 = and i8 %25, 1
  %spec.select170 = xor i8 %26, %frombool.i.i.i97
  %f.lobit.i.i171 = xor i16 %b, %a
  %27 = lshr i16 %f.lobit.i.i171, 15
  %28 = trunc i16 %27 to i8
  %29 = lshr i8 %25, 1
  %30 = and i8 %29, 1
  %spec.select = xor i8 %30, %28
  store i8 %spec.select, ptr %pa.sroa.gep158, align 1
  %trunc = trunc i32 %or.i to i8
  switch i8 %trunc, label %if.end54.i [
    i8 4, label %if.end108.i
    i8 10, label %d_nan.i
  ]

if.end54.i:                                       ; preds = %if.end.i
  %and55.i = and i32 %or.i, 8
  %tobool56.i.not = icmp eq i32 %and55.i, 0
  br i1 %tobool56.i.not, label %if.end72.i, label %if.then57.i

if.then57.i:                                      ; preds = %if.end54.i
  %cmp60.i = icmp ne i8 %pc.sroa.0.0, 3
  %cmp68.i.not = icmp eq i8 %spec.select, %spec.select170
  %or.cond = or i1 %cmp68.i.not, %cmp60.i
  br i1 %or.cond, label %return_inf.i, label %d_nan.i

if.end72.i:                                       ; preds = %if.end54.i
  %and73.i = and i32 %or.i, 2
  %tobool74.i.not = icmp eq i32 %and73.i, 0
  br i1 %tobool74.i.not, label %if.else.i, label %if.then75.i

if.then75.i:                                      ; preds = %if.end72.i
  switch i8 %pc.sroa.0.0, label %if.else105.i [
    i8 2, label %if.then81.i
    i8 1, label %if.then87.i
    i8 3, label %if.then119.i
  ]

if.else.i:                                        ; preds = %if.end72.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 522, ptr noundef nonnull @__func__.parts64_muladd, ptr noundef nonnull @.str.7) #16
  unreachable

if.then81.i:                                      ; preds = %if.then75.i
  store i8 2, ptr %pa, align 8
  store i8 %spec.select170, ptr %pa.sroa.gep158, align 1
  store i32 %pc.sroa.20155.0, ptr %pa.sroa.gep163, align 4
  store i64 %pc.sroa.24.0, ptr %pa.sroa.gep168, align 8
  br label %return_normal.i

if.then87.i:                                      ; preds = %if.then75.i
  %cmp94.i.not = icmp eq i8 %spec.select, %spec.select170
  br i1 %cmp94.i.not, label %return_zero.i, label %return_sub_zero.i

if.else105.i:                                     ; preds = %if.then75.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 533, ptr noundef nonnull @__func__.parts64_muladd, ptr noundef nonnull @.str.12) #16
  unreachable

if.end108.i:                                      ; preds = %if.end.i
  %cmp111.i = icmp eq i8 %pc.sroa.0.0, 3
  br i1 %cmp111.i, label %if.then119.i, label %if.end124.i

if.then119.i:                                     ; preds = %if.then75.i, %if.end108.i
  store i8 %spec.select170, ptr %pa.sroa.gep158, align 1
  br label %return_inf.i

if.end124.i:                                      ; preds = %if.end108.i
  %sign127.i = getelementptr inbounds i8, ptr %p_widen.i, i64 1
  store i8 %spec.select, ptr %sign127.i, align 1
  %add.i = add nsw i32 %7, %pb.sroa.10.0
  %add130.i = add nsw i32 %add.i, 1
  %exp131.i = getelementptr inbounds i8, ptr %p_widen.i, i64 4
  store i32 %add130.i, ptr %exp131.i, align 4
  %frac_lo.i = getelementptr inbounds i8, ptr %p_widen.i, i64 16
  %frac_hi.i137 = getelementptr inbounds i8, ptr %p_widen.i, i64 8
  %conv.i.i = zext i64 %pa.val to i128
  %conv1.i.i = zext i64 %pb.sroa.14.0 to i128
  %mul.i.i = mul nuw i128 %conv.i.i, %conv1.i.i
  %conv2.i.i = trunc i128 %mul.i.i to i64
  store i64 %conv2.i.i, ptr %frac_lo.i, align 8
  %shr.i.i = lshr i128 %mul.i.i, 64
  %conv3.i.i = trunc i128 %shr.i.i to i64
  store i64 %conv3.i.i, ptr %frac_hi.i137, align 8
  %tobool133.i.not = icmp sgt i128 %mul.i.i, -1
  br i1 %tobool133.i.not, label %if.then134.i, label %if.end137.i

if.then134.i:                                     ; preds = %if.end124.i
  %31 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i, i64 %conv2.i.i)
  %32 = extractvalue { i64, i1 } %31, 1
  %33 = extractvalue { i64, i1 } %31, 0
  store i64 %33, ptr %frac_lo.i, align 8
  %conv.i4.i = zext i1 %32 to i64
  %34 = shl nuw i64 %conv3.i.i, 1
  %35 = or disjoint i64 %34, %conv.i4.i
  store i64 %35, ptr %frac_hi.i137, align 8
  store i32 %add.i, ptr %exp131.i, align 4
  br label %if.end137.i

if.end137.i:                                      ; preds = %if.then134.i, %if.end124.i
  %cmp140.i.not = icmp eq i8 %pc.sroa.0.0, 1
  br i1 %cmp140.i.not, label %if.end159.i, label %if.then142.i

if.then142.i:                                     ; preds = %if.end137.i
  %frac_hi.i140 = getelementptr inbounds i8, ptr %c_widen.i, i64 8
  store i64 %pc.sroa.24.0, ptr %frac_hi.i140, align 8
  %frac_lo.i141 = getelementptr inbounds i8, ptr %c_widen.i, i64 16
  store i64 0, ptr %frac_lo.i141, align 8
  %exp144.i = getelementptr inbounds i8, ptr %c_widen.i, i64 4
  store i32 %pc.sroa.20155.0, ptr %exp144.i, align 4
  %cmp151.i = icmp eq i8 %spec.select, %spec.select170
  br i1 %cmp151.i, label %if.then153.i, label %if.else154.i

if.then153.i:                                     ; preds = %if.then142.i
  call fastcc void @parts128_add_normal(ptr noundef nonnull %p_widen.i, ptr noundef nonnull %c_widen.i)
  br label %if.end159.i

if.else154.i:                                     ; preds = %if.then142.i
  %call155.i = call fastcc zeroext i1 @parts128_sub_normal(ptr noundef nonnull %p_widen.i, ptr noundef nonnull %c_widen.i)
  br i1 %call155.i, label %if.end159.i, label %return_sub_zero.i

if.end159.i:                                      ; preds = %if.then153.i, %if.else154.i, %if.end137.i
  %p_widen.i.val = load i64, ptr %frac_hi.i137, align 8
  %p_widen.i.val60 = load i64, ptr %frac_lo.i, align 8
  %cmp.i142 = icmp ne i64 %p_widen.i.val60, 0
  %conv1.i = zext i1 %cmp.i142 to i64
  %or.i143 = or i64 %p_widen.i.val, %conv1.i
  store i64 %or.i143, ptr %pa.sroa.gep168, align 8
  %36 = load i8, ptr %sign127.i, align 1
  %37 = and i8 %36, 1
  store i8 %37, ptr %pa.sroa.gep158, align 1
  %38 = load i32, ptr %exp131.i, align 4
  store i32 %38, ptr %pa.sroa.gep163, align 4
  br label %return_normal.i

return_normal.i:                                  ; preds = %if.end159.i, %if.then81.i
  %39 = phi i8 [ %37, %if.end159.i ], [ %spec.select170, %if.then81.i ]
  %40 = phi i32 [ %38, %if.end159.i ], [ %pc.sroa.20155.0, %if.then81.i ]
  %and166.i = and i32 %flags, 8
  %tobool167.i.not = icmp eq i32 %and166.i, 0
  br i1 %tobool167.i.not, label %finish_sign.i, label %if.then168.i

if.then168.i:                                     ; preds = %return_normal.i
  %sub170.i = add i32 %40, -1
  store i32 %sub170.i, ptr %pa.sroa.gep163, align 4
  br label %finish_sign.i

finish_sign.i:                                    ; preds = %return_normal.i, %if.then168.i, %return_inf.i, %return_zero.i
  %41 = phi i8 [ %39, %return_normal.i ], [ %39, %if.then168.i ], [ %44, %return_inf.i ], [ %43, %return_zero.i ]
  %and172.i = and i32 %flags, 4
  %tobool173.i.not = icmp eq i32 %and172.i, 0
  br i1 %tobool173.i.not, label %parts64_muladd.exit, label %if.then174.i

if.then174.i:                                     ; preds = %finish_sign.i
  %frombool180.i = xor i8 %41, 1
  store i8 %frombool180.i, ptr %pa.sroa.gep158, align 1
  br label %parts64_muladd.exit

return_sub_zero.i:                                ; preds = %if.else154.i, %if.then87.i
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %42 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp183.i = icmp eq i8 %42, 1
  %frombool186.i = zext i1 %cmp183.i to i8
  store i8 %frombool186.i, ptr %pa.sroa.gep158, align 1
  br label %return_zero.i

return_zero.i:                                    ; preds = %if.then87.i, %return_sub_zero.i
  %43 = phi i8 [ %spec.select170, %if.then87.i ], [ %frombool186.i, %return_sub_zero.i ]
  store i8 1, ptr %pa, align 8
  br label %finish_sign.i

return_inf.i:                                     ; preds = %if.then57.i, %if.then119.i
  %44 = phi i8 [ %spec.select, %if.then57.i ], [ %spec.select170, %if.then119.i ]
  store i8 3, ptr %pa, align 8
  br label %finish_sign.i

d_nan.i:                                          ; preds = %if.then57.i, %if.end.i
  %.sink173 = phi i16 [ 257, %if.end.i ], [ 129, %if.then57.i ]
  %45 = load i16, ptr %status, align 2
  %or1.i136 = or i16 %45, %.sink173
  store i16 %or1.i136, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %pa.sroa.gep158, align 1
  store i32 2147483647, ptr %pa.sroa.gep163, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep168, align 8
  br label %parts64_muladd.exit

parts64_muladd.exit:                              ; preds = %finish_sign.i, %if.then174.i, %d_nan.i, %parts64_pick_nan_muladd.exit
  call fastcc void @parts64_uncanon(ptr noundef nonnull %pa, ptr noundef %status, ptr noundef nonnull @float16_params)
  %46 = load i8, ptr %pa.sroa.gep158, align 1
  %conv.i.i.i144 = zext i8 %46 to i64
  %shl.i.i.i145 = shl nuw nsw i64 %conv.i.i.i144, 15
  %47 = load i32, ptr %pa.sroa.gep163, align 4
  %48 = shl i32 %47, 10
  %49 = and i32 %48, 31744
  %and8.i.i.i = zext nneg i32 %49 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i145, %and8.i.i.i
  %50 = load i64, ptr %pa.sroa.gep168, align 8
  %shl77.i9.i.i = and i64 %50, 1023
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i146 = trunc i64 %or.i10.i.i to i16
  ret i16 %conv.i.i146
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @parts64_muladd(ptr noundef returned %a, ptr nocapture noundef readonly %b, ptr nocapture noundef %c, i32 noundef %flags, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %p_widen = alloca %struct.FloatParts128, align 8
  %c_widen = alloca %struct.FloatParts128, align 8
  %0 = load i8, ptr %a, align 8
  %conv = zext nneg i8 %0 to i32
  %shl = shl nuw i32 1, %conv
  %1 = load i8, ptr %b, align 8
  %conv2 = zext nneg i8 %1 to i32
  %shl3 = shl nuw i32 1, %conv2
  %or = or i32 %shl3, %shl
  %2 = load i8, ptr %c, align 8
  %conv5 = zext nneg i8 %2 to i32
  %shl6 = shl nuw i32 1, %conv5
  %or7 = or i32 %shl6, %or
  %and = and i32 %or7, 48
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %and.i = and i32 %or7, 32
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %3 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %3, 8193
  store i16 %or1.i.i, ptr %s, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then
  %cmp.i = icmp eq i32 %or, 10
  br i1 %cmp.i, label %if.then.i.i, label %parts64_pick_nan_muladd.exit

if.then.i.i:                                      ; preds = %if.end.i
  %4 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %4, 257
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_pick_nan_muladd.exit

parts64_pick_nan_muladd.exit:                     ; preds = %if.end.i, %if.then.i.i
  store i8 4, ptr %a, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  br label %return

if.end:                                           ; preds = %entry
  %and11 = and i32 %flags, 1
  %tobool12.not = icmp eq i32 %and11, 0
  br i1 %tobool12.not, label %if.end17, label %if.then13

if.then13:                                        ; preds = %if.end
  %sign = getelementptr inbounds i8, ptr %c, i64 1
  %5 = load i8, ptr %sign, align 1
  %6 = and i8 %5, 1
  %frombool = xor i8 %6, 1
  store i8 %frombool, ptr %sign, align 1
  br label %if.end17

if.end17:                                         ; preds = %if.then13, %if.end
  %sign18 = getelementptr inbounds i8, ptr %b, i64 1
  %7 = load i8, ptr %sign18, align 1
  %sign21 = getelementptr inbounds i8, ptr %a, i64 1
  %8 = load i8, ptr %sign21, align 1
  %9 = trunc i32 %flags to i8
  %10 = lshr i8 %9, 1
  %11 = xor i8 %7, %10
  %xor245564 = xor i8 %11, %8
  %spec.select = and i8 %xor245564, 1
  store i8 %spec.select, ptr %sign21, align 1
  switch i32 %or, label %if.end54 [
    i32 4, label %if.end108
    i32 10, label %d_nan
  ]

if.end54:                                         ; preds = %if.end17
  %and55 = and i32 %or, 8
  %tobool56.not = icmp eq i32 %and55, 0
  br i1 %tobool56.not, label %do.body, label %if.then57

if.then57:                                        ; preds = %if.end54
  %12 = load i8, ptr %c, align 8
  %cmp60 = icmp eq i8 %12, 3
  br i1 %cmp60, label %land.lhs.true, label %return_inf

land.lhs.true:                                    ; preds = %if.then57
  %sign65 = getelementptr inbounds i8, ptr %c, i64 1
  %13 = load i8, ptr %sign65, align 1
  %14 = xor i8 %13, %xor245564
  %15 = and i8 %14, 1
  %cmp68.not = icmp eq i8 %15, 0
  br i1 %cmp68.not, label %return_inf, label %d_nan

do.body:                                          ; preds = %if.end54
  %and73 = and i32 %or, 2
  %tobool74.not = icmp eq i32 %and73, 0
  br i1 %tobool74.not, label %if.else, label %do.end

if.else:                                          ; preds = %do.body
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 522, ptr noundef nonnull @__func__.parts64_muladd, ptr noundef nonnull @.str.7) #16
  unreachable

do.end:                                           ; preds = %do.body
  %16 = load i8, ptr %c, align 8
  switch i8 %16, label %if.else105 [
    i8 2, label %if.then81
    i8 1, label %if.then87
    i8 3, label %if.then119
  ]

if.then81:                                        ; preds = %do.end
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %a, ptr noundef nonnull align 8 dereferenceable(16) %c, i64 16, i1 false)
  br label %return_normal

if.then87:                                        ; preds = %do.end
  %sign91 = getelementptr inbounds i8, ptr %c, i64 1
  %17 = load i8, ptr %sign91, align 1
  %18 = xor i8 %17, %xor245564
  %19 = and i8 %18, 1
  %cmp94.not = icmp eq i8 %19, 0
  br i1 %cmp94.not, label %return_zero, label %return_sub_zero

if.else105:                                       ; preds = %do.end
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 533, ptr noundef nonnull @__func__.parts64_muladd, ptr noundef nonnull @.str.12) #16
  unreachable

if.end108:                                        ; preds = %if.end17
  %.pr = load i8, ptr %c, align 8
  %cmp111 = icmp eq i8 %.pr, 3
  br i1 %cmp111, label %if.then119, label %if.end124

if.then119:                                       ; preds = %do.end, %if.end108
  %sign120 = getelementptr inbounds i8, ptr %c, i64 1
  %20 = load i8, ptr %sign120, align 1
  %21 = and i8 %20, 1
  store i8 %21, ptr %sign21, align 1
  br label %return_inf

if.end124:                                        ; preds = %if.end108
  %sign127 = getelementptr inbounds i8, ptr %p_widen, i64 1
  store i8 %spec.select, ptr %sign127, align 1
  %exp = getelementptr inbounds i8, ptr %a, i64 4
  %22 = load i32, ptr %exp, align 4
  %exp129 = getelementptr inbounds i8, ptr %b, i64 4
  %23 = load i32, ptr %exp129, align 4
  %add = add i32 %23, %22
  %add130 = add i32 %add, 1
  %exp131 = getelementptr inbounds i8, ptr %p_widen, i64 4
  store i32 %add130, ptr %exp131, align 4
  %24 = getelementptr i8, ptr %a, i64 8
  %a.val = load i64, ptr %24, align 8
  %25 = getelementptr i8, ptr %b, i64 8
  %b.val = load i64, ptr %25, align 8
  %frac_lo.i = getelementptr inbounds i8, ptr %p_widen, i64 16
  %frac_hi.i = getelementptr inbounds i8, ptr %p_widen, i64 8
  %conv.i.i = zext i64 %a.val to i128
  %conv1.i.i = zext i64 %b.val to i128
  %mul.i.i = mul nuw i128 %conv1.i.i, %conv.i.i
  %conv2.i.i = trunc i128 %mul.i.i to i64
  store i64 %conv2.i.i, ptr %frac_lo.i, align 8
  %shr.i.i = lshr i128 %mul.i.i, 64
  %conv3.i.i = trunc i128 %shr.i.i to i64
  store i64 %conv3.i.i, ptr %frac_hi.i, align 8
  %tobool133.not = icmp sgt i128 %mul.i.i, -1
  br i1 %tobool133.not, label %if.then134, label %if.end137

if.then134:                                       ; preds = %if.end124
  %26 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i, i64 %conv2.i.i)
  %27 = extractvalue { i64, i1 } %26, 1
  %28 = extractvalue { i64, i1 } %26, 0
  store i64 %28, ptr %frac_lo.i, align 8
  %conv.i4.i = zext i1 %27 to i64
  %29 = shl nuw i64 %conv3.i.i, 1
  %30 = or disjoint i64 %29, %conv.i4.i
  store i64 %30, ptr %frac_hi.i, align 8
  store i32 %add, ptr %exp131, align 4
  br label %if.end137

if.end137:                                        ; preds = %if.then134, %if.end124
  %cmp140.not = icmp eq i8 %.pr, 1
  br i1 %cmp140.not, label %if.end159, label %if.then142

if.then142:                                       ; preds = %if.end137
  %31 = getelementptr i8, ptr %c, i64 8
  %c.val = load i64, ptr %31, align 8
  %frac_hi.i60 = getelementptr inbounds i8, ptr %c_widen, i64 8
  store i64 %c.val, ptr %frac_hi.i60, align 8
  %frac_lo.i61 = getelementptr inbounds i8, ptr %c_widen, i64 16
  store i64 0, ptr %frac_lo.i61, align 8
  %exp143 = getelementptr inbounds i8, ptr %c, i64 4
  %32 = load i32, ptr %exp143, align 4
  %exp144 = getelementptr inbounds i8, ptr %c_widen, i64 4
  store i32 %32, ptr %exp144, align 4
  %sign148 = getelementptr inbounds i8, ptr %c, i64 1
  %33 = load i8, ptr %sign148, align 1
  %34 = xor i8 %33, %xor245564
  %35 = and i8 %34, 1
  %cmp151 = icmp eq i8 %35, 0
  br i1 %cmp151, label %if.then153, label %if.else154

if.then153:                                       ; preds = %if.then142
  call fastcc void @parts128_add_normal(ptr noundef nonnull %p_widen, ptr noundef nonnull %c_widen)
  br label %if.end159

if.else154:                                       ; preds = %if.then142
  %call155 = call fastcc zeroext i1 @parts128_sub_normal(ptr noundef nonnull %p_widen, ptr noundef nonnull %c_widen)
  br i1 %call155, label %if.end159, label %return_sub_zero

if.end159:                                        ; preds = %if.then153, %if.else154, %if.end137
  %p_widen.val = load i64, ptr %frac_hi.i, align 8
  %p_widen.val56 = load i64, ptr %frac_lo.i, align 8
  %cmp.i62 = icmp ne i64 %p_widen.val56, 0
  %conv1.i = zext i1 %cmp.i62 to i64
  %or.i = or i64 %p_widen.val, %conv1.i
  store i64 %or.i, ptr %24, align 8
  %36 = load i8, ptr %sign127, align 1
  %37 = and i8 %36, 1
  store i8 %37, ptr %sign21, align 1
  %38 = load i32, ptr %exp131, align 4
  store i32 %38, ptr %exp, align 4
  br label %return_normal

return_normal:                                    ; preds = %if.end159, %if.then81
  %and166 = and i32 %flags, 8
  %tobool167.not = icmp eq i32 %and166, 0
  br i1 %tobool167.not, label %finish_sign, label %if.then168

if.then168:                                       ; preds = %return_normal
  %exp169 = getelementptr inbounds i8, ptr %a, i64 4
  %39 = load i32, ptr %exp169, align 4
  %sub170 = add i32 %39, -1
  store i32 %sub170, ptr %exp169, align 4
  br label %finish_sign

finish_sign:                                      ; preds = %return_normal, %if.then168, %return_inf, %return_zero
  %and172 = and i32 %flags, 4
  %tobool173.not = icmp eq i32 %and172, 0
  br i1 %tobool173.not, label %return, label %if.then174

if.then174:                                       ; preds = %finish_sign
  %40 = load i8, ptr %sign21, align 1
  %41 = and i8 %40, 1
  %frombool180 = xor i8 %41, 1
  store i8 %frombool180, ptr %sign21, align 1
  br label %return

return_sub_zero:                                  ; preds = %if.else154, %if.then87
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %42 = load i8, ptr %float_rounding_mode, align 2
  %cmp183 = icmp eq i8 %42, 1
  %frombool186 = zext i1 %cmp183 to i8
  store i8 %frombool186, ptr %sign21, align 1
  br label %return_zero

return_zero:                                      ; preds = %if.then87, %return_sub_zero
  store i8 1, ptr %a, align 8
  br label %finish_sign

return_inf:                                       ; preds = %if.then57, %land.lhs.true, %if.then119
  store i8 3, ptr %a, align 8
  br label %finish_sign

d_nan:                                            ; preds = %land.lhs.true, %if.end17
  %.sink65 = phi i16 [ 257, %if.end17 ], [ 129, %land.lhs.true ]
  %43 = load i16, ptr %s, align 2
  %or1.i57 = or i16 %43, %.sink65
  store i16 %or1.i57, ptr %s, align 2
  store i8 4, ptr %a, align 8
  store i8 0, ptr %sign21, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  br label %return

return:                                           ; preds = %finish_sign, %if.then174, %d_nan, %parts64_pick_nan_muladd.exit
  ret ptr %a
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_muladd(i32 noundef %xa, i32 noundef %xb, i32 noundef %xc, i32 noundef %flags, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p_widen.i.i = alloca %struct.FloatParts128, align 8
  %c_widen.i.i = alloca %struct.FloatParts128, align 8
  %pa.i = alloca %struct.FloatParts64, align 8
  %0 = load i16, ptr %s, align 2
  %1 = and i16 %0, 16
  %tobool.i.not = icmp eq i16 %1, 0
  br i1 %tobool.i.not, label %soft, label %land.rhs.i

land.rhs.i:                                       ; preds = %entry
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %s, i64 2
  %2 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp.i = icmp eq i8 %2, 0
  %and = and i32 %flags, 8
  %tobool3.not = icmp eq i32 %and, 0
  %or.cond = and i1 %tobool3.not, %cmp.i
  br i1 %or.cond, label %if.end11, label %soft

if.end11:                                         ; preds = %land.rhs.i
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool.i102.not = icmp eq i8 %4, 0
  br i1 %tobool.i102.not, label %float32_input_flush3.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end11
  %and.i.i.i = and i32 %xa, 2139095040
  %cmp.i.i.i = icmp eq i32 %and.i.i.i, 0
  %and.i2.i.i = and i32 %xa, 2147483647
  %cmp.i3.i.i = icmp ne i32 %and.i2.i.i, 0
  %5 = and i1 %cmp.i.i.i, %cmp.i3.i.i
  %.lobit.i = and i32 %xa, -2147483648
  %or1.i.i = or i16 %0, 32
  %ua.sroa.0.0 = select i1 %5, i32 %.lobit.i, i32 %xa
  %and.i.i.i23 = and i32 %xb, 2139095040
  %cmp.i.i.i24 = icmp eq i32 %and.i.i.i23, 0
  %and.i2.i.i25 = and i32 %xb, 2147483647
  %cmp.i3.i.i26 = icmp ne i32 %and.i2.i.i25, 0
  %6 = and i1 %cmp.i.i.i24, %cmp.i3.i.i26
  %.lobit.i29 = and i32 %xb, -2147483648
  %7 = or i1 %6, %5
  %ub.sroa.0.0 = select i1 %6, i32 %.lobit.i29, i32 %xb
  %8 = or i1 %5, %6
  %and.i.i.i32 = and i32 %xc, 2139095040
  %cmp.i.i.i33 = icmp eq i32 %and.i.i.i32, 0
  %and.i2.i.i34 = and i32 %xc, 2147483647
  %cmp.i3.i.i35 = icmp ne i32 %and.i2.i.i34, 0
  %9 = and i1 %cmp.i.i.i33, %cmp.i3.i.i35
  %.lobit.i38 = and i32 %xc, -2147483648
  %10 = or i1 %9, %7
  %.ph = select i1 %10, i16 %or1.i.i, i16 %0
  %uc.sroa.0.1.ph = select i1 %9, i32 %.lobit.i38, i32 %xc
  %11 = or i1 %8, %9
  br i1 %11, label %12, label %float32_input_flush3.exit

12:                                               ; preds = %if.end.i
  store i16 %.ph, ptr %s, align 2
  br label %float32_input_flush3.exit

float32_input_flush3.exit:                        ; preds = %12, %if.end.i, %if.end11
  %13 = phi i16 [ %0, %if.end11 ], [ %.ph, %if.end.i ], [ %.ph, %12 ]
  %ua.sroa.0.1 = phi i32 [ %xa, %if.end11 ], [ %ua.sroa.0.0, %if.end.i ], [ %ua.sroa.0.0, %12 ]
  %ub.sroa.0.1 = phi i32 [ %xb, %if.end11 ], [ %ub.sroa.0.0, %if.end.i ], [ %ub.sroa.0.0, %12 ]
  %uc.sroa.0.1 = phi i32 [ %xc, %if.end11 ], [ %uc.sroa.0.1.ph, %if.end.i ], [ %uc.sroa.0.1.ph, %12 ]
  %shr.i.i = lshr i32 %ua.sroa.0.1, 23
  %add.i.i = add nuw nsw i32 %shr.i.i, 1
  %and.i.i = and i32 %add.i.i, 254
  %cmp.i.i = icmp ne i32 %and.i.i, 0
  %and.i2.i = and i32 %ua.sroa.0.1, 2147483647
  %cmp.i3.i = icmp eq i32 %and.i2.i, 0
  %14 = or i1 %cmp.i3.i, %cmp.i.i
  br i1 %14, label %land.lhs.true.i, label %soft

land.lhs.true.i:                                  ; preds = %float32_input_flush3.exit
  %shr.i.i41 = lshr i32 %ub.sroa.0.1, 23
  %add.i.i42 = add nuw nsw i32 %shr.i.i41, 1
  %and.i.i43 = and i32 %add.i.i42, 254
  %cmp.i.i44 = icmp ne i32 %and.i.i43, 0
  %and.i2.i45 = and i32 %ub.sroa.0.1, 2147483647
  %cmp.i3.i46 = icmp eq i32 %and.i2.i45, 0
  %15 = or i1 %cmp.i3.i46, %cmp.i.i44
  br i1 %15, label %land.rhs.i106, label %soft

land.rhs.i106:                                    ; preds = %land.lhs.true.i
  %shr.i.i47 = lshr i32 %uc.sroa.0.1, 23
  %add.i.i48 = add nuw nsw i32 %shr.i.i47, 1
  %and.i.i49 = and i32 %add.i.i48, 254
  %cmp.i.i50 = icmp eq i32 %and.i.i49, 0
  %and.i2.i51 = and i32 %uc.sroa.0.1, 2147483647
  %cmp.i3.i52 = icmp ne i32 %and.i2.i51, 0
  %.not = and i1 %cmp.i3.i52, %cmp.i.i50
  br i1 %.not, label %soft, label %if.end33

if.end33:                                         ; preds = %land.rhs.i106
  %brmerge = or i1 %cmp.i3.i, %cmp.i3.i46
  br i1 %brmerge, label %if.then38, label %if.else

if.then38:                                        ; preds = %if.end33
  %.lobit20 = xor i32 %ub.sroa.0.1, %ua.sroa.0.1
  %and44 = lshr i32 %flags, 1
  %and44.lobit = and i32 %and44, 1
  %.lobit20.lobit = lshr i32 %.lobit20, 31
  %tobool53.not = icmp eq i32 %.lobit20.lobit, %and44.lobit
  %shl.i = select i1 %tobool53.not, i32 0, i32 -2147483648
  %and58 = and i32 %flags, 1
  %tobool59.not = icmp eq i32 %and58, 0
  %16 = bitcast i32 %uc.sroa.0.1 to float
  %fneg = fneg float %16
  %17 = bitcast i32 %shl.i to float
  %18 = select i1 %tobool59.not, float %16, float %fneg
  %add = fadd float %18, %17
  br label %if.end92

if.else:                                          ; preds = %if.end33
  %and62 = and i32 %flags, 2
  %tobool63.not = icmp eq i32 %and62, 0
  %19 = bitcast i32 %ua.sroa.0.1 to float
  %fneg65 = fneg float %19
  %and67 = and i32 %flags, 1
  %tobool68.not = icmp eq i32 %and67, 0
  %20 = bitcast i32 %uc.sroa.0.1 to float
  %fneg70 = fneg float %20
  %21 = select i1 %tobool63.not, float %19, float %fneg65
  %22 = bitcast i32 %ub.sroa.0.1 to float
  %23 = select i1 %tobool68.not, float %20, float %fneg70
  %24 = tail call float @llvm.fma.f32(float %21, float %22, float %23)
  %25 = tail call float @llvm.fabs.f32(float %24) #17
  %isinf.i = fcmp oeq float %25, 0x7FF0000000000000
  br i1 %isinf.i, label %if.then80, label %if.else81

if.then80:                                        ; preds = %if.else
  %26 = or i16 %13, 4
  store i16 %26, ptr %s, align 2
  br label %if.end92

if.else81:                                        ; preds = %if.else
  %cmp = fcmp ugt float %25, 0x3810000000000000
  br i1 %cmp, label %if.end92, label %soft

if.end92:                                         ; preds = %if.then80, %if.else81, %if.then38
  %ur.sroa.0.0.in = phi float [ %add, %if.then38 ], [ %24, %if.then80 ], [ %24, %if.else81 ]
  %and93 = and i32 %flags, 4
  %tobool94.not = icmp eq i32 %and93, 0
  br i1 %tobool94.not, label %if.end97, label %if.then95

if.then95:                                        ; preds = %if.end92
  %27 = fneg float %ur.sroa.0.0.in
  %xor.i = bitcast float %27 to i32
  br label %return

if.end97:                                         ; preds = %if.end92
  %ur.sroa.0.0 = bitcast float %ur.sroa.0.0.in to i32
  br label %return

soft:                                             ; preds = %if.else81, %land.lhs.true.i, %float32_input_flush3.exit, %entry, %land.rhs.i106, %land.rhs.i
  %28 = phi i16 [ %0, %entry ], [ %13, %land.rhs.i106 ], [ %13, %land.lhs.true.i ], [ %13, %float32_input_flush3.exit ], [ %0, %land.rhs.i ], [ %13, %if.else81 ]
  %ua.sroa.0.3 = phi i32 [ %xa, %entry ], [ %ua.sroa.0.1, %land.rhs.i106 ], [ %ua.sroa.0.1, %land.lhs.true.i ], [ %ua.sroa.0.1, %float32_input_flush3.exit ], [ %xa, %land.rhs.i ], [ %ua.sroa.0.1, %if.else81 ]
  %ub.sroa.0.2 = phi i32 [ %xb, %entry ], [ %ub.sroa.0.1, %land.rhs.i106 ], [ %ub.sroa.0.1, %land.lhs.true.i ], [ %ub.sroa.0.1, %float32_input_flush3.exit ], [ %xb, %land.rhs.i ], [ %ub.sroa.0.1, %if.else81 ]
  %uc.sroa.0.4 = phi i32 [ %xc, %entry ], [ %uc.sroa.0.1, %land.rhs.i106 ], [ %uc.sroa.0.1, %land.lhs.true.i ], [ %uc.sroa.0.1, %float32_input_flush3.exit ], [ %xc, %land.rhs.i ], [ %uc.sroa.0.1, %if.else81 ]
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %p_widen.i.i)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %c_widen.i.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %pa.i)
  %pa.sroa.gep193.i = getelementptr inbounds i8, ptr %pa.i, i64 8
  %pa.sroa.gep188.i = getelementptr inbounds i8, ptr %pa.i, i64 4
  %pa.sroa.gep183.i = getelementptr inbounds i8, ptr %pa.i, i64 1
  %shr.i8.i.i = lshr i32 %ua.sroa.0.3, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %29 = and i32 %ua.sroa.0.3, 8388607
  %and.i10.i.i = zext nneg i32 %29 to i64
  store i32 %and.i9.i.i, ptr %pa.sroa.gep188.i, align 4
  store i64 %and.i10.i.i, ptr %pa.sroa.gep193.i, align 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %if.then33.i.i [
    i8 0, label %if.then.i67.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i67.i:                                    ; preds = %soft
  %cmp.i.i.i55 = icmp eq i32 %29, 0
  br i1 %cmp.i.i.i55, label %if.then8.i.i, label %if.else.i68.i

if.then8.i.i:                                     ; preds = %if.then.i67.i
  store i8 1, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

if.else.i68.i:                                    ; preds = %if.then.i67.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %30 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %31 = and i8 %30, 1
  %tobool9.not.i.i = icmp eq i8 %31, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i68.i
  %or1.i.i.i = or i16 %28, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %pa.i, align 8
  store i64 0, ptr %pa.sroa.gep193.i, align 8
  br label %parts64_canonicalize.exit.i

frac64_normalize.exit.i.i:                        ; preds = %if.else.i68.i
  %32 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %32 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %32
  store i64 %shl.i.i.i, ptr %pa.sroa.gep193.i, align 8
  store i8 2, ptr %pa.i, align 8
  %add.i69.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i69.i, ptr %pa.sroa.gep188.i, align 4
  br label %parts64_canonicalize.exit.i

lor.lhs.false.i.i:                                ; preds = %soft
  %cmp.i29.i.i = icmp eq i32 %29, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %soft
  store i8 2, ptr %pa.i, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %pa.sroa.gep188.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i66.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i66.i, ptr %pa.sroa.gep193.i, align 8
  br label %parts64_canonicalize.exit.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %pa.sroa.gep193.i, align 8
  %tobool.not.i32.i.i = icmp ult i32 %29, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

parts64_canonicalize.exit.i:                      ; preds = %if.else49.i.i, %if.then47.i.i, %if.then33.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then8.i.i
  %33 = phi i16 [ %28, %if.then8.i.i ], [ %or1.i.i.i, %if.then10.i.i ], [ %28, %frac64_normalize.exit.i.i ], [ %28, %if.then33.i.i ], [ %28, %if.then47.i.i ], [ %28, %if.else49.i.i ]
  %pa.val.i = phi i64 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i66.i, %if.then33.i.i ], [ 0, %if.then47.i.i ], [ %shl.i31.i.i, %if.else49.i.i ]
  %34 = phi i32 [ %and.i9.i.i, %if.then8.i.i ], [ %and.i9.i.i, %if.then10.i.i ], [ %add.i69.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ %and.i9.i.i, %if.then47.i.i ], [ %and.i9.i.i, %if.else49.i.i ]
  %35 = phi i8 [ 1, %if.then8.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ], [ 3, %if.then47.i.i ], [ %conv53.i.i, %if.else49.i.i ]
  %shr.i8.i72.i = lshr i32 %ub.sroa.0.2, 23
  %36 = and i32 %ub.sroa.0.2, 8388607
  %and.i10.i74.i = zext nneg i32 %36 to i64
  %trunc197.i = trunc i32 %shr.i8.i72.i to i8
  switch i8 %trunc197.i, label %if.then33.i90.i [
    i8 0, label %if.then.i94.i
    i8 -1, label %lor.lhs.false.i82.i
  ]

if.then.i94.i:                                    ; preds = %parts64_canonicalize.exit.i
  %cmp.i.i96.i = icmp eq i32 %36, 0
  br i1 %cmp.i.i96.i, label %parts64_canonicalize.exit108.i, label %if.else.i97.i

if.else.i97.i:                                    ; preds = %if.then.i94.i
  %flush_inputs_to_zero.i98.i = getelementptr inbounds i8, ptr %s, i64 6
  %37 = load i8, ptr %flush_inputs_to_zero.i98.i, align 2
  %38 = and i8 %37, 1
  %tobool9.not.i99.i = icmp eq i8 %38, 0
  br i1 %tobool9.not.i99.i, label %frac64_normalize.exit.i102.i, label %if.then10.i100.i

if.then10.i100.i:                                 ; preds = %if.else.i97.i
  %or1.i.i101.i = or i16 %33, 32
  store i16 %or1.i.i101.i, ptr %s, align 2
  br label %parts64_canonicalize.exit108.i

frac64_normalize.exit.i102.i:                     ; preds = %if.else.i97.i
  %39 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i74.i, i1 true), !range !5
  %cast.i.i.i103.i = trunc i64 %39 to i32
  %shl.i.i104.i = shl i64 %and.i10.i74.i, %39
  %add.i106.i = sub nuw nsw i32 -86, %cast.i.i.i103.i
  br label %parts64_canonicalize.exit108.i

lor.lhs.false.i82.i:                              ; preds = %parts64_canonicalize.exit.i
  %cmp.i29.i84.i = icmp eq i32 %36, 0
  br i1 %cmp.i29.i84.i, label %parts64_canonicalize.exit108.i, label %if.else49.i85.i

if.then33.i90.i:                                  ; preds = %parts64_canonicalize.exit.i
  %and.i9.i73.i = and i32 %shr.i8.i72.i, 255
  %sub37.i91.i = add nsw i32 %and.i9.i73.i, -127
  %shl.i28.i92.i = shl nuw nsw i64 %and.i10.i74.i, 40
  %or.i93.i = or disjoint i64 %shl.i28.i92.i, -9223372036854775808
  br label %parts64_canonicalize.exit108.i

if.else49.i85.i:                                  ; preds = %lor.lhs.false.i82.i
  %shl.i31.i86.i = shl nuw nsw i64 %and.i10.i74.i, 40
  %tobool.not.i32.i87.i = icmp ult i32 %36, 4194304
  %conv53.i88.i = select i1 %tobool.not.i32.i87.i, i32 5, i32 4
  br label %parts64_canonicalize.exit108.i

parts64_canonicalize.exit108.i:                   ; preds = %if.else49.i85.i, %if.then33.i90.i, %lor.lhs.false.i82.i, %frac64_normalize.exit.i102.i, %if.then10.i100.i, %if.then.i94.i
  %40 = phi i16 [ %33, %frac64_normalize.exit.i102.i ], [ %or1.i.i101.i, %if.then10.i100.i ], [ %33, %if.then33.i90.i ], [ %33, %if.else49.i85.i ], [ %33, %if.then.i94.i ], [ %33, %lor.lhs.false.i82.i ]
  %pb.sroa.10.0.i = phi i32 [ %add.i106.i, %frac64_normalize.exit.i102.i ], [ 0, %if.then10.i100.i ], [ %sub37.i91.i, %if.then33.i90.i ], [ 255, %if.else49.i85.i ], [ 0, %if.then.i94.i ], [ 255, %lor.lhs.false.i82.i ]
  %pb.sroa.0.0.i = phi i32 [ 2, %frac64_normalize.exit.i102.i ], [ 1, %if.then10.i100.i ], [ 2, %if.then33.i90.i ], [ %conv53.i88.i, %if.else49.i85.i ], [ 1, %if.then.i94.i ], [ 3, %lor.lhs.false.i82.i ]
  %pb.sroa.15.0.i = phi i64 [ %shl.i.i104.i, %frac64_normalize.exit.i102.i ], [ 0, %if.then10.i100.i ], [ %or.i93.i, %if.then33.i90.i ], [ %shl.i31.i86.i, %if.else49.i85.i ], [ 0, %if.then.i94.i ], [ 0, %lor.lhs.false.i82.i ]
  %f.lobit.i109.i = lshr i32 %uc.sroa.0.4, 31
  %frombool.i.i110.i = trunc i32 %f.lobit.i109.i to i8
  %shr.i8.i111.i = lshr i32 %uc.sroa.0.4, 23
  %41 = and i32 %uc.sroa.0.4, 8388607
  %and.i10.i113.i = zext nneg i32 %41 to i64
  %trunc198.i = trunc i32 %shr.i8.i111.i to i8
  switch i8 %trunc198.i, label %if.then33.i129.i [
    i8 0, label %if.then.i133.i
    i8 -1, label %lor.lhs.false.i121.i
  ]

if.then.i133.i:                                   ; preds = %parts64_canonicalize.exit108.i
  %cmp.i.i135.i = icmp eq i32 %41, 0
  br i1 %cmp.i.i135.i, label %parts64_canonicalize.exit147.i, label %if.else.i136.i

if.else.i136.i:                                   ; preds = %if.then.i133.i
  %flush_inputs_to_zero.i137.i = getelementptr inbounds i8, ptr %s, i64 6
  %42 = load i8, ptr %flush_inputs_to_zero.i137.i, align 2
  %43 = and i8 %42, 1
  %tobool9.not.i138.i = icmp eq i8 %43, 0
  br i1 %tobool9.not.i138.i, label %frac64_normalize.exit.i141.i, label %if.then10.i139.i

if.then10.i139.i:                                 ; preds = %if.else.i136.i
  %or1.i.i140.i = or i16 %40, 32
  store i16 %or1.i.i140.i, ptr %s, align 2
  br label %parts64_canonicalize.exit147.i

frac64_normalize.exit.i141.i:                     ; preds = %if.else.i136.i
  %44 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i113.i, i1 true), !range !5
  %cast.i.i.i142.i = trunc i64 %44 to i32
  %shl.i.i143.i = shl i64 %and.i10.i113.i, %44
  %add.i145.i = sub nuw nsw i32 -86, %cast.i.i.i142.i
  br label %parts64_canonicalize.exit147.i

lor.lhs.false.i121.i:                             ; preds = %parts64_canonicalize.exit108.i
  %cmp.i29.i123.i = icmp eq i32 %41, 0
  br i1 %cmp.i29.i123.i, label %parts64_canonicalize.exit147.i, label %if.else49.i124.i

if.then33.i129.i:                                 ; preds = %parts64_canonicalize.exit108.i
  %and.i9.i112.i = and i32 %shr.i8.i111.i, 255
  %sub37.i130.i = add nsw i32 %and.i9.i112.i, -127
  %shl.i28.i131.i = shl nuw nsw i64 %and.i10.i113.i, 40
  %or.i132.i = or disjoint i64 %shl.i28.i131.i, -9223372036854775808
  br label %parts64_canonicalize.exit147.i

if.else49.i124.i:                                 ; preds = %lor.lhs.false.i121.i
  %shl.i31.i125.i = shl nuw nsw i64 %and.i10.i113.i, 40
  %tobool.not.i32.i126.i = icmp ult i32 %41, 4194304
  %conv53.i127.i = select i1 %tobool.not.i32.i126.i, i8 5, i8 4
  br label %parts64_canonicalize.exit147.i

parts64_canonicalize.exit147.i:                   ; preds = %if.else49.i124.i, %if.then33.i129.i, %lor.lhs.false.i121.i, %frac64_normalize.exit.i141.i, %if.then10.i139.i, %if.then.i133.i
  %45 = phi i16 [ %40, %frac64_normalize.exit.i141.i ], [ %or1.i.i140.i, %if.then10.i139.i ], [ %40, %if.then33.i129.i ], [ %40, %if.else49.i124.i ], [ %40, %if.then.i133.i ], [ %40, %lor.lhs.false.i121.i ]
  %pc.sroa.25.0.i = phi i64 [ %shl.i.i143.i, %frac64_normalize.exit.i141.i ], [ 0, %if.then10.i139.i ], [ %or.i132.i, %if.then33.i129.i ], [ %shl.i31.i125.i, %if.else49.i124.i ], [ 0, %if.then.i133.i ], [ 0, %lor.lhs.false.i121.i ]
  %pc.sroa.20172.0.i = phi i32 [ %add.i145.i, %frac64_normalize.exit.i141.i ], [ 0, %if.then10.i139.i ], [ %sub37.i130.i, %if.then33.i129.i ], [ 255, %if.else49.i124.i ], [ 0, %if.then.i133.i ], [ 255, %lor.lhs.false.i121.i ]
  %pc.sroa.0.0.i = phi i8 [ 2, %frac64_normalize.exit.i141.i ], [ 1, %if.then10.i139.i ], [ 2, %if.then33.i129.i ], [ %conv53.i127.i, %if.else49.i124.i ], [ 1, %if.then.i133.i ], [ 3, %lor.lhs.false.i121.i ]
  %conv.i.i = zext nneg i8 %35 to i32
  %shl.i.i = shl nuw nsw i32 1, %conv.i.i
  %shl3.i.i = shl nuw nsw i32 1, %pb.sroa.0.0.i
  %or.i.i = or i32 %shl3.i.i, %shl.i.i
  %conv5.i.i = zext nneg i8 %pc.sroa.0.0.i to i32
  %shl6.i.i = shl nuw nsw i32 1, %conv5.i.i
  %or7.i.i = or i32 %shl6.i.i, %or.i.i
  %and.i.i53 = and i32 %or7.i.i, 48
  %tobool.i.not.i = icmp eq i32 %and.i.i53, 0
  br i1 %tobool.i.not.i, label %if.end.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %parts64_canonicalize.exit147.i
  %and.i148.i = and i32 %or7.i.i, 32
  %tobool.not.i.i = icmp ne i32 %and.i148.i, 0
  %cmp.i152.i.not = icmp eq i32 %or.i.i, 10
  %46 = or i1 %tobool.not.i.i, %cmp.i152.i.not
  br i1 %46, label %47, label %49

47:                                               ; preds = %if.then.i.i
  %or1.i.i150.i = or i16 %45, 8193
  %48 = select i1 %tobool.not.i.i, i16 %or1.i.i150.i, i16 %45
  %or1.i.i.i.i = or i16 %48, 257
  %simplifycfg.merge = select i1 %cmp.i152.i.not, i16 %or1.i.i.i.i, i16 %48
  store i16 %simplifycfg.merge, ptr %s, align 2
  br label %49

49:                                               ; preds = %if.then.i.i, %47
  store i8 4, ptr %pa.i, align 8
  store i8 0, ptr %pa.sroa.gep183.i, align 1
  store i32 2147483647, ptr %pa.sroa.gep188.i, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep193.i, align 8
  br label %soft_f32_muladd.exit

if.end.i.i:                                       ; preds = %parts64_canonicalize.exit147.i
  %50 = trunc i32 %flags to i8
  %51 = and i8 %50, 1
  %spec.select195.i = xor i8 %51, %frombool.i.i110.i
  %f.lobit.i196.i = xor i32 %ub.sroa.0.2, %ua.sroa.0.3
  %52 = lshr i32 %f.lobit.i196.i, 31
  %53 = trunc i32 %52 to i8
  %54 = lshr i8 %50, 1
  %55 = and i8 %54, 1
  %spec.select.i = xor i8 %55, %53
  store i8 %spec.select.i, ptr %pa.sroa.gep183.i, align 1
  %trunc200.i = trunc i32 %or.i.i to i8
  switch i8 %trunc200.i, label %if.end54.i.i [
    i8 4, label %if.end108.i.i
    i8 10, label %d_nan.i.i
  ]

if.end54.i.i:                                     ; preds = %if.end.i.i
  %and55.i.i = and i32 %or.i.i, 8
  %tobool56.i.not.i = icmp eq i32 %and55.i.i, 0
  br i1 %tobool56.i.not.i, label %if.end72.i.i, label %if.then57.i.i

if.then57.i.i:                                    ; preds = %if.end54.i.i
  %cmp60.i.i = icmp ne i8 %pc.sroa.0.0.i, 3
  %cmp68.i.not.i = icmp eq i8 %spec.select.i, %spec.select195.i
  %or.cond.i = or i1 %cmp68.i.not.i, %cmp60.i.i
  br i1 %or.cond.i, label %return_inf.i.i, label %d_nan.i.i

if.end72.i.i:                                     ; preds = %if.end54.i.i
  %and73.i.i = and i32 %or.i.i, 2
  %tobool74.i.not.i = icmp eq i32 %and73.i.i, 0
  br i1 %tobool74.i.not.i, label %if.else.i.i, label %if.then75.i.i

if.then75.i.i:                                    ; preds = %if.end72.i.i
  switch i8 %pc.sroa.0.0.i, label %if.else105.i.i [
    i8 2, label %if.then81.i.i
    i8 1, label %if.then87.i.i
    i8 3, label %if.then119.i.i
  ]

if.else.i.i:                                      ; preds = %if.end72.i.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 522, ptr noundef nonnull @__func__.parts64_muladd, ptr noundef nonnull @.str.7) #16
  unreachable

if.then81.i.i:                                    ; preds = %if.then75.i.i
  store i8 2, ptr %pa.i, align 8
  store i8 %spec.select195.i, ptr %pa.sroa.gep183.i, align 1
  store i32 %pc.sroa.20172.0.i, ptr %pa.sroa.gep188.i, align 4
  store i64 %pc.sroa.25.0.i, ptr %pa.sroa.gep193.i, align 8
  br label %return_normal.i.i

if.then87.i.i:                                    ; preds = %if.then75.i.i
  %cmp94.i.not.i = icmp eq i8 %spec.select.i, %spec.select195.i
  br i1 %cmp94.i.not.i, label %return_zero.i.i, label %return_sub_zero.i.i

if.else105.i.i:                                   ; preds = %if.then75.i.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 533, ptr noundef nonnull @__func__.parts64_muladd, ptr noundef nonnull @.str.12) #16
  unreachable

if.end108.i.i:                                    ; preds = %if.end.i.i
  %cmp111.i.i = icmp eq i8 %pc.sroa.0.0.i, 3
  br i1 %cmp111.i.i, label %if.then119.i.i, label %if.end124.i.i

if.then119.i.i:                                   ; preds = %if.end108.i.i, %if.then75.i.i
  store i8 %spec.select195.i, ptr %pa.sroa.gep183.i, align 1
  br label %return_inf.i.i

if.end124.i.i:                                    ; preds = %if.end108.i.i
  %sign127.i.i = getelementptr inbounds i8, ptr %p_widen.i.i, i64 1
  store i8 %spec.select.i, ptr %sign127.i.i, align 1
  %add.i.i54 = add nsw i32 %pb.sroa.10.0.i, %34
  %add130.i.i = add nsw i32 %add.i.i54, 1
  %exp131.i.i = getelementptr inbounds i8, ptr %p_widen.i.i, i64 4
  store i32 %add130.i.i, ptr %exp131.i.i, align 4
  %frac_lo.i.i = getelementptr inbounds i8, ptr %p_widen.i.i, i64 16
  %frac_hi.i154.i = getelementptr inbounds i8, ptr %p_widen.i.i, i64 8
  %conv.i.i.i = zext i64 %pa.val.i to i128
  %conv1.i.i.i = zext i64 %pb.sroa.15.0.i to i128
  %mul.i.i.i = mul nuw i128 %conv1.i.i.i, %conv.i.i.i
  %conv2.i.i.i = trunc i128 %mul.i.i.i to i64
  store i64 %conv2.i.i.i, ptr %frac_lo.i.i, align 8
  %shr.i.i.i = lshr i128 %mul.i.i.i, 64
  %conv3.i.i.i = trunc i128 %shr.i.i.i to i64
  store i64 %conv3.i.i.i, ptr %frac_hi.i154.i, align 8
  %tobool133.i.not.i = icmp sgt i128 %mul.i.i.i, -1
  br i1 %tobool133.i.not.i, label %if.then134.i.i, label %if.end137.i.i

if.then134.i.i:                                   ; preds = %if.end124.i.i
  %56 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i.i, i64 %conv2.i.i.i)
  %57 = extractvalue { i64, i1 } %56, 1
  %58 = extractvalue { i64, i1 } %56, 0
  store i64 %58, ptr %frac_lo.i.i, align 8
  %conv.i4.i.i = zext i1 %57 to i64
  %59 = shl nuw i64 %conv3.i.i.i, 1
  %60 = or disjoint i64 %59, %conv.i4.i.i
  store i64 %60, ptr %frac_hi.i154.i, align 8
  store i32 %add.i.i54, ptr %exp131.i.i, align 4
  br label %if.end137.i.i

if.end137.i.i:                                    ; preds = %if.then134.i.i, %if.end124.i.i
  %cmp140.i.not.i = icmp eq i8 %pc.sroa.0.0.i, 1
  br i1 %cmp140.i.not.i, label %if.end159.i.i, label %if.then142.i.i

if.then142.i.i:                                   ; preds = %if.end137.i.i
  %frac_hi.i157.i = getelementptr inbounds i8, ptr %c_widen.i.i, i64 8
  store i64 %pc.sroa.25.0.i, ptr %frac_hi.i157.i, align 8
  %frac_lo.i158.i = getelementptr inbounds i8, ptr %c_widen.i.i, i64 16
  store i64 0, ptr %frac_lo.i158.i, align 8
  %exp144.i.i = getelementptr inbounds i8, ptr %c_widen.i.i, i64 4
  store i32 %pc.sroa.20172.0.i, ptr %exp144.i.i, align 4
  %cmp151.i.i = icmp eq i8 %spec.select.i, %spec.select195.i
  br i1 %cmp151.i.i, label %if.then153.i.i, label %if.else154.i.i

if.then153.i.i:                                   ; preds = %if.then142.i.i
  call fastcc void @parts128_add_normal(ptr noundef nonnull %p_widen.i.i, ptr noundef nonnull %c_widen.i.i)
  br label %if.end159.i.i

if.else154.i.i:                                   ; preds = %if.then142.i.i
  %call155.i.i = call fastcc zeroext i1 @parts128_sub_normal(ptr noundef nonnull %p_widen.i.i, ptr noundef nonnull %c_widen.i.i)
  br i1 %call155.i.i, label %if.end159.i.i, label %return_sub_zero.i.i

if.end159.i.i:                                    ; preds = %if.else154.i.i, %if.then153.i.i, %if.end137.i.i
  %p_widen.i.val.i = load i64, ptr %frac_hi.i154.i, align 8
  %p_widen.i.val64.i = load i64, ptr %frac_lo.i.i, align 8
  %cmp.i159.i = icmp ne i64 %p_widen.i.val64.i, 0
  %conv1.i.i = zext i1 %cmp.i159.i to i64
  %or.i160.i = or i64 %p_widen.i.val.i, %conv1.i.i
  store i64 %or.i160.i, ptr %pa.sroa.gep193.i, align 8
  %61 = load i8, ptr %sign127.i.i, align 1
  %62 = and i8 %61, 1
  store i8 %62, ptr %pa.sroa.gep183.i, align 1
  %63 = load i32, ptr %exp131.i.i, align 4
  store i32 %63, ptr %pa.sroa.gep188.i, align 4
  br label %return_normal.i.i

return_normal.i.i:                                ; preds = %if.end159.i.i, %if.then81.i.i
  %64 = phi i8 [ %62, %if.end159.i.i ], [ %spec.select195.i, %if.then81.i.i ]
  %65 = phi i32 [ %63, %if.end159.i.i ], [ %pc.sroa.20172.0.i, %if.then81.i.i ]
  %and166.i.i = and i32 %flags, 8
  %tobool167.i.not.i = icmp eq i32 %and166.i.i, 0
  br i1 %tobool167.i.not.i, label %finish_sign.i.i, label %if.then168.i.i

if.then168.i.i:                                   ; preds = %return_normal.i.i
  %sub170.i.i = add i32 %65, -1
  store i32 %sub170.i.i, ptr %pa.sroa.gep188.i, align 4
  br label %finish_sign.i.i

finish_sign.i.i:                                  ; preds = %return_inf.i.i, %return_zero.i.i, %if.then168.i.i, %return_normal.i.i
  %66 = phi i8 [ %64, %return_normal.i.i ], [ %64, %if.then168.i.i ], [ %69, %return_inf.i.i ], [ %68, %return_zero.i.i ]
  %and172.i.i = and i32 %flags, 4
  %tobool173.i.not.i = icmp eq i32 %and172.i.i, 0
  br i1 %tobool173.i.not.i, label %soft_f32_muladd.exit, label %if.then174.i.i

if.then174.i.i:                                   ; preds = %finish_sign.i.i
  %frombool180.i.i = xor i8 %66, 1
  store i8 %frombool180.i.i, ptr %pa.sroa.gep183.i, align 1
  br label %soft_f32_muladd.exit

return_sub_zero.i.i:                              ; preds = %if.else154.i.i, %if.then87.i.i
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %s, i64 2
  %67 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp183.i.i = icmp eq i8 %67, 1
  %frombool186.i.i = zext i1 %cmp183.i.i to i8
  store i8 %frombool186.i.i, ptr %pa.sroa.gep183.i, align 1
  br label %return_zero.i.i

return_zero.i.i:                                  ; preds = %return_sub_zero.i.i, %if.then87.i.i
  %68 = phi i8 [ %spec.select195.i, %if.then87.i.i ], [ %frombool186.i.i, %return_sub_zero.i.i ]
  store i8 1, ptr %pa.i, align 8
  br label %finish_sign.i.i

return_inf.i.i:                                   ; preds = %if.then119.i.i, %if.then57.i.i
  %69 = phi i8 [ %spec.select.i, %if.then57.i.i ], [ %spec.select195.i, %if.then119.i.i ]
  store i8 3, ptr %pa.i, align 8
  br label %finish_sign.i.i

d_nan.i.i:                                        ; preds = %if.then57.i.i, %if.end.i.i
  %.sink201.i = phi i16 [ 257, %if.end.i.i ], [ 129, %if.then57.i.i ]
  %or1.i153.i = or i16 %45, %.sink201.i
  store i16 %or1.i153.i, ptr %s, align 2
  store i8 4, ptr %pa.i, align 8
  store i8 0, ptr %pa.sroa.gep183.i, align 1
  store i32 2147483647, ptr %pa.sroa.gep188.i, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep193.i, align 8
  br label %soft_f32_muladd.exit

soft_f32_muladd.exit:                             ; preds = %49, %finish_sign.i.i, %if.then174.i.i, %d_nan.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %pa.i, ptr noundef nonnull %s, ptr noundef nonnull @float32_params)
  %70 = load i8, ptr %pa.sroa.gep183.i, align 1
  %conv.i.i161.i = zext i8 %70 to i64
  %shl.i.i162.i = shl nuw nsw i64 %conv.i.i161.i, 31
  %71 = load i32, ptr %pa.sroa.gep188.i, align 4
  %72 = shl i32 %71, 23
  %73 = and i32 %72, 2139095040
  %and8.i.i.i = zext nneg i32 %73 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i162.i, %and8.i.i.i
  %74 = load i64, ptr %pa.sroa.gep193.i, align 8
  %shl77.i9.i.i = and i64 %74, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i163.i = trunc i64 %or.i10.i.i to i32
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %p_widen.i.i)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %c_widen.i.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %pa.i)
  br label %return

return:                                           ; preds = %soft_f32_muladd.exit, %if.end97, %if.then95
  %retval.0 = phi i32 [ %conv.i163.i, %soft_f32_muladd.exit ], [ %xor.i, %if.then95 ], [ %ur.sroa.0.0, %if.end97 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fma.f32(float, float, float) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fabs.f32(float) #4

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_muladd(i64 noundef %xa, i64 noundef %xb, i64 noundef %xc, i32 noundef %flags, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p_widen.i.i = alloca %struct.FloatParts128, align 8
  %c_widen.i.i = alloca %struct.FloatParts128, align 8
  %pa.i = alloca %struct.FloatParts64, align 8
  %0 = load i16, ptr %s, align 2
  %1 = and i16 %0, 16
  %tobool.i.not = icmp eq i16 %1, 0
  br i1 %tobool.i.not, label %soft, label %land.rhs.i

land.rhs.i:                                       ; preds = %entry
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %s, i64 2
  %2 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp.i = icmp eq i8 %2, 0
  %and = and i32 %flags, 8
  %tobool3.not = icmp eq i32 %and, 0
  %or.cond = and i1 %tobool3.not, %cmp.i
  br i1 %or.cond, label %if.end11, label %soft

if.end11:                                         ; preds = %land.rhs.i
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool.i102.not = icmp eq i8 %4, 0
  br i1 %tobool.i102.not, label %float64_input_flush3.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end11
  %and.i.i.i = and i64 %xa, 9218868437227405312
  %cmp.i.i.i = icmp eq i64 %and.i.i.i, 0
  %and.i2.i.i = and i64 %xa, 9223372036854775807
  %cmp.i3.i.i = icmp ne i64 %and.i2.i.i, 0
  %5 = and i1 %cmp.i.i.i, %cmp.i3.i.i
  %.lobit.i = and i64 %xa, -9223372036854775808
  %or1.i.i = or i16 %0, 32
  %ua.sroa.0.0 = select i1 %5, i64 %.lobit.i, i64 %xa
  %and.i.i.i49 = and i64 %xb, 9218868437227405312
  %cmp.i.i.i50 = icmp eq i64 %and.i.i.i49, 0
  %and.i2.i.i51 = and i64 %xb, 9223372036854775807
  %cmp.i3.i.i52 = icmp ne i64 %and.i2.i.i51, 0
  %6 = and i1 %cmp.i.i.i50, %cmp.i3.i.i52
  %.lobit.i55 = and i64 %xb, -9223372036854775808
  %7 = or i1 %6, %5
  %ub.sroa.0.0 = select i1 %6, i64 %.lobit.i55, i64 %xb
  %8 = or i1 %5, %6
  %and.i.i.i58 = and i64 %xc, 9218868437227405312
  %cmp.i.i.i59 = icmp eq i64 %and.i.i.i58, 0
  %and.i2.i.i60 = and i64 %xc, 9223372036854775807
  %cmp.i3.i.i61 = icmp ne i64 %and.i2.i.i60, 0
  %9 = and i1 %cmp.i.i.i59, %cmp.i3.i.i61
  %.lobit.i64 = and i64 %xc, -9223372036854775808
  %10 = or i1 %9, %7
  %.ph = select i1 %10, i16 %or1.i.i, i16 %0
  %uc.sroa.0.1.ph = select i1 %9, i64 %.lobit.i64, i64 %xc
  %11 = or i1 %8, %9
  br i1 %11, label %12, label %float64_input_flush3.exit

12:                                               ; preds = %if.end.i
  store i16 %.ph, ptr %s, align 2
  br label %float64_input_flush3.exit

float64_input_flush3.exit:                        ; preds = %12, %if.end.i, %if.end11
  %13 = phi i16 [ %0, %if.end11 ], [ %.ph, %if.end.i ], [ %.ph, %12 ]
  %ua.sroa.0.1 = phi i64 [ %xa, %if.end11 ], [ %ua.sroa.0.0, %if.end.i ], [ %ua.sroa.0.0, %12 ]
  %ub.sroa.0.1 = phi i64 [ %xb, %if.end11 ], [ %ub.sroa.0.0, %if.end.i ], [ %ub.sroa.0.0, %12 ]
  %uc.sroa.0.1 = phi i64 [ %xc, %if.end11 ], [ %uc.sroa.0.1.ph, %if.end.i ], [ %uc.sroa.0.1.ph, %12 ]
  %14 = bitcast i64 %ua.sroa.0.1 to double
  %15 = bitcast i64 %ub.sroa.0.1 to double
  %16 = bitcast i64 %uc.sroa.0.1 to double
  %or.cond35 = fcmp ueq double %14, 0.000000e+00
  br i1 %or.cond35, label %lor.lhs.false.i, label %fpclassify_not_nan.i

lor.lhs.false.i:                                  ; preds = %float64_input_flush3.exit
  %iszero.i = fcmp oeq double %14, 0.000000e+00
  br i1 %iszero.i, label %land.lhs.true.i, label %soft

fpclassify_not_nan.i:                             ; preds = %float64_input_flush3.exit
  %or.cond44 = tail call i1 @llvm.is.fpclass.f64(double %14, i32 267)
  br i1 %or.cond44, label %land.lhs.true.i, label %soft

land.lhs.true.i:                                  ; preds = %fpclassify_not_nan.i, %lor.lhs.false.i
  %or.cond37 = fcmp ueq double %15, 0.000000e+00
  br i1 %or.cond37, label %lor.lhs.false24.i, label %fpclassify_not_nan19.i

lor.lhs.false24.i:                                ; preds = %land.lhs.true.i
  %iszero16.i = fcmp oeq double %15, 0.000000e+00
  br i1 %iszero16.i, label %land.rhs.i107, label %soft

fpclassify_not_nan19.i:                           ; preds = %land.lhs.true.i
  %or.cond45 = tail call i1 @llvm.is.fpclass.f64(double %15, i32 267)
  br i1 %or.cond45, label %land.rhs.i107, label %soft

land.rhs.i107:                                    ; preds = %fpclassify_not_nan19.i, %lor.lhs.false24.i
  %iszero37.i = fcmp oeq double %16, 0.000000e+00
  %or.cond39 = fcmp ueq double %16, 0.000000e+00
  br i1 %or.cond39, label %lor.rhs.i, label %fpclassify_not_nan40.i

lor.rhs.i:                                        ; preds = %land.rhs.i107
  br i1 %iszero37.i, label %if.end33, label %soft

fpclassify_not_nan40.i:                           ; preds = %land.rhs.i107
  %or.cond46 = tail call i1 @llvm.is.fpclass.f64(double %16, i32 267)
  %brmerge = or i1 %or.cond46, %iszero37.i
  br i1 %brmerge, label %if.end33, label %soft

if.end33:                                         ; preds = %fpclassify_not_nan40.i, %lor.rhs.i
  %and.i112 = and i64 %ua.sroa.0.1, 9223372036854775807
  %cmp.i113 = icmp eq i64 %and.i112, 0
  %and.i109 = and i64 %ub.sroa.0.1, 9223372036854775807
  %cmp.i110 = icmp eq i64 %and.i109, 0
  %or.cond83 = or i1 %cmp.i113, %cmp.i110
  br i1 %or.cond83, label %if.then38, label %if.else

if.then38:                                        ; preds = %if.end33
  %.lobit34 = xor i64 %ub.sroa.0.1, %ua.sroa.0.1
  %and44 = lshr i32 %flags, 1
  %and44.lobit = and i32 %and44, 1
  %.lobit34.lobit = lshr i64 %.lobit34, 63
  %conv51 = trunc i64 %.lobit34.lobit to i32
  %tobool53.not = icmp eq i32 %and44.lobit, %conv51
  %and58 = and i32 %flags, 1
  %tobool59.not = icmp eq i32 %and58, 0
  %fneg = fneg double %16
  %17 = select i1 %tobool53.not, double 0.000000e+00, double -0.000000e+00
  %18 = select i1 %tobool59.not, double %16, double %fneg
  %add = fadd double %18, %17
  br label %if.end92

if.else:                                          ; preds = %if.end33
  %and62 = and i32 %flags, 2
  %tobool63.not = icmp eq i32 %and62, 0
  %fneg65 = fneg double %14
  %and67 = and i32 %flags, 1
  %tobool68.not = icmp eq i32 %and67, 0
  %fneg70 = fneg double %16
  %19 = select i1 %tobool63.not, double %14, double %fneg65
  %20 = select i1 %tobool68.not, double %16, double %fneg70
  %21 = tail call double @llvm.fma.f64(double %19, double %15, double %20)
  %22 = tail call double @llvm.fabs.f64(double %21) #17
  %isinf.i124 = fcmp oeq double %22, 0x7FF0000000000000
  br i1 %isinf.i124, label %if.then80, label %if.else81

if.then80:                                        ; preds = %if.else
  %23 = or i16 %13, 4
  store i16 %23, ptr %s, align 2
  br label %if.end92

if.else81:                                        ; preds = %if.else
  %cmp = fcmp ugt double %22, 0x3810000000000000
  br i1 %cmp, label %if.end92, label %soft

if.end92:                                         ; preds = %if.then80, %if.else81, %if.then38
  %ur.sroa.0.0.in = phi double [ %add, %if.then38 ], [ %21, %if.then80 ], [ %21, %if.else81 ]
  %and93 = and i32 %flags, 4
  %tobool94.not = icmp eq i32 %and93, 0
  br i1 %tobool94.not, label %if.end97, label %if.then95

if.then95:                                        ; preds = %if.end92
  %24 = fneg double %ur.sroa.0.0.in
  %xor.i = bitcast double %24 to i64
  br label %return

if.end97:                                         ; preds = %if.end92
  %ur.sroa.0.0 = bitcast double %ur.sroa.0.0.in to i64
  br label %return

soft:                                             ; preds = %fpclassify_not_nan40.i, %lor.lhs.false24.i, %fpclassify_not_nan19.i, %lor.lhs.false.i, %fpclassify_not_nan.i, %if.else81, %entry, %lor.rhs.i, %land.rhs.i
  %25 = phi i16 [ %0, %entry ], [ %13, %lor.rhs.i ], [ %0, %land.rhs.i ], [ %13, %if.else81 ], [ %13, %fpclassify_not_nan.i ], [ %13, %lor.lhs.false.i ], [ %13, %fpclassify_not_nan19.i ], [ %13, %lor.lhs.false24.i ], [ %13, %fpclassify_not_nan40.i ]
  %ua.sroa.0.3 = phi i64 [ %xa, %entry ], [ %ua.sroa.0.1, %lor.rhs.i ], [ %xa, %land.rhs.i ], [ %ua.sroa.0.1, %if.else81 ], [ %ua.sroa.0.1, %fpclassify_not_nan.i ], [ %ua.sroa.0.1, %lor.lhs.false.i ], [ %ua.sroa.0.1, %fpclassify_not_nan19.i ], [ %ua.sroa.0.1, %lor.lhs.false24.i ], [ %ua.sroa.0.1, %fpclassify_not_nan40.i ]
  %ub.sroa.0.2 = phi i64 [ %xb, %entry ], [ %ub.sroa.0.1, %lor.rhs.i ], [ %xb, %land.rhs.i ], [ %ub.sroa.0.1, %if.else81 ], [ %ub.sroa.0.1, %fpclassify_not_nan.i ], [ %ub.sroa.0.1, %lor.lhs.false.i ], [ %ub.sroa.0.1, %fpclassify_not_nan19.i ], [ %ub.sroa.0.1, %lor.lhs.false24.i ], [ %ub.sroa.0.1, %fpclassify_not_nan40.i ]
  %uc.sroa.0.4 = phi i64 [ %xc, %entry ], [ %uc.sroa.0.1, %lor.rhs.i ], [ %xc, %land.rhs.i ], [ %uc.sroa.0.1, %if.else81 ], [ %uc.sroa.0.1, %fpclassify_not_nan.i ], [ %uc.sroa.0.1, %lor.lhs.false.i ], [ %uc.sroa.0.1, %fpclassify_not_nan19.i ], [ %uc.sroa.0.1, %lor.lhs.false24.i ], [ %uc.sroa.0.1, %fpclassify_not_nan40.i ]
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %p_widen.i.i)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %c_widen.i.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %pa.i)
  %pa.sroa.gep193.i = getelementptr inbounds i8, ptr %pa.i, i64 8
  %pa.sroa.gep188.i = getelementptr inbounds i8, ptr %pa.i, i64 4
  %pa.sroa.gep183.i = getelementptr inbounds i8, ptr %pa.i, i64 1
  %shr.i8.i.i = lshr i64 %ua.sroa.0.3, 52
  %26 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %26, 2047
  %and.i9.i.i = and i64 %ua.sroa.0.3, 4503599627370495
  store i32 %conv.i.i.i, ptr %pa.sroa.gep188.i, align 4
  store i64 %and.i9.i.i, ptr %pa.sroa.gep193.i, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i67.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i67.i:                                    ; preds = %soft
  %cmp.i.i.i67 = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i67, label %if.then8.i.i, label %if.else.i68.i

if.then8.i.i:                                     ; preds = %if.then.i67.i
  store i8 1, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

if.else.i68.i:                                    ; preds = %if.then.i67.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %27 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %28 = and i8 %27, 1
  %tobool9.not.i.i = icmp eq i8 %28, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i68.i
  %or1.i.i.i = or i16 %25, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %pa.i, align 8
  store i64 0, ptr %pa.sroa.gep193.i, align 8
  br label %parts64_canonicalize.exit.i

frac64_normalize.exit.i.i:                        ; preds = %if.else.i68.i
  %29 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %29 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %29
  store i64 %shl.i.i.i, ptr %pa.sroa.gep193.i, align 8
  store i8 2, ptr %pa.i, align 8
  %add.i69.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i69.i, ptr %pa.sroa.gep188.i, align 4
  br label %parts64_canonicalize.exit.i

lor.lhs.false.i.i:                                ; preds = %soft
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %soft
  store i8 2, ptr %pa.i, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %pa.sroa.gep188.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i66.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i66.i, ptr %pa.sroa.gep193.i, align 8
  br label %parts64_canonicalize.exit.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %pa.sroa.gep193.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

parts64_canonicalize.exit.i:                      ; preds = %if.else49.i.i, %if.then47.i.i, %if.then33.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then8.i.i
  %30 = phi i16 [ %25, %if.then8.i.i ], [ %or1.i.i.i, %if.then10.i.i ], [ %25, %frac64_normalize.exit.i.i ], [ %25, %if.then33.i.i ], [ %25, %if.then47.i.i ], [ %25, %if.else49.i.i ]
  %pa.val.i = phi i64 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i66.i, %if.then33.i.i ], [ 0, %if.then47.i.i ], [ %shl.i31.i.i, %if.else49.i.i ]
  %31 = phi i32 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %add.i69.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ 2047, %if.then47.i.i ], [ 2047, %if.else49.i.i ]
  %32 = phi i8 [ 1, %if.then8.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ], [ 3, %if.then47.i.i ], [ %conv53.i.i, %if.else49.i.i ]
  %shr.i8.i72.i = lshr i64 %ub.sroa.0.2, 52
  %33 = trunc i64 %shr.i8.i72.i to i32
  %conv.i.i73.i = and i32 %33, 2047
  %and.i9.i74.i = and i64 %ub.sroa.0.2, 4503599627370495
  switch i32 %conv.i.i73.i, label %if.then33.i90.i [
    i32 0, label %if.then.i94.i
    i32 2047, label %lor.lhs.false.i82.i
  ]

if.then.i94.i:                                    ; preds = %parts64_canonicalize.exit.i
  %cmp.i.i96.i = icmp eq i64 %and.i9.i74.i, 0
  br i1 %cmp.i.i96.i, label %parts64_canonicalize.exit108.i, label %if.else.i97.i

if.else.i97.i:                                    ; preds = %if.then.i94.i
  %flush_inputs_to_zero.i98.i = getelementptr inbounds i8, ptr %s, i64 6
  %34 = load i8, ptr %flush_inputs_to_zero.i98.i, align 2
  %35 = and i8 %34, 1
  %tobool9.not.i99.i = icmp eq i8 %35, 0
  br i1 %tobool9.not.i99.i, label %frac64_normalize.exit.i102.i, label %if.then10.i100.i

if.then10.i100.i:                                 ; preds = %if.else.i97.i
  %or1.i.i101.i = or i16 %30, 32
  store i16 %or1.i.i101.i, ptr %s, align 2
  br label %parts64_canonicalize.exit108.i

frac64_normalize.exit.i102.i:                     ; preds = %if.else.i97.i
  %36 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i74.i, i1 true), !range !5
  %cast.i.i.i103.i = trunc i64 %36 to i32
  %shl.i.i104.i = shl i64 %and.i9.i74.i, %36
  %add.i106.i = sub nuw nsw i32 -1011, %cast.i.i.i103.i
  br label %parts64_canonicalize.exit108.i

lor.lhs.false.i82.i:                              ; preds = %parts64_canonicalize.exit.i
  %cmp.i29.i84.i = icmp eq i64 %and.i9.i74.i, 0
  br i1 %cmp.i29.i84.i, label %parts64_canonicalize.exit108.i, label %if.else49.i85.i

if.then33.i90.i:                                  ; preds = %parts64_canonicalize.exit.i
  %sub37.i91.i = add nsw i32 %conv.i.i73.i, -1023
  %shl.i28.i92.i = shl nuw nsw i64 %and.i9.i74.i, 11
  %or.i93.i = or disjoint i64 %shl.i28.i92.i, -9223372036854775808
  br label %parts64_canonicalize.exit108.i

if.else49.i85.i:                                  ; preds = %lor.lhs.false.i82.i
  %shl.i31.i86.i = shl nuw nsw i64 %and.i9.i74.i, 11
  %tobool.not.i32.i87.i = icmp ult i64 %and.i9.i74.i, 2251799813685248
  %conv53.i88.i = select i1 %tobool.not.i32.i87.i, i32 5, i32 4
  br label %parts64_canonicalize.exit108.i

parts64_canonicalize.exit108.i:                   ; preds = %if.else49.i85.i, %if.then33.i90.i, %lor.lhs.false.i82.i, %frac64_normalize.exit.i102.i, %if.then10.i100.i, %if.then.i94.i
  %37 = phi i16 [ %30, %frac64_normalize.exit.i102.i ], [ %or1.i.i101.i, %if.then10.i100.i ], [ %30, %if.then33.i90.i ], [ %30, %if.else49.i85.i ], [ %30, %if.then.i94.i ], [ %30, %lor.lhs.false.i82.i ]
  %pb.sroa.10.0.i = phi i32 [ %add.i106.i, %frac64_normalize.exit.i102.i ], [ 0, %if.then10.i100.i ], [ %sub37.i91.i, %if.then33.i90.i ], [ 2047, %if.else49.i85.i ], [ 0, %if.then.i94.i ], [ 2047, %lor.lhs.false.i82.i ]
  %pb.sroa.0.0.i = phi i32 [ 2, %frac64_normalize.exit.i102.i ], [ 1, %if.then10.i100.i ], [ 2, %if.then33.i90.i ], [ %conv53.i88.i, %if.else49.i85.i ], [ 1, %if.then.i94.i ], [ 3, %lor.lhs.false.i82.i ]
  %pb.sroa.15.0.i = phi i64 [ %shl.i.i104.i, %frac64_normalize.exit.i102.i ], [ 0, %if.then10.i100.i ], [ %or.i93.i, %if.then33.i90.i ], [ %shl.i31.i86.i, %if.else49.i85.i ], [ 0, %if.then.i94.i ], [ 0, %lor.lhs.false.i82.i ]
  %f.lobit.i109.i = lshr i64 %uc.sroa.0.4, 63
  %frombool.i.i110.i = trunc i64 %f.lobit.i109.i to i8
  %shr.i8.i111.i = lshr i64 %uc.sroa.0.4, 52
  %38 = trunc i64 %shr.i8.i111.i to i32
  %conv.i.i112.i = and i32 %38, 2047
  %and.i9.i113.i = and i64 %uc.sroa.0.4, 4503599627370495
  switch i32 %conv.i.i112.i, label %if.then33.i129.i [
    i32 0, label %if.then.i133.i
    i32 2047, label %lor.lhs.false.i121.i
  ]

if.then.i133.i:                                   ; preds = %parts64_canonicalize.exit108.i
  %cmp.i.i135.i = icmp eq i64 %and.i9.i113.i, 0
  br i1 %cmp.i.i135.i, label %parts64_canonicalize.exit147.i, label %if.else.i136.i

if.else.i136.i:                                   ; preds = %if.then.i133.i
  %flush_inputs_to_zero.i137.i = getelementptr inbounds i8, ptr %s, i64 6
  %39 = load i8, ptr %flush_inputs_to_zero.i137.i, align 2
  %40 = and i8 %39, 1
  %tobool9.not.i138.i = icmp eq i8 %40, 0
  br i1 %tobool9.not.i138.i, label %frac64_normalize.exit.i141.i, label %if.then10.i139.i

if.then10.i139.i:                                 ; preds = %if.else.i136.i
  %or1.i.i140.i = or i16 %37, 32
  store i16 %or1.i.i140.i, ptr %s, align 2
  br label %parts64_canonicalize.exit147.i

frac64_normalize.exit.i141.i:                     ; preds = %if.else.i136.i
  %41 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i113.i, i1 true), !range !5
  %cast.i.i.i142.i = trunc i64 %41 to i32
  %shl.i.i143.i = shl i64 %and.i9.i113.i, %41
  %add.i145.i = sub nuw nsw i32 -1011, %cast.i.i.i142.i
  br label %parts64_canonicalize.exit147.i

lor.lhs.false.i121.i:                             ; preds = %parts64_canonicalize.exit108.i
  %cmp.i29.i123.i = icmp eq i64 %and.i9.i113.i, 0
  br i1 %cmp.i29.i123.i, label %parts64_canonicalize.exit147.i, label %if.else49.i124.i

if.then33.i129.i:                                 ; preds = %parts64_canonicalize.exit108.i
  %sub37.i130.i = add nsw i32 %conv.i.i112.i, -1023
  %shl.i28.i131.i = shl nuw nsw i64 %and.i9.i113.i, 11
  %or.i132.i = or disjoint i64 %shl.i28.i131.i, -9223372036854775808
  br label %parts64_canonicalize.exit147.i

if.else49.i124.i:                                 ; preds = %lor.lhs.false.i121.i
  %shl.i31.i125.i = shl nuw nsw i64 %and.i9.i113.i, 11
  %tobool.not.i32.i126.i = icmp ult i64 %and.i9.i113.i, 2251799813685248
  %conv53.i127.i = select i1 %tobool.not.i32.i126.i, i8 5, i8 4
  br label %parts64_canonicalize.exit147.i

parts64_canonicalize.exit147.i:                   ; preds = %if.else49.i124.i, %if.then33.i129.i, %lor.lhs.false.i121.i, %frac64_normalize.exit.i141.i, %if.then10.i139.i, %if.then.i133.i
  %42 = phi i16 [ %37, %frac64_normalize.exit.i141.i ], [ %or1.i.i140.i, %if.then10.i139.i ], [ %37, %if.then33.i129.i ], [ %37, %if.else49.i124.i ], [ %37, %if.then.i133.i ], [ %37, %lor.lhs.false.i121.i ]
  %pc.sroa.25.0.i = phi i64 [ %shl.i.i143.i, %frac64_normalize.exit.i141.i ], [ 0, %if.then10.i139.i ], [ %or.i132.i, %if.then33.i129.i ], [ %shl.i31.i125.i, %if.else49.i124.i ], [ 0, %if.then.i133.i ], [ 0, %lor.lhs.false.i121.i ]
  %pc.sroa.20172.0.i = phi i32 [ %add.i145.i, %frac64_normalize.exit.i141.i ], [ 0, %if.then10.i139.i ], [ %sub37.i130.i, %if.then33.i129.i ], [ 2047, %if.else49.i124.i ], [ 0, %if.then.i133.i ], [ 2047, %lor.lhs.false.i121.i ]
  %pc.sroa.0.0.i = phi i8 [ 2, %frac64_normalize.exit.i141.i ], [ 1, %if.then10.i139.i ], [ 2, %if.then33.i129.i ], [ %conv53.i127.i, %if.else49.i124.i ], [ 1, %if.then.i133.i ], [ 3, %lor.lhs.false.i121.i ]
  %conv.i.i = zext nneg i8 %32 to i32
  %shl.i.i = shl nuw nsw i32 1, %conv.i.i
  %shl3.i.i = shl nuw nsw i32 1, %pb.sroa.0.0.i
  %or.i.i = or i32 %shl3.i.i, %shl.i.i
  %conv5.i.i = zext nneg i8 %pc.sroa.0.0.i to i32
  %shl6.i.i = shl nuw nsw i32 1, %conv5.i.i
  %or7.i.i = or i32 %shl6.i.i, %or.i.i
  %and.i.i = and i32 %or7.i.i, 48
  %tobool.i.not.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.i.not.i, label %if.end.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %parts64_canonicalize.exit147.i
  %and.i148.i = and i32 %or7.i.i, 32
  %tobool.not.i.i = icmp ne i32 %and.i148.i, 0
  %cmp.i152.i.not = icmp eq i32 %or.i.i, 10
  %43 = or i1 %tobool.not.i.i, %cmp.i152.i.not
  br i1 %43, label %44, label %46

44:                                               ; preds = %if.then.i.i
  %or1.i.i150.i = or i16 %42, 8193
  %45 = select i1 %tobool.not.i.i, i16 %or1.i.i150.i, i16 %42
  %or1.i.i.i.i = or i16 %45, 257
  %simplifycfg.merge = select i1 %cmp.i152.i.not, i16 %or1.i.i.i.i, i16 %45
  store i16 %simplifycfg.merge, ptr %s, align 2
  br label %46

46:                                               ; preds = %if.then.i.i, %44
  store i8 4, ptr %pa.i, align 8
  store i8 0, ptr %pa.sroa.gep183.i, align 1
  store i32 2147483647, ptr %pa.sroa.gep188.i, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep193.i, align 8
  br label %soft_f64_muladd.exit

if.end.i.i:                                       ; preds = %parts64_canonicalize.exit147.i
  %47 = trunc i32 %flags to i8
  %48 = and i8 %47, 1
  %spec.select195.i = xor i8 %48, %frombool.i.i110.i
  %f.lobit.i196.i = xor i64 %ub.sroa.0.2, %ua.sroa.0.3
  %49 = lshr i64 %f.lobit.i196.i, 63
  %50 = trunc i64 %49 to i8
  %51 = lshr i8 %47, 1
  %52 = and i8 %51, 1
  %spec.select.i = xor i8 %52, %50
  store i8 %spec.select.i, ptr %pa.sroa.gep183.i, align 1
  %trunc.i = trunc i32 %or.i.i to i8
  switch i8 %trunc.i, label %if.end54.i.i [
    i8 4, label %if.end108.i.i
    i8 10, label %d_nan.i.i
  ]

if.end54.i.i:                                     ; preds = %if.end.i.i
  %and55.i.i = and i32 %or.i.i, 8
  %tobool56.i.not.i = icmp eq i32 %and55.i.i, 0
  br i1 %tobool56.i.not.i, label %if.end72.i.i, label %if.then57.i.i

if.then57.i.i:                                    ; preds = %if.end54.i.i
  %cmp60.i.i = icmp ne i8 %pc.sroa.0.0.i, 3
  %cmp68.i.not.i = icmp eq i8 %spec.select.i, %spec.select195.i
  %or.cond.i = or i1 %cmp68.i.not.i, %cmp60.i.i
  br i1 %or.cond.i, label %return_inf.i.i, label %d_nan.i.i

if.end72.i.i:                                     ; preds = %if.end54.i.i
  %and73.i.i = and i32 %or.i.i, 2
  %tobool74.i.not.i = icmp eq i32 %and73.i.i, 0
  br i1 %tobool74.i.not.i, label %if.else.i.i, label %if.then75.i.i

if.then75.i.i:                                    ; preds = %if.end72.i.i
  switch i8 %pc.sroa.0.0.i, label %if.else105.i.i [
    i8 2, label %if.then81.i.i
    i8 1, label %if.then87.i.i
    i8 3, label %if.then119.i.i
  ]

if.else.i.i:                                      ; preds = %if.end72.i.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 522, ptr noundef nonnull @__func__.parts64_muladd, ptr noundef nonnull @.str.7) #16
  unreachable

if.then81.i.i:                                    ; preds = %if.then75.i.i
  store i8 2, ptr %pa.i, align 8
  store i8 %spec.select195.i, ptr %pa.sroa.gep183.i, align 1
  store i32 %pc.sroa.20172.0.i, ptr %pa.sroa.gep188.i, align 4
  store i64 %pc.sroa.25.0.i, ptr %pa.sroa.gep193.i, align 8
  br label %return_normal.i.i

if.then87.i.i:                                    ; preds = %if.then75.i.i
  %cmp94.i.not.i = icmp eq i8 %spec.select.i, %spec.select195.i
  br i1 %cmp94.i.not.i, label %return_zero.i.i, label %return_sub_zero.i.i

if.else105.i.i:                                   ; preds = %if.then75.i.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 533, ptr noundef nonnull @__func__.parts64_muladd, ptr noundef nonnull @.str.12) #16
  unreachable

if.end108.i.i:                                    ; preds = %if.end.i.i
  %cmp111.i.i = icmp eq i8 %pc.sroa.0.0.i, 3
  br i1 %cmp111.i.i, label %if.then119.i.i, label %if.end124.i.i

if.then119.i.i:                                   ; preds = %if.end108.i.i, %if.then75.i.i
  store i8 %spec.select195.i, ptr %pa.sroa.gep183.i, align 1
  br label %return_inf.i.i

if.end124.i.i:                                    ; preds = %if.end108.i.i
  %sign127.i.i = getelementptr inbounds i8, ptr %p_widen.i.i, i64 1
  store i8 %spec.select.i, ptr %sign127.i.i, align 1
  %add.i.i = add nsw i32 %pb.sroa.10.0.i, %31
  %add130.i.i = add nsw i32 %add.i.i, 1
  %exp131.i.i = getelementptr inbounds i8, ptr %p_widen.i.i, i64 4
  store i32 %add130.i.i, ptr %exp131.i.i, align 4
  %frac_lo.i.i = getelementptr inbounds i8, ptr %p_widen.i.i, i64 16
  %frac_hi.i154.i = getelementptr inbounds i8, ptr %p_widen.i.i, i64 8
  %conv.i.i155.i = zext i64 %pa.val.i to i128
  %conv1.i.i.i = zext i64 %pb.sroa.15.0.i to i128
  %mul.i.i.i = mul nuw i128 %conv1.i.i.i, %conv.i.i155.i
  %conv2.i.i.i = trunc i128 %mul.i.i.i to i64
  store i64 %conv2.i.i.i, ptr %frac_lo.i.i, align 8
  %shr.i.i.i = lshr i128 %mul.i.i.i, 64
  %conv3.i.i.i = trunc i128 %shr.i.i.i to i64
  store i64 %conv3.i.i.i, ptr %frac_hi.i154.i, align 8
  %tobool133.i.not.i = icmp sgt i128 %mul.i.i.i, -1
  br i1 %tobool133.i.not.i, label %if.then134.i.i, label %if.end137.i.i

if.then134.i.i:                                   ; preds = %if.end124.i.i
  %53 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i.i, i64 %conv2.i.i.i)
  %54 = extractvalue { i64, i1 } %53, 1
  %55 = extractvalue { i64, i1 } %53, 0
  store i64 %55, ptr %frac_lo.i.i, align 8
  %conv.i4.i.i = zext i1 %54 to i64
  %56 = shl nuw i64 %conv3.i.i.i, 1
  %57 = or disjoint i64 %56, %conv.i4.i.i
  store i64 %57, ptr %frac_hi.i154.i, align 8
  store i32 %add.i.i, ptr %exp131.i.i, align 4
  br label %if.end137.i.i

if.end137.i.i:                                    ; preds = %if.then134.i.i, %if.end124.i.i
  %cmp140.i.not.i = icmp eq i8 %pc.sroa.0.0.i, 1
  br i1 %cmp140.i.not.i, label %if.end159.i.i, label %if.then142.i.i

if.then142.i.i:                                   ; preds = %if.end137.i.i
  %frac_hi.i158.i = getelementptr inbounds i8, ptr %c_widen.i.i, i64 8
  store i64 %pc.sroa.25.0.i, ptr %frac_hi.i158.i, align 8
  %frac_lo.i159.i = getelementptr inbounds i8, ptr %c_widen.i.i, i64 16
  store i64 0, ptr %frac_lo.i159.i, align 8
  %exp144.i.i = getelementptr inbounds i8, ptr %c_widen.i.i, i64 4
  store i32 %pc.sroa.20172.0.i, ptr %exp144.i.i, align 4
  %cmp151.i.i = icmp eq i8 %spec.select.i, %spec.select195.i
  br i1 %cmp151.i.i, label %if.then153.i.i, label %if.else154.i.i

if.then153.i.i:                                   ; preds = %if.then142.i.i
  call fastcc void @parts128_add_normal(ptr noundef nonnull %p_widen.i.i, ptr noundef nonnull %c_widen.i.i)
  br label %if.end159.i.i

if.else154.i.i:                                   ; preds = %if.then142.i.i
  %call155.i.i = call fastcc zeroext i1 @parts128_sub_normal(ptr noundef nonnull %p_widen.i.i, ptr noundef nonnull %c_widen.i.i)
  br i1 %call155.i.i, label %if.end159.i.i, label %return_sub_zero.i.i

if.end159.i.i:                                    ; preds = %if.else154.i.i, %if.then153.i.i, %if.end137.i.i
  %p_widen.i.val.i = load i64, ptr %frac_hi.i154.i, align 8
  %p_widen.i.val64.i = load i64, ptr %frac_lo.i.i, align 8
  %cmp.i160.i = icmp ne i64 %p_widen.i.val64.i, 0
  %conv1.i.i = zext i1 %cmp.i160.i to i64
  %or.i161.i = or i64 %p_widen.i.val.i, %conv1.i.i
  store i64 %or.i161.i, ptr %pa.sroa.gep193.i, align 8
  %58 = load i8, ptr %sign127.i.i, align 1
  %59 = and i8 %58, 1
  store i8 %59, ptr %pa.sroa.gep183.i, align 1
  %60 = load i32, ptr %exp131.i.i, align 4
  store i32 %60, ptr %pa.sroa.gep188.i, align 4
  br label %return_normal.i.i

return_normal.i.i:                                ; preds = %if.end159.i.i, %if.then81.i.i
  %61 = phi i8 [ %59, %if.end159.i.i ], [ %spec.select195.i, %if.then81.i.i ]
  %62 = phi i32 [ %60, %if.end159.i.i ], [ %pc.sroa.20172.0.i, %if.then81.i.i ]
  %and166.i.i = and i32 %flags, 8
  %tobool167.i.not.i = icmp eq i32 %and166.i.i, 0
  br i1 %tobool167.i.not.i, label %finish_sign.i.i, label %if.then168.i.i

if.then168.i.i:                                   ; preds = %return_normal.i.i
  %sub170.i.i = add i32 %62, -1
  store i32 %sub170.i.i, ptr %pa.sroa.gep188.i, align 4
  br label %finish_sign.i.i

finish_sign.i.i:                                  ; preds = %return_inf.i.i, %return_zero.i.i, %if.then168.i.i, %return_normal.i.i
  %63 = phi i8 [ %61, %return_normal.i.i ], [ %61, %if.then168.i.i ], [ %66, %return_inf.i.i ], [ %65, %return_zero.i.i ]
  %and172.i.i = and i32 %flags, 4
  %tobool173.i.not.i = icmp eq i32 %and172.i.i, 0
  br i1 %tobool173.i.not.i, label %soft_f64_muladd.exit, label %if.then174.i.i

if.then174.i.i:                                   ; preds = %finish_sign.i.i
  %frombool180.i.i = xor i8 %63, 1
  store i8 %frombool180.i.i, ptr %pa.sroa.gep183.i, align 1
  br label %soft_f64_muladd.exit

return_sub_zero.i.i:                              ; preds = %if.else154.i.i, %if.then87.i.i
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %s, i64 2
  %64 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp183.i.i = icmp eq i8 %64, 1
  %frombool186.i.i = zext i1 %cmp183.i.i to i8
  store i8 %frombool186.i.i, ptr %pa.sroa.gep183.i, align 1
  br label %return_zero.i.i

return_zero.i.i:                                  ; preds = %return_sub_zero.i.i, %if.then87.i.i
  %65 = phi i8 [ %spec.select195.i, %if.then87.i.i ], [ %frombool186.i.i, %return_sub_zero.i.i ]
  store i8 1, ptr %pa.i, align 8
  br label %finish_sign.i.i

return_inf.i.i:                                   ; preds = %if.then119.i.i, %if.then57.i.i
  %66 = phi i8 [ %spec.select.i, %if.then57.i.i ], [ %spec.select195.i, %if.then119.i.i ]
  store i8 3, ptr %pa.i, align 8
  br label %finish_sign.i.i

d_nan.i.i:                                        ; preds = %if.then57.i.i, %if.end.i.i
  %.sink198.i = phi i16 [ 257, %if.end.i.i ], [ 129, %if.then57.i.i ]
  %or1.i153.i = or i16 %42, %.sink198.i
  store i16 %or1.i153.i, ptr %s, align 2
  store i8 4, ptr %pa.i, align 8
  store i8 0, ptr %pa.sroa.gep183.i, align 1
  store i32 2147483647, ptr %pa.sroa.gep188.i, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep193.i, align 8
  br label %soft_f64_muladd.exit

soft_f64_muladd.exit:                             ; preds = %46, %finish_sign.i.i, %if.then174.i.i, %d_nan.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %pa.i, ptr noundef nonnull %s, ptr noundef nonnull @float64_params)
  %67 = load i8, ptr %pa.sroa.gep183.i, align 1
  %68 = and i8 %67, 1
  %conv.i.i162.i = zext nneg i8 %68 to i64
  %shl.i.i163.i = shl nuw i64 %conv.i.i162.i, 63
  %69 = load i32, ptr %pa.sroa.gep188.i, align 4
  %70 = and i32 %69, 2047
  %shl77.i.i.i = zext nneg i32 %70 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i163.i
  %71 = load i64, ptr %pa.sroa.gep193.i, align 8
  %shl77.i9.i.i = and i64 %71, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %p_widen.i.i)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %c_widen.i.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %pa.i)
  br label %return

return:                                           ; preds = %soft_f64_muladd.exit, %if.end97, %if.then95
  %retval.0 = phi i64 [ %or.i10.i.i, %soft_f64_muladd.exit ], [ %xor.i, %if.then95 ], [ %ur.sroa.0.0, %if.end97 ]
  ret i64 %retval.0
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fma.f64(double, double, double) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fabs.f64(double) #4

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64r32_muladd(i64 noundef %a, i64 noundef %b, i64 noundef %c, i32 noundef %flags, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pb = alloca %struct.FloatParts64, align 8
  %pc = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float64_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

float64_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %f.lobit.i.i5 = lshr i64 %b, 63
  %frombool.i.i.i6 = trunc i64 %f.lobit.i.i5 to i8
  %shr.i8.i.i7 = lshr i64 %b, 52
  %5 = trunc i64 %shr.i8.i.i7 to i32
  %conv.i.i.i8 = and i32 %5, 2047
  %and.i9.i.i9 = and i64 %b, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i6, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i10, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i11 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i.i8, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i11, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i12 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i9.i.i9, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i12, align 8
  switch i32 %conv.i.i.i8, label %if.then33.i.i32 [
    i32 0, label %if.then.i.i20
    i32 2047, label %lor.lhs.false.i.i13
  ]

if.then.i.i20:                                    ; preds = %float64_unpack_canonical.exit
  %cmp.i.i.i21 = icmp eq i64 %and.i9.i.i9, 0
  br i1 %cmp.i.i.i21, label %if.then8.i.i31, label %if.else.i.i22

if.then8.i.i31:                                   ; preds = %if.then.i.i20
  store i8 1, ptr %pb, align 8
  br label %float64_unpack_canonical.exit36

if.else.i.i22:                                    ; preds = %if.then.i.i20
  %flush_inputs_to_zero.i.i23 = getelementptr inbounds i8, ptr %status, i64 6
  %6 = load i8, ptr %flush_inputs_to_zero.i.i23, align 2
  %7 = and i8 %6, 1
  %tobool9.not.i.i24 = icmp eq i8 %7, 0
  br i1 %tobool9.not.i.i24, label %frac64_normalize.exit.i.i27, label %if.then10.i.i25

if.then10.i.i25:                                  ; preds = %if.else.i.i22
  %8 = load i16, ptr %status, align 2
  %or1.i.i.i26 = or i16 %8, 32
  store i16 %or1.i.i.i26, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i12, align 8
  br label %float64_unpack_canonical.exit36

frac64_normalize.exit.i.i27:                      ; preds = %if.else.i.i22
  %9 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i9, i1 true), !range !5
  %cast.i.i.i.i28 = trunc i64 %9 to i32
  %shl.i.i.i29 = shl i64 %and.i9.i.i9, %9
  store i64 %shl.i.i.i29, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i12, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i30 = sub nuw nsw i32 -1011, %cast.i.i.i.i28
  store i32 %add.i.i30, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i11, align 4
  br label %float64_unpack_canonical.exit36

lor.lhs.false.i.i13:                              ; preds = %float64_unpack_canonical.exit
  %cmp.i29.i.i14 = icmp eq i64 %and.i9.i.i9, 0
  br i1 %cmp.i29.i.i14, label %if.then47.i.i19, label %if.else49.i.i15

if.then33.i.i32:                                  ; preds = %float64_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i33 = add nsw i32 %conv.i.i.i8, -1023
  store i32 %sub37.i.i33, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i11, align 4
  %shl.i28.i.i34 = shl nuw nsw i64 %and.i9.i.i9, 11
  %or.i.i35 = or disjoint i64 %shl.i28.i.i34, -9223372036854775808
  store i64 %or.i.i35, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i12, align 8
  br label %float64_unpack_canonical.exit36

if.then47.i.i19:                                  ; preds = %lor.lhs.false.i.i13
  store i8 3, ptr %pb, align 8
  br label %float64_unpack_canonical.exit36

if.else49.i.i15:                                  ; preds = %lor.lhs.false.i.i13
  %shl.i31.i.i16 = shl nuw nsw i64 %and.i9.i.i9, 11
  store i64 %shl.i31.i.i16, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i12, align 8
  %tobool.not.i32.i.i17 = icmp ult i64 %and.i9.i.i9, 2251799813685248
  %conv53.i.i18 = select i1 %tobool.not.i32.i.i17, i8 5, i8 4
  store i8 %conv53.i.i18, ptr %pb, align 8
  br label %float64_unpack_canonical.exit36

float64_unpack_canonical.exit36:                  ; preds = %if.then8.i.i31, %if.then10.i.i25, %frac64_normalize.exit.i.i27, %if.then33.i.i32, %if.then47.i.i19, %if.else49.i.i15
  %f.lobit.i.i37 = lshr i64 %c, 63
  %frombool.i.i.i38 = trunc i64 %f.lobit.i.i37 to i8
  %shr.i8.i.i39 = lshr i64 %c, 52
  %10 = trunc i64 %shr.i8.i.i39 to i32
  %conv.i.i.i40 = and i32 %10, 2047
  %and.i9.i.i41 = and i64 %c, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i42 = getelementptr inbounds i8, ptr %pc, i64 1
  store i8 %frombool.i.i.i38, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i42, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i43 = getelementptr inbounds i8, ptr %pc, i64 4
  store i32 %conv.i.i.i40, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i43, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i44 = getelementptr inbounds i8, ptr %pc, i64 8
  store i64 %and.i9.i.i41, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i44, align 8
  switch i32 %conv.i.i.i40, label %if.then33.i.i64 [
    i32 0, label %if.then.i.i52
    i32 2047, label %lor.lhs.false.i.i45
  ]

if.then.i.i52:                                    ; preds = %float64_unpack_canonical.exit36
  %cmp.i.i.i53 = icmp eq i64 %and.i9.i.i41, 0
  br i1 %cmp.i.i.i53, label %if.then8.i.i63, label %if.else.i.i54

if.then8.i.i63:                                   ; preds = %if.then.i.i52
  store i8 1, ptr %pc, align 8
  br label %float64_unpack_canonical.exit68

if.else.i.i54:                                    ; preds = %if.then.i.i52
  %flush_inputs_to_zero.i.i55 = getelementptr inbounds i8, ptr %status, i64 6
  %11 = load i8, ptr %flush_inputs_to_zero.i.i55, align 2
  %12 = and i8 %11, 1
  %tobool9.not.i.i56 = icmp eq i8 %12, 0
  br i1 %tobool9.not.i.i56, label %frac64_normalize.exit.i.i59, label %if.then10.i.i57

if.then10.i.i57:                                  ; preds = %if.else.i.i54
  %13 = load i16, ptr %status, align 2
  %or1.i.i.i58 = or i16 %13, 32
  store i16 %or1.i.i.i58, ptr %status, align 2
  store i8 1, ptr %pc, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i44, align 8
  br label %float64_unpack_canonical.exit68

frac64_normalize.exit.i.i59:                      ; preds = %if.else.i.i54
  %14 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i41, i1 true), !range !5
  %cast.i.i.i.i60 = trunc i64 %14 to i32
  %shl.i.i.i61 = shl i64 %and.i9.i.i41, %14
  store i64 %shl.i.i.i61, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i44, align 8
  store i8 2, ptr %pc, align 8
  %add.i.i62 = sub nuw nsw i32 -1011, %cast.i.i.i.i60
  store i32 %add.i.i62, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i43, align 4
  br label %float64_unpack_canonical.exit68

lor.lhs.false.i.i45:                              ; preds = %float64_unpack_canonical.exit36
  %cmp.i29.i.i46 = icmp eq i64 %and.i9.i.i41, 0
  br i1 %cmp.i29.i.i46, label %if.then47.i.i51, label %if.else49.i.i47

if.then33.i.i64:                                  ; preds = %float64_unpack_canonical.exit36
  store i8 2, ptr %pc, align 8
  %sub37.i.i65 = add nsw i32 %conv.i.i.i40, -1023
  store i32 %sub37.i.i65, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i43, align 4
  %shl.i28.i.i66 = shl nuw nsw i64 %and.i9.i.i41, 11
  %or.i.i67 = or disjoint i64 %shl.i28.i.i66, -9223372036854775808
  store i64 %or.i.i67, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i44, align 8
  br label %float64_unpack_canonical.exit68

if.then47.i.i51:                                  ; preds = %lor.lhs.false.i.i45
  store i8 3, ptr %pc, align 8
  br label %float64_unpack_canonical.exit68

if.else49.i.i47:                                  ; preds = %lor.lhs.false.i.i45
  %shl.i31.i.i48 = shl nuw nsw i64 %and.i9.i.i41, 11
  store i64 %shl.i31.i.i48, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i44, align 8
  %tobool.not.i32.i.i49 = icmp ult i64 %and.i9.i.i41, 2251799813685248
  %conv53.i.i50 = select i1 %tobool.not.i32.i.i49, i8 5, i8 4
  store i8 %conv53.i.i50, ptr %pc, align 8
  br label %float64_unpack_canonical.exit68

float64_unpack_canonical.exit68:                  ; preds = %if.then8.i.i63, %if.then10.i.i57, %frac64_normalize.exit.i.i59, %if.then33.i.i64, %if.then47.i.i51, %if.else49.i.i47
  %call = call fastcc ptr @parts64_muladd(ptr noundef nonnull %pa, ptr noundef nonnull %pb, ptr noundef nonnull %pc, i32 noundef %flags, ptr noundef %status)
  %call1 = call fastcc i64 @float64r32_round_pack_canonical(ptr noundef nonnull %pa, ptr noundef %status)
  ret i64 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_muladd(i16 noundef zeroext %a, i16 noundef zeroext %b, i16 noundef zeroext %c, i32 noundef %flags, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p_widen.i = alloca %struct.FloatParts128, align 8
  %c_widen.i = alloca %struct.FloatParts128, align 8
  %pa = alloca %struct.FloatParts64, align 8
  %pa.sroa.gep192 = getelementptr inbounds i8, ptr %pa, i64 8
  %pa.sroa.gep187 = getelementptr inbounds i8, ptr %pa, i64 4
  %pa.sroa.gep182 = getelementptr inbounds i8, ptr %pa, i64 1
  %0 = lshr i16 %a, 7
  %1 = and i16 %0, 255
  %conv.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 127
  %and.i10.i = zext nneg i16 %2 to i64
  store i32 %conv.i.i, ptr %pa.sroa.gep187, align 4
  store i64 %and.i10.i, ptr %pa.sroa.gep192, align 8
  %trunc = trunc i16 %0 to i8
  switch i8 %trunc, label %if.then33.i [
    i8 0, label %if.then.i67
    i8 -1, label %lor.lhs.false.i
  ]

if.then.i67:                                      ; preds = %entry
  %cmp.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i, label %if.then8.i, label %if.else.i68

if.then8.i:                                       ; preds = %if.then.i67
  store i8 1, ptr %pa, align 8
  br label %parts64_canonicalize.exit

if.else.i68:                                      ; preds = %if.then.i67
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i, label %frac64_normalize.exit.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.else.i68
  %5 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %5, 32
  store i16 %or1.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %pa.sroa.gep192, align 8
  br label %parts64_canonicalize.exit

frac64_normalize.exit.i:                          ; preds = %if.else.i68
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i, i1 true), !range !5
  %cast.i.i.i = trunc i64 %6 to i32
  %shl.i.i = shl i64 %and.i10.i, %6
  store i64 %shl.i.i, ptr %pa.sroa.gep192, align 8
  store i8 2, ptr %pa, align 8
  %add.i69 = sub nuw nsw i32 -70, %cast.i.i.i
  store i32 %add.i69, ptr %pa.sroa.gep187, align 4
  br label %parts64_canonicalize.exit

lor.lhs.false.i:                                  ; preds = %entry
  %cmp.i29.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i, label %if.then47.i, label %if.else49.i

if.then33.i:                                      ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i = add nsw i32 %conv.i.i, -127
  store i32 %sub37.i, ptr %pa.sroa.gep187, align 4
  %shl.i28.i = shl nuw nsw i64 %and.i10.i, 56
  %or.i66 = or disjoint i64 %shl.i28.i, -9223372036854775808
  store i64 %or.i66, ptr %pa.sroa.gep192, align 8
  br label %parts64_canonicalize.exit

if.then47.i:                                      ; preds = %lor.lhs.false.i
  store i8 3, ptr %pa, align 8
  br label %parts64_canonicalize.exit

if.else49.i:                                      ; preds = %lor.lhs.false.i
  %shl.i31.i = shl nuw nsw i64 %and.i10.i, 56
  store i64 %shl.i31.i, ptr %pa.sroa.gep192, align 8
  %tobool.not.i32.i = icmp ult i16 %2, 64
  %conv53.i = select i1 %tobool.not.i32.i, i8 5, i8 4
  store i8 %conv53.i, ptr %pa, align 8
  br label %parts64_canonicalize.exit

parts64_canonicalize.exit:                        ; preds = %if.then8.i, %if.then10.i, %frac64_normalize.exit.i, %if.then33.i, %if.then47.i, %if.else49.i
  %pa.val = phi i64 [ 0, %if.then8.i ], [ 0, %if.then10.i ], [ %shl.i.i, %frac64_normalize.exit.i ], [ %or.i66, %if.then33.i ], [ 0, %if.then47.i ], [ %shl.i31.i, %if.else49.i ]
  %7 = phi i32 [ %conv.i.i, %if.then8.i ], [ %conv.i.i, %if.then10.i ], [ %add.i69, %frac64_normalize.exit.i ], [ %sub37.i, %if.then33.i ], [ %conv.i.i, %if.then47.i ], [ %conv.i.i, %if.else49.i ]
  %8 = phi i8 [ 1, %if.then8.i ], [ 1, %if.then10.i ], [ 2, %frac64_normalize.exit.i ], [ 2, %if.then33.i ], [ 3, %if.then47.i ], [ %conv53.i, %if.else49.i ]
  %9 = lshr i16 %b, 7
  %10 = and i16 %b, 127
  %and.i10.i73 = zext nneg i16 %10 to i64
  %trunc196 = trunc i16 %9 to i8
  switch i8 %trunc196, label %if.then33.i89 [
    i8 0, label %if.then.i93
    i8 -1, label %lor.lhs.false.i81
  ]

if.then.i93:                                      ; preds = %parts64_canonicalize.exit
  %cmp.i.i95 = icmp eq i16 %10, 0
  br i1 %cmp.i.i95, label %parts64_canonicalize.exit107, label %if.else.i96

if.else.i96:                                      ; preds = %if.then.i93
  %flush_inputs_to_zero.i97 = getelementptr inbounds i8, ptr %status, i64 6
  %11 = load i8, ptr %flush_inputs_to_zero.i97, align 2
  %12 = and i8 %11, 1
  %tobool9.not.i98 = icmp eq i8 %12, 0
  br i1 %tobool9.not.i98, label %frac64_normalize.exit.i101, label %if.then10.i99

if.then10.i99:                                    ; preds = %if.else.i96
  %13 = load i16, ptr %status, align 2
  %or1.i.i100 = or i16 %13, 32
  store i16 %or1.i.i100, ptr %status, align 2
  br label %parts64_canonicalize.exit107

frac64_normalize.exit.i101:                       ; preds = %if.else.i96
  %14 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i73, i1 true), !range !5
  %cast.i.i.i102 = trunc i64 %14 to i32
  %shl.i.i103 = shl i64 %and.i10.i73, %14
  %add.i105 = sub nuw nsw i32 -70, %cast.i.i.i102
  br label %parts64_canonicalize.exit107

lor.lhs.false.i81:                                ; preds = %parts64_canonicalize.exit
  %cmp.i29.i83 = icmp eq i16 %10, 0
  br i1 %cmp.i29.i83, label %parts64_canonicalize.exit107, label %if.else49.i84

if.then33.i89:                                    ; preds = %parts64_canonicalize.exit
  %15 = and i16 %9, 255
  %conv.i.i72 = zext nneg i16 %15 to i32
  %sub37.i90 = add nsw i32 %conv.i.i72, -127
  %shl.i28.i91 = shl nuw nsw i64 %and.i10.i73, 56
  %or.i92 = or disjoint i64 %shl.i28.i91, -9223372036854775808
  br label %parts64_canonicalize.exit107

if.else49.i84:                                    ; preds = %lor.lhs.false.i81
  %shl.i31.i85 = shl nuw nsw i64 %and.i10.i73, 56
  %tobool.not.i32.i86 = icmp ult i16 %10, 64
  %conv53.i87 = select i1 %tobool.not.i32.i86, i32 5, i32 4
  br label %parts64_canonicalize.exit107

parts64_canonicalize.exit107:                     ; preds = %lor.lhs.false.i81, %if.then.i93, %if.then10.i99, %frac64_normalize.exit.i101, %if.then33.i89, %if.else49.i84
  %pb.sroa.10.0 = phi i32 [ %add.i105, %frac64_normalize.exit.i101 ], [ 0, %if.then10.i99 ], [ %sub37.i90, %if.then33.i89 ], [ 255, %if.else49.i84 ], [ 0, %if.then.i93 ], [ 255, %lor.lhs.false.i81 ]
  %pb.sroa.0.0 = phi i32 [ 2, %frac64_normalize.exit.i101 ], [ 1, %if.then10.i99 ], [ 2, %if.then33.i89 ], [ %conv53.i87, %if.else49.i84 ], [ 1, %if.then.i93 ], [ 3, %lor.lhs.false.i81 ]
  %pb.sroa.15.0 = phi i64 [ %shl.i.i103, %frac64_normalize.exit.i101 ], [ 0, %if.then10.i99 ], [ %or.i92, %if.then33.i89 ], [ %shl.i31.i85, %if.else49.i84 ], [ 0, %if.then.i93 ], [ 0, %lor.lhs.false.i81 ]
  %f.lobit.i108 = lshr i16 %c, 15
  %frombool.i.i109 = trunc i16 %f.lobit.i108 to i8
  %16 = lshr i16 %c, 7
  %17 = and i16 %c, 127
  %and.i10.i111 = zext nneg i16 %17 to i64
  %trunc197 = trunc i16 %16 to i8
  switch i8 %trunc197, label %if.then33.i127 [
    i8 0, label %if.then.i131
    i8 -1, label %lor.lhs.false.i119
  ]

if.then.i131:                                     ; preds = %parts64_canonicalize.exit107
  %cmp.i.i133 = icmp eq i16 %17, 0
  br i1 %cmp.i.i133, label %parts64_canonicalize.exit145, label %if.else.i134

if.else.i134:                                     ; preds = %if.then.i131
  %flush_inputs_to_zero.i135 = getelementptr inbounds i8, ptr %status, i64 6
  %18 = load i8, ptr %flush_inputs_to_zero.i135, align 2
  %19 = and i8 %18, 1
  %tobool9.not.i136 = icmp eq i8 %19, 0
  br i1 %tobool9.not.i136, label %frac64_normalize.exit.i139, label %if.then10.i137

if.then10.i137:                                   ; preds = %if.else.i134
  %20 = load i16, ptr %status, align 2
  %or1.i.i138 = or i16 %20, 32
  store i16 %or1.i.i138, ptr %status, align 2
  br label %parts64_canonicalize.exit145

frac64_normalize.exit.i139:                       ; preds = %if.else.i134
  %21 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i111, i1 true), !range !5
  %cast.i.i.i140 = trunc i64 %21 to i32
  %shl.i.i141 = shl i64 %and.i10.i111, %21
  %add.i143 = sub nuw nsw i32 -70, %cast.i.i.i140
  br label %parts64_canonicalize.exit145

lor.lhs.false.i119:                               ; preds = %parts64_canonicalize.exit107
  %cmp.i29.i121 = icmp eq i16 %17, 0
  br i1 %cmp.i29.i121, label %parts64_canonicalize.exit145, label %if.else49.i122

if.then33.i127:                                   ; preds = %parts64_canonicalize.exit107
  %22 = and i16 %16, 255
  %conv.i.i110 = zext nneg i16 %22 to i32
  %sub37.i128 = add nsw i32 %conv.i.i110, -127
  %shl.i28.i129 = shl nuw nsw i64 %and.i10.i111, 56
  %or.i130 = or disjoint i64 %shl.i28.i129, -9223372036854775808
  br label %parts64_canonicalize.exit145

if.else49.i122:                                   ; preds = %lor.lhs.false.i119
  %shl.i31.i123 = shl nuw nsw i64 %and.i10.i111, 56
  %tobool.not.i32.i124 = icmp ult i16 %17, 64
  %conv53.i125 = select i1 %tobool.not.i32.i124, i8 5, i8 4
  br label %parts64_canonicalize.exit145

parts64_canonicalize.exit145:                     ; preds = %lor.lhs.false.i119, %if.then.i131, %if.then10.i137, %frac64_normalize.exit.i139, %if.then33.i127, %if.else49.i122
  %pc.sroa.25.0 = phi i64 [ %shl.i.i141, %frac64_normalize.exit.i139 ], [ 0, %if.then10.i137 ], [ %or.i130, %if.then33.i127 ], [ %shl.i31.i123, %if.else49.i122 ], [ 0, %if.then.i131 ], [ 0, %lor.lhs.false.i119 ]
  %pc.sroa.20171.0 = phi i32 [ %add.i143, %frac64_normalize.exit.i139 ], [ 0, %if.then10.i137 ], [ %sub37.i128, %if.then33.i127 ], [ 255, %if.else49.i122 ], [ 0, %if.then.i131 ], [ 255, %lor.lhs.false.i119 ]
  %pc.sroa.0.0 = phi i8 [ 2, %frac64_normalize.exit.i139 ], [ 1, %if.then10.i137 ], [ 2, %if.then33.i127 ], [ %conv53.i125, %if.else49.i122 ], [ 1, %if.then.i131 ], [ 3, %lor.lhs.false.i119 ]
  %conv.i = zext nneg i8 %8 to i32
  %shl.i = shl nuw nsw i32 1, %conv.i
  %shl3.i = shl nuw nsw i32 1, %pb.sroa.0.0
  %or.i = or i32 %shl.i, %shl3.i
  %conv5.i = zext nneg i8 %pc.sroa.0.0 to i32
  %shl6.i = shl nuw nsw i32 1, %conv5.i
  %or7.i = or i32 %or.i, %shl6.i
  %and.i = and i32 %or7.i, 48
  %tobool.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool.i.not, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %parts64_canonicalize.exit145
  %and.i146 = and i32 %or7.i, 32
  %tobool.not.i = icmp eq i32 %and.i146, 0
  br i1 %tobool.not.i, label %if.end.i149, label %if.then.i147

if.then.i147:                                     ; preds = %if.then.i
  %23 = load i16, ptr %status, align 2
  %or1.i.i148 = or i16 %23, 8193
  store i16 %or1.i.i148, ptr %status, align 2
  br label %if.end.i149

if.end.i149:                                      ; preds = %if.then.i147, %if.then.i
  %cmp.i150 = icmp eq i32 %or.i, 10
  br i1 %cmp.i150, label %if.then.i.i, label %parts64_pick_nan_muladd.exit

if.then.i.i:                                      ; preds = %if.end.i149
  %24 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %24, 257
  store i16 %or1.i.i.i, ptr %status, align 2
  br label %parts64_pick_nan_muladd.exit

parts64_pick_nan_muladd.exit:                     ; preds = %if.end.i149, %if.then.i.i
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %pa.sroa.gep182, align 1
  store i32 2147483647, ptr %pa.sroa.gep187, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep192, align 8
  br label %parts64_muladd.exit

if.end.i:                                         ; preds = %parts64_canonicalize.exit145
  %25 = trunc i32 %flags to i8
  %26 = and i8 %25, 1
  %spec.select194 = xor i8 %26, %frombool.i.i109
  %f.lobit.i195 = xor i16 %b, %a
  %27 = lshr i16 %f.lobit.i195, 15
  %28 = trunc i16 %27 to i8
  %29 = lshr i8 %25, 1
  %30 = and i8 %29, 1
  %spec.select = xor i8 %30, %28
  store i8 %spec.select, ptr %pa.sroa.gep182, align 1
  %trunc199 = trunc i32 %or.i to i8
  switch i8 %trunc199, label %if.end54.i [
    i8 4, label %if.end108.i
    i8 10, label %d_nan.i
  ]

if.end54.i:                                       ; preds = %if.end.i
  %and55.i = and i32 %or.i, 8
  %tobool56.i.not = icmp eq i32 %and55.i, 0
  br i1 %tobool56.i.not, label %if.end72.i, label %if.then57.i

if.then57.i:                                      ; preds = %if.end54.i
  %cmp60.i = icmp ne i8 %pc.sroa.0.0, 3
  %cmp68.i.not = icmp eq i8 %spec.select, %spec.select194
  %or.cond = or i1 %cmp68.i.not, %cmp60.i
  br i1 %or.cond, label %return_inf.i, label %d_nan.i

if.end72.i:                                       ; preds = %if.end54.i
  %and73.i = and i32 %or.i, 2
  %tobool74.i.not = icmp eq i32 %and73.i, 0
  br i1 %tobool74.i.not, label %if.else.i, label %if.then75.i

if.then75.i:                                      ; preds = %if.end72.i
  switch i8 %pc.sroa.0.0, label %if.else105.i [
    i8 2, label %if.then81.i
    i8 1, label %if.then87.i
    i8 3, label %if.then119.i
  ]

if.else.i:                                        ; preds = %if.end72.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 522, ptr noundef nonnull @__func__.parts64_muladd, ptr noundef nonnull @.str.7) #16
  unreachable

if.then81.i:                                      ; preds = %if.then75.i
  store i8 2, ptr %pa, align 8
  store i8 %spec.select194, ptr %pa.sroa.gep182, align 1
  store i32 %pc.sroa.20171.0, ptr %pa.sroa.gep187, align 4
  store i64 %pc.sroa.25.0, ptr %pa.sroa.gep192, align 8
  br label %return_normal.i

if.then87.i:                                      ; preds = %if.then75.i
  %cmp94.i.not = icmp eq i8 %spec.select, %spec.select194
  br i1 %cmp94.i.not, label %return_zero.i, label %return_sub_zero.i

if.else105.i:                                     ; preds = %if.then75.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 533, ptr noundef nonnull @__func__.parts64_muladd, ptr noundef nonnull @.str.12) #16
  unreachable

if.end108.i:                                      ; preds = %if.end.i
  %cmp111.i = icmp eq i8 %pc.sroa.0.0, 3
  br i1 %cmp111.i, label %if.then119.i, label %if.end124.i

if.then119.i:                                     ; preds = %if.then75.i, %if.end108.i
  store i8 %spec.select194, ptr %pa.sroa.gep182, align 1
  br label %return_inf.i

if.end124.i:                                      ; preds = %if.end108.i
  %sign127.i = getelementptr inbounds i8, ptr %p_widen.i, i64 1
  store i8 %spec.select, ptr %sign127.i, align 1
  %add.i = add nsw i32 %7, %pb.sroa.10.0
  %add130.i = add nsw i32 %add.i, 1
  %exp131.i = getelementptr inbounds i8, ptr %p_widen.i, i64 4
  store i32 %add130.i, ptr %exp131.i, align 4
  %frac_lo.i = getelementptr inbounds i8, ptr %p_widen.i, i64 16
  %frac_hi.i152 = getelementptr inbounds i8, ptr %p_widen.i, i64 8
  %conv.i.i153 = zext i64 %pa.val to i128
  %conv1.i.i = zext i64 %pb.sroa.15.0 to i128
  %mul.i.i = mul nuw i128 %conv.i.i153, %conv1.i.i
  %conv2.i.i = trunc i128 %mul.i.i to i64
  store i64 %conv2.i.i, ptr %frac_lo.i, align 8
  %shr.i.i = lshr i128 %mul.i.i, 64
  %conv3.i.i = trunc i128 %shr.i.i to i64
  store i64 %conv3.i.i, ptr %frac_hi.i152, align 8
  %tobool133.i.not = icmp sgt i128 %mul.i.i, -1
  br i1 %tobool133.i.not, label %if.then134.i, label %if.end137.i

if.then134.i:                                     ; preds = %if.end124.i
  %31 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i, i64 %conv2.i.i)
  %32 = extractvalue { i64, i1 } %31, 1
  %33 = extractvalue { i64, i1 } %31, 0
  store i64 %33, ptr %frac_lo.i, align 8
  %conv.i4.i = zext i1 %32 to i64
  %34 = shl nuw i64 %conv3.i.i, 1
  %35 = or disjoint i64 %34, %conv.i4.i
  store i64 %35, ptr %frac_hi.i152, align 8
  store i32 %add.i, ptr %exp131.i, align 4
  br label %if.end137.i

if.end137.i:                                      ; preds = %if.then134.i, %if.end124.i
  %cmp140.i.not = icmp eq i8 %pc.sroa.0.0, 1
  br i1 %cmp140.i.not, label %if.end159.i, label %if.then142.i

if.then142.i:                                     ; preds = %if.end137.i
  %frac_hi.i156 = getelementptr inbounds i8, ptr %c_widen.i, i64 8
  store i64 %pc.sroa.25.0, ptr %frac_hi.i156, align 8
  %frac_lo.i157 = getelementptr inbounds i8, ptr %c_widen.i, i64 16
  store i64 0, ptr %frac_lo.i157, align 8
  %exp144.i = getelementptr inbounds i8, ptr %c_widen.i, i64 4
  store i32 %pc.sroa.20171.0, ptr %exp144.i, align 4
  %cmp151.i = icmp eq i8 %spec.select, %spec.select194
  br i1 %cmp151.i, label %if.then153.i, label %if.else154.i

if.then153.i:                                     ; preds = %if.then142.i
  call fastcc void @parts128_add_normal(ptr noundef nonnull %p_widen.i, ptr noundef nonnull %c_widen.i)
  br label %if.end159.i

if.else154.i:                                     ; preds = %if.then142.i
  %call155.i = call fastcc zeroext i1 @parts128_sub_normal(ptr noundef nonnull %p_widen.i, ptr noundef nonnull %c_widen.i)
  br i1 %call155.i, label %if.end159.i, label %return_sub_zero.i

if.end159.i:                                      ; preds = %if.then153.i, %if.else154.i, %if.end137.i
  %p_widen.i.val = load i64, ptr %frac_hi.i152, align 8
  %p_widen.i.val64 = load i64, ptr %frac_lo.i, align 8
  %cmp.i158 = icmp ne i64 %p_widen.i.val64, 0
  %conv1.i = zext i1 %cmp.i158 to i64
  %or.i159 = or i64 %p_widen.i.val, %conv1.i
  store i64 %or.i159, ptr %pa.sroa.gep192, align 8
  %36 = load i8, ptr %sign127.i, align 1
  %37 = and i8 %36, 1
  store i8 %37, ptr %pa.sroa.gep182, align 1
  %38 = load i32, ptr %exp131.i, align 4
  store i32 %38, ptr %pa.sroa.gep187, align 4
  br label %return_normal.i

return_normal.i:                                  ; preds = %if.end159.i, %if.then81.i
  %39 = phi i8 [ %37, %if.end159.i ], [ %spec.select194, %if.then81.i ]
  %40 = phi i32 [ %38, %if.end159.i ], [ %pc.sroa.20171.0, %if.then81.i ]
  %and166.i = and i32 %flags, 8
  %tobool167.i.not = icmp eq i32 %and166.i, 0
  br i1 %tobool167.i.not, label %finish_sign.i, label %if.then168.i

if.then168.i:                                     ; preds = %return_normal.i
  %sub170.i = add i32 %40, -1
  store i32 %sub170.i, ptr %pa.sroa.gep187, align 4
  br label %finish_sign.i

finish_sign.i:                                    ; preds = %return_normal.i, %if.then168.i, %return_inf.i, %return_zero.i
  %41 = phi i8 [ %39, %return_normal.i ], [ %39, %if.then168.i ], [ %44, %return_inf.i ], [ %43, %return_zero.i ]
  %and172.i = and i32 %flags, 4
  %tobool173.i.not = icmp eq i32 %and172.i, 0
  br i1 %tobool173.i.not, label %parts64_muladd.exit, label %if.then174.i

if.then174.i:                                     ; preds = %finish_sign.i
  %frombool180.i = xor i8 %41, 1
  store i8 %frombool180.i, ptr %pa.sroa.gep182, align 1
  br label %parts64_muladd.exit

return_sub_zero.i:                                ; preds = %if.else154.i, %if.then87.i
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %42 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp183.i = icmp eq i8 %42, 1
  %frombool186.i = zext i1 %cmp183.i to i8
  store i8 %frombool186.i, ptr %pa.sroa.gep182, align 1
  br label %return_zero.i

return_zero.i:                                    ; preds = %if.then87.i, %return_sub_zero.i
  %43 = phi i8 [ %spec.select194, %if.then87.i ], [ %frombool186.i, %return_sub_zero.i ]
  store i8 1, ptr %pa, align 8
  br label %finish_sign.i

return_inf.i:                                     ; preds = %if.then57.i, %if.then119.i
  %44 = phi i8 [ %spec.select, %if.then57.i ], [ %spec.select194, %if.then119.i ]
  store i8 3, ptr %pa, align 8
  br label %finish_sign.i

d_nan.i:                                          ; preds = %if.then57.i, %if.end.i
  %.sink200 = phi i16 [ 257, %if.end.i ], [ 129, %if.then57.i ]
  %45 = load i16, ptr %status, align 2
  %or1.i151 = or i16 %45, %.sink200
  store i16 %or1.i151, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %pa.sroa.gep182, align 1
  store i32 2147483647, ptr %pa.sroa.gep187, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep192, align 8
  br label %parts64_muladd.exit

parts64_muladd.exit:                              ; preds = %finish_sign.i, %if.then174.i, %d_nan.i, %parts64_pick_nan_muladd.exit
  call fastcc void @parts64_uncanon(ptr noundef nonnull %pa, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %46 = load i8, ptr %pa.sroa.gep182, align 1
  %conv.i.i160 = zext i8 %46 to i64
  %shl.i.i161 = shl nuw nsw i64 %conv.i.i160, 15
  %47 = load i32, ptr %pa.sroa.gep187, align 4
  %48 = shl i32 %47, 7
  %49 = and i32 %48, 32640
  %and8.i.i = zext nneg i32 %49 to i64
  %or.i.i = or disjoint i64 %shl.i.i161, %and8.i.i
  %50 = load i64, ptr %pa.sroa.gep192, align 8
  %shl77.i9.i = and i64 %50, 127
  %or.i10.i = or disjoint i64 %or.i.i, %shl77.i9.i
  %conv.i162 = trunc i64 %or.i10.i to i16
  ret i16 %conv.i162
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_muladd(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, i64 %c.coerce0, i64 %c.coerce1, i32 noundef %flags, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p_widen.i = alloca %struct.FloatParts256, align 8
  %c_widen.i = alloca %struct.FloatParts256, align 8
  %pa = alloca %struct.FloatParts128, align 8
  %pb = alloca %struct.FloatParts128, align 8
  %pc = alloca %struct.FloatParts128, align 8
  %shr.i16.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i to i32
  %conv.i68 = and i32 %0, 32767
  %f.coerce1.lobit.i = lshr i64 %a.coerce1, 63
  %frombool.i69 = trunc i64 %f.coerce1.lobit.i to i8
  %and.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %pa, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i69, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i68, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pa, ptr noundef %status, ptr noundef nonnull @float128_params)
  %shr.i16.i70 = lshr i64 %b.coerce1, 48
  %1 = trunc i64 %shr.i16.i70 to i32
  %conv.i71 = and i32 %1, 32767
  %f.coerce1.lobit.i72 = lshr i64 %b.coerce1, 63
  %frombool.i73 = trunc i64 %f.coerce1.lobit.i72 to i8
  %and.i.i74 = and i64 %b.coerce1, 281474976710655
  store i8 0, ptr %pb, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i75 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i73, ptr %.compoundliteral.sroa.2.0..sroa_idx.i75, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i76 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i71, ptr %.compoundliteral.sroa.33.0..sroa_idx.i76, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i77 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i.i74, ptr %.compoundliteral.sroa.4.0..sroa_idx.i77, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i78 = getelementptr inbounds i8, ptr %pb, i64 16
  store i64 %b.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i78, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pb, ptr noundef %status, ptr noundef nonnull @float128_params)
  %shr.i16.i79 = lshr i64 %c.coerce1, 48
  %2 = trunc i64 %shr.i16.i79 to i32
  %conv.i80 = and i32 %2, 32767
  %f.coerce1.lobit.i81 = lshr i64 %c.coerce1, 63
  %frombool.i82 = trunc i64 %f.coerce1.lobit.i81 to i8
  %and.i.i83 = and i64 %c.coerce1, 281474976710655
  store i8 0, ptr %pc, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i84 = getelementptr inbounds i8, ptr %pc, i64 1
  store i8 %frombool.i82, ptr %.compoundliteral.sroa.2.0..sroa_idx.i84, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i85 = getelementptr inbounds i8, ptr %pc, i64 4
  store i32 %conv.i80, ptr %.compoundliteral.sroa.33.0..sroa_idx.i85, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i86 = getelementptr inbounds i8, ptr %pc, i64 8
  store i64 %and.i.i83, ptr %.compoundliteral.sroa.4.0..sroa_idx.i86, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i87 = getelementptr inbounds i8, ptr %pc, i64 16
  store i64 %c.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i87, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pc, ptr noundef %status, ptr noundef nonnull @float128_params)
  %3 = load i8, ptr %pa, align 8
  %conv.i = zext nneg i8 %3 to i32
  %shl.i = shl nuw i32 1, %conv.i
  %4 = load i8, ptr %pb, align 8
  %conv2.i = zext nneg i8 %4 to i32
  %shl3.i = shl nuw i32 1, %conv2.i
  %or.i = or i32 %shl3.i, %shl.i
  %5 = load i8, ptr %pc, align 8
  %conv5.i = zext nneg i8 %5 to i32
  %shl6.i = shl nuw i32 1, %conv5.i
  %or7.i = or i32 %shl6.i, %or.i
  %and.i = and i32 %or7.i, 48
  %tobool.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool.i.not, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %and.i88 = and i32 %or7.i, 32
  %tobool.not.i = icmp eq i32 %and.i88, 0
  br i1 %tobool.not.i, label %if.end.i90, label %if.then.i89

if.then.i89:                                      ; preds = %if.then.i
  %6 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %6, 8193
  store i16 %or1.i.i, ptr %status, align 2
  br label %if.end.i90

if.end.i90:                                       ; preds = %if.then.i89, %if.then.i
  %cmp.i = icmp eq i32 %or.i, 10
  br i1 %cmp.i, label %do.end18.i.sink.split.sink.split, label %do.end18.i.sink.split

if.end.i:                                         ; preds = %entry
  %and11.i = and i32 %flags, 1
  %tobool12.i.not = icmp eq i32 %and11.i, 0
  br i1 %tobool12.i.not, label %if.end17.i, label %if.then13.i

if.then13.i:                                      ; preds = %if.end.i
  %7 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i84, align 1
  %8 = and i8 %7, 1
  %frombool.i = xor i8 %8, 1
  store i8 %frombool.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i84, align 1
  br label %if.end17.i

if.end17.i:                                       ; preds = %if.then13.i, %if.end.i
  %9 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i75, align 1
  %10 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %11 = trunc i32 %flags to i8
  %12 = lshr i8 %11, 1
  %13 = xor i8 %9, %12
  %xor24.i65120 = xor i8 %13, %10
  %spec.select = and i8 %xor24.i65120, 1
  store i8 %spec.select, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  switch i32 %or.i, label %if.end54.i [
    i32 4, label %if.end108.i
    i32 10, label %do.end18.i.sink.split.sink.split
  ]

if.end54.i:                                       ; preds = %if.end17.i
  %and55.i = and i32 %or.i, 8
  %tobool56.i.not = icmp eq i32 %and55.i, 0
  br i1 %tobool56.i.not, label %if.end72.i, label %if.then57.i

if.then57.i:                                      ; preds = %if.end54.i
  %cmp60.i = icmp eq i8 %5, 3
  br i1 %cmp60.i, label %land.lhs.true.i, label %return_inf.i

land.lhs.true.i:                                  ; preds = %if.then57.i
  %14 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i84, align 1
  %15 = xor i8 %14, %xor24.i65120
  %16 = and i8 %15, 1
  %cmp68.i.not = icmp eq i8 %16, 0
  br i1 %cmp68.i.not, label %return_inf.i, label %do.end18.i.sink.split.sink.split

if.end72.i:                                       ; preds = %if.end54.i
  %and73.i = and i32 %or.i, 2
  %tobool74.i.not = icmp eq i32 %and73.i, 0
  br i1 %tobool74.i.not, label %if.else.i, label %if.then75.i

if.then75.i:                                      ; preds = %if.end72.i
  switch i8 %5, label %if.else105.i [
    i8 2, label %if.then81.i
    i8 1, label %if.then87.i
    i8 3, label %if.then119.i
  ]

if.else.i:                                        ; preds = %if.end72.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 522, ptr noundef nonnull @__func__.parts128_muladd, ptr noundef nonnull @.str.7) #16
  unreachable

if.then81.i:                                      ; preds = %if.then75.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %pa, ptr noundef nonnull align 8 dereferenceable(24) %pc, i64 24, i1 false)
  br label %return_normal.i

if.then87.i:                                      ; preds = %if.then75.i
  %17 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i84, align 1
  %18 = xor i8 %17, %xor24.i65120
  %19 = and i8 %18, 1
  %cmp94.i.not = icmp eq i8 %19, 0
  br i1 %cmp94.i.not, label %return_zero.i, label %return_sub_zero.i

if.else105.i:                                     ; preds = %if.then75.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 533, ptr noundef nonnull @__func__.parts128_muladd, ptr noundef nonnull @.str.12) #16
  unreachable

if.end108.i:                                      ; preds = %if.end17.i
  %cmp111.i = icmp eq i8 %5, 3
  br i1 %cmp111.i, label %if.then119.i, label %if.end124.i

if.then119.i:                                     ; preds = %if.then75.i, %if.end108.i
  %20 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i84, align 1
  %21 = and i8 %20, 1
  store i8 %21, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  br label %return_inf.i

if.end124.i:                                      ; preds = %if.end108.i
  %sign127.i = getelementptr inbounds i8, ptr %p_widen.i, i64 1
  store i8 %spec.select, ptr %sign127.i, align 1
  %22 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %23 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i76, align 4
  %add.i = add i32 %23, %22
  %add130.i = add i32 %add.i, 1
  %exp131.i = getelementptr inbounds i8, ptr %p_widen.i, i64 4
  store i32 %add130.i, ptr %exp131.i, align 4
  %pa.val = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %pa.val66 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %pb.val = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i77, align 8
  %pb.val67 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i78, align 8
  %frac_hi3.i = getelementptr inbounds i8, ptr %p_widen.i, i64 8
  %frac_hm.i = getelementptr inbounds i8, ptr %p_widen.i, i64 16
  %frac_lm.i = getelementptr inbounds i8, ptr %p_widen.i, i64 24
  %frac_lo4.i = getelementptr inbounds i8, ptr %p_widen.i, i64 32
  %conv.i.i.i.i = zext i64 %pa.val66 to i128
  %conv1.i.i.i.i = zext i64 %pb.val to i128
  %mul.i.i.i.i = mul nuw i128 %conv1.i.i.i.i, %conv.i.i.i.i
  %conv2.i.i.i.i = trunc i128 %mul.i.i.i.i to i64
  %shr.i.i.i.i = lshr i128 %mul.i.i.i.i, 64
  %conv3.i.i.i.i = trunc i128 %shr.i.i.i.i to i64
  %conv.i.i5.i.i = zext i64 %pa.val to i128
  %conv1.i.i6.i.i = zext i64 %pb.val67 to i128
  %mul.i.i7.i.i = mul nuw i128 %conv1.i.i6.i.i, %conv.i.i5.i.i
  %conv2.i.i8.i.i = trunc i128 %mul.i.i7.i.i to i64
  %shr.i.i9.i.i = lshr i128 %mul.i.i7.i.i, 64
  %conv3.i.i10.i.i = trunc i128 %shr.i.i9.i.i to i64
  %mul.i.i13.i.i = mul nuw i128 %conv1.i.i6.i.i, %conv.i.i.i.i
  %conv2.i.i14.i.i = trunc i128 %mul.i.i13.i.i to i64
  store i64 %conv2.i.i14.i.i, ptr %frac_lo4.i, align 8
  %shr.i.i15.i.i = lshr i128 %mul.i.i13.i.i, 64
  %conv3.i.i16.i.i = trunc i128 %shr.i.i15.i.i to i64
  %mul.i.i19.i.i = mul nuw i128 %conv1.i.i.i.i, %conv.i.i5.i.i
  %conv2.i.i20.i.i = trunc i128 %mul.i.i19.i.i to i64
  %shr.i.i21.i.i = lshr i128 %mul.i.i19.i.i, 64
  %conv3.i.i22.i.i = trunc i128 %shr.i.i21.i.i to i64
  %24 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i.i.i, i64 %conv2.i.i8.i.i)
  %25 = extractvalue { i64, i1 } %24, 1
  %26 = extractvalue { i64, i1 } %24, 0
  %conv.i1.i.i.i = zext i1 %25 to i64
  %27 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv3.i.i.i.i, i64 %conv3.i.i10.i.i)
  %28 = extractvalue { i64, i1 } %27, 1
  %29 = extractvalue { i64, i1 } %27, 0
  %30 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %29, i64 %conv.i1.i.i.i)
  %31 = extractvalue { i64, i1 } %30, 1
  %32 = extractvalue { i64, i1 } %30, 0
  %33 = or i1 %28, %31
  %conv.i3.i.i.i = zext i1 %33 to i64
  %34 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %26, i64 %conv3.i.i16.i.i)
  %35 = extractvalue { i64, i1 } %34, 1
  %36 = extractvalue { i64, i1 } %34, 0
  store i64 %36, ptr %frac_lm.i, align 8
  %conv.i1.i23.i.i = zext i1 %35 to i64
  %37 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %32, i64 %conv2.i.i20.i.i)
  %38 = extractvalue { i64, i1 } %37, 1
  %39 = extractvalue { i64, i1 } %37, 0
  %40 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %39, i64 %conv.i1.i23.i.i)
  %41 = extractvalue { i64, i1 } %40, 1
  %42 = extractvalue { i64, i1 } %40, 0
  %43 = or i1 %38, %41
  store i64 %42, ptr %frac_hm.i, align 8
  %conv.i3.i24.i.i = zext i1 %43 to i64
  %44 = add nuw i64 %conv.i3.i.i.i, %conv3.i.i22.i.i
  %45 = add i64 %44, %conv.i3.i24.i.i
  store i64 %45, ptr %frac_hi3.i, align 8
  %tobool133.i.not = icmp sgt i64 %45, -1
  br i1 %tobool133.i.not, label %if.then134.i, label %if.end137.i

if.then134.i:                                     ; preds = %if.end124.i
  %46 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i14.i.i, i64 %conv2.i.i14.i.i)
  %47 = extractvalue { i64, i1 } %46, 1
  %48 = extractvalue { i64, i1 } %46, 0
  store i64 %48, ptr %frac_lo4.i, align 8
  %conv.i10.i = zext i1 %47 to i64
  %49 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %36, i64 %36)
  %50 = extractvalue { i64, i1 } %49, 1
  %51 = extractvalue { i64, i1 } %49, 0
  %52 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %51, i64 %conv.i10.i)
  %53 = extractvalue { i64, i1 } %52, 1
  %54 = extractvalue { i64, i1 } %52, 0
  %55 = or i1 %50, %53
  store i64 %54, ptr %frac_lm.i, align 8
  %conv.i12.i = zext i1 %55 to i64
  %56 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %42, i64 %42)
  %57 = extractvalue { i64, i1 } %56, 1
  %58 = extractvalue { i64, i1 } %56, 0
  %59 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %58, i64 %conv.i12.i)
  %60 = extractvalue { i64, i1 } %59, 1
  %61 = extractvalue { i64, i1 } %59, 0
  %62 = or i1 %57, %60
  store i64 %61, ptr %frac_hm.i, align 8
  %conv.i14.i = zext i1 %62 to i64
  %63 = shl nuw i64 %45, 1
  %64 = or disjoint i64 %63, %conv.i14.i
  store i64 %64, ptr %frac_hi3.i, align 8
  store i32 %add.i, ptr %exp131.i, align 4
  br label %if.end137.i

if.end137.i:                                      ; preds = %if.then134.i, %if.end124.i
  %cmp140.i.not = icmp eq i8 %5, 1
  br i1 %cmp140.i.not, label %if.end159.i, label %if.then142.i

if.then142.i:                                     ; preds = %if.end137.i
  %frac_hi1.i = getelementptr inbounds i8, ptr %c_widen.i, i64 8
  %65 = load <2 x i64>, ptr %.compoundliteral.sroa.4.0..sroa_idx.i86, align 8
  store <2 x i64> %65, ptr %frac_hi1.i, align 8
  %frac_lm.i98 = getelementptr inbounds i8, ptr %c_widen.i, i64 24
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %frac_lm.i98, i8 0, i64 16, i1 false)
  %66 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i85, align 4
  %exp144.i = getelementptr inbounds i8, ptr %c_widen.i, i64 4
  store i32 %66, ptr %exp144.i, align 4
  %67 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i84, align 1
  %68 = xor i8 %67, %xor24.i65120
  %69 = and i8 %68, 1
  %cmp151.i = icmp eq i8 %69, 0
  br i1 %cmp151.i, label %if.then153.i, label %if.else154.i

if.then153.i:                                     ; preds = %if.then142.i
  call fastcc void @parts256_add_normal(ptr noundef nonnull %p_widen.i, ptr noundef nonnull %c_widen.i)
  br label %if.end159.i

if.else154.i:                                     ; preds = %if.then142.i
  %call155.i = call fastcc zeroext i1 @parts256_sub_normal(ptr noundef nonnull %p_widen.i, ptr noundef nonnull %c_widen.i)
  br i1 %call155.i, label %if.end159.i, label %return_sub_zero.i

if.end159.i:                                      ; preds = %if.then153.i, %if.else154.i, %if.end137.i
  %70 = load i64, ptr %frac_hi3.i, align 8
  store i64 %70, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %71 = load i64, ptr %frac_hm.i, align 8
  %72 = load i64, ptr %frac_lm.i, align 8
  %73 = load i64, ptr %frac_lo4.i, align 8
  %or.i104 = or i64 %73, %72
  %cmp.i105 = icmp ne i64 %or.i104, 0
  %conv2.i106 = zext i1 %cmp.i105 to i64
  %or3.i = or i64 %71, %conv2.i106
  store i64 %or3.i, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %74 = load i8, ptr %sign127.i, align 1
  %75 = and i8 %74, 1
  store i8 %75, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %76 = load i32, ptr %exp131.i, align 4
  store i32 %76, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  br label %return_normal.i

return_normal.i:                                  ; preds = %if.end159.i, %if.then81.i
  %and166.i = and i32 %flags, 8
  %tobool167.i.not = icmp eq i32 %and166.i, 0
  br i1 %tobool167.i.not, label %finish_sign.i, label %if.then168.i

if.then168.i:                                     ; preds = %return_normal.i
  %77 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %sub170.i = add i32 %77, -1
  store i32 %sub170.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  br label %finish_sign.i

finish_sign.i:                                    ; preds = %return_normal.i, %if.then168.i, %return_inf.i, %return_zero.i
  %and172.i = and i32 %flags, 4
  %tobool173.i.not = icmp eq i32 %and172.i, 0
  br i1 %tobool173.i.not, label %parts128_muladd.exit, label %if.then174.i

if.then174.i:                                     ; preds = %finish_sign.i
  %78 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %79 = and i8 %78, 1
  %frombool180.i = xor i8 %79, 1
  store i8 %frombool180.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  br label %parts128_muladd.exit

return_sub_zero.i:                                ; preds = %if.else154.i, %if.then87.i
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %80 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp183.i = icmp eq i8 %80, 1
  %frombool186.i = zext i1 %cmp183.i to i8
  store i8 %frombool186.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  br label %return_zero.i

return_zero.i:                                    ; preds = %if.then87.i, %return_sub_zero.i
  store i8 1, ptr %pa, align 8
  br label %finish_sign.i

return_inf.i:                                     ; preds = %if.then57.i, %land.lhs.true.i, %if.then119.i
  store i8 3, ptr %pa, align 8
  br label %finish_sign.i

parts128_muladd.exit:                             ; preds = %finish_sign.i, %if.then174.i
  %.pr = load i8, ptr %pa, align 8
  switch i8 %.pr, label %do.body21.i [
    i8 2, label %if.then.i112
    i8 1, label %parts128_uncanon.exit
    i8 3, label %do.end.i
    i8 4, label %do.end18.i
    i8 5, label %do.end18.i
  ]

if.then.i112:                                     ; preds = %parts128_muladd.exit
  call fastcc void @parts128_uncanon_normal(ptr noundef nonnull %pa, ptr noundef %status, ptr noundef nonnull @float128_params)
  %.pre = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %.pre121 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %.pre122 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %81 = zext i32 %.pre to i64
  %82 = shl i64 %81, 48
  %83 = and i64 %82, 9223090561878065152
  br label %parts128_uncanon.exit

do.end.i:                                         ; preds = %parts128_muladd.exit
  br label %parts128_uncanon.exit

do.end18.i.sink.split.sink.split:                 ; preds = %if.end17.i, %land.lhs.true.i, %if.end.i90
  %.sink124 = phi i16 [ 257, %if.end.i90 ], [ 257, %if.end17.i ], [ 129, %land.lhs.true.i ]
  %84 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %84, %.sink124
  store i16 %or1.i.i.i, ptr %status, align 2
  br label %do.end18.i.sink.split

do.end18.i.sink.split:                            ; preds = %do.end18.i.sink.split.sink.split, %if.end.i90
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %do.end18.i

do.end18.i:                                       ; preds = %do.end18.i.sink.split, %parts128_muladd.exit, %parts128_muladd.exit
  %85 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %86 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %87 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %85, i32 15, i64 %86) #15, !srcloc !6
  %shr.i.i = lshr i64 %85, 15
  br label %parts128_uncanon.exit

do.body21.i:                                      ; preds = %parts128_muladd.exit
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 330, ptr noundef nonnull @__func__.parts128_uncanon, ptr noundef null) #16
  unreachable

parts128_uncanon.exit:                            ; preds = %parts128_muladd.exit, %if.then.i112, %do.end.i, %do.end18.i
  %88 = phi i64 [ %.pre122, %if.then.i112 ], [ 0, %do.end.i ], [ %87, %do.end18.i ], [ 0, %parts128_muladd.exit ]
  %89 = phi i64 [ %.pre121, %if.then.i112 ], [ 0, %do.end.i ], [ %shr.i.i, %do.end18.i ], [ 0, %parts128_muladd.exit ]
  %conv1.i = phi i64 [ %83, %if.then.i112 ], [ 9223090561878065152, %do.end.i ], [ 9223090561878065152, %do.end18.i ], [ 0, %parts128_muladd.exit ]
  %90 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %91 = and i8 %90, 1
  %conv.i116 = zext nneg i8 %91 to i64
  %shl.i117 = shl nuw i64 %conv.i116, 63
  %or.i25.i = or disjoint i64 %conv1.i, %shl.i117
  %and8.i.i = and i64 %89, 281474976710655
  %or.i.i = or disjoint i64 %or.i25.i, %and8.i.i
  %.fca.0.insert.i = insertvalue { i64, i64 } poison, i64 %88, 0
  %.fca.1.insert.i = insertvalue { i64, i64 } %.fca.0.insert.i, i64 %or.i.i, 1
  ret { i64, i64 } %.fca.1.insert.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_div(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pb = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %conv.i.i.i4 = zext nneg i16 %1 to i32
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i.i4, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i16 %1, label %if.then33.i.i [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float16a_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float16a_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i4, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float16a_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit:                   ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %f.lobit.i.i5 = lshr i16 %b, 15
  %frombool.i.i.i6 = trunc i16 %f.lobit.i.i5 to i8
  %7 = lshr i16 %b, 10
  %8 = and i16 %7, 31
  %conv.i.i.i7 = zext nneg i16 %8 to i32
  %9 = and i16 %b, 1023
  %and.i10.i.i8 = zext nneg i16 %9 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i6, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i.i7, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i10.i.i8, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  switch i16 %8, label %if.then33.i.i22 [
    i16 0, label %if.then.i.i26
    i16 31, label %lor.lhs.false.i.i15
  ]

if.then.i.i26:                                    ; preds = %float16a_unpack_canonical.exit
  %cmp.i.i.i27 = icmp eq i16 %9, 0
  br i1 %cmp.i.i.i27, label %if.then8.i.i38, label %if.else.i.i28

if.then8.i.i38:                                   ; preds = %if.then.i.i26
  store i8 1, ptr %pb, align 8
  br label %float16a_unpack_canonical.exit39

if.else.i.i28:                                    ; preds = %if.then.i.i26
  %flush_inputs_to_zero.i.i29 = getelementptr inbounds i8, ptr %status, i64 6
  %10 = load i8, ptr %flush_inputs_to_zero.i.i29, align 2
  %11 = and i8 %10, 1
  %tobool9.not.i.i30 = icmp eq i8 %11, 0
  br i1 %tobool9.not.i.i30, label %frac64_normalize.exit.i.i33, label %if.then10.i.i31

if.then10.i.i31:                                  ; preds = %if.else.i.i28
  %12 = load i16, ptr %status, align 2
  %or1.i.i.i32 = or i16 %12, 32
  store i16 %or1.i.i.i32, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float16a_unpack_canonical.exit39

frac64_normalize.exit.i.i33:                      ; preds = %if.else.i.i28
  %13 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i8, i1 true), !range !5
  %cast.i.i.i.i34 = trunc i64 %13 to i32
  %shl.i.i.i35 = shl i64 %and.i10.i.i8, %13
  store i64 %shl.i.i.i35, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i37 = sub nsw i32 39, %cast.i.i.i.i34
  store i32 %add.i.i37, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  br label %float16a_unpack_canonical.exit39

lor.lhs.false.i.i15:                              ; preds = %float16a_unpack_canonical.exit
  %cmp.i29.i.i16 = icmp eq i16 %9, 0
  br i1 %cmp.i29.i.i16, label %if.then47.i.i21, label %if.else49.i.i17

if.then33.i.i22:                                  ; preds = %float16a_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i23 = add nsw i32 %conv.i.i.i7, -15
  store i32 %sub37.i.i23, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %shl.i28.i.i24 = shl nuw nsw i64 %and.i10.i.i8, 53
  %or.i.i25 = or disjoint i64 %shl.i28.i.i24, -9223372036854775808
  store i64 %or.i.i25, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float16a_unpack_canonical.exit39

if.then47.i.i21:                                  ; preds = %lor.lhs.false.i.i15
  store i8 3, ptr %pb, align 8
  br label %float16a_unpack_canonical.exit39

if.else49.i.i17:                                  ; preds = %lor.lhs.false.i.i15
  %shl.i31.i.i18 = shl nuw nsw i64 %and.i10.i.i8, 53
  store i64 %shl.i31.i.i18, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  %tobool.not.i32.i.i19 = icmp ult i16 %9, 512
  %conv53.i.i20 = select i1 %tobool.not.i32.i.i19, i8 5, i8 4
  store i8 %conv53.i.i20, ptr %pb, align 8
  br label %float16a_unpack_canonical.exit39

float16a_unpack_canonical.exit39:                 ; preds = %if.then8.i.i38, %if.then10.i.i31, %frac64_normalize.exit.i.i33, %if.then33.i.i22, %if.then47.i.i21, %if.else49.i.i17
  %call = call fastcc ptr @parts64_div(ptr noundef nonnull %pa, ptr noundef nonnull %pb, ptr noundef %status)
  call fastcc void @parts64_uncanon(ptr noundef %call, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %call, i64 1
  %14 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %14 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %call, i64 4
  %15 = load i32, ptr %exp.i.i.i.i, align 4
  %16 = shl i32 %15, 10
  %17 = and i32 %16, 31744
  %and8.i.i.i.i = zext nneg i32 %17 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %18 = getelementptr inbounds i8, ptr %call, i64 8
  %19 = load i64, ptr %18, align 8
  %shl77.i9.i.i.i = and i64 %19, 1023
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @parts64_div(ptr noundef %a, ptr noundef %b, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %0 = load i8, ptr %a, align 8
  %conv = zext nneg i8 %0 to i32
  %shl = shl nuw i32 1, %conv
  %1 = load i8, ptr %b, align 8
  %conv2 = zext nneg i8 %1 to i32
  %shl3 = shl nuw i32 1, %conv2
  %or = or i32 %shl3, %shl
  %sign4 = getelementptr inbounds i8, ptr %a, i64 1
  %2 = load i8, ptr %sign4, align 1
  %sign6 = getelementptr inbounds i8, ptr %b, i64 1
  %3 = load i8, ptr %sign6, align 1
  %4 = xor i8 %3, %2
  %xor32 = and i8 %4, 1
  switch i32 %or, label %if.end38 [
    i32 4, label %if.then
    i32 2, label %d_nan
    i32 8, label %if.then37
  ]

if.then:                                          ; preds = %entry
  store i8 %xor32, ptr %sign4, align 1
  %exp = getelementptr inbounds i8, ptr %b, i64 4
  %5 = load i32, ptr %exp, align 4
  %6 = getelementptr i8, ptr %b, i64 8
  %b.val = load i64, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %a, i64 8
  %8 = load i64, ptr %7, align 8
  %cmp.i = icmp ult i64 %8, %b.val
  %shl.i = shl i64 %8, 63
  %not.cmp.i = xor i1 %cmp.i, true
  %shr.i = zext i1 %not.cmp.i to i64
  %n0.0.i = lshr i64 %8, %shr.i
  %n1.0.i = select i1 %cmp.i, i64 0, i64 %shl.i
  %9 = tail call { i64, i64 } asm "divq $4", "={ax},={dx},0,1,rm,~{dirflag},~{fpsr},~{flags}"(i64 %n1.0.i, i64 %n0.0.i, i64 %b.val) #18, !srcloc !7
  %asmresult.i.i = extractvalue { i64, i64 } %9, 0
  %asmresult1.i.i = extractvalue { i64, i64 } %9, 1
  %cmp1.i = icmp ne i64 %asmresult1.i.i, 0
  %conv2.i = zext i1 %cmp1.i to i64
  %or.i = or i64 %asmresult.i.i, %conv2.i
  store i64 %or.i, ptr %7, align 8
  %conv17.neg35 = sext i1 %cmp.i to i32
  %exp18 = getelementptr inbounds i8, ptr %a, i64 4
  %10 = load i32, ptr %exp18, align 4
  %add.neg = sub i32 %conv17.neg35, %5
  %sub = add i32 %add.neg, %10
  store i32 %sub, ptr %exp18, align 4
  br label %return

if.then37:                                        ; preds = %entry
  br label %d_nan

if.end38:                                         ; preds = %entry
  %and = and i32 %or, 48
  %tobool39.not = icmp eq i32 %and, 0
  br i1 %tobool39.not, label %if.end48, label %if.then46

if.then46:                                        ; preds = %if.end38
  %cmp.i.i = icmp eq i8 %0, 5
  %cmp.i17.i = icmp eq i8 %1, 5
  %or.cond = or i1 %cmp.i.i, %cmp.i17.i
  br i1 %or.cond, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then46
  %11 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %11, 8193
  store i16 %or1.i.i, ptr %s, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %if.then46, %if.then.i
  %default_nan_mode.i = getelementptr inbounds i8, ptr %s, i64 7
  %12 = load i8, ptr %default_nan_mode.i, align 1
  %13 = and i8 %12, 1
  %tobool.not.i = icmp eq i8 %13, 0
  br i1 %tobool.not.i, label %if.else.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  store i8 4, ptr %a, align 8
  store i8 0, ptr %sign4, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  br label %return

if.else.i:                                        ; preds = %if.end.i
  %14 = getelementptr i8, ptr %a, i64 8
  %a.val.i = load i64, ptr %14, align 8
  %15 = getelementptr i8, ptr %b, i64 8
  %b.val.i = load i64, ptr %15, align 8
  %cmp.i18.i = icmp eq i64 %a.val.i, %b.val.i
  %cmp1.i.i = icmp ult i64 %a.val.i, %b.val.i
  br i1 %cmp.i18.i, label %if.then6.i, label %if.end13.i

if.then6.i:                                       ; preds = %if.else.i
  %16 = load i8, ptr %sign4, align 1
  %17 = and i8 %16, 1
  %18 = load i8, ptr %sign6, align 1
  %19 = and i8 %18, 1
  %cmp11.i = icmp uge i8 %17, %19
  br label %if.end13.i

if.end13.i:                                       ; preds = %if.then6.i, %if.else.i
  %cmp.0.i = phi i1 [ %cmp11.i, %if.then6.i ], [ %cmp1.i.i, %if.else.i ]
  %20 = load i8, ptr %a, align 8
  %21 = load i8, ptr %b, align 8
  switch i8 %20, label %22 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end13.i
  %cmp.i10.i.i = icmp eq i8 %21, 5
  br i1 %cmp.i10.i.i, label %return, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %21, 4
  %spec.select.i.i = and i1 %cmp.0.i, %cmp.i11.i.i
  %cond.fr26.i = freeze i1 %spec.select.i.i
  %spec.select = select i1 %cond.fr26.i, ptr %b, ptr %a
  br label %return

pickNaN.exit.i:                                   ; preds = %if.end13.i
  %cmp.i7.i.i = icmp eq i8 %21, 5
  %cmp.i8.i.i = icmp eq i8 %21, 4
  %spec.select20.i = select i1 %cmp.i7.i.i, i1 %cmp.0.i, i1 %cmp.i8.i.i
  %cond.fr.i = freeze i1 %spec.select20.i
  br i1 %cond.fr.i, label %22, label %if.then24.i

22:                                               ; preds = %if.end13.i, %pickNaN.exit.i
  %23 = icmp eq i8 %21, 5
  br i1 %23, label %if.then24.i, label %return

if.then24.i:                                      ; preds = %pickNaN.exit.i, %22
  %.ph.i39 = phi ptr [ %b, %22 ], [ %a, %pickNaN.exit.i ]
  %24 = getelementptr inbounds i8, ptr %.ph.i39, i64 8
  %25 = load i64, ptr %24, align 8
  %or4.i.i.i = or i64 %25, 4611686018427387904
  store i64 %or4.i.i.i, ptr %24, align 8
  store i8 4, ptr %.ph.i39, align 8
  br label %return

if.end48:                                         ; preds = %if.end38
  store i8 %xor32, ptr %sign4, align 1
  switch i8 %0, label %if.end63 [
    i8 3, label %return
    i8 1, label %return
  ]

if.end63:                                         ; preds = %if.end48
  %26 = load i8, ptr %b, align 8
  switch i8 %26, label %if.else [
    i8 3, label %if.then68
    i8 1, label %do.end
  ]

if.then68:                                        ; preds = %if.end63
  store i8 1, ptr %a, align 8
  br label %return

if.else:                                          ; preds = %if.end63
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 644, ptr noundef nonnull @__func__.parts64_div, ptr noundef nonnull @.str.13) #16
  unreachable

do.end:                                           ; preds = %if.end63
  %27 = load i16, ptr %s, align 2
  %or1.i34 = or i16 %27, 2
  store i16 %or1.i34, ptr %s, align 2
  store i8 3, ptr %a, align 8
  br label %return

d_nan:                                            ; preds = %entry, %if.then37
  %.sink44 = phi i16 [ 513, %if.then37 ], [ 1025, %entry ]
  %28 = load i16, ptr %s, align 2
  %or1.i33 = or i16 %28, %.sink44
  store i16 %or1.i33, ptr %s, align 2
  store i8 4, ptr %a, align 8
  store i8 0, ptr %sign4, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  br label %return

return:                                           ; preds = %lor.lhs.false.i.i, %if.then24.i, %22, %if.then6.i.i, %if.then3.i, %if.end48, %if.end48, %d_nan, %do.end, %if.then68, %if.then
  %retval.0 = phi ptr [ %a, %if.then ], [ %a, %d_nan ], [ %a, %if.then68 ], [ %a, %do.end ], [ %a, %if.end48 ], [ %a, %if.end48 ], [ %a, %if.then3.i ], [ %.ph.i39, %if.then24.i ], [ %b, %22 ], [ %a, %if.then6.i.i ], [ %spec.select, %lor.lhs.false.i.i ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_div(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %pa.i = alloca %struct.FloatParts64, align 8
  %pa.i.sroa.gep = getelementptr inbounds i8, ptr %pa.i, i64 8
  %pb.i = alloca %struct.FloatParts64, align 8
  %pb.i.sroa.gep = getelementptr inbounds i8, ptr %pb.i, i64 8
  %0 = load i16, ptr %s, align 2
  %1 = and i16 %0, 16
  %tobool.not.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i, label %soft39.i, label %can_use_fpu.exit

can_use_fpu.exit:                                 ; preds = %entry
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %s, i64 2
  %2 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp.i5 = icmp eq i8 %2, 0
  br i1 %cmp.i5, label %if.end.i, label %soft39.i

if.end.i:                                         ; preds = %can_use_fpu.exit
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool.not.i6 = icmp eq i8 %4, 0
  br i1 %tobool.not.i6, label %float32_input_flush2.exit, label %if.end.i7

if.end.i7:                                        ; preds = %if.end.i
  %and.i.i.i.i = and i32 %a, 2139095040
  %cmp.i.i.i.i = icmp eq i32 %and.i.i.i.i, 0
  %and.i2.i.i.i = and i32 %a, 2147483647
  %cmp.i3.i.i.i = icmp ne i32 %and.i2.i.i.i, 0
  %5 = and i1 %cmp.i.i.i.i, %cmp.i3.i.i.i
  %.lobit.i.i = and i32 %a, -2147483648
  %or1.i.i.i = or i16 %0, 32
  %ua.i.sroa.0.0 = select i1 %5, i32 %.lobit.i.i, i32 %a
  %and.i.i.i3.i = and i32 %b, 2139095040
  %cmp.i.i.i4.i = icmp eq i32 %and.i.i.i3.i, 0
  %and.i2.i.i5.i = and i32 %b, 2147483647
  %cmp.i3.i.i6.i = icmp ne i32 %and.i2.i.i5.i, 0
  %6 = and i1 %cmp.i.i.i4.i, %cmp.i3.i.i6.i
  %.lobit.i8.i = and i32 %b, -2147483648
  %7 = or i1 %6, %5
  %.ph = select i1 %7, i16 %or1.i.i.i, i16 %0
  %ub.i.sroa.0.0.ph = select i1 %6, i32 %.lobit.i8.i, i32 %b
  %8 = or i1 %5, %6
  br i1 %8, label %9, label %float32_input_flush2.exit

9:                                                ; preds = %if.end.i7
  store i16 %.ph, ptr %s, align 2
  br label %float32_input_flush2.exit

float32_input_flush2.exit:                        ; preds = %9, %if.end.i7, %if.end.i
  %10 = phi i16 [ %0, %if.end.i ], [ %.ph, %if.end.i7 ], [ %.ph, %9 ]
  %ua.i.sroa.0.1 = phi i32 [ %a, %if.end.i ], [ %ua.i.sroa.0.0, %if.end.i7 ], [ %ua.i.sroa.0.0, %9 ]
  %ub.i.sroa.0.0 = phi i32 [ %b, %if.end.i ], [ %ub.i.sroa.0.0.ph, %if.end.i7 ], [ %ub.i.sroa.0.0.ph, %9 ]
  %shr.i.i.i = lshr i32 %ua.i.sroa.0.1, 23
  %add.i.i.i = add nuw nsw i32 %shr.i.i.i, 1
  %and.i.i.i = and i32 %add.i.i.i, 254
  %cmp.i.i.i = icmp ne i32 %and.i.i.i, 0
  %and.i2.i.i = and i32 %ua.i.sroa.0.1, 2147483647
  %cmp.i3.i.i = icmp eq i32 %and.i2.i.i, 0
  %11 = or i1 %cmp.i3.i.i, %cmp.i.i.i
  br i1 %11, label %f32_div_pre.exit, label %soft39.i

f32_div_pre.exit:                                 ; preds = %float32_input_flush2.exit
  %shr.i.i = lshr i32 %ub.i.sroa.0.0, 23
  %add.i.i = add nuw nsw i32 %shr.i.i, 1
  %and.i.i = and i32 %add.i.i, 254
  %cmp.i.i.not = icmp eq i32 %and.i.i, 0
  br i1 %cmp.i.i.not, label %soft39.i, label %if.end14.i

if.end14.i:                                       ; preds = %f32_div_pre.exit
  %12 = bitcast i32 %ua.i.sroa.0.1 to float
  %13 = bitcast i32 %ub.i.sroa.0.0 to float
  %div.i = fdiv float %12, %13
  %14 = bitcast float %div.i to i32
  %15 = tail call float @llvm.fabs.f32(float %div.i) #17
  %isinf.i = fcmp oeq float %15, 0x7FF0000000000000
  br i1 %isinf.i, label %if.then24.i, label %if.else.i

if.then24.i:                                      ; preds = %if.end14.i
  %or1.i = or i16 %10, 4
  store i16 %or1.i, ptr %s, align 2
  br label %float32_gen2.exit

if.else.i:                                        ; preds = %if.end14.i
  %cmp.i = fcmp ole float %15, 0x3810000000000000
  %cmp.i.i10 = icmp ne i32 %and.i2.i.i, 0
  %or.cond = and i1 %cmp.i.i10, %cmp.i
  br i1 %or.cond, label %soft39.i, label %float32_gen2.exit

soft39.i:                                         ; preds = %if.else.i, %float32_input_flush2.exit, %entry, %f32_div_pre.exit, %can_use_fpu.exit
  %16 = phi i16 [ %10, %f32_div_pre.exit ], [ %0, %can_use_fpu.exit ], [ %0, %entry ], [ %10, %float32_input_flush2.exit ], [ %10, %if.else.i ]
  %ua.i.sroa.0.2 = phi i32 [ %ua.i.sroa.0.1, %f32_div_pre.exit ], [ %a, %can_use_fpu.exit ], [ %a, %entry ], [ %ua.i.sroa.0.1, %float32_input_flush2.exit ], [ %ua.i.sroa.0.1, %if.else.i ]
  %ub.i.sroa.0.1 = phi i32 [ %ub.i.sroa.0.0, %f32_div_pre.exit ], [ %b, %can_use_fpu.exit ], [ %b, %entry ], [ %ub.i.sroa.0.0, %float32_input_flush2.exit ], [ %ub.i.sroa.0.0, %if.else.i ]
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %pa.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %pb.i)
  %f.lobit.i.i = lshr i32 %ua.i.sroa.0.2, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %ua.i.sroa.0.2, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %17 = and i32 %ua.i.sroa.0.2, 8388607
  %and.i10.i.i = zext nneg i32 %17 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa.i, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa.i, i64 4
  store i32 %and.i9.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 %and.i10.i.i, ptr %pa.i.sroa.gep, align 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %if.then33.i.i [
    i8 0, label %if.then.i41.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i41.i:                                    ; preds = %soft39.i
  %cmp.i.i.i14 = icmp eq i32 %17, 0
  br i1 %cmp.i.i.i14, label %if.then8.i.i, label %if.else.i42.i

if.then8.i.i:                                     ; preds = %if.then.i41.i
  store i8 1, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

if.else.i42.i:                                    ; preds = %if.then.i41.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %18 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %19 = and i8 %18, 1
  %tobool9.not.i.i = icmp eq i8 %19, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i42.i
  %or1.i.i.i15 = or i16 %16, 32
  store i16 %or1.i.i.i15, ptr %s, align 2
  store i8 1, ptr %pa.i, align 8
  store i64 0, ptr %pa.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit.i

frac64_normalize.exit.i.i:                        ; preds = %if.else.i42.i
  %20 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %20 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %20
  store i64 %shl.i.i.i, ptr %pa.i.sroa.gep, align 8
  store i8 2, ptr %pa.i, align 8
  %add.i43.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i43.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_canonicalize.exit.i

lor.lhs.false.i.i:                                ; preds = %soft39.i
  %cmp.i29.i.i = icmp eq i32 %17, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %soft39.i
  store i8 2, ptr %pa.i, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i40.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i40.i, ptr %pa.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %pa.i.sroa.gep, align 8
  %tobool.not.i32.i.i = icmp ult i32 %17, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

parts64_canonicalize.exit.i:                      ; preds = %if.else49.i.i, %if.then47.i.i, %if.then33.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then8.i.i
  %21 = phi i16 [ %16, %if.then8.i.i ], [ %or1.i.i.i15, %if.then10.i.i ], [ %16, %frac64_normalize.exit.i.i ], [ %16, %if.then33.i.i ], [ %16, %if.then47.i.i ], [ %16, %if.else49.i.i ]
  %22 = phi i32 [ %and.i9.i.i, %if.then8.i.i ], [ %and.i9.i.i, %if.then10.i.i ], [ %add.i43.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ %and.i9.i.i, %if.then47.i.i ], [ %and.i9.i.i, %if.else49.i.i ]
  %a.val.i.i = phi i64 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i40.i, %if.then33.i.i ], [ 0, %if.then47.i.i ], [ %shl.i31.i.i, %if.else49.i.i ]
  %23 = phi i8 [ 1, %if.then8.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ], [ 3, %if.then47.i.i ], [ %conv53.i.i, %if.else49.i.i ]
  %f.lobit.i44.i = lshr i32 %ub.i.sroa.0.1, 31
  %frombool.i.i45.i = trunc i32 %f.lobit.i44.i to i8
  %shr.i8.i46.i = lshr i32 %ub.i.sroa.0.1, 23
  %and.i9.i47.i = and i32 %shr.i8.i46.i, 255
  %24 = and i32 %ub.i.sroa.0.1, 8388607
  %and.i10.i48.i = zext nneg i32 %24 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i49.i = getelementptr inbounds i8, ptr %pb.i, i64 1
  store i8 %frombool.i.i45.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i49.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i50.i = getelementptr inbounds i8, ptr %pb.i, i64 4
  store i32 %and.i9.i47.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i50.i, align 4
  store i64 %and.i10.i48.i, ptr %pb.i.sroa.gep, align 8
  %trunc96.i = trunc i32 %shr.i8.i46.i to i8
  switch i8 %trunc96.i, label %if.then33.i64.i [
    i8 0, label %if.then.i68.i
    i8 -1, label %lor.lhs.false.i56.i
  ]

if.then.i68.i:                                    ; preds = %parts64_canonicalize.exit.i
  %cmp.i.i70.i = icmp eq i32 %24, 0
  br i1 %cmp.i.i70.i, label %if.then8.i81.i, label %if.else.i71.i

if.then8.i81.i:                                   ; preds = %if.then.i68.i
  store i8 1, ptr %pb.i, align 8
  br label %parts64_canonicalize.exit82.i

if.else.i71.i:                                    ; preds = %if.then.i68.i
  %flush_inputs_to_zero.i72.i = getelementptr inbounds i8, ptr %s, i64 6
  %25 = load i8, ptr %flush_inputs_to_zero.i72.i, align 2
  %26 = and i8 %25, 1
  %tobool9.not.i73.i = icmp eq i8 %26, 0
  br i1 %tobool9.not.i73.i, label %frac64_normalize.exit.i76.i, label %if.then10.i74.i

if.then10.i74.i:                                  ; preds = %if.else.i71.i
  %or1.i.i75.i = or i16 %21, 32
  store i16 %or1.i.i75.i, ptr %s, align 2
  store i8 1, ptr %pb.i, align 8
  store i64 0, ptr %pb.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit82.i

frac64_normalize.exit.i76.i:                      ; preds = %if.else.i71.i
  %27 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i48.i, i1 true), !range !5
  %cast.i.i.i77.i = trunc i64 %27 to i32
  %shl.i.i78.i = shl i64 %and.i10.i48.i, %27
  store i64 %shl.i.i78.i, ptr %pb.i.sroa.gep, align 8
  store i8 2, ptr %pb.i, align 8
  %add.i80.i = sub nuw nsw i32 -86, %cast.i.i.i77.i
  store i32 %add.i80.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i50.i, align 4
  br label %parts64_canonicalize.exit82.i

lor.lhs.false.i56.i:                              ; preds = %parts64_canonicalize.exit.i
  %cmp.i29.i58.i = icmp eq i32 %24, 0
  br i1 %cmp.i29.i58.i, label %if.then47.i63.i, label %if.else49.i59.i

if.then33.i64.i:                                  ; preds = %parts64_canonicalize.exit.i
  store i8 2, ptr %pb.i, align 8
  %sub37.i65.i = add nsw i32 %and.i9.i47.i, -127
  store i32 %sub37.i65.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i50.i, align 4
  %shl.i28.i66.i = shl nuw nsw i64 %and.i10.i48.i, 40
  %or.i67.i = or disjoint i64 %shl.i28.i66.i, -9223372036854775808
  store i64 %or.i67.i, ptr %pb.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit82.i

if.then47.i63.i:                                  ; preds = %lor.lhs.false.i56.i
  store i8 3, ptr %pb.i, align 8
  br label %parts64_canonicalize.exit82.i

if.else49.i59.i:                                  ; preds = %lor.lhs.false.i56.i
  %shl.i31.i60.i = shl nuw nsw i64 %and.i10.i48.i, 40
  store i64 %shl.i31.i60.i, ptr %pb.i.sroa.gep, align 8
  %tobool.not.i32.i61.i = icmp ult i32 %24, 4194304
  %conv53.i62.i = select i1 %tobool.not.i32.i61.i, i8 5, i8 4
  store i8 %conv53.i62.i, ptr %pb.i, align 8
  br label %parts64_canonicalize.exit82.i

parts64_canonicalize.exit82.i:                    ; preds = %if.else49.i59.i, %if.then47.i63.i, %if.then33.i64.i, %frac64_normalize.exit.i76.i, %if.then10.i74.i, %if.then8.i81.i
  %28 = phi i64 [ 0, %if.then8.i81.i ], [ 0, %if.then10.i74.i ], [ %shl.i.i78.i, %frac64_normalize.exit.i76.i ], [ %or.i67.i, %if.then33.i64.i ], [ 0, %if.then47.i63.i ], [ %shl.i31.i60.i, %if.else49.i59.i ]
  %29 = phi i16 [ %21, %if.then8.i81.i ], [ %or1.i.i75.i, %if.then10.i74.i ], [ %21, %frac64_normalize.exit.i76.i ], [ %21, %if.then33.i64.i ], [ %21, %if.then47.i63.i ], [ %21, %if.else49.i59.i ]
  %30 = phi i32 [ %and.i9.i47.i, %if.then8.i81.i ], [ %and.i9.i47.i, %if.then10.i74.i ], [ %add.i80.i, %frac64_normalize.exit.i76.i ], [ %sub37.i65.i, %if.then33.i64.i ], [ %and.i9.i47.i, %if.then47.i63.i ], [ %and.i9.i47.i, %if.else49.i59.i ]
  %.pr.i.pre.i = phi i8 [ 1, %if.then8.i81.i ], [ 1, %if.then10.i74.i ], [ 2, %frac64_normalize.exit.i76.i ], [ 2, %if.then33.i64.i ], [ 3, %if.then47.i63.i ], [ %conv53.i62.i, %if.else49.i59.i ]
  %conv.i.i = zext nneg i8 %23 to i32
  %shl.i.i = shl nuw nsw i32 1, %conv.i.i
  %conv2.i.i = zext nneg i8 %.pr.i.pre.i to i32
  %shl3.i.i = shl nuw nsw i32 1, %conv2.i.i
  %or.i.i = or i32 %shl3.i.i, %shl.i.i
  %31 = xor i8 %frombool.i.i45.i, %frombool.i.i.i
  %trunc100.i = trunc i32 %or.i.i to i8
  switch i8 %trunc100.i, label %if.end38.i.i [
    i8 4, label %if.then.i.i11
    i8 2, label %d_nan.i.i
    i8 8, label %if.then37.i.i
  ]

if.then.i.i11:                                    ; preds = %parts64_canonicalize.exit82.i
  store i8 %31, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %cmp.i83.i = icmp ult i64 %a.val.i.i, %28
  %shl.i84.i = shl i64 %a.val.i.i, 63
  %not.cmp.i.i = xor i1 %cmp.i83.i, true
  %shr.i.i12 = zext i1 %not.cmp.i.i to i64
  %n0.0.i.i = lshr i64 %a.val.i.i, %shr.i.i12
  %n1.0.i.i = select i1 %cmp.i83.i, i64 0, i64 %shl.i84.i
  %32 = tail call { i64, i64 } asm "divq $4", "={ax},={dx},0,1,rm,~{dirflag},~{fpsr},~{flags}"(i64 %n1.0.i.i, i64 %n0.0.i.i, i64 %28) #18, !srcloc !7
  %asmresult.i.i.i = extractvalue { i64, i64 } %32, 0
  %asmresult1.i.i.i = extractvalue { i64, i64 } %32, 1
  %cmp1.i.i = icmp ne i64 %asmresult1.i.i.i, 0
  %conv2.i85.i = zext i1 %cmp1.i.i to i64
  %or.i86.i = or i64 %asmresult.i.i.i, %conv2.i85.i
  store i64 %or.i86.i, ptr %pa.i.sroa.gep, align 8
  %conv17.i.neg97.i = sext i1 %cmp.i83.i to i32
  %add.i.neg.i = sub nsw i32 %22, %30
  %sub.i.i = add nsw i32 %add.i.neg.i, %conv17.i.neg97.i
  store i32 %sub.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %soft_f32_div.exit

if.then37.i.i:                                    ; preds = %parts64_canonicalize.exit82.i
  br label %d_nan.i.i

if.end38.i.i:                                     ; preds = %parts64_canonicalize.exit82.i
  %and.i.i13 = and i32 %or.i.i, 48
  %tobool39.i.not.i = icmp eq i32 %and.i.i13, 0
  br i1 %tobool39.i.not.i, label %if.end48.i.i, label %if.then46.i.i

if.then46.i.i:                                    ; preds = %if.end38.i.i
  %cmp.i.i88.i = icmp eq i8 %23, 5
  %cmp.i17.i.i = icmp eq i8 %.pr.i.pre.i, 5
  %or.cond.i = or i1 %cmp.i.i88.i, %cmp.i17.i.i
  br i1 %or.cond.i, label %if.then.i91.i, label %if.end.i.i

if.then.i91.i:                                    ; preds = %if.then46.i.i
  %or1.i.i92.i = or i16 %29, 8193
  store i16 %or1.i.i92.i, ptr %s, align 2
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i91.i, %if.then46.i.i
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %33 = load i8, ptr %default_nan_mode.i.i, align 1
  %34 = and i8 %33, 1
  %tobool.not.i.i = icmp eq i8 %34, 0
  br i1 %tobool.not.i.i, label %if.else.i90.i, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  store i8 4, ptr %pa.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.i.sroa.gep, align 8
  br label %soft_f32_div.exit

if.else.i90.i:                                    ; preds = %if.end.i.i
  %cmp.i18.i.i = icmp eq i64 %a.val.i.i, %28
  %cmp1.i.i.i = icmp ult i64 %a.val.i.i, %28
  %cmp11.i.i = icmp uge i32 %f.lobit.i.i, %f.lobit.i44.i
  %spec.select.i = select i1 %cmp.i18.i.i, i1 %cmp11.i.i, i1 %cmp1.i.i.i
  %spec.select.fr.i = freeze i1 %spec.select.i
  switch i8 %23, label %35 [
    i8 5, label %pickNaN.exit.i.i
    i8 4, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.else.i90.i
  br i1 %cmp.i17.i.i, label %soft_f32_div.exit, label %lor.lhs.false.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %if.then6.i.i.i
  %cmp.i11.i.i.i = icmp eq i8 %.pr.i.pre.i, 4
  %spec.select.i.i.i = and i1 %cmp.i11.i.i.i, %spec.select.fr.i
  %spec.select108.i = select i1 %spec.select.i.i.i, ptr %pb.i, ptr %pa.i
  br label %soft_f32_div.exit

pickNaN.exit.i.i:                                 ; preds = %if.else.i90.i
  %cmp.i8.i.i.i = icmp eq i8 %.pr.i.pre.i, 4
  %spec.select20.i.i = select i1 %cmp.i17.i.i, i1 %spec.select.fr.i, i1 %cmp.i8.i.i.i
  %spec.select20.i.i.not = xor i1 %spec.select20.i.i, true
  %brmerge = or i1 %cmp.i17.i.i, %spec.select20.i.i.not
  br i1 %brmerge, label %pickNaN.exit.i.i.if.then24.i.i_crit_edge, label %soft_f32_div.exit

pickNaN.exit.i.i.if.then24.i.i_crit_edge:         ; preds = %pickNaN.exit.i.i
  %pa.i.sroa.gep.mux = select i1 %spec.select20.i.i, ptr %pb.i.sroa.gep, ptr %pa.i.sroa.gep
  %pa.i.mux = select i1 %spec.select20.i.i, ptr %pb.i, ptr %pa.i
  %.pre = load i64, ptr %pa.i.sroa.gep.mux, align 8
  br label %if.then24.i.i

35:                                               ; preds = %if.else.i90.i
  br i1 %cmp.i17.i.i, label %if.then24.i.i, label %soft_f32_div.exit

if.then24.i.i:                                    ; preds = %pickNaN.exit.i.i.if.then24.i.i_crit_edge, %35
  %36 = phi i64 [ %28, %35 ], [ %.pre, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i103.i = phi ptr [ %pb.i, %35 ], [ %pa.i.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i103.i.sroa.phi = phi ptr [ %pb.i.sroa.gep, %35 ], [ %pa.i.sroa.gep.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %or4.i.i.i.i = or i64 %36, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.ph.i103.i.sroa.phi, align 8
  store i8 4, ptr %.ph.i103.i, align 8
  br label %soft_f32_div.exit

if.end48.i.i:                                     ; preds = %if.end38.i.i
  store i8 %31, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  switch i8 %23, label %if.end63.i.i [
    i8 3, label %soft_f32_div.exit
    i8 1, label %soft_f32_div.exit
  ]

if.end63.i.i:                                     ; preds = %if.end48.i.i
  switch i8 %.pr.i.pre.i, label %if.else.i.i [
    i8 3, label %if.then68.i.i
    i8 1, label %if.then75.i.i
  ]

if.then68.i.i:                                    ; preds = %if.end63.i.i
  store i8 1, ptr %pa.i, align 8
  br label %soft_f32_div.exit

if.then75.i.i:                                    ; preds = %if.end63.i.i
  %or1.i93.i = or i16 %29, 2
  store i16 %or1.i93.i, ptr %s, align 2
  store i8 3, ptr %pa.i, align 8
  br label %soft_f32_div.exit

if.else.i.i:                                      ; preds = %if.end63.i.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 644, ptr noundef nonnull @__func__.parts64_div, ptr noundef nonnull @.str.13) #16
  unreachable

d_nan.i.i:                                        ; preds = %if.then37.i.i, %parts64_canonicalize.exit82.i
  %.sink109.i = phi i16 [ 513, %if.then37.i.i ], [ 1025, %parts64_canonicalize.exit82.i ]
  %or1.i87.i = or i16 %29, %.sink109.i
  store i16 %or1.i87.i, ptr %s, align 2
  store i8 4, ptr %pa.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.i.sroa.gep, align 8
  br label %soft_f32_div.exit

soft_f32_div.exit:                                ; preds = %pickNaN.exit.i.i, %if.then.i.i11, %if.then3.i.i, %if.then6.i.i.i, %lor.lhs.false.i.i.i, %35, %if.then24.i.i, %if.end48.i.i, %if.end48.i.i, %if.then68.i.i, %if.then75.i.i, %d_nan.i.i
  %retval.i.0.i = phi ptr [ %pa.i, %if.then.i.i11 ], [ %pa.i, %d_nan.i.i ], [ %pa.i, %if.then68.i.i ], [ %pa.i, %if.then75.i.i ], [ %pa.i, %if.end48.i.i ], [ %pa.i, %if.end48.i.i ], [ %pa.i, %if.then3.i.i ], [ %.ph.i103.i, %if.then24.i.i ], [ %pb.i, %35 ], [ %pa.i, %if.then6.i.i.i ], [ %spec.select108.i, %lor.lhs.false.i.i.i ], [ %pb.i, %pickNaN.exit.i.i ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %retval.i.0.i, ptr noundef nonnull %s, ptr noundef nonnull @float32_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %retval.i.0.i, i64 1
  %37 = load i8, ptr %sign.i.i.i, align 1
  %conv.i.i.i = zext i8 %37 to i64
  %shl.i.i94.i = shl nuw nsw i64 %conv.i.i.i, 31
  %exp.i.i.i = getelementptr inbounds i8, ptr %retval.i.0.i, i64 4
  %38 = load i32, ptr %exp.i.i.i, align 4
  %39 = shl i32 %38, 23
  %40 = and i32 %39, 2139095040
  %and8.i.i.i = zext nneg i32 %40 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i94.i, %and8.i.i.i
  %41 = getelementptr inbounds i8, ptr %retval.i.0.i, i64 8
  %42 = load i64, ptr %41, align 8
  %shl77.i9.i.i = and i64 %42, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i95.i = trunc i64 %or.i10.i.i to i32
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %pa.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %pb.i)
  br label %float32_gen2.exit

float32_gen2.exit:                                ; preds = %if.then24.i, %if.else.i, %soft_f32_div.exit
  %retval.i.0 = phi i32 [ %conv.i95.i, %soft_f32_div.exit ], [ %14, %if.else.i ], [ %14, %if.then24.i ]
  ret i32 %retval.i.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_div(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %pa.i = alloca %struct.FloatParts64, align 8
  %pa.i.sroa.gep = getelementptr inbounds i8, ptr %pa.i, i64 8
  %pb.i = alloca %struct.FloatParts64, align 8
  %pb.i.sroa.gep = getelementptr inbounds i8, ptr %pb.i, i64 8
  %0 = load i16, ptr %s, align 2
  %1 = and i16 %0, 16
  %tobool.not.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i, label %soft39.i, label %can_use_fpu.exit

can_use_fpu.exit:                                 ; preds = %entry
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %s, i64 2
  %2 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp.i5 = icmp eq i8 %2, 0
  br i1 %cmp.i5, label %if.end.i, label %soft39.i

if.end.i:                                         ; preds = %can_use_fpu.exit
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool.not.i6 = icmp eq i8 %4, 0
  br i1 %tobool.not.i6, label %float64_input_flush2.exit, label %if.end.i7

if.end.i7:                                        ; preds = %if.end.i
  %and.i.i.i.i = and i64 %a, 9218868437227405312
  %cmp.i.i.i.i = icmp eq i64 %and.i.i.i.i, 0
  %and.i2.i.i.i = and i64 %a, 9223372036854775807
  %cmp.i3.i.i.i = icmp ne i64 %and.i2.i.i.i, 0
  %5 = and i1 %cmp.i.i.i.i, %cmp.i3.i.i.i
  %.lobit.i.i = and i64 %a, -9223372036854775808
  %or1.i.i.i = or i16 %0, 32
  %ua.i.sroa.0.0 = select i1 %5, i64 %.lobit.i.i, i64 %a
  %and.i.i.i3.i = and i64 %b, 9218868437227405312
  %cmp.i.i.i4.i = icmp eq i64 %and.i.i.i3.i, 0
  %and.i2.i.i5.i = and i64 %b, 9223372036854775807
  %cmp.i3.i.i6.i = icmp ne i64 %and.i2.i.i5.i, 0
  %6 = and i1 %cmp.i.i.i4.i, %cmp.i3.i.i6.i
  %.lobit.i8.i = and i64 %b, -9223372036854775808
  %7 = or i1 %6, %5
  %.ph = select i1 %7, i16 %or1.i.i.i, i16 %0
  %ub.i.sroa.0.0.ph = select i1 %6, i64 %.lobit.i8.i, i64 %b
  %8 = or i1 %5, %6
  br i1 %8, label %9, label %float64_input_flush2.exit

9:                                                ; preds = %if.end.i7
  store i16 %.ph, ptr %s, align 2
  br label %float64_input_flush2.exit

float64_input_flush2.exit:                        ; preds = %9, %if.end.i7, %if.end.i
  %10 = phi i16 [ %0, %if.end.i ], [ %.ph, %if.end.i7 ], [ %.ph, %9 ]
  %ua.i.sroa.0.1 = phi i64 [ %a, %if.end.i ], [ %ua.i.sroa.0.0, %if.end.i7 ], [ %ua.i.sroa.0.0, %9 ]
  %ub.i.sroa.0.0 = phi i64 [ %b, %if.end.i ], [ %ub.i.sroa.0.0.ph, %if.end.i7 ], [ %ub.i.sroa.0.0.ph, %9 ]
  %11 = bitcast i64 %ua.i.sroa.0.1 to double
  %or.cond.i = fcmp ueq double %11, 0.000000e+00
  br i1 %or.cond.i, label %lor.lhs.false.i, label %fpclassify_not_nan.i

lor.lhs.false.i:                                  ; preds = %float64_input_flush2.exit
  %iszero.i = fcmp oeq double %11, 0.000000e+00
  br i1 %iszero.i, label %land.rhs.i8, label %soft39.i

fpclassify_not_nan.i:                             ; preds = %float64_input_flush2.exit
  %or.cond8.i = tail call i1 @llvm.is.fpclass.f64(double %11, i32 267)
  br i1 %or.cond8.i, label %land.rhs.i8, label %soft39.i

land.rhs.i8:                                      ; preds = %fpclassify_not_nan.i, %lor.lhs.false.i
  %12 = bitcast i64 %ub.i.sroa.0.0 to double
  %or.cond7.i = fcmp ueq double %12, 0.000000e+00
  br i1 %or.cond7.i, label %soft39.i, label %fpclassify_not_nan18.i

fpclassify_not_nan18.i:                           ; preds = %land.rhs.i8
  %or.cond = tail call i1 @llvm.is.fpclass.f64(double %12, i32 267)
  br i1 %or.cond, label %if.end14.i, label %soft39.i

if.end14.i:                                       ; preds = %fpclassify_not_nan18.i
  %div.i = fdiv double %11, %12
  %13 = bitcast double %div.i to i64
  %14 = tail call double @llvm.fabs.f64(double %div.i) #17
  %isinf.i = fcmp oeq double %14, 0x7FF0000000000000
  br i1 %isinf.i, label %if.then24.i, label %if.else.i

if.then24.i:                                      ; preds = %if.end14.i
  %or1.i = or i16 %10, 4
  store i16 %or1.i, ptr %s, align 2
  br label %float64_gen2.exit

if.else.i:                                        ; preds = %if.end14.i
  %cmp.i = fcmp ole double %14, 0x10000000000000
  %15 = and i64 %ua.i.sroa.0.1, 9223372036854775807
  %iszero.i9 = icmp ne i64 %15, 0
  %or.cond19 = and i1 %iszero.i9, %cmp.i
  br i1 %or.cond19, label %soft39.i, label %float64_gen2.exit

soft39.i:                                         ; preds = %if.else.i, %lor.lhs.false.i, %fpclassify_not_nan.i, %fpclassify_not_nan18.i, %land.rhs.i8, %entry, %can_use_fpu.exit
  %16 = phi i16 [ %0, %can_use_fpu.exit ], [ %0, %entry ], [ %10, %land.rhs.i8 ], [ %10, %fpclassify_not_nan18.i ], [ %10, %fpclassify_not_nan.i ], [ %10, %lor.lhs.false.i ], [ %10, %if.else.i ]
  %ua.i.sroa.0.2 = phi i64 [ %a, %can_use_fpu.exit ], [ %a, %entry ], [ %ua.i.sroa.0.1, %land.rhs.i8 ], [ %ua.i.sroa.0.1, %fpclassify_not_nan18.i ], [ %ua.i.sroa.0.1, %fpclassify_not_nan.i ], [ %ua.i.sroa.0.1, %lor.lhs.false.i ], [ %ua.i.sroa.0.1, %if.else.i ]
  %ub.i.sroa.0.1 = phi i64 [ %b, %can_use_fpu.exit ], [ %b, %entry ], [ %ub.i.sroa.0.0, %land.rhs.i8 ], [ %ub.i.sroa.0.0, %fpclassify_not_nan18.i ], [ %ub.i.sroa.0.0, %fpclassify_not_nan.i ], [ %ub.i.sroa.0.0, %lor.lhs.false.i ], [ %ub.i.sroa.0.0, %if.else.i ]
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %pa.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %pb.i)
  %f.lobit.i.i = lshr i64 %ua.i.sroa.0.2, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %ua.i.sroa.0.2, 52
  %17 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %17, 2047
  %and.i9.i.i = and i64 %ua.i.sroa.0.2, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa.i, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa.i, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 %and.i9.i.i, ptr %pa.i.sroa.gep, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i41.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i41.i:                                    ; preds = %soft39.i
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i42.i

if.then8.i.i:                                     ; preds = %if.then.i41.i
  store i8 1, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

if.else.i42.i:                                    ; preds = %if.then.i41.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %18 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %19 = and i8 %18, 1
  %tobool9.not.i.i = icmp eq i8 %19, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i42.i
  %or1.i.i.i12 = or i16 %16, 32
  store i16 %or1.i.i.i12, ptr %s, align 2
  store i8 1, ptr %pa.i, align 8
  store i64 0, ptr %pa.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit.i

frac64_normalize.exit.i.i:                        ; preds = %if.else.i42.i
  %20 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %20 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %20
  store i64 %shl.i.i.i, ptr %pa.i.sroa.gep, align 8
  store i8 2, ptr %pa.i, align 8
  %add.i43.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i43.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_canonicalize.exit.i

lor.lhs.false.i.i:                                ; preds = %soft39.i
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %soft39.i
  store i8 2, ptr %pa.i, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i40.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i40.i, ptr %pa.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %pa.i.sroa.gep, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa.i, align 8
  br label %parts64_canonicalize.exit.i

parts64_canonicalize.exit.i:                      ; preds = %if.else49.i.i, %if.then47.i.i, %if.then33.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then8.i.i
  %21 = phi i16 [ %16, %if.then8.i.i ], [ %or1.i.i.i12, %if.then10.i.i ], [ %16, %frac64_normalize.exit.i.i ], [ %16, %if.then33.i.i ], [ %16, %if.then47.i.i ], [ %16, %if.else49.i.i ]
  %22 = phi i32 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %add.i43.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ 2047, %if.then47.i.i ], [ 2047, %if.else49.i.i ]
  %a.val.i.i = phi i64 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i40.i, %if.then33.i.i ], [ 0, %if.then47.i.i ], [ %shl.i31.i.i, %if.else49.i.i ]
  %23 = phi i8 [ 1, %if.then8.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ], [ 3, %if.then47.i.i ], [ %conv53.i.i, %if.else49.i.i ]
  %f.lobit.i44.i = lshr i64 %ub.i.sroa.0.1, 63
  %frombool.i.i45.i = trunc i64 %f.lobit.i44.i to i8
  %shr.i8.i46.i = lshr i64 %ub.i.sroa.0.1, 52
  %24 = trunc i64 %shr.i8.i46.i to i32
  %conv.i.i47.i = and i32 %24, 2047
  %and.i9.i48.i = and i64 %ub.i.sroa.0.1, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i49.i = getelementptr inbounds i8, ptr %pb.i, i64 1
  store i8 %frombool.i.i45.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i49.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i50.i = getelementptr inbounds i8, ptr %pb.i, i64 4
  store i32 %conv.i.i47.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i50.i, align 4
  store i64 %and.i9.i48.i, ptr %pb.i.sroa.gep, align 8
  switch i32 %conv.i.i47.i, label %if.then33.i64.i [
    i32 0, label %if.then.i68.i
    i32 2047, label %lor.lhs.false.i56.i
  ]

if.then.i68.i:                                    ; preds = %parts64_canonicalize.exit.i
  %cmp.i.i70.i = icmp eq i64 %and.i9.i48.i, 0
  br i1 %cmp.i.i70.i, label %if.then8.i81.i, label %if.else.i71.i

if.then8.i81.i:                                   ; preds = %if.then.i68.i
  store i8 1, ptr %pb.i, align 8
  br label %parts64_canonicalize.exit82.i

if.else.i71.i:                                    ; preds = %if.then.i68.i
  %flush_inputs_to_zero.i72.i = getelementptr inbounds i8, ptr %s, i64 6
  %25 = load i8, ptr %flush_inputs_to_zero.i72.i, align 2
  %26 = and i8 %25, 1
  %tobool9.not.i73.i = icmp eq i8 %26, 0
  br i1 %tobool9.not.i73.i, label %frac64_normalize.exit.i76.i, label %if.then10.i74.i

if.then10.i74.i:                                  ; preds = %if.else.i71.i
  %or1.i.i75.i = or i16 %21, 32
  store i16 %or1.i.i75.i, ptr %s, align 2
  store i8 1, ptr %pb.i, align 8
  store i64 0, ptr %pb.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit82.i

frac64_normalize.exit.i76.i:                      ; preds = %if.else.i71.i
  %27 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i48.i, i1 true), !range !5
  %cast.i.i.i77.i = trunc i64 %27 to i32
  %shl.i.i78.i = shl i64 %and.i9.i48.i, %27
  store i64 %shl.i.i78.i, ptr %pb.i.sroa.gep, align 8
  store i8 2, ptr %pb.i, align 8
  %add.i80.i = sub nuw nsw i32 -1011, %cast.i.i.i77.i
  store i32 %add.i80.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i50.i, align 4
  br label %parts64_canonicalize.exit82.i

lor.lhs.false.i56.i:                              ; preds = %parts64_canonicalize.exit.i
  %cmp.i29.i58.i = icmp eq i64 %and.i9.i48.i, 0
  br i1 %cmp.i29.i58.i, label %if.then47.i63.i, label %if.else49.i59.i

if.then33.i64.i:                                  ; preds = %parts64_canonicalize.exit.i
  store i8 2, ptr %pb.i, align 8
  %sub37.i65.i = add nsw i32 %conv.i.i47.i, -1023
  store i32 %sub37.i65.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i50.i, align 4
  %shl.i28.i66.i = shl nuw nsw i64 %and.i9.i48.i, 11
  %or.i67.i = or disjoint i64 %shl.i28.i66.i, -9223372036854775808
  store i64 %or.i67.i, ptr %pb.i.sroa.gep, align 8
  br label %parts64_canonicalize.exit82.i

if.then47.i63.i:                                  ; preds = %lor.lhs.false.i56.i
  store i8 3, ptr %pb.i, align 8
  br label %parts64_canonicalize.exit82.i

if.else49.i59.i:                                  ; preds = %lor.lhs.false.i56.i
  %shl.i31.i60.i = shl nuw nsw i64 %and.i9.i48.i, 11
  store i64 %shl.i31.i60.i, ptr %pb.i.sroa.gep, align 8
  %tobool.not.i32.i61.i = icmp ult i64 %and.i9.i48.i, 2251799813685248
  %conv53.i62.i = select i1 %tobool.not.i32.i61.i, i8 5, i8 4
  store i8 %conv53.i62.i, ptr %pb.i, align 8
  br label %parts64_canonicalize.exit82.i

parts64_canonicalize.exit82.i:                    ; preds = %if.else49.i59.i, %if.then47.i63.i, %if.then33.i64.i, %frac64_normalize.exit.i76.i, %if.then10.i74.i, %if.then8.i81.i
  %28 = phi i64 [ 0, %if.then8.i81.i ], [ 0, %if.then10.i74.i ], [ %shl.i.i78.i, %frac64_normalize.exit.i76.i ], [ %or.i67.i, %if.then33.i64.i ], [ 0, %if.then47.i63.i ], [ %shl.i31.i60.i, %if.else49.i59.i ]
  %29 = phi i16 [ %21, %if.then8.i81.i ], [ %or1.i.i75.i, %if.then10.i74.i ], [ %21, %frac64_normalize.exit.i76.i ], [ %21, %if.then33.i64.i ], [ %21, %if.then47.i63.i ], [ %21, %if.else49.i59.i ]
  %30 = phi i32 [ 0, %if.then8.i81.i ], [ 0, %if.then10.i74.i ], [ %add.i80.i, %frac64_normalize.exit.i76.i ], [ %sub37.i65.i, %if.then33.i64.i ], [ 2047, %if.then47.i63.i ], [ 2047, %if.else49.i59.i ]
  %.pr.i.pre.i = phi i8 [ 1, %if.then8.i81.i ], [ 1, %if.then10.i74.i ], [ 2, %frac64_normalize.exit.i76.i ], [ 2, %if.then33.i64.i ], [ 3, %if.then47.i63.i ], [ %conv53.i62.i, %if.else49.i59.i ]
  %conv.i.i = zext nneg i8 %23 to i32
  %shl.i.i = shl nuw nsw i32 1, %conv.i.i
  %conv2.i.i = zext nneg i8 %.pr.i.pre.i to i32
  %shl3.i.i = shl nuw nsw i32 1, %conv2.i.i
  %or.i.i = or i32 %shl3.i.i, %shl.i.i
  %31 = xor i8 %frombool.i.i45.i, %frombool.i.i.i
  %trunc.i = trunc i32 %or.i.i to i8
  switch i8 %trunc.i, label %if.end38.i.i [
    i8 4, label %if.then.i.i10
    i8 2, label %d_nan.i.i
    i8 8, label %if.then37.i.i
  ]

if.then.i.i10:                                    ; preds = %parts64_canonicalize.exit82.i
  store i8 %31, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %cmp.i83.i = icmp ult i64 %a.val.i.i, %28
  %shl.i84.i = shl i64 %a.val.i.i, 63
  %not.cmp.i.i = xor i1 %cmp.i83.i, true
  %shr.i.i = zext i1 %not.cmp.i.i to i64
  %n0.0.i.i = lshr i64 %a.val.i.i, %shr.i.i
  %n1.0.i.i = select i1 %cmp.i83.i, i64 0, i64 %shl.i84.i
  %32 = tail call { i64, i64 } asm "divq $4", "={ax},={dx},0,1,rm,~{dirflag},~{fpsr},~{flags}"(i64 %n1.0.i.i, i64 %n0.0.i.i, i64 %28) #18, !srcloc !7
  %asmresult.i.i.i = extractvalue { i64, i64 } %32, 0
  %asmresult1.i.i.i = extractvalue { i64, i64 } %32, 1
  %cmp1.i.i = icmp ne i64 %asmresult1.i.i.i, 0
  %conv2.i85.i = zext i1 %cmp1.i.i to i64
  %or.i86.i = or i64 %asmresult.i.i.i, %conv2.i85.i
  store i64 %or.i86.i, ptr %pa.i.sroa.gep, align 8
  %conv17.i.neg96.i = sext i1 %cmp.i83.i to i32
  %add.i.neg.i = sub nsw i32 %22, %30
  %sub.i.i = add nsw i32 %add.i.neg.i, %conv17.i.neg96.i
  store i32 %sub.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %soft_f64_div.exit

if.then37.i.i:                                    ; preds = %parts64_canonicalize.exit82.i
  br label %d_nan.i.i

if.end38.i.i:                                     ; preds = %parts64_canonicalize.exit82.i
  %and.i.i = and i32 %or.i.i, 48
  %tobool39.i.not.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool39.i.not.i, label %if.end48.i.i, label %if.then46.i.i

if.then46.i.i:                                    ; preds = %if.end38.i.i
  %cmp.i.i88.i = icmp eq i8 %23, 5
  %cmp.i17.i.i = icmp eq i8 %.pr.i.pre.i, 5
  %or.cond.i11 = or i1 %cmp.i.i88.i, %cmp.i17.i.i
  br i1 %or.cond.i11, label %if.then.i91.i, label %if.end.i.i

if.then.i91.i:                                    ; preds = %if.then46.i.i
  %or1.i.i92.i = or i16 %29, 8193
  store i16 %or1.i.i92.i, ptr %s, align 2
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i91.i, %if.then46.i.i
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %33 = load i8, ptr %default_nan_mode.i.i, align 1
  %34 = and i8 %33, 1
  %tobool.not.i.i = icmp eq i8 %34, 0
  br i1 %tobool.not.i.i, label %if.else.i90.i, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  store i8 4, ptr %pa.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.i.sroa.gep, align 8
  br label %soft_f64_div.exit

if.else.i90.i:                                    ; preds = %if.end.i.i
  %cmp.i18.i.i = icmp eq i64 %a.val.i.i, %28
  %cmp1.i.i.i = icmp ult i64 %a.val.i.i, %28
  %cmp11.i.i = icmp uge i64 %f.lobit.i.i, %f.lobit.i44.i
  %spec.select.i = select i1 %cmp.i18.i.i, i1 %cmp11.i.i, i1 %cmp1.i.i.i
  %spec.select.fr.i = freeze i1 %spec.select.i
  switch i8 %23, label %35 [
    i8 5, label %pickNaN.exit.i.i
    i8 4, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.else.i90.i
  br i1 %cmp.i17.i.i, label %soft_f64_div.exit, label %lor.lhs.false.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %if.then6.i.i.i
  %cmp.i11.i.i.i = icmp eq i8 %.pr.i.pre.i, 4
  %spec.select.i.i.i = and i1 %cmp.i11.i.i.i, %spec.select.fr.i
  %spec.select106.i = select i1 %spec.select.i.i.i, ptr %pb.i, ptr %pa.i
  br label %soft_f64_div.exit

pickNaN.exit.i.i:                                 ; preds = %if.else.i90.i
  %cmp.i8.i.i.i = icmp eq i8 %.pr.i.pre.i, 4
  %spec.select20.i.i = select i1 %cmp.i17.i.i, i1 %spec.select.fr.i, i1 %cmp.i8.i.i.i
  %spec.select20.i.i.not = xor i1 %spec.select20.i.i, true
  %brmerge = or i1 %cmp.i17.i.i, %spec.select20.i.i.not
  br i1 %brmerge, label %pickNaN.exit.i.i.if.then24.i.i_crit_edge, label %soft_f64_div.exit

pickNaN.exit.i.i.if.then24.i.i_crit_edge:         ; preds = %pickNaN.exit.i.i
  %pa.i.sroa.gep.mux = select i1 %spec.select20.i.i, ptr %pb.i.sroa.gep, ptr %pa.i.sroa.gep
  %pa.i.mux = select i1 %spec.select20.i.i, ptr %pb.i, ptr %pa.i
  %.pre = load i64, ptr %pa.i.sroa.gep.mux, align 8
  br label %if.then24.i.i

35:                                               ; preds = %if.else.i90.i
  br i1 %cmp.i17.i.i, label %if.then24.i.i, label %soft_f64_div.exit

if.then24.i.i:                                    ; preds = %pickNaN.exit.i.i.if.then24.i.i_crit_edge, %35
  %36 = phi i64 [ %28, %35 ], [ %.pre, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i101.i = phi ptr [ %pb.i, %35 ], [ %pa.i.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i101.i.sroa.phi = phi ptr [ %pb.i.sroa.gep, %35 ], [ %pa.i.sroa.gep.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %or4.i.i.i.i = or i64 %36, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.ph.i101.i.sroa.phi, align 8
  store i8 4, ptr %.ph.i101.i, align 8
  br label %soft_f64_div.exit

if.end48.i.i:                                     ; preds = %if.end38.i.i
  store i8 %31, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  switch i8 %23, label %if.end63.i.i [
    i8 3, label %soft_f64_div.exit
    i8 1, label %soft_f64_div.exit
  ]

if.end63.i.i:                                     ; preds = %if.end48.i.i
  switch i8 %.pr.i.pre.i, label %if.else.i.i [
    i8 3, label %if.then68.i.i
    i8 1, label %if.then75.i.i
  ]

if.then68.i.i:                                    ; preds = %if.end63.i.i
  store i8 1, ptr %pa.i, align 8
  br label %soft_f64_div.exit

if.then75.i.i:                                    ; preds = %if.end63.i.i
  %or1.i93.i = or i16 %29, 2
  store i16 %or1.i93.i, ptr %s, align 2
  store i8 3, ptr %pa.i, align 8
  br label %soft_f64_div.exit

if.else.i.i:                                      ; preds = %if.end63.i.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 644, ptr noundef nonnull @__func__.parts64_div, ptr noundef nonnull @.str.13) #16
  unreachable

d_nan.i.i:                                        ; preds = %if.then37.i.i, %parts64_canonicalize.exit82.i
  %.sink107.i = phi i16 [ 513, %if.then37.i.i ], [ 1025, %parts64_canonicalize.exit82.i ]
  %or1.i87.i = or i16 %29, %.sink107.i
  store i16 %or1.i87.i, ptr %s, align 2
  store i8 4, ptr %pa.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.i.sroa.gep, align 8
  br label %soft_f64_div.exit

soft_f64_div.exit:                                ; preds = %pickNaN.exit.i.i, %if.then.i.i10, %if.then3.i.i, %if.then6.i.i.i, %lor.lhs.false.i.i.i, %35, %if.then24.i.i, %if.end48.i.i, %if.end48.i.i, %if.then68.i.i, %if.then75.i.i, %d_nan.i.i
  %retval.i.0.i = phi ptr [ %pa.i, %if.then.i.i10 ], [ %pa.i, %d_nan.i.i ], [ %pa.i, %if.then68.i.i ], [ %pa.i, %if.then75.i.i ], [ %pa.i, %if.end48.i.i ], [ %pa.i, %if.end48.i.i ], [ %pa.i, %if.then3.i.i ], [ %.ph.i101.i, %if.then24.i.i ], [ %pb.i, %35 ], [ %pa.i, %if.then6.i.i.i ], [ %spec.select106.i, %lor.lhs.false.i.i.i ], [ %pb.i, %pickNaN.exit.i.i ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %retval.i.0.i, ptr noundef nonnull %s, ptr noundef nonnull @float64_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %retval.i.0.i, i64 1
  %37 = load i8, ptr %sign.i.i.i, align 1
  %38 = and i8 %37, 1
  %conv.i.i94.i = zext nneg i8 %38 to i64
  %shl.i.i95.i = shl nuw i64 %conv.i.i94.i, 63
  %exp.i.i.i = getelementptr inbounds i8, ptr %retval.i.0.i, i64 4
  %39 = load i32, ptr %exp.i.i.i, align 4
  %40 = and i32 %39, 2047
  %shl77.i.i.i = zext nneg i32 %40 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i95.i
  %41 = getelementptr inbounds i8, ptr %retval.i.0.i, i64 8
  %42 = load i64, ptr %41, align 8
  %shl77.i9.i.i = and i64 %42, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %pa.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %pb.i)
  br label %float64_gen2.exit

float64_gen2.exit:                                ; preds = %if.then24.i, %if.else.i, %soft_f64_div.exit
  %retval.i.0 = phi i64 [ %or.i10.i.i, %soft_f64_div.exit ], [ %13, %if.else.i ], [ %13, %if.then24.i ]
  ret i64 %retval.i.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64r32_div(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pb = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float64_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

float64_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %f.lobit.i.i4 = lshr i64 %b, 63
  %frombool.i.i.i5 = trunc i64 %f.lobit.i.i4 to i8
  %shr.i8.i.i6 = lshr i64 %b, 52
  %5 = trunc i64 %shr.i8.i.i6 to i32
  %conv.i.i.i7 = and i32 %5, 2047
  %and.i9.i.i8 = and i64 %b, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i5, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i.i7, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i9.i.i8, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  switch i32 %conv.i.i.i7, label %if.then33.i.i31 [
    i32 0, label %if.then.i.i19
    i32 2047, label %lor.lhs.false.i.i12
  ]

if.then.i.i19:                                    ; preds = %float64_unpack_canonical.exit
  %cmp.i.i.i20 = icmp eq i64 %and.i9.i.i8, 0
  br i1 %cmp.i.i.i20, label %if.then8.i.i30, label %if.else.i.i21

if.then8.i.i30:                                   ; preds = %if.then.i.i19
  store i8 1, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

if.else.i.i21:                                    ; preds = %if.then.i.i19
  %flush_inputs_to_zero.i.i22 = getelementptr inbounds i8, ptr %status, i64 6
  %6 = load i8, ptr %flush_inputs_to_zero.i.i22, align 2
  %7 = and i8 %6, 1
  %tobool9.not.i.i23 = icmp eq i8 %7, 0
  br i1 %tobool9.not.i.i23, label %frac64_normalize.exit.i.i26, label %if.then10.i.i24

if.then10.i.i24:                                  ; preds = %if.else.i.i21
  %8 = load i16, ptr %status, align 2
  %or1.i.i.i25 = or i16 %8, 32
  store i16 %or1.i.i.i25, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float64_unpack_canonical.exit35

frac64_normalize.exit.i.i26:                      ; preds = %if.else.i.i21
  %9 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i8, i1 true), !range !5
  %cast.i.i.i.i27 = trunc i64 %9 to i32
  %shl.i.i.i28 = shl i64 %and.i9.i.i8, %9
  store i64 %shl.i.i.i28, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i29 = sub nuw nsw i32 -1011, %cast.i.i.i.i27
  store i32 %add.i.i29, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  br label %float64_unpack_canonical.exit35

lor.lhs.false.i.i12:                              ; preds = %float64_unpack_canonical.exit
  %cmp.i29.i.i13 = icmp eq i64 %and.i9.i.i8, 0
  br i1 %cmp.i29.i.i13, label %if.then47.i.i18, label %if.else49.i.i14

if.then33.i.i31:                                  ; preds = %float64_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i32 = add nsw i32 %conv.i.i.i7, -1023
  store i32 %sub37.i.i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %shl.i28.i.i33 = shl nuw nsw i64 %and.i9.i.i8, 11
  %or.i.i34 = or disjoint i64 %shl.i28.i.i33, -9223372036854775808
  store i64 %or.i.i34, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float64_unpack_canonical.exit35

if.then47.i.i18:                                  ; preds = %lor.lhs.false.i.i12
  store i8 3, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

if.else49.i.i14:                                  ; preds = %lor.lhs.false.i.i12
  %shl.i31.i.i15 = shl nuw nsw i64 %and.i9.i.i8, 11
  store i64 %shl.i31.i.i15, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  %tobool.not.i32.i.i16 = icmp ult i64 %and.i9.i.i8, 2251799813685248
  %conv53.i.i17 = select i1 %tobool.not.i32.i.i16, i8 5, i8 4
  store i8 %conv53.i.i17, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

float64_unpack_canonical.exit35:                  ; preds = %if.then8.i.i30, %if.then10.i.i24, %frac64_normalize.exit.i.i26, %if.then33.i.i31, %if.then47.i.i18, %if.else49.i.i14
  %call = call fastcc ptr @parts64_div(ptr noundef nonnull %pa, ptr noundef nonnull %pb, ptr noundef %status)
  %call1 = call fastcc i64 @float64r32_round_pack_canonical(ptr noundef %call, ptr noundef %status)
  ret i64 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_div(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts64, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %f.lobit.i = lshr i16 %a, 15
  %frombool.i.i = trunc i16 %f.lobit.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %0, 255
  %conv.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 127
  %and.i10.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i10.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %trunc = trunc i16 %0 to i8
  switch i8 %trunc, label %if.then33.i [
    i8 0, label %if.then.i41
    i8 -1, label %lor.lhs.false.i
  ]

if.then.i41:                                      ; preds = %entry
  %cmp.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i, label %if.then8.i, label %if.else.i42

if.then8.i:                                       ; preds = %if.then.i41
  store i8 1, ptr %pa, align 8
  br label %parts64_canonicalize.exit

if.else.i42:                                      ; preds = %if.then.i41
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i, label %frac64_normalize.exit.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.else.i42
  %5 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %5, 32
  store i16 %or1.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_canonicalize.exit

frac64_normalize.exit.i:                          ; preds = %if.else.i42
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i, i1 true), !range !5
  %cast.i.i.i = trunc i64 %6 to i32
  %shl.i.i = shl i64 %and.i10.i, %6
  store i64 %shl.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i43 = sub nuw nsw i32 -70, %cast.i.i.i
  store i32 %add.i43, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_canonicalize.exit

lor.lhs.false.i:                                  ; preds = %entry
  %cmp.i29.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i, label %if.then47.i, label %if.else49.i

if.then33.i:                                      ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i = add nsw i32 %conv.i.i, -127
  store i32 %sub37.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %shl.i28.i = shl nuw nsw i64 %and.i10.i, 56
  %or.i40 = or disjoint i64 %shl.i28.i, -9223372036854775808
  store i64 %or.i40, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_canonicalize.exit

if.then47.i:                                      ; preds = %lor.lhs.false.i
  store i8 3, ptr %pa, align 8
  br label %parts64_canonicalize.exit

if.else49.i:                                      ; preds = %lor.lhs.false.i
  %shl.i31.i = shl nuw nsw i64 %and.i10.i, 56
  store i64 %shl.i31.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %tobool.not.i32.i = icmp ult i16 %2, 64
  %conv53.i = select i1 %tobool.not.i32.i, i8 5, i8 4
  store i8 %conv53.i, ptr %pa, align 8
  br label %parts64_canonicalize.exit

parts64_canonicalize.exit:                        ; preds = %if.then8.i, %if.then10.i, %frac64_normalize.exit.i, %if.then33.i, %if.then47.i, %if.else49.i
  %7 = phi i32 [ %conv.i.i, %if.then8.i ], [ %conv.i.i, %if.then10.i ], [ %add.i43, %frac64_normalize.exit.i ], [ %sub37.i, %if.then33.i ], [ %conv.i.i, %if.then47.i ], [ %conv.i.i, %if.else49.i ]
  %a.val.i = phi i64 [ 0, %if.then8.i ], [ 0, %if.then10.i ], [ %shl.i.i, %frac64_normalize.exit.i ], [ %or.i40, %if.then33.i ], [ 0, %if.then47.i ], [ %shl.i31.i, %if.else49.i ]
  %8 = phi i8 [ 1, %if.then8.i ], [ 1, %if.then10.i ], [ 2, %frac64_normalize.exit.i ], [ 2, %if.then33.i ], [ 3, %if.then47.i ], [ %conv53.i, %if.else49.i ]
  %f.lobit.i44 = lshr i16 %b, 15
  %frombool.i.i45 = trunc i16 %f.lobit.i44 to i8
  %9 = lshr i16 %b, 7
  %10 = and i16 %9, 255
  %conv.i.i46 = zext nneg i16 %10 to i32
  %11 = and i16 %b, 127
  %and.i10.i47 = zext nneg i16 %11 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i48 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i45, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i48, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i49 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i46, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i49, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i50 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i10.i47, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i50, align 8
  %trunc96 = trunc i16 %9 to i8
  switch i8 %trunc96, label %if.then33.i63 [
    i8 0, label %if.then.i67
    i8 -1, label %lor.lhs.false.i55
  ]

if.then.i67:                                      ; preds = %parts64_canonicalize.exit
  %cmp.i.i69 = icmp eq i16 %11, 0
  br i1 %cmp.i.i69, label %if.then8.i80, label %if.else.i70

if.then8.i80:                                     ; preds = %if.then.i67
  store i8 1, ptr %pb, align 8
  br label %parts64_canonicalize.exit81

if.else.i70:                                      ; preds = %if.then.i67
  %flush_inputs_to_zero.i71 = getelementptr inbounds i8, ptr %status, i64 6
  %12 = load i8, ptr %flush_inputs_to_zero.i71, align 2
  %13 = and i8 %12, 1
  %tobool9.not.i72 = icmp eq i8 %13, 0
  br i1 %tobool9.not.i72, label %frac64_normalize.exit.i75, label %if.then10.i73

if.then10.i73:                                    ; preds = %if.else.i70
  %14 = load i16, ptr %status, align 2
  %or1.i.i74 = or i16 %14, 32
  store i16 %or1.i.i74, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i50, align 8
  br label %parts64_canonicalize.exit81

frac64_normalize.exit.i75:                        ; preds = %if.else.i70
  %15 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i47, i1 true), !range !5
  %cast.i.i.i76 = trunc i64 %15 to i32
  %shl.i.i77 = shl i64 %and.i10.i47, %15
  store i64 %shl.i.i77, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i50, align 8
  store i8 2, ptr %pb, align 8
  %add.i79 = sub nuw nsw i32 -70, %cast.i.i.i76
  store i32 %add.i79, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i49, align 4
  br label %parts64_canonicalize.exit81

lor.lhs.false.i55:                                ; preds = %parts64_canonicalize.exit
  %cmp.i29.i57 = icmp eq i16 %11, 0
  br i1 %cmp.i29.i57, label %if.then47.i62, label %if.else49.i58

if.then33.i63:                                    ; preds = %parts64_canonicalize.exit
  store i8 2, ptr %pb, align 8
  %sub37.i64 = add nsw i32 %conv.i.i46, -127
  store i32 %sub37.i64, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i49, align 4
  %shl.i28.i65 = shl nuw nsw i64 %and.i10.i47, 56
  %or.i66 = or disjoint i64 %shl.i28.i65, -9223372036854775808
  store i64 %or.i66, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i50, align 8
  br label %parts64_canonicalize.exit81

if.then47.i62:                                    ; preds = %lor.lhs.false.i55
  store i8 3, ptr %pb, align 8
  br label %parts64_canonicalize.exit81

if.else49.i58:                                    ; preds = %lor.lhs.false.i55
  %shl.i31.i59 = shl nuw nsw i64 %and.i10.i47, 56
  store i64 %shl.i31.i59, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i50, align 8
  %tobool.not.i32.i60 = icmp ult i16 %11, 64
  %conv53.i61 = select i1 %tobool.not.i32.i60, i8 5, i8 4
  store i8 %conv53.i61, ptr %pb, align 8
  br label %parts64_canonicalize.exit81

parts64_canonicalize.exit81:                      ; preds = %if.then8.i80, %if.then10.i73, %frac64_normalize.exit.i75, %if.then33.i63, %if.then47.i62, %if.else49.i58
  %b.val.i = phi i64 [ 0, %if.then8.i80 ], [ 0, %if.then10.i73 ], [ %shl.i.i77, %frac64_normalize.exit.i75 ], [ %or.i66, %if.then33.i63 ], [ 0, %if.then47.i62 ], [ %shl.i31.i59, %if.else49.i58 ]
  %16 = phi i32 [ %conv.i.i46, %if.then8.i80 ], [ %conv.i.i46, %if.then10.i73 ], [ %add.i79, %frac64_normalize.exit.i75 ], [ %sub37.i64, %if.then33.i63 ], [ %conv.i.i46, %if.then47.i62 ], [ %conv.i.i46, %if.else49.i58 ]
  %.pr.i.pre = phi i8 [ 1, %if.then8.i80 ], [ 1, %if.then10.i73 ], [ 2, %frac64_normalize.exit.i75 ], [ 2, %if.then33.i63 ], [ 3, %if.then47.i62 ], [ %conv53.i61, %if.else49.i58 ]
  %conv.i = zext nneg i8 %8 to i32
  %shl.i = shl nuw nsw i32 1, %conv.i
  %conv2.i = zext nneg i8 %.pr.i.pre to i32
  %shl3.i = shl nuw nsw i32 1, %conv2.i
  %or.i = or i32 %shl.i, %shl3.i
  %17 = xor i8 %frombool.i.i45, %frombool.i.i
  %trunc100 = trunc i32 %or.i to i8
  switch i8 %trunc100, label %if.end38.i [
    i8 4, label %if.then.i
    i8 2, label %d_nan.i
    i8 8, label %if.then37.i
  ]

if.then.i:                                        ; preds = %parts64_canonicalize.exit81
  store i8 %17, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  %cmp.i82 = icmp ult i64 %a.val.i, %b.val.i
  %shl.i83 = shl i64 %a.val.i, 63
  %not.cmp.i = xor i1 %cmp.i82, true
  %shr.i = zext i1 %not.cmp.i to i64
  %n0.0.i = lshr i64 %a.val.i, %shr.i
  %n1.0.i = select i1 %cmp.i82, i64 0, i64 %shl.i83
  %18 = tail call { i64, i64 } asm "divq $4", "={ax},={dx},0,1,rm,~{dirflag},~{fpsr},~{flags}"(i64 %n1.0.i, i64 %n0.0.i, i64 %b.val.i) #18, !srcloc !7
  %asmresult.i.i = extractvalue { i64, i64 } %18, 0
  %asmresult1.i.i = extractvalue { i64, i64 } %18, 1
  %cmp1.i = icmp ne i64 %asmresult1.i.i, 0
  %conv2.i84 = zext i1 %cmp1.i to i64
  %or.i85 = or i64 %asmresult.i.i, %conv2.i84
  store i64 %or.i85, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %conv17.i.neg97 = sext i1 %cmp.i82 to i32
  %add.i.neg = sub nsw i32 %conv17.i.neg97, %16
  %sub.i = add nsw i32 %add.i.neg, %7
  store i32 %sub.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_div.exit

if.then37.i:                                      ; preds = %parts64_canonicalize.exit81
  br label %d_nan.i

if.end38.i:                                       ; preds = %parts64_canonicalize.exit81
  %and.i = and i32 %or.i, 48
  %tobool39.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool39.i.not, label %if.end48.i, label %if.then46.i

if.then46.i:                                      ; preds = %if.end38.i
  %cmp.i.i87 = icmp eq i8 %8, 5
  %cmp.i17.i = icmp eq i8 %.pr.i.pre, 5
  %or.cond = or i1 %cmp.i17.i, %cmp.i.i87
  br i1 %or.cond, label %if.then.i90, label %if.end.i

if.then.i90:                                      ; preds = %if.then46.i
  %19 = load i16, ptr %status, align 2
  %or1.i.i91 = or i16 %19, 8193
  store i16 %or1.i.i91, ptr %status, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %if.then46.i, %if.then.i90
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %20 = load i8, ptr %default_nan_mode.i, align 1
  %21 = and i8 %20, 1
  %tobool.not.i = icmp eq i8 %21, 0
  br i1 %tobool.not.i, label %if.else.i89, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_div.exit

if.else.i89:                                      ; preds = %if.end.i
  %cmp.i18.i = icmp eq i64 %a.val.i, %b.val.i
  %cmp1.i.i = icmp ult i64 %a.val.i, %b.val.i
  %cmp11.i = icmp uge i16 %f.lobit.i, %f.lobit.i44
  %spec.select = select i1 %cmp.i18.i, i1 %cmp11.i, i1 %cmp1.i.i
  %spec.select.fr = freeze i1 %spec.select
  switch i8 %8, label %22 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.else.i89
  br i1 %cmp.i17.i, label %parts64_div.exit, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select.i.i = and i1 %cmp.i11.i.i, %spec.select.fr
  %spec.select108 = select i1 %spec.select.i.i, ptr %pb, ptr %pa
  br label %parts64_div.exit

pickNaN.exit.i:                                   ; preds = %if.else.i89
  %cmp.i8.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select20.i = select i1 %cmp.i17.i, i1 %spec.select.fr, i1 %cmp.i8.i.i
  br i1 %spec.select20.i, label %22, label %if.then24.i

22:                                               ; preds = %if.else.i89, %pickNaN.exit.i
  %23 = icmp eq i8 %.pr.i.pre, 5
  br i1 %23, label %if.then24.i, label %parts64_div.exit

if.then24.i:                                      ; preds = %pickNaN.exit.i, %22
  %.ph.i103 = phi ptr [ %pb, %22 ], [ %pa, %pickNaN.exit.i ]
  %.ph.i103.sroa.phi = phi ptr [ %pb.sroa.gep, %22 ], [ %pa.sroa.gep, %pickNaN.exit.i ]
  %24 = load i64, ptr %.ph.i103.sroa.phi, align 8
  %or4.i.i.i = or i64 %24, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.ph.i103.sroa.phi, align 8
  store i8 4, ptr %.ph.i103, align 8
  br label %parts64_div.exit

if.end48.i:                                       ; preds = %if.end38.i
  store i8 %17, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  switch i8 %8, label %if.end63.i [
    i8 3, label %parts64_div.exit
    i8 1, label %parts64_div.exit
  ]

if.end63.i:                                       ; preds = %if.end48.i
  switch i8 %.pr.i.pre, label %if.else.i [
    i8 3, label %if.then68.i
    i8 1, label %if.then75.i
  ]

if.then68.i:                                      ; preds = %if.end63.i
  store i8 1, ptr %pa, align 8
  br label %parts64_div.exit

if.then75.i:                                      ; preds = %if.end63.i
  %25 = load i16, ptr %status, align 2
  %or1.i92 = or i16 %25, 2
  store i16 %or1.i92, ptr %status, align 2
  store i8 3, ptr %pa, align 8
  br label %parts64_div.exit

if.else.i:                                        ; preds = %if.end63.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 644, ptr noundef nonnull @__func__.parts64_div, ptr noundef nonnull @.str.13) #16
  unreachable

d_nan.i:                                          ; preds = %parts64_canonicalize.exit81, %if.then37.i
  %.sink109 = phi i16 [ 513, %if.then37.i ], [ 1025, %parts64_canonicalize.exit81 ]
  %26 = load i16, ptr %status, align 2
  %or1.i86 = or i16 %26, %.sink109
  store i16 %or1.i86, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_div.exit

parts64_div.exit:                                 ; preds = %lor.lhs.false.i.i, %if.then24.i, %22, %if.then6.i.i, %if.then3.i, %if.end48.i, %if.end48.i, %d_nan.i, %if.then75.i, %if.then68.i, %if.then.i
  %retval.i.0 = phi ptr [ %pa, %if.then.i ], [ %pa, %d_nan.i ], [ %pa, %if.then68.i ], [ %pa, %if.then75.i ], [ %pa, %if.end48.i ], [ %pa, %if.end48.i ], [ %pa, %if.then3.i ], [ %.ph.i103, %if.then24.i ], [ %pb, %22 ], [ %pa, %if.then6.i.i ], [ %spec.select108, %lor.lhs.false.i.i ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %retval.i.0, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 1
  %27 = load i8, ptr %sign.i.i, align 1
  %conv.i.i93 = zext i8 %27 to i64
  %shl.i.i94 = shl nuw nsw i64 %conv.i.i93, 15
  %exp.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 4
  %28 = load i32, ptr %exp.i.i, align 4
  %29 = shl i32 %28, 7
  %30 = and i32 %29, 32640
  %and8.i.i = zext nneg i32 %30 to i64
  %or.i.i = or disjoint i64 %shl.i.i94, %and8.i.i
  %31 = getelementptr inbounds i8, ptr %retval.i.0, i64 8
  %32 = load i64, ptr %31, align 8
  %shl77.i9.i = and i64 %32, 127
  %or.i10.i = or disjoint i64 %or.i.i, %shl77.i9.i
  %conv.i95 = trunc i64 %or.i10.i to i16
  ret i16 %conv.i95
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_div(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts128, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts128, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %shr.i16.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i to i32
  %conv.i42 = and i32 %0, 32767
  %f.coerce1.lobit.i = lshr i64 %a.coerce1, 63
  %frombool.i = trunc i64 %f.coerce1.lobit.i to i8
  %and.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %pa, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i42, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pa, ptr noundef %status, ptr noundef nonnull @float128_params)
  %shr.i16.i43 = lshr i64 %b.coerce1, 48
  %1 = trunc i64 %shr.i16.i43 to i32
  %conv.i44 = and i32 %1, 32767
  %f.coerce1.lobit.i45 = lshr i64 %b.coerce1, 63
  %frombool.i46 = trunc i64 %f.coerce1.lobit.i45 to i8
  %and.i.i47 = and i64 %b.coerce1, 281474976710655
  store i8 0, ptr %pb, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i48 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i46, ptr %.compoundliteral.sroa.2.0..sroa_idx.i48, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i49 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i44, ptr %.compoundliteral.sroa.33.0..sroa_idx.i49, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i50 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i.i47, ptr %.compoundliteral.sroa.4.0..sroa_idx.i50, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i51 = getelementptr inbounds i8, ptr %pb, i64 16
  store i64 %b.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i51, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pb, ptr noundef %status, ptr noundef nonnull @float128_params)
  %2 = load i8, ptr %pa, align 8
  %conv.i = zext nneg i8 %2 to i32
  %shl.i = shl nuw i32 1, %conv.i
  %3 = load i8, ptr %pb, align 8
  %conv2.i = zext nneg i8 %3 to i32
  %shl3.i = shl nuw i32 1, %conv2.i
  %or.i = or i32 %shl3.i, %shl.i
  %4 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %5 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i48, align 1
  %6 = xor i8 %5, %4
  %xor.i40 = and i8 %6, 1
  switch i32 %or.i, label %if.end38.i [
    i32 4, label %if.then.i
    i32 2, label %d_nan.i
    i32 8, label %if.then37.i
  ]

if.then.i:                                        ; preds = %entry
  store i8 %xor.i40, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %7 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i49, align 4
  %pb.val = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i50, align 8
  %pb.val41 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i51, align 8
  %call.i9 = call fastcc zeroext i1 @frac128_div(ptr noundef nonnull %pa, i64 %pb.val, i64 %pb.val41)
  %conv17.i.neg77 = sext i1 %call.i9 to i32
  %8 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %add.i.neg = sub i32 %conv17.i.neg77, %7
  %sub.i = add i32 %add.i.neg, %8
  store i32 %sub.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %.pr.pre = load i8, ptr %pa, align 8
  br label %parts128_div.exit

if.then37.i:                                      ; preds = %entry
  br label %d_nan.i

if.end38.i:                                       ; preds = %entry
  %and.i = and i32 %or.i, 48
  %tobool39.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool39.i.not, label %if.end48.i, label %if.then46.i

if.then46.i:                                      ; preds = %if.end38.i
  %cmp.i.i = icmp eq i8 %2, 5
  %cmp.i17.i = icmp eq i8 %3, 5
  %or.cond = or i1 %cmp.i.i, %cmp.i17.i
  br i1 %or.cond, label %if.then.i54, label %if.end.i

if.then.i54:                                      ; preds = %if.then46.i
  %9 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %9, 8193
  store i16 %or1.i.i, ptr %status, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %if.then46.i, %if.then.i54
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %10 = load i8, ptr %default_nan_mode.i, align 1
  %11 = and i8 %10, 1
  %tobool.not.i = icmp eq i8 %11, 0
  br i1 %tobool.not.i, label %if.else.i53, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %do.end18.i

if.else.i53:                                      ; preds = %if.end.i
  %12 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %13 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i50, align 8
  %cmp.i18.i = icmp eq i64 %12, %13
  br i1 %cmp.i18.i, label %if.then.i.i, label %frac128_cmp.exit.i

if.then.i.i:                                      ; preds = %if.else.i53
  %14 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %15 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i51, align 8
  %cmp3.i.i = icmp eq i64 %14, %15
  br i1 %cmp3.i.i, label %if.then6.i, label %frac128_cmp.exit.i

frac128_cmp.exit.i:                               ; preds = %if.then.i.i, %if.else.i53
  %ta.0.i.i = phi i64 [ %14, %if.then.i.i ], [ %12, %if.else.i53 ]
  %tb.0.i.i = phi i64 [ %15, %if.then.i.i ], [ %13, %if.else.i53 ]
  %cmp6.i.i = icmp ult i64 %ta.0.i.i, %tb.0.i.i
  br label %if.end13.i

if.then6.i:                                       ; preds = %if.then.i.i
  %16 = and i8 %4, 1
  %17 = and i8 %5, 1
  %cmp11.i = icmp uge i8 %16, %17
  br label %if.end13.i

if.end13.i:                                       ; preds = %if.then6.i, %frac128_cmp.exit.i
  %cmp.0.i = phi i1 [ %cmp11.i, %if.then6.i ], [ %cmp6.i.i, %frac128_cmp.exit.i ]
  switch i8 %2, label %18 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end13.i
  br i1 %cmp.i17.i, label %do.end18.i, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %3, 4
  %spec.select.i.i = and i1 %cmp.i11.i.i, %cmp.0.i
  %cond.fr31.i = freeze i1 %spec.select.i.i
  br i1 %cond.fr31.i, label %parts128_div.exit, label %do.end18.i

pickNaN.exit.i:                                   ; preds = %if.end13.i
  %cmp.i8.i.i = icmp eq i8 %3, 4
  %spec.select25.i = select i1 %cmp.i17.i, i1 %cmp.0.i, i1 %cmp.i8.i.i
  %cond.fr.i = freeze i1 %spec.select25.i
  br i1 %cond.fr.i, label %18, label %if.then24.i

18:                                               ; preds = %if.end13.i, %pickNaN.exit.i
  %cmp.i21.i = icmp eq i8 %3, 5
  br i1 %cmp.i21.i, label %if.then24.i, label %parts128_div.exit

if.then24.i:                                      ; preds = %pickNaN.exit.i, %18
  %.ph.i83 = phi ptr [ %pb, %18 ], [ %pa, %pickNaN.exit.i ]
  %.ph.i83.sroa.phi = phi ptr [ %pb.sroa.gep, %18 ], [ %pa.sroa.gep, %pickNaN.exit.i ]
  %19 = load i64, ptr %.ph.i83.sroa.phi, align 8
  %or4.i.i.i = or i64 %19, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.ph.i83.sroa.phi, align 8
  store i8 4, ptr %.ph.i83, align 8
  br label %do.end18.i

if.end48.i:                                       ; preds = %if.end38.i
  store i8 %xor.i40, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  switch i8 %2, label %if.end63.i [
    i8 3, label %parts128_div.exit
    i8 1, label %parts128_div.exit
  ]

if.end63.i:                                       ; preds = %if.end48.i
  switch i8 %3, label %if.else.i [
    i8 3, label %sw.bb.i
    i8 1, label %parts128_div.exit.thread74
  ]

parts128_div.exit.thread74:                       ; preds = %if.end63.i
  %20 = load i16, ptr %status, align 2
  %or1.i55 = or i16 %20, 2
  store i16 %or1.i55, ptr %status, align 2
  br label %do.end.i

if.else.i:                                        ; preds = %if.end63.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 644, ptr noundef nonnull @__func__.parts128_div, ptr noundef nonnull @.str.13) #16
  unreachable

d_nan.i:                                          ; preds = %entry, %if.then37.i
  %.sink91 = phi i16 [ 513, %if.then37.i ], [ 1025, %entry ]
  %21 = load i16, ptr %status, align 2
  %or1.i52 = or i16 %21, %.sink91
  store i16 %or1.i52, ptr %status, align 2
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %do.end18.i

parts128_div.exit:                                ; preds = %lor.lhs.false.i.i, %if.end48.i, %if.end48.i, %if.then.i, %18
  %22 = phi i8 [ %3, %18 ], [ %.pr.pre, %if.then.i ], [ %2, %if.end48.i ], [ %2, %if.end48.i ], [ %3, %lor.lhs.false.i.i ]
  %retval.i7.0 = phi ptr [ %pb, %18 ], [ %pa, %if.then.i ], [ %pa, %if.end48.i ], [ %pa, %if.end48.i ], [ %pb, %lor.lhs.false.i.i ]
  switch i8 %22, label %do.body21.i [
    i8 2, label %if.then.i61
    i8 1, label %sw.bb.i
    i8 3, label %do.end.i
    i8 4, label %do.end18.i
    i8 5, label %do.end18.i
  ]

if.then.i61:                                      ; preds = %parts128_div.exit
  call fastcc void @parts128_uncanon_normal(ptr noundef nonnull %retval.i7.0, ptr noundef %status, ptr noundef nonnull @float128_params)
  %exp.i63.phi.trans.insert = getelementptr inbounds i8, ptr %retval.i7.0, i64 4
  %.pre = load i32, ptr %exp.i63.phi.trans.insert, align 4
  %23 = zext i32 %.pre to i64
  %24 = shl i64 %23, 48
  %25 = and i64 %24, 9223090561878065152
  br label %parts128_uncanon.exit

sw.bb.i:                                          ; preds = %if.end63.i, %parts128_div.exit
  %retval.i7.073 = phi ptr [ %retval.i7.0, %parts128_div.exit ], [ %pa, %if.end63.i ]
  %exp.i60 = getelementptr inbounds i8, ptr %retval.i7.073, i64 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(20) %exp.i60, i8 0, i64 20, i1 false)
  br label %parts128_uncanon.exit

do.end.i:                                         ; preds = %parts128_div.exit.thread74, %parts128_div.exit
  %retval.i7.076 = phi ptr [ %pa, %parts128_div.exit.thread74 ], [ %retval.i7.0, %parts128_div.exit ]
  %exp10.i = getelementptr inbounds i8, ptr %retval.i7.076, i64 4
  store i32 32767, ptr %exp10.i, align 4
  %frac_hi.i14.i = getelementptr inbounds i8, ptr %retval.i7.076, i64 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %frac_hi.i14.i, i8 0, i64 16, i1 false)
  br label %parts128_uncanon.exit

do.end18.i:                                       ; preds = %lor.lhs.false.i.i, %if.then6.i.i, %d_nan.i, %if.then3.i, %if.then24.i, %parts128_div.exit, %parts128_div.exit
  %retval.i7.069 = phi ptr [ %retval.i7.0, %parts128_div.exit ], [ %retval.i7.0, %parts128_div.exit ], [ %.ph.i83, %if.then24.i ], [ %pa, %if.then3.i ], [ %pa, %d_nan.i ], [ %pa, %if.then6.i.i ], [ %pa, %lor.lhs.false.i.i ]
  %exp20.i = getelementptr inbounds i8, ptr %retval.i7.069, i64 4
  store i32 32767, ptr %exp20.i, align 4
  %frac_hi.i15.i = getelementptr inbounds i8, ptr %retval.i7.069, i64 8
  %26 = load i64, ptr %frac_hi.i15.i, align 8
  %frac_lo.i.i59 = getelementptr inbounds i8, ptr %retval.i7.069, i64 16
  %27 = load i64, ptr %frac_lo.i.i59, align 8
  %28 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %26, i32 15, i64 %27) #15, !srcloc !6
  %shr.i.i = lshr i64 %26, 15
  store i64 %shr.i.i, ptr %frac_hi.i15.i, align 8
  store i64 %28, ptr %frac_lo.i.i59, align 8
  br label %parts128_uncanon.exit

do.body21.i:                                      ; preds = %parts128_div.exit
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 330, ptr noundef nonnull @__func__.parts128_uncanon, ptr noundef null) #16
  unreachable

parts128_uncanon.exit:                            ; preds = %if.then.i61, %sw.bb.i, %do.end.i, %do.end18.i
  %conv1.i = phi i64 [ %25, %if.then.i61 ], [ 0, %sw.bb.i ], [ 9223090561878065152, %do.end.i ], [ 9223090561878065152, %do.end18.i ]
  %retval.i7.070 = phi ptr [ %retval.i7.0, %if.then.i61 ], [ %retval.i7.073, %sw.bb.i ], [ %retval.i7.076, %do.end.i ], [ %retval.i7.069, %do.end18.i ]
  %sign.i62 = getelementptr inbounds i8, ptr %retval.i7.070, i64 1
  %29 = load i8, ptr %sign.i62, align 1
  %frac_hi.i = getelementptr inbounds i8, ptr %retval.i7.070, i64 8
  %30 = load i64, ptr %frac_hi.i, align 8
  %31 = and i8 %29, 1
  %conv.i64 = zext nneg i8 %31 to i64
  %shl.i65 = shl nuw i64 %conv.i64, 63
  %or.i25.i = or disjoint i64 %conv1.i, %shl.i65
  %and8.i.i = and i64 %30, 281474976710655
  %or.i.i = or disjoint i64 %or.i25.i, %and8.i.i
  %frac_lo.i = getelementptr inbounds i8, ptr %retval.i7.070, i64 16
  %32 = load i64, ptr %frac_lo.i, align 8
  %.fca.0.insert.i = insertvalue { i64, i64 } poison, i64 %32, 0
  %.fca.1.insert.i = insertvalue { i64, i64 } %.fca.0.insert.i, i64 %or.i.i, 1
  ret { i64, i64 } %.fca.1.insert.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @floatx80_div(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts128, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts128, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %floatx80_rounding_precision.i = getelementptr inbounds i8, ptr %status, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i = icmp ult i8 %0, 3
  br i1 %switch.i, label %sw.epilog.i, label %do.body.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %entry
  %cmp.i.i = icmp slt i64 %a.coerce0, 0
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i.i = icmp eq i16 %1, 0
  %.not.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  br i1 %.not.i, label %if.end.i, label %floatx80_unpack_canonical.exit

if.end.i:                                         ; preds = %sw.epilog.i
  %f.coerce1.lobit.i.i = lshr i16 %a.coerce1, 15
  %frombool.i.i = trunc i16 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %pa, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %and.i.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i64 %a.coerce0, ptr %pa.sroa.gep, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.not.i = icmp eq i16 %1, 32767
  br i1 %cmp.not.i, label %lor.lhs.false.thread, label %lor.lhs.false

lor.lhs.false.thread:                             ; preds = %if.end.i
  %and.i = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i, ptr %pa.sroa.gep, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %2 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i.i = icmp eq i64 %2, 0
  %3 = select i1 %tobool.not.i.i, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %3
  store i8 %cond17.i, ptr %pa, align 8
  br label %sw.epilog.i8

floatx80_unpack_canonical.exit:                   ; preds = %sw.epilog.i
  %4 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %4, 1
  store i16 %or1.i.i, ptr %status, align 2
  br label %return

lor.lhs.false:                                    ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pa, ptr noundef nonnull %status, ptr noundef nonnull @floatx80_params)
  %.pre = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i6 = icmp ult i8 %.pre, 3
  br i1 %switch.i6, label %sw.epilog.i8, label %do.body.i7

do.body.i7:                                       ; preds = %lor.lhs.false
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i8:                                     ; preds = %lor.lhs.false.thread, %lor.lhs.false
  %cmp.i.i9 = icmp slt i64 %b.coerce0, 0
  %5 = and i16 %b.coerce1, 32767
  %cmp2.i.i10 = icmp eq i16 %5, 0
  %.not.i11 = select i1 %cmp.i.i9, i1 true, i1 %cmp2.i.i10
  br i1 %.not.i11, label %if.end.i14, label %floatx80_unpack_canonical.exit29

if.end.i14:                                       ; preds = %sw.epilog.i8
  %f.coerce1.lobit.i.i15 = lshr i16 %b.coerce1, 15
  %frombool.i.i16 = trunc i16 %f.coerce1.lobit.i.i15 to i8
  %and.i.i.i17 = zext nneg i16 %5 to i32
  store i8 0, ptr %pb, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i18 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i16, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i18, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i19 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %and.i.i.i17, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i19, align 4
  store i64 %b.coerce0, ptr %pb.sroa.gep, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i21 = getelementptr inbounds i8, ptr %pb, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i21, align 8
  %cmp.not.i22 = icmp eq i16 %5, 32767
  br i1 %cmp.not.i22, label %if.else.i24, label %if.then10.i23

if.then10.i23:                                    ; preds = %if.end.i14
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pb, ptr noundef nonnull %status, ptr noundef nonnull @floatx80_params)
  %.pr = load i8, ptr %pb, align 8
  %.pre36 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i18, align 1
  br label %if.end

if.else.i24:                                      ; preds = %if.end.i14
  %and.i25 = and i64 %b.coerce0, 9223372036854775807
  store i64 %and.i25, ptr %pb.sroa.gep, align 8
  %cmp12.i26 = icmp eq i64 %and.i25, 0
  %6 = and i64 %b.coerce0, 4611686018427387904
  %tobool.not.i.i27 = icmp eq i64 %6, 0
  %7 = select i1 %tobool.not.i.i27, i8 5, i8 4
  %cond17.i28 = select i1 %cmp12.i26, i8 3, i8 %7
  store i8 %cond17.i28, ptr %pb, align 8
  br label %if.end

floatx80_unpack_canonical.exit29:                 ; preds = %sw.epilog.i8
  %8 = load i16, ptr %status, align 2
  %or1.i.i13 = or i16 %8, 1
  store i16 %or1.i.i13, ptr %status, align 2
  br label %return

if.end:                                           ; preds = %if.then10.i23, %if.else.i24
  %9 = phi i8 [ %.pre36, %if.then10.i23 ], [ %frombool.i.i16, %if.else.i24 ]
  %10 = phi i8 [ %.pr, %if.then10.i23 ], [ %cond17.i28, %if.else.i24 ]
  %11 = load i8, ptr %pa, align 8
  %conv.i = zext nneg i8 %11 to i32
  %shl.i = shl nuw i32 1, %conv.i
  %conv2.i = zext nneg i8 %10 to i32
  %shl3.i = shl nuw i32 1, %conv2.i
  %or.i = or i32 %shl.i, %shl3.i
  %12 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %13 = xor i8 %9, %12
  %xor32.i = and i8 %13, 1
  switch i32 %or.i, label %if.end38.i [
    i32 4, label %if.then.i32
    i32 2, label %d_nan.i
    i32 8, label %if.then37.i
  ]

if.then.i32:                                      ; preds = %if.end
  store i8 %xor32.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %14 = load i32, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i19, align 4
  %b.val.i = load i64, ptr %pb.sroa.gep, align 8
  %b.val33.i = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i21, align 8
  %call.i = call fastcc zeroext i1 @frac128_div(ptr noundef nonnull %pa, i64 %b.val.i, i64 %b.val33.i)
  %conv17.neg36.i = sext i1 %call.i to i32
  %15 = load i32, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %add.neg.i = sub i32 %conv17.neg36.i, %14
  %sub.i = add i32 %add.neg.i, %15
  store i32 %sub.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  br label %parts128_div.exit

if.then37.i:                                      ; preds = %if.end
  br label %d_nan.i

if.end38.i:                                       ; preds = %if.end
  %and.i33 = and i32 %or.i, 48
  %tobool39.not.i = icmp eq i32 %and.i33, 0
  br i1 %tobool39.not.i, label %if.end48.i, label %if.then46.i

if.then46.i:                                      ; preds = %if.end38.i
  %cmp.i.i.i = icmp eq i8 %11, 5
  %cmp.i17.i.i = icmp eq i8 %10, 5
  %or.cond.i = or i1 %cmp.i17.i.i, %cmp.i.i.i
  br i1 %or.cond.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %if.then46.i
  %16 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %16, 8193
  store i16 %or1.i.i.i, ptr %status, align 2
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i.i, %if.then46.i
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %17 = load i8, ptr %default_nan_mode.i.i, align 1
  %18 = and i8 %17, 1
  %tobool.not.i.i34 = icmp eq i8 %18, 0
  br i1 %tobool.not.i.i34, label %if.else.i.i, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %parts128_div.exit

if.else.i.i:                                      ; preds = %if.end.i.i
  %19 = load i64, ptr %pa.sroa.gep, align 8
  %20 = load i64, ptr %pb.sroa.gep, align 8
  %cmp.i18.i.i = icmp eq i64 %19, %20
  br i1 %cmp.i18.i.i, label %if.then.i.i.i, label %frac128_cmp.exit.i.i

if.then.i.i.i:                                    ; preds = %if.else.i.i
  %21 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %22 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i21, align 8
  %cmp3.i.i.i = icmp eq i64 %21, %22
  br i1 %cmp3.i.i.i, label %if.then6.i.i, label %frac128_cmp.exit.i.i

frac128_cmp.exit.i.i:                             ; preds = %if.then.i.i.i, %if.else.i.i
  %ta.0.i.i.i = phi i64 [ %21, %if.then.i.i.i ], [ %19, %if.else.i.i ]
  %tb.0.i.i.i = phi i64 [ %22, %if.then.i.i.i ], [ %20, %if.else.i.i ]
  %cmp6.i.i.i = icmp ult i64 %ta.0.i.i.i, %tb.0.i.i.i
  br label %if.end13.i.i

if.then6.i.i:                                     ; preds = %if.then.i.i.i
  %23 = and i8 %12, 1
  %24 = and i8 %9, 1
  %cmp11.i.i = icmp uge i8 %23, %24
  br label %if.end13.i.i

if.end13.i.i:                                     ; preds = %if.then6.i.i, %frac128_cmp.exit.i.i
  %cmp.0.i.i = phi i1 [ %cmp11.i.i, %if.then6.i.i ], [ %cmp6.i.i.i, %frac128_cmp.exit.i.i ]
  switch i8 %11, label %25 [
    i8 5, label %pickNaN.exit.i.i
    i8 4, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end13.i.i
  br i1 %cmp.i17.i.i, label %parts128_div.exit, label %lor.lhs.false.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %if.then6.i.i.i
  %cmp.i11.i.i.i = icmp eq i8 %10, 4
  %spec.select.i.i.i = and i1 %cmp.i11.i.i.i, %cmp.0.i.i
  %cond.fr31.i.i = freeze i1 %spec.select.i.i.i
  %spec.select.i = select i1 %cond.fr31.i.i, ptr %pb, ptr %pa
  br label %parts128_div.exit

pickNaN.exit.i.i:                                 ; preds = %if.end13.i.i
  %cmp.i8.i.i.i = icmp eq i8 %10, 4
  %spec.select25.i.i = select i1 %cmp.i17.i.i, i1 %cmp.0.i.i, i1 %cmp.i8.i.i.i
  %cond.fr.i.i = freeze i1 %spec.select25.i.i
  %cond.fr.i.i.not = xor i1 %cond.fr.i.i, true
  %brmerge = or i1 %cmp.i17.i.i, %cond.fr.i.i.not
  br i1 %brmerge, label %pickNaN.exit.i.i.if.then24.i.i_crit_edge, label %parts128_div.exit

pickNaN.exit.i.i.if.then24.i.i_crit_edge:         ; preds = %pickNaN.exit.i.i
  %pa.sroa.gep.mux = select i1 %cond.fr.i.i, ptr %pb.sroa.gep, ptr %pa.sroa.gep
  %pa.mux = select i1 %cond.fr.i.i, ptr %pb, ptr %pa
  %.pre37 = load i64, ptr %pa.sroa.gep.mux, align 8
  br label %if.then24.i.i

25:                                               ; preds = %if.end13.i.i
  br i1 %cmp.i17.i.i, label %if.then24.i.i, label %parts128_div.exit

if.then24.i.i:                                    ; preds = %pickNaN.exit.i.i.if.then24.i.i_crit_edge, %25
  %26 = phi i64 [ %20, %25 ], [ %.pre37, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i40.i = phi ptr [ %pb, %25 ], [ %pa.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i40.i.sroa.phi = phi ptr [ %pb.sroa.gep, %25 ], [ %pa.sroa.gep.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %or4.i.i.i.i = or i64 %26, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.ph.i40.i.sroa.phi, align 8
  store i8 4, ptr %.ph.i40.i, align 8
  br label %parts128_div.exit

if.end48.i:                                       ; preds = %if.end38.i
  store i8 %xor32.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  switch i8 %11, label %if.end63.i [
    i8 3, label %parts128_div.exit
    i8 1, label %parts128_div.exit
  ]

if.end63.i:                                       ; preds = %if.end48.i
  switch i8 %10, label %if.else.i35 [
    i8 3, label %if.then68.i
    i8 1, label %do.end.i
  ]

if.then68.i:                                      ; preds = %if.end63.i
  store i8 1, ptr %pa, align 8
  br label %parts128_div.exit

if.else.i35:                                      ; preds = %if.end63.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 644, ptr noundef nonnull @__func__.parts128_div, ptr noundef nonnull @.str.13) #16
  unreachable

do.end.i:                                         ; preds = %if.end63.i
  %27 = load i16, ptr %status, align 2
  %or1.i35.i = or i16 %27, 2
  store i16 %or1.i35.i, ptr %status, align 2
  store i8 3, ptr %pa, align 8
  br label %parts128_div.exit

d_nan.i:                                          ; preds = %if.then37.i, %if.end
  %.sink45.i = phi i16 [ 513, %if.then37.i ], [ 1025, %if.end ]
  %28 = load i16, ptr %status, align 2
  %or1.i34.i = or i16 %28, %.sink45.i
  store i16 %or1.i34.i, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %parts128_div.exit

parts128_div.exit:                                ; preds = %pickNaN.exit.i.i, %if.then.i32, %if.then3.i.i, %if.then6.i.i.i, %lor.lhs.false.i.i.i, %25, %if.then24.i.i, %if.end48.i, %if.end48.i, %if.then68.i, %do.end.i, %d_nan.i
  %retval.0.i = phi ptr [ %pa, %if.then.i32 ], [ %pa, %d_nan.i ], [ %pa, %if.then68.i ], [ %pa, %do.end.i ], [ %pa, %if.end48.i ], [ %pa, %if.end48.i ], [ %pa, %if.then3.i.i ], [ %.ph.i40.i, %if.then24.i.i ], [ %pb, %25 ], [ %pa, %if.then6.i.i.i ], [ %spec.select.i, %lor.lhs.false.i.i.i ], [ %pb, %pickNaN.exit.i.i ]
  %call4 = call fastcc { i64, i16 } @floatx80_round_pack_canonical(ptr noundef nonnull %retval.0.i, ptr noundef nonnull %status)
  %29 = extractvalue { i64, i16 } %call4, 0
  %30 = extractvalue { i64, i16 } %call4, 1
  br label %return

return:                                           ; preds = %floatx80_unpack_canonical.exit, %floatx80_unpack_canonical.exit29, %parts128_div.exit
  %retval.sroa.0.0 = phi i64 [ %29, %parts128_div.exit ], [ -4611686018427387904, %floatx80_unpack_canonical.exit29 ], [ -4611686018427387904, %floatx80_unpack_canonical.exit ]
  %retval.sroa.3.0 = phi i16 [ %30, %parts128_div.exit ], [ -1, %floatx80_unpack_canonical.exit29 ], [ -1, %floatx80_unpack_canonical.exit ]
  %.fca.0.insert = insertvalue { i64, i16 } poison, i64 %retval.sroa.0.0, 0
  %.fca.1.insert = insertvalue { i64, i16 } %.fca.0.insert, i16 %retval.sroa.3.0, 1
  ret { i64, i16 } %.fca.1.insert
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_rem(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pb = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %and.i9.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %if.then33.i.i [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float32_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float32_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float32_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float32_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float32_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float32_unpack_canonical.exit

float32_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %f.lobit.i.i4 = lshr i32 %b, 31
  %frombool.i.i.i5 = trunc i32 %f.lobit.i.i4 to i8
  %shr.i8.i.i6 = lshr i32 %b, 23
  %and.i9.i.i7 = and i32 %shr.i8.i.i6, 255
  %5 = and i32 %b, 8388607
  %and.i10.i.i8 = zext nneg i32 %5 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i5, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %and.i9.i.i7, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i10.i.i8, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  %trunc.i12 = trunc i32 %shr.i8.i.i6 to i8
  switch i8 %trunc.i12, label %if.then33.i.i32 [
    i8 0, label %if.then.i.i20
    i8 -1, label %lor.lhs.false.i.i13
  ]

if.then.i.i20:                                    ; preds = %float32_unpack_canonical.exit
  %cmp.i.i.i21 = icmp eq i32 %5, 0
  br i1 %cmp.i.i.i21, label %if.then8.i.i31, label %if.else.i.i22

if.then8.i.i31:                                   ; preds = %if.then.i.i20
  store i8 1, ptr %pb, align 8
  br label %float32_unpack_canonical.exit36

if.else.i.i22:                                    ; preds = %if.then.i.i20
  %flush_inputs_to_zero.i.i23 = getelementptr inbounds i8, ptr %status, i64 6
  %6 = load i8, ptr %flush_inputs_to_zero.i.i23, align 2
  %7 = and i8 %6, 1
  %tobool9.not.i.i24 = icmp eq i8 %7, 0
  br i1 %tobool9.not.i.i24, label %frac64_normalize.exit.i.i27, label %if.then10.i.i25

if.then10.i.i25:                                  ; preds = %if.else.i.i22
  %8 = load i16, ptr %status, align 2
  %or1.i.i.i26 = or i16 %8, 32
  store i16 %or1.i.i.i26, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float32_unpack_canonical.exit36

frac64_normalize.exit.i.i27:                      ; preds = %if.else.i.i22
  %9 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i8, i1 true), !range !5
  %cast.i.i.i.i28 = trunc i64 %9 to i32
  %shl.i.i.i29 = shl i64 %and.i10.i.i8, %9
  store i64 %shl.i.i.i29, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i30 = sub nuw nsw i32 -86, %cast.i.i.i.i28
  store i32 %add.i.i30, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  br label %float32_unpack_canonical.exit36

lor.lhs.false.i.i13:                              ; preds = %float32_unpack_canonical.exit
  %cmp.i29.i.i14 = icmp eq i32 %5, 0
  br i1 %cmp.i29.i.i14, label %if.then47.i.i19, label %if.else49.i.i15

if.then33.i.i32:                                  ; preds = %float32_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i33 = add nsw i32 %and.i9.i.i7, -127
  store i32 %sub37.i.i33, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %shl.i28.i.i34 = shl nuw nsw i64 %and.i10.i.i8, 40
  %or.i.i35 = or disjoint i64 %shl.i28.i.i34, -9223372036854775808
  store i64 %or.i.i35, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float32_unpack_canonical.exit36

if.then47.i.i19:                                  ; preds = %lor.lhs.false.i.i13
  store i8 3, ptr %pb, align 8
  br label %float32_unpack_canonical.exit36

if.else49.i.i15:                                  ; preds = %lor.lhs.false.i.i13
  %shl.i31.i.i16 = shl nuw nsw i64 %and.i10.i.i8, 40
  store i64 %shl.i31.i.i16, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  %tobool.not.i32.i.i17 = icmp ult i32 %5, 4194304
  %conv53.i.i18 = select i1 %tobool.not.i32.i.i17, i8 5, i8 4
  store i8 %conv53.i.i18, ptr %pb, align 8
  br label %float32_unpack_canonical.exit36

float32_unpack_canonical.exit36:                  ; preds = %if.then8.i.i31, %if.then10.i.i25, %frac64_normalize.exit.i.i27, %if.then33.i.i32, %if.then47.i.i19, %if.else49.i.i15
  %call = call fastcc ptr @parts64_modrem(ptr noundef nonnull %pa, ptr noundef nonnull %pb, ptr noundef %status)
  call fastcc void @parts64_uncanon(ptr noundef %call, ptr noundef %status, ptr noundef nonnull @float32_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %call, i64 1
  %10 = load i8, ptr %sign.i.i.i, align 1
  %conv.i.i.i = zext i8 %10 to i64
  %shl.i.i.i37 = shl nuw nsw i64 %conv.i.i.i, 31
  %exp.i.i.i = getelementptr inbounds i8, ptr %call, i64 4
  %11 = load i32, ptr %exp.i.i.i, align 4
  %12 = shl i32 %11, 23
  %13 = and i32 %12, 2139095040
  %and8.i.i.i = zext nneg i32 %13 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i37, %and8.i.i.i
  %14 = getelementptr inbounds i8, ptr %call, i64 8
  %15 = load i64, ptr %14, align 8
  %shl77.i9.i.i = and i64 %15, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  ret i32 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @parts64_modrem(ptr noundef %a, ptr noundef %b, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %0 = load i8, ptr %a, align 8
  %conv = zext nneg i8 %0 to i32
  %shl = shl nuw i32 1, %conv
  %1 = load i8, ptr %b, align 8
  %conv2 = zext nneg i8 %1 to i32
  %shl3 = shl nuw i32 1, %conv2
  %or = or i32 %shl3, %shl
  %cmp = icmp eq i32 %or, 4
  br i1 %cmp, label %if.then, label %if.end9

if.then:                                          ; preds = %entry
  %exp.i = getelementptr inbounds i8, ptr %a, i64 4
  %2 = load i32, ptr %exp.i, align 4
  %exp1.i = getelementptr inbounds i8, ptr %b, i64 4
  %3 = load i32, ptr %exp1.i, align 4
  %sub.i = sub i32 %2, %3
  %4 = getelementptr inbounds i8, ptr %a, i64 8
  %cmp.i = icmp slt i32 %sub.i, -1
  br i1 %cmp.i, label %return, label %if.end3.i

if.end3.i:                                        ; preds = %if.then
  %5 = load i64, ptr %4, align 8
  %cmp4.i = icmp eq i32 %sub.i, -1
  %shr.i = zext i1 %cmp4.i to i64
  %spec.select.i = lshr i64 %5, %shr.i
  %6 = add nsw i32 %sub.i, -64
  %7 = getelementptr inbounds i8, ptr %b, i64 8
  %8 = load i64, ptr %7, align 8
  %cmp7.i = icmp ule i64 %8, %spec.select.i
  %conv8.i = zext i1 %cmp7.i to i64
  %sub11.i = select i1 %cmp7.i, i64 %8, i64 0
  %a0.1.i = sub i64 %spec.select.i, %sub11.i
  %sub13.i = select i1 %cmp4.i, i32 -64, i32 %6
  %cmp1457.i = icmp sgt i32 %sub13.i, 0
  br i1 %cmp1457.i, label %while.body.lr.ph.i, label %while.end.i

while.body.lr.ph.i:                               ; preds = %if.end3.i
  %shr.i.i = lshr i64 %8, 32
  %shl.i.i = and i64 %8, -4294967296
  %conv.i.i.i.i = zext i64 %8 to i128
  %shl4.i.i = shl i64 %8, 32
  br label %while.body.i

while.body.i:                                     ; preds = %estimateDiv128To64.exit.i, %while.body.lr.ph.i
  %exp_diff.161.i = phi i32 [ %6, %while.body.lr.ph.i ], [ %sub19.i, %estimateDiv128To64.exit.i ]
  %a1.059.i = phi i64 [ 0, %while.body.lr.ph.i ], [ %shl.i49.i, %estimateDiv128To64.exit.i ]
  %a0.258.i = phi i64 [ %a0.1.i, %while.body.lr.ph.i ], [ %or.i53.i, %estimateDiv128To64.exit.i ]
  %cmp.not.i.i = icmp ugt i64 %8, %a0.258.i
  br i1 %cmp.not.i.i, label %if.end.i.i, label %estimateDiv128To64.exit.i

if.end.i.i:                                       ; preds = %while.body.i
  %cmp1.not.i.i = icmp ugt i64 %shl.i.i, %a0.258.i
  br i1 %cmp1.not.i.i, label %cond.false.i.i, label %cond.end.i.i

cond.false.i.i:                                   ; preds = %if.end.i.i
  %div.i.i = udiv i64 %a0.258.i, %shr.i.i
  %shl2.i.i = shl i64 %div.i.i, 32
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.false.i.i, %if.end.i.i
  %cond.i.i = phi i64 [ %shl2.i.i, %cond.false.i.i ], [ -4294967296, %if.end.i.i ]
  %conv1.i.i.i.i = zext i64 %cond.i.i to i128
  %mul.i.i.i.i = mul nuw i128 %conv1.i.i.i.i, %conv.i.i.i.i
  %conv2.i.i.i.i = trunc i128 %mul.i.i.i.i to i64
  %shr.i.i.i.i = lshr i128 %mul.i.i.i.i, 64
  %conv3.i.i.i.i = trunc i128 %shr.i.i.i.i to i64
  %9 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.059.i, i64 %conv2.i.i.i.i)
  %10 = extractvalue { i64, i1 } %9, 1
  %conv.i1.neg.i.i.i = sext i1 %10 to i64
  %11 = sub i64 %a0.258.i, %conv3.i.i.i.i
  %12 = add i64 %11, %conv.i1.neg.i.i.i
  %rem1.015.i.i = extractvalue { i64, i1 } %9, 0
  %cmp316.i.i = icmp slt i64 %12, 0
  br i1 %cmp316.i.i, label %while.body.i.i, label %while.end.i.i

while.body.i.i:                                   ; preds = %cond.end.i.i, %while.body.i.i
  %rem1.019.i.i = phi i64 [ %rem1.0.i.i, %while.body.i.i ], [ %rem1.015.i.i, %cond.end.i.i ]
  %z.018.i.i = phi i64 [ %sub.i.i, %while.body.i.i ], [ %cond.i.i, %cond.end.i.i ]
  %rem0.017.i.i = phi i64 [ %16, %while.body.i.i ], [ %12, %cond.end.i.i ]
  %sub.i.i = add i64 %z.018.i.i, -4294967296
  %13 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %rem1.019.i.i, i64 %shl4.i.i)
  %14 = extractvalue { i64, i1 } %13, 1
  %conv.i1.i.i.i = zext i1 %14 to i64
  %15 = add nsw i64 %rem0.017.i.i, %shr.i.i
  %16 = add nsw i64 %15, %conv.i1.i.i.i
  %rem1.0.i.i = extractvalue { i64, i1 } %13, 0
  %cmp3.i.i = icmp slt i64 %16, 0
  br i1 %cmp3.i.i, label %while.body.i.i, label %while.end.i.i, !llvm.loop !8

while.end.i.i:                                    ; preds = %while.body.i.i, %cond.end.i.i
  %rem0.0.lcssa.i.i = phi i64 [ %12, %cond.end.i.i ], [ %16, %while.body.i.i ]
  %z.0.lcssa.i.i = phi i64 [ %cond.i.i, %cond.end.i.i ], [ %sub.i.i, %while.body.i.i ]
  %rem1.0.lcssa.i.i = phi i64 [ %rem1.015.i.i, %cond.end.i.i ], [ %rem1.0.i.i, %while.body.i.i ]
  %or.i.i = tail call i64 @llvm.fshl.i64(i64 %rem0.0.lcssa.i.i, i64 %rem1.0.lcssa.i.i, i64 32)
  %cmp8.not.i.i = icmp ugt i64 %shl.i.i, %or.i.i
  br i1 %cmp8.not.i.i, label %cond.false10.i.i, label %cond.end12.i.i

cond.false10.i.i:                                 ; preds = %while.end.i.i
  %div11.i.i = udiv i64 %or.i.i, %shr.i.i
  br label %cond.end12.i.i

cond.end12.i.i:                                   ; preds = %cond.false10.i.i, %while.end.i.i
  %cond13.i.i = phi i64 [ %div11.i.i, %cond.false10.i.i ], [ 4294967295, %while.end.i.i ]
  %or14.i.i = or i64 %cond13.i.i, %z.0.lcssa.i.i
  br label %estimateDiv128To64.exit.i

estimateDiv128To64.exit.i:                        ; preds = %cond.end12.i.i, %while.body.i
  %retval.0.i.i = phi i64 [ %or14.i.i, %cond.end12.i.i ], [ -1, %while.body.i ]
  %cond.i = tail call i64 @llvm.usub.sat.i64(i64 %retval.0.i.i, i64 2)
  %conv1.i.i.i = zext i64 %cond.i to i128
  %mul.i.i.i = mul nuw i128 %conv1.i.i.i, %conv.i.i.i.i
  %conv2.i.i.i = trunc i128 %mul.i.i.i to i64
  %shr.i.i.i = lshr i128 %mul.i.i.i, 64
  %conv3.i.i.i = trunc i128 %shr.i.i.i to i64
  %17 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.059.i, i64 %conv2.i.i.i)
  %18 = extractvalue { i64, i1 } %17, 1
  %19 = extractvalue { i64, i1 } %17, 0
  %conv.i1.neg.i.i = sext i1 %18 to i64
  %20 = sub i64 %a0.258.i, %conv3.i.i.i
  %21 = add i64 %20, %conv.i1.neg.i.i
  %shl.i49.i = shl i64 %19, 62
  %or.i53.i = tail call i64 @llvm.fshl.i64(i64 %21, i64 %19, i64 62)
  %sub19.i = add nsw i32 %exp_diff.161.i, -62
  %cmp14.i = icmp sgt i32 %exp_diff.161.i, 62
  br i1 %cmp14.i, label %while.body.i, label %while.end.i, !llvm.loop !10

while.end.i:                                      ; preds = %estimateDiv128To64.exit.i, %if.end3.i
  %a0.2.lcssa.i = phi i64 [ %a0.1.i, %if.end3.i ], [ %or.i53.i, %estimateDiv128To64.exit.i ]
  %a1.0.lcssa.i = phi i64 [ 0, %if.end3.i ], [ %shl.i49.i, %estimateDiv128To64.exit.i ]
  %q.0.lcssa.i = phi i64 [ %conv8.i, %if.end3.i ], [ %cond.i, %estimateDiv128To64.exit.i ]
  %exp_diff.1.lcssa.i = phi i32 [ %sub13.i, %if.end3.i ], [ %sub19.i, %estimateDiv128To64.exit.i ]
  %add20.i = add nsw i32 %exp_diff.1.lcssa.i, 64
  %cmp21.i = icmp sgt i32 %exp_diff.1.lcssa.i, -64
  br i1 %cmp21.i, label %if.then23.i, label %if.else54.i

if.then23.i:                                      ; preds = %while.end.i
  %cmp.not.i56.i = icmp ugt i64 %8, %a0.2.lcssa.i
  br i1 %cmp.not.i56.i, label %if.end.i58.i, label %estimateDiv128To64.exit97.thread.i

estimateDiv128To64.exit97.thread.i:               ; preds = %if.then23.i
  %sub2945.i = sub nsw i32 0, %exp_diff.1.lcssa.i
  %sh_prom46.i = zext nneg i32 %sub2945.i to i64
  %shr3047.i = lshr i64 -3, %sh_prom46.i
  %.pre.i = zext i64 %8 to i128
  br label %shortShift128Left.exit.i

if.end.i58.i:                                     ; preds = %if.then23.i
  %shr.i59.i = lshr i64 %8, 32
  %shl.i60.i = and i64 %8, -4294967296
  %cmp1.not.i61.i = icmp ugt i64 %shl.i60.i, %a0.2.lcssa.i
  br i1 %cmp1.not.i61.i, label %cond.false.i94.i, label %cond.end.i62.i

cond.false.i94.i:                                 ; preds = %if.end.i58.i
  %div.i95.i = udiv i64 %a0.2.lcssa.i, %shr.i59.i
  %shl2.i96.i = shl i64 %div.i95.i, 32
  br label %cond.end.i62.i

cond.end.i62.i:                                   ; preds = %cond.false.i94.i, %if.end.i58.i
  %cond.i63.i = phi i64 [ %shl2.i96.i, %cond.false.i94.i ], [ -4294967296, %if.end.i58.i ]
  %conv.i.i.i64.i = zext i64 %8 to i128
  %conv1.i.i.i65.i = zext i64 %cond.i63.i to i128
  %mul.i.i.i66.i = mul nuw i128 %conv1.i.i.i65.i, %conv.i.i.i64.i
  %conv2.i.i.i67.i = trunc i128 %mul.i.i.i66.i to i64
  %shr.i.i.i68.i = lshr i128 %mul.i.i.i66.i, 64
  %conv3.i.i.i69.i = trunc i128 %shr.i.i.i68.i to i64
  %22 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.0.lcssa.i, i64 %conv2.i.i.i67.i)
  %23 = extractvalue { i64, i1 } %22, 1
  %conv.i1.neg.i.i70.i = sext i1 %23 to i64
  %24 = sub i64 %a0.2.lcssa.i, %conv3.i.i.i69.i
  %25 = add i64 %24, %conv.i1.neg.i.i70.i
  %rem1.015.i71.i = extractvalue { i64, i1 } %22, 0
  %cmp316.i72.i = icmp slt i64 %25, 0
  br i1 %cmp316.i72.i, label %while.body.lr.ph.i84.i, label %while.end.i73.i

while.body.lr.ph.i84.i:                           ; preds = %cond.end.i62.i
  %shl4.i85.i = shl i64 %8, 32
  br label %while.body.i86.i

while.body.i86.i:                                 ; preds = %while.body.i86.i, %while.body.lr.ph.i84.i
  %rem1.019.i87.i = phi i64 [ %rem1.015.i71.i, %while.body.lr.ph.i84.i ], [ %rem1.0.i92.i, %while.body.i86.i ]
  %z.018.i88.i = phi i64 [ %cond.i63.i, %while.body.lr.ph.i84.i ], [ %sub.i90.i, %while.body.i86.i ]
  %rem0.017.i89.i = phi i64 [ %25, %while.body.lr.ph.i84.i ], [ %29, %while.body.i86.i ]
  %sub.i90.i = add i64 %z.018.i88.i, -4294967296
  %26 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %rem1.019.i87.i, i64 %shl4.i85.i)
  %27 = extractvalue { i64, i1 } %26, 1
  %conv.i1.i.i91.i = zext i1 %27 to i64
  %28 = add nsw i64 %rem0.017.i89.i, %shr.i59.i
  %29 = add nsw i64 %28, %conv.i1.i.i91.i
  %rem1.0.i92.i = extractvalue { i64, i1 } %26, 0
  %cmp3.i93.i = icmp slt i64 %29, 0
  br i1 %cmp3.i93.i, label %while.body.i86.i, label %while.end.i73.i, !llvm.loop !8

while.end.i73.i:                                  ; preds = %while.body.i86.i, %cond.end.i62.i
  %rem0.0.lcssa.i74.i = phi i64 [ %25, %cond.end.i62.i ], [ %29, %while.body.i86.i ]
  %z.0.lcssa.i75.i = phi i64 [ %cond.i63.i, %cond.end.i62.i ], [ %sub.i90.i, %while.body.i86.i ]
  %rem1.0.lcssa.i76.i = phi i64 [ %rem1.015.i71.i, %cond.end.i62.i ], [ %rem1.0.i92.i, %while.body.i86.i ]
  %or.i77.i = tail call i64 @llvm.fshl.i64(i64 %rem0.0.lcssa.i74.i, i64 %rem1.0.lcssa.i76.i, i64 32)
  %cmp8.not.i78.i = icmp ugt i64 %shl.i60.i, %or.i77.i
  br i1 %cmp8.not.i78.i, label %cond.false10.i82.i, label %estimateDiv128To64.exit97.i

cond.false10.i82.i:                               ; preds = %while.end.i73.i
  %div11.i83.i = udiv i64 %or.i77.i, %shr.i59.i
  br label %estimateDiv128To64.exit97.i

estimateDiv128To64.exit97.i:                      ; preds = %cond.false10.i82.i, %while.end.i73.i
  %cond13.i80.i = phi i64 [ %div11.i83.i, %cond.false10.i82.i ], [ 4294967295, %while.end.i73.i ]
  %or14.i81.i = or i64 %cond13.i80.i, %z.0.lcssa.i75.i
  %or14.i81.fr.i = freeze i64 %or14.i81.i
  %cmp25.i = icmp ugt i64 %or14.i81.fr.i, 2
  %sub28.i = add i64 %or14.i81.fr.i, -2
  %sub29.i = sub nsw i32 0, %exp_diff.1.lcssa.i
  %sh_prom.i = zext nneg i32 %sub29.i to i64
  %shr30.i = lshr i64 %sub28.i, %sh_prom.i
  %spec.select55.i = select i1 %cmp25.i, i64 %shr30.i, i64 0
  br label %shortShift128Left.exit.i

shortShift128Left.exit.i:                         ; preds = %estimateDiv128To64.exit97.i, %estimateDiv128To64.exit97.thread.i
  %conv.i.i98.pre-phi.i = phi i128 [ %conv.i.i.i64.i, %estimateDiv128To64.exit97.i ], [ %.pre.i, %estimateDiv128To64.exit97.thread.i ]
  %sh_prom51.i = phi i64 [ %sh_prom.i, %estimateDiv128To64.exit97.i ], [ %sh_prom46.i, %estimateDiv128To64.exit97.thread.i ]
  %sub2949.i = phi i32 [ %sub29.i, %estimateDiv128To64.exit97.i ], [ %sub2945.i, %estimateDiv128To64.exit97.thread.i ]
  %30 = phi i64 [ %spec.select55.i, %estimateDiv128To64.exit97.i ], [ %shr3047.i, %estimateDiv128To64.exit97.thread.i ]
  %shl36.i = shl i64 %30, %sh_prom51.i
  %conv1.i.i99.i = zext i64 %shl36.i to i128
  %mul.i.i100.i = mul nuw i128 %conv.i.i98.pre-phi.i, %conv1.i.i99.i
  %conv2.i.i101.i = trunc i128 %mul.i.i100.i to i64
  %shr.i.i102.i = lshr i128 %mul.i.i100.i, 64
  %conv3.i.i103.i = trunc i128 %shr.i.i102.i to i64
  %31 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.0.lcssa.i, i64 %conv2.i.i101.i)
  %32 = extractvalue { i64, i1 } %31, 1
  %conv.i1.neg.i104.i = sext i1 %32 to i64
  %33 = sub i64 %a0.2.lcssa.i, %conv3.i.i103.i
  %34 = add i64 %33, %conv.i1.neg.i104.i
  %shl.i105.i = shl i64 %8, %sh_prom51.i
  %cmp.i.i = icmp eq i32 %sub2949.i, 0
  %and.i.i = and i32 %exp_diff.1.lcssa.i, 63
  %sh_prom3.i.i = zext nneg i32 %and.i.i to i64
  %shr.i107.i = lshr i64 %8, %sh_prom3.i.i
  %cond.i109.i = select i1 %cmp.i.i, i64 0, i64 %shr.i107.i
  br label %while.cond38.i

while.cond38.i:                                   ; preds = %while.body40.i, %shortShift128Left.exit.i
  %a0.3.i = phi i64 [ %34, %shortShift128Left.exit.i ], [ %39, %while.body40.i ]
  %.pn.i = phi { i64, i1 } [ %31, %shortShift128Left.exit.i ], [ %36, %while.body40.i ]
  %q.1.i = phi i64 [ %30, %shortShift128Left.exit.i ], [ %inc.i, %while.body40.i ]
  %a1.1.i = extractvalue { i64, i1 } %.pn.i, 0
  %cmp.i110.i = icmp ult i64 %cond.i109.i, %a0.3.i
  br i1 %cmp.i110.i, label %while.body40.i, label %le128.exit.i

le128.exit.i:                                     ; preds = %while.cond38.i
  %cmp1.i.i = icmp eq i64 %cond.i109.i, %a0.3.i
  %cmp2.i.i = icmp ule i64 %shl.i105.i, %a1.1.i
  %35 = and i1 %cmp1.i.i, %cmp2.i.i
  br i1 %35, label %while.body40.i, label %if.else54.i

while.body40.i:                                   ; preds = %le128.exit.i, %while.cond38.i
  %inc.i = add i64 %q.1.i, 1
  %36 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.1.i, i64 %shl.i105.i)
  %37 = extractvalue { i64, i1 } %36, 1
  %conv.i1.neg.i111.i = sext i1 %37 to i64
  %38 = sub i64 %a0.3.i, %cond.i109.i
  %39 = add i64 %38, %conv.i1.neg.i111.i
  br label %while.cond38.i, !llvm.loop !11

if.else54.i:                                      ; preds = %le128.exit.i, %while.end.i
  %a0.4.i = phi i64 [ %a0.2.lcssa.i, %while.end.i ], [ %a0.3.i, %le128.exit.i ]
  %a1.2.i = phi i64 [ %a1.0.lcssa.i, %while.end.i ], [ %a1.1.i, %le128.exit.i ]
  %t0.0.i = phi i64 [ %8, %while.end.i ], [ %cond.i109.i, %le128.exit.i ]
  %t1.0.i = phi i64 [ 0, %while.end.i ], [ %shl.i105.i, %le128.exit.i ]
  %q.2.i = phi i64 [ %q.0.lcssa.i, %while.end.i ], [ %q.1.i, %le128.exit.i ]
  %40 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %t1.0.i, i64 %a1.2.i)
  %41 = extractvalue { i64, i1 } %40, 1
  %42 = extractvalue { i64, i1 } %40, 0
  %conv.i1.neg.i112.i = sext i1 %41 to i64
  %43 = sub i64 %t0.0.i, %a0.4.i
  %44 = add i64 %43, %conv.i1.neg.i112.i
  %cmp.i113.i = icmp ult i64 %44, %a0.4.i
  br i1 %cmp.i113.i, label %if.then60.i, label %lt128.exit.i

lt128.exit.i:                                     ; preds = %if.else54.i
  %cmp1.i115.i = icmp eq i64 %44, %a0.4.i
  %cmp2.i116.i = icmp ult i64 %42, %a1.2.i
  %45 = and i1 %cmp2.i116.i, %cmp1.i115.i
  br i1 %45, label %if.then60.i, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %lt128.exit.i
  %cmp.i117.i = icmp ne i64 %44, %a0.4.i
  %cmp1.i118.i = icmp ne i64 %42, %a1.2.i
  %.not.i = or i1 %cmp1.i118.i, %cmp.i117.i
  %and.i = and i64 %q.2.i, 1
  %tobool59.not.i = icmp eq i64 %and.i, 0
  %or.cond.i = select i1 %.not.i, i1 true, i1 %tobool59.not.i
  br i1 %or.cond.i, label %if.end64.i, label %if.then60.i

if.then60.i:                                      ; preds = %lor.lhs.false.i, %lt128.exit.i, %if.else54.i
  %sign.i = getelementptr inbounds i8, ptr %a, i64 1
  %46 = load i8, ptr %sign.i, align 1
  %47 = and i8 %46, 1
  %frombool.i = xor i8 %47, 1
  store i8 %frombool.i, ptr %sign.i, align 1
  br label %if.end64.i

if.end64.i:                                       ; preds = %if.then60.i, %lor.lhs.false.i
  %a0.5.i = phi i64 [ %44, %if.then60.i ], [ %a0.4.i, %lor.lhs.false.i ]
  %a1.3.i = phi i64 [ %42, %if.then60.i ], [ %a1.2.i, %lor.lhs.false.i ]
  %tobool65.not.i = icmp eq i64 %a0.5.i, 0
  br i1 %tobool65.not.i, label %if.else72.i, label %if.then70.i

if.then70.i:                                      ; preds = %if.end64.i
  %48 = tail call i64 @llvm.ctlz.i64(i64 %a0.5.i, i1 true), !range !5
  %cast.i.i = trunc i64 %48 to i32
  %shl.i120.i = shl i64 %a1.3.i, %48
  %cmp.i121.i = icmp eq i32 %cast.i.i, 0
  br i1 %cmp.i121.i, label %if.end87.i, label %cond.false.i122.i

cond.false.i122.i:                                ; preds = %if.then70.i
  %shl2.i123.i = shl i64 %a0.5.i, %48
  %sub.i124.i = sub nsw i64 0, %48
  %and.i125.i = and i64 %sub.i124.i, 63
  %shr.i127.i = lshr i64 %a1.3.i, %and.i125.i
  %or.i128.i = or i64 %shr.i127.i, %shl2.i123.i
  br label %if.end87.i

if.else72.i:                                      ; preds = %if.end64.i
  %tobool73.not.i = icmp eq i64 %a1.3.i, 0
  br i1 %tobool73.not.i, label %if.else85.i, label %if.then80.i

if.then80.i:                                      ; preds = %if.else72.i
  %49 = tail call i64 @llvm.ctlz.i64(i64 %a1.3.i, i1 true), !range !5
  %cast.i132.i = trunc i64 %49 to i32
  %shl83.i = shl i64 %a1.3.i, %49
  %add84.i = or disjoint i32 %cast.i132.i, 64
  br label %if.end87.i

if.else85.i:                                      ; preds = %if.else72.i
  store i8 1, ptr %a, align 8
  br label %return

if.end87.i:                                       ; preds = %if.then80.i, %cond.false.i122.i, %if.then70.i
  %a0.6.i = phi i64 [ %shl83.i, %if.then80.i ], [ %or.i128.i, %cond.false.i122.i ], [ %a0.5.i, %if.then70.i ]
  %a1.4.i = phi i64 [ 0, %if.then80.i ], [ %shl.i120.i, %cond.false.i122.i ], [ %shl.i120.i, %if.then70.i ]
  %shift.0.i = phi i32 [ %add84.i, %if.then80.i ], [ %cast.i.i, %cond.false.i122.i ], [ 0, %if.then70.i ]
  %50 = load i32, ptr %exp1.i, align 4
  %add89.i = sub i32 %add20.i, %shift.0.i
  %sub90.i = add i32 %add89.i, %50
  store i32 %sub90.i, ptr %exp.i, align 4
  %cmp92.i = icmp ne i64 %a1.4.i, 0
  %conv94.i = zext i1 %cmp92.i to i64
  %or.i = or i64 %a0.6.i, %conv94.i
  store i64 %or.i, ptr %4, align 8
  br label %return

if.end9:                                          ; preds = %entry
  %and = and i32 %or, 48
  %tobool10.not = icmp eq i32 %and, 0
  br i1 %tobool10.not, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end9
  %cmp.i.i18 = icmp eq i8 %0, 5
  %cmp.i17.i = icmp eq i8 %1, 5
  %or.cond = or i1 %cmp.i.i18, %cmp.i17.i
  br i1 %or.cond, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.then17
  %51 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %51, 8193
  store i16 %or1.i.i, ptr %s, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %if.then17, %if.then.i
  %default_nan_mode.i = getelementptr inbounds i8, ptr %s, i64 7
  %52 = load i8, ptr %default_nan_mode.i, align 1
  %53 = and i8 %52, 1
  %tobool.not.i = icmp eq i8 %53, 0
  br i1 %tobool.not.i, label %if.else.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  store i8 4, ptr %a, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  br label %return

if.else.i:                                        ; preds = %if.end.i
  %54 = getelementptr i8, ptr %a, i64 8
  %a.val.i = load i64, ptr %54, align 8
  %55 = getelementptr i8, ptr %b, i64 8
  %b.val.i = load i64, ptr %55, align 8
  %cmp.i18.i = icmp eq i64 %a.val.i, %b.val.i
  %cmp1.i.i20 = icmp ult i64 %a.val.i, %b.val.i
  br i1 %cmp.i18.i, label %if.then6.i, label %if.end13.i

if.then6.i:                                       ; preds = %if.else.i
  %sign.i21 = getelementptr inbounds i8, ptr %a, i64 1
  %56 = load i8, ptr %sign.i21, align 1
  %57 = and i8 %56, 1
  %sign8.i = getelementptr inbounds i8, ptr %b, i64 1
  %58 = load i8, ptr %sign8.i, align 1
  %59 = and i8 %58, 1
  %cmp11.i = icmp uge i8 %57, %59
  br label %if.end13.i

if.end13.i:                                       ; preds = %if.then6.i, %if.else.i
  %cmp.0.i = phi i1 [ %cmp11.i, %if.then6.i ], [ %cmp1.i.i20, %if.else.i ]
  %60 = load i8, ptr %a, align 8
  %61 = load i8, ptr %b, align 8
  switch i8 %60, label %62 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end13.i
  %cmp.i10.i.i = icmp eq i8 %61, 5
  br i1 %cmp.i10.i.i, label %return, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %61, 4
  %spec.select.i.i = and i1 %cmp.0.i, %cmp.i11.i.i
  %cond.fr26.i = freeze i1 %spec.select.i.i
  %spec.select = select i1 %cond.fr26.i, ptr %b, ptr %a
  br label %return

pickNaN.exit.i:                                   ; preds = %if.end13.i
  %cmp.i7.i.i = icmp eq i8 %61, 5
  %cmp.i8.i.i = icmp eq i8 %61, 4
  %spec.select20.i = select i1 %cmp.i7.i.i, i1 %cmp.0.i, i1 %cmp.i8.i.i
  %cond.fr.i = freeze i1 %spec.select20.i
  br i1 %cond.fr.i, label %62, label %if.then24.i

62:                                               ; preds = %if.end13.i, %pickNaN.exit.i
  %63 = icmp eq i8 %61, 5
  br i1 %63, label %if.then24.i, label %return

if.then24.i:                                      ; preds = %pickNaN.exit.i, %62
  %.ph.i6 = phi ptr [ %b, %62 ], [ %a, %pickNaN.exit.i ]
  %64 = getelementptr inbounds i8, ptr %.ph.i6, i64 8
  %65 = load i64, ptr %64, align 8
  %or4.i.i.i = or i64 %65, 4611686018427387904
  store i64 %or4.i.i.i, ptr %64, align 8
  store i8 4, ptr %.ph.i6, align 8
  br label %return

if.end18:                                         ; preds = %if.end9
  %cmp21 = icmp eq i8 %0, 3
  br i1 %cmp21, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end18
  switch i8 %1, label %lor.lhs.false33 [
    i8 1, label %if.then27
    i8 3, label %return
  ]

if.then27:                                        ; preds = %lor.lhs.false, %if.end18
  %66 = load i16, ptr %s, align 2
  %or1.i = or i16 %66, 1
  store i16 %or1.i, ptr %s, align 2
  store i8 4, ptr %a, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  br label %return

lor.lhs.false33:                                  ; preds = %lor.lhs.false
  %cmp36 = icmp eq i8 %0, 1
  br i1 %cmp36, label %return, label %if.else

if.else:                                          ; preds = %lor.lhs.false33
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 684, ptr noundef nonnull @__func__.parts64_modrem, ptr noundef nonnull @.str.14) #16
  unreachable

return:                                           ; preds = %lor.lhs.false.i.i, %if.then24.i, %62, %if.then6.i.i, %if.then3.i, %if.end87.i, %if.else85.i, %if.then, %lor.lhs.false33, %lor.lhs.false, %if.then27
  %retval.0 = phi ptr [ %a, %if.then27 ], [ %a, %lor.lhs.false ], [ %a, %lor.lhs.false33 ], [ %a, %if.then ], [ %a, %if.else85.i ], [ %a, %if.end87.i ], [ %a, %if.then3.i ], [ %.ph.i6, %if.then24.i ], [ %b, %62 ], [ %a, %if.then6.i.i ], [ %spec.select, %lor.lhs.false.i.i ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_rem(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pb = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float64_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

float64_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %f.lobit.i.i4 = lshr i64 %b, 63
  %frombool.i.i.i5 = trunc i64 %f.lobit.i.i4 to i8
  %shr.i8.i.i6 = lshr i64 %b, 52
  %5 = trunc i64 %shr.i8.i.i6 to i32
  %conv.i.i.i7 = and i32 %5, 2047
  %and.i9.i.i8 = and i64 %b, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i5, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i.i7, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i9.i.i8, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  switch i32 %conv.i.i.i7, label %if.then33.i.i31 [
    i32 0, label %if.then.i.i19
    i32 2047, label %lor.lhs.false.i.i12
  ]

if.then.i.i19:                                    ; preds = %float64_unpack_canonical.exit
  %cmp.i.i.i20 = icmp eq i64 %and.i9.i.i8, 0
  br i1 %cmp.i.i.i20, label %if.then8.i.i30, label %if.else.i.i21

if.then8.i.i30:                                   ; preds = %if.then.i.i19
  store i8 1, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

if.else.i.i21:                                    ; preds = %if.then.i.i19
  %flush_inputs_to_zero.i.i22 = getelementptr inbounds i8, ptr %status, i64 6
  %6 = load i8, ptr %flush_inputs_to_zero.i.i22, align 2
  %7 = and i8 %6, 1
  %tobool9.not.i.i23 = icmp eq i8 %7, 0
  br i1 %tobool9.not.i.i23, label %frac64_normalize.exit.i.i26, label %if.then10.i.i24

if.then10.i.i24:                                  ; preds = %if.else.i.i21
  %8 = load i16, ptr %status, align 2
  %or1.i.i.i25 = or i16 %8, 32
  store i16 %or1.i.i.i25, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float64_unpack_canonical.exit35

frac64_normalize.exit.i.i26:                      ; preds = %if.else.i.i21
  %9 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i8, i1 true), !range !5
  %cast.i.i.i.i27 = trunc i64 %9 to i32
  %shl.i.i.i28 = shl i64 %and.i9.i.i8, %9
  store i64 %shl.i.i.i28, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i29 = sub nuw nsw i32 -1011, %cast.i.i.i.i27
  store i32 %add.i.i29, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  br label %float64_unpack_canonical.exit35

lor.lhs.false.i.i12:                              ; preds = %float64_unpack_canonical.exit
  %cmp.i29.i.i13 = icmp eq i64 %and.i9.i.i8, 0
  br i1 %cmp.i29.i.i13, label %if.then47.i.i18, label %if.else49.i.i14

if.then33.i.i31:                                  ; preds = %float64_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i32 = add nsw i32 %conv.i.i.i7, -1023
  store i32 %sub37.i.i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %shl.i28.i.i33 = shl nuw nsw i64 %and.i9.i.i8, 11
  %or.i.i34 = or disjoint i64 %shl.i28.i.i33, -9223372036854775808
  store i64 %or.i.i34, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float64_unpack_canonical.exit35

if.then47.i.i18:                                  ; preds = %lor.lhs.false.i.i12
  store i8 3, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

if.else49.i.i14:                                  ; preds = %lor.lhs.false.i.i12
  %shl.i31.i.i15 = shl nuw nsw i64 %and.i9.i.i8, 11
  store i64 %shl.i31.i.i15, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  %tobool.not.i32.i.i16 = icmp ult i64 %and.i9.i.i8, 2251799813685248
  %conv53.i.i17 = select i1 %tobool.not.i32.i.i16, i8 5, i8 4
  store i8 %conv53.i.i17, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

float64_unpack_canonical.exit35:                  ; preds = %if.then8.i.i30, %if.then10.i.i24, %frac64_normalize.exit.i.i26, %if.then33.i.i31, %if.then47.i.i18, %if.else49.i.i14
  %call = call fastcc ptr @parts64_modrem(ptr noundef nonnull %pa, ptr noundef nonnull %pb, ptr noundef %status)
  call fastcc void @parts64_uncanon(ptr noundef %call, ptr noundef %status, ptr noundef nonnull @float64_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %call, i64 1
  %10 = load i8, ptr %sign.i.i.i, align 1
  %11 = and i8 %10, 1
  %conv.i.i.i36 = zext nneg i8 %11 to i64
  %shl.i.i.i37 = shl nuw i64 %conv.i.i.i36, 63
  %exp.i.i.i = getelementptr inbounds i8, ptr %call, i64 4
  %12 = load i32, ptr %exp.i.i.i, align 4
  %13 = and i32 %12, 2047
  %shl77.i.i.i = zext nneg i32 %13 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i.i37
  %14 = getelementptr inbounds i8, ptr %call, i64 8
  %15 = load i64, ptr %14, align 8
  %shl77.i9.i.i = and i64 %15, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  ret i64 %or.i10.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_rem(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts128, align 8
  %pb = alloca %struct.FloatParts128, align 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %pa, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pa, ptr noundef %status, ptr noundef nonnull @float128_params)
  %shr.i16.i.i4 = lshr i64 %b.coerce1, 48
  %1 = trunc i64 %shr.i16.i.i4 to i32
  %conv.i.i5 = and i32 %1, 32767
  %f.coerce1.lobit.i.i6 = lshr i64 %b.coerce1, 63
  %frombool.i.i7 = trunc i64 %f.coerce1.lobit.i.i6 to i8
  %and.i.i.i8 = and i64 %b.coerce1, 281474976710655
  store i8 0, ptr %pb, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i9 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i7, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i9, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i5, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i10, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i11 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i.i.i8, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i11, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i12 = getelementptr inbounds i8, ptr %pb, i64 16
  store i64 %b.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i12, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pb, ptr noundef %status, ptr noundef nonnull @float128_params)
  %call = call fastcc ptr @parts128_modrem(ptr noundef nonnull %pa, ptr noundef nonnull %pb, ptr noundef null, ptr noundef %status)
  %call1 = call fastcc { i64, i64 } @float128_round_pack_canonical(ptr noundef %call, ptr noundef %status)
  ret { i64, i64 } %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @parts128_modrem(ptr noundef %a, ptr noundef %b, ptr noundef writeonly %mod_quot, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %0 = load i8, ptr %a, align 8
  %conv = zext nneg i8 %0 to i32
  %shl = shl nuw i32 1, %conv
  %1 = load i8, ptr %b, align 8
  %conv2 = zext nneg i8 %1 to i32
  %shl3 = shl nuw i32 1, %conv2
  %or = or i32 %shl3, %shl
  %cmp = icmp eq i32 %or, 4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %exp.i = getelementptr inbounds i8, ptr %a, i64 4
  %2 = load i32, ptr %exp.i, align 4
  %exp1.i = getelementptr inbounds i8, ptr %b, i64 4
  %3 = load i32, ptr %exp1.i, align 4
  %sub.i = sub i32 %2, %3
  %frac_hi.i = getelementptr inbounds i8, ptr %a, i64 8
  %frac_lo.i = getelementptr inbounds i8, ptr %a, i64 16
  %cmp.i = icmp slt i32 %sub.i, -1
  br i1 %cmp.i, label %if.then.i, label %if.end3.i

if.then.i:                                        ; preds = %if.then
  %tobool.not.i = icmp eq ptr %mod_quot, null
  br i1 %tobool.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  store i64 0, ptr %mod_quot, align 8
  br label %return

if.end3.i:                                        ; preds = %if.then
  %4 = load i64, ptr %frac_lo.i, align 8
  %5 = load i64, ptr %frac_hi.i, align 8
  %cmp4.i = icmp eq i32 %sub.i, -1
  %or.i.i = tail call i64 @llvm.fshl.i64(i64 %5, i64 %4, i64 63)
  %shr8.i.i = zext i1 %cmp4.i to i64
  %a0.0.i = lshr i64 %5, %shr8.i.i
  %a1.0.i = select i1 %cmp4.i, i64 %or.i.i, i64 %4
  %6 = add nsw i32 %sub.i, -64
  %frac_hi7.i = getelementptr inbounds i8, ptr %b, i64 8
  %7 = load i64, ptr %frac_hi7.i, align 8
  %frac_lo8.i = getelementptr inbounds i8, ptr %b, i64 16
  %8 = load i64, ptr %frac_lo8.i, align 8
  %cmp.i.i = icmp ult i64 %7, %a0.0.i
  br i1 %cmp.i.i, label %if.then10.i, label %le128.exit.i

le128.exit.i:                                     ; preds = %if.end3.i
  %cmp1.i.i = icmp eq i64 %7, %a0.0.i
  %cmp2.i.i = icmp ule i64 %8, %a1.0.i
  %9 = and i1 %cmp1.i.i, %cmp2.i.i
  br i1 %9, label %if.then10.i, label %if.end11.i

if.then10.i:                                      ; preds = %le128.exit.i, %if.end3.i
  %10 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.0.i, i64 %8)
  %11 = extractvalue { i64, i1 } %10, 1
  %12 = extractvalue { i64, i1 } %10, 0
  %conv.i1.neg.i.i = sext i1 %11 to i64
  %13 = sub i64 %a0.0.i, %7
  %14 = add i64 %13, %conv.i1.neg.i.i
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then10.i, %le128.exit.i
  %conv250.i = phi i64 [ 1, %if.then10.i ], [ 0, %le128.exit.i ]
  %a0.1.i = phi i64 [ %14, %if.then10.i ], [ %a0.0.i, %le128.exit.i ]
  %a1.1.i = phi i64 [ %12, %if.then10.i ], [ %a1.0.i, %le128.exit.i ]
  %sub12.i = select i1 %cmp4.i, i32 -64, i32 %6
  %cmp13268.i = icmp sgt i32 %sub12.i, 0
  br i1 %cmp13268.i, label %while.body.lr.ph.i, label %while.end.i

while.body.lr.ph.i:                               ; preds = %if.end11.i
  %shr.i58.i = lshr i64 %7, 32
  %shl.i59.i = and i64 %7, -4294967296
  %conv.i.i.i.i = zext i64 %7 to i128
  %shl4.i.i = shl i64 %7, 32
  %conv.i.i.i61.i = zext i64 %8 to i128
  br label %while.body.i

while.body.i:                                     ; preds = %estimateDiv128To64.exit.i, %while.body.lr.ph.i
  %exp_diff.1273.i = phi i32 [ %6, %while.body.lr.ph.i ], [ %sub19.i, %estimateDiv128To64.exit.i ]
  %quot.0272.i = phi i64 [ %conv250.i, %while.body.lr.ph.i ], [ %add.i, %estimateDiv128To64.exit.i ]
  %a2.0271.i = phi i64 [ 0, %while.body.lr.ph.i ], [ %shl.i73.i, %estimateDiv128To64.exit.i ]
  %a1.2270.i = phi i64 [ %a1.1.i, %while.body.lr.ph.i ], [ %or.i71.i, %estimateDiv128To64.exit.i ]
  %a0.2269.i = phi i64 [ %a0.1.i, %while.body.lr.ph.i ], [ %or10.i.i, %estimateDiv128To64.exit.i ]
  %cmp.not.i.i = icmp ugt i64 %7, %a0.2269.i
  br i1 %cmp.not.i.i, label %if.end.i.i, label %estimateDiv128To64.exit.i

if.end.i.i:                                       ; preds = %while.body.i
  %cmp1.not.i.i = icmp ugt i64 %shl.i59.i, %a0.2269.i
  br i1 %cmp1.not.i.i, label %cond.false.i.i, label %cond.end.i.i

cond.false.i.i:                                   ; preds = %if.end.i.i
  %div.i.i = udiv i64 %a0.2269.i, %shr.i58.i
  %shl2.i.i = shl i64 %div.i.i, 32
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.false.i.i, %if.end.i.i
  %cond.i.i = phi i64 [ %shl2.i.i, %cond.false.i.i ], [ -4294967296, %if.end.i.i ]
  %conv1.i.i.i.i = zext i64 %cond.i.i to i128
  %mul.i.i.i.i = mul nuw i128 %conv1.i.i.i.i, %conv.i.i.i.i
  %conv2.i.i.i.i = trunc i128 %mul.i.i.i.i to i64
  %shr.i.i.i.i = lshr i128 %mul.i.i.i.i, 64
  %conv3.i.i.i.i = trunc i128 %shr.i.i.i.i to i64
  %15 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.2270.i, i64 %conv2.i.i.i.i)
  %16 = extractvalue { i64, i1 } %15, 1
  %conv.i1.neg.i.i.i = sext i1 %16 to i64
  %17 = sub i64 %a0.2269.i, %conv3.i.i.i.i
  %18 = add i64 %17, %conv.i1.neg.i.i.i
  %rem1.015.i.i = extractvalue { i64, i1 } %15, 0
  %cmp316.i.i = icmp slt i64 %18, 0
  br i1 %cmp316.i.i, label %while.body.i.i, label %while.end.i.i

while.body.i.i:                                   ; preds = %cond.end.i.i, %while.body.i.i
  %rem1.019.i.i = phi i64 [ %rem1.0.i.i, %while.body.i.i ], [ %rem1.015.i.i, %cond.end.i.i ]
  %z.018.i.i = phi i64 [ %sub.i.i, %while.body.i.i ], [ %cond.i.i, %cond.end.i.i ]
  %rem0.017.i.i = phi i64 [ %22, %while.body.i.i ], [ %18, %cond.end.i.i ]
  %sub.i.i = add i64 %z.018.i.i, -4294967296
  %19 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %rem1.019.i.i, i64 %shl4.i.i)
  %20 = extractvalue { i64, i1 } %19, 1
  %conv.i1.i.i.i = zext i1 %20 to i64
  %21 = add nsw i64 %rem0.017.i.i, %shr.i58.i
  %22 = add nsw i64 %21, %conv.i1.i.i.i
  %rem1.0.i.i = extractvalue { i64, i1 } %19, 0
  %cmp3.i.i = icmp slt i64 %22, 0
  br i1 %cmp3.i.i, label %while.body.i.i, label %while.end.i.i, !llvm.loop !8

while.end.i.i:                                    ; preds = %while.body.i.i, %cond.end.i.i
  %rem0.0.lcssa.i.i = phi i64 [ %18, %cond.end.i.i ], [ %22, %while.body.i.i ]
  %z.0.lcssa.i.i = phi i64 [ %cond.i.i, %cond.end.i.i ], [ %sub.i.i, %while.body.i.i ]
  %rem1.0.lcssa.i.i = phi i64 [ %rem1.015.i.i, %cond.end.i.i ], [ %rem1.0.i.i, %while.body.i.i ]
  %or.i60.i = tail call i64 @llvm.fshl.i64(i64 %rem0.0.lcssa.i.i, i64 %rem1.0.lcssa.i.i, i64 32)
  %cmp8.not.i.i = icmp ugt i64 %shl.i59.i, %or.i60.i
  br i1 %cmp8.not.i.i, label %cond.false10.i.i, label %cond.end12.i.i

cond.false10.i.i:                                 ; preds = %while.end.i.i
  %div11.i.i = udiv i64 %or.i60.i, %shr.i58.i
  br label %cond.end12.i.i

cond.end12.i.i:                                   ; preds = %cond.false10.i.i, %while.end.i.i
  %cond13.i.i = phi i64 [ %div11.i.i, %cond.false10.i.i ], [ 4294967295, %while.end.i.i ]
  %or14.i.i = or i64 %cond13.i.i, %z.0.lcssa.i.i
  br label %estimateDiv128To64.exit.i

estimateDiv128To64.exit.i:                        ; preds = %cond.end12.i.i, %while.body.i
  %retval.0.i.i = phi i64 [ %or14.i.i, %cond.end12.i.i ], [ -1, %while.body.i ]
  %cond.i = tail call i64 @llvm.usub.sat.i64(i64 %retval.0.i.i, i64 4)
  %conv1.i.i.i62.i = zext i64 %cond.i to i128
  %mul.i.i.i63.i = mul nuw i128 %conv1.i.i.i62.i, %conv.i.i.i61.i
  %conv2.i.i.i64.i = trunc i128 %mul.i.i.i63.i to i64
  %shr.i.i.i65.i = lshr i128 %mul.i.i.i63.i, 64
  %conv3.i.i.i66.i = trunc i128 %shr.i.i.i65.i to i64
  %mul.i.i4.i.i = mul nuw i128 %conv1.i.i.i62.i, %conv.i.i.i.i
  %conv2.i.i5.i.i = trunc i128 %mul.i.i4.i.i to i64
  %shr.i.i6.i.i = lshr i128 %mul.i.i4.i.i, 64
  %conv3.i.i7.i.i = trunc i128 %shr.i.i6.i.i to i64
  %23 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i5.i.i, i64 %conv3.i.i.i66.i)
  %24 = extractvalue { i64, i1 } %23, 1
  %25 = extractvalue { i64, i1 } %23, 0
  %conv.i1.i.i67.neg279.i = sext i1 %24 to i64
  %26 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a2.0271.i, i64 %conv2.i.i.i64.i)
  %27 = extractvalue { i64, i1 } %26, 1
  %28 = extractvalue { i64, i1 } %26, 0
  %conv.i1.i.i = zext i1 %27 to i64
  %29 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.2270.i, i64 %25)
  %30 = extractvalue { i64, i1 } %29, 1
  %31 = extractvalue { i64, i1 } %29, 0
  %32 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %31, i64 %conv.i1.i.i)
  %33 = extractvalue { i64, i1 } %32, 1
  %34 = extractvalue { i64, i1 } %32, 0
  %35 = or i1 %30, %33
  %conv.i3.neg.i.i = sext i1 %35 to i64
  %.neg266.i = sub i64 %a0.2269.i, %conv3.i.i7.i.i
  %36 = add i64 %.neg266.i, %conv.i1.i.i67.neg279.i
  %37 = add i64 %36, %conv.i3.neg.i.i
  %or.i71.i = tail call i64 @llvm.fshl.i64(i64 %34, i64 %28, i64 61)
  %or10.i.i = tail call i64 @llvm.fshl.i64(i64 %37, i64 %34, i64 61)
  %shl.i73.i = shl i64 %28, 61
  %sub19.i = add nsw i32 %exp_diff.1273.i, -61
  %shl.i = shl i64 %quot.0272.i, 61
  %add.i = add i64 %cond.i, %shl.i
  %cmp13.i = icmp sgt i32 %exp_diff.1273.i, 61
  br i1 %cmp13.i, label %while.body.i, label %while.end.i, !llvm.loop !12

while.end.i:                                      ; preds = %estimateDiv128To64.exit.i, %if.end11.i
  %a0.2.lcssa.i = phi i64 [ %a0.1.i, %if.end11.i ], [ %or10.i.i, %estimateDiv128To64.exit.i ]
  %a1.2.lcssa.i = phi i64 [ %a1.1.i, %if.end11.i ], [ %or.i71.i, %estimateDiv128To64.exit.i ]
  %a2.0.lcssa.i = phi i64 [ 0, %if.end11.i ], [ %shl.i73.i, %estimateDiv128To64.exit.i ]
  %q.0.lcssa.i = phi i64 [ %conv250.i, %if.end11.i ], [ %cond.i, %estimateDiv128To64.exit.i ]
  %quot.0.lcssa.i = phi i64 [ %conv250.i, %if.end11.i ], [ %add.i, %estimateDiv128To64.exit.i ]
  %exp_diff.1.lcssa.i = phi i32 [ %sub12.i, %if.end11.i ], [ %sub19.i, %estimateDiv128To64.exit.i ]
  %add20.i = add nsw i32 %exp_diff.1.lcssa.i, 64
  %cmp21.i = icmp sgt i32 %exp_diff.1.lcssa.i, -64
  br i1 %cmp21.i, label %if.then23.i, label %if.end50.i

if.then23.i:                                      ; preds = %while.end.i
  %cmp.not.i74.i = icmp ugt i64 %7, %a0.2.lcssa.i
  br i1 %cmp.not.i74.i, label %if.end.i76.i, label %estimateDiv128To64.exit115.thread.i

estimateDiv128To64.exit115.thread.i:              ; preds = %if.then23.i
  %sub29255.i = sub nsw i32 0, %exp_diff.1.lcssa.i
  %sh_prom256.i = zext nneg i32 %sub29255.i to i64
  %shr257.i = lshr i64 -5, %sh_prom256.i
  %.pre.i = zext i64 %7 to i128
  br label %shortShift192Left.exit.i

if.end.i76.i:                                     ; preds = %if.then23.i
  %shr.i77.i = lshr i64 %7, 32
  %shl.i78.i = and i64 %7, -4294967296
  %cmp1.not.i79.i = icmp ugt i64 %shl.i78.i, %a0.2.lcssa.i
  br i1 %cmp1.not.i79.i, label %cond.false.i112.i, label %cond.end.i80.i

cond.false.i112.i:                                ; preds = %if.end.i76.i
  %div.i113.i = udiv i64 %a0.2.lcssa.i, %shr.i77.i
  %shl2.i114.i = shl i64 %div.i113.i, 32
  br label %cond.end.i80.i

cond.end.i80.i:                                   ; preds = %cond.false.i112.i, %if.end.i76.i
  %cond.i81.i = phi i64 [ %shl2.i114.i, %cond.false.i112.i ], [ -4294967296, %if.end.i76.i ]
  %conv.i.i.i82.i = zext i64 %7 to i128
  %conv1.i.i.i83.i = zext i64 %cond.i81.i to i128
  %mul.i.i.i84.i = mul nuw i128 %conv1.i.i.i83.i, %conv.i.i.i82.i
  %conv2.i.i.i85.i = trunc i128 %mul.i.i.i84.i to i64
  %shr.i.i.i86.i = lshr i128 %mul.i.i.i84.i, 64
  %conv3.i.i.i87.i = trunc i128 %shr.i.i.i86.i to i64
  %38 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.2.lcssa.i, i64 %conv2.i.i.i85.i)
  %39 = extractvalue { i64, i1 } %38, 1
  %conv.i1.neg.i.i88.i = sext i1 %39 to i64
  %40 = sub i64 %a0.2.lcssa.i, %conv3.i.i.i87.i
  %41 = add i64 %40, %conv.i1.neg.i.i88.i
  %rem1.015.i89.i = extractvalue { i64, i1 } %38, 0
  %cmp316.i90.i = icmp slt i64 %41, 0
  br i1 %cmp316.i90.i, label %while.body.lr.ph.i102.i, label %while.end.i91.i

while.body.lr.ph.i102.i:                          ; preds = %cond.end.i80.i
  %shl4.i103.i = shl i64 %7, 32
  br label %while.body.i104.i

while.body.i104.i:                                ; preds = %while.body.i104.i, %while.body.lr.ph.i102.i
  %rem1.019.i105.i = phi i64 [ %rem1.015.i89.i, %while.body.lr.ph.i102.i ], [ %rem1.0.i110.i, %while.body.i104.i ]
  %z.018.i106.i = phi i64 [ %cond.i81.i, %while.body.lr.ph.i102.i ], [ %sub.i108.i, %while.body.i104.i ]
  %rem0.017.i107.i = phi i64 [ %41, %while.body.lr.ph.i102.i ], [ %45, %while.body.i104.i ]
  %sub.i108.i = add i64 %z.018.i106.i, -4294967296
  %42 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %rem1.019.i105.i, i64 %shl4.i103.i)
  %43 = extractvalue { i64, i1 } %42, 1
  %conv.i1.i.i109.i = zext i1 %43 to i64
  %44 = add nsw i64 %rem0.017.i107.i, %shr.i77.i
  %45 = add nsw i64 %44, %conv.i1.i.i109.i
  %rem1.0.i110.i = extractvalue { i64, i1 } %42, 0
  %cmp3.i111.i = icmp slt i64 %45, 0
  br i1 %cmp3.i111.i, label %while.body.i104.i, label %while.end.i91.i, !llvm.loop !8

while.end.i91.i:                                  ; preds = %while.body.i104.i, %cond.end.i80.i
  %rem0.0.lcssa.i92.i = phi i64 [ %41, %cond.end.i80.i ], [ %45, %while.body.i104.i ]
  %z.0.lcssa.i93.i = phi i64 [ %cond.i81.i, %cond.end.i80.i ], [ %sub.i108.i, %while.body.i104.i ]
  %rem1.0.lcssa.i94.i = phi i64 [ %rem1.015.i89.i, %cond.end.i80.i ], [ %rem1.0.i110.i, %while.body.i104.i ]
  %or.i95.i = tail call i64 @llvm.fshl.i64(i64 %rem0.0.lcssa.i92.i, i64 %rem1.0.lcssa.i94.i, i64 32)
  %cmp8.not.i96.i = icmp ugt i64 %shl.i78.i, %or.i95.i
  br i1 %cmp8.not.i96.i, label %cond.false10.i100.i, label %estimateDiv128To64.exit115.i

cond.false10.i100.i:                              ; preds = %while.end.i91.i
  %div11.i101.i = udiv i64 %or.i95.i, %shr.i77.i
  br label %estimateDiv128To64.exit115.i

estimateDiv128To64.exit115.i:                     ; preds = %cond.false10.i100.i, %while.end.i91.i
  %cond13.i98.i = phi i64 [ %div11.i101.i, %cond.false10.i100.i ], [ 4294967295, %while.end.i91.i ]
  %or14.i99.i = or i64 %cond13.i98.i, %z.0.lcssa.i93.i
  %or14.i99.fr.i = freeze i64 %or14.i99.i
  %cmp25.i = icmp ugt i64 %or14.i99.fr.i, 4
  %sub28.i = add i64 %or14.i99.fr.i, -4
  %sub29.i = sub nsw i32 0, %exp_diff.1.lcssa.i
  %sh_prom.i = zext nneg i32 %sub29.i to i64
  %shr.i = lshr i64 %sub28.i, %sh_prom.i
  %spec.select.i = select i1 %cmp25.i, i64 %shr.i, i64 0
  br label %shortShift192Left.exit.i

shortShift192Left.exit.i:                         ; preds = %estimateDiv128To64.exit115.i, %estimateDiv128To64.exit115.thread.i
  %conv.i.i2.i122.pre-phi.i = phi i128 [ %conv.i.i.i82.i, %estimateDiv128To64.exit115.i ], [ %.pre.i, %estimateDiv128To64.exit115.thread.i ]
  %sh_prom261.i = phi i64 [ %sh_prom.i, %estimateDiv128To64.exit115.i ], [ %sh_prom256.i, %estimateDiv128To64.exit115.thread.i ]
  %sub29259.i = phi i32 [ %sub29.i, %estimateDiv128To64.exit115.i ], [ %sub29255.i, %estimateDiv128To64.exit115.thread.i ]
  %46 = phi i64 [ %spec.select.i, %estimateDiv128To64.exit115.i ], [ %shr257.i, %estimateDiv128To64.exit115.thread.i ]
  %shl35.i = shl i64 %46, %sh_prom261.i
  %conv.i.i.i116.i = zext i64 %8 to i128
  %conv1.i.i.i117.i = zext i64 %shl35.i to i128
  %mul.i.i.i118.i = mul nuw i128 %conv1.i.i.i117.i, %conv.i.i.i116.i
  %conv2.i.i.i119.i = trunc i128 %mul.i.i.i118.i to i64
  %shr.i.i.i120.i = lshr i128 %mul.i.i.i118.i, 64
  %conv3.i.i.i121.i = trunc i128 %shr.i.i.i120.i to i64
  %mul.i.i4.i123.i = mul nuw i128 %conv.i.i2.i122.pre-phi.i, %conv1.i.i.i117.i
  %conv2.i.i5.i124.i = trunc i128 %mul.i.i4.i123.i to i64
  %shr.i.i6.i125.i = lshr i128 %mul.i.i4.i123.i, 64
  %conv3.i.i7.i126.i = trunc i128 %shr.i.i6.i125.i to i64
  %47 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i5.i124.i, i64 %conv3.i.i.i121.i)
  %48 = extractvalue { i64, i1 } %47, 1
  %49 = extractvalue { i64, i1 } %47, 0
  %conv.i1.i.i127.neg280.i = sext i1 %48 to i64
  %50 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a2.0.lcssa.i, i64 %conv2.i.i.i119.i)
  %51 = extractvalue { i64, i1 } %50, 1
  %conv.i1.i128.i = zext i1 %51 to i64
  %52 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.2.lcssa.i, i64 %49)
  %53 = extractvalue { i64, i1 } %52, 1
  %54 = extractvalue { i64, i1 } %52, 0
  %55 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %54, i64 %conv.i1.i128.i)
  %56 = extractvalue { i64, i1 } %55, 1
  %57 = or i1 %53, %56
  %conv.i3.neg.i129.i = sext i1 %57 to i64
  %.neg265.i = sub i64 %a0.2.lcssa.i, %conv3.i.i7.i126.i
  %58 = add i64 %.neg265.i, %conv.i1.i.i127.neg280.i
  %59 = add i64 %58, %conv.i3.neg.i129.i
  %shl2.i130.i = shl i64 %7, %sh_prom261.i
  %cmp.i131.i = icmp sgt i32 %sub29259.i, 0
  %conv.i.i = and i32 %exp_diff.1.lcssa.i, 63
  %sh_prom6.i.i = zext nneg i32 %conv.i.i to i64
  %shr.i134.i = lshr i64 %8, %sh_prom6.i.i
  %shr9.i136.i = lshr i64 %7, %sh_prom6.i.i
  %or.i135.i = select i1 %cmp.i131.i, i64 %shr.i134.i, i64 0
  %z1.0.i.i = or i64 %or.i135.i, %shl2.i130.i
  %z0.0.i.i = select i1 %cmp.i131.i, i64 %shr9.i136.i, i64 0
  %shl.i133.i = shl i64 %8, %sh_prom261.i
  br label %while.cond37.i

while.cond37.i:                                   ; preds = %while.body39.i, %shortShift192Left.exit.i
  %a0.3.i = phi i64 [ %59, %shortShift192Left.exit.i ], [ %69, %while.body39.i ]
  %.pn.i = phi { i64, i1 } [ %55, %shortShift192Left.exit.i ], [ %65, %while.body39.i ]
  %.pn264.i = phi { i64, i1 } [ %50, %shortShift192Left.exit.i ], [ %60, %while.body39.i ]
  %q.1.i = phi i64 [ %46, %shortShift192Left.exit.i ], [ %inc.i, %while.body39.i ]
  %a2.1.i = extractvalue { i64, i1 } %.pn264.i, 0
  %a1.3.i = extractvalue { i64, i1 } %.pn.i, 0
  %cmp.not.i137.i = icmp eq i64 %z0.0.i.i, %a0.3.i
  br i1 %cmp.not.i137.i, label %if.end.i141.i, label %if.then.i138.i

if.then.i138.i:                                   ; preds = %while.cond37.i
  %cmp1.i139.i = icmp ult i64 %z0.0.i.i, %a0.3.i
  br i1 %cmp1.i139.i, label %while.body39.i, label %while.end40.i

if.end.i141.i:                                    ; preds = %while.cond37.i
  %cmp2.not.i.i = icmp eq i64 %z1.0.i.i, %a1.3.i
  br i1 %cmp2.not.i.i, label %le192.exit.i, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.end.i141.i
  %cmp4.i.i = icmp ult i64 %z1.0.i.i, %a1.3.i
  br i1 %cmp4.i.i, label %while.body39.i, label %while.end40.i

le192.exit.i:                                     ; preds = %if.end.i141.i
  %cmp6.i.not.i = icmp ugt i64 %shl.i133.i, %a2.1.i
  br i1 %cmp6.i.not.i, label %while.end40.i, label %while.body39.i

while.body39.i:                                   ; preds = %le192.exit.i, %if.then3.i.i, %if.then.i138.i
  %inc.i = add i64 %q.1.i, 1
  %60 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a2.1.i, i64 %shl.i133.i)
  %61 = extractvalue { i64, i1 } %60, 1
  %conv.i1.i142.i = zext i1 %61 to i64
  %62 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.3.i, i64 %z1.0.i.i)
  %63 = extractvalue { i64, i1 } %62, 1
  %64 = extractvalue { i64, i1 } %62, 0
  %65 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %64, i64 %conv.i1.i142.i)
  %66 = extractvalue { i64, i1 } %65, 1
  %67 = or i1 %63, %66
  %conv.i3.neg.i143.i = sext i1 %67 to i64
  %68 = sub i64 %a0.3.i, %z0.0.i.i
  %69 = add i64 %68, %conv.i3.neg.i143.i
  br label %while.cond37.i, !llvm.loop !13

while.end40.i:                                    ; preds = %le192.exit.i, %if.then3.i.i, %if.then.i138.i
  %a0.3.lcssa.i = phi i64 [ %z0.0.i.i, %if.then3.i.i ], [ %a0.3.i, %if.then.i138.i ], [ %z0.0.i.i, %le192.exit.i ]
  %a1.3.lcssa.i = phi i64 [ %a1.3.i, %if.then3.i.i ], [ %a1.3.i, %if.then.i138.i ], [ %z1.0.i.i, %le192.exit.i ]
  %cmp41.not.i = icmp eq i32 %exp_diff.1.lcssa.i, 0
  %sh_prom44.i = zext nneg i32 %add20.i to i64
  %shl45.i = shl i64 %quot.0.lcssa.i, %sh_prom44.i
  %cond48.i = select i1 %cmp41.not.i, i64 0, i64 %shl45.i
  %add49.i = add i64 %q.1.i, %cond48.i
  br label %if.end50.i

if.end50.i:                                       ; preds = %while.end40.i, %while.end.i
  %a0.4.i = phi i64 [ %a0.3.lcssa.i, %while.end40.i ], [ %a0.2.lcssa.i, %while.end.i ]
  %a1.4.i = phi i64 [ %a1.3.lcssa.i, %while.end40.i ], [ %a1.2.lcssa.i, %while.end.i ]
  %a2.2.i = phi i64 [ %a2.1.i, %while.end40.i ], [ %a2.0.lcssa.i, %while.end.i ]
  %t0.0.i = phi i64 [ %z0.0.i.i, %while.end40.i ], [ %7, %while.end.i ]
  %t1.0.i = phi i64 [ %z1.0.i.i, %while.end40.i ], [ %8, %while.end.i ]
  %t2.0.i = phi i64 [ %shl.i133.i, %while.end40.i ], [ 0, %while.end.i ]
  %q.2.i = phi i64 [ %q.1.i, %while.end40.i ], [ %q.0.lcssa.i, %while.end.i ]
  %quot.1.i = phi i64 [ %add49.i, %while.end40.i ], [ %quot.0.lcssa.i, %while.end.i ]
  %tobool51.not.i = icmp eq ptr %mod_quot, null
  br i1 %tobool51.not.i, label %if.else53.i, label %if.then52.i

if.then52.i:                                      ; preds = %if.end50.i
  store i64 %quot.1.i, ptr %mod_quot, align 8
  br label %if.end63.i

if.else53.i:                                      ; preds = %if.end50.i
  %70 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %t2.0.i, i64 %a2.2.i)
  %71 = extractvalue { i64, i1 } %70, 1
  %72 = extractvalue { i64, i1 } %70, 0
  %conv.i1.i144.i = zext i1 %71 to i64
  %73 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %t1.0.i, i64 %a1.4.i)
  %74 = extractvalue { i64, i1 } %73, 1
  %75 = extractvalue { i64, i1 } %73, 0
  %76 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %75, i64 %conv.i1.i144.i)
  %77 = extractvalue { i64, i1 } %76, 1
  %78 = extractvalue { i64, i1 } %76, 0
  %79 = or i1 %74, %77
  %conv.i3.neg.i145.i = sext i1 %79 to i64
  %80 = sub i64 %t0.0.i, %a0.4.i
  %81 = add i64 %80, %conv.i3.neg.i145.i
  %cmp.not.i146.i = icmp eq i64 %81, %a0.4.i
  br i1 %cmp.not.i146.i, label %if.end.i150.i, label %if.then.i147.i

if.then.i147.i:                                   ; preds = %if.else53.i
  %cmp1.i148.i = icmp ult i64 %81, %a0.4.i
  br i1 %cmp1.i148.i, label %if.then59.i, label %lor.lhs.false.i

if.end.i150.i:                                    ; preds = %if.else53.i
  %cmp2.not.i151.i = icmp eq i64 %78, %a1.4.i
  br i1 %cmp2.not.i151.i, label %lt192.exit.i, label %if.then3.i152.i

if.then3.i152.i:                                  ; preds = %if.end.i150.i
  %cmp4.i153.i = icmp ult i64 %78, %a1.4.i
  br i1 %cmp4.i153.i, label %if.then59.i, label %lor.lhs.false.i

lt192.exit.i:                                     ; preds = %if.end.i150.i
  %cmp6.i155.i = icmp ult i64 %72, %a2.2.i
  br i1 %cmp6.i155.i, label %if.then59.i, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %lt192.exit.i, %if.then3.i152.i, %if.then.i147.i
  %82 = icmp eq i64 %78, %a1.4.i
  %83 = icmp eq i64 %72, %a2.2.i
  %84 = and i1 %83, %82
  %cmp.i156.i = and i1 %84, %cmp.not.i146.i
  %and.i = and i64 %q.2.i, 1
  %tobool58.not.i = icmp ne i64 %and.i, 0
  %or.cond.not.i = select i1 %cmp.i156.i, i1 %tobool58.not.i, i1 false
  br i1 %or.cond.not.i, label %if.then59.i, label %if.end63.i

if.then59.i:                                      ; preds = %lor.lhs.false.i, %lt192.exit.i, %if.then3.i152.i, %if.then.i147.i
  %sign.i = getelementptr inbounds i8, ptr %a, i64 1
  %85 = load i8, ptr %sign.i, align 1
  %86 = and i8 %85, 1
  %frombool.i = xor i8 %86, 1
  store i8 %frombool.i, ptr %sign.i, align 1
  br label %if.end63.i

if.end63.i:                                       ; preds = %if.then59.i, %lor.lhs.false.i, %if.then52.i
  %a0.5.i = phi i64 [ %81, %if.then59.i ], [ %a0.4.i, %lor.lhs.false.i ], [ %a0.4.i, %if.then52.i ]
  %a1.5.i = phi i64 [ %78, %if.then59.i ], [ %a1.4.i, %lor.lhs.false.i ], [ %a1.4.i, %if.then52.i ]
  %a2.3.i = phi i64 [ %72, %if.then59.i ], [ %a2.2.i, %lor.lhs.false.i ], [ %a2.2.i, %if.then52.i ]
  %tobool64.not.i = icmp eq i64 %a0.5.i, 0
  br i1 %tobool64.not.i, label %if.else71.i, label %if.then69.i

if.then69.i:                                      ; preds = %if.end63.i
  %87 = tail call i64 @llvm.ctlz.i64(i64 %a0.5.i, i1 true), !range !5
  %cast.i.i = trunc i64 %87 to i32
  %shl2.i158.i = shl i64 %a1.5.i, %87
  %shl4.i159.i = shl i64 %a0.5.i, %87
  %cmp.i160.not.i = icmp eq i32 %cast.i.i, 0
  br i1 %cmp.i160.not.i, label %shortShift192Left.exit172.i, label %if.then.i165.i

if.then.i165.i:                                   ; preds = %if.then69.i
  %88 = sub nsw i64 0, %87
  %conv.i166.i = and i64 %88, 63
  %shr.i168.i = lshr i64 %a2.3.i, %conv.i166.i
  %or.i169.i = or i64 %shr.i168.i, %shl2.i158.i
  %shr9.i170.i = lshr i64 %a1.5.i, %conv.i166.i
  %or10.i171.i = or i64 %shr9.i170.i, %shl4.i159.i
  br label %shortShift192Left.exit172.i

shortShift192Left.exit172.i:                      ; preds = %if.then.i165.i, %if.then69.i
  %z1.0.i162.i = phi i64 [ %or.i169.i, %if.then.i165.i ], [ %shl2.i158.i, %if.then69.i ]
  %z0.0.i163.i = phi i64 [ %or10.i171.i, %if.then.i165.i ], [ %shl4.i159.i, %if.then69.i ]
  %shl.i164.i = shl i64 %a2.3.i, %87
  %89 = icmp ne i64 %shl.i164.i, 0
  %90 = zext i1 %89 to i64
  br label %if.end98.i

if.else71.i:                                      ; preds = %if.end63.i
  %tobool72.not.i = icmp eq i64 %a1.5.i, 0
  br i1 %tobool72.not.i, label %if.else82.i, label %if.then79.i

if.then79.i:                                      ; preds = %if.else71.i
  %91 = tail call i64 @llvm.ctlz.i64(i64 %a1.5.i, i1 true), !range !5
  %cast.i173.i = trunc i64 %91 to i32
  %shl.i175.i = shl i64 %a2.3.i, %91
  %cmp.i176.i = icmp eq i32 %cast.i173.i, 0
  br i1 %cmp.i176.i, label %shortShift128Left.exit.i, label %cond.false.i177.i

cond.false.i177.i:                                ; preds = %if.then79.i
  %shl2.i178.i = shl i64 %a1.5.i, %91
  %sub.i179.i = sub nsw i64 0, %91
  %and.i.i = and i64 %sub.i179.i, 63
  %shr.i180.i = lshr i64 %a2.3.i, %and.i.i
  %or.i181.i = or i64 %shr.i180.i, %shl2.i178.i
  br label %shortShift128Left.exit.i

shortShift128Left.exit.i:                         ; preds = %cond.false.i177.i, %if.then79.i
  %cond.i183.i = phi i64 [ %or.i181.i, %cond.false.i177.i ], [ %a1.5.i, %if.then79.i ]
  %add81.i = or disjoint i32 %cast.i173.i, 64
  br label %if.end98.i

if.else82.i:                                      ; preds = %if.else71.i
  %tobool83.not.i = icmp eq i64 %a2.3.i, 0
  br i1 %tobool83.not.i, label %if.else95.i, label %if.then90.i

if.then90.i:                                      ; preds = %if.else82.i
  %92 = tail call i64 @llvm.ctlz.i64(i64 %a2.3.i, i1 true), !range !5
  %cast.i184.i = trunc i64 %92 to i32
  %shl93.i = shl i64 %a2.3.i, %92
  %add94.i = or disjoint i32 %cast.i184.i, 128
  br label %if.end98.i

if.else95.i:                                      ; preds = %if.else82.i
  store i8 1, ptr %a, align 8
  br label %return

if.end98.i:                                       ; preds = %if.then90.i, %shortShift128Left.exit.i, %shortShift192Left.exit172.i
  %a0.6.i = phi i64 [ %shl93.i, %if.then90.i ], [ %cond.i183.i, %shortShift128Left.exit.i ], [ %z0.0.i163.i, %shortShift192Left.exit172.i ]
  %a1.6.i = phi i64 [ 0, %if.then90.i ], [ %shl.i175.i, %shortShift128Left.exit.i ], [ %z1.0.i162.i, %shortShift192Left.exit172.i ]
  %a2.4.i = phi i64 [ 0, %if.then90.i ], [ 0, %shortShift128Left.exit.i ], [ %90, %shortShift192Left.exit172.i ]
  %shift.0.i = phi i32 [ %add94.i, %if.then90.i ], [ %add81.i, %shortShift128Left.exit.i ], [ %cast.i.i, %shortShift192Left.exit172.i ]
  %93 = load i32, ptr %exp1.i, align 4
  %add100.i = sub i32 %add20.i, %shift.0.i
  %sub101.i = add i32 %add100.i, %93
  store i32 %sub101.i, ptr %exp.i, align 4
  store i64 %a0.6.i, ptr %frac_hi.i, align 8
  %or.i = or i64 %a2.4.i, %a1.6.i
  store i64 %or.i, ptr %frac_lo.i, align 8
  br label %return

if.end:                                           ; preds = %entry
  %tobool7.not = icmp eq ptr %mod_quot, null
  br i1 %tobool7.not, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  store i64 0, ptr %mod_quot, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end
  %and = and i32 %or, 48
  %tobool10.not = icmp eq i32 %and, 0
  %94 = load i8, ptr %a, align 8
  br i1 %tobool10.not, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end9
  %cmp.i.i18 = icmp eq i8 %94, 5
  br i1 %cmp.i.i18, label %if.then.i23, label %lor.lhs.false.i19

lor.lhs.false.i19:                                ; preds = %if.then17
  %95 = load i8, ptr %b, align 8
  %cmp.i17.i = icmp eq i8 %95, 5
  br i1 %cmp.i17.i, label %if.then.i23, label %if.end.i

if.then.i23:                                      ; preds = %lor.lhs.false.i19, %if.then17
  %96 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %96, 8193
  store i16 %or1.i.i, ptr %s, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i23, %lor.lhs.false.i19
  %default_nan_mode.i = getelementptr inbounds i8, ptr %s, i64 7
  %97 = load i8, ptr %default_nan_mode.i, align 1
  %98 = and i8 %97, 1
  %tobool.not.i20 = icmp eq i8 %98, 0
  br i1 %tobool.not.i20, label %if.else.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  store i8 4, ptr %a, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %return

if.else.i:                                        ; preds = %if.end.i
  %frac_hi.i.i = getelementptr inbounds i8, ptr %a, i64 8
  %99 = load i64, ptr %frac_hi.i.i, align 8
  %frac_hi1.i.i = getelementptr inbounds i8, ptr %b, i64 8
  %100 = load i64, ptr %frac_hi1.i.i, align 8
  %cmp.i18.i = icmp eq i64 %99, %100
  br i1 %cmp.i18.i, label %if.then.i.i, label %frac128_cmp.exit.i

if.then.i.i:                                      ; preds = %if.else.i
  %frac_lo.i.i = getelementptr inbounds i8, ptr %a, i64 16
  %101 = load i64, ptr %frac_lo.i.i, align 8
  %frac_lo2.i.i = getelementptr inbounds i8, ptr %b, i64 16
  %102 = load i64, ptr %frac_lo2.i.i, align 8
  %cmp3.i.i21 = icmp eq i64 %101, %102
  br i1 %cmp3.i.i21, label %if.then6.i, label %frac128_cmp.exit.i

frac128_cmp.exit.i:                               ; preds = %if.then.i.i, %if.else.i
  %ta.0.i.i = phi i64 [ %101, %if.then.i.i ], [ %99, %if.else.i ]
  %tb.0.i.i = phi i64 [ %102, %if.then.i.i ], [ %100, %if.else.i ]
  %cmp6.i.i = icmp ult i64 %ta.0.i.i, %tb.0.i.i
  br label %if.end13.i

if.then6.i:                                       ; preds = %if.then.i.i
  %sign.i22 = getelementptr inbounds i8, ptr %a, i64 1
  %103 = load i8, ptr %sign.i22, align 1
  %104 = and i8 %103, 1
  %sign8.i = getelementptr inbounds i8, ptr %b, i64 1
  %105 = load i8, ptr %sign8.i, align 1
  %106 = and i8 %105, 1
  %cmp11.i = icmp uge i8 %104, %106
  br label %if.end13.i

if.end13.i:                                       ; preds = %if.then6.i, %frac128_cmp.exit.i
  %cmp.0.i = phi i1 [ %cmp11.i, %if.then6.i ], [ %cmp6.i.i, %frac128_cmp.exit.i ]
  %107 = load i8, ptr %a, align 8
  %108 = load i8, ptr %b, align 8
  switch i8 %107, label %109 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end13.i
  %cmp.i10.i.i = icmp eq i8 %108, 5
  br i1 %cmp.i10.i.i, label %return, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %108, 4
  %spec.select.i.i = and i1 %cmp.0.i, %cmp.i11.i.i
  %cond.fr31.i = freeze i1 %spec.select.i.i
  %spec.select = select i1 %cond.fr31.i, ptr %b, ptr %a
  br label %return

pickNaN.exit.i:                                   ; preds = %if.end13.i
  %cmp.i7.i.i = icmp eq i8 %108, 5
  %cmp.i8.i.i = icmp eq i8 %108, 4
  %spec.select25.i = select i1 %cmp.i7.i.i, i1 %cmp.0.i, i1 %cmp.i8.i.i
  %cond.fr.i = freeze i1 %spec.select25.i
  br i1 %cond.fr.i, label %109, label %if.then24.i

109:                                              ; preds = %if.end13.i, %pickNaN.exit.i
  %110 = icmp eq i8 %108, 5
  br i1 %110, label %if.then24.i, label %return

if.then24.i:                                      ; preds = %pickNaN.exit.i, %109
  %.ph.i29 = phi ptr [ %b, %109 ], [ %a, %pickNaN.exit.i ]
  %frac_hi.i22.i = getelementptr inbounds i8, ptr %.ph.i29, i64 8
  %111 = load i64, ptr %frac_hi.i22.i, align 8
  %or4.i.i.i = or i64 %111, 4611686018427387904
  store i64 %or4.i.i.i, ptr %frac_hi.i22.i, align 8
  store i8 4, ptr %.ph.i29, align 8
  br label %return

if.end18:                                         ; preds = %if.end9
  %cmp21 = icmp eq i8 %94, 3
  br i1 %cmp21, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end18
  %112 = load i8, ptr %b, align 8
  switch i8 %112, label %lor.lhs.false33 [
    i8 1, label %if.then27
    i8 3, label %return
  ]

if.then27:                                        ; preds = %lor.lhs.false, %if.end18
  %113 = load i16, ptr %s, align 2
  %or1.i = or i16 %113, 1
  store i16 %or1.i, ptr %s, align 2
  store i8 4, ptr %a, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %return

lor.lhs.false33:                                  ; preds = %lor.lhs.false
  %cmp36 = icmp eq i8 %94, 1
  br i1 %cmp36, label %return, label %if.else

if.else:                                          ; preds = %lor.lhs.false33
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 684, ptr noundef nonnull @__func__.parts128_modrem, ptr noundef nonnull @.str.14) #16
  unreachable

return:                                           ; preds = %lor.lhs.false.i.i, %if.then24.i, %109, %if.then6.i.i, %if.then3.i, %if.end98.i, %if.else95.i, %if.then2.i, %if.then.i, %lor.lhs.false33, %lor.lhs.false, %if.then27
  %retval.0 = phi ptr [ %a, %if.then27 ], [ %a, %lor.lhs.false ], [ %a, %lor.lhs.false33 ], [ %a, %if.then.i ], [ %a, %if.then2.i ], [ %a, %if.else95.i ], [ %a, %if.end98.i ], [ %a, %if.then3.i ], [ %.ph.i29, %if.then24.i ], [ %b, %109 ], [ %a, %if.then6.i.i ], [ %spec.select, %lor.lhs.false.i.i ]
  ret ptr %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @floatx80_modrem(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, i1 noundef zeroext %mod, ptr noundef %quotient, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts128, align 8
  %pb = alloca %struct.FloatParts128, align 8
  store i64 0, ptr %quotient, align 8
  %floatx80_rounding_precision.i = getelementptr inbounds i8, ptr %status, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i = icmp ult i8 %0, 3
  br i1 %switch.i, label %sw.epilog.i, label %do.body.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %entry
  %cmp.i.i = icmp slt i64 %a.coerce0, 0
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i.i = icmp eq i16 %1, 0
  %.not.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  br i1 %.not.i, label %if.end.i, label %floatx80_unpack_canonical.exit

if.end.i:                                         ; preds = %sw.epilog.i
  %f.coerce1.lobit.i.i = lshr i16 %a.coerce1, 15
  %frombool.i.i = trunc i16 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %pa, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %and.i.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.not.i = icmp eq i16 %1, 32767
  br i1 %cmp.not.i, label %lor.lhs.false.thread, label %lor.lhs.false

lor.lhs.false.thread:                             ; preds = %if.end.i
  %and.i = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %2 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i.i = icmp eq i64 %2, 0
  %3 = select i1 %tobool.not.i.i, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %3
  store i8 %cond17.i, ptr %pa, align 8
  br label %sw.epilog.i9

floatx80_unpack_canonical.exit:                   ; preds = %sw.epilog.i
  %4 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %4, 1
  store i16 %or1.i.i, ptr %status, align 2
  br label %return

lor.lhs.false:                                    ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pa, ptr noundef nonnull %status, ptr noundef nonnull @floatx80_params)
  %.pre = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i7 = icmp ult i8 %.pre, 3
  br i1 %switch.i7, label %sw.epilog.i9, label %do.body.i8

do.body.i8:                                       ; preds = %lor.lhs.false
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i9:                                     ; preds = %lor.lhs.false.thread, %lor.lhs.false
  %cmp.i.i10 = icmp slt i64 %b.coerce0, 0
  %5 = and i16 %b.coerce1, 32767
  %cmp2.i.i11 = icmp eq i16 %5, 0
  %.not.i12 = select i1 %cmp.i.i10, i1 true, i1 %cmp2.i.i11
  br i1 %.not.i12, label %if.end.i15, label %floatx80_unpack_canonical.exit30

if.end.i15:                                       ; preds = %sw.epilog.i9
  %f.coerce1.lobit.i.i16 = lshr i16 %b.coerce1, 15
  %frombool.i.i17 = trunc i16 %f.coerce1.lobit.i.i16 to i8
  %and.i.i.i18 = zext nneg i16 %5 to i32
  store i8 0, ptr %pb, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i19 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i17, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i19, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i20 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %and.i.i.i18, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i20, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i21 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %b.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i21, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i22 = getelementptr inbounds i8, ptr %pb, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i22, align 8
  %cmp.not.i23 = icmp eq i16 %5, 32767
  br i1 %cmp.not.i23, label %if.else.i25, label %if.then10.i24

if.then10.i24:                                    ; preds = %if.end.i15
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pb, ptr noundef nonnull %status, ptr noundef nonnull @floatx80_params)
  br label %if.end

if.else.i25:                                      ; preds = %if.end.i15
  %and.i26 = and i64 %b.coerce0, 9223372036854775807
  store i64 %and.i26, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i21, align 8
  %cmp12.i27 = icmp eq i64 %and.i26, 0
  %6 = and i64 %b.coerce0, 4611686018427387904
  %tobool.not.i.i28 = icmp eq i64 %6, 0
  %7 = select i1 %tobool.not.i.i28, i8 5, i8 4
  %cond17.i29 = select i1 %cmp12.i27, i8 3, i8 %7
  store i8 %cond17.i29, ptr %pb, align 8
  br label %if.end

floatx80_unpack_canonical.exit30:                 ; preds = %sw.epilog.i9
  %8 = load i16, ptr %status, align 2
  %or1.i.i14 = or i16 %8, 1
  store i16 %or1.i.i14, ptr %status, align 2
  br label %return

if.end:                                           ; preds = %if.then10.i24, %if.else.i25
  %cond = select i1 %mod, ptr %quotient, ptr null
  %call3 = call fastcc ptr @parts128_modrem(ptr noundef nonnull %pa, ptr noundef nonnull %pb, ptr noundef %cond, ptr noundef nonnull %status)
  %call4 = call fastcc { i64, i16 } @floatx80_round_pack_canonical(ptr noundef %call3, ptr noundef nonnull %status)
  %9 = extractvalue { i64, i16 } %call4, 0
  %10 = extractvalue { i64, i16 } %call4, 1
  br label %return

return:                                           ; preds = %floatx80_unpack_canonical.exit, %floatx80_unpack_canonical.exit30, %if.end
  %retval.sroa.0.0 = phi i64 [ %9, %if.end ], [ -4611686018427387904, %floatx80_unpack_canonical.exit30 ], [ -4611686018427387904, %floatx80_unpack_canonical.exit ]
  %retval.sroa.3.0 = phi i16 [ %10, %if.end ], [ -1, %floatx80_unpack_canonical.exit30 ], [ -1, %floatx80_unpack_canonical.exit ]
  %.fca.0.insert = insertvalue { i64, i16 } poison, i64 %retval.sroa.0.0, 0
  %.fca.1.insert = insertvalue { i64, i16 } %.fca.0.insert, i16 %retval.sroa.3.0, 1
  ret { i64, i16 } %.fca.1.insert
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @floatx80_rem(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %quotient = alloca i64, align 8
  %call = call { i64, i16 } @floatx80_modrem(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, i1 noundef zeroext false, ptr noundef nonnull %quotient, ptr noundef %status)
  ret { i64, i16 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @floatx80_mod(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %quotient = alloca i64, align 8
  %call = call { i64, i16 } @floatx80_modrem(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, i1 noundef zeroext true, ptr noundef nonnull %quotient, ptr noundef %status)
  ret { i64, i16 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float16_to_float32(i16 noundef zeroext %a, i1 noundef zeroext %ieee, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %conv.i.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i16 %1, label %if.then33.i.i [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_float_to_float.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_float_to_float.exit

lor.lhs.false.i.i:                                ; preds = %entry
  br i1 %ieee, label %if.else39.i.i, label %if.then33.i.i

if.then33.i.i:                                    ; preds = %entry, %lor.lhs.false.i.i
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

if.else39.i.i:                                    ; preds = %lor.lhs.false.i.i
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.then.i

if.then47.i.i:                                    ; preds = %if.else39.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_float_to_float.exit

if.then.i:                                        ; preds = %if.else39.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %if.then.i
  %7 = load i16, ptr %s, align 2
  %or1.i.i.i4 = or i16 %7, 8193
  store i16 %or1.i.i.i4, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode.i.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i.i, label %if.else.i.i6, label %if.then.i.i5

if.then.i.i5:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

if.else.i.i6:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_float_to_float.exit

sw.bb1.i.i:                                       ; preds = %if.then.i
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %parts64_float_to_float.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

parts64_float_to_float.exit:                      ; preds = %if.then33.i.i, %frac64_normalize.exit.i.i, %if.then47.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i5, %if.else.i.i6, %sw.bb1.i.i, %if.then4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float32_params)
  %12 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i7 = zext i8 %12 to i64
  %shl.i.i.i8 = shl nuw nsw i64 %conv.i.i.i7, 31
  %13 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %14 = shl i32 %13, 23
  %15 = and i32 %14, 2139095040
  %and8.i.i.i = zext nneg i32 %15 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i8, %and8.i.i.i
  %16 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %16, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  ret i32 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float16_to_float64(i16 noundef zeroext %a, i1 noundef zeroext %ieee, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %conv.i.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i16 %1, label %if.then33.i.i [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_float_to_float.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_float_to_float.exit

lor.lhs.false.i.i:                                ; preds = %entry
  br i1 %ieee, label %if.else39.i.i, label %if.then33.i.i

if.then33.i.i:                                    ; preds = %entry, %lor.lhs.false.i.i
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

if.else39.i.i:                                    ; preds = %lor.lhs.false.i.i
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.then.i

if.then47.i.i:                                    ; preds = %if.else39.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_float_to_float.exit

if.then.i:                                        ; preds = %if.else39.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %if.then.i
  %7 = load i16, ptr %s, align 2
  %or1.i.i.i4 = or i16 %7, 8193
  store i16 %or1.i.i.i4, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode.i.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i.i, label %if.else.i.i6, label %if.then.i.i5

if.then.i.i5:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

if.else.i.i6:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_float_to_float.exit

sw.bb1.i.i:                                       ; preds = %if.then.i
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %parts64_float_to_float.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

parts64_float_to_float.exit:                      ; preds = %if.then33.i.i, %frac64_normalize.exit.i.i, %if.then47.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i5, %if.else.i.i6, %sw.bb1.i.i, %if.then4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float64_params)
  %12 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %13 = and i8 %12, 1
  %conv.i.i.i7 = zext nneg i8 %13 to i64
  %shl.i.i.i8 = shl nuw i64 %conv.i.i.i7, 63
  %14 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %15 = and i32 %14, 2047
  %shl77.i.i.i = zext nneg i32 %15 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i.i8
  %16 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %16, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  ret i64 %or.i10.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float32_to_float16(i32 noundef %a, i1 noundef zeroext %ieee, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %and.i9.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %if.then33.i.i [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %float32_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float32_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float32_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float32_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %float32_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br label %float32_unpack_canonical.exit

float32_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %5 = phi i64 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i.i, %if.then33.i.i ], [ 0, %if.then47.i.i ], [ %shl.i31.i.i, %if.else49.i.i ]
  %6 = phi i8 [ 1, %if.then8.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ], [ 3, %if.then47.i.i ], [ %conv53.i.i, %if.else49.i.i ]
  br i1 %ieee, label %if.then, label %if.else

if.then:                                          ; preds = %float32_unpack_canonical.exit
  %cmp.i.i = icmp ugt i8 %6, 3
  br i1 %cmp.i.i, label %if.then.i, label %if.end

if.then.i:                                        ; preds = %if.then
  switch i8 %6, label %do.body.i.i [
    i8 5, label %sw.bb.i.i
    i8 4, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then.i
  %7 = load i16, ptr %s, align 2
  %or1.i.i.i6 = or i16 %7, 8193
  store i16 %or1.i.i.i6, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode.i.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i.i, label %if.else.i.i8, label %if.then.i.i7

if.then.i.i7:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %if.end

if.else.i.i8:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or i64 %5, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %if.end

sw.bb1.i.i:                                       ; preds = %if.then.i
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %if.end, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %if.end

do.body.i.i:                                      ; preds = %if.then.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 35, ptr noundef nonnull @__func__.parts64_return_nan, ptr noundef null) #16
  unreachable

if.else:                                          ; preds = %float32_unpack_canonical.exit
  switch i8 %6, label %do.body.i [
    i8 5, label %sw.bb.i
    i8 4, label %entry.sw.bb1_crit_edge.i
    i8 3, label %sw.bb3.i
    i8 2, label %if.end
    i8 1, label %if.end
  ]

entry.sw.bb1_crit_edge.i:                         ; preds = %if.else
  %.pre.i = load i16, ptr %s, align 2
  br label %sw.bb1.i

sw.bb.i:                                          ; preds = %if.else
  %12 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %12, 8192
  br label %sw.bb1.i

sw.bb1.i:                                         ; preds = %sw.bb.i, %entry.sw.bb1_crit_edge.i
  %13 = phi i16 [ %.pre.i, %entry.sw.bb1_crit_edge.i ], [ %or1.i.i, %sw.bb.i ]
  %or1.i7.i = or i16 %13, 1
  store i16 %or1.i7.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  br label %if.end

sw.bb3.i:                                         ; preds = %if.else
  %14 = load i16, ptr %s, align 2
  %or1.i8.i = or i16 %14, 1
  store i16 %or1.i8.i, ptr %s, align 2
  store i8 2, ptr %p, align 8
  store i32 31, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 -9007199254740992, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %if.end

do.body.i:                                        ; preds = %if.else
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 2700, ptr noundef nonnull @__func__.parts_float_to_ahp, ptr noundef null) #16
  unreachable

if.end:                                           ; preds = %sw.bb3.i, %sw.bb1.i, %if.else, %if.else, %if.then4.i.i, %sw.bb1.i.i, %if.else.i.i8, %if.then.i.i7, %if.then
  %float16_params_ahp.sink = phi ptr [ @float16_params, %if.then ], [ @float16_params, %if.then.i.i7 ], [ @float16_params, %if.else.i.i8 ], [ @float16_params, %sw.bb1.i.i ], [ @float16_params, %if.then4.i.i ], [ @float16_params_ahp, %if.else ], [ @float16_params_ahp, %if.else ], [ @float16_params_ahp, %sw.bb1.i ], [ @float16_params_ahp, %sw.bb3.i ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull %float16_params_ahp.sink)
  %15 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i11 = zext i8 %15 to i64
  %shl.i.i.i12 = shl nuw nsw i64 %conv.i.i.i11, 15
  %16 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %17 = shl i32 %16, 10
  %18 = and i32 %17, 31744
  %and8.i.i.i14 = zext nneg i32 %18 to i64
  %or.i.i.i15 = or disjoint i64 %shl.i.i.i12, %and8.i.i.i14
  %19 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i16 = and i64 %19, 1023
  %or.i10.i.i17 = or disjoint i64 %or.i.i.i15, %shl77.i9.i.i16
  %phi.call = trunc i64 %or.i10.i.i17 to i16
  ret i16 %phi.call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float32_to_float64(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %shr.i = lshr i32 %a, 23
  %add.i = add nuw nsw i32 %shr.i, 1
  %and.i = and i32 %add.i, 254
  %cmp.i.not = icmp eq i32 %and.i, 0
  br i1 %cmp.i.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = bitcast i32 %a to float
  %conv2 = fpext float %0 to double
  %1 = bitcast double %conv2 to i64
  br label %return

if.else:                                          ; preds = %entry
  %and.i5 = and i32 %a, 2147483647
  %cmp.i6 = icmp eq i32 %and.i5, 0
  br i1 %cmp.i6, label %if.then4, label %if.else8

if.then4:                                         ; preds = %if.else
  %a.lobit = lshr exact i32 %a, 31
  %conv.i = zext nneg i32 %a.lobit to i64
  %shl.i = shl nuw i64 %conv.i, 63
  br label %return

if.else8:                                         ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %and.i9.i.i = and i32 %shr.i, 255
  %2 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %and.i9.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i32 %shr.i to i8
  switch i8 %trunc.i, label %parts64_canonicalize.exit.i [
    i8 0, label %if.then.i6.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i6.i:                                     ; preds = %if.else8
  %cmp.i.i.i = icmp eq i32 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i6.i
  store i8 1, ptr %p.i, align 8
  br label %soft_float32_to_float64.exit

if.else.i.i:                                      ; preds = %if.then.i6.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p.i, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_float32_to_float64.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p.i, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %soft_float32_to_float64.exit

lor.lhs.false.i.i:                                ; preds = %if.else8
  %cmp.i29.i.i = icmp eq i32 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %parts64_canonicalize.exit.thread13.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p.i, align 8
  br label %soft_float32_to_float64.exit

parts64_canonicalize.exit.thread13.i:             ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i32 %2, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p.i, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

parts64_canonicalize.exit.i:                      ; preds = %if.else8
  store i8 2, ptr %p.i, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_float32_to_float64.exit

sw.bb.i.i:                                        ; preds = %parts64_canonicalize.exit.thread13.i
  %7 = load i16, ptr %s, align 2
  %or1.i.i8.i = or i16 %7, 8193
  store i16 %or1.i.i8.i, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode.i.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i.i, label %if.else.i10.i, label %if.then.i9.i

if.then.i9.i:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_float32_to_float64.exit

if.else.i10.i:                                    ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p.i, align 8
  br label %soft_float32_to_float64.exit

sw.bb1.i.i:                                       ; preds = %parts64_canonicalize.exit.thread13.i
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %soft_float32_to_float64.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_float32_to_float64.exit

soft_float32_to_float64.exit:                     ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then47.i.i, %parts64_canonicalize.exit.i, %if.then.i9.i, %if.else.i10.i, %sw.bb1.i.i, %if.then4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %s, ptr noundef nonnull @float64_params)
  %12 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %13 = and i8 %12, 1
  %conv.i.i.i = zext nneg i8 %13 to i64
  %shl.i.i11.i = shl nuw i64 %conv.i.i.i, 63
  %14 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %15 = and i32 %14, 2047
  %shl77.i.i.i = zext nneg i32 %15 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i11.i
  %16 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %16, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  br label %return

return:                                           ; preds = %soft_float32_to_float64.exit, %if.then4, %if.then
  %retval.0 = phi i64 [ %1, %if.then ], [ %shl.i, %if.then4 ], [ %or.i10.i.i, %soft_float32_to_float64.exit ]
  ret i64 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float64_to_float16(i64 noundef %a, i1 noundef zeroext %ieee, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %float64_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float64_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %float64_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br label %float64_unpack_canonical.exit

float64_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %5 = phi i64 [ 0, %if.then8.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i.i, %if.then33.i.i ], [ 0, %if.then47.i.i ], [ %shl.i31.i.i, %if.else49.i.i ]
  %6 = phi i8 [ 1, %if.then8.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ], [ 3, %if.then47.i.i ], [ %conv53.i.i, %if.else49.i.i ]
  br i1 %ieee, label %if.then, label %if.else

if.then:                                          ; preds = %float64_unpack_canonical.exit
  %cmp.i.i = icmp ugt i8 %6, 3
  br i1 %cmp.i.i, label %if.then.i, label %if.end

if.then.i:                                        ; preds = %if.then
  switch i8 %6, label %do.body.i.i [
    i8 5, label %sw.bb.i.i
    i8 4, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then.i
  %7 = load i16, ptr %s, align 2
  %or1.i.i.i6 = or i16 %7, 8193
  store i16 %or1.i.i.i6, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode.i.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i.i, label %if.else.i.i8, label %if.then.i.i7

if.then.i.i7:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %if.end

if.else.i.i8:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or i64 %5, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %if.end

sw.bb1.i.i:                                       ; preds = %if.then.i
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %if.end, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %if.end

do.body.i.i:                                      ; preds = %if.then.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 35, ptr noundef nonnull @__func__.parts64_return_nan, ptr noundef null) #16
  unreachable

if.else:                                          ; preds = %float64_unpack_canonical.exit
  switch i8 %6, label %do.body.i [
    i8 5, label %sw.bb.i
    i8 4, label %entry.sw.bb1_crit_edge.i
    i8 3, label %sw.bb3.i
    i8 2, label %if.end
    i8 1, label %if.end
  ]

entry.sw.bb1_crit_edge.i:                         ; preds = %if.else
  %.pre.i = load i16, ptr %s, align 2
  br label %sw.bb1.i

sw.bb.i:                                          ; preds = %if.else
  %12 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %12, 8192
  br label %sw.bb1.i

sw.bb1.i:                                         ; preds = %sw.bb.i, %entry.sw.bb1_crit_edge.i
  %13 = phi i16 [ %.pre.i, %entry.sw.bb1_crit_edge.i ], [ %or1.i.i, %sw.bb.i ]
  %or1.i7.i = or i16 %13, 1
  store i16 %or1.i7.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  br label %if.end

sw.bb3.i:                                         ; preds = %if.else
  %14 = load i16, ptr %s, align 2
  %or1.i8.i = or i16 %14, 1
  store i16 %or1.i8.i, ptr %s, align 2
  store i8 2, ptr %p, align 8
  store i32 31, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 -9007199254740992, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %if.end

do.body.i:                                        ; preds = %if.else
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 2700, ptr noundef nonnull @__func__.parts_float_to_ahp, ptr noundef null) #16
  unreachable

if.end:                                           ; preds = %sw.bb3.i, %sw.bb1.i, %if.else, %if.else, %if.then4.i.i, %sw.bb1.i.i, %if.else.i.i8, %if.then.i.i7, %if.then
  %float16_params_ahp.sink = phi ptr [ @float16_params, %if.then ], [ @float16_params, %if.then.i.i7 ], [ @float16_params, %if.else.i.i8 ], [ @float16_params, %sw.bb1.i.i ], [ @float16_params, %if.then4.i.i ], [ @float16_params_ahp, %if.else ], [ @float16_params_ahp, %if.else ], [ @float16_params_ahp, %sw.bb1.i ], [ @float16_params_ahp, %sw.bb3.i ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull %float16_params_ahp.sink)
  %15 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i12 = zext i8 %15 to i64
  %shl.i.i.i13 = shl nuw nsw i64 %conv.i.i.i12, 15
  %16 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %17 = shl i32 %16, 10
  %18 = and i32 %17, 31744
  %and8.i.i.i15 = zext nneg i32 %18 to i64
  %or.i.i.i16 = or disjoint i64 %shl.i.i.i13, %and8.i.i.i15
  %19 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i17 = and i64 %19, 1023
  %or.i10.i.i18 = or disjoint i64 %or.i.i.i16, %shl77.i9.i.i17
  %phi.call = trunc i64 %or.i10.i.i18 to i16
  ret i16 %phi.call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float64_to_float32(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %float64_unpack_canonical.exit [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_float_to_float.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_float_to_float.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %float64_unpack_canonical.exit.thread9

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_float_to_float.exit

float64_unpack_canonical.exit.thread9:            ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

float64_unpack_canonical.exit:                    ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

sw.bb.i.i:                                        ; preds = %float64_unpack_canonical.exit.thread9
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i3 = or i16 %5, 8193
  store i16 %or1.i.i.i3, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_float_to_float.exit

sw.bb1.i.i:                                       ; preds = %float64_unpack_canonical.exit.thread9
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode2.i.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i, label %parts64_float_to_float.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

parts64_float_to_float.exit:                      ; preds = %float64_unpack_canonical.exit, %if.then47.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float32_params)
  %10 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i6 = zext i8 %10 to i64
  %shl.i.i.i7 = shl nuw nsw i64 %conv.i.i.i6, 31
  %11 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %12 = shl i32 %11, 23
  %13 = and i32 %12, 2139095040
  %and8.i.i.i = zext nneg i32 %13 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i7, %and8.i.i.i
  %14 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %14, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  ret i32 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bfloat16_to_float32(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %bfloat16_unpack_canonical.exit [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_float_to_float.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_float_to_float.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %bfloat16_unpack_canonical.exit.thread9

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_float_to_float.exit

bfloat16_unpack_canonical.exit.thread9:           ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 64
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

bfloat16_unpack_canonical.exit:                   ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

sw.bb.i.i:                                        ; preds = %bfloat16_unpack_canonical.exit.thread9
  %7 = load i16, ptr %s, align 2
  %or1.i.i.i3 = or i16 %7, 8193
  store i16 %or1.i.i.i3, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode.i.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_float_to_float.exit

sw.bb1.i.i:                                       ; preds = %bfloat16_unpack_canonical.exit.thread9
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %parts64_float_to_float.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

parts64_float_to_float.exit:                      ; preds = %bfloat16_unpack_canonical.exit, %if.then47.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float32_params)
  %12 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i6 = zext i8 %12 to i64
  %shl.i.i.i7 = shl nuw nsw i64 %conv.i.i.i6, 31
  %13 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %14 = shl i32 %13, 23
  %15 = and i32 %14, 2139095040
  %and8.i.i.i = zext nneg i32 %15 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i7, %and8.i.i.i
  %16 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %16, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  ret i32 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bfloat16_to_float64(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %bfloat16_unpack_canonical.exit [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_float_to_float.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_float_to_float.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %bfloat16_unpack_canonical.exit.thread9

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_float_to_float.exit

bfloat16_unpack_canonical.exit.thread9:           ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 64
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

bfloat16_unpack_canonical.exit:                   ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

sw.bb.i.i:                                        ; preds = %bfloat16_unpack_canonical.exit.thread9
  %7 = load i16, ptr %s, align 2
  %or1.i.i.i3 = or i16 %7, 8193
  store i16 %or1.i.i.i3, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode.i.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_float_to_float.exit

sw.bb1.i.i:                                       ; preds = %bfloat16_unpack_canonical.exit.thread9
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %parts64_float_to_float.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

parts64_float_to_float.exit:                      ; preds = %bfloat16_unpack_canonical.exit, %if.then47.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float64_params)
  %12 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %13 = and i8 %12, 1
  %conv.i.i.i6 = zext nneg i8 %13 to i64
  %shl.i.i.i7 = shl nuw i64 %conv.i.i.i6, 63
  %14 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %15 = and i32 %14, 2047
  %shl77.i.i.i = zext nneg i32 %15 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i.i7
  %16 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %16, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  ret i64 %or.i10.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float32_to_bfloat16(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %and.i9.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %float32_unpack_canonical.exit [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_float_to_float.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_float_to_float.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %float32_unpack_canonical.exit.thread8

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_float_to_float.exit

float32_unpack_canonical.exit.thread8:            ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

float32_unpack_canonical.exit:                    ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

sw.bb.i.i:                                        ; preds = %float32_unpack_canonical.exit.thread8
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i3 = or i16 %5, 8193
  store i16 %or1.i.i.i3, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_float_to_float.exit

sw.bb1.i.i:                                       ; preds = %float32_unpack_canonical.exit.thread8
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode2.i.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i, label %parts64_float_to_float.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

parts64_float_to_float.exit:                      ; preds = %float32_unpack_canonical.exit, %if.then47.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @bfloat16_params)
  %10 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i = zext i8 %10 to i64
  %shl.i.i.i6 = shl nuw nsw i64 %conv.i.i.i, 15
  %11 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %12 = shl i32 %11, 7
  %13 = and i32 %12, 32640
  %and8.i.i.i = zext nneg i32 %13 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i6, %and8.i.i.i
  %14 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %14, 127
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i16
  ret i16 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float64_to_bfloat16(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %float64_unpack_canonical.exit [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_float_to_float.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_float_to_float.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %float64_unpack_canonical.exit.thread9

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_float_to_float.exit

float64_unpack_canonical.exit.thread9:            ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

float64_unpack_canonical.exit:                    ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

sw.bb.i.i:                                        ; preds = %float64_unpack_canonical.exit.thread9
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i3 = or i16 %5, 8193
  store i16 %or1.i.i.i3, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_float_to_float.exit

sw.bb1.i.i:                                       ; preds = %float64_unpack_canonical.exit.thread9
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode2.i.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i, label %parts64_float_to_float.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_float_to_float.exit

parts64_float_to_float.exit:                      ; preds = %float64_unpack_canonical.exit, %if.then47.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @bfloat16_params)
  %10 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i6 = zext i8 %10 to i64
  %shl.i.i.i7 = shl nuw nsw i64 %conv.i.i.i6, 15
  %11 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %12 = shl i32 %11, 7
  %13 = and i32 %12, 32640
  %and8.i.i.i = zext nneg i32 %13 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i7, %and8.i.i.i
  %14 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %14, 127
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i16
  ret i16 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float128_to_float32(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p64 = alloca %struct.FloatParts64, align 8
  %p128 = alloca %struct.FloatParts128, align 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %p128, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 8
  store i64 %and.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p128, ptr noundef %s, ptr noundef nonnull @float128_params)
  %1 = load i8, ptr %p128, align 8
  store i8 %1, ptr %p64, align 8
  %2 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %3 = and i8 %2, 1
  %sign2.i = getelementptr inbounds i8, ptr %p64, i64 1
  store i8 %3, ptr %sign2.i, align 1
  %4 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %exp3.i = getelementptr inbounds i8, ptr %p64, i64 4
  store i32 %4, ptr %exp3.i, align 4
  %cmp.i = icmp eq i8 %1, 2
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  %b.val.i = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %b.val12.i = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.i.i = icmp ne i64 %b.val12.i, 0
  %conv1.i.i = zext i1 %cmp.i.i to i64
  %or.i.i = or i64 %b.val.i, %conv1.i.i
  %5 = getelementptr inbounds i8, ptr %p64, i64 8
  store i64 %or.i.i, ptr %5, align 8
  br label %parts_float_to_float_narrow.exit

if.else.i:                                        ; preds = %entry
  %cmp.i13.i = icmp ugt i8 %1, 3
  br i1 %cmp.i13.i, label %if.then7.i, label %parts_float_to_float_narrow.exit

if.then7.i:                                       ; preds = %if.else.i
  %6 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %7 = getelementptr inbounds i8, ptr %p64, i64 8
  store i64 %6, ptr %7, align 8
  switch i8 %1, label %do.body.i.i [
    i8 5, label %sw.bb.i.i
    i8 4, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then7.i
  %8 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %8, 8193
  store i16 %or1.i.i.i, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %9 = load i8, ptr %default_nan_mode.i.i, align 1
  %10 = and i8 %9, 1
  %tobool.not.i.i = icmp eq i8 %10, 0
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb.i.i
  store i8 4, ptr %p64, align 8
  store i8 0, ptr %sign2.i, align 1
  store i32 2147483647, ptr %exp3.i, align 4
  store i64 4611686018427387904, ptr %7, align 8
  br label %parts_float_to_float_narrow.exit

if.else.i.i:                                      ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or i64 %6, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %7, align 8
  store i8 4, ptr %p64, align 8
  br label %parts_float_to_float_narrow.exit

sw.bb1.i.i:                                       ; preds = %if.then7.i
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %11 = load i8, ptr %default_nan_mode2.i.i, align 1
  %12 = and i8 %11, 1
  %tobool3.not.i.i = icmp eq i8 %12, 0
  br i1 %tobool3.not.i.i, label %parts_float_to_float_narrow.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p64, align 8
  store i8 0, ptr %sign2.i, align 1
  store i32 2147483647, ptr %exp3.i, align 4
  store i64 4611686018427387904, ptr %7, align 8
  br label %parts_float_to_float_narrow.exit

do.body.i.i:                                      ; preds = %if.then7.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 35, ptr noundef nonnull @__func__.parts64_return_nan, ptr noundef null) #16
  unreachable

parts_float_to_float_narrow.exit:                 ; preds = %if.then.i, %if.else.i, %if.then.i.i, %if.else.i.i, %sw.bb1.i.i, %if.then4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p64, ptr noundef %s, ptr noundef nonnull @float32_params)
  %13 = load i8, ptr %sign2.i, align 1
  %conv.i.i.i = zext i8 %13 to i64
  %shl.i.i.i = shl nuw nsw i64 %conv.i.i.i, 31
  %14 = load i32, ptr %exp3.i, align 4
  %15 = shl i32 %14, 23
  %16 = and i32 %15, 2139095040
  %and8.i.i.i = zext nneg i32 %16 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i, %and8.i.i.i
  %17 = getelementptr inbounds i8, ptr %p64, i64 8
  %18 = load i64, ptr %17, align 8
  %shl77.i9.i.i = and i64 %18, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i3 = trunc i64 %or.i10.i.i to i32
  ret i32 %conv.i.i3
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float128_to_float64(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p64 = alloca %struct.FloatParts64, align 8
  %p128 = alloca %struct.FloatParts128, align 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %p128, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 8
  store i64 %and.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p128, ptr noundef %s, ptr noundef nonnull @float128_params)
  %1 = load i8, ptr %p128, align 8
  store i8 %1, ptr %p64, align 8
  %2 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %3 = and i8 %2, 1
  %sign2.i = getelementptr inbounds i8, ptr %p64, i64 1
  store i8 %3, ptr %sign2.i, align 1
  %4 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %exp3.i = getelementptr inbounds i8, ptr %p64, i64 4
  store i32 %4, ptr %exp3.i, align 4
  %cmp.i = icmp eq i8 %1, 2
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  %b.val.i = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %b.val12.i = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.i.i = icmp ne i64 %b.val12.i, 0
  %conv1.i.i = zext i1 %cmp.i.i to i64
  %or.i.i = or i64 %b.val.i, %conv1.i.i
  %5 = getelementptr inbounds i8, ptr %p64, i64 8
  store i64 %or.i.i, ptr %5, align 8
  br label %parts_float_to_float_narrow.exit

if.else.i:                                        ; preds = %entry
  %cmp.i13.i = icmp ugt i8 %1, 3
  br i1 %cmp.i13.i, label %if.then7.i, label %parts_float_to_float_narrow.exit

if.then7.i:                                       ; preds = %if.else.i
  %6 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %7 = getelementptr inbounds i8, ptr %p64, i64 8
  store i64 %6, ptr %7, align 8
  switch i8 %1, label %do.body.i.i [
    i8 5, label %sw.bb.i.i
    i8 4, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then7.i
  %8 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %8, 8193
  store i16 %or1.i.i.i, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %9 = load i8, ptr %default_nan_mode.i.i, align 1
  %10 = and i8 %9, 1
  %tobool.not.i.i = icmp eq i8 %10, 0
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb.i.i
  store i8 4, ptr %p64, align 8
  store i8 0, ptr %sign2.i, align 1
  store i32 2147483647, ptr %exp3.i, align 4
  store i64 4611686018427387904, ptr %7, align 8
  br label %parts_float_to_float_narrow.exit

if.else.i.i:                                      ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or i64 %6, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %7, align 8
  store i8 4, ptr %p64, align 8
  br label %parts_float_to_float_narrow.exit

sw.bb1.i.i:                                       ; preds = %if.then7.i
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %11 = load i8, ptr %default_nan_mode2.i.i, align 1
  %12 = and i8 %11, 1
  %tobool3.not.i.i = icmp eq i8 %12, 0
  br i1 %tobool3.not.i.i, label %parts_float_to_float_narrow.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p64, align 8
  store i8 0, ptr %sign2.i, align 1
  store i32 2147483647, ptr %exp3.i, align 4
  store i64 4611686018427387904, ptr %7, align 8
  br label %parts_float_to_float_narrow.exit

do.body.i.i:                                      ; preds = %if.then7.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 35, ptr noundef nonnull @__func__.parts64_return_nan, ptr noundef null) #16
  unreachable

parts_float_to_float_narrow.exit:                 ; preds = %if.then.i, %if.else.i, %if.then.i.i, %if.else.i.i, %sw.bb1.i.i, %if.then4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p64, ptr noundef %s, ptr noundef nonnull @float64_params)
  %13 = load i8, ptr %sign2.i, align 1
  %14 = and i8 %13, 1
  %conv.i.i.i = zext nneg i8 %14 to i64
  %shl.i.i.i = shl nuw i64 %conv.i.i.i, 63
  %15 = load i32, ptr %exp3.i, align 4
  %16 = and i32 %15, 2047
  %shl77.i.i.i = zext nneg i32 %16 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i.i
  %17 = getelementptr inbounds i8, ptr %p64, i64 8
  %18 = load i64, ptr %17, align 8
  %shl77.i9.i.i = and i64 %18, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  ret i64 %or.i10.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float32_to_float128(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p128 = alloca %struct.FloatParts128, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %if.then33.i.i [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %float32_unpack_canonical.exit.thread, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %float32_unpack_canonical.exit.thread

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  br label %float32_unpack_canonical.exit.thread

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %float32_unpack_canonical.exit.thread, label %float32_unpack_canonical.exit

if.then33.i.i:                                    ; preds = %entry
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  br label %float32_unpack_canonical.exit.thread

float32_unpack_canonical.exit.thread:             ; preds = %if.then33.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then.i.i, %lor.lhs.false.i.i
  %p64.sroa.10.0.ph = phi i32 [ %and.i9.i.i, %lor.lhs.false.i.i ], [ %and.i9.i.i, %if.then.i.i ], [ %and.i9.i.i, %if.then10.i.i ], [ %add.i.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ]
  %p64.sroa.14.0.ph = phi i64 [ 0, %lor.lhs.false.i.i ], [ 0, %if.then.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i.i, %if.then33.i.i ]
  %p64.sroa.0.0.ph = phi i8 [ 3, %lor.lhs.false.i.i ], [ 1, %if.then.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ]
  store i8 %p64.sroa.0.0.ph, ptr %p128, align 8
  %sign2.i9 = getelementptr inbounds i8, ptr %p128, i64 1
  store i8 %frombool.i.i.i, ptr %sign2.i9, align 1
  %exp3.i10 = getelementptr inbounds i8, ptr %p128, i64 4
  store i32 %p64.sroa.10.0.ph, ptr %exp3.i10, align 4
  %frac_hi.i.i11 = getelementptr inbounds i8, ptr %p128, i64 8
  store i64 %p64.sroa.14.0.ph, ptr %frac_hi.i.i11, align 8
  %frac_lo.i.i12 = getelementptr inbounds i8, ptr %p128, i64 16
  store i64 0, ptr %frac_lo.i.i12, align 8
  br label %parts_float_to_float_widen.exit

float32_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p128, align 8
  %sign2.i = getelementptr inbounds i8, ptr %p128, i64 1
  store i8 %frombool.i.i.i, ptr %sign2.i, align 1
  %exp3.i = getelementptr inbounds i8, ptr %p128, i64 4
  store i32 %and.i9.i.i, ptr %exp3.i, align 4
  %frac_hi.i.i = getelementptr inbounds i8, ptr %p128, i64 8
  store i64 %shl.i31.i.i, ptr %frac_hi.i.i, align 8
  %frac_lo.i.i = getelementptr inbounds i8, ptr %p128, i64 16
  store i64 0, ptr %frac_lo.i.i, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %float32_unpack_canonical.exit
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i3 = or i16 %5, 8193
  store i16 %or1.i.i.i3, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p128, align 8
  store i8 0, ptr %sign2.i, align 1
  store i32 2147483647, ptr %exp3.i, align 4
  store i64 4611686018427387904, ptr %frac_hi.i.i, align 8
  br label %parts_float_to_float_widen.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %frac_hi.i.i, align 8
  store i8 4, ptr %p128, align 8
  br label %parts_float_to_float_widen.exit

sw.bb1.i.i:                                       ; preds = %float32_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode2.i.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i, label %parts_float_to_float_widen.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p128, align 8
  store i8 0, ptr %sign2.i, align 1
  store i32 2147483647, ptr %exp3.i, align 4
  store i64 4611686018427387904, ptr %frac_hi.i.i, align 8
  br label %parts_float_to_float_widen.exit

parts_float_to_float_widen.exit:                  ; preds = %float32_unpack_canonical.exit.thread, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i
  %call = call fastcc { i64, i64 } @float128_round_pack_canonical(ptr noundef nonnull %p128, ptr noundef %s)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float64_to_float128(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p128 = alloca %struct.FloatParts128, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %float64_unpack_canonical.exit.thread, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %float64_unpack_canonical.exit.thread

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  br label %float64_unpack_canonical.exit.thread

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %float64_unpack_canonical.exit.thread, label %float64_unpack_canonical.exit

if.then33.i.i:                                    ; preds = %entry
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  br label %float64_unpack_canonical.exit.thread

float64_unpack_canonical.exit.thread:             ; preds = %if.then33.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then.i.i, %lor.lhs.false.i.i
  %p64.sroa.10.0.ph = phi i32 [ 2047, %lor.lhs.false.i.i ], [ 0, %if.then.i.i ], [ 0, %if.then10.i.i ], [ %add.i.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ]
  %p64.sroa.14.0.ph = phi i64 [ 0, %lor.lhs.false.i.i ], [ 0, %if.then.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i.i, %if.then33.i.i ]
  %p64.sroa.0.0.ph = phi i8 [ 3, %lor.lhs.false.i.i ], [ 1, %if.then.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ]
  store i8 %p64.sroa.0.0.ph, ptr %p128, align 8
  %sign2.i9 = getelementptr inbounds i8, ptr %p128, i64 1
  store i8 %frombool.i.i.i, ptr %sign2.i9, align 1
  %exp3.i10 = getelementptr inbounds i8, ptr %p128, i64 4
  store i32 %p64.sroa.10.0.ph, ptr %exp3.i10, align 4
  %frac_hi.i.i11 = getelementptr inbounds i8, ptr %p128, i64 8
  store i64 %p64.sroa.14.0.ph, ptr %frac_hi.i.i11, align 8
  %frac_lo.i.i12 = getelementptr inbounds i8, ptr %p128, i64 16
  store i64 0, ptr %frac_lo.i.i12, align 8
  br label %parts_float_to_float_widen.exit

float64_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p128, align 8
  %sign2.i = getelementptr inbounds i8, ptr %p128, i64 1
  store i8 %frombool.i.i.i, ptr %sign2.i, align 1
  %exp3.i = getelementptr inbounds i8, ptr %p128, i64 4
  store i32 2047, ptr %exp3.i, align 4
  %frac_hi.i.i = getelementptr inbounds i8, ptr %p128, i64 8
  store i64 %shl.i31.i.i, ptr %frac_hi.i.i, align 8
  %frac_lo.i.i = getelementptr inbounds i8, ptr %p128, i64 16
  store i64 0, ptr %frac_lo.i.i, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %float64_unpack_canonical.exit
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i3 = or i16 %5, 8193
  store i16 %or1.i.i.i3, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p128, align 8
  store i8 0, ptr %sign2.i, align 1
  store i32 2147483647, ptr %exp3.i, align 4
  store i64 4611686018427387904, ptr %frac_hi.i.i, align 8
  br label %parts_float_to_float_widen.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %frac_hi.i.i, align 8
  store i8 4, ptr %p128, align 8
  br label %parts_float_to_float_widen.exit

sw.bb1.i.i:                                       ; preds = %float64_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode2.i.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i, label %parts_float_to_float_widen.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p128, align 8
  store i8 0, ptr %sign2.i, align 1
  store i32 2147483647, ptr %exp3.i, align 4
  store i64 4611686018427387904, ptr %frac_hi.i.i, align 8
  br label %parts_float_to_float_widen.exit

parts_float_to_float_widen.exit:                  ; preds = %float64_unpack_canonical.exit.thread, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i
  %call = call fastcc { i64, i64 } @float128_round_pack_canonical(ptr noundef nonnull %p128, ptr noundef %s)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @floatx80_to_float32(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p64 = alloca %struct.FloatParts64, align 8
  %p128 = alloca %struct.FloatParts128, align 8
  %floatx80_rounding_precision.i = getelementptr inbounds i8, ptr %s, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i = icmp ult i8 %0, 3
  br i1 %switch.i, label %sw.epilog.i, label %do.body.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %entry
  %cmp.i.i = icmp slt i64 %a.coerce0, 0
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i.i = icmp eq i16 %1, 0
  %.not.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  br i1 %.not.i, label %if.end.i, label %if.else

if.end.i:                                         ; preds = %sw.epilog.i
  %f.coerce1.lobit.i.i = lshr i16 %a.coerce1, 15
  %frombool.i.i = trunc i16 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %p128, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 4
  store i32 %and.i.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 8
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.not.i = icmp eq i16 %1, 32767
  br i1 %cmp.not.i, label %if.then.thread, label %if.then

if.then.thread:                                   ; preds = %if.end.i
  %and.i = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %2 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i.i = icmp eq i64 %2, 0
  %3 = select i1 %tobool.not.i.i, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %3
  store i8 %cond17.i, ptr %p64, align 8
  %sign2.i9 = getelementptr inbounds i8, ptr %p64, i64 1
  store i8 %frombool.i.i, ptr %sign2.i9, align 1
  %exp3.i10 = getelementptr inbounds i8, ptr %p64, i64 4
  store i32 %and.i.i.i, ptr %exp3.i10, align 4
  br label %if.else.i4

if.then:                                          ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p128, ptr noundef nonnull %s, ptr noundef nonnull @floatx80_params)
  %.pr = load i8, ptr %p128, align 8
  %.pre = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.pre8 = load i32, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i8 %.pr, ptr %p64, align 8
  %4 = and i8 %.pre, 1
  %sign2.i = getelementptr inbounds i8, ptr %p64, i64 1
  store i8 %4, ptr %sign2.i, align 1
  %exp3.i = getelementptr inbounds i8, ptr %p64, i64 4
  store i32 %.pre8, ptr %exp3.i, align 4
  %cmp.i = icmp eq i8 %.pr, 2
  br i1 %cmp.i, label %if.then.i6, label %if.else.i4

if.then.i6:                                       ; preds = %if.then
  %b.val.i = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %b.val12.i = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.i.i7 = icmp ne i64 %b.val12.i, 0
  %conv1.i.i = zext i1 %cmp.i.i7 to i64
  %or.i.i = or i64 %b.val.i, %conv1.i.i
  %5 = getelementptr inbounds i8, ptr %p64, i64 8
  store i64 %or.i.i, ptr %5, align 8
  br label %if.end

if.else.i4:                                       ; preds = %if.then.thread, %if.then
  %exp3.i13 = phi ptr [ %exp3.i10, %if.then.thread ], [ %exp3.i, %if.then ]
  %sign2.i12 = phi ptr [ %sign2.i9, %if.then.thread ], [ %sign2.i, %if.then ]
  %6 = phi i8 [ %cond17.i, %if.then.thread ], [ %.pr, %if.then ]
  %cmp.i13.i = icmp ugt i8 %6, 3
  br i1 %cmp.i13.i, label %if.then7.i, label %if.end

if.then7.i:                                       ; preds = %if.else.i4
  %7 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %8 = getelementptr inbounds i8, ptr %p64, i64 8
  store i64 %7, ptr %8, align 8
  switch i8 %6, label %do.body.i.i [
    i8 5, label %sw.bb.i.i
    i8 4, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then7.i
  %9 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %9, 8193
  store i16 %or1.i.i.i, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %10 = load i8, ptr %default_nan_mode.i.i, align 1
  %11 = and i8 %10, 1
  %tobool.not.i.i5 = icmp eq i8 %11, 0
  br i1 %tobool.not.i.i5, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb.i.i
  store i8 4, ptr %p64, align 8
  store i8 0, ptr %sign2.i12, align 1
  store i32 2147483647, ptr %exp3.i13, align 4
  store i64 4611686018427387904, ptr %8, align 8
  br label %if.end

if.else.i.i:                                      ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or i64 %7, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %8, align 8
  store i8 4, ptr %p64, align 8
  br label %if.end

sw.bb1.i.i:                                       ; preds = %if.then7.i
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %12 = load i8, ptr %default_nan_mode2.i.i, align 1
  %13 = and i8 %12, 1
  %tobool3.not.i.i = icmp eq i8 %13, 0
  br i1 %tobool3.not.i.i, label %if.end, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p64, align 8
  store i8 0, ptr %sign2.i12, align 1
  store i32 2147483647, ptr %exp3.i13, align 4
  store i64 4611686018427387904, ptr %8, align 8
  br label %if.end

do.body.i.i:                                      ; preds = %if.then7.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 35, ptr noundef nonnull @__func__.parts64_return_nan, ptr noundef null) #16
  unreachable

if.else:                                          ; preds = %sw.epilog.i
  %14 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %14, 1
  store i16 %or1.i.i, ptr %s, align 2
  store i8 4, ptr %p64, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %p64, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %p64, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %p64, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4.i.i, %sw.bb1.i.i, %if.else.i.i, %if.then.i.i, %if.else.i4, %if.then.i6, %if.else
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p64, ptr noundef nonnull %s, ptr noundef nonnull @float32_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %p64, i64 1
  %15 = load i8, ptr %sign.i.i.i, align 1
  %conv.i.i.i = zext i8 %15 to i64
  %shl.i.i.i = shl nuw nsw i64 %conv.i.i.i, 31
  %exp.i.i.i = getelementptr inbounds i8, ptr %p64, i64 4
  %16 = load i32, ptr %exp.i.i.i, align 4
  %17 = shl i32 %16, 23
  %18 = and i32 %17, 2139095040
  %and8.i.i.i = zext nneg i32 %18 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i, %and8.i.i.i
  %19 = getelementptr inbounds i8, ptr %p64, i64 8
  %20 = load i64, ptr %19, align 8
  %shl77.i9.i.i = and i64 %20, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  ret i32 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @floatx80_to_float64(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p64 = alloca %struct.FloatParts64, align 8
  %p128 = alloca %struct.FloatParts128, align 8
  %floatx80_rounding_precision.i = getelementptr inbounds i8, ptr %s, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i = icmp ult i8 %0, 3
  br i1 %switch.i, label %sw.epilog.i, label %do.body.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %entry
  %cmp.i.i = icmp slt i64 %a.coerce0, 0
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i.i = icmp eq i16 %1, 0
  %.not.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  br i1 %.not.i, label %if.end.i, label %if.else

if.end.i:                                         ; preds = %sw.epilog.i
  %f.coerce1.lobit.i.i = lshr i16 %a.coerce1, 15
  %frombool.i.i = trunc i16 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %p128, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 4
  store i32 %and.i.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 8
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p128, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.not.i = icmp eq i16 %1, 32767
  br i1 %cmp.not.i, label %if.then.thread, label %if.then

if.then.thread:                                   ; preds = %if.end.i
  %and.i = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %2 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i.i = icmp eq i64 %2, 0
  %3 = select i1 %tobool.not.i.i, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %3
  store i8 %cond17.i, ptr %p64, align 8
  %sign2.i9 = getelementptr inbounds i8, ptr %p64, i64 1
  store i8 %frombool.i.i, ptr %sign2.i9, align 1
  %exp3.i10 = getelementptr inbounds i8, ptr %p64, i64 4
  store i32 %and.i.i.i, ptr %exp3.i10, align 4
  br label %if.else.i4

if.then:                                          ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p128, ptr noundef nonnull %s, ptr noundef nonnull @floatx80_params)
  %.pr = load i8, ptr %p128, align 8
  %.pre = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.pre8 = load i32, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i8 %.pr, ptr %p64, align 8
  %4 = and i8 %.pre, 1
  %sign2.i = getelementptr inbounds i8, ptr %p64, i64 1
  store i8 %4, ptr %sign2.i, align 1
  %exp3.i = getelementptr inbounds i8, ptr %p64, i64 4
  store i32 %.pre8, ptr %exp3.i, align 4
  %cmp.i = icmp eq i8 %.pr, 2
  br i1 %cmp.i, label %if.then.i6, label %if.else.i4

if.then.i6:                                       ; preds = %if.then
  %b.val.i = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %b.val12.i = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.i.i7 = icmp ne i64 %b.val12.i, 0
  %conv1.i.i = zext i1 %cmp.i.i7 to i64
  %or.i.i = or i64 %b.val.i, %conv1.i.i
  %5 = getelementptr inbounds i8, ptr %p64, i64 8
  store i64 %or.i.i, ptr %5, align 8
  br label %if.end

if.else.i4:                                       ; preds = %if.then.thread, %if.then
  %exp3.i13 = phi ptr [ %exp3.i10, %if.then.thread ], [ %exp3.i, %if.then ]
  %sign2.i12 = phi ptr [ %sign2.i9, %if.then.thread ], [ %sign2.i, %if.then ]
  %6 = phi i8 [ %cond17.i, %if.then.thread ], [ %.pr, %if.then ]
  %cmp.i13.i = icmp ugt i8 %6, 3
  br i1 %cmp.i13.i, label %if.then7.i, label %if.end

if.then7.i:                                       ; preds = %if.else.i4
  %7 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %8 = getelementptr inbounds i8, ptr %p64, i64 8
  store i64 %7, ptr %8, align 8
  switch i8 %6, label %do.body.i.i [
    i8 5, label %sw.bb.i.i
    i8 4, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then7.i
  %9 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %9, 8193
  store i16 %or1.i.i.i, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %10 = load i8, ptr %default_nan_mode.i.i, align 1
  %11 = and i8 %10, 1
  %tobool.not.i.i5 = icmp eq i8 %11, 0
  br i1 %tobool.not.i.i5, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb.i.i
  store i8 4, ptr %p64, align 8
  store i8 0, ptr %sign2.i12, align 1
  store i32 2147483647, ptr %exp3.i13, align 4
  store i64 4611686018427387904, ptr %8, align 8
  br label %if.end

if.else.i.i:                                      ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or i64 %7, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %8, align 8
  store i8 4, ptr %p64, align 8
  br label %if.end

sw.bb1.i.i:                                       ; preds = %if.then7.i
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %12 = load i8, ptr %default_nan_mode2.i.i, align 1
  %13 = and i8 %12, 1
  %tobool3.not.i.i = icmp eq i8 %13, 0
  br i1 %tobool3.not.i.i, label %if.end, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p64, align 8
  store i8 0, ptr %sign2.i12, align 1
  store i32 2147483647, ptr %exp3.i13, align 4
  store i64 4611686018427387904, ptr %8, align 8
  br label %if.end

do.body.i.i:                                      ; preds = %if.then7.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 35, ptr noundef nonnull @__func__.parts64_return_nan, ptr noundef null) #16
  unreachable

if.else:                                          ; preds = %sw.epilog.i
  %14 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %14, 1
  store i16 %or1.i.i, ptr %s, align 2
  store i8 4, ptr %p64, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %p64, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %p64, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %p64, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4.i.i, %sw.bb1.i.i, %if.else.i.i, %if.then.i.i, %if.else.i4, %if.then.i6, %if.else
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p64, ptr noundef nonnull %s, ptr noundef nonnull @float64_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %p64, i64 1
  %15 = load i8, ptr %sign.i.i.i, align 1
  %16 = and i8 %15, 1
  %conv.i.i.i = zext nneg i8 %16 to i64
  %shl.i.i.i = shl nuw i64 %conv.i.i.i, 63
  %exp.i.i.i = getelementptr inbounds i8, ptr %p64, i64 4
  %17 = load i32, ptr %exp.i.i.i, align 4
  %18 = and i32 %17, 2047
  %shl77.i.i.i = zext nneg i32 %18 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i.i
  %19 = getelementptr inbounds i8, ptr %p64, i64 8
  %20 = load i64, ptr %19, align 8
  %shl77.i9.i.i = and i64 %20, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  ret i64 %or.i10.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @floatx80_to_float128(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %floatx80_rounding_precision.i = getelementptr inbounds i8, ptr %s, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i = icmp ult i8 %0, 3
  br i1 %switch.i, label %sw.epilog.i, label %do.body.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %entry
  %cmp.i.i = icmp slt i64 %a.coerce0, 0
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i.i = icmp eq i16 %1, 0
  %.not.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  br i1 %.not.i, label %if.end.i, label %if.else

if.end.i:                                         ; preds = %sw.epilog.i
  %f.coerce1.lobit.i.i = lshr i16 %a.coerce1, 15
  %frombool.i.i = trunc i16 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %p, align 8
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 %and.i.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.not.i = icmp eq i16 %1, 32767
  br i1 %cmp.not.i, label %if.else.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef nonnull %s, ptr noundef nonnull @floatx80_params)
  %.pr = load i8, ptr %p, align 8
  br label %if.then

if.else.i:                                        ; preds = %if.end.i
  %and.i = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %2 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i.i = icmp eq i64 %2, 0
  %3 = select i1 %tobool.not.i.i, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %3
  store i8 %cond17.i, ptr %p, align 8
  br label %if.then

if.then:                                          ; preds = %if.then10.i, %if.else.i
  %4 = phi i8 [ %.pr, %if.then10.i ], [ %cond17.i, %if.else.i ]
  %cmp.i.i4 = icmp ugt i8 %4, 3
  br i1 %cmp.i.i4, label %if.then.i6, label %if.end

if.then.i6:                                       ; preds = %if.then
  switch i8 %4, label %do.body.i.i [
    i8 5, label %sw.bb.i.i
    i8 4, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then.i6
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 8193
  store i16 %or1.i.i.i, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i7 = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i7, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %if.end

if.else.i.i:                                      ; preds = %sw.bb.i.i
  %8 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %or4.i.i.i.i = or i64 %8, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %if.end

sw.bb1.i.i:                                       ; preds = %if.then.i6
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %9 = load i8, ptr %default_nan_mode2.i.i, align 1
  %10 = and i8 %9, 1
  %tobool3.not.i.i = icmp eq i8 %10, 0
  br i1 %tobool3.not.i.i, label %if.end, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %if.end

do.body.i.i:                                      ; preds = %if.then.i6
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 35, ptr noundef nonnull @__func__.parts128_return_nan, ptr noundef null) #16
  unreachable

if.else:                                          ; preds = %sw.epilog.i
  %11 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %11, 1
  store i16 %or1.i.i, ptr %s, align 2
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4.i.i, %sw.bb1.i.i, %if.else.i.i, %if.then.i.i, %if.then, %if.else
  %call1 = call fastcc { i64, i64 } @float128_round_pack_canonical(ptr noundef nonnull %p, ptr noundef nonnull %s)
  ret { i64, i64 } %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @float32_to_floatx80(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p128 = alloca %struct.FloatParts128, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %if.then33.i.i [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %float32_unpack_canonical.exit.thread, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %float32_unpack_canonical.exit.thread

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  br label %float32_unpack_canonical.exit.thread

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %float32_unpack_canonical.exit.thread, label %float32_unpack_canonical.exit

if.then33.i.i:                                    ; preds = %entry
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  br label %float32_unpack_canonical.exit.thread

float32_unpack_canonical.exit.thread:             ; preds = %if.then33.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then.i.i, %lor.lhs.false.i.i
  %p64.sroa.10.0.ph = phi i32 [ %and.i9.i.i, %lor.lhs.false.i.i ], [ %and.i9.i.i, %if.then.i.i ], [ %and.i9.i.i, %if.then10.i.i ], [ %add.i.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ]
  %p64.sroa.14.0.ph = phi i64 [ 0, %lor.lhs.false.i.i ], [ 0, %if.then.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i.i, %if.then33.i.i ]
  %p64.sroa.0.0.ph = phi i8 [ 3, %lor.lhs.false.i.i ], [ 1, %if.then.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ]
  store i8 %p64.sroa.0.0.ph, ptr %p128, align 8
  %sign2.i9 = getelementptr inbounds i8, ptr %p128, i64 1
  store i8 %frombool.i.i.i, ptr %sign2.i9, align 1
  %exp3.i10 = getelementptr inbounds i8, ptr %p128, i64 4
  store i32 %p64.sroa.10.0.ph, ptr %exp3.i10, align 4
  %frac_hi.i.i11 = getelementptr inbounds i8, ptr %p128, i64 8
  store i64 %p64.sroa.14.0.ph, ptr %frac_hi.i.i11, align 8
  %frac_lo.i.i12 = getelementptr inbounds i8, ptr %p128, i64 16
  store i64 0, ptr %frac_lo.i.i12, align 8
  br label %parts_float_to_float_widen.exit

float32_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p128, align 8
  %sign2.i = getelementptr inbounds i8, ptr %p128, i64 1
  store i8 %frombool.i.i.i, ptr %sign2.i, align 1
  %exp3.i = getelementptr inbounds i8, ptr %p128, i64 4
  store i32 %and.i9.i.i, ptr %exp3.i, align 4
  %frac_hi.i.i = getelementptr inbounds i8, ptr %p128, i64 8
  store i64 %shl.i31.i.i, ptr %frac_hi.i.i, align 8
  %frac_lo.i.i = getelementptr inbounds i8, ptr %p128, i64 16
  store i64 0, ptr %frac_lo.i.i, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %float32_unpack_canonical.exit
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i3 = or i16 %5, 8193
  store i16 %or1.i.i.i3, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p128, align 8
  store i8 0, ptr %sign2.i, align 1
  store i32 2147483647, ptr %exp3.i, align 4
  store i64 4611686018427387904, ptr %frac_hi.i.i, align 8
  br label %parts_float_to_float_widen.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %frac_hi.i.i, align 8
  store i8 4, ptr %p128, align 8
  br label %parts_float_to_float_widen.exit

sw.bb1.i.i:                                       ; preds = %float32_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode2.i.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i, label %parts_float_to_float_widen.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p128, align 8
  store i8 0, ptr %sign2.i, align 1
  store i32 2147483647, ptr %exp3.i, align 4
  store i64 4611686018427387904, ptr %frac_hi.i.i, align 8
  br label %parts_float_to_float_widen.exit

parts_float_to_float_widen.exit:                  ; preds = %float32_unpack_canonical.exit.thread, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i
  %call = call fastcc { i64, i16 } @floatx80_round_pack_canonical(ptr noundef nonnull %p128, ptr noundef %s)
  ret { i64, i16 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @float64_to_floatx80(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p128 = alloca %struct.FloatParts128, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %float64_unpack_canonical.exit.thread, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %float64_unpack_canonical.exit.thread

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  br label %float64_unpack_canonical.exit.thread

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %float64_unpack_canonical.exit.thread, label %float64_unpack_canonical.exit

if.then33.i.i:                                    ; preds = %entry
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  br label %float64_unpack_canonical.exit.thread

float64_unpack_canonical.exit.thread:             ; preds = %if.then33.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then.i.i, %lor.lhs.false.i.i
  %p64.sroa.10.0.ph = phi i32 [ 2047, %lor.lhs.false.i.i ], [ 0, %if.then.i.i ], [ 0, %if.then10.i.i ], [ %add.i.i, %frac64_normalize.exit.i.i ], [ %sub37.i.i, %if.then33.i.i ]
  %p64.sroa.14.0.ph = phi i64 [ 0, %lor.lhs.false.i.i ], [ 0, %if.then.i.i ], [ 0, %if.then10.i.i ], [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ %or.i.i, %if.then33.i.i ]
  %p64.sroa.0.0.ph = phi i8 [ 3, %lor.lhs.false.i.i ], [ 1, %if.then.i.i ], [ 1, %if.then10.i.i ], [ 2, %frac64_normalize.exit.i.i ], [ 2, %if.then33.i.i ]
  store i8 %p64.sroa.0.0.ph, ptr %p128, align 8
  %sign2.i9 = getelementptr inbounds i8, ptr %p128, i64 1
  store i8 %frombool.i.i.i, ptr %sign2.i9, align 1
  %exp3.i10 = getelementptr inbounds i8, ptr %p128, i64 4
  store i32 %p64.sroa.10.0.ph, ptr %exp3.i10, align 4
  %frac_hi.i.i11 = getelementptr inbounds i8, ptr %p128, i64 8
  store i64 %p64.sroa.14.0.ph, ptr %frac_hi.i.i11, align 8
  %frac_lo.i.i12 = getelementptr inbounds i8, ptr %p128, i64 16
  store i64 0, ptr %frac_lo.i.i12, align 8
  br label %parts_float_to_float_widen.exit

float64_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p128, align 8
  %sign2.i = getelementptr inbounds i8, ptr %p128, i64 1
  store i8 %frombool.i.i.i, ptr %sign2.i, align 1
  %exp3.i = getelementptr inbounds i8, ptr %p128, i64 4
  store i32 2047, ptr %exp3.i, align 4
  %frac_hi.i.i = getelementptr inbounds i8, ptr %p128, i64 8
  store i64 %shl.i31.i.i, ptr %frac_hi.i.i, align 8
  %frac_lo.i.i = getelementptr inbounds i8, ptr %p128, i64 16
  store i64 0, ptr %frac_lo.i.i, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %float64_unpack_canonical.exit
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i3 = or i16 %5, 8193
  store i16 %or1.i.i.i3, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p128, align 8
  store i8 0, ptr %sign2.i, align 1
  store i32 2147483647, ptr %exp3.i, align 4
  store i64 4611686018427387904, ptr %frac_hi.i.i, align 8
  br label %parts_float_to_float_widen.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %frac_hi.i.i, align 8
  store i8 4, ptr %p128, align 8
  br label %parts_float_to_float_widen.exit

sw.bb1.i.i:                                       ; preds = %float64_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode2.i.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i, label %parts_float_to_float_widen.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p128, align 8
  store i8 0, ptr %sign2.i, align 1
  store i32 2147483647, ptr %exp3.i, align 4
  store i64 4611686018427387904, ptr %frac_hi.i.i, align 8
  br label %parts_float_to_float_widen.exit

parts_float_to_float_widen.exit:                  ; preds = %float64_unpack_canonical.exit.thread, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i
  %call = call fastcc { i64, i16 } @floatx80_round_pack_canonical(ptr noundef nonnull %p128, ptr noundef %s)
  ret { i64, i16 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @float128_to_floatx80(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float128_params)
  %1 = load i8, ptr %p, align 8
  %cmp.i.i = icmp ugt i8 %1, 3
  br i1 %cmp.i.i, label %if.then.i, label %parts128_float_to_float.exit

if.then.i:                                        ; preds = %entry
  switch i8 %1, label %do.body.i.i [
    i8 5, label %sw.bb.i.i
    i8 4, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then.i
  %2 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %2, 8193
  store i16 %or1.i.i.i, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %3 = load i8, ptr %default_nan_mode.i.i, align 1
  %4 = and i8 %3, 1
  %tobool.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %parts128_float_to_float.exit

if.else.i.i:                                      ; preds = %sw.bb.i.i
  %5 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %or4.i.i.i.i = or i64 %5, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts128_float_to_float.exit

sw.bb1.i.i:                                       ; preds = %if.then.i
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode2.i.i, align 1
  %7 = and i8 %6, 1
  %tobool3.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool3.not.i.i, label %parts128_float_to_float.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %parts128_float_to_float.exit

do.body.i.i:                                      ; preds = %if.then.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 35, ptr noundef nonnull @__func__.parts128_return_nan, ptr noundef null) #16
  unreachable

parts128_float_to_float.exit:                     ; preds = %entry, %if.then.i.i, %if.else.i.i, %sw.bb1.i.i, %if.then4.i.i
  %call = call fastcc { i64, i16 } @floatx80_round_pack_canonical(ptr noundef nonnull %p, ptr noundef %s)
  ret { i64, i16 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_round_to_int(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %conv.i.i.i4 = zext nneg i16 %1 to i32
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i4, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i16 %1, label %float16a_unpack_canonical.exit.thread [
    i16 0, label %if.then.i.i5
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i5:                                     ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i6

if.then8.i.i:                                     ; preds = %if.then.i.i5
  store i8 1, ptr %p, align 8
  br label %parts64_round_to_int.exit

if.else.i.i6:                                     ; preds = %if.then.i.i5
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %float16a_unpack_canonical.exit.thread9, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i6
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i7 = or i16 %5, 32
  store i16 %or1.i.i.i7, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_round_to_int.exit

float16a_unpack_canonical.exit.thread9:           ; preds = %if.else.i.i6
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb2.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit.thread:            ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i4, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb2.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_round_to_int.exit

float16a_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %float16a_unpack_canonical.exit
  %7 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %7, 8193
  store i16 %or1.i.i.i, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode.i.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_round_to_int.exit

if.else.i.i:                                      ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_round_to_int.exit

sw.bb1.i.i:                                       ; preds = %float16a_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %parts64_round_to_int.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_round_to_int.exit

sw.bb2.i:                                         ; preds = %float16a_unpack_canonical.exit.thread, %float16a_unpack_canonical.exit.thread9
  %.in = getelementptr inbounds i8, ptr %s, i64 2
  %12 = load i8, ptr %.in, align 2
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %12, i32 noundef 0, i32 noundef 10)
  br i1 %call.i, label %if.then.i, label %parts64_round_to_int.exit

if.then.i:                                        ; preds = %sw.bb2.i
  %13 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %13, 16
  store i16 %or1.i.i, ptr %s, align 2
  br label %parts64_round_to_int.exit

parts64_round_to_int.exit:                        ; preds = %if.then47.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i, %if.else.i.i, %sw.bb1.i.i, %if.then4.i.i, %sw.bb2.i, %if.then.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float16_params)
  %14 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i.i = zext i8 %14 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %15 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %16 = shl i32 %15, 10
  %17 = and i32 %16, 31744
  %and8.i.i.i.i = zext nneg i32 %17 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %18 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i.i = and i64 %18, 1023
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_round_to_int(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %and.i9.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %float32_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_round_to_int.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float32_unpack_canonical.exit.thread9, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_round_to_int.exit

float32_unpack_canonical.exit.thread9:            ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb2.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %float32_unpack_canonical.exit

float32_unpack_canonical.exit.thread:             ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb2.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_round_to_int.exit

float32_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %float32_unpack_canonical.exit
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i4 = or i16 %5, 8193
  store i16 %or1.i.i.i4, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i6, label %if.then.i.i5

if.then.i.i5:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_round_to_int.exit

if.else.i.i6:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_round_to_int.exit

sw.bb1.i.i:                                       ; preds = %float32_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode2.i.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i, label %parts64_round_to_int.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_round_to_int.exit

sw.bb2.i:                                         ; preds = %float32_unpack_canonical.exit.thread, %float32_unpack_canonical.exit.thread9
  %.in = getelementptr inbounds i8, ptr %s, i64 2
  %10 = load i8, ptr %.in, align 2
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %10, i32 noundef 0, i32 noundef 23)
  br i1 %call.i, label %if.then.i, label %parts64_round_to_int.exit

if.then.i:                                        ; preds = %sw.bb2.i
  %11 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %11, 16
  store i16 %or1.i.i, ptr %s, align 2
  br label %parts64_round_to_int.exit

parts64_round_to_int.exit:                        ; preds = %if.then47.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i5, %if.else.i.i6, %sw.bb1.i.i, %if.then4.i.i, %sw.bb2.i, %if.then.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float32_params)
  %12 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i = zext i8 %12 to i64
  %shl.i.i.i7 = shl nuw nsw i64 %conv.i.i.i, 31
  %13 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %14 = shl i32 %13, 23
  %15 = and i32 %14, 2139095040
  %and8.i.i.i = zext nneg i32 %15 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i7, %and8.i.i.i
  %16 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %16, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  ret i32 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_round_to_int(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %float64_unpack_canonical.exit.thread [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_round_to_int.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float64_unpack_canonical.exit.thread10, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_round_to_int.exit

float64_unpack_canonical.exit.thread10:           ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb2.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %float64_unpack_canonical.exit

float64_unpack_canonical.exit.thread:             ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb2.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_round_to_int.exit

float64_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %float64_unpack_canonical.exit
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i4 = or i16 %5, 8193
  store i16 %or1.i.i.i4, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i6, label %if.then.i.i5

if.then.i.i5:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_round_to_int.exit

if.else.i.i6:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_round_to_int.exit

sw.bb1.i.i:                                       ; preds = %float64_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode2.i.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i, label %parts64_round_to_int.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_round_to_int.exit

sw.bb2.i:                                         ; preds = %float64_unpack_canonical.exit.thread, %float64_unpack_canonical.exit.thread10
  %.in = getelementptr inbounds i8, ptr %s, i64 2
  %10 = load i8, ptr %.in, align 2
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %10, i32 noundef 0, i32 noundef 52)
  br i1 %call.i, label %if.then.i, label %parts64_round_to_int.exit

if.then.i:                                        ; preds = %sw.bb2.i
  %11 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %11, 16
  store i16 %or1.i.i, ptr %s, align 2
  br label %parts64_round_to_int.exit

parts64_round_to_int.exit:                        ; preds = %if.then47.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i5, %if.else.i.i6, %sw.bb1.i.i, %if.then4.i.i, %sw.bb2.i, %if.then.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float64_params)
  %12 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %13 = and i8 %12, 1
  %conv.i.i.i7 = zext nneg i8 %13 to i64
  %shl.i.i.i8 = shl nuw i64 %conv.i.i.i7, 63
  %14 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %15 = and i32 %14, 2047
  %shl77.i.i.i = zext nneg i32 %15 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i.i8
  %16 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %16, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  ret i64 %or.i10.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_round_to_int(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %bfloat16_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_round_to_int.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %bfloat16_unpack_canonical.exit.thread10, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_round_to_int.exit

bfloat16_unpack_canonical.exit.thread10:          ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb2.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %bfloat16_unpack_canonical.exit

bfloat16_unpack_canonical.exit.thread:            ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb2.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_round_to_int.exit

bfloat16_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 64
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %bfloat16_unpack_canonical.exit
  %7 = load i16, ptr %s, align 2
  %or1.i.i.i4 = or i16 %7, 8193
  store i16 %or1.i.i.i4, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %8 = load i8, ptr %default_nan_mode.i.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i.i, label %if.else.i.i6, label %if.then.i.i5

if.then.i.i5:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_round_to_int.exit

if.else.i.i6:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_round_to_int.exit

sw.bb1.i.i:                                       ; preds = %bfloat16_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %parts64_round_to_int.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_round_to_int.exit

sw.bb2.i:                                         ; preds = %bfloat16_unpack_canonical.exit.thread, %bfloat16_unpack_canonical.exit.thread10
  %.in = getelementptr inbounds i8, ptr %s, i64 2
  %12 = load i8, ptr %.in, align 2
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %12, i32 noundef 0, i32 noundef 7)
  br i1 %call.i, label %if.then.i, label %parts64_round_to_int.exit

if.then.i:                                        ; preds = %sw.bb2.i
  %13 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %13, 16
  store i16 %or1.i.i, ptr %s, align 2
  br label %parts64_round_to_int.exit

parts64_round_to_int.exit:                        ; preds = %if.then47.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i5, %if.else.i.i6, %sw.bb1.i.i, %if.then4.i.i, %sw.bb2.i, %if.then.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @bfloat16_params)
  %14 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i7 = zext i8 %14 to i64
  %shl.i.i.i8 = shl nuw nsw i64 %conv.i.i.i7, 15
  %15 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %16 = shl i32 %15, 7
  %17 = and i32 %16, 32640
  %and8.i.i.i = zext nneg i32 %17 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i8, %and8.i.i.i
  %18 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %18, 127
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i16
  ret i16 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_round_to_int(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float128_params)
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %1 = load i8, ptr %float_rounding_mode, align 2
  call fastcc void @parts128_round_to_int(ptr noundef nonnull %p, i8 noundef zeroext %1, ptr noundef %s, ptr noundef nonnull @float128_params)
  %call = call fastcc { i64, i64 } @float128_round_pack_canonical(ptr noundef nonnull %p, ptr noundef %s)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @parts128_round_to_int(ptr nocapture noundef %a, i8 noundef zeroext %rmode, ptr nocapture noundef %s, ptr nocapture noundef readonly %fmt) unnamed_addr #3 {
entry:
  %0 = load i8, ptr %a, align 8
  switch i8 %0, label %do.body [
    i8 2, label %sw.bb2
    i8 3, label %sw.epilog
    i8 1, label %sw.epilog
    i8 5, label %sw.bb.i
    i8 4, label %sw.bb1.i
  ]

sw.bb.i:                                          ; preds = %entry
  %1 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %1, 8193
  store i16 %or1.i.i, ptr %s, align 2
  %default_nan_mode.i = getelementptr inbounds i8, ptr %s, i64 7
  %2 = load i8, ptr %default_nan_mode.i, align 1
  %3 = and i8 %2, 1
  %tobool.not.i = icmp eq i8 %3, 0
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %sw.bb.i
  store i8 4, ptr %a, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %sw.epilog

if.else.i:                                        ; preds = %sw.bb.i
  %frac_hi.i.i = getelementptr inbounds i8, ptr %a, i64 8
  %4 = load i64, ptr %frac_hi.i.i, align 8
  %or4.i.i.i = or i64 %4, 4611686018427387904
  store i64 %or4.i.i.i, ptr %frac_hi.i.i, align 8
  store i8 4, ptr %a, align 8
  br label %sw.epilog

sw.bb1.i:                                         ; preds = %entry
  %default_nan_mode2.i = getelementptr inbounds i8, ptr %s, i64 7
  %5 = load i8, ptr %default_nan_mode2.i, align 1
  %6 = and i8 %5, 1
  %tobool3.not.i = icmp eq i8 %6, 0
  br i1 %tobool3.not.i, label %sw.epilog, label %if.then4.i

if.then4.i:                                       ; preds = %sw.bb1.i
  store i8 4, ptr %a, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i9.i = getelementptr inbounds i8, ptr %a, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i9.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i10.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i10.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i11.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i11.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i12.i = getelementptr inbounds i8, ptr %a, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i12.i, align 8
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %frac_size = getelementptr inbounds i8, ptr %fmt, i64 16
  %7 = load i32, ptr %frac_size, align 8
  %call = tail call fastcc zeroext i1 @parts128_round_to_int_normal(ptr noundef nonnull %a, i8 noundef zeroext %rmode, i32 noundef %7)
  br i1 %call, label %if.then, label %sw.epilog

if.then:                                          ; preds = %sw.bb2
  %8 = load i16, ptr %s, align 2
  %or1.i = or i16 %8, 16
  store i16 %or1.i, ptr %s, align 2
  br label %sw.epilog

do.body:                                          ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1047, ptr noundef nonnull @__func__.parts128_round_to_int, ptr noundef null) #16
  unreachable

sw.epilog:                                        ; preds = %entry, %entry, %if.then4.i, %sw.bb1.i, %if.else.i, %if.then.i, %sw.bb2, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @floatx80_round_to_int(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %floatx80_rounding_precision.i = getelementptr inbounds i8, ptr %status, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i = icmp ult i8 %0, 3
  br i1 %switch.i, label %sw.epilog.i, label %do.body.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %entry
  %cmp.i.i = icmp slt i64 %a.coerce0, 0
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i.i = icmp eq i16 %1, 0
  %.not.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  br i1 %.not.i, label %if.end.i, label %if.then

if.end.i:                                         ; preds = %sw.epilog.i
  %f.coerce1.lobit.i.i = lshr i16 %a.coerce1, 15
  %frombool.i.i = trunc i16 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %and.i.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.not.i = icmp eq i16 %1, 32767
  br i1 %cmp.not.i, label %if.else.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef nonnull %status, ptr noundef nonnull @floatx80_params)
  %.pre = load i8, ptr %floatx80_rounding_precision.i, align 1
  br label %if.end

if.else.i:                                        ; preds = %if.end.i
  %and.i = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %2 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i.i = icmp eq i64 %2, 0
  %3 = select i1 %tobool.not.i.i, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %3
  store i8 %cond17.i, ptr %p, align 8
  br label %if.end

if.then:                                          ; preds = %sw.epilog.i
  %4 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %4, 1
  store i16 %or1.i.i, ptr %status, align 2
  br label %return

if.end:                                           ; preds = %if.then10.i, %if.else.i
  %5 = phi i8 [ %.pre, %if.then10.i ], [ %0, %if.else.i ]
  %float_rounding_mode = getelementptr inbounds i8, ptr %status, i64 2
  %6 = load i8, ptr %float_rounding_mode, align 2
  %idxprom = zext i8 %5 to i64
  %arrayidx = getelementptr [3 x %struct.FloatFmt], ptr @floatx80_params, i64 0, i64 %idxprom
  call fastcc void @parts128_round_to_int(ptr noundef nonnull %p, i8 noundef zeroext %6, ptr noundef nonnull %status, ptr noundef %arrayidx)
  %call2 = call fastcc { i64, i16 } @floatx80_round_pack_canonical(ptr noundef nonnull %p, ptr noundef nonnull %status)
  %7 = extractvalue { i64, i16 } %call2, 0
  %8 = extractvalue { i64, i16 } %call2, 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.sroa.0.0 = phi i64 [ %7, %if.end ], [ -4611686018427387904, %if.then ]
  %retval.sroa.3.0 = phi i16 [ %8, %if.end ], [ -1, %if.then ]
  %.fca.0.insert = insertvalue { i64, i16 } poison, i64 %retval.sroa.0.0, 0
  %.fca.1.insert = insertvalue { i64, i16 } %.fca.0.insert, i16 %retval.sroa.3.0, 1
  ret { i64, i16 } %.fca.1.insert
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i8 @float16_to_int8_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i16 %1, label %float16a_unpack_canonical.exit.thread [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %float16a_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

float16a_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit.thread:            ; preds = %entry
  %conv.i.i.i = zext nneg i16 %1 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float16a_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 127, i64 -128
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float16a_unpack_canonical.exit.thread, %float16a_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %7 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %7, 64
  %8 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %7
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %8, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %9 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %10 = and i8 %9, 1
  %tobool12.not.i = icmp eq i8 %10, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, 128
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -128, i64 %sub18.i
  br label %sw.epilog.i

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp ugt i64 %r.0.i, 127
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 127)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float16a_unpack_canonical.exit, %if.else21.i, %if.then13.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %float16a_unpack_canonical.exit ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 127, %float16a_unpack_canonical.exit ]
  %11 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %11, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %12 = trunc i64 %r.1.i to i8
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i8 [ %12, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i8 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i16 @float16_to_int16_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i16 %1, label %float16a_unpack_canonical.exit.thread [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %float16a_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

float16a_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit.thread:            ; preds = %entry
  %conv.i.i.i = zext nneg i16 %1 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float16a_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 32767, i64 -32768
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float16a_unpack_canonical.exit.thread, %float16a_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %7 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %7, 64
  %8 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %7
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %8, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %9 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %10 = and i8 %9, 1
  %tobool12.not.i = icmp eq i8 %10, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, 32768
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -32768, i64 %sub18.i
  br label %sw.epilog.i

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp ugt i64 %r.0.i, 32767
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 32767)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float16a_unpack_canonical.exit, %if.else21.i, %if.then13.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %float16a_unpack_canonical.exit ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 32767, %float16a_unpack_canonical.exit ]
  %11 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %11, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %12 = trunc i64 %r.1.i to i16
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i16 [ %12, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i16 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float16_to_int32_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i16 %1, label %float16a_unpack_canonical.exit.thread [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %float16a_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

float16a_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit.thread:            ; preds = %entry
  %conv.i.i.i = zext nneg i16 %1 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float16a_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 2147483647, i64 -2147483648
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float16a_unpack_canonical.exit.thread, %float16a_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %7 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %7, 64
  %8 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %7
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %8, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %9 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %10 = and i8 %9, 1
  %tobool12.not.i = icmp eq i8 %10, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, 2147483648
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -2147483648, i64 %sub18.i
  br label %sw.epilog.i

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp ugt i64 %r.0.i, 2147483647
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 2147483647)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float16a_unpack_canonical.exit, %if.else21.i, %if.then13.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %float16a_unpack_canonical.exit ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 2147483647, %float16a_unpack_canonical.exit ]
  %11 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %11, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %12 = trunc i64 %r.1.i to i32
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i32 [ %12, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float16_to_int64_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i16 %1, label %float16a_unpack_canonical.exit.thread [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %float16a_unpack_canonical.exit.thread3, label %parts64_float_to_sint.exit.sink.split

float16a_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %5 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %5 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %5
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit.thread:            ; preds = %entry
  %conv.i.i.i = zext nneg i16 %1 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float16a_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %parts64_float_to_sint.exit.sink.split

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 9223372036854775807, i64 -9223372036854775808
  br label %parts64_float_to_sint.exit.sink.split

sw.bb6.i:                                         ; preds = %float16a_unpack_canonical.exit.thread, %float16a_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %6 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %6, 64
  %7 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %6
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %7, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %8 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %9 = and i8 %8, 1
  %tobool12.not.i = icmp eq i8 %9, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, -9223372036854775808
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -9223372036854775808, i64 %sub18.i
  br label %parts64_float_to_sint.exit.sink.split

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp slt i64 %r.0.i, 0
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 9223372036854775807)
  br label %parts64_float_to_sint.exit.sink.split

parts64_float_to_sint.exit.sink.split:            ; preds = %sw.bb3.i, %if.then13.i, %if.else21.i, %float16a_unpack_canonical.exit, %if.else.i.i
  %.sink4 = phi i16 [ 32, %if.else.i.i ], [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %float16a_unpack_canonical.exit ]
  %retval.0.i.ph = phi i64 [ 0, %if.else.i.i ], [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 9223372036854775807, %float16a_unpack_canonical.exit ]
  %10 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %10, %.sink4
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %parts64_float_to_sint.exit.sink.split, %if.then.i.i
  %retval.0.i = phi i64 [ 0, %if.then.i.i ], [ %retval.0.i.ph, %parts64_float_to_sint.exit.sink.split ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i16 @float32_to_int16_scalbn(i32 noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %float32_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float32_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

float32_unpack_canonical.exit.thread3:            ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float32_unpack_canonical.exit

float32_unpack_canonical.exit.thread:             ; preds = %entry
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float32_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i32 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 32767, i64 -32768
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float32_unpack_canonical.exit.thread, %float32_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %5 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %5, 64
  %6 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %5
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %6, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %7 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %8 = and i8 %7, 1
  %tobool12.not.i = icmp eq i8 %8, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, 32768
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -32768, i64 %sub18.i
  br label %sw.epilog.i

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp ugt i64 %r.0.i, 32767
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 32767)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float32_unpack_canonical.exit, %if.else21.i, %if.then13.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %float32_unpack_canonical.exit ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 32767, %float32_unpack_canonical.exit ]
  %9 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %9, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %10 = trunc i64 %r.1.i to i16
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i16 [ %10, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i16 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_to_int32_scalbn(i32 noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %float32_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float32_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

float32_unpack_canonical.exit.thread3:            ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float32_unpack_canonical.exit

float32_unpack_canonical.exit.thread:             ; preds = %entry
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float32_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i32 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 2147483647, i64 -2147483648
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float32_unpack_canonical.exit.thread, %float32_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %5 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %5, 64
  %6 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %5
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %6, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %7 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %8 = and i8 %7, 1
  %tobool12.not.i = icmp eq i8 %8, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, 2147483648
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -2147483648, i64 %sub18.i
  br label %sw.epilog.i

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp ugt i64 %r.0.i, 2147483647
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 2147483647)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float32_unpack_canonical.exit, %if.else21.i, %if.then13.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %float32_unpack_canonical.exit ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 2147483647, %float32_unpack_canonical.exit ]
  %9 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %9, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %10 = trunc i64 %r.1.i to i32
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i32 [ %10, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float32_to_int64_scalbn(i32 noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %float32_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float32_unpack_canonical.exit.thread3, label %parts64_float_to_sint.exit.sink.split

float32_unpack_canonical.exit.thread3:            ; preds = %if.else.i.i
  %3 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %3 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %3
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float32_unpack_canonical.exit

float32_unpack_canonical.exit.thread:             ; preds = %entry
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float32_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %parts64_float_to_sint.exit.sink.split

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i32 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 9223372036854775807, i64 -9223372036854775808
  br label %parts64_float_to_sint.exit.sink.split

sw.bb6.i:                                         ; preds = %float32_unpack_canonical.exit.thread, %float32_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %4 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %4, 64
  %5 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %4
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %5, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %6 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %7 = and i8 %6, 1
  %tobool12.not.i = icmp eq i8 %7, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, -9223372036854775808
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -9223372036854775808, i64 %sub18.i
  br label %parts64_float_to_sint.exit.sink.split

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp slt i64 %r.0.i, 0
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 9223372036854775807)
  br label %parts64_float_to_sint.exit.sink.split

parts64_float_to_sint.exit.sink.split:            ; preds = %sw.bb3.i, %if.then13.i, %if.else21.i, %float32_unpack_canonical.exit, %if.else.i.i
  %.sink4 = phi i16 [ 32, %if.else.i.i ], [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %float32_unpack_canonical.exit ]
  %retval.0.i.ph = phi i64 [ 0, %if.else.i.i ], [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 9223372036854775807, %float32_unpack_canonical.exit ]
  %8 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %8, %.sink4
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %parts64_float_to_sint.exit.sink.split, %if.then.i.i
  %retval.0.i = phi i64 [ 0, %if.then.i.i ], [ %retval.0.i.ph, %parts64_float_to_sint.exit.sink.split ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i16 @float64_to_int16_scalbn(i64 noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i32 %conv.i.i.i, label %float64_unpack_canonical.exit.thread [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float64_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

float64_unpack_canonical.exit.thread3:            ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float64_unpack_canonical.exit

float64_unpack_canonical.exit.thread:             ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float64_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i64 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 32767, i64 -32768
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float64_unpack_canonical.exit.thread, %float64_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %5 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %5, 64
  %6 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %5
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %6, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %7 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %8 = and i8 %7, 1
  %tobool12.not.i = icmp eq i8 %8, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, 32768
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -32768, i64 %sub18.i
  br label %sw.epilog.i

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp ugt i64 %r.0.i, 32767
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 32767)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float64_unpack_canonical.exit, %if.else21.i, %if.then13.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %float64_unpack_canonical.exit ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 32767, %float64_unpack_canonical.exit ]
  %9 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %9, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %10 = trunc i64 %r.1.i to i16
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i16 [ %10, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i16 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float64_to_int32_scalbn(i64 noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i32 %conv.i.i.i, label %float64_unpack_canonical.exit.thread [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float64_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

float64_unpack_canonical.exit.thread3:            ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float64_unpack_canonical.exit

float64_unpack_canonical.exit.thread:             ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float64_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i64 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 2147483647, i64 -2147483648
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float64_unpack_canonical.exit.thread, %float64_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %5 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %5, 64
  %6 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %5
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %6, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %7 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %8 = and i8 %7, 1
  %tobool12.not.i = icmp eq i8 %8, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, 2147483648
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -2147483648, i64 %sub18.i
  br label %sw.epilog.i

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp ugt i64 %r.0.i, 2147483647
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 2147483647)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float64_unpack_canonical.exit, %if.else21.i, %if.then13.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %float64_unpack_canonical.exit ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 2147483647, %float64_unpack_canonical.exit ]
  %9 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %9, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %10 = trunc i64 %r.1.i to i32
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i32 [ %10, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_to_int64_scalbn(i64 noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i32 %conv.i.i.i, label %float64_unpack_canonical.exit.thread [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float64_unpack_canonical.exit.thread3, label %parts64_float_to_sint.exit.sink.split

float64_unpack_canonical.exit.thread3:            ; preds = %if.else.i.i
  %3 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %3 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %3
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float64_unpack_canonical.exit

float64_unpack_canonical.exit.thread:             ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float64_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %parts64_float_to_sint.exit.sink.split

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i64 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 9223372036854775807, i64 -9223372036854775808
  br label %parts64_float_to_sint.exit.sink.split

sw.bb6.i:                                         ; preds = %float64_unpack_canonical.exit.thread, %float64_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %4 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %4, 64
  %5 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %4
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %5, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %6 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %7 = and i8 %6, 1
  %tobool12.not.i = icmp eq i8 %7, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, -9223372036854775808
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -9223372036854775808, i64 %sub18.i
  br label %parts64_float_to_sint.exit.sink.split

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp slt i64 %r.0.i, 0
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 9223372036854775807)
  br label %parts64_float_to_sint.exit.sink.split

parts64_float_to_sint.exit.sink.split:            ; preds = %sw.bb3.i, %if.then13.i, %if.else21.i, %float64_unpack_canonical.exit, %if.else.i.i
  %.sink4 = phi i16 [ 32, %if.else.i.i ], [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %float64_unpack_canonical.exit ]
  %retval.0.i.ph = phi i64 [ 0, %if.else.i.i ], [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 9223372036854775807, %float64_unpack_canonical.exit ]
  %8 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %8, %.sink4
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %parts64_float_to_sint.exit.sink.split, %if.then.i.i
  %retval.0.i = phi i64 [ 0, %if.then.i.i ], [ %retval.0.i.ph, %parts64_float_to_sint.exit.sink.split ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i8 @bfloat16_to_int8_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %1 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %bfloat16_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %2 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %3 = and i8 %2, 1
  %tobool9.not.i.i = icmp eq i8 %3, 0
  br i1 %tobool9.not.i.i, label %bfloat16_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %4 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %4, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

bfloat16_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %5 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %5 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %5
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %bfloat16_unpack_canonical.exit

bfloat16_unpack_canonical.exit.thread:            ; preds = %entry
  %6 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %6 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

bfloat16_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %1, 64
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 127, i64 -128
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %bfloat16_unpack_canonical.exit.thread, %bfloat16_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %7 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %7, 64
  %8 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %7
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %8, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %9 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %10 = and i8 %9, 1
  %tobool12.not.i = icmp eq i8 %10, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, 128
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -128, i64 %sub18.i
  br label %sw.epilog.i

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp ugt i64 %r.0.i, 127
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 127)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %bfloat16_unpack_canonical.exit, %if.else21.i, %if.then13.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %bfloat16_unpack_canonical.exit ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 127, %bfloat16_unpack_canonical.exit ]
  %11 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %11, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %12 = trunc i64 %r.1.i to i8
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i8 [ %12, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i8 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i16 @bfloat16_to_int16_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %1 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %bfloat16_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %2 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %3 = and i8 %2, 1
  %tobool9.not.i.i = icmp eq i8 %3, 0
  br i1 %tobool9.not.i.i, label %bfloat16_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %4 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %4, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

bfloat16_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %5 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %5 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %5
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %bfloat16_unpack_canonical.exit

bfloat16_unpack_canonical.exit.thread:            ; preds = %entry
  %6 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %6 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

bfloat16_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %1, 64
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 32767, i64 -32768
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %bfloat16_unpack_canonical.exit.thread, %bfloat16_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %7 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %7, 64
  %8 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %7
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %8, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %9 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %10 = and i8 %9, 1
  %tobool12.not.i = icmp eq i8 %10, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, 32768
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -32768, i64 %sub18.i
  br label %sw.epilog.i

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp ugt i64 %r.0.i, 32767
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 32767)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %bfloat16_unpack_canonical.exit, %if.else21.i, %if.then13.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %bfloat16_unpack_canonical.exit ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 32767, %bfloat16_unpack_canonical.exit ]
  %11 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %11, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %12 = trunc i64 %r.1.i to i16
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i16 [ %12, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i16 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bfloat16_to_int32_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %1 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %bfloat16_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %2 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %3 = and i8 %2, 1
  %tobool9.not.i.i = icmp eq i8 %3, 0
  br i1 %tobool9.not.i.i, label %bfloat16_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %4 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %4, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

bfloat16_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %5 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %5 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %5
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %bfloat16_unpack_canonical.exit

bfloat16_unpack_canonical.exit.thread:            ; preds = %entry
  %6 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %6 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

bfloat16_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %1, 64
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 2147483647, i64 -2147483648
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %bfloat16_unpack_canonical.exit.thread, %bfloat16_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %7 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %7, 64
  %8 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %7
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %8, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %9 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %10 = and i8 %9, 1
  %tobool12.not.i = icmp eq i8 %10, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, 2147483648
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -2147483648, i64 %sub18.i
  br label %sw.epilog.i

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp ugt i64 %r.0.i, 2147483647
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 2147483647)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %bfloat16_unpack_canonical.exit, %if.else21.i, %if.then13.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %bfloat16_unpack_canonical.exit ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 2147483647, %bfloat16_unpack_canonical.exit ]
  %11 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %11, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %12 = trunc i64 %r.1.i to i32
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i32 [ %12, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bfloat16_to_int64_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %1 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %bfloat16_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_sint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %2 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %3 = and i8 %2, 1
  %tobool9.not.i.i = icmp eq i8 %3, 0
  br i1 %tobool9.not.i.i, label %bfloat16_unpack_canonical.exit.thread3, label %parts64_float_to_sint.exit.sink.split

bfloat16_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %bfloat16_unpack_canonical.exit

bfloat16_unpack_canonical.exit.thread:            ; preds = %entry
  %5 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %5 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

bfloat16_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %1, 64
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %parts64_float_to_sint.exit.sink.split

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 9223372036854775807, i64 -9223372036854775808
  br label %parts64_float_to_sint.exit.sink.split

sw.bb6.i:                                         ; preds = %bfloat16_unpack_canonical.exit.thread, %bfloat16_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %6 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %6, 64
  %7 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %6
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %7, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %8 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %9 = and i8 %8, 1
  %tobool12.not.i = icmp eq i8 %9, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, -9223372036854775808
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -9223372036854775808, i64 %sub18.i
  br label %parts64_float_to_sint.exit.sink.split

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp slt i64 %r.0.i, 0
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 9223372036854775807)
  br label %parts64_float_to_sint.exit.sink.split

parts64_float_to_sint.exit.sink.split:            ; preds = %sw.bb3.i, %if.then13.i, %if.else21.i, %bfloat16_unpack_canonical.exit, %if.else.i.i
  %.sink4 = phi i16 [ 32, %if.else.i.i ], [ 4097, %sw.bb3.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ %spec.select, %bfloat16_unpack_canonical.exit ]
  %retval.0.i.ph = phi i64 [ 0, %if.else.i.i ], [ %cond.i, %sw.bb3.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 9223372036854775807, %bfloat16_unpack_canonical.exit ]
  %10 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %10, %.sink4
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_sint.exit

parts64_float_to_sint.exit:                       ; preds = %parts64_float_to_sint.exit.sink.split, %if.then.i.i
  %retval.0.i = phi i64 [ 0, %if.then.i.i ], [ %retval.0.i.ph, %parts64_float_to_sint.exit.sink.split ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i8 @float16_to_int8(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call signext i8 @float16_to_int8_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i8 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i16 @float16_to_int16(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call signext i16 @float16_to_int16_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float16_to_int32(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i32 @float16_to_int32_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float16_to_int64(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i64 @float16_to_int64_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i16 @float32_to_int16(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call signext i16 @float32_to_int16_scalbn(i32 noundef %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_to_int32(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i32 @float32_to_int32_scalbn(i32 noundef %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float32_to_int64(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i64 @float32_to_int64_scalbn(i32 noundef %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i16 @float64_to_int16(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call signext i16 @float64_to_int16_scalbn(i64 noundef %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float64_to_int32(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i32 @float64_to_int32_scalbn(i64 noundef %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_to_int64(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i64 @float64_to_int64_scalbn(i64 noundef %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float128_to_int32(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call fastcc i32 @float128_to_int32_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @float128_to_int32_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %rmode, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float128_params)
  %1 = load i8, ptr %p, align 8
  switch i8 %1, label %do.body.i [
    i8 5, label %sw.bb.i
    i8 4, label %sw.epilog.i
    i8 3, label %sw.bb3.i
    i8 1, label %parts128_float_to_sint.exit
    i8 2, label %sw.bb6.i
  ]

sw.bb.i:                                          ; preds = %entry
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %entry
  %2 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %3 = and i8 %2, 1
  %tobool.not.i = icmp eq i8 %3, 0
  %cond.i = select i1 %tobool.not.i, i64 2147483647, i64 -2147483648
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %entry
  %call.i = call fastcc zeroext i1 @parts128_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef 126)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %4 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %4, 64
  %5 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %4
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %5, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %6 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %7 = and i8 %6, 1
  %tobool12.not.i = icmp eq i8 %7, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, 2147483648
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -2147483648, i64 %sub18.i
  br label %sw.epilog.i

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp ugt i64 %r.0.i, 2147483647
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 2147483647)
  br label %sw.epilog.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1110, ptr noundef nonnull @__func__.parts128_float_to_sint, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %if.else21.i, %if.then13.i, %sw.bb3.i, %sw.bb.i, %entry
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 1, %entry ], [ 8193, %sw.bb.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 2147483647, %entry ], [ 2147483647, %sw.bb.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ]
  %8 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %8, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %9 = trunc i64 %r.1.i to i32
  br label %parts128_float_to_sint.exit

parts128_float_to_sint.exit:                      ; preds = %entry, %sw.epilog.i
  %retval.0.i = phi i32 [ %9, %sw.epilog.i ], [ 0, %entry ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float128_to_int64(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call fastcc i64 @float128_to_int64_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i64 @float128_to_int64_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %rmode, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float128_params)
  %1 = load i8, ptr %p, align 8
  switch i8 %1, label %do.body.i [
    i8 5, label %sw.bb.i
    i8 4, label %sw.epilog.i
    i8 3, label %sw.bb3.i
    i8 1, label %parts128_float_to_sint.exit
    i8 2, label %sw.bb6.i
  ]

sw.bb.i:                                          ; preds = %entry
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %entry
  %2 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %3 = and i8 %2, 1
  %tobool.not.i = icmp eq i8 %3, 0
  %cond.i = select i1 %tobool.not.i, i64 9223372036854775807, i64 -9223372036854775808
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %entry
  %call.i = call fastcc zeroext i1 @parts128_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef 126)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %4 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %cmp.i = icmp slt i32 %4, 64
  %5 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %4
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %5, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %6 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %7 = and i8 %6, 1
  %tobool12.not.i = icmp eq i8 %7, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, -9223372036854775808
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -9223372036854775808, i64 %sub18.i
  br label %sw.epilog.i

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp slt i64 %r.0.i, 0
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 9223372036854775807)
  br label %sw.epilog.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1110, ptr noundef nonnull @__func__.parts128_float_to_sint, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %if.else21.i, %if.then13.i, %sw.bb3.i, %sw.bb.i, %entry
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 1, %entry ], [ 8193, %sw.bb.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 9223372036854775807, %entry ], [ 9223372036854775807, %sw.bb.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ]
  %8 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %8, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  br label %parts128_float_to_sint.exit

parts128_float_to_sint.exit:                      ; preds = %entry, %sw.epilog.i
  %retval.0.i = phi i64 [ %r.1.i, %sw.epilog.i ], [ 0, %entry ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_to_int128(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call fastcc { i64, i64 } @float128_to_int128_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %0, ptr noundef %s)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc { i64, i64 } @float128_to_int128_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %rmode, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float128_params)
  %1 = load i8, ptr %p, align 8
  switch i8 %1, label %do.body [
    i8 5, label %sw.bb
    i8 4, label %sw.epilog
    i8 3, label %sw.bb3
    i8 1, label %return
    i8 2, label %sw.bb12
  ]

sw.bb:                                            ; preds = %entry
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %2 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %3 = and i8 %2, 1
  %tobool.not = icmp eq i8 %3, 0
  %spec.select45 = select i1 %tobool.not, { i64, i64 } { i64 -1, i64 9223372036854775807 }, { i64, i64 } { i64 0, i64 -9223372036854775808 }
  %cond.off64 = extractvalue { i64, i64 } %spec.select45, 1
  %cond.off0 = extractvalue { i64, i64 } %spec.select45, 0
  br label %sw.epilog

sw.bb12:                                          ; preds = %entry
  %call13 = call fastcc zeroext i1 @parts128_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef 126)
  %spec.select = select i1 %call13, i16 16, i16 0
  %4 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %cmp = icmp slt i32 %4, 127
  br i1 %cmp, label %if.then15, label %if.else

if.then15:                                        ; preds = %sw.bb12
  %sub = sub i32 127, %4
  %5 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %6 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %a.sroa.2.0.insert.ext.i = zext i64 %6 to i128
  %a.sroa.2.0.insert.shift.i = shl nuw i128 %a.sroa.2.0.insert.ext.i, 64
  %a.sroa.0.0.insert.ext.i = zext i64 %5 to i128
  %a.sroa.0.0.insert.insert.i = or disjoint i128 %a.sroa.2.0.insert.shift.i, %a.sroa.0.0.insert.ext.i
  %sh_prom.i = zext nneg i32 %sub to i128
  %shr.i = lshr i128 %a.sroa.0.0.insert.insert.i, %sh_prom.i
  %retval.sroa.0.0.extract.trunc.i = trunc i128 %shr.i to i64
  %retval.sroa.2.0.extract.shift.i = lshr i128 %shr.i, 64
  %retval.sroa.2.0.extract.trunc.i = trunc i128 %retval.sroa.2.0.extract.shift.i to i64
  %7 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %8 = and i8 %7, 1
  %tobool23.not = icmp eq i8 %8, 0
  br i1 %tobool23.not, label %sw.epilog, label %if.then24

if.then24:                                        ; preds = %if.then15
  %a.coerce1.neg.i = sub nsw i64 0, %retval.sroa.2.0.extract.trunc.i
  %a.coerce1.neg.z.i = zext i64 %a.coerce1.neg.i to i128
  %a.sroa.2.0.insert.shift.neg.i = shl nuw i128 %a.coerce1.neg.z.i, 64
  %a.sroa.0.0.insert.ext.i39 = and i128 %shr.i, 18446744073709551615
  %a.sroa.0.0.insert.insert.neg.i = sub i128 %a.sroa.2.0.insert.shift.neg.i, %a.sroa.0.0.insert.ext.i39
  %retval.sroa.0.0.extract.trunc.i40 = trunc i128 %a.sroa.0.0.insert.insert.neg.i to i64
  %retval.sroa.2.0.extract.shift.i41 = lshr i128 %a.sroa.0.0.insert.insert.neg.i, 64
  %retval.sroa.2.0.extract.trunc.i42 = trunc i128 %retval.sroa.2.0.extract.shift.i41 to i64
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb12
  %cmp30 = icmp eq i32 %4, 127
  %.pre = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %9 = and i8 %.pre, 1
  br i1 %cmp30, label %land.lhs.true, label %if.else46

land.lhs.true:                                    ; preds = %if.else
  %tobool33 = icmp ne i8 %9, 0
  %10 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp37 = icmp eq i64 %10, 0
  %or.cond = select i1 %tobool33, i1 %cmp37, i1 false
  %11 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %cmp41 = icmp eq i64 %11, -9223372036854775808
  %or.cond1 = select i1 %or.cond, i1 %cmp41, i1 false
  br i1 %or.cond1, label %sw.epilog, label %if.else46

if.else46:                                        ; preds = %if.else, %land.lhs.true
  %tobool48.not = icmp eq i8 %9, 0
  %spec.select46 = select i1 %tobool48.not, { i64, i64 } { i64 -1, i64 9223372036854775807 }, { i64, i64 } { i64 0, i64 -9223372036854775808 }
  %cond57.off64 = extractvalue { i64, i64 } %spec.select46, 1
  %cond57.off0 = extractvalue { i64, i64 } %spec.select46, 0
  br label %sw.epilog

do.body:                                          ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 3237, ptr noundef nonnull @__func__.float128_to_int128_scalbn, ptr noundef null) #16
  unreachable

sw.epilog:                                        ; preds = %land.lhs.true, %entry, %sw.bb, %if.then24, %if.then15, %if.else46, %sw.bb3
  %r.0.off0 = phi i64 [ %retval.sroa.0.0.extract.trunc.i40, %if.then24 ], [ %retval.sroa.0.0.extract.trunc.i, %if.then15 ], [ %cond57.off0, %if.else46 ], [ %cond.off0, %sw.bb3 ], [ -1, %sw.bb ], [ -1, %entry ], [ 0, %land.lhs.true ]
  %r.0.off64 = phi i64 [ %retval.sroa.2.0.extract.trunc.i42, %if.then24 ], [ %retval.sroa.2.0.extract.trunc.i, %if.then15 ], [ %cond57.off64, %if.else46 ], [ %cond.off64, %sw.bb3 ], [ -1, %sw.bb ], [ -1, %entry ], [ -9223372036854775808, %land.lhs.true ]
  %flags.2 = phi i16 [ %spec.select, %if.then24 ], [ %spec.select, %if.then15 ], [ 4097, %if.else46 ], [ 4097, %sw.bb3 ], [ 8193, %sw.bb ], [ 1, %entry ], [ %spec.select, %land.lhs.true ]
  %12 = load i16, ptr %s, align 2
  %or1.i = or i16 %12, %flags.2
  store i16 %or1.i, ptr %s, align 2
  br label %return

return:                                           ; preds = %entry, %sw.epilog
  %retval.sroa.0.0 = phi i64 [ %r.0.off0, %sw.epilog ], [ 0, %entry ]
  %retval.sroa.3.0 = phi i64 [ %r.0.off64, %sw.epilog ], [ 0, %entry ]
  %.fca.0.insert = insertvalue { i64, i64 } poison, i64 %retval.sroa.0.0, 0
  %.fca.1.insert = insertvalue { i64, i64 } %.fca.0.insert, i64 %retval.sroa.3.0, 1
  ret { i64, i64 } %.fca.1.insert
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @floatx80_to_int32(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call fastcc i32 @floatx80_to_int32_scalbn(i64 %a.coerce0, i16 %a.coerce1, i8 noundef zeroext %0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @floatx80_to_int32_scalbn(i64 %a.coerce0, i16 %a.coerce1, i8 noundef zeroext %rmode, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %floatx80_rounding_precision.i = getelementptr inbounds i8, ptr %s, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i = icmp ult i8 %0, 3
  br i1 %switch.i, label %sw.epilog.i, label %do.body.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %entry
  %cmp.i.i = icmp slt i64 %a.coerce0, 0
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i.i = icmp eq i16 %1, 0
  %.not.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  br i1 %.not.i, label %if.end.i, label %if.end.thread

if.end.i:                                         ; preds = %sw.epilog.i
  %f.coerce1.lobit.i.i = lshr i16 %a.coerce1, 15
  %frombool.i.i = trunc i16 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %and.i.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.not.i = icmp eq i16 %1, 32767
  br i1 %cmp.not.i, label %if.else.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef nonnull %s, ptr noundef nonnull @floatx80_params)
  %.pr.pre = load i8, ptr %p, align 8
  br label %if.end

if.else.i:                                        ; preds = %if.end.i
  %and.i = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %2 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i.i = icmp eq i64 %2, 0
  %3 = select i1 %tobool.not.i.i, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %3
  store i8 %cond17.i, ptr %p, align 8
  br label %if.end

if.end.thread:                                    ; preds = %sw.epilog.i
  %4 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %4, 1
  store i16 %or1.i.i, ptr %s, align 2
  br label %sw.epilog.i3

if.end:                                           ; preds = %if.then10.i, %if.else.i
  %5 = phi i8 [ %cond17.i, %if.else.i ], [ %.pr.pre, %if.then10.i ]
  switch i8 %5, label %do.body.i5 [
    i8 5, label %sw.bb.i
    i8 4, label %sw.epilog.i3
    i8 3, label %sw.bb3.i
    i8 1, label %parts128_float_to_sint.exit
    i8 2, label %sw.bb6.i
  ]

sw.bb.i:                                          ; preds = %if.end
  br label %sw.epilog.i3

sw.bb3.i:                                         ; preds = %if.end
  %sign.i = getelementptr inbounds i8, ptr %p, i64 1
  %6 = load i8, ptr %sign.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i = icmp eq i8 %7, 0
  %cond.i = select i1 %tobool.not.i, i64 2147483647, i64 -2147483648
  br label %sw.epilog.i3

sw.bb6.i:                                         ; preds = %if.end
  %call.i = call fastcc zeroext i1 @parts128_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef 126)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %exp.i = getelementptr inbounds i8, ptr %p, i64 4
  %8 = load i32, ptr %exp.i, align 4
  %cmp.i = icmp slt i32 %8, 64
  %frac_hi.i = getelementptr inbounds i8, ptr %p, i64 8
  %9 = load i64, ptr %frac_hi.i, align 8
  %sub.i = sub i32 63, %8
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %9, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %sign11.i = getelementptr inbounds i8, ptr %p, i64 1
  %10 = load i8, ptr %sign11.i, align 1
  %11 = and i8 %10, 1
  %tobool12.not.i = icmp eq i8 %11, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, 2147483648
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -2147483648, i64 %sub18.i
  br label %sw.epilog.i3

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp ugt i64 %r.0.i, 2147483647
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 2147483647)
  br label %sw.epilog.i3

do.body.i5:                                       ; preds = %if.end
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1110, ptr noundef nonnull @__func__.parts128_float_to_sint, ptr noundef null) #16
  unreachable

sw.epilog.i3:                                     ; preds = %if.end.thread, %if.else21.i, %if.then13.i, %sw.bb3.i, %sw.bb.i, %if.end
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 1, %if.end ], [ 8193, %sw.bb.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ 1, %if.end.thread ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 2147483647, %if.end ], [ 2147483647, %sw.bb.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 2147483647, %if.end.thread ]
  %12 = load i16, ptr %s, align 2
  %or1.i.i4 = or i16 %12, %flags.2.i
  store i16 %or1.i.i4, ptr %s, align 2
  %13 = trunc i64 %r.1.i to i32
  br label %parts128_float_to_sint.exit

parts128_float_to_sint.exit:                      ; preds = %if.end, %sw.epilog.i3
  %retval.0.i = phi i32 [ %13, %sw.epilog.i3 ], [ 0, %if.end ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @floatx80_to_int64(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call fastcc i64 @floatx80_to_int64_scalbn(i64 %a.coerce0, i16 %a.coerce1, i8 noundef zeroext %0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i64 @floatx80_to_int64_scalbn(i64 %a.coerce0, i16 %a.coerce1, i8 noundef zeroext %rmode, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %floatx80_rounding_precision.i = getelementptr inbounds i8, ptr %s, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i = icmp ult i8 %0, 3
  br i1 %switch.i, label %sw.epilog.i, label %do.body.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %entry
  %cmp.i.i = icmp slt i64 %a.coerce0, 0
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i.i = icmp eq i16 %1, 0
  %.not.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  br i1 %.not.i, label %if.end.i, label %if.end.thread

if.end.i:                                         ; preds = %sw.epilog.i
  %f.coerce1.lobit.i.i = lshr i16 %a.coerce1, 15
  %frombool.i.i = trunc i16 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %and.i.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.not.i = icmp eq i16 %1, 32767
  br i1 %cmp.not.i, label %if.else.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef nonnull %s, ptr noundef nonnull @floatx80_params)
  %.pr.pre = load i8, ptr %p, align 8
  br label %if.end

if.else.i:                                        ; preds = %if.end.i
  %and.i = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %2 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i.i = icmp eq i64 %2, 0
  %3 = select i1 %tobool.not.i.i, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %3
  store i8 %cond17.i, ptr %p, align 8
  br label %if.end

if.end.thread:                                    ; preds = %sw.epilog.i
  %4 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %4, 1
  store i16 %or1.i.i, ptr %s, align 2
  br label %sw.epilog.i3

if.end:                                           ; preds = %if.then10.i, %if.else.i
  %5 = phi i8 [ %cond17.i, %if.else.i ], [ %.pr.pre, %if.then10.i ]
  switch i8 %5, label %do.body.i5 [
    i8 5, label %sw.bb.i
    i8 4, label %sw.epilog.i3
    i8 3, label %sw.bb3.i
    i8 1, label %parts128_float_to_sint.exit
    i8 2, label %sw.bb6.i
  ]

sw.bb.i:                                          ; preds = %if.end
  br label %sw.epilog.i3

sw.bb3.i:                                         ; preds = %if.end
  %sign.i = getelementptr inbounds i8, ptr %p, i64 1
  %6 = load i8, ptr %sign.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i = icmp eq i8 %7, 0
  %cond.i = select i1 %tobool.not.i, i64 9223372036854775807, i64 -9223372036854775808
  br label %sw.epilog.i3

sw.bb6.i:                                         ; preds = %if.end
  %call.i = call fastcc zeroext i1 @parts128_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef 126)
  %spec.select.i = select i1 %call.i, i16 16, i16 0
  %exp.i = getelementptr inbounds i8, ptr %p, i64 4
  %8 = load i32, ptr %exp.i, align 4
  %cmp.i = icmp slt i32 %8, 64
  %frac_hi.i = getelementptr inbounds i8, ptr %p, i64 8
  %9 = load i64, ptr %frac_hi.i, align 8
  %sub.i = sub i32 63, %8
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %9, %sh_prom.i
  %r.0.i = select i1 %cmp.i, i64 %shr.i, i64 -1
  %sign11.i = getelementptr inbounds i8, ptr %p, i64 1
  %10 = load i8, ptr %sign11.i, align 1
  %11 = and i8 %10, 1
  %tobool12.not.i = icmp eq i8 %11, 0
  br i1 %tobool12.not.i, label %if.else21.i, label %if.then13.i

if.then13.i:                                      ; preds = %sw.bb6.i
  %cmp15.not.i = icmp ugt i64 %r.0.i, -9223372036854775808
  %sub18.i = sub i64 0, %r.0.i
  %spec.select19.i = select i1 %cmp15.not.i, i16 4097, i16 %spec.select.i
  %spec.select20.i = select i1 %cmp15.not.i, i64 -9223372036854775808, i64 %sub18.i
  br label %sw.epilog.i3

if.else21.i:                                      ; preds = %sw.bb6.i
  %cmp22.i = icmp slt i64 %r.0.i, 0
  %spec.select17.i = select i1 %cmp22.i, i16 4097, i16 %spec.select.i
  %spec.select18.i = tail call i64 @llvm.umin.i64(i64 %r.0.i, i64 9223372036854775807)
  br label %sw.epilog.i3

do.body.i5:                                       ; preds = %if.end
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1110, ptr noundef nonnull @__func__.parts128_float_to_sint, ptr noundef null) #16
  unreachable

sw.epilog.i3:                                     ; preds = %if.end.thread, %if.else21.i, %if.then13.i, %sw.bb3.i, %sw.bb.i, %if.end
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 1, %if.end ], [ 8193, %sw.bb.i ], [ %spec.select17.i, %if.else21.i ], [ %spec.select19.i, %if.then13.i ], [ 1, %if.end.thread ]
  %r.1.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 9223372036854775807, %if.end ], [ 9223372036854775807, %sw.bb.i ], [ %spec.select18.i, %if.else21.i ], [ %spec.select20.i, %if.then13.i ], [ 9223372036854775807, %if.end.thread ]
  %12 = load i16, ptr %s, align 2
  %or1.i.i4 = or i16 %12, %flags.2.i
  store i16 %or1.i.i4, ptr %s, align 2
  br label %parts128_float_to_sint.exit

parts128_float_to_sint.exit:                      ; preds = %if.end, %sw.epilog.i3
  %retval.0.i = phi i64 [ %r.1.i, %sw.epilog.i3 ], [ 0, %if.end ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i16 @float16_to_int16_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call signext i16 @float16_to_int16_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float16_to_int32_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i32 @float16_to_int32_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float16_to_int64_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i64 @float16_to_int64_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i16 @float32_to_int16_round_to_zero(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call signext i16 @float32_to_int16_scalbn(i32 noundef %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_to_int32_round_to_zero(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i32 @float32_to_int32_scalbn(i32 noundef %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float32_to_int64_round_to_zero(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i64 @float32_to_int64_scalbn(i32 noundef %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i16 @float64_to_int16_round_to_zero(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call signext i16 @float64_to_int16_scalbn(i64 noundef %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float64_to_int32_round_to_zero(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i32 @float64_to_int32_scalbn(i64 noundef %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_to_int64_round_to_zero(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i64 @float64_to_int64_scalbn(i64 noundef %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float128_to_int32_round_to_zero(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float128_to_int32_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext 3, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float128_to_int64_round_to_zero(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @float128_to_int64_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext 3, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_to_int128_round_to_zero(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i64 } @float128_to_int128_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext 3, ptr noundef %s)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @floatx80_to_int32_round_to_zero(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @floatx80_to_int32_scalbn(i64 %a.coerce0, i16 %a.coerce1, i8 noundef zeroext 3, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @floatx80_to_int64_round_to_zero(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @floatx80_to_int64_scalbn(i64 %a.coerce0, i16 %a.coerce1, i8 noundef zeroext 3, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i8 @bfloat16_to_int8(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call signext i8 @bfloat16_to_int8_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i8 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i16 @bfloat16_to_int16(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call signext i16 @bfloat16_to_int16_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bfloat16_to_int32(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i32 @bfloat16_to_int32_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bfloat16_to_int64(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i64 @bfloat16_to_int64_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i8 @bfloat16_to_int8_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call signext i8 @bfloat16_to_int8_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i8 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local signext i16 @bfloat16_to_int16_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call signext i16 @bfloat16_to_int16_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bfloat16_to_int32_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i32 @bfloat16_to_int32_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bfloat16_to_int64_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i64 @bfloat16_to_int64_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float64_to_int32_modulo(i64 noundef %a, i8 noundef zeroext %rmode, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %float64_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float64_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %float64_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br label %float64_unpack_canonical.exit

float64_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %call = call fastcc i64 @parts64_float_to_sint_modulo(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef 31, ptr noundef %s)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i64 @parts64_float_to_sint_modulo(ptr nocapture noundef %p, i8 noundef zeroext %rmode, i32 noundef %bitsm1, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %0 = load i8, ptr %p, align 8
  switch i8 %0, label %do.body [
    i8 5, label %sw.bb
    i8 4, label %sw.epilog
    i8 3, label %sw.bb3
    i8 1, label %return
    i8 2, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %call = tail call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef 0, i32 noundef 62)
  %spec.select = select i1 %call, i16 16, i16 0
  %exp = getelementptr inbounds i8, ptr %p, i64 4
  %1 = load i32, ptr %exp, align 4
  %cmp = icmp slt i32 %1, 64
  br i1 %cmp, label %if.then7, label %if.else22

if.then7:                                         ; preds = %sw.bb5
  %2 = getelementptr inbounds i8, ptr %p, i64 8
  %3 = load i64, ptr %2, align 8
  %sub = sub i32 63, %1
  %sh_prom = zext nneg i32 %sub to i64
  %shr = lshr i64 %3, %sh_prom
  %cmp10 = icmp slt i32 %1, %bitsm1
  br i1 %cmp10, label %if.end30, label %if.else

if.else:                                          ; preds = %if.then7
  %cmp14 = icmp eq i32 %1, %bitsm1
  br i1 %cmp14, label %if.then16, label %if.end30

if.then16:                                        ; preds = %if.else
  %sign = getelementptr inbounds i8, ptr %p, i64 1
  %4 = load i8, ptr %sign, align 1
  %5 = and i8 %4, 1
  %tobool.not = icmp ne i8 %5, 0
  %cmp17 = icmp eq i64 %3, -9223372036854775808
  %narrow.not = select i1 %tobool.not, i1 %cmp17, i1 false
  %6 = select i1 %narrow.not, i16 %spec.select, i16 4097
  br label %if.end30

if.else22:                                        ; preds = %sw.bb5
  %cmp25 = icmp ult i32 %1, 127
  br i1 %cmp25, label %if.then27, label %if.end30

if.then27:                                        ; preds = %if.else22
  %sub24 = add nsw i32 %1, -63
  %7 = getelementptr inbounds i8, ptr %p, i64 8
  %8 = load i64, ptr %7, align 8
  %sh_prom.i = zext nneg i32 %sub24 to i64
  %shl.i = shl i64 %8, %sh_prom.i
  store i64 %shl.i, ptr %7, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then27, %if.else22, %if.else, %if.then7, %if.then16
  %r.1 = phi i64 [ %shr, %if.then7 ], [ %shr, %if.then16 ], [ %shr, %if.else ], [ %shl.i, %if.then27 ], [ 0, %if.else22 ]
  %overflow.0 = phi i16 [ %spec.select, %if.then7 ], [ %6, %if.then16 ], [ 4097, %if.else ], [ 4097, %if.then27 ], [ 4097, %if.else22 ]
  %sign31 = getelementptr inbounds i8, ptr %p, i64 1
  %9 = load i8, ptr %sign31, align 1
  %10 = and i8 %9, 1
  %tobool32.not = icmp eq i8 %10, 0
  %sub34 = sub i64 0, %r.1
  %spec.select18 = select i1 %tobool32.not, i64 %r.1, i64 %sub34
  br label %sw.epilog

do.body:                                          ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1253, ptr noundef nonnull @__func__.parts64_float_to_sint_modulo, ptr noundef null) #16
  unreachable

sw.epilog:                                        ; preds = %if.end30, %entry, %sw.bb, %sw.bb3
  %r.2 = phi i64 [ 0, %sw.bb3 ], [ 0, %entry ], [ 0, %sw.bb ], [ %spec.select18, %if.end30 ]
  %overflow.1 = phi i16 [ 4097, %sw.bb3 ], [ 1, %entry ], [ 8193, %sw.bb ], [ %overflow.0, %if.end30 ]
  %11 = load i16, ptr %s, align 2
  %or1.i = or i16 %11, %overflow.1
  store i16 %or1.i, ptr %s, align 2
  br label %return

return:                                           ; preds = %entry, %sw.epilog
  %retval.0 = phi i64 [ %r.2, %sw.epilog ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_to_int64_modulo(i64 noundef %a, i8 noundef zeroext %rmode, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %float64_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float64_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %float64_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br label %float64_unpack_canonical.exit

float64_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %call = call fastcc i64 @parts64_float_to_sint_modulo(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef 63, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i8 @float16_to_uint8_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i16 %1, label %float16a_unpack_canonical.exit.thread [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %float16a_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

float16a_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit.thread:            ; preds = %entry
  %conv.i.i.i = zext nneg i16 %1 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float16a_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 255, i64 0
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float16a_unpack_canonical.exit.thread, %float16a_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %7 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %7, 1
  br i1 %cmp.i, label %sw.epilog.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %8 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %9 = and i8 %8, 1
  %tobool13.not.i = icmp eq i8 %9, 0
  br i1 %tobool13.not.i, label %if.else.i, label %sw.epilog.i

if.else.i:                                        ; preds = %if.end11.i
  %10 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %10, 63
  br i1 %cmp15.i, label %sw.epilog.i, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %11 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %10
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %11, %sh_prom.i
  %cmp20.i = icmp ugt i64 %shr.i, 255
  %spec.select.i = select i1 %cmp20.i, i16 4097, i16 %flags.1.i
  %spec.select15.i = tail call i64 @llvm.umin.i64(i64 %shr.i, i64 255)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float16a_unpack_canonical.exit, %if.else18.i, %if.else.i, %if.end11.i, %if.then.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %spec.select.i, %if.else18.i ], [ %spec.select, %float16a_unpack_canonical.exit ]
  %r.0.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ 255, %if.else.i ], [ %spec.select15.i, %if.else18.i ], [ 255, %float16a_unpack_canonical.exit ]
  %12 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %12, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %13 = trunc i64 %r.0.i to i8
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i8 [ %13, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i8 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_to_uint16_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i16 %1, label %float16a_unpack_canonical.exit.thread [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %float16a_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

float16a_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit.thread:            ; preds = %entry
  %conv.i.i.i = zext nneg i16 %1 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float16a_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 65535, i64 0
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float16a_unpack_canonical.exit.thread, %float16a_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %7 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %7, 1
  br i1 %cmp.i, label %sw.epilog.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %8 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %9 = and i8 %8, 1
  %tobool13.not.i = icmp eq i8 %9, 0
  br i1 %tobool13.not.i, label %if.else.i, label %sw.epilog.i

if.else.i:                                        ; preds = %if.end11.i
  %10 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %10, 63
  br i1 %cmp15.i, label %sw.epilog.i, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %11 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %10
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %11, %sh_prom.i
  %cmp20.i = icmp ugt i64 %shr.i, 65535
  %spec.select.i = select i1 %cmp20.i, i16 4097, i16 %flags.1.i
  %spec.select15.i = tail call i64 @llvm.umin.i64(i64 %shr.i, i64 65535)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float16a_unpack_canonical.exit, %if.else18.i, %if.else.i, %if.end11.i, %if.then.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %spec.select.i, %if.else18.i ], [ %spec.select, %float16a_unpack_canonical.exit ]
  %r.0.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ 65535, %if.else.i ], [ %spec.select15.i, %if.else18.i ], [ 65535, %float16a_unpack_canonical.exit ]
  %12 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %12, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %13 = trunc i64 %r.0.i to i16
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i16 [ %13, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i16 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float16_to_uint32_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i16 %1, label %float16a_unpack_canonical.exit.thread [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %float16a_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

float16a_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit.thread:            ; preds = %entry
  %conv.i.i.i = zext nneg i16 %1 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float16a_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 4294967295, i64 0
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float16a_unpack_canonical.exit.thread, %float16a_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %7 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %7, 1
  br i1 %cmp.i, label %sw.epilog.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %8 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %9 = and i8 %8, 1
  %tobool13.not.i = icmp eq i8 %9, 0
  br i1 %tobool13.not.i, label %if.else.i, label %sw.epilog.i

if.else.i:                                        ; preds = %if.end11.i
  %10 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %10, 63
  br i1 %cmp15.i, label %sw.epilog.i, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %11 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %10
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %11, %sh_prom.i
  %cmp20.i = icmp ugt i64 %shr.i, 4294967295
  %spec.select.i = select i1 %cmp20.i, i16 4097, i16 %flags.1.i
  %spec.select15.i = tail call i64 @llvm.umin.i64(i64 %shr.i, i64 4294967295)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float16a_unpack_canonical.exit, %if.else18.i, %if.else.i, %if.end11.i, %if.then.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %spec.select.i, %if.else18.i ], [ %spec.select, %float16a_unpack_canonical.exit ]
  %r.0.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ 4294967295, %if.else.i ], [ %spec.select15.i, %if.else18.i ], [ 4294967295, %float16a_unpack_canonical.exit ]
  %12 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %12, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %13 = trunc i64 %r.0.i to i32
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i32 [ %13, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float16_to_uint64_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i16 %1, label %float16a_unpack_canonical.exit.thread [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %float16a_unpack_canonical.exit.thread3, label %parts64_float_to_uint.exit.sink.split

float16a_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %5 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %5 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %5
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit.thread:            ; preds = %entry
  %conv.i.i.i = zext nneg i16 %1 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float16a_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %parts64_float_to_uint.exit.sink.split

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = sext i1 %tobool.not.i to i64
  br label %parts64_float_to_uint.exit.sink.split

sw.bb6.i:                                         ; preds = %float16a_unpack_canonical.exit.thread, %float16a_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %6 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %6, 1
  br i1 %cmp.i, label %parts64_float_to_uint.exit.sink.split, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %7 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %8 = and i8 %7, 1
  %tobool13.not.i = icmp eq i8 %8, 0
  br i1 %tobool13.not.i, label %if.else.i, label %parts64_float_to_uint.exit.sink.split

if.else.i:                                        ; preds = %if.end11.i
  %9 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %9, 63
  br i1 %cmp15.i, label %parts64_float_to_uint.exit.sink.split, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %10 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %9
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %10, %sh_prom.i
  br label %parts64_float_to_uint.exit.sink.split

parts64_float_to_uint.exit.sink.split:            ; preds = %sw.bb3.i, %if.then.i, %if.end11.i, %if.else.i, %if.else18.i, %float16a_unpack_canonical.exit, %if.else.i.i
  %.sink4 = phi i16 [ 32, %if.else.i.i ], [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %flags.1.i, %if.else18.i ], [ %spec.select, %float16a_unpack_canonical.exit ]
  %retval.0.i.ph = phi i64 [ 0, %if.else.i.i ], [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ -1, %if.else.i ], [ %shr.i, %if.else18.i ], [ -1, %float16a_unpack_canonical.exit ]
  %11 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %11, %.sink4
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %parts64_float_to_uint.exit.sink.split, %if.then.i.i
  %retval.0.i = phi i64 [ 0, %if.then.i.i ], [ %retval.0.i.ph, %parts64_float_to_uint.exit.sink.split ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float32_to_uint16_scalbn(i32 noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %float32_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float32_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

float32_unpack_canonical.exit.thread3:            ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float32_unpack_canonical.exit

float32_unpack_canonical.exit.thread:             ; preds = %entry
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float32_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i32 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 65535, i64 0
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float32_unpack_canonical.exit.thread, %float32_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %5 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %5, 1
  br i1 %cmp.i, label %sw.epilog.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %6 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %7 = and i8 %6, 1
  %tobool13.not.i = icmp eq i8 %7, 0
  br i1 %tobool13.not.i, label %if.else.i, label %sw.epilog.i

if.else.i:                                        ; preds = %if.end11.i
  %8 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %8, 63
  br i1 %cmp15.i, label %sw.epilog.i, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %9 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %8
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %9, %sh_prom.i
  %cmp20.i = icmp ugt i64 %shr.i, 65535
  %spec.select.i = select i1 %cmp20.i, i16 4097, i16 %flags.1.i
  %spec.select15.i = tail call i64 @llvm.umin.i64(i64 %shr.i, i64 65535)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float32_unpack_canonical.exit, %if.else18.i, %if.else.i, %if.end11.i, %if.then.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %spec.select.i, %if.else18.i ], [ %spec.select, %float32_unpack_canonical.exit ]
  %r.0.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ 65535, %if.else.i ], [ %spec.select15.i, %if.else18.i ], [ 65535, %float32_unpack_canonical.exit ]
  %10 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %10, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %11 = trunc i64 %r.0.i to i16
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i16 [ %11, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i16 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_to_uint32_scalbn(i32 noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %float32_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float32_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

float32_unpack_canonical.exit.thread3:            ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float32_unpack_canonical.exit

float32_unpack_canonical.exit.thread:             ; preds = %entry
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float32_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i32 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 4294967295, i64 0
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float32_unpack_canonical.exit.thread, %float32_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %5 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %5, 1
  br i1 %cmp.i, label %sw.epilog.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %6 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %7 = and i8 %6, 1
  %tobool13.not.i = icmp eq i8 %7, 0
  br i1 %tobool13.not.i, label %if.else.i, label %sw.epilog.i

if.else.i:                                        ; preds = %if.end11.i
  %8 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %8, 63
  br i1 %cmp15.i, label %sw.epilog.i, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %9 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %8
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %9, %sh_prom.i
  %cmp20.i = icmp ugt i64 %shr.i, 4294967295
  %spec.select.i = select i1 %cmp20.i, i16 4097, i16 %flags.1.i
  %spec.select15.i = tail call i64 @llvm.umin.i64(i64 %shr.i, i64 4294967295)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float32_unpack_canonical.exit, %if.else18.i, %if.else.i, %if.end11.i, %if.then.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %spec.select.i, %if.else18.i ], [ %spec.select, %float32_unpack_canonical.exit ]
  %r.0.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ 4294967295, %if.else.i ], [ %spec.select15.i, %if.else18.i ], [ 4294967295, %float32_unpack_canonical.exit ]
  %10 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %10, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %11 = trunc i64 %r.0.i to i32
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i32 [ %11, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float32_to_uint64_scalbn(i32 noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %float32_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float32_unpack_canonical.exit.thread3, label %parts64_float_to_uint.exit.sink.split

float32_unpack_canonical.exit.thread3:            ; preds = %if.else.i.i
  %3 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %3 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %3
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float32_unpack_canonical.exit

float32_unpack_canonical.exit.thread:             ; preds = %entry
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float32_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %parts64_float_to_uint.exit.sink.split

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i32 %a, -1
  %cond.i = sext i1 %tobool.not.i to i64
  br label %parts64_float_to_uint.exit.sink.split

sw.bb6.i:                                         ; preds = %float32_unpack_canonical.exit.thread, %float32_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %4 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %4, 1
  br i1 %cmp.i, label %parts64_float_to_uint.exit.sink.split, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %5 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %6 = and i8 %5, 1
  %tobool13.not.i = icmp eq i8 %6, 0
  br i1 %tobool13.not.i, label %if.else.i, label %parts64_float_to_uint.exit.sink.split

if.else.i:                                        ; preds = %if.end11.i
  %7 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %7, 63
  br i1 %cmp15.i, label %parts64_float_to_uint.exit.sink.split, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %8 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %7
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %8, %sh_prom.i
  br label %parts64_float_to_uint.exit.sink.split

parts64_float_to_uint.exit.sink.split:            ; preds = %sw.bb3.i, %if.then.i, %if.end11.i, %if.else.i, %if.else18.i, %float32_unpack_canonical.exit, %if.else.i.i
  %.sink4 = phi i16 [ 32, %if.else.i.i ], [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %flags.1.i, %if.else18.i ], [ %spec.select, %float32_unpack_canonical.exit ]
  %retval.0.i.ph = phi i64 [ 0, %if.else.i.i ], [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ -1, %if.else.i ], [ %shr.i, %if.else18.i ], [ -1, %float32_unpack_canonical.exit ]
  %9 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %9, %.sink4
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %parts64_float_to_uint.exit.sink.split, %if.then.i.i
  %retval.0.i = phi i64 [ 0, %if.then.i.i ], [ %retval.0.i.ph, %parts64_float_to_uint.exit.sink.split ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float64_to_uint16_scalbn(i64 noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i32 %conv.i.i.i, label %float64_unpack_canonical.exit.thread [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float64_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

float64_unpack_canonical.exit.thread3:            ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float64_unpack_canonical.exit

float64_unpack_canonical.exit.thread:             ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float64_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i.inv = icmp slt i64 %a, 0
  %cond.i = select i1 %tobool.not.i.inv, i64 0, i64 65535
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float64_unpack_canonical.exit.thread, %float64_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %5 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %5, 1
  br i1 %cmp.i, label %sw.epilog.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %6 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %7 = and i8 %6, 1
  %tobool13.not.i = icmp eq i8 %7, 0
  br i1 %tobool13.not.i, label %if.else.i, label %sw.epilog.i

if.else.i:                                        ; preds = %if.end11.i
  %8 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %8, 63
  br i1 %cmp15.i, label %sw.epilog.i, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %9 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %8
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %9, %sh_prom.i
  %cmp20.i = icmp ugt i64 %shr.i, 65535
  %spec.select.i = select i1 %cmp20.i, i16 4097, i16 %flags.1.i
  %spec.select15.i = tail call i64 @llvm.umin.i64(i64 %shr.i, i64 65535)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float64_unpack_canonical.exit, %if.else18.i, %if.else.i, %if.end11.i, %if.then.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %spec.select.i, %if.else18.i ], [ %spec.select, %float64_unpack_canonical.exit ]
  %r.0.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ 65535, %if.else.i ], [ %spec.select15.i, %if.else18.i ], [ 65535, %float64_unpack_canonical.exit ]
  %10 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %10, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %11 = trunc i64 %r.0.i to i16
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i16 [ %11, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i16 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float64_to_uint32_scalbn(i64 noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i32 %conv.i.i.i, label %float64_unpack_canonical.exit.thread [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float64_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

float64_unpack_canonical.exit.thread3:            ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float64_unpack_canonical.exit

float64_unpack_canonical.exit.thread:             ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float64_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i.inv = icmp slt i64 %a, 0
  %cond.i = select i1 %tobool.not.i.inv, i64 0, i64 4294967295
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %float64_unpack_canonical.exit.thread, %float64_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %5 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %5, 1
  br i1 %cmp.i, label %sw.epilog.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %6 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %7 = and i8 %6, 1
  %tobool13.not.i = icmp eq i8 %7, 0
  br i1 %tobool13.not.i, label %if.else.i, label %sw.epilog.i

if.else.i:                                        ; preds = %if.end11.i
  %8 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %8, 63
  br i1 %cmp15.i, label %sw.epilog.i, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %9 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %8
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %9, %sh_prom.i
  %cmp20.i = icmp ugt i64 %shr.i, 4294967295
  %spec.select.i = select i1 %cmp20.i, i16 4097, i16 %flags.1.i
  %spec.select15.i = tail call i64 @llvm.umin.i64(i64 %shr.i, i64 4294967295)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %float64_unpack_canonical.exit, %if.else18.i, %if.else.i, %if.end11.i, %if.then.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %spec.select.i, %if.else18.i ], [ %spec.select, %float64_unpack_canonical.exit ]
  %r.0.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ 4294967295, %if.else.i ], [ %spec.select15.i, %if.else18.i ], [ 4294967295, %float64_unpack_canonical.exit ]
  %10 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %10, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %11 = trunc i64 %r.0.i to i32
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i32 [ %11, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_to_uint64_scalbn(i64 noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  switch i32 %conv.i.i.i, label %float64_unpack_canonical.exit.thread [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float64_unpack_canonical.exit.thread3, label %parts64_float_to_uint.exit.sink.split

float64_unpack_canonical.exit.thread3:            ; preds = %if.else.i.i
  %3 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %3 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %3
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %float64_unpack_canonical.exit

float64_unpack_canonical.exit.thread:             ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

float64_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %parts64_float_to_uint.exit.sink.split

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i64 %a, -1
  %cond.i = sext i1 %tobool.not.i to i64
  br label %parts64_float_to_uint.exit.sink.split

sw.bb6.i:                                         ; preds = %float64_unpack_canonical.exit.thread, %float64_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %4 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %4, 1
  br i1 %cmp.i, label %parts64_float_to_uint.exit.sink.split, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %5 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %6 = and i8 %5, 1
  %tobool13.not.i = icmp eq i8 %6, 0
  br i1 %tobool13.not.i, label %if.else.i, label %parts64_float_to_uint.exit.sink.split

if.else.i:                                        ; preds = %if.end11.i
  %7 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %7, 63
  br i1 %cmp15.i, label %parts64_float_to_uint.exit.sink.split, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %8 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %7
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %8, %sh_prom.i
  br label %parts64_float_to_uint.exit.sink.split

parts64_float_to_uint.exit.sink.split:            ; preds = %sw.bb3.i, %if.then.i, %if.end11.i, %if.else.i, %if.else18.i, %float64_unpack_canonical.exit, %if.else.i.i
  %.sink4 = phi i16 [ 32, %if.else.i.i ], [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %flags.1.i, %if.else18.i ], [ %spec.select, %float64_unpack_canonical.exit ]
  %retval.0.i.ph = phi i64 [ 0, %if.else.i.i ], [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ -1, %if.else.i ], [ %shr.i, %if.else18.i ], [ -1, %float64_unpack_canonical.exit ]
  %9 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %9, %.sink4
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %parts64_float_to_uint.exit.sink.split, %if.then.i.i
  %retval.0.i = phi i64 [ 0, %if.then.i.i ], [ %retval.0.i.ph, %parts64_float_to_uint.exit.sink.split ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i8 @bfloat16_to_uint8_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %1 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %bfloat16_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %2 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %3 = and i8 %2, 1
  %tobool9.not.i.i = icmp eq i8 %3, 0
  br i1 %tobool9.not.i.i, label %bfloat16_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %4 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %4, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

bfloat16_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %5 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %5 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %5
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %bfloat16_unpack_canonical.exit

bfloat16_unpack_canonical.exit.thread:            ; preds = %entry
  %6 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %6 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

bfloat16_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %1, 64
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 255, i64 0
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %bfloat16_unpack_canonical.exit.thread, %bfloat16_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %7 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %7, 1
  br i1 %cmp.i, label %sw.epilog.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %8 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %9 = and i8 %8, 1
  %tobool13.not.i = icmp eq i8 %9, 0
  br i1 %tobool13.not.i, label %if.else.i, label %sw.epilog.i

if.else.i:                                        ; preds = %if.end11.i
  %10 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %10, 63
  br i1 %cmp15.i, label %sw.epilog.i, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %11 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %10
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %11, %sh_prom.i
  %cmp20.i = icmp ugt i64 %shr.i, 255
  %spec.select.i = select i1 %cmp20.i, i16 4097, i16 %flags.1.i
  %spec.select15.i = tail call i64 @llvm.umin.i64(i64 %shr.i, i64 255)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %bfloat16_unpack_canonical.exit, %if.else18.i, %if.else.i, %if.end11.i, %if.then.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %spec.select.i, %if.else18.i ], [ %spec.select, %bfloat16_unpack_canonical.exit ]
  %r.0.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ 255, %if.else.i ], [ %spec.select15.i, %if.else18.i ], [ 255, %bfloat16_unpack_canonical.exit ]
  %12 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %12, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %13 = trunc i64 %r.0.i to i8
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i8 [ %13, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i8 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_to_uint16_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %1 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %bfloat16_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %2 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %3 = and i8 %2, 1
  %tobool9.not.i.i = icmp eq i8 %3, 0
  br i1 %tobool9.not.i.i, label %bfloat16_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %4 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %4, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

bfloat16_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %5 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %5 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %5
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %bfloat16_unpack_canonical.exit

bfloat16_unpack_canonical.exit.thread:            ; preds = %entry
  %6 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %6 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

bfloat16_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %1, 64
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 65535, i64 0
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %bfloat16_unpack_canonical.exit.thread, %bfloat16_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %7 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %7, 1
  br i1 %cmp.i, label %sw.epilog.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %8 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %9 = and i8 %8, 1
  %tobool13.not.i = icmp eq i8 %9, 0
  br i1 %tobool13.not.i, label %if.else.i, label %sw.epilog.i

if.else.i:                                        ; preds = %if.end11.i
  %10 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %10, 63
  br i1 %cmp15.i, label %sw.epilog.i, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %11 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %10
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %11, %sh_prom.i
  %cmp20.i = icmp ugt i64 %shr.i, 65535
  %spec.select.i = select i1 %cmp20.i, i16 4097, i16 %flags.1.i
  %spec.select15.i = tail call i64 @llvm.umin.i64(i64 %shr.i, i64 65535)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %bfloat16_unpack_canonical.exit, %if.else18.i, %if.else.i, %if.end11.i, %if.then.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %spec.select.i, %if.else18.i ], [ %spec.select, %bfloat16_unpack_canonical.exit ]
  %r.0.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ 65535, %if.else.i ], [ %spec.select15.i, %if.else18.i ], [ 65535, %bfloat16_unpack_canonical.exit ]
  %12 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %12, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %13 = trunc i64 %r.0.i to i16
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i16 [ %13, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i16 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bfloat16_to_uint32_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %1 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %bfloat16_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %2 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %3 = and i8 %2, 1
  %tobool9.not.i.i = icmp eq i8 %3, 0
  br i1 %tobool9.not.i.i, label %bfloat16_unpack_canonical.exit.thread3, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %4 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %4, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

bfloat16_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %5 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %5 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %5
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %bfloat16_unpack_canonical.exit

bfloat16_unpack_canonical.exit.thread:            ; preds = %entry
  %6 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %6 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

bfloat16_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %1, 64
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool.not.i, i64 4294967295, i64 0
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %bfloat16_unpack_canonical.exit.thread, %bfloat16_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %7 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %7, 1
  br i1 %cmp.i, label %sw.epilog.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %8 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %9 = and i8 %8, 1
  %tobool13.not.i = icmp eq i8 %9, 0
  br i1 %tobool13.not.i, label %if.else.i, label %sw.epilog.i

if.else.i:                                        ; preds = %if.end11.i
  %10 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %10, 63
  br i1 %cmp15.i, label %sw.epilog.i, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %11 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %10
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %11, %sh_prom.i
  %cmp20.i = icmp ugt i64 %shr.i, 4294967295
  %spec.select.i = select i1 %cmp20.i, i16 4097, i16 %flags.1.i
  %spec.select15.i = tail call i64 @llvm.umin.i64(i64 %shr.i, i64 4294967295)
  br label %sw.epilog.i

sw.epilog.i:                                      ; preds = %bfloat16_unpack_canonical.exit, %if.else18.i, %if.else.i, %if.end11.i, %if.then.i, %sw.bb3.i
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %spec.select.i, %if.else18.i ], [ %spec.select, %bfloat16_unpack_canonical.exit ]
  %r.0.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ 4294967295, %if.else.i ], [ %spec.select15.i, %if.else18.i ], [ 4294967295, %bfloat16_unpack_canonical.exit ]
  %12 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %12, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %13 = trunc i64 %r.0.i to i32
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %if.then.i.i, %if.then10.i.i, %sw.epilog.i
  %retval.0.i = phi i32 [ %13, %sw.epilog.i ], [ 0, %if.then10.i.i ], [ 0, %if.then.i.i ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bfloat16_to_uint64_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %rmode, i32 noundef %scale, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %1 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %bfloat16_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i.i.i, label %parts64_float_to_uint.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %2 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %3 = and i8 %2, 1
  %tobool9.not.i.i = icmp eq i8 %3, 0
  br i1 %tobool9.not.i.i, label %bfloat16_unpack_canonical.exit.thread3, label %parts64_float_to_uint.exit.sink.split

bfloat16_unpack_canonical.exit.thread3:           ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %sw.bb6.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i29.i.i, label %sw.bb3.i, label %bfloat16_unpack_canonical.exit

bfloat16_unpack_canonical.exit.thread:            ; preds = %entry
  %5 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %5 to i32
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb6.i

bfloat16_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %tobool.not.i32.i.i = icmp ult i16 %1, 64
  %spec.select = select i1 %tobool.not.i32.i.i, i16 8193, i16 1
  br label %parts64_float_to_uint.exit.sink.split

sw.bb3.i:                                         ; preds = %lor.lhs.false.i.i
  %tobool.not.i = icmp sgt i16 %a, -1
  %cond.i = sext i1 %tobool.not.i to i64
  br label %parts64_float_to_uint.exit.sink.split

sw.bb6.i:                                         ; preds = %bfloat16_unpack_canonical.exit.thread, %bfloat16_unpack_canonical.exit.thread3
  %call.i = call fastcc zeroext i1 @parts64_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef 62)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %6 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %6, 1
  br i1 %cmp.i, label %parts64_float_to_uint.exit.sink.split, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %7 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %8 = and i8 %7, 1
  %tobool13.not.i = icmp eq i8 %8, 0
  br i1 %tobool13.not.i, label %if.else.i, label %parts64_float_to_uint.exit.sink.split

if.else.i:                                        ; preds = %if.end11.i
  %9 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %9, 63
  br i1 %cmp15.i, label %parts64_float_to_uint.exit.sink.split, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %10 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %9
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %10, %sh_prom.i
  br label %parts64_float_to_uint.exit.sink.split

parts64_float_to_uint.exit.sink.split:            ; preds = %sw.bb3.i, %if.then.i, %if.end11.i, %if.else.i, %if.else18.i, %bfloat16_unpack_canonical.exit, %if.else.i.i
  %.sink4 = phi i16 [ 32, %if.else.i.i ], [ 4097, %sw.bb3.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %flags.1.i, %if.else18.i ], [ %spec.select, %bfloat16_unpack_canonical.exit ]
  %retval.0.i.ph = phi i64 [ 0, %if.else.i.i ], [ %cond.i, %sw.bb3.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ -1, %if.else.i ], [ %shr.i, %if.else18.i ], [ -1, %bfloat16_unpack_canonical.exit ]
  %11 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %11, %.sink4
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_float_to_uint.exit

parts64_float_to_uint.exit:                       ; preds = %parts64_float_to_uint.exit.sink.split, %if.then.i.i
  %retval.0.i = phi i64 [ 0, %if.then.i.i ], [ %retval.0.i.ph, %parts64_float_to_uint.exit.sink.split ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i8 @float16_to_uint8(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call zeroext i8 @float16_to_uint8_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i8 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_to_uint16(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call zeroext i16 @float16_to_uint16_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float16_to_uint32(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i32 @float16_to_uint32_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float16_to_uint64(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i64 @float16_to_uint64_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float32_to_uint16(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call zeroext i16 @float32_to_uint16_scalbn(i32 noundef %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_to_uint32(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i32 @float32_to_uint32_scalbn(i32 noundef %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float32_to_uint64(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i64 @float32_to_uint64_scalbn(i32 noundef %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float64_to_uint16(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call zeroext i16 @float64_to_uint16_scalbn(i64 noundef %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float64_to_uint32(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i32 @float64_to_uint32_scalbn(i64 noundef %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_to_uint64(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i64 @float64_to_uint64_scalbn(i64 noundef %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float128_to_uint32(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call fastcc i32 @float128_to_uint32_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @float128_to_uint32_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %rmode, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float128_params)
  %1 = load i8, ptr %p, align 8
  switch i8 %1, label %do.body.i [
    i8 5, label %sw.bb.i
    i8 4, label %sw.epilog.i
    i8 3, label %sw.bb3.i
    i8 1, label %parts128_float_to_uint.exit
    i8 2, label %sw.bb6.i
  ]

sw.bb.i:                                          ; preds = %entry
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %entry
  %2 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %3 = and i8 %2, 1
  %tobool.not.i = icmp eq i8 %3, 0
  %cond.i = select i1 %tobool.not.i, i64 4294967295, i64 0
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %entry
  %call.i = call fastcc zeroext i1 @parts128_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef 126)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %4 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %4, 1
  br i1 %cmp.i, label %sw.epilog.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %5 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %6 = and i8 %5, 1
  %tobool13.not.i = icmp eq i8 %6, 0
  br i1 %tobool13.not.i, label %if.else.i, label %sw.epilog.i

if.else.i:                                        ; preds = %if.end11.i
  %7 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %7, 63
  br i1 %cmp15.i, label %sw.epilog.i, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %8 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %7
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %8, %sh_prom.i
  %cmp20.i = icmp ugt i64 %shr.i, 4294967295
  %spec.select.i = select i1 %cmp20.i, i16 4097, i16 %flags.1.i
  %spec.select15.i = tail call i64 @llvm.umin.i64(i64 %shr.i, i64 4294967295)
  br label %sw.epilog.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1178, ptr noundef nonnull @__func__.parts128_float_to_uint, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %if.else18.i, %if.else.i, %if.end11.i, %if.then.i, %sw.bb3.i, %sw.bb.i, %entry
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 1, %entry ], [ 8193, %sw.bb.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %spec.select.i, %if.else18.i ]
  %r.0.i = phi i64 [ %cond.i, %sw.bb3.i ], [ 4294967295, %entry ], [ 4294967295, %sw.bb.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ 4294967295, %if.else.i ], [ %spec.select15.i, %if.else18.i ]
  %9 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %9, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  %10 = trunc i64 %r.0.i to i32
  br label %parts128_float_to_uint.exit

parts128_float_to_uint.exit:                      ; preds = %entry, %sw.epilog.i
  %retval.0.i = phi i32 [ %10, %sw.epilog.i ], [ 0, %entry ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float128_to_uint64(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call fastcc i64 @float128_to_uint64_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i64 @float128_to_uint64_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %rmode, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float128_params)
  %1 = load i8, ptr %p, align 8
  switch i8 %1, label %do.body.i [
    i8 5, label %sw.bb.i
    i8 4, label %sw.epilog.i
    i8 3, label %sw.bb3.i
    i8 1, label %parts128_float_to_uint.exit
    i8 2, label %sw.bb6.i
  ]

sw.bb.i:                                          ; preds = %entry
  br label %sw.epilog.i

sw.bb3.i:                                         ; preds = %entry
  %2 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %3 = and i8 %2, 1
  %sext = add nsw i8 %3, -1
  %cond.i = sext i8 %sext to i64
  br label %sw.epilog.i

sw.bb6.i:                                         ; preds = %entry
  %call.i = call fastcc zeroext i1 @parts128_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef 126)
  br i1 %call.i, label %if.then.i, label %if.end11.i

if.then.i:                                        ; preds = %sw.bb6.i
  %4 = load i8, ptr %p, align 8
  %cmp.i = icmp eq i8 %4, 1
  br i1 %cmp.i, label %sw.epilog.i, label %if.end11.i

if.end11.i:                                       ; preds = %if.then.i, %sw.bb6.i
  %flags.1.i = phi i16 [ 16, %if.then.i ], [ 0, %sw.bb6.i ]
  %5 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %6 = and i8 %5, 1
  %tobool13.not.i = icmp eq i8 %6, 0
  br i1 %tobool13.not.i, label %if.else.i, label %sw.epilog.i

if.else.i:                                        ; preds = %if.end11.i
  %7 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %cmp15.i = icmp sgt i32 %7, 63
  br i1 %cmp15.i, label %sw.epilog.i, label %if.else18.i

if.else18.i:                                      ; preds = %if.else.i
  %8 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %sub.i = sub i32 63, %7
  %sh_prom.i = zext nneg i32 %sub.i to i64
  %shr.i = lshr i64 %8, %sh_prom.i
  br label %sw.epilog.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1178, ptr noundef nonnull @__func__.parts128_float_to_uint, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %if.else18.i, %if.else.i, %if.end11.i, %if.then.i, %sw.bb3.i, %sw.bb.i, %entry
  %flags.2.i = phi i16 [ 4097, %sw.bb3.i ], [ 1, %entry ], [ 8193, %sw.bb.i ], [ 16, %if.then.i ], [ 4097, %if.end11.i ], [ 4097, %if.else.i ], [ %flags.1.i, %if.else18.i ]
  %r.0.i = phi i64 [ %cond.i, %sw.bb3.i ], [ -1, %entry ], [ -1, %sw.bb.i ], [ 0, %if.then.i ], [ 0, %if.end11.i ], [ -1, %if.else.i ], [ %shr.i, %if.else18.i ]
  %9 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %9, %flags.2.i
  store i16 %or1.i.i, ptr %s, align 2
  br label %parts128_float_to_uint.exit

parts128_float_to_uint.exit:                      ; preds = %entry, %sw.epilog.i
  %retval.0.i = phi i64 [ %r.0.i, %sw.epilog.i ], [ 0, %entry ]
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_to_uint128(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call fastcc { i64, i64 } @float128_to_uint128_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %0, ptr noundef %s)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc { i64, i64 } @float128_to_uint128_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %rmode, ptr nocapture noundef %s) unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef %s, ptr noundef nonnull @float128_params)
  %1 = load i8, ptr %p, align 8
  switch i8 %1, label %do.body [
    i8 5, label %sw.bb
    i8 4, label %sw.epilog
    i8 3, label %sw.bb3
    i8 1, label %return
    i8 2, label %sw.bb12
  ]

sw.bb:                                            ; preds = %entry
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %2 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %3 = and i8 %2, 1
  %sext = add nsw i8 %3, -1
  %spec.select = sext i8 %sext to i64
  br label %sw.epilog

sw.bb12:                                          ; preds = %entry
  %call13 = call fastcc zeroext i1 @parts128_round_to_int_normal(ptr noundef nonnull %p, i8 noundef zeroext %rmode, i32 noundef 126)
  br i1 %call13, label %if.then, label %if.end20

if.then:                                          ; preds = %sw.bb12
  %4 = load i8, ptr %p, align 8
  %cmp = icmp eq i8 %4, 1
  br i1 %cmp, label %sw.epilog, label %if.end20

if.end20:                                         ; preds = %if.then, %sw.bb12
  %flags.1 = phi i16 [ 16, %if.then ], [ 0, %sw.bb12 ]
  %5 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %6 = and i8 %5, 1
  %tobool22.not = icmp eq i8 %6, 0
  br i1 %tobool22.not, label %if.else, label %sw.epilog

if.else:                                          ; preds = %if.end20
  %7 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %cmp26 = icmp slt i32 %7, 128
  br i1 %cmp26, label %if.then28, label %sw.epilog

if.then28:                                        ; preds = %if.else
  %sub = sub i32 127, %7
  %8 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %9 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %a.sroa.2.0.insert.ext.i = zext i64 %9 to i128
  %a.sroa.2.0.insert.shift.i = shl nuw i128 %a.sroa.2.0.insert.ext.i, 64
  %a.sroa.0.0.insert.ext.i = zext i64 %8 to i128
  %a.sroa.0.0.insert.insert.i = or disjoint i128 %a.sroa.2.0.insert.shift.i, %a.sroa.0.0.insert.ext.i
  %sh_prom.i = zext nneg i32 %sub to i128
  %shr.i = lshr i128 %a.sroa.0.0.insert.insert.i, %sh_prom.i
  %retval.sroa.0.0.extract.trunc.i = trunc i128 %shr.i to i64
  %retval.sroa.2.0.extract.shift.i = lshr i128 %shr.i, 64
  %retval.sroa.2.0.extract.trunc.i = trunc i128 %retval.sroa.2.0.extract.shift.i to i64
  br label %sw.epilog

do.body:                                          ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 3665, ptr noundef nonnull @__func__.float128_to_uint128_scalbn, ptr noundef null) #16
  unreachable

sw.epilog:                                        ; preds = %sw.bb3, %if.else, %if.end20, %if.then, %entry, %sw.bb, %if.then28
  %r.0.off0 = phi i64 [ %retval.sroa.0.0.extract.trunc.i, %if.then28 ], [ -1, %sw.bb ], [ -1, %entry ], [ 0, %if.then ], [ 0, %if.end20 ], [ -1, %if.else ], [ %spec.select, %sw.bb3 ]
  %r.0.off64 = phi i64 [ %retval.sroa.2.0.extract.trunc.i, %if.then28 ], [ -1, %sw.bb ], [ -1, %entry ], [ 0, %if.then ], [ 0, %if.end20 ], [ -1, %if.else ], [ %spec.select, %sw.bb3 ]
  %flags.2 = phi i16 [ %flags.1, %if.then28 ], [ 8193, %sw.bb ], [ 1, %entry ], [ 16, %if.then ], [ 4097, %if.end20 ], [ 4097, %if.else ], [ 4097, %sw.bb3 ]
  %10 = load i16, ptr %s, align 2
  %or1.i = or i16 %10, %flags.2
  store i16 %or1.i, ptr %s, align 2
  br label %return

return:                                           ; preds = %entry, %sw.epilog
  %retval.sroa.0.0 = phi i64 [ %r.0.off0, %sw.epilog ], [ 0, %entry ]
  %retval.sroa.3.0 = phi i64 [ %r.0.off64, %sw.epilog ], [ 0, %entry ]
  %.fca.0.insert = insertvalue { i64, i64 } poison, i64 %retval.sroa.0.0, 0
  %.fca.1.insert = insertvalue { i64, i64 } %.fca.0.insert, i64 %retval.sroa.3.0, 1
  ret { i64, i64 } %.fca.1.insert
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_to_uint16_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call zeroext i16 @float16_to_uint16_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float16_to_uint32_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i32 @float16_to_uint32_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float16_to_uint64_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i64 @float16_to_uint64_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float32_to_uint16_round_to_zero(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call zeroext i16 @float32_to_uint16_scalbn(i32 noundef %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_to_uint32_round_to_zero(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i32 @float32_to_uint32_scalbn(i32 noundef %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float32_to_uint64_round_to_zero(i32 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i64 @float32_to_uint64_scalbn(i32 noundef %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float64_to_uint16_round_to_zero(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call zeroext i16 @float64_to_uint16_scalbn(i64 noundef %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float64_to_uint32_round_to_zero(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i32 @float64_to_uint32_scalbn(i64 noundef %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_to_uint64_round_to_zero(i64 noundef %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i64 @float64_to_uint64_scalbn(i64 noundef %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float128_to_uint32_round_to_zero(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float128_to_uint32_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext 3, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float128_to_uint64_round_to_zero(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @float128_to_uint64_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext 3, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_to_uint128_round_to_zero(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i64 } @float128_to_uint128_scalbn(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext 3, ptr noundef %s)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i8 @bfloat16_to_uint8(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call zeroext i8 @bfloat16_to_uint8_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i8 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_to_uint16(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call zeroext i16 @bfloat16_to_uint16_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bfloat16_to_uint32(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i32 @bfloat16_to_uint32_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bfloat16_to_uint64(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %call = tail call i64 @bfloat16_to_uint64_scalbn(i16 noundef zeroext %a, i8 noundef zeroext %0, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i8 @bfloat16_to_uint8_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call zeroext i8 @bfloat16_to_uint8_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i8 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_to_uint16_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call zeroext i16 @bfloat16_to_uint16_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bfloat16_to_uint32_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i32 @bfloat16_to_uint32_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bfloat16_to_uint64_round_to_zero(i16 noundef zeroext %a, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call i64 @bfloat16_to_uint64_scalbn(i16 noundef zeroext %a, i8 noundef zeroext 3, i32 noundef 0, ptr noundef %s)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int64_to_float16_scalbn(i64 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p, i8 0, i64 16, i1 false)
  %cmp.i = icmp eq i64 %a, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %entry
  store i8 1, ptr %p, align 8
  br label %parts64_sint_to_float.exit

if.end.i:                                         ; preds = %entry
  store i8 2, ptr %p, align 8
  %cmp2.i = icmp slt i64 %a, 0
  br i1 %cmp2.i, label %if.then3.i, label %if.end4.i

if.then3.i:                                       ; preds = %if.end.i
  %sub.i = sub i64 0, %a
  %sign.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 1, ptr %sign.i, align 1
  br label %if.end4.i

if.end4.i:                                        ; preds = %if.then3.i, %if.end.i
  %f.0.i = phi i64 [ %sub.i, %if.then3.i ], [ %a, %if.end.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i, i1 false), !range !5
  %cast.i.i = trunc i64 %0 to i32
  %cond.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond11.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %reass.sub.i = add nsw i32 %cond11.i, 63
  %add.i = sub nsw i32 %reass.sub.i, %cast.i.i
  %exp.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %add.i, ptr %exp.i, align 4
  %shl.i = shl i64 %f.0.i, %0
  %1 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i, ptr %1, align 8
  br label %parts64_sint_to_float.exit

parts64_sint_to_float.exit:                       ; preds = %if.then.i, %if.end4.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int32_to_float16_scalbn(i32 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i32 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i32 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_float16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i32 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond11.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = add nsw i32 %cond11.i.i, 63
  %add.i.i = sub nsw i32 %reass.sub.i.i, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_float16_scalbn.exit

int64_to_float16_scalbn.exit:                     ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i.i, 15
  %exp.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i.i = or disjoint i64 %shl.i.i.i.i.i, %and8.i.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i.i = or disjoint i64 %or.i.i.i.i.i, %shl77.i9.i.i.i.i
  %conv.i.i.i.i = trunc i64 %or.i10.i.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int16_to_float16_scalbn(i16 noundef signext %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i16 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i16 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_float16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i16 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond11.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = add nsw i32 %cond11.i.i, 63
  %add.i.i = sub nsw i32 %reass.sub.i.i, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_float16_scalbn.exit

int64_to_float16_scalbn.exit:                     ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i.i, 15
  %exp.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i.i = or disjoint i64 %shl.i.i.i.i.i, %and8.i.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i.i = or disjoint i64 %or.i.i.i.i.i, %shl77.i9.i.i.i.i
  %conv.i.i.i.i = trunc i64 %or.i10.i.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int64_to_float16(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i64 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_float16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i64 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub i64 0, %a
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %a, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %add.i.i = sub nuw nsw i32 63, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_float16_scalbn.exit

int64_to_float16_scalbn.exit:                     ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i.i, 15
  %exp.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i.i = or disjoint i64 %shl.i.i.i.i.i, %and8.i.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i.i = or disjoint i64 %or.i.i.i.i.i, %shl77.i9.i.i.i.i
  %conv.i.i.i.i = trunc i64 %or.i10.i.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int32_to_float16(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i32 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i32 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_float16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i32 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %add.i.i = sub nsw i32 63, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_float16_scalbn.exit

int64_to_float16_scalbn.exit:                     ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i.i, 15
  %exp.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i.i = or disjoint i64 %shl.i.i.i.i.i, %and8.i.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i.i = or disjoint i64 %or.i.i.i.i.i, %shl77.i9.i.i.i.i
  %conv.i.i.i.i = trunc i64 %or.i10.i.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int16_to_float16(i16 noundef signext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i16 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i16 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_float16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i16 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %add.i.i = sub nsw i32 63, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_float16_scalbn.exit

int64_to_float16_scalbn.exit:                     ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i.i, 15
  %exp.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i.i = or disjoint i64 %shl.i.i.i.i.i, %and8.i.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i.i = or disjoint i64 %or.i.i.i.i.i, %shl77.i9.i.i.i.i
  %conv.i.i.i.i = trunc i64 %or.i10.i.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int8_to_float16(i8 noundef signext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i8 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i8 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_float16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i8 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %add.i.i = sub nsw i32 63, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_float16_scalbn.exit

int64_to_float16_scalbn.exit:                     ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i.i, 15
  %exp.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i.i = or disjoint i64 %shl.i.i.i.i.i, %and8.i.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i.i = or disjoint i64 %or.i.i.i.i.i, %shl77.i9.i.i.i.i
  %conv.i.i.i.i = trunc i64 %or.i10.i.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @int64_to_float32_scalbn(i64 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %cmp = icmp eq i32 %scale, 0
  br i1 %cmp, label %land.lhs.true, label %entry.split

entry.split:                                      ; preds = %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p, i8 0, i64 16, i1 false)
  %cmp.i = icmp eq i64 %a, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %entry.split
  store i8 1, ptr %p, align 8
  br label %if.end

if.end.i:                                         ; preds = %entry.split
  store i8 2, ptr %p, align 8
  %cmp2.i = icmp slt i64 %a, 0
  br i1 %cmp2.i, label %if.then3.i, label %if.end4.i

if.then3.i:                                       ; preds = %if.end.i
  %sub.i = sub i64 0, %a
  %sign.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 1, ptr %sign.i, align 1
  br label %if.end4.i

if.end4.i:                                        ; preds = %if.then3.i, %if.end.i
  %f.0.i = phi i64 [ %sub.i, %if.then3.i ], [ %a, %if.end.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i, i1 false), !range !5
  %cast.i.i = trunc i64 %0 to i32
  %cond.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond11.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %reass.sub.i = add nsw i32 %cond11.i, 63
  %add.i = sub nsw i32 %reass.sub.i, %cast.i.i
  %exp.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %add.i, ptr %exp.i, align 4
  %shl.i = shl i64 %f.0.i, %0
  %1 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i, ptr %1, align 8
  br label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load i16, ptr %status, align 2
  %3 = and i16 %2, 16
  %tobool.not.i = icmp eq i16 %3, 0
  br i1 %tobool.not.i, label %land.lhs.true.split, label %can_use_fpu.exit

can_use_fpu.exit:                                 ; preds = %land.lhs.true
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %4 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp.i5 = icmp eq i8 %4, 0
  br i1 %cmp.i5, label %if.then, label %land.lhs.true.split

land.lhs.true.split:                              ; preds = %land.lhs.true, %can_use_fpu.exit
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p, i8 0, i64 16, i1 false)
  %cmp.i6 = icmp eq i64 %a, 0
  br i1 %cmp.i6, label %if.then.i18, label %if.end.i7

if.then.i18:                                      ; preds = %land.lhs.true.split
  store i8 1, ptr %p, align 8
  br label %if.end

if.end.i7:                                        ; preds = %land.lhs.true.split
  store i8 2, ptr %p, align 8
  %cmp2.i8 = icmp slt i64 %a, 0
  br i1 %cmp2.i8, label %if.then3.i15, label %if.end4.i9

if.then3.i15:                                     ; preds = %if.end.i7
  %sub.i16 = sub i64 0, %a
  %sign.i17 = getelementptr inbounds i8, ptr %p, i64 1
  store i8 1, ptr %sign.i17, align 1
  br label %if.end4.i9

if.end4.i9:                                       ; preds = %if.then3.i15, %if.end.i7
  %f.0.i10 = phi i64 [ %sub.i16, %if.then3.i15 ], [ %a, %if.end.i7 ]
  %5 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i10, i1 false), !range !5
  %cast.i.i11 = trunc i64 %5 to i32
  %add.i12 = sub nuw nsw i32 63, %cast.i.i11
  %exp.i13 = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %add.i12, ptr %exp.i13, align 4
  %shl.i14 = shl i64 %f.0.i10, %5
  %6 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i14, ptr %6, align 8
  br label %if.end

if.then:                                          ; preds = %can_use_fpu.exit
  %conv3 = sitofp i64 %a to float
  %7 = bitcast float %conv3 to i32
  br label %return

if.end:                                           ; preds = %if.end4.i9, %if.then.i18, %if.end4.i, %if.then.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float32_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %p, i64 1
  %8 = load i8, ptr %sign.i.i.i, align 1
  %conv.i.i.i = zext i8 %8 to i64
  %shl.i.i.i = shl nuw nsw i64 %conv.i.i.i, 31
  %exp.i.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %9 = load i32, ptr %exp.i.i.i, align 4
  %10 = shl i32 %9, 23
  %11 = and i32 %10, 2139095040
  %and8.i.i.i = zext nneg i32 %11 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i, %and8.i.i.i
  %12 = getelementptr inbounds i8, ptr %p, i64 8
  %13 = load i64, ptr %12, align 8
  %shl77.i9.i.i = and i64 %13, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %7, %if.then ], [ %conv.i.i, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @int32_to_float32_scalbn(i32 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %conv = sext i32 %a to i64
  %call = tail call i32 @int64_to_float32_scalbn(i64 noundef %conv, i32 noundef %scale, ptr noundef %status)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @int16_to_float32_scalbn(i16 noundef signext %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %conv = sext i16 %a to i64
  %call = tail call i32 @int64_to_float32_scalbn(i64 noundef %conv, i32 noundef %scale, ptr noundef %status)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @int64_to_float32(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %0 = load i16, ptr %status, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %2, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i64 %a, 0
  br i1 %cmp.i6.i, label %if.then.i18.i, label %if.end.i7.i

if.then.i18.i:                                    ; preds = %land.lhs.true.split.i
  store i8 1, ptr %p.i, align 8
  br label %if.end.i

if.end.i7.i:                                      ; preds = %land.lhs.true.split.i
  store i8 2, ptr %p.i, align 8
  %cmp2.i8.i = icmp slt i64 %a, 0
  br i1 %cmp2.i8.i, label %if.then3.i15.i, label %if.end4.i9.i

if.then3.i15.i:                                   ; preds = %if.end.i7.i
  %sub.i16.i = sub i64 0, %a
  %sign.i17.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i17.i, align 1
  br label %if.end4.i9.i

if.end4.i9.i:                                     ; preds = %if.then3.i15.i, %if.end.i7.i
  %f.0.i10.i = phi i64 [ %sub.i16.i, %if.then3.i15.i ], [ %a, %if.end.i7.i ]
  %3 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i10.i, i1 false), !range !5
  %cast.i.i11.i = trunc i64 %3 to i32
  %add.i12.i = sub nuw nsw i32 63, %cast.i.i11.i
  %exp.i13.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i12.i, ptr %exp.i13.i, align 4
  %shl.i14.i = shl i64 %f.0.i10.i, %3
  %4 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i14.i, ptr %4, align 8
  br label %if.end.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = sitofp i64 %a to float
  %5 = bitcast float %conv3.i to i32
  br label %int64_to_float32_scalbn.exit

if.end.i:                                         ; preds = %if.end4.i9.i, %if.then.i18.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %status, ptr noundef nonnull @float32_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %6 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %6 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 31
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %7 = load i32, ptr %exp.i.i.i.i, align 4
  %8 = shl i32 %7, 23
  %9 = and i32 %8, 2139095040
  %and8.i.i.i.i = zext nneg i32 %9 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %10 = getelementptr inbounds i8, ptr %p.i, i64 8
  %11 = load i64, ptr %10, align 8
  %shl77.i9.i.i.i = and i64 %11, 8388607
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i32
  br label %int64_to_float32_scalbn.exit

int64_to_float32_scalbn.exit:                     ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i32 [ %5, %if.then.i ], [ %conv.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @int32_to_float32(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i32 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %0 = load i16, ptr %status, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %2, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i32 %a, 0
  br i1 %cmp.i6.i, label %if.then.i18.i, label %if.end.i7.i

if.then.i18.i:                                    ; preds = %land.lhs.true.split.i
  store i8 1, ptr %p.i, align 8
  br label %if.end.i

if.end.i7.i:                                      ; preds = %land.lhs.true.split.i
  store i8 2, ptr %p.i, align 8
  %cmp2.i8.i = icmp slt i32 %a, 0
  br i1 %cmp2.i8.i, label %if.then3.i15.i, label %if.end4.i9.i

if.then3.i15.i:                                   ; preds = %if.end.i7.i
  %sub.i16.i = sub nsw i64 0, %conv
  %sign.i17.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i17.i, align 1
  br label %if.end4.i9.i

if.end4.i9.i:                                     ; preds = %if.then3.i15.i, %if.end.i7.i
  %f.0.i10.i = phi i64 [ %sub.i16.i, %if.then3.i15.i ], [ %conv, %if.end.i7.i ]
  %3 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i10.i, i1 false), !range !5
  %cast.i.i11.i = trunc i64 %3 to i32
  %add.i12.i = sub nuw nsw i32 63, %cast.i.i11.i
  %exp.i13.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i12.i, ptr %exp.i13.i, align 4
  %shl.i14.i = shl i64 %f.0.i10.i, %3
  %4 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i14.i, ptr %4, align 8
  br label %if.end.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = sitofp i32 %a to float
  %5 = bitcast float %conv3.i to i32
  br label %int64_to_float32_scalbn.exit

if.end.i:                                         ; preds = %if.end4.i9.i, %if.then.i18.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %status, ptr noundef nonnull @float32_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %6 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %6 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 31
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %7 = load i32, ptr %exp.i.i.i.i, align 4
  %8 = shl i32 %7, 23
  %9 = and i32 %8, 2139095040
  %and8.i.i.i.i = zext nneg i32 %9 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %10 = getelementptr inbounds i8, ptr %p.i, i64 8
  %11 = load i64, ptr %10, align 8
  %shl77.i9.i.i.i = and i64 %11, 8388607
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i32
  br label %int64_to_float32_scalbn.exit

int64_to_float32_scalbn.exit:                     ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i32 [ %5, %if.then.i ], [ %conv.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @int16_to_float32(i16 noundef signext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i16 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %0 = load i16, ptr %status, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %2, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i16 %a, 0
  br i1 %cmp.i6.i, label %if.then.i18.i, label %if.end.i7.i

if.then.i18.i:                                    ; preds = %land.lhs.true.split.i
  store i8 1, ptr %p.i, align 8
  br label %if.end.i

if.end.i7.i:                                      ; preds = %land.lhs.true.split.i
  store i8 2, ptr %p.i, align 8
  %cmp2.i8.i = icmp slt i16 %a, 0
  br i1 %cmp2.i8.i, label %if.then3.i15.i, label %if.end4.i9.i

if.then3.i15.i:                                   ; preds = %if.end.i7.i
  %sub.i16.i = sub nsw i64 0, %conv
  %sign.i17.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i17.i, align 1
  br label %if.end4.i9.i

if.end4.i9.i:                                     ; preds = %if.then3.i15.i, %if.end.i7.i
  %f.0.i10.i = phi i64 [ %sub.i16.i, %if.then3.i15.i ], [ %conv, %if.end.i7.i ]
  %3 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i10.i, i1 false), !range !5
  %cast.i.i11.i = trunc i64 %3 to i32
  %add.i12.i = sub nuw nsw i32 63, %cast.i.i11.i
  %exp.i13.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i12.i, ptr %exp.i13.i, align 4
  %shl.i14.i = shl i64 %f.0.i10.i, %3
  %4 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i14.i, ptr %4, align 8
  br label %if.end.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = sitofp i16 %a to float
  %5 = bitcast float %conv3.i to i32
  br label %int64_to_float32_scalbn.exit

if.end.i:                                         ; preds = %if.end4.i9.i, %if.then.i18.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %status, ptr noundef nonnull @float32_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %6 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %6 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 31
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %7 = load i32, ptr %exp.i.i.i.i, align 4
  %8 = shl i32 %7, 23
  %9 = and i32 %8, 2139095040
  %and8.i.i.i.i = zext nneg i32 %9 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %10 = getelementptr inbounds i8, ptr %p.i, i64 8
  %11 = load i64, ptr %10, align 8
  %shl77.i9.i.i.i = and i64 %11, 8388607
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i32
  br label %int64_to_float32_scalbn.exit

int64_to_float32_scalbn.exit:                     ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i32 [ %5, %if.then.i ], [ %conv.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @int64_to_float64_scalbn(i64 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %cmp = icmp eq i32 %scale, 0
  br i1 %cmp, label %land.lhs.true, label %entry.split

entry.split:                                      ; preds = %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p, i8 0, i64 16, i1 false)
  %cmp.i = icmp eq i64 %a, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %entry.split
  store i8 1, ptr %p, align 8
  br label %if.end

if.end.i:                                         ; preds = %entry.split
  store i8 2, ptr %p, align 8
  %cmp2.i = icmp slt i64 %a, 0
  br i1 %cmp2.i, label %if.then3.i, label %if.end4.i

if.then3.i:                                       ; preds = %if.end.i
  %sub.i = sub i64 0, %a
  %sign.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 1, ptr %sign.i, align 1
  br label %if.end4.i

if.end4.i:                                        ; preds = %if.then3.i, %if.end.i
  %f.0.i = phi i64 [ %sub.i, %if.then3.i ], [ %a, %if.end.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i, i1 false), !range !5
  %cast.i.i = trunc i64 %0 to i32
  %cond.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond11.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %reass.sub.i = add nsw i32 %cond11.i, 63
  %add.i = sub nsw i32 %reass.sub.i, %cast.i.i
  %exp.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %add.i, ptr %exp.i, align 4
  %shl.i = shl i64 %f.0.i, %0
  %1 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i, ptr %1, align 8
  br label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load i16, ptr %status, align 2
  %3 = and i16 %2, 16
  %tobool.not.i = icmp eq i16 %3, 0
  br i1 %tobool.not.i, label %land.lhs.true.split, label %can_use_fpu.exit

can_use_fpu.exit:                                 ; preds = %land.lhs.true
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %4 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp.i5 = icmp eq i8 %4, 0
  br i1 %cmp.i5, label %if.then, label %land.lhs.true.split

land.lhs.true.split:                              ; preds = %land.lhs.true, %can_use_fpu.exit
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p, i8 0, i64 16, i1 false)
  %cmp.i6 = icmp eq i64 %a, 0
  br i1 %cmp.i6, label %if.then.i18, label %if.end.i7

if.then.i18:                                      ; preds = %land.lhs.true.split
  store i8 1, ptr %p, align 8
  br label %if.end

if.end.i7:                                        ; preds = %land.lhs.true.split
  store i8 2, ptr %p, align 8
  %cmp2.i8 = icmp slt i64 %a, 0
  br i1 %cmp2.i8, label %if.then3.i15, label %if.end4.i9

if.then3.i15:                                     ; preds = %if.end.i7
  %sub.i16 = sub i64 0, %a
  %sign.i17 = getelementptr inbounds i8, ptr %p, i64 1
  store i8 1, ptr %sign.i17, align 1
  br label %if.end4.i9

if.end4.i9:                                       ; preds = %if.then3.i15, %if.end.i7
  %f.0.i10 = phi i64 [ %sub.i16, %if.then3.i15 ], [ %a, %if.end.i7 ]
  %5 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i10, i1 false), !range !5
  %cast.i.i11 = trunc i64 %5 to i32
  %add.i12 = sub nuw nsw i32 63, %cast.i.i11
  %exp.i13 = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %add.i12, ptr %exp.i13, align 4
  %shl.i14 = shl i64 %f.0.i10, %5
  %6 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i14, ptr %6, align 8
  br label %if.end

if.then:                                          ; preds = %can_use_fpu.exit
  %conv3 = sitofp i64 %a to double
  %7 = bitcast double %conv3 to i64
  br label %return

if.end:                                           ; preds = %if.end4.i9, %if.then.i18, %if.end4.i, %if.then.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float64_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %p, i64 1
  %8 = load i8, ptr %sign.i.i.i, align 1
  %9 = and i8 %8, 1
  %conv.i.i.i = zext nneg i8 %9 to i64
  %shl.i.i.i = shl nuw i64 %conv.i.i.i, 63
  %exp.i.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %10 = load i32, ptr %exp.i.i.i, align 4
  %11 = and i32 %10, 2047
  %shl77.i.i.i = zext nneg i32 %11 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i.i
  %12 = getelementptr inbounds i8, ptr %p, i64 8
  %13 = load i64, ptr %12, align 8
  %shl77.i9.i.i = and i64 %13, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %7, %if.then ], [ %or.i10.i.i, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @int32_to_float64_scalbn(i32 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %conv = sext i32 %a to i64
  %call = tail call i64 @int64_to_float64_scalbn(i64 noundef %conv, i32 noundef %scale, ptr noundef %status)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @int16_to_float64_scalbn(i16 noundef signext %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %conv = sext i16 %a to i64
  %call = tail call i64 @int64_to_float64_scalbn(i64 noundef %conv, i32 noundef %scale, ptr noundef %status)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @int64_to_float64(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %0 = load i16, ptr %status, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %2, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i64 %a, 0
  br i1 %cmp.i6.i, label %if.then.i18.i, label %if.end.i7.i

if.then.i18.i:                                    ; preds = %land.lhs.true.split.i
  store i8 1, ptr %p.i, align 8
  br label %if.end.i

if.end.i7.i:                                      ; preds = %land.lhs.true.split.i
  store i8 2, ptr %p.i, align 8
  %cmp2.i8.i = icmp slt i64 %a, 0
  br i1 %cmp2.i8.i, label %if.then3.i15.i, label %if.end4.i9.i

if.then3.i15.i:                                   ; preds = %if.end.i7.i
  %sub.i16.i = sub i64 0, %a
  %sign.i17.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i17.i, align 1
  br label %if.end4.i9.i

if.end4.i9.i:                                     ; preds = %if.then3.i15.i, %if.end.i7.i
  %f.0.i10.i = phi i64 [ %sub.i16.i, %if.then3.i15.i ], [ %a, %if.end.i7.i ]
  %3 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i10.i, i1 false), !range !5
  %cast.i.i11.i = trunc i64 %3 to i32
  %add.i12.i = sub nuw nsw i32 63, %cast.i.i11.i
  %exp.i13.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i12.i, ptr %exp.i13.i, align 4
  %shl.i14.i = shl i64 %f.0.i10.i, %3
  %4 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i14.i, ptr %4, align 8
  br label %if.end.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = sitofp i64 %a to double
  %5 = bitcast double %conv3.i to i64
  br label %int64_to_float64_scalbn.exit

if.end.i:                                         ; preds = %if.end4.i9.i, %if.then.i18.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %status, ptr noundef nonnull @float64_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %6 = load i8, ptr %sign.i.i.i.i, align 1
  %7 = and i8 %6, 1
  %conv.i.i.i.i = zext nneg i8 %7 to i64
  %shl.i.i.i.i = shl nuw i64 %conv.i.i.i.i, 63
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %8 = load i32, ptr %exp.i.i.i.i, align 4
  %9 = and i32 %8, 2047
  %shl77.i.i.i.i = zext nneg i32 %9 to i64
  %and8.i.i.i.i = shl nuw nsw i64 %shl77.i.i.i.i, 52
  %or.i.i.i.i = or disjoint i64 %and8.i.i.i.i, %shl.i.i.i.i
  %10 = getelementptr inbounds i8, ptr %p.i, i64 8
  %11 = load i64, ptr %10, align 8
  %shl77.i9.i.i.i = and i64 %11, 4503599627370495
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  br label %int64_to_float64_scalbn.exit

int64_to_float64_scalbn.exit:                     ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i64 [ %5, %if.then.i ], [ %or.i10.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @int32_to_float64(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i32 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %0 = load i16, ptr %status, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %2, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i32 %a, 0
  br i1 %cmp.i6.i, label %if.then.i18.i, label %if.end.i7.i

if.then.i18.i:                                    ; preds = %land.lhs.true.split.i
  store i8 1, ptr %p.i, align 8
  br label %if.end.i

if.end.i7.i:                                      ; preds = %land.lhs.true.split.i
  store i8 2, ptr %p.i, align 8
  %cmp2.i8.i = icmp slt i32 %a, 0
  br i1 %cmp2.i8.i, label %if.then3.i15.i, label %if.end4.i9.i

if.then3.i15.i:                                   ; preds = %if.end.i7.i
  %sub.i16.i = sub nsw i64 0, %conv
  %sign.i17.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i17.i, align 1
  br label %if.end4.i9.i

if.end4.i9.i:                                     ; preds = %if.then3.i15.i, %if.end.i7.i
  %f.0.i10.i = phi i64 [ %sub.i16.i, %if.then3.i15.i ], [ %conv, %if.end.i7.i ]
  %3 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i10.i, i1 false), !range !5
  %cast.i.i11.i = trunc i64 %3 to i32
  %add.i12.i = sub nuw nsw i32 63, %cast.i.i11.i
  %exp.i13.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i12.i, ptr %exp.i13.i, align 4
  %shl.i14.i = shl i64 %f.0.i10.i, %3
  %4 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i14.i, ptr %4, align 8
  br label %if.end.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = sitofp i32 %a to double
  %5 = bitcast double %conv3.i to i64
  br label %int64_to_float64_scalbn.exit

if.end.i:                                         ; preds = %if.end4.i9.i, %if.then.i18.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %status, ptr noundef nonnull @float64_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %6 = load i8, ptr %sign.i.i.i.i, align 1
  %7 = and i8 %6, 1
  %conv.i.i.i.i = zext nneg i8 %7 to i64
  %shl.i.i.i.i = shl nuw i64 %conv.i.i.i.i, 63
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %8 = load i32, ptr %exp.i.i.i.i, align 4
  %9 = and i32 %8, 2047
  %shl77.i.i.i.i = zext nneg i32 %9 to i64
  %and8.i.i.i.i = shl nuw nsw i64 %shl77.i.i.i.i, 52
  %or.i.i.i.i = or disjoint i64 %and8.i.i.i.i, %shl.i.i.i.i
  %10 = getelementptr inbounds i8, ptr %p.i, i64 8
  %11 = load i64, ptr %10, align 8
  %shl77.i9.i.i.i = and i64 %11, 4503599627370495
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  br label %int64_to_float64_scalbn.exit

int64_to_float64_scalbn.exit:                     ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i64 [ %5, %if.then.i ], [ %or.i10.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @int16_to_float64(i16 noundef signext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i16 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %0 = load i16, ptr %status, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %2, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i16 %a, 0
  br i1 %cmp.i6.i, label %if.then.i18.i, label %if.end.i7.i

if.then.i18.i:                                    ; preds = %land.lhs.true.split.i
  store i8 1, ptr %p.i, align 8
  br label %if.end.i

if.end.i7.i:                                      ; preds = %land.lhs.true.split.i
  store i8 2, ptr %p.i, align 8
  %cmp2.i8.i = icmp slt i16 %a, 0
  br i1 %cmp2.i8.i, label %if.then3.i15.i, label %if.end4.i9.i

if.then3.i15.i:                                   ; preds = %if.end.i7.i
  %sub.i16.i = sub nsw i64 0, %conv
  %sign.i17.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i17.i, align 1
  br label %if.end4.i9.i

if.end4.i9.i:                                     ; preds = %if.then3.i15.i, %if.end.i7.i
  %f.0.i10.i = phi i64 [ %sub.i16.i, %if.then3.i15.i ], [ %conv, %if.end.i7.i ]
  %3 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i10.i, i1 false), !range !5
  %cast.i.i11.i = trunc i64 %3 to i32
  %add.i12.i = sub nuw nsw i32 63, %cast.i.i11.i
  %exp.i13.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i12.i, ptr %exp.i13.i, align 4
  %shl.i14.i = shl i64 %f.0.i10.i, %3
  %4 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i14.i, ptr %4, align 8
  br label %if.end.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = sitofp i16 %a to double
  %5 = bitcast double %conv3.i to i64
  br label %int64_to_float64_scalbn.exit

if.end.i:                                         ; preds = %if.end4.i9.i, %if.then.i18.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %status, ptr noundef nonnull @float64_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %6 = load i8, ptr %sign.i.i.i.i, align 1
  %7 = and i8 %6, 1
  %conv.i.i.i.i = zext nneg i8 %7 to i64
  %shl.i.i.i.i = shl nuw i64 %conv.i.i.i.i, 63
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %8 = load i32, ptr %exp.i.i.i.i, align 4
  %9 = and i32 %8, 2047
  %shl77.i.i.i.i = zext nneg i32 %9 to i64
  %and8.i.i.i.i = shl nuw nsw i64 %shl77.i.i.i.i, 52
  %or.i.i.i.i = or disjoint i64 %and8.i.i.i.i, %shl.i.i.i.i
  %10 = getelementptr inbounds i8, ptr %p.i, i64 8
  %11 = load i64, ptr %10, align 8
  %shl77.i9.i.i.i = and i64 %11, 4503599627370495
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  br label %int64_to_float64_scalbn.exit

int64_to_float64_scalbn.exit:                     ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i64 [ %5, %if.then.i ], [ %or.i10.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int64_to_bfloat16_scalbn(i64 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p, i8 0, i64 16, i1 false)
  %cmp.i = icmp eq i64 %a, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %entry
  store i8 1, ptr %p, align 8
  br label %parts64_sint_to_float.exit

if.end.i:                                         ; preds = %entry
  store i8 2, ptr %p, align 8
  %cmp2.i = icmp slt i64 %a, 0
  br i1 %cmp2.i, label %if.then3.i, label %if.end4.i

if.then3.i:                                       ; preds = %if.end.i
  %sub.i = sub i64 0, %a
  %sign.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 1, ptr %sign.i, align 1
  br label %if.end4.i

if.end4.i:                                        ; preds = %if.then3.i, %if.end.i
  %f.0.i = phi i64 [ %sub.i, %if.then3.i ], [ %a, %if.end.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i, i1 false), !range !5
  %cast.i.i = trunc i64 %0 to i32
  %cond.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond11.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %reass.sub.i = add nsw i32 %cond11.i, 63
  %add.i = sub nsw i32 %reass.sub.i, %cast.i.i
  %exp.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %add.i, ptr %exp.i, align 4
  %shl.i = shl i64 %f.0.i, %0
  %1 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i, ptr %1, align 8
  br label %parts64_sint_to_float.exit

parts64_sint_to_float.exit:                       ; preds = %if.then.i, %if.end4.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %p, i64 1
  %2 = load i8, ptr %sign.i.i.i, align 1
  %conv.i.i.i = zext i8 %2 to i64
  %shl.i.i.i = shl nuw nsw i64 %conv.i.i.i, 15
  %exp.i.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %3 = load i32, ptr %exp.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i, %and8.i.i.i
  %6 = getelementptr inbounds i8, ptr %p, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i = and i64 %7, 127
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i16
  ret i16 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int32_to_bfloat16_scalbn(i32 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i32 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i32 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_bfloat16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i32 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond11.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = add nsw i32 %cond11.i.i, 63
  %add.i.i = sub nsw i32 %reass.sub.i.i, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_bfloat16_scalbn.exit

int64_to_bfloat16_scalbn.exit:                    ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int16_to_bfloat16_scalbn(i16 noundef signext %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i16 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i16 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_bfloat16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i16 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond11.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = add nsw i32 %cond11.i.i, 63
  %add.i.i = sub nsw i32 %reass.sub.i.i, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_bfloat16_scalbn.exit

int64_to_bfloat16_scalbn.exit:                    ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int8_to_bfloat16_scalbn(i8 noundef signext %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i8 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i8 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_bfloat16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i8 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond11.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = add nsw i32 %cond11.i.i, 63
  %add.i.i = sub nsw i32 %reass.sub.i.i, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_bfloat16_scalbn.exit

int64_to_bfloat16_scalbn.exit:                    ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int64_to_bfloat16(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i64 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_bfloat16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i64 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub i64 0, %a
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %a, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %add.i.i = sub nuw nsw i32 63, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_bfloat16_scalbn.exit

int64_to_bfloat16_scalbn.exit:                    ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int32_to_bfloat16(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i32 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i32 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_bfloat16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i32 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %add.i.i = sub nsw i32 63, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_bfloat16_scalbn.exit

int64_to_bfloat16_scalbn.exit:                    ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int16_to_bfloat16(i16 noundef signext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i16 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i16 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_bfloat16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i16 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %add.i.i = sub nsw i32 63, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_bfloat16_scalbn.exit

int64_to_bfloat16_scalbn.exit:                    ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @int8_to_bfloat16(i8 noundef signext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = sext i8 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i8 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_bfloat16_scalbn.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i8 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %add.i.i = sub nsw i32 63, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %int64_to_bfloat16_scalbn.exit

int64_to_bfloat16_scalbn.exit:                    ; preds = %if.then.i.i, %if.end4.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @int128_to_float128(i64 noundef %a.coerce0, i64 noundef %a.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %p, i8 0, i64 24, i1 false)
  %a.sroa.2.0.insert.ext.i = zext i64 %a.coerce1 to i128
  %a.sroa.2.0.insert.shift.i = shl nuw i128 %a.sroa.2.0.insert.ext.i, 64
  %a.sroa.0.0.insert.ext.i = zext i64 %a.coerce0 to i128
  %a.sroa.0.0.insert.insert.i = or disjoint i128 %a.sroa.2.0.insert.shift.i, %a.sroa.0.0.insert.ext.i
  %cmp.i.not = icmp eq i128 %a.sroa.0.0.insert.insert.i, 0
  br i1 %cmp.i.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i8 2, ptr %p, align 8
  %cmp.i15 = icmp sgt i64 %a.coerce1, -1
  br i1 %cmp.i15, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then
  %sign = getelementptr inbounds i8, ptr %p, i64 1
  store i8 1, ptr %sign, align 1
  %a.coerce1.neg.i = sub i64 0, %a.coerce1
  %a.coerce1.neg.z.i = zext i64 %a.coerce1.neg.i to i128
  %a.sroa.2.0.insert.shift.neg.i = shl nuw i128 %a.coerce1.neg.z.i, 64
  %a.sroa.0.0.insert.insert.neg.i = sub nuw i128 %a.sroa.2.0.insert.shift.neg.i, %a.sroa.0.0.insert.ext.i
  %retval.sroa.0.0.extract.trunc.i = trunc i128 %a.sroa.0.0.insert.insert.neg.i to i64
  %retval.sroa.2.0.extract.shift.i = lshr i128 %a.sroa.0.0.insert.insert.neg.i, 64
  %retval.sroa.2.0.extract.trunc.i = trunc i128 %retval.sroa.2.0.extract.shift.i to i64
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %a.sroa.0.0.insert.insert.i21.pre-phi = phi i128 [ %a.sroa.0.0.insert.insert.neg.i, %if.then4 ], [ %a.sroa.0.0.insert.insert.i, %if.then ]
  %a.addr.0.off0 = phi i64 [ %retval.sroa.0.0.extract.trunc.i, %if.then4 ], [ %a.coerce0, %if.then ]
  %a.addr.0.off64 = phi i64 [ %retval.sroa.2.0.extract.trunc.i, %if.then4 ], [ %a.coerce1, %if.then ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %a.addr.0.off64, i1 false), !range !5
  %cast.i = trunc i64 %0 to i32
  %cmp = icmp eq i32 %cast.i, 64
  %1 = tail call i64 @llvm.ctlz.i64(i64 %a.addr.0.off0, i1 false), !range !5
  %cast.i17 = trunc i64 %1 to i32
  %add = add nuw nsw i32 %cast.i17, 64
  %shift.0 = select i1 %cmp, i32 %add, i32 %cast.i
  %sub = sub nsw i32 127, %shift.0
  %exp = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %sub, ptr %exp, align 4
  %sh_prom.i = zext nneg i32 %shift.0 to i128
  %shl.i = shl i128 %a.sroa.0.0.insert.insert.i21.pre-phi, %sh_prom.i
  %retval.sroa.0.0.extract.trunc.i22 = trunc i128 %shl.i to i64
  %retval.sroa.2.0.extract.shift.i23 = lshr i128 %shl.i, 64
  %retval.sroa.2.0.extract.trunc.i24 = trunc i128 %retval.sroa.2.0.extract.shift.i23 to i64
  %frac_hi = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %retval.sroa.2.0.extract.trunc.i24, ptr %frac_hi, align 8
  %frac_lo = getelementptr inbounds i8, ptr %p, i64 16
  store i64 %retval.sroa.0.0.extract.trunc.i22, ptr %frac_lo, align 8
  br label %if.end24

if.else:                                          ; preds = %entry
  store i8 1, ptr %p, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.else, %if.end
  %call25 = call fastcc { i64, i64 } @float128_round_pack_canonical(ptr noundef nonnull %p, ptr noundef %status)
  ret { i64, i64 } %call25
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @int64_to_float128(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %p, i8 0, i64 24, i1 false)
  %cmp.i = icmp eq i64 %a, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %entry
  store i8 1, ptr %p, align 8
  br label %parts128_sint_to_float.exit

if.end.i:                                         ; preds = %entry
  store i8 2, ptr %p, align 8
  %cmp2.i = icmp slt i64 %a, 0
  br i1 %cmp2.i, label %if.then3.i, label %if.end4.i

if.then3.i:                                       ; preds = %if.end.i
  %sub.i = sub i64 0, %a
  %sign.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 1, ptr %sign.i, align 1
  br label %if.end4.i

if.end4.i:                                        ; preds = %if.then3.i, %if.end.i
  %f.0.i = phi i64 [ %sub.i, %if.then3.i ], [ %a, %if.end.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i, i1 false), !range !5
  %cast.i.i = trunc i64 %0 to i32
  %sub12.i = sub nuw nsw i32 63, %cast.i.i
  %exp.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %sub12.i, ptr %exp.i, align 4
  %shl.i = shl i64 %f.0.i, %0
  %frac_hi.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i, ptr %frac_hi.i, align 8
  br label %parts128_sint_to_float.exit

parts128_sint_to_float.exit:                      ; preds = %if.then.i, %if.end4.i
  %call = call fastcc { i64, i64 } @float128_round_pack_canonical(ptr noundef nonnull %p, ptr noundef %status)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @int32_to_float128(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts128, align 8
  %conv = sext i32 %a to i64
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %p.i, i8 0, i64 24, i1 false)
  %cmp.i.i = icmp eq i32 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_float128.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i32 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %sub12.i.i = sub nuw nsw i32 63, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %sub12.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %frac_hi.i.i = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %frac_hi.i.i, align 8
  br label %int64_to_float128.exit

int64_to_float128.exit:                           ; preds = %if.then.i.i, %if.end4.i.i
  %call.i = call fastcc { i64, i64 } @float128_round_pack_canonical(ptr noundef nonnull %p.i, ptr noundef %status)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %p.i)
  ret { i64, i64 } %call.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @int64_to_floatx80(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %p, i8 0, i64 24, i1 false)
  %cmp.i = icmp eq i64 %a, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %entry
  store i8 1, ptr %p, align 8
  br label %parts128_sint_to_float.exit

if.end.i:                                         ; preds = %entry
  store i8 2, ptr %p, align 8
  %cmp2.i = icmp slt i64 %a, 0
  br i1 %cmp2.i, label %if.then3.i, label %if.end4.i

if.then3.i:                                       ; preds = %if.end.i
  %sub.i = sub i64 0, %a
  %sign.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 1, ptr %sign.i, align 1
  br label %if.end4.i

if.end4.i:                                        ; preds = %if.then3.i, %if.end.i
  %f.0.i = phi i64 [ %sub.i, %if.then3.i ], [ %a, %if.end.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i, i1 false), !range !5
  %cast.i.i = trunc i64 %0 to i32
  %sub12.i = sub nuw nsw i32 63, %cast.i.i
  %exp.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %sub12.i, ptr %exp.i, align 4
  %shl.i = shl i64 %f.0.i, %0
  %frac_hi.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i, ptr %frac_hi.i, align 8
  br label %parts128_sint_to_float.exit

parts128_sint_to_float.exit:                      ; preds = %if.then.i, %if.end4.i
  %call = call fastcc { i64, i16 } @floatx80_round_pack_canonical(ptr noundef nonnull %p, ptr noundef %status)
  ret { i64, i16 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @int32_to_floatx80(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts128, align 8
  %conv = sext i32 %a to i64
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %p.i, i8 0, i64 24, i1 false)
  %cmp.i.i = icmp eq i32 %a, 0
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %entry
  store i8 1, ptr %p.i, align 8
  br label %int64_to_floatx80.exit

if.end.i.i:                                       ; preds = %entry
  store i8 2, ptr %p.i, align 8
  %cmp2.i.i = icmp slt i32 %a, 0
  br i1 %cmp2.i.i, label %if.then3.i.i, label %if.end4.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  %sub.i.i = sub nsw i64 0, %conv
  %sign.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 1, ptr %sign.i.i, align 1
  br label %if.end4.i.i

if.end4.i.i:                                      ; preds = %if.then3.i.i, %if.end.i.i
  %f.0.i.i = phi i64 [ %sub.i.i, %if.then3.i.i ], [ %conv, %if.end.i.i ]
  %0 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i.i, i1 false), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %sub12.i.i = sub nuw nsw i32 63, %cast.i.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %sub12.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %f.0.i.i, %0
  %frac_hi.i.i = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %frac_hi.i.i, align 8
  br label %int64_to_floatx80.exit

int64_to_floatx80.exit:                           ; preds = %if.then.i.i, %if.end4.i.i
  %call.i = call fastcc { i64, i16 } @floatx80_round_pack_canonical(ptr noundef nonnull %p.i, ptr noundef %status)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %p.i)
  ret { i64, i16 } %call.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint64_to_float16_scalbn(i64 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p, i8 0, i64 16, i1 false)
  %cmp.i = icmp eq i64 %a, 0
  br i1 %cmp.i, label %parts64_uint_to_float.exit, label %if.else.i

if.else.i:                                        ; preds = %entry
  %0 = tail call i64 @llvm.ctlz.i64(i64 %a, i1 true), !range !5
  %cast.i.i = trunc i64 %0 to i32
  %cond.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %reass.sub.i = xor i32 %cast.i.i, 63
  %add.i = add nsw i32 %reass.sub.i, %cond7.i
  %exp.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %add.i, ptr %exp.i, align 4
  %shl.i = shl i64 %a, %0
  %1 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i, ptr %1, align 8
  br label %parts64_uint_to_float.exit

parts64_uint_to_float.exit:                       ; preds = %entry, %if.else.i
  %.sink.i = phi i8 [ 2, %if.else.i ], [ 1, %entry ]
  store i8 %.sink.i, ptr %p, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint32_to_float16_scalbn(i32 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i32 %a, 0
  br i1 %cmp.i.i, label %uint64_to_float16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %conv = zext i32 %a to i64
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %add.i.i = add nsw i32 %reass.sub.i.i, %cond7.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %conv, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_float16_scalbn.exit

uint64_to_float16_scalbn.exit:                    ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i.i, 15
  %exp.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i.i = or disjoint i64 %shl.i.i.i.i.i, %and8.i.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i.i = or disjoint i64 %or.i.i.i.i.i, %shl77.i9.i.i.i.i
  %conv.i.i.i.i = trunc i64 %or.i10.i.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint16_to_float16_scalbn(i16 noundef zeroext %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i16 %a, 0
  br i1 %cmp.i.i, label %uint64_to_float16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %conv = zext i16 %a to i64
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %add.i.i = add nsw i32 %reass.sub.i.i, %cond7.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %conv, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_float16_scalbn.exit

uint64_to_float16_scalbn.exit:                    ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i.i, 15
  %exp.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i.i = or disjoint i64 %shl.i.i.i.i.i, %and8.i.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i.i = or disjoint i64 %or.i.i.i.i.i, %shl77.i9.i.i.i.i
  %conv.i.i.i.i = trunc i64 %or.i10.i.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint64_to_float16(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i64 %a, 0
  br i1 %cmp.i.i, label %uint64_to_float16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %0 = tail call i64 @llvm.ctlz.i64(i64 %a, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %a, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_float16_scalbn.exit

uint64_to_float16_scalbn.exit:                    ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i.i, 15
  %exp.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i.i = or disjoint i64 %shl.i.i.i.i.i, %and8.i.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i.i = or disjoint i64 %or.i.i.i.i.i, %shl77.i9.i.i.i.i
  %conv.i.i.i.i = trunc i64 %or.i10.i.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint32_to_float16(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i32 %a, 0
  br i1 %cmp.i.i, label %uint64_to_float16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %conv = zext i32 %a to i64
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %conv, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_float16_scalbn.exit

uint64_to_float16_scalbn.exit:                    ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i.i, 15
  %exp.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i.i = or disjoint i64 %shl.i.i.i.i.i, %and8.i.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i.i = or disjoint i64 %or.i.i.i.i.i, %shl77.i9.i.i.i.i
  %conv.i.i.i.i = trunc i64 %or.i10.i.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint16_to_float16(i16 noundef zeroext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i16 %a, 0
  br i1 %cmp.i.i, label %uint64_to_float16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %conv = zext i16 %a to i64
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %conv, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_float16_scalbn.exit

uint64_to_float16_scalbn.exit:                    ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i.i, 15
  %exp.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i.i = or disjoint i64 %shl.i.i.i.i.i, %and8.i.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i.i = or disjoint i64 %or.i.i.i.i.i, %shl77.i9.i.i.i.i
  %conv.i.i.i.i = trunc i64 %or.i10.i.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint8_to_float16(i8 noundef zeroext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i8 %a, 0
  br i1 %cmp.i.i, label %uint64_to_float16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %conv = zext i8 %a to i64
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %conv, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_float16_scalbn.exit

uint64_to_float16_scalbn.exit:                    ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i.i, align 1
  %conv.i.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i.i, 15
  %exp.i.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i.i, align 4
  %4 = shl i32 %3, 10
  %5 = and i32 %4, 31744
  %and8.i.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i.i = or disjoint i64 %shl.i.i.i.i.i, %and8.i.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i.i = and i64 %7, 1023
  %or.i10.i.i.i.i = or disjoint i64 %or.i.i.i.i.i, %shl77.i9.i.i.i.i
  %conv.i.i.i.i = trunc i64 %or.i10.i.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @uint64_to_float32_scalbn(i64 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %cmp = icmp eq i32 %scale, 0
  br i1 %cmp, label %land.lhs.true, label %entry.split

entry.split:                                      ; preds = %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p, i8 0, i64 16, i1 false)
  %cmp.i = icmp eq i64 %a, 0
  br i1 %cmp.i, label %if.end, label %if.else.i

if.else.i:                                        ; preds = %entry.split
  %0 = tail call i64 @llvm.ctlz.i64(i64 %a, i1 true), !range !5
  %cast.i.i = trunc i64 %0 to i32
  %cond.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %reass.sub.i = xor i32 %cast.i.i, 63
  %add.i = add nsw i32 %reass.sub.i, %cond7.i
  br label %if.end.sink.split

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr %status, align 2
  %2 = and i16 %1, 16
  %tobool.not.i = icmp eq i16 %2, 0
  br i1 %tobool.not.i, label %land.lhs.true.split, label %can_use_fpu.exit

can_use_fpu.exit:                                 ; preds = %land.lhs.true
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %3 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp.i5 = icmp eq i8 %3, 0
  br i1 %cmp.i5, label %if.then, label %land.lhs.true.split

land.lhs.true.split:                              ; preds = %land.lhs.true, %can_use_fpu.exit
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p, i8 0, i64 16, i1 false)
  %cmp.i6 = icmp eq i64 %a, 0
  br i1 %cmp.i6, label %if.end, label %if.else.i7

if.else.i7:                                       ; preds = %land.lhs.true.split
  %4 = tail call i64 @llvm.ctlz.i64(i64 %a, i1 true), !range !5
  %cast.i.i8 = trunc i64 %4 to i32
  %reass.sub.i9 = xor i32 %cast.i.i8, 63
  br label %if.end.sink.split

if.then:                                          ; preds = %can_use_fpu.exit
  %conv3 = uitofp i64 %a to float
  %5 = bitcast float %conv3 to i32
  br label %return

if.end.sink.split:                                ; preds = %if.else.i, %if.else.i7
  %reass.sub.i9.sink = phi i32 [ %reass.sub.i9, %if.else.i7 ], [ %add.i, %if.else.i ]
  %.sink = phi i64 [ %4, %if.else.i7 ], [ %0, %if.else.i ]
  %exp.i10 = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %reass.sub.i9.sink, ptr %exp.i10, align 4
  %shl.i11 = shl i64 %a, %.sink
  %6 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i11, ptr %6, align 8
  br label %if.end

if.end:                                           ; preds = %if.end.sink.split, %land.lhs.true.split, %entry.split
  %storemerge = phi i8 [ 1, %entry.split ], [ 1, %land.lhs.true.split ], [ 2, %if.end.sink.split ]
  store i8 %storemerge, ptr %p, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float32_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %p, i64 1
  %7 = load i8, ptr %sign.i.i.i, align 1
  %conv.i.i.i = zext i8 %7 to i64
  %shl.i.i.i = shl nuw nsw i64 %conv.i.i.i, 31
  %exp.i.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %8 = load i32, ptr %exp.i.i.i, align 4
  %9 = shl i32 %8, 23
  %10 = and i32 %9, 2139095040
  %and8.i.i.i = zext nneg i32 %10 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i, %and8.i.i.i
  %11 = getelementptr inbounds i8, ptr %p, i64 8
  %12 = load i64, ptr %11, align 8
  %shl77.i9.i.i = and i64 %12, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %5, %if.then ], [ %conv.i.i, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @uint32_to_float32_scalbn(i32 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = zext i32 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %cmp.i = icmp eq i32 %scale, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %entry.split.i

entry.split.i:                                    ; preds = %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i32 %a, 0
  br i1 %cmp.i.i, label %if.end.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry.split.i
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %add.i.i = add nsw i32 %reass.sub.i.i, %cond7.i.i
  br label %if.end.sink.split.i

land.lhs.true.i:                                  ; preds = %entry
  %1 = load i16, ptr %status, align 2
  %2 = and i16 %1, 16
  %tobool.not.i.i = icmp eq i16 %2, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %land.lhs.true.i
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %3 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %3, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %land.lhs.true.i
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i32 %a, 0
  br i1 %cmp.i6.i, label %if.end.i, label %if.else.i7.i

if.else.i7.i:                                     ; preds = %land.lhs.true.split.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i8.i = trunc i64 %4 to i32
  %reass.sub.i9.i = xor i32 %cast.i.i8.i, 63
  br label %if.end.sink.split.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = uitofp i32 %a to float
  %5 = bitcast float %conv3.i to i32
  br label %uint64_to_float32_scalbn.exit

if.end.sink.split.i:                              ; preds = %if.else.i7.i, %if.else.i.i
  %reass.sub.i9.sink.i = phi i32 [ %reass.sub.i9.i, %if.else.i7.i ], [ %add.i.i, %if.else.i.i ]
  %.sink.i = phi i64 [ %4, %if.else.i7.i ], [ %0, %if.else.i.i ]
  %exp.i10.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i9.sink.i, ptr %exp.i10.i, align 4
  %shl.i11.i = shl i64 %conv, %.sink.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i11.i, ptr %6, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.end.sink.split.i, %land.lhs.true.split.i, %entry.split.i
  %storemerge.i = phi i8 [ 1, %entry.split.i ], [ 1, %land.lhs.true.split.i ], [ 2, %if.end.sink.split.i ]
  store i8 %storemerge.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float32_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %7 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %7 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 31
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %8 = load i32, ptr %exp.i.i.i.i, align 4
  %9 = shl i32 %8, 23
  %10 = and i32 %9, 2139095040
  %and8.i.i.i.i = zext nneg i32 %10 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %11 = getelementptr inbounds i8, ptr %p.i, i64 8
  %12 = load i64, ptr %11, align 8
  %shl77.i9.i.i.i = and i64 %12, 8388607
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i32
  br label %uint64_to_float32_scalbn.exit

uint64_to_float32_scalbn.exit:                    ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i32 [ %5, %if.then.i ], [ %conv.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @uint16_to_float32_scalbn(i16 noundef zeroext %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = zext i16 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %cmp.i = icmp eq i32 %scale, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %entry.split.i

entry.split.i:                                    ; preds = %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i16 %a, 0
  br i1 %cmp.i.i, label %if.end.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry.split.i
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %add.i.i = add nsw i32 %reass.sub.i.i, %cond7.i.i
  br label %if.end.sink.split.i

land.lhs.true.i:                                  ; preds = %entry
  %1 = load i16, ptr %status, align 2
  %2 = and i16 %1, 16
  %tobool.not.i.i = icmp eq i16 %2, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %land.lhs.true.i
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %3 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %3, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %land.lhs.true.i
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i16 %a, 0
  br i1 %cmp.i6.i, label %if.end.i, label %if.else.i7.i

if.else.i7.i:                                     ; preds = %land.lhs.true.split.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i8.i = trunc i64 %4 to i32
  %reass.sub.i9.i = xor i32 %cast.i.i8.i, 63
  br label %if.end.sink.split.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = uitofp i16 %a to float
  %5 = bitcast float %conv3.i to i32
  br label %uint64_to_float32_scalbn.exit

if.end.sink.split.i:                              ; preds = %if.else.i7.i, %if.else.i.i
  %reass.sub.i9.sink.i = phi i32 [ %reass.sub.i9.i, %if.else.i7.i ], [ %add.i.i, %if.else.i.i ]
  %.sink.i = phi i64 [ %4, %if.else.i7.i ], [ %0, %if.else.i.i ]
  %exp.i10.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i9.sink.i, ptr %exp.i10.i, align 4
  %shl.i11.i = shl i64 %conv, %.sink.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i11.i, ptr %6, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.end.sink.split.i, %land.lhs.true.split.i, %entry.split.i
  %storemerge.i = phi i8 [ 1, %entry.split.i ], [ 1, %land.lhs.true.split.i ], [ 2, %if.end.sink.split.i ]
  store i8 %storemerge.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float32_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %7 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %7 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 31
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %8 = load i32, ptr %exp.i.i.i.i, align 4
  %9 = shl i32 %8, 23
  %10 = and i32 %9, 2139095040
  %and8.i.i.i.i = zext nneg i32 %10 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %11 = getelementptr inbounds i8, ptr %p.i, i64 8
  %12 = load i64, ptr %11, align 8
  %shl77.i9.i.i.i = and i64 %12, 8388607
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i32
  br label %uint64_to_float32_scalbn.exit

uint64_to_float32_scalbn.exit:                    ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i32 [ %5, %if.then.i ], [ %conv.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @uint64_to_float32(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %0 = load i16, ptr %status, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %2, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i64 %a, 0
  br i1 %cmp.i6.i, label %if.end.i, label %if.else.i7.i

if.else.i7.i:                                     ; preds = %land.lhs.true.split.i
  %3 = tail call i64 @llvm.ctlz.i64(i64 %a, i1 true), !range !5
  %cast.i.i8.i = trunc i64 %3 to i32
  %reass.sub.i9.i = xor i32 %cast.i.i8.i, 63
  %exp.i10.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i9.i, ptr %exp.i10.i, align 4
  %shl.i11.i = shl i64 %a, %3
  %4 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i11.i, ptr %4, align 8
  br label %if.end.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = uitofp i64 %a to float
  %5 = bitcast float %conv3.i to i32
  br label %uint64_to_float32_scalbn.exit

if.end.i:                                         ; preds = %if.else.i7.i, %land.lhs.true.split.i
  %storemerge.i = phi i8 [ 1, %land.lhs.true.split.i ], [ 2, %if.else.i7.i ]
  store i8 %storemerge.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %status, ptr noundef nonnull @float32_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %6 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %6 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 31
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %7 = load i32, ptr %exp.i.i.i.i, align 4
  %8 = shl i32 %7, 23
  %9 = and i32 %8, 2139095040
  %and8.i.i.i.i = zext nneg i32 %9 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %10 = getelementptr inbounds i8, ptr %p.i, i64 8
  %11 = load i64, ptr %10, align 8
  %shl77.i9.i.i.i = and i64 %11, 8388607
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i32
  br label %uint64_to_float32_scalbn.exit

uint64_to_float32_scalbn.exit:                    ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i32 [ %5, %if.then.i ], [ %conv.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @uint32_to_float32(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = zext i32 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %0 = load i16, ptr %status, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %2, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i32 %a, 0
  br i1 %cmp.i6.i, label %if.end.i, label %if.else.i7.i

if.else.i7.i:                                     ; preds = %land.lhs.true.split.i
  %3 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i8.i = trunc i64 %3 to i32
  %reass.sub.i9.i = xor i32 %cast.i.i8.i, 63
  %exp.i10.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i9.i, ptr %exp.i10.i, align 4
  %shl.i11.i = shl i64 %conv, %3
  %4 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i11.i, ptr %4, align 8
  br label %if.end.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = uitofp i32 %a to float
  %5 = bitcast float %conv3.i to i32
  br label %uint64_to_float32_scalbn.exit

if.end.i:                                         ; preds = %if.else.i7.i, %land.lhs.true.split.i
  %storemerge.i = phi i8 [ 1, %land.lhs.true.split.i ], [ 2, %if.else.i7.i ]
  store i8 %storemerge.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %status, ptr noundef nonnull @float32_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %6 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %6 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 31
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %7 = load i32, ptr %exp.i.i.i.i, align 4
  %8 = shl i32 %7, 23
  %9 = and i32 %8, 2139095040
  %and8.i.i.i.i = zext nneg i32 %9 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %10 = getelementptr inbounds i8, ptr %p.i, i64 8
  %11 = load i64, ptr %10, align 8
  %shl77.i9.i.i.i = and i64 %11, 8388607
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i32
  br label %uint64_to_float32_scalbn.exit

uint64_to_float32_scalbn.exit:                    ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i32 [ %5, %if.then.i ], [ %conv.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @uint16_to_float32(i16 noundef zeroext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = zext i16 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %0 = load i16, ptr %status, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %2, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i16 %a, 0
  br i1 %cmp.i6.i, label %if.end.i, label %if.else.i7.i

if.else.i7.i:                                     ; preds = %land.lhs.true.split.i
  %3 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i8.i = trunc i64 %3 to i32
  %reass.sub.i9.i = xor i32 %cast.i.i8.i, 63
  %exp.i10.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i9.i, ptr %exp.i10.i, align 4
  %shl.i11.i = shl i64 %conv, %3
  %4 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i11.i, ptr %4, align 8
  br label %if.end.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = uitofp i16 %a to float
  %5 = bitcast float %conv3.i to i32
  br label %uint64_to_float32_scalbn.exit

if.end.i:                                         ; preds = %if.else.i7.i, %land.lhs.true.split.i
  %storemerge.i = phi i8 [ 1, %land.lhs.true.split.i ], [ 2, %if.else.i7.i ]
  store i8 %storemerge.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %status, ptr noundef nonnull @float32_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %6 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %6 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 31
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %7 = load i32, ptr %exp.i.i.i.i, align 4
  %8 = shl i32 %7, 23
  %9 = and i32 %8, 2139095040
  %and8.i.i.i.i = zext nneg i32 %9 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %10 = getelementptr inbounds i8, ptr %p.i, i64 8
  %11 = load i64, ptr %10, align 8
  %shl77.i9.i.i.i = and i64 %11, 8388607
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i32
  br label %uint64_to_float32_scalbn.exit

uint64_to_float32_scalbn.exit:                    ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i32 [ %5, %if.then.i ], [ %conv.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i32 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @uint64_to_float64_scalbn(i64 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %cmp = icmp eq i32 %scale, 0
  br i1 %cmp, label %land.lhs.true, label %entry.split

entry.split:                                      ; preds = %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p, i8 0, i64 16, i1 false)
  %cmp.i = icmp eq i64 %a, 0
  br i1 %cmp.i, label %if.end, label %if.else.i

if.else.i:                                        ; preds = %entry.split
  %0 = tail call i64 @llvm.ctlz.i64(i64 %a, i1 true), !range !5
  %cast.i.i = trunc i64 %0 to i32
  %cond.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %reass.sub.i = xor i32 %cast.i.i, 63
  %add.i = add nsw i32 %reass.sub.i, %cond7.i
  br label %if.end.sink.split

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr %status, align 2
  %2 = and i16 %1, 16
  %tobool.not.i = icmp eq i16 %2, 0
  br i1 %tobool.not.i, label %land.lhs.true.split, label %can_use_fpu.exit

can_use_fpu.exit:                                 ; preds = %land.lhs.true
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %3 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp.i5 = icmp eq i8 %3, 0
  br i1 %cmp.i5, label %if.then, label %land.lhs.true.split

land.lhs.true.split:                              ; preds = %land.lhs.true, %can_use_fpu.exit
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p, i8 0, i64 16, i1 false)
  %cmp.i6 = icmp eq i64 %a, 0
  br i1 %cmp.i6, label %if.end, label %if.else.i7

if.else.i7:                                       ; preds = %land.lhs.true.split
  %4 = tail call i64 @llvm.ctlz.i64(i64 %a, i1 true), !range !5
  %cast.i.i8 = trunc i64 %4 to i32
  %reass.sub.i9 = xor i32 %cast.i.i8, 63
  br label %if.end.sink.split

if.then:                                          ; preds = %can_use_fpu.exit
  %conv3 = uitofp i64 %a to double
  %5 = bitcast double %conv3 to i64
  br label %return

if.end.sink.split:                                ; preds = %if.else.i, %if.else.i7
  %reass.sub.i9.sink = phi i32 [ %reass.sub.i9, %if.else.i7 ], [ %add.i, %if.else.i ]
  %.sink = phi i64 [ %4, %if.else.i7 ], [ %0, %if.else.i ]
  %exp.i10 = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %reass.sub.i9.sink, ptr %exp.i10, align 4
  %shl.i11 = shl i64 %a, %.sink
  %6 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i11, ptr %6, align 8
  br label %if.end

if.end:                                           ; preds = %if.end.sink.split, %land.lhs.true.split, %entry.split
  %storemerge = phi i8 [ 1, %entry.split ], [ 1, %land.lhs.true.split ], [ 2, %if.end.sink.split ]
  store i8 %storemerge, ptr %p, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float64_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %p, i64 1
  %7 = load i8, ptr %sign.i.i.i, align 1
  %8 = and i8 %7, 1
  %conv.i.i.i = zext nneg i8 %8 to i64
  %shl.i.i.i = shl nuw i64 %conv.i.i.i, 63
  %exp.i.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %9 = load i32, ptr %exp.i.i.i, align 4
  %10 = and i32 %9, 2047
  %shl77.i.i.i = zext nneg i32 %10 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i.i
  %11 = getelementptr inbounds i8, ptr %p, i64 8
  %12 = load i64, ptr %11, align 8
  %shl77.i9.i.i = and i64 %12, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %5, %if.then ], [ %or.i10.i.i, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @uint32_to_float64_scalbn(i32 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = zext i32 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %cmp.i = icmp eq i32 %scale, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %entry.split.i

entry.split.i:                                    ; preds = %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i32 %a, 0
  br i1 %cmp.i.i, label %if.end.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry.split.i
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %add.i.i = add nsw i32 %reass.sub.i.i, %cond7.i.i
  br label %if.end.sink.split.i

land.lhs.true.i:                                  ; preds = %entry
  %1 = load i16, ptr %status, align 2
  %2 = and i16 %1, 16
  %tobool.not.i.i = icmp eq i16 %2, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %land.lhs.true.i
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %3 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %3, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %land.lhs.true.i
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i32 %a, 0
  br i1 %cmp.i6.i, label %if.end.i, label %if.else.i7.i

if.else.i7.i:                                     ; preds = %land.lhs.true.split.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i8.i = trunc i64 %4 to i32
  %reass.sub.i9.i = xor i32 %cast.i.i8.i, 63
  br label %if.end.sink.split.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = uitofp i32 %a to double
  %5 = bitcast double %conv3.i to i64
  br label %uint64_to_float64_scalbn.exit

if.end.sink.split.i:                              ; preds = %if.else.i7.i, %if.else.i.i
  %reass.sub.i9.sink.i = phi i32 [ %reass.sub.i9.i, %if.else.i7.i ], [ %add.i.i, %if.else.i.i ]
  %.sink.i = phi i64 [ %4, %if.else.i7.i ], [ %0, %if.else.i.i ]
  %exp.i10.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i9.sink.i, ptr %exp.i10.i, align 4
  %shl.i11.i = shl i64 %conv, %.sink.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i11.i, ptr %6, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.end.sink.split.i, %land.lhs.true.split.i, %entry.split.i
  %storemerge.i = phi i8 [ 1, %entry.split.i ], [ 1, %land.lhs.true.split.i ], [ 2, %if.end.sink.split.i ]
  store i8 %storemerge.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float64_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %7 = load i8, ptr %sign.i.i.i.i, align 1
  %8 = and i8 %7, 1
  %conv.i.i.i.i = zext nneg i8 %8 to i64
  %shl.i.i.i.i = shl nuw i64 %conv.i.i.i.i, 63
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %9 = load i32, ptr %exp.i.i.i.i, align 4
  %10 = and i32 %9, 2047
  %shl77.i.i.i.i = zext nneg i32 %10 to i64
  %and8.i.i.i.i = shl nuw nsw i64 %shl77.i.i.i.i, 52
  %or.i.i.i.i = or disjoint i64 %and8.i.i.i.i, %shl.i.i.i.i
  %11 = getelementptr inbounds i8, ptr %p.i, i64 8
  %12 = load i64, ptr %11, align 8
  %shl77.i9.i.i.i = and i64 %12, 4503599627370495
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  br label %uint64_to_float64_scalbn.exit

uint64_to_float64_scalbn.exit:                    ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i64 [ %5, %if.then.i ], [ %or.i10.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @uint16_to_float64_scalbn(i16 noundef zeroext %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = zext i16 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %cmp.i = icmp eq i32 %scale, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %entry.split.i

entry.split.i:                                    ; preds = %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i16 %a, 0
  br i1 %cmp.i.i, label %if.end.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry.split.i
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %add.i.i = add nsw i32 %reass.sub.i.i, %cond7.i.i
  br label %if.end.sink.split.i

land.lhs.true.i:                                  ; preds = %entry
  %1 = load i16, ptr %status, align 2
  %2 = and i16 %1, 16
  %tobool.not.i.i = icmp eq i16 %2, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %land.lhs.true.i
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %3 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %3, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %land.lhs.true.i
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i16 %a, 0
  br i1 %cmp.i6.i, label %if.end.i, label %if.else.i7.i

if.else.i7.i:                                     ; preds = %land.lhs.true.split.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i8.i = trunc i64 %4 to i32
  %reass.sub.i9.i = xor i32 %cast.i.i8.i, 63
  br label %if.end.sink.split.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = uitofp i16 %a to double
  %5 = bitcast double %conv3.i to i64
  br label %uint64_to_float64_scalbn.exit

if.end.sink.split.i:                              ; preds = %if.else.i7.i, %if.else.i.i
  %reass.sub.i9.sink.i = phi i32 [ %reass.sub.i9.i, %if.else.i7.i ], [ %add.i.i, %if.else.i.i ]
  %.sink.i = phi i64 [ %4, %if.else.i7.i ], [ %0, %if.else.i.i ]
  %exp.i10.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i9.sink.i, ptr %exp.i10.i, align 4
  %shl.i11.i = shl i64 %conv, %.sink.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i11.i, ptr %6, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.end.sink.split.i, %land.lhs.true.split.i, %entry.split.i
  %storemerge.i = phi i8 [ 1, %entry.split.i ], [ 1, %land.lhs.true.split.i ], [ 2, %if.end.sink.split.i ]
  store i8 %storemerge.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @float64_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %7 = load i8, ptr %sign.i.i.i.i, align 1
  %8 = and i8 %7, 1
  %conv.i.i.i.i = zext nneg i8 %8 to i64
  %shl.i.i.i.i = shl nuw i64 %conv.i.i.i.i, 63
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %9 = load i32, ptr %exp.i.i.i.i, align 4
  %10 = and i32 %9, 2047
  %shl77.i.i.i.i = zext nneg i32 %10 to i64
  %and8.i.i.i.i = shl nuw nsw i64 %shl77.i.i.i.i, 52
  %or.i.i.i.i = or disjoint i64 %and8.i.i.i.i, %shl.i.i.i.i
  %11 = getelementptr inbounds i8, ptr %p.i, i64 8
  %12 = load i64, ptr %11, align 8
  %shl77.i9.i.i.i = and i64 %12, 4503599627370495
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  br label %uint64_to_float64_scalbn.exit

uint64_to_float64_scalbn.exit:                    ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i64 [ %5, %if.then.i ], [ %or.i10.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @uint64_to_float64(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %0 = load i16, ptr %status, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %2, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i64 %a, 0
  br i1 %cmp.i6.i, label %if.end.i, label %if.else.i7.i

if.else.i7.i:                                     ; preds = %land.lhs.true.split.i
  %3 = tail call i64 @llvm.ctlz.i64(i64 %a, i1 true), !range !5
  %cast.i.i8.i = trunc i64 %3 to i32
  %reass.sub.i9.i = xor i32 %cast.i.i8.i, 63
  %exp.i10.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i9.i, ptr %exp.i10.i, align 4
  %shl.i11.i = shl i64 %a, %3
  %4 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i11.i, ptr %4, align 8
  br label %if.end.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = uitofp i64 %a to double
  %5 = bitcast double %conv3.i to i64
  br label %uint64_to_float64_scalbn.exit

if.end.i:                                         ; preds = %if.else.i7.i, %land.lhs.true.split.i
  %storemerge.i = phi i8 [ 1, %land.lhs.true.split.i ], [ 2, %if.else.i7.i ]
  store i8 %storemerge.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %status, ptr noundef nonnull @float64_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %6 = load i8, ptr %sign.i.i.i.i, align 1
  %7 = and i8 %6, 1
  %conv.i.i.i.i = zext nneg i8 %7 to i64
  %shl.i.i.i.i = shl nuw i64 %conv.i.i.i.i, 63
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %8 = load i32, ptr %exp.i.i.i.i, align 4
  %9 = and i32 %8, 2047
  %shl77.i.i.i.i = zext nneg i32 %9 to i64
  %and8.i.i.i.i = shl nuw nsw i64 %shl77.i.i.i.i, 52
  %or.i.i.i.i = or disjoint i64 %and8.i.i.i.i, %shl.i.i.i.i
  %10 = getelementptr inbounds i8, ptr %p.i, i64 8
  %11 = load i64, ptr %10, align 8
  %shl77.i9.i.i.i = and i64 %11, 4503599627370495
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  br label %uint64_to_float64_scalbn.exit

uint64_to_float64_scalbn.exit:                    ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i64 [ %5, %if.then.i ], [ %or.i10.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @uint32_to_float64(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = zext i32 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %0 = load i16, ptr %status, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %2, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i32 %a, 0
  br i1 %cmp.i6.i, label %if.end.i, label %if.else.i7.i

if.else.i7.i:                                     ; preds = %land.lhs.true.split.i
  %3 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i8.i = trunc i64 %3 to i32
  %reass.sub.i9.i = xor i32 %cast.i.i8.i, 63
  %exp.i10.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i9.i, ptr %exp.i10.i, align 4
  %shl.i11.i = shl i64 %conv, %3
  %4 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i11.i, ptr %4, align 8
  br label %if.end.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = uitofp i32 %a to double
  %5 = bitcast double %conv3.i to i64
  br label %uint64_to_float64_scalbn.exit

if.end.i:                                         ; preds = %if.else.i7.i, %land.lhs.true.split.i
  %storemerge.i = phi i8 [ 1, %land.lhs.true.split.i ], [ 2, %if.else.i7.i ]
  store i8 %storemerge.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %status, ptr noundef nonnull @float64_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %6 = load i8, ptr %sign.i.i.i.i, align 1
  %7 = and i8 %6, 1
  %conv.i.i.i.i = zext nneg i8 %7 to i64
  %shl.i.i.i.i = shl nuw i64 %conv.i.i.i.i, 63
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %8 = load i32, ptr %exp.i.i.i.i, align 4
  %9 = and i32 %8, 2047
  %shl77.i.i.i.i = zext nneg i32 %9 to i64
  %and8.i.i.i.i = shl nuw nsw i64 %shl77.i.i.i.i, 52
  %or.i.i.i.i = or disjoint i64 %and8.i.i.i.i, %shl.i.i.i.i
  %10 = getelementptr inbounds i8, ptr %p.i, i64 8
  %11 = load i64, ptr %10, align 8
  %shl77.i9.i.i.i = and i64 %11, 4503599627370495
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  br label %uint64_to_float64_scalbn.exit

uint64_to_float64_scalbn.exit:                    ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i64 [ %5, %if.then.i ], [ %or.i10.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @uint16_to_float64(i16 noundef zeroext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %conv = zext i16 %a to i64
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %0 = load i16, ptr %status, align 2
  %1 = and i16 %0, 16
  %tobool.not.i.i = icmp eq i16 %1, 0
  br i1 %tobool.not.i.i, label %land.lhs.true.split.i, label %can_use_fpu.exit.i

can_use_fpu.exit.i:                               ; preds = %entry
  %float_rounding_mode.i.i = getelementptr inbounds i8, ptr %status, i64 2
  %2 = load i8, ptr %float_rounding_mode.i.i, align 2
  %cmp.i5.i = icmp eq i8 %2, 0
  br i1 %cmp.i5.i, label %if.then.i, label %land.lhs.true.split.i

land.lhs.true.split.i:                            ; preds = %can_use_fpu.exit.i, %entry
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i6.i = icmp eq i16 %a, 0
  br i1 %cmp.i6.i, label %if.end.i, label %if.else.i7.i

if.else.i7.i:                                     ; preds = %land.lhs.true.split.i
  %3 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i8.i = trunc i64 %3 to i32
  %reass.sub.i9.i = xor i32 %cast.i.i8.i, 63
  %exp.i10.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i9.i, ptr %exp.i10.i, align 4
  %shl.i11.i = shl i64 %conv, %3
  %4 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i11.i, ptr %4, align 8
  br label %if.end.i

if.then.i:                                        ; preds = %can_use_fpu.exit.i
  %conv3.i = uitofp i16 %a to double
  %5 = bitcast double %conv3.i to i64
  br label %uint64_to_float64_scalbn.exit

if.end.i:                                         ; preds = %if.else.i7.i, %land.lhs.true.split.i
  %storemerge.i = phi i8 [ 1, %land.lhs.true.split.i ], [ 2, %if.else.i7.i ]
  store i8 %storemerge.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %status, ptr noundef nonnull @float64_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %6 = load i8, ptr %sign.i.i.i.i, align 1
  %7 = and i8 %6, 1
  %conv.i.i.i.i = zext nneg i8 %7 to i64
  %shl.i.i.i.i = shl nuw i64 %conv.i.i.i.i, 63
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %8 = load i32, ptr %exp.i.i.i.i, align 4
  %9 = and i32 %8, 2047
  %shl77.i.i.i.i = zext nneg i32 %9 to i64
  %and8.i.i.i.i = shl nuw nsw i64 %shl77.i.i.i.i, 52
  %or.i.i.i.i = or disjoint i64 %and8.i.i.i.i, %shl.i.i.i.i
  %10 = getelementptr inbounds i8, ptr %p.i, i64 8
  %11 = load i64, ptr %10, align 8
  %shl77.i9.i.i.i = and i64 %11, 4503599627370495
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  br label %uint64_to_float64_scalbn.exit

uint64_to_float64_scalbn.exit:                    ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i64 [ %5, %if.then.i ], [ %or.i10.i.i.i, %if.end.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i64 %retval.0.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint64_to_bfloat16_scalbn(i64 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p, i8 0, i64 16, i1 false)
  %cmp.i = icmp eq i64 %a, 0
  br i1 %cmp.i, label %parts64_uint_to_float.exit, label %if.else.i

if.else.i:                                        ; preds = %entry
  %0 = tail call i64 @llvm.ctlz.i64(i64 %a, i1 true), !range !5
  %cast.i.i = trunc i64 %0 to i32
  %cond.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %reass.sub.i = xor i32 %cast.i.i, 63
  %add.i = add nsw i32 %reass.sub.i, %cond7.i
  %exp.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %add.i, ptr %exp.i, align 4
  %shl.i = shl i64 %a, %0
  %1 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i, ptr %1, align 8
  br label %parts64_uint_to_float.exit

parts64_uint_to_float.exit:                       ; preds = %entry, %if.else.i
  %.sink.i = phi i8 [ 2, %if.else.i ], [ 1, %entry ]
  store i8 %.sink.i, ptr %p, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %p, i64 1
  %2 = load i8, ptr %sign.i.i.i, align 1
  %conv.i.i.i = zext i8 %2 to i64
  %shl.i.i.i = shl nuw nsw i64 %conv.i.i.i, 15
  %exp.i.i.i = getelementptr inbounds i8, ptr %p, i64 4
  %3 = load i32, ptr %exp.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i, %and8.i.i.i
  %6 = getelementptr inbounds i8, ptr %p, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i = and i64 %7, 127
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i16
  ret i16 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint32_to_bfloat16_scalbn(i32 noundef %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i32 %a, 0
  br i1 %cmp.i.i, label %uint64_to_bfloat16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %conv = zext i32 %a to i64
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %add.i.i = add nsw i32 %reass.sub.i.i, %cond7.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %conv, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_bfloat16_scalbn.exit

uint64_to_bfloat16_scalbn.exit:                   ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint16_to_bfloat16_scalbn(i16 noundef zeroext %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i16 %a, 0
  br i1 %cmp.i.i, label %uint64_to_bfloat16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %conv = zext i16 %a to i64
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %add.i.i = add nsw i32 %reass.sub.i.i, %cond7.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %conv, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_bfloat16_scalbn.exit

uint64_to_bfloat16_scalbn.exit:                   ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint8_to_bfloat16_scalbn(i8 noundef zeroext %a, i32 noundef %scale, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i8 %a, 0
  br i1 %cmp.i.i, label %uint64_to_bfloat16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %conv = zext i8 %a to i64
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %cond.i.i = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond7.i.i = tail call i32 @llvm.smin.i32(i32 %cond.i.i, i32 65536)
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %add.i.i = add nsw i32 %reass.sub.i.i, %cond7.i.i
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %add.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %conv, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_bfloat16_scalbn.exit

uint64_to_bfloat16_scalbn.exit:                   ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint64_to_bfloat16(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i64 %a, 0
  br i1 %cmp.i.i, label %uint64_to_bfloat16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %0 = tail call i64 @llvm.ctlz.i64(i64 %a, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %a, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_bfloat16_scalbn.exit

uint64_to_bfloat16_scalbn.exit:                   ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint32_to_bfloat16(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i32 %a, 0
  br i1 %cmp.i.i, label %uint64_to_bfloat16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %conv = zext i32 %a to i64
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %conv, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_bfloat16_scalbn.exit

uint64_to_bfloat16_scalbn.exit:                   ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint16_to_bfloat16(i16 noundef zeroext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i16 %a, 0
  br i1 %cmp.i.i, label %uint64_to_bfloat16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %conv = zext i16 %a to i64
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %conv, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_bfloat16_scalbn.exit

uint64_to_bfloat16_scalbn.exit:                   ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @uint8_to_bfloat16(i8 noundef zeroext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %p.i, i8 0, i64 16, i1 false)
  %cmp.i.i = icmp eq i8 %a, 0
  br i1 %cmp.i.i, label %uint64_to_bfloat16_scalbn.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %entry
  %conv = zext i8 %a to i64
  %0 = tail call i64 @llvm.ctlz.i64(i64 %conv, i1 true), !range !5
  %cast.i.i.i = trunc i64 %0 to i32
  %reass.sub.i.i = xor i32 %cast.i.i.i, 63
  %exp.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %reass.sub.i.i, ptr %exp.i.i, align 4
  %shl.i.i = shl i64 %conv, %0
  %1 = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %shl.i.i, ptr %1, align 8
  br label %uint64_to_bfloat16_scalbn.exit

uint64_to_bfloat16_scalbn.exit:                   ; preds = %entry, %if.else.i.i
  %.sink.i.i = phi i8 [ 2, %if.else.i.i ], [ 1, %entry ]
  store i8 %.sink.i.i, ptr %p.i, align 8
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  %2 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %2 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  %3 = load i32, ptr %exp.i.i.i.i, align 4
  %4 = shl i32 %3, 7
  %5 = and i32 %4, 32640
  %and8.i.i.i.i = zext nneg i32 %5 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %6 = getelementptr inbounds i8, ptr %p.i, i64 8
  %7 = load i64, ptr %6, align 8
  %shl77.i9.i.i.i = and i64 %7, 127
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @uint64_to_float128(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %p, i8 0, i64 24, i1 false)
  %cmp.i = icmp eq i64 %a, 0
  br i1 %cmp.i, label %parts128_uint_to_float.exit, label %if.else.i

if.else.i:                                        ; preds = %entry
  %0 = tail call i64 @llvm.ctlz.i64(i64 %a, i1 true), !range !5
  %cast.i.i = trunc i64 %0 to i32
  %sub.i = xor i32 %cast.i.i, 63
  %exp.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %sub.i, ptr %exp.i, align 4
  %shl.i = shl i64 %a, %0
  %frac_hi.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %shl.i, ptr %frac_hi.i, align 8
  br label %parts128_uint_to_float.exit

parts128_uint_to_float.exit:                      ; preds = %entry, %if.else.i
  %.sink.i = phi i8 [ 2, %if.else.i ], [ 1, %entry ]
  store i8 %.sink.i, ptr %p, align 8
  %call = call fastcc { i64, i64 } @float128_round_pack_canonical(ptr noundef nonnull %p, ptr noundef %status)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @uint128_to_float128(i64 noundef %a.coerce0, i64 noundef %a.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %p, i8 0, i64 24, i1 false)
  %a.sroa.2.0.insert.ext.i = zext i64 %a.coerce1 to i128
  %a.sroa.2.0.insert.shift.i = shl nuw i128 %a.sroa.2.0.insert.ext.i, 64
  %a.sroa.0.0.insert.ext.i = zext i64 %a.coerce0 to i128
  %a.sroa.0.0.insert.insert.i = or disjoint i128 %a.sroa.2.0.insert.shift.i, %a.sroa.0.0.insert.ext.i
  %cmp.i.not = icmp eq i128 %a.sroa.0.0.insert.insert.i, 0
  br i1 %cmp.i.not, label %if.end17, label %if.then

if.then:                                          ; preds = %entry
  %0 = tail call i64 @llvm.ctlz.i64(i64 %a.coerce1, i1 false), !range !5
  %cast.i = trunc i64 %0 to i32
  %cmp = icmp eq i32 %cast.i, 64
  %1 = tail call i64 @llvm.ctlz.i64(i64 %a.coerce0, i1 false), !range !5
  %cast.i9 = trunc i64 %1 to i32
  %add = add nuw nsw i32 %cast.i9, 64
  %shift.0 = select i1 %cmp, i32 %add, i32 %cast.i
  %sub = sub nsw i32 127, %shift.0
  %exp = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %sub, ptr %exp, align 4
  %sh_prom.i = zext nneg i32 %shift.0 to i128
  %shl.i = shl i128 %a.sroa.0.0.insert.insert.i, %sh_prom.i
  %retval.sroa.0.0.extract.trunc.i = trunc i128 %shl.i to i64
  %retval.sroa.2.0.extract.shift.i = lshr i128 %shl.i, 64
  %retval.sroa.2.0.extract.trunc.i = trunc i128 %retval.sroa.2.0.extract.shift.i to i64
  %frac_hi = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %retval.sroa.2.0.extract.trunc.i, ptr %frac_hi, align 8
  %frac_lo = getelementptr inbounds i8, ptr %p, i64 16
  store i64 %retval.sroa.0.0.extract.trunc.i, ptr %frac_lo, align 8
  br label %if.end17

if.end17:                                         ; preds = %entry, %if.then
  %.sink = phi i8 [ 2, %if.then ], [ 1, %entry ]
  store i8 %.sink, ptr %p, align 8
  %call18 = call fastcc { i64, i64 } @float128_round_pack_canonical(ptr noundef nonnull %p, ptr noundef %status)
  ret { i64, i64 } %call18
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_max(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @float16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 0)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc zeroext i16 @float16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s, i32 noundef %flags) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pb = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %conv.i.i.i4 = zext nneg i16 %1 to i32
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i.i4, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i16 %1, label %if.then33.i.i [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float16a_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float16a_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i4, -15
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float16a_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit:                   ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %f.lobit.i.i5 = lshr i16 %b, 15
  %frombool.i.i.i6 = trunc i16 %f.lobit.i.i5 to i8
  %7 = lshr i16 %b, 10
  %8 = and i16 %7, 31
  %conv.i.i.i7 = zext nneg i16 %8 to i32
  %9 = and i16 %b, 1023
  %and.i10.i.i8 = zext nneg i16 %9 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i6, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i.i7, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i10.i.i8, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  switch i16 %8, label %if.then33.i.i22 [
    i16 0, label %if.then.i.i26
    i16 31, label %lor.lhs.false.i.i15
  ]

if.then.i.i26:                                    ; preds = %float16a_unpack_canonical.exit
  %cmp.i.i.i27 = icmp eq i16 %9, 0
  br i1 %cmp.i.i.i27, label %if.then8.i.i38, label %if.else.i.i28

if.then8.i.i38:                                   ; preds = %if.then.i.i26
  store i8 1, ptr %pb, align 8
  br label %float16a_unpack_canonical.exit39

if.else.i.i28:                                    ; preds = %if.then.i.i26
  %flush_inputs_to_zero.i.i29 = getelementptr inbounds i8, ptr %s, i64 6
  %10 = load i8, ptr %flush_inputs_to_zero.i.i29, align 2
  %11 = and i8 %10, 1
  %tobool9.not.i.i30 = icmp eq i8 %11, 0
  br i1 %tobool9.not.i.i30, label %frac64_normalize.exit.i.i33, label %if.then10.i.i31

if.then10.i.i31:                                  ; preds = %if.else.i.i28
  %12 = load i16, ptr %s, align 2
  %or1.i.i.i32 = or i16 %12, 32
  store i16 %or1.i.i.i32, ptr %s, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float16a_unpack_canonical.exit39

frac64_normalize.exit.i.i33:                      ; preds = %if.else.i.i28
  %13 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i8, i1 true), !range !5
  %cast.i.i.i.i34 = trunc i64 %13 to i32
  %shl.i.i.i35 = shl i64 %and.i10.i.i8, %13
  store i64 %shl.i.i.i35, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i37 = sub nsw i32 39, %cast.i.i.i.i34
  store i32 %add.i.i37, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  br label %float16a_unpack_canonical.exit39

lor.lhs.false.i.i15:                              ; preds = %float16a_unpack_canonical.exit
  %cmp.i29.i.i16 = icmp eq i16 %9, 0
  br i1 %cmp.i29.i.i16, label %if.then47.i.i21, label %if.else49.i.i17

if.then33.i.i22:                                  ; preds = %float16a_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i23 = add nsw i32 %conv.i.i.i7, -15
  store i32 %sub37.i.i23, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %shl.i28.i.i24 = shl nuw nsw i64 %and.i10.i.i8, 53
  %or.i.i25 = or disjoint i64 %shl.i28.i.i24, -9223372036854775808
  store i64 %or.i.i25, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float16a_unpack_canonical.exit39

if.then47.i.i21:                                  ; preds = %lor.lhs.false.i.i15
  store i8 3, ptr %pb, align 8
  br label %float16a_unpack_canonical.exit39

if.else49.i.i17:                                  ; preds = %lor.lhs.false.i.i15
  %shl.i31.i.i18 = shl nuw nsw i64 %and.i10.i.i8, 53
  store i64 %shl.i31.i.i18, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  %tobool.not.i32.i.i19 = icmp ult i16 %9, 512
  %conv53.i.i20 = select i1 %tobool.not.i32.i.i19, i8 5, i8 4
  store i8 %conv53.i.i20, ptr %pb, align 8
  br label %float16a_unpack_canonical.exit39

float16a_unpack_canonical.exit39:                 ; preds = %if.then8.i.i38, %if.then10.i.i31, %frac64_normalize.exit.i.i33, %if.then33.i.i22, %if.then47.i.i21, %if.else49.i.i17
  %call = call fastcc ptr @parts64_minmax(ptr noundef nonnull %pa, ptr noundef nonnull %pb, ptr noundef %s, i32 noundef %flags)
  call fastcc void @parts64_uncanon(ptr noundef %call, ptr noundef %s, ptr noundef nonnull @float16_params)
  %sign.i.i.i.i = getelementptr inbounds i8, ptr %call, i64 1
  %14 = load i8, ptr %sign.i.i.i.i, align 1
  %conv.i.i.i.i = zext i8 %14 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %exp.i.i.i.i = getelementptr inbounds i8, ptr %call, i64 4
  %15 = load i32, ptr %exp.i.i.i.i, align 4
  %16 = shl i32 %15, 10
  %17 = and i32 %16, 31744
  %and8.i.i.i.i = zext nneg i32 %17 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %18 = getelementptr inbounds i8, ptr %call, i64 8
  %19 = load i64, ptr %18, align 8
  %shl77.i9.i.i.i = and i64 %19, 1023
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_maxnum(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @float16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 2)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_maxnummag(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @float16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 6)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_maximum_number(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @float16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 8)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_min(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @float16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 1)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_minnum(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @float16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 3)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_minnummag(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @float16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 7)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_minimum_number(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @float16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 9)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_max(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @bfloat16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 0)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc zeroext i16 @bfloat16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s, i32 noundef %flags) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pb = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %if.then33.i.i [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %bfloat16_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %bfloat16_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %bfloat16_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %bfloat16_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %bfloat16_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 64
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %bfloat16_unpack_canonical.exit

bfloat16_unpack_canonical.exit:                   ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %f.lobit.i.i4 = lshr i16 %b, 15
  %frombool.i.i.i5 = trunc i16 %f.lobit.i.i4 to i8
  %7 = lshr i16 %b, 7
  %8 = and i16 %7, 255
  %conv.i.i.i6 = zext nneg i16 %8 to i32
  %9 = and i16 %b, 127
  %and.i10.i.i7 = zext nneg i16 %9 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i8 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i5, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i8, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i9 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i.i6, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i9, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i10.i.i7, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i10, align 8
  %trunc.i11 = trunc i16 %7 to i8
  switch i8 %trunc.i11, label %if.then33.i.i31 [
    i8 0, label %if.then.i.i19
    i8 -1, label %lor.lhs.false.i.i12
  ]

if.then.i.i19:                                    ; preds = %bfloat16_unpack_canonical.exit
  %cmp.i.i.i20 = icmp eq i16 %9, 0
  br i1 %cmp.i.i.i20, label %if.then8.i.i30, label %if.else.i.i21

if.then8.i.i30:                                   ; preds = %if.then.i.i19
  store i8 1, ptr %pb, align 8
  br label %bfloat16_unpack_canonical.exit35

if.else.i.i21:                                    ; preds = %if.then.i.i19
  %flush_inputs_to_zero.i.i22 = getelementptr inbounds i8, ptr %s, i64 6
  %10 = load i8, ptr %flush_inputs_to_zero.i.i22, align 2
  %11 = and i8 %10, 1
  %tobool9.not.i.i23 = icmp eq i8 %11, 0
  br i1 %tobool9.not.i.i23, label %frac64_normalize.exit.i.i26, label %if.then10.i.i24

if.then10.i.i24:                                  ; preds = %if.else.i.i21
  %12 = load i16, ptr %s, align 2
  %or1.i.i.i25 = or i16 %12, 32
  store i16 %or1.i.i.i25, ptr %s, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i10, align 8
  br label %bfloat16_unpack_canonical.exit35

frac64_normalize.exit.i.i26:                      ; preds = %if.else.i.i21
  %13 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i7, i1 true), !range !5
  %cast.i.i.i.i27 = trunc i64 %13 to i32
  %shl.i.i.i28 = shl i64 %and.i10.i.i7, %13
  store i64 %shl.i.i.i28, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i10, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i29 = sub nuw nsw i32 -70, %cast.i.i.i.i27
  store i32 %add.i.i29, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i9, align 4
  br label %bfloat16_unpack_canonical.exit35

lor.lhs.false.i.i12:                              ; preds = %bfloat16_unpack_canonical.exit
  %cmp.i29.i.i13 = icmp eq i16 %9, 0
  br i1 %cmp.i29.i.i13, label %if.then47.i.i18, label %if.else49.i.i14

if.then33.i.i31:                                  ; preds = %bfloat16_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i32 = add nsw i32 %conv.i.i.i6, -127
  store i32 %sub37.i.i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i9, align 4
  %shl.i28.i.i33 = shl nuw nsw i64 %and.i10.i.i7, 56
  %or.i.i34 = or disjoint i64 %shl.i28.i.i33, -9223372036854775808
  store i64 %or.i.i34, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i10, align 8
  br label %bfloat16_unpack_canonical.exit35

if.then47.i.i18:                                  ; preds = %lor.lhs.false.i.i12
  store i8 3, ptr %pb, align 8
  br label %bfloat16_unpack_canonical.exit35

if.else49.i.i14:                                  ; preds = %lor.lhs.false.i.i12
  %shl.i31.i.i15 = shl nuw nsw i64 %and.i10.i.i7, 56
  store i64 %shl.i31.i.i15, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i10, align 8
  %tobool.not.i32.i.i16 = icmp ult i16 %9, 64
  %conv53.i.i17 = select i1 %tobool.not.i32.i.i16, i8 5, i8 4
  store i8 %conv53.i.i17, ptr %pb, align 8
  br label %bfloat16_unpack_canonical.exit35

bfloat16_unpack_canonical.exit35:                 ; preds = %if.then8.i.i30, %if.then10.i.i24, %frac64_normalize.exit.i.i26, %if.then33.i.i31, %if.then47.i.i18, %if.else49.i.i14
  %call = call fastcc ptr @parts64_minmax(ptr noundef nonnull %pa, ptr noundef nonnull %pb, ptr noundef %s, i32 noundef %flags)
  call fastcc void @parts64_uncanon(ptr noundef %call, ptr noundef %s, ptr noundef nonnull @bfloat16_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %call, i64 1
  %14 = load i8, ptr %sign.i.i.i, align 1
  %conv.i.i.i36 = zext i8 %14 to i64
  %shl.i.i.i37 = shl nuw nsw i64 %conv.i.i.i36, 15
  %exp.i.i.i = getelementptr inbounds i8, ptr %call, i64 4
  %15 = load i32, ptr %exp.i.i.i, align 4
  %16 = shl i32 %15, 7
  %17 = and i32 %16, 32640
  %and8.i.i.i = zext nneg i32 %17 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i37, %and8.i.i.i
  %18 = getelementptr inbounds i8, ptr %call, i64 8
  %19 = load i64, ptr %18, align 8
  %shl77.i9.i.i = and i64 %19, 127
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i16
  ret i16 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_maxnum(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @bfloat16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 2)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_maxnummag(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @bfloat16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 6)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_maximum_number(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @bfloat16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 8)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_min(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @bfloat16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 1)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_minnum(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @bfloat16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 3)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_minnummag(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @bfloat16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 7)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_minimum_number(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc zeroext i16 @bfloat16_minmax(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i32 noundef 9)
  ret i16 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_max(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float32_minmax(i32 noundef %a, i32 noundef %b, ptr noundef %s, i32 noundef 0)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @float32_minmax(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s, i32 noundef %flags) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pb = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %and.i9.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %if.then33.i.i [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float32_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float32_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float32_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float32_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float32_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float32_unpack_canonical.exit

float32_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %f.lobit.i.i4 = lshr i32 %b, 31
  %frombool.i.i.i5 = trunc i32 %f.lobit.i.i4 to i8
  %shr.i8.i.i6 = lshr i32 %b, 23
  %and.i9.i.i7 = and i32 %shr.i8.i.i6, 255
  %5 = and i32 %b, 8388607
  %and.i10.i.i8 = zext nneg i32 %5 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i5, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %and.i9.i.i7, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i10.i.i8, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  %trunc.i12 = trunc i32 %shr.i8.i.i6 to i8
  switch i8 %trunc.i12, label %if.then33.i.i32 [
    i8 0, label %if.then.i.i20
    i8 -1, label %lor.lhs.false.i.i13
  ]

if.then.i.i20:                                    ; preds = %float32_unpack_canonical.exit
  %cmp.i.i.i21 = icmp eq i32 %5, 0
  br i1 %cmp.i.i.i21, label %if.then8.i.i31, label %if.else.i.i22

if.then8.i.i31:                                   ; preds = %if.then.i.i20
  store i8 1, ptr %pb, align 8
  br label %float32_unpack_canonical.exit36

if.else.i.i22:                                    ; preds = %if.then.i.i20
  %flush_inputs_to_zero.i.i23 = getelementptr inbounds i8, ptr %s, i64 6
  %6 = load i8, ptr %flush_inputs_to_zero.i.i23, align 2
  %7 = and i8 %6, 1
  %tobool9.not.i.i24 = icmp eq i8 %7, 0
  br i1 %tobool9.not.i.i24, label %frac64_normalize.exit.i.i27, label %if.then10.i.i25

if.then10.i.i25:                                  ; preds = %if.else.i.i22
  %8 = load i16, ptr %s, align 2
  %or1.i.i.i26 = or i16 %8, 32
  store i16 %or1.i.i.i26, ptr %s, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float32_unpack_canonical.exit36

frac64_normalize.exit.i.i27:                      ; preds = %if.else.i.i22
  %9 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i8, i1 true), !range !5
  %cast.i.i.i.i28 = trunc i64 %9 to i32
  %shl.i.i.i29 = shl i64 %and.i10.i.i8, %9
  store i64 %shl.i.i.i29, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i30 = sub nuw nsw i32 -86, %cast.i.i.i.i28
  store i32 %add.i.i30, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  br label %float32_unpack_canonical.exit36

lor.lhs.false.i.i13:                              ; preds = %float32_unpack_canonical.exit
  %cmp.i29.i.i14 = icmp eq i32 %5, 0
  br i1 %cmp.i29.i.i14, label %if.then47.i.i19, label %if.else49.i.i15

if.then33.i.i32:                                  ; preds = %float32_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i33 = add nsw i32 %and.i9.i.i7, -127
  store i32 %sub37.i.i33, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %shl.i28.i.i34 = shl nuw nsw i64 %and.i10.i.i8, 40
  %or.i.i35 = or disjoint i64 %shl.i28.i.i34, -9223372036854775808
  store i64 %or.i.i35, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float32_unpack_canonical.exit36

if.then47.i.i19:                                  ; preds = %lor.lhs.false.i.i13
  store i8 3, ptr %pb, align 8
  br label %float32_unpack_canonical.exit36

if.else49.i.i15:                                  ; preds = %lor.lhs.false.i.i13
  %shl.i31.i.i16 = shl nuw nsw i64 %and.i10.i.i8, 40
  store i64 %shl.i31.i.i16, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  %tobool.not.i32.i.i17 = icmp ult i32 %5, 4194304
  %conv53.i.i18 = select i1 %tobool.not.i32.i.i17, i8 5, i8 4
  store i8 %conv53.i.i18, ptr %pb, align 8
  br label %float32_unpack_canonical.exit36

float32_unpack_canonical.exit36:                  ; preds = %if.then8.i.i31, %if.then10.i.i25, %frac64_normalize.exit.i.i27, %if.then33.i.i32, %if.then47.i.i19, %if.else49.i.i15
  %call = call fastcc ptr @parts64_minmax(ptr noundef nonnull %pa, ptr noundef nonnull %pb, ptr noundef %s, i32 noundef %flags)
  call fastcc void @parts64_uncanon(ptr noundef %call, ptr noundef %s, ptr noundef nonnull @float32_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %call, i64 1
  %10 = load i8, ptr %sign.i.i.i, align 1
  %conv.i.i.i = zext i8 %10 to i64
  %shl.i.i.i37 = shl nuw nsw i64 %conv.i.i.i, 31
  %exp.i.i.i = getelementptr inbounds i8, ptr %call, i64 4
  %11 = load i32, ptr %exp.i.i.i, align 4
  %12 = shl i32 %11, 23
  %13 = and i32 %12, 2139095040
  %and8.i.i.i = zext nneg i32 %13 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i37, %and8.i.i.i
  %14 = getelementptr inbounds i8, ptr %call, i64 8
  %15 = load i64, ptr %14, align 8
  %shl77.i9.i.i = and i64 %15, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  ret i32 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_maxnum(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float32_minmax(i32 noundef %a, i32 noundef %b, ptr noundef %s, i32 noundef 2)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_maxnummag(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float32_minmax(i32 noundef %a, i32 noundef %b, ptr noundef %s, i32 noundef 6)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_maximum_number(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float32_minmax(i32 noundef %a, i32 noundef %b, ptr noundef %s, i32 noundef 8)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_min(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float32_minmax(i32 noundef %a, i32 noundef %b, ptr noundef %s, i32 noundef 1)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_minnum(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float32_minmax(i32 noundef %a, i32 noundef %b, ptr noundef %s, i32 noundef 3)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_minnummag(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float32_minmax(i32 noundef %a, i32 noundef %b, ptr noundef %s, i32 noundef 7)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_minimum_number(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float32_minmax(i32 noundef %a, i32 noundef %b, ptr noundef %s, i32 noundef 9)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_max(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @float64_minmax(i64 noundef %a, i64 noundef %b, ptr noundef %s, i32 noundef 0)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i64 @float64_minmax(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s, i32 noundef %flags) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pb = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float64_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %pa, align 8
  br label %float64_unpack_canonical.exit

float64_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  %f.lobit.i.i4 = lshr i64 %b, 63
  %frombool.i.i.i5 = trunc i64 %f.lobit.i.i4 to i8
  %shr.i8.i.i6 = lshr i64 %b, 52
  %5 = trunc i64 %shr.i8.i.i6 to i32
  %conv.i.i.i7 = and i32 %5, 2047
  %and.i9.i.i8 = and i64 %b, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i.i5, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i9, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i.i7, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i9.i.i8, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  switch i32 %conv.i.i.i7, label %if.then33.i.i31 [
    i32 0, label %if.then.i.i19
    i32 2047, label %lor.lhs.false.i.i12
  ]

if.then.i.i19:                                    ; preds = %float64_unpack_canonical.exit
  %cmp.i.i.i20 = icmp eq i64 %and.i9.i.i8, 0
  br i1 %cmp.i.i.i20, label %if.then8.i.i30, label %if.else.i.i21

if.then8.i.i30:                                   ; preds = %if.then.i.i19
  store i8 1, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

if.else.i.i21:                                    ; preds = %if.then.i.i19
  %flush_inputs_to_zero.i.i22 = getelementptr inbounds i8, ptr %s, i64 6
  %6 = load i8, ptr %flush_inputs_to_zero.i.i22, align 2
  %7 = and i8 %6, 1
  %tobool9.not.i.i23 = icmp eq i8 %7, 0
  br i1 %tobool9.not.i.i23, label %frac64_normalize.exit.i.i26, label %if.then10.i.i24

if.then10.i.i24:                                  ; preds = %if.else.i.i21
  %8 = load i16, ptr %s, align 2
  %or1.i.i.i25 = or i16 %8, 32
  store i16 %or1.i.i.i25, ptr %s, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float64_unpack_canonical.exit35

frac64_normalize.exit.i.i26:                      ; preds = %if.else.i.i21
  %9 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i8, i1 true), !range !5
  %cast.i.i.i.i27 = trunc i64 %9 to i32
  %shl.i.i.i28 = shl i64 %and.i9.i.i8, %9
  store i64 %shl.i.i.i28, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  store i8 2, ptr %pb, align 8
  %add.i.i29 = sub nuw nsw i32 -1011, %cast.i.i.i.i27
  store i32 %add.i.i29, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  br label %float64_unpack_canonical.exit35

lor.lhs.false.i.i12:                              ; preds = %float64_unpack_canonical.exit
  %cmp.i29.i.i13 = icmp eq i64 %and.i9.i.i8, 0
  br i1 %cmp.i29.i.i13, label %if.then47.i.i18, label %if.else49.i.i14

if.then33.i.i31:                                  ; preds = %float64_unpack_canonical.exit
  store i8 2, ptr %pb, align 8
  %sub37.i.i32 = add nsw i32 %conv.i.i.i7, -1023
  store i32 %sub37.i.i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i10, align 4
  %shl.i28.i.i33 = shl nuw nsw i64 %and.i9.i.i8, 11
  %or.i.i34 = or disjoint i64 %shl.i28.i.i33, -9223372036854775808
  store i64 %or.i.i34, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  br label %float64_unpack_canonical.exit35

if.then47.i.i18:                                  ; preds = %lor.lhs.false.i.i12
  store i8 3, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

if.else49.i.i14:                                  ; preds = %lor.lhs.false.i.i12
  %shl.i31.i.i15 = shl nuw nsw i64 %and.i9.i.i8, 11
  store i64 %shl.i31.i.i15, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i11, align 8
  %tobool.not.i32.i.i16 = icmp ult i64 %and.i9.i.i8, 2251799813685248
  %conv53.i.i17 = select i1 %tobool.not.i32.i.i16, i8 5, i8 4
  store i8 %conv53.i.i17, ptr %pb, align 8
  br label %float64_unpack_canonical.exit35

float64_unpack_canonical.exit35:                  ; preds = %if.then8.i.i30, %if.then10.i.i24, %frac64_normalize.exit.i.i26, %if.then33.i.i31, %if.then47.i.i18, %if.else49.i.i14
  %call = call fastcc ptr @parts64_minmax(ptr noundef nonnull %pa, ptr noundef nonnull %pb, ptr noundef %s, i32 noundef %flags)
  call fastcc void @parts64_uncanon(ptr noundef %call, ptr noundef %s, ptr noundef nonnull @float64_params)
  %sign.i.i.i = getelementptr inbounds i8, ptr %call, i64 1
  %10 = load i8, ptr %sign.i.i.i, align 1
  %11 = and i8 %10, 1
  %conv.i.i.i36 = zext nneg i8 %11 to i64
  %shl.i.i.i37 = shl nuw i64 %conv.i.i.i36, 63
  %exp.i.i.i = getelementptr inbounds i8, ptr %call, i64 4
  %12 = load i32, ptr %exp.i.i.i, align 4
  %13 = and i32 %12, 2047
  %shl77.i.i.i = zext nneg i32 %13 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i.i37
  %14 = getelementptr inbounds i8, ptr %call, i64 8
  %15 = load i64, ptr %14, align 8
  %shl77.i9.i.i = and i64 %15, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  ret i64 %or.i10.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_maxnum(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @float64_minmax(i64 noundef %a, i64 noundef %b, ptr noundef %s, i32 noundef 2)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_maxnummag(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @float64_minmax(i64 noundef %a, i64 noundef %b, ptr noundef %s, i32 noundef 6)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_maximum_number(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @float64_minmax(i64 noundef %a, i64 noundef %b, ptr noundef %s, i32 noundef 8)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_min(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @float64_minmax(i64 noundef %a, i64 noundef %b, ptr noundef %s, i32 noundef 1)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_minnum(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @float64_minmax(i64 noundef %a, i64 noundef %b, ptr noundef %s, i32 noundef 3)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_minnummag(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @float64_minmax(i64 noundef %a, i64 noundef %b, ptr noundef %s, i32 noundef 7)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_minimum_number(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i64 @float64_minmax(i64 noundef %a, i64 noundef %b, ptr noundef %s, i32 noundef 9)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_max(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i64 } @float128_minmax(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr noundef %s, i32 noundef 0)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc { i64, i64 } @float128_minmax(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %s, i32 noundef %flags) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts128, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts128, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %pa, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  store i64 %and.i.i.i, ptr %pa.sroa.gep, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %pa, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pa, ptr noundef %s, ptr noundef nonnull @float128_params)
  %shr.i16.i.i4 = lshr i64 %b.coerce1, 48
  %1 = trunc i64 %shr.i16.i.i4 to i32
  %conv.i.i5 = and i32 %1, 32767
  %f.coerce1.lobit.i.i6 = lshr i64 %b.coerce1, 63
  %frombool.i.i7 = trunc i64 %f.coerce1.lobit.i.i6 to i8
  %and.i.i.i8 = and i64 %b.coerce1, 281474976710655
  store i8 0, ptr %pb, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i9 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i7, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i9, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i10 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i5, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i10, align 4
  store i64 %and.i.i.i8, ptr %pb.sroa.gep, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i12 = getelementptr inbounds i8, ptr %pb, i64 16
  store i64 %b.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i12, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pb, ptr noundef %s, ptr noundef nonnull @float128_params)
  %2 = load i8, ptr %pa, align 8
  %conv.i = zext nneg i8 %2 to i32
  %shl.i = shl nuw i32 1, %conv.i
  %3 = load i8, ptr %pb, align 8
  %conv2.i = zext nneg i8 %3 to i32
  %shl3.i = shl nuw i32 1, %conv2.i
  %or.i = or i32 %shl3.i, %shl.i
  %and.i = and i32 %or.i, 48
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end35.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %and7.i = and i32 %flags, 10
  %tobool8.not.i = icmp ne i32 %and7.i, 0
  %and9.i = and i32 %or.i, 32
  %tobool10.not.i = icmp eq i32 %and9.i, 0
  %or.cond34.i = and i1 %tobool8.not.i, %tobool10.not.i
  %or.cond34.not.i = xor i1 %or.cond34.i, true
  %and12.i = and i32 %or.i, -49
  %tobool13.not.i = icmp eq i32 %and12.i, 0
  %or.cond35.i = or i1 %tobool13.not.i, %or.cond34.not.i
  br i1 %or.cond35.i, label %if.end.i, label %if.then14.i

if.then14.i:                                      ; preds = %if.then.i
  %cmp.i.i = icmp ugt i8 %2, 3
  %cond.i = select i1 %cmp.i.i, ptr %pb, ptr %pa
  br label %parts128_minmax.exit

if.end.i:                                         ; preds = %if.then.i
  %and17.i = and i32 %flags, 8
  %tobool18.not.i = icmp eq i32 %and17.i, 0
  %or.cond36.i = or i1 %tobool18.not.i, %tobool10.not.i
  %or.cond37.i = or i1 %tobool13.not.i, %or.cond36.i
  br i1 %or.cond37.i, label %if.end33.i, label %if.then25.i

if.then25.i:                                      ; preds = %if.end.i
  %4 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %4, 1
  store i16 %or1.i.i, ptr %s, align 2
  %cmp.i39.i = icmp ugt i8 %2, 3
  %cond32.i = select i1 %cmp.i39.i, ptr %pb, ptr %pa
  br label %parts128_minmax.exit

if.end33.i:                                       ; preds = %if.end.i
  %cmp.i.i.i = icmp eq i8 %2, 5
  %cmp.i17.i.i = icmp eq i8 %3, 5
  %or.cond48.i = or i1 %cmp.i.i.i, %cmp.i17.i.i
  br i1 %or.cond48.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %if.end33.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 8193
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i.i, %if.end33.i
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.end.i.i
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %pa.sroa.gep, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %parts128_minmax.exit

if.else.i.i:                                      ; preds = %if.end.i.i
  %8 = load i64, ptr %pa.sroa.gep, align 8
  %9 = load i64, ptr %pb.sroa.gep, align 8
  %cmp.i18.i.i = icmp eq i64 %8, %9
  br i1 %cmp.i18.i.i, label %if.then.i.i.i, label %frac128_cmp.exit.i.i

if.then.i.i.i:                                    ; preds = %if.else.i.i
  %10 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %11 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i12, align 8
  %cmp3.i.i.i = icmp eq i64 %10, %11
  br i1 %cmp3.i.i.i, label %if.then6.i.i, label %frac128_cmp.exit.i.i

frac128_cmp.exit.i.i:                             ; preds = %if.then.i.i.i, %if.else.i.i
  %ta.0.i.i.i = phi i64 [ %10, %if.then.i.i.i ], [ %8, %if.else.i.i ]
  %tb.0.i.i.i = phi i64 [ %11, %if.then.i.i.i ], [ %9, %if.else.i.i ]
  %cmp6.i.i.i = icmp ult i64 %ta.0.i.i.i, %tb.0.i.i.i
  br label %if.end13.i.i

if.then6.i.i:                                     ; preds = %if.then.i.i.i
  %12 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %13 = and i8 %12, 1
  %14 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i9, align 1
  %15 = and i8 %14, 1
  %cmp11.i.i = icmp uge i8 %13, %15
  br label %if.end13.i.i

if.end13.i.i:                                     ; preds = %if.then6.i.i, %frac128_cmp.exit.i.i
  %cmp.0.i.i = phi i1 [ %cmp11.i.i, %if.then6.i.i ], [ %cmp6.i.i.i, %frac128_cmp.exit.i.i ]
  switch i8 %2, label %16 [
    i8 5, label %pickNaN.exit.i.i
    i8 4, label %if.then6.i.i.i
  ]

if.then6.i.i.i:                                   ; preds = %if.end13.i.i
  br i1 %cmp.i17.i.i, label %parts128_minmax.exit, label %lor.lhs.false.i.i.i

lor.lhs.false.i.i.i:                              ; preds = %if.then6.i.i.i
  %cmp.i11.i.i.i = icmp eq i8 %3, 4
  %spec.select.i.i.i = and i1 %cmp.i11.i.i.i, %cmp.0.i.i
  %cond.fr31.i.i = freeze i1 %spec.select.i.i.i
  %spec.select57.i = select i1 %cond.fr31.i.i, ptr %pb, ptr %pa
  br label %parts128_minmax.exit

pickNaN.exit.i.i:                                 ; preds = %if.end13.i.i
  %cmp.i8.i.i.i = icmp eq i8 %3, 4
  %spec.select25.i.i = select i1 %cmp.i17.i.i, i1 %cmp.0.i.i, i1 %cmp.i8.i.i.i
  %cond.fr.i.i = freeze i1 %spec.select25.i.i
  %cond.fr.i.i.not = xor i1 %cond.fr.i.i, true
  %brmerge = or i1 %cmp.i17.i.i, %cond.fr.i.i.not
  br i1 %brmerge, label %pickNaN.exit.i.i.if.then24.i.i_crit_edge, label %parts128_minmax.exit

pickNaN.exit.i.i.if.then24.i.i_crit_edge:         ; preds = %pickNaN.exit.i.i
  %pa.sroa.gep.mux = select i1 %cond.fr.i.i, ptr %pb.sroa.gep, ptr %pa.sroa.gep
  %pa.mux = select i1 %cond.fr.i.i, ptr %pb, ptr %pa
  %.pre = load i64, ptr %pa.sroa.gep.mux, align 8
  br label %if.then24.i.i

16:                                               ; preds = %if.end13.i.i
  br i1 %cmp.i17.i.i, label %if.then24.i.i, label %parts128_minmax.exit

if.then24.i.i:                                    ; preds = %pickNaN.exit.i.i.if.then24.i.i_crit_edge, %16
  %17 = phi i64 [ %9, %16 ], [ %.pre, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i52.i = phi ptr [ %pb, %16 ], [ %pa.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %.ph.i52.i.sroa.phi = phi ptr [ %pb.sroa.gep, %16 ], [ %pa.sroa.gep.mux, %pickNaN.exit.i.i.if.then24.i.i_crit_edge ]
  %or4.i.i.i.i = or i64 %17, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.ph.i52.i.sroa.phi, align 8
  store i8 4, ptr %.ph.i52.i, align 8
  br label %parts128_minmax.exit

if.end35.i:                                       ; preds = %entry
  %18 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %19 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i10, align 4
  %cmp37.not.i = icmp eq i32 %or.i, 4
  br i1 %cmp37.not.i, label %if.end59.i, label %if.then45.i

if.then45.i:                                      ; preds = %if.end35.i
  switch i8 %2, label %do.body.i [
    i8 2, label %sw.epilog.i
    i8 3, label %sw.bb48.i
    i8 1, label %sw.bb49.i
  ]

sw.bb48.i:                                        ; preds = %if.then45.i
  br label %sw.epilog.i

sw.bb49.i:                                        ; preds = %if.then45.i
  br label %sw.epilog.i

do.body.i:                                        ; preds = %if.then45.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1375, ptr noundef nonnull @__func__.parts128_minmax, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %sw.bb49.i, %sw.bb48.i, %if.then45.i
  %a_exp.0.i = phi i32 [ -32768, %sw.bb49.i ], [ 32767, %sw.bb48.i ], [ %18, %if.then45.i ]
  switch i8 %3, label %do.body56.i [
    i8 2, label %if.end59.i
    i8 3, label %sw.bb53.i
    i8 1, label %sw.bb54.i
  ]

sw.bb53.i:                                        ; preds = %sw.epilog.i
  br label %if.end59.i

sw.bb54.i:                                        ; preds = %sw.epilog.i
  br label %if.end59.i

do.body56.i:                                      ; preds = %sw.epilog.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1388, ptr noundef nonnull @__func__.parts128_minmax, ptr noundef null) #16
  unreachable

if.end59.i:                                       ; preds = %sw.bb54.i, %sw.bb53.i, %sw.epilog.i, %if.end35.i
  %a_exp.1.i = phi i32 [ %a_exp.0.i, %sw.bb54.i ], [ %a_exp.0.i, %sw.bb53.i ], [ %a_exp.0.i, %sw.epilog.i ], [ %18, %if.end35.i ]
  %b_exp.0.i = phi i32 [ -32768, %sw.bb54.i ], [ 32767, %sw.bb53.i ], [ %19, %sw.epilog.i ], [ %19, %if.end35.i ]
  %sub.i = sub i32 %a_exp.1.i, %b_exp.0.i
  %cmp60.i = icmp eq i32 %sub.i, 0
  br i1 %cmp60.i, label %if.then62.i, label %if.end64.i

if.then62.i:                                      ; preds = %if.end59.i
  %20 = load i64, ptr %pa.sroa.gep, align 8
  %21 = load i64, ptr %pb.sroa.gep, align 8
  %cmp.i40.i = icmp eq i64 %20, %21
  br i1 %cmp.i40.i, label %if.then.i41.i, label %if.end5.i.i

if.then.i41.i:                                    ; preds = %if.then62.i
  %22 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %23 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i12, align 8
  %cmp3.i.i = icmp eq i64 %22, %23
  br i1 %cmp3.i.i, label %if.then69.i, label %if.end5.i.i

if.end5.i.i:                                      ; preds = %if.then.i41.i, %if.then62.i
  %ta.0.i.i = phi i64 [ %22, %if.then.i41.i ], [ %20, %if.then62.i ]
  %tb.0.i.i = phi i64 [ %23, %if.then.i41.i ], [ %21, %if.then62.i ]
  %cmp6.i.i = icmp ult i64 %ta.0.i.i, %tb.0.i.i
  %cond.i.i = select i1 %cmp6.i.i, i32 -1, i32 1
  br label %if.end64.i

if.end64.i:                                       ; preds = %if.end5.i.i, %if.end59.i
  %cmp.0.i = phi i32 [ %sub.i, %if.end59.i ], [ %cond.i.i, %if.end5.i.i ]
  %and65.i = and i32 %flags, 4
  %tobool66.i = icmp eq i32 %and65.i, 0
  br i1 %tobool66.i, label %if.then69.i, label %if.end88.i

if.then69.i:                                      ; preds = %if.end64.i, %if.then.i41.i
  %cmp.047.i = phi i32 [ %cmp.0.i, %if.end64.i ], [ 0, %if.then.i41.i ]
  %24 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %25 = and i8 %24, 1
  %tobool70.not.i = icmp eq i8 %25, 0
  %26 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i9, align 1
  %27 = and i8 %26, 1
  %cmp75.not.i = icmp eq i8 %25, %27
  br i1 %cmp75.not.i, label %if.else.i, label %if.then77.i

if.then77.i:                                      ; preds = %if.then69.i
  %cond81.i = select i1 %tobool70.not.i, i32 1, i32 -1
  br label %if.end88.i

if.else.i:                                        ; preds = %if.then69.i
  %sub85.i = sub i32 0, %cmp.047.i
  %spec.select.i = select i1 %tobool70.not.i, i32 %cmp.047.i, i32 %sub85.i
  br label %if.end88.i

if.end88.i:                                       ; preds = %if.else.i, %if.then77.i, %if.end64.i
  %cmp.1.i = phi i32 [ %cond81.i, %if.then77.i ], [ %cmp.0.i, %if.end64.i ], [ %spec.select.i, %if.else.i ]
  %and89.i = and i32 %flags, 1
  %tobool90.not.i = icmp eq i32 %and89.i, 0
  %sub92.i = sub i32 0, %cmp.1.i
  %spec.select38.i = select i1 %tobool90.not.i, i32 %cmp.1.i, i32 %sub92.i
  %cmp94.i = icmp slt i32 %spec.select38.i, 0
  %cond99.i = select i1 %cmp94.i, ptr %pb, ptr %pa
  br label %parts128_minmax.exit

parts128_minmax.exit:                             ; preds = %pickNaN.exit.i.i, %if.then14.i, %if.then25.i, %if.then3.i.i, %if.then6.i.i.i, %lor.lhs.false.i.i.i, %16, %if.then24.i.i, %if.end88.i
  %retval.0.i = phi ptr [ %cond32.i, %if.then25.i ], [ %cond.i, %if.then14.i ], [ %cond99.i, %if.end88.i ], [ %pa, %if.then3.i.i ], [ %.ph.i52.i, %if.then24.i.i ], [ %pb, %16 ], [ %pa, %if.then6.i.i.i ], [ %spec.select57.i, %lor.lhs.false.i.i.i ], [ %pb, %pickNaN.exit.i.i ]
  %call1 = call fastcc { i64, i64 } @float128_round_pack_canonical(ptr noundef nonnull %retval.0.i, ptr noundef %s)
  ret { i64, i64 } %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_maxnum(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i64 } @float128_minmax(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr noundef %s, i32 noundef 2)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_maxnummag(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i64 } @float128_minmax(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr noundef %s, i32 noundef 6)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_maximum_number(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i64 } @float128_minmax(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr noundef %s, i32 noundef 8)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_min(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i64 } @float128_minmax(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr noundef %s, i32 noundef 1)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_minnum(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i64 } @float128_minmax(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr noundef %s, i32 noundef 3)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_minnummag(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i64 } @float128_minmax(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr noundef %s, i32 noundef 7)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_minimum_number(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc { i64, i64 } @float128_minmax(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr noundef %s, i32 noundef 9)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float16_compare(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float16_do_compare(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i1 noundef zeroext false), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @float16_do_compare(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s, i1 noundef zeroext %is_quiet) unnamed_addr #3 {
entry:
  %f.lobit.i.i = lshr i16 %a, 15
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  switch i16 %1, label %if.then33.i.i [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %float16a_unpack_canonical.exit, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %float16a_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  br label %float16a_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %float16a_unpack_canonical.exit, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  %conv.i.i.i = zext nneg i16 %1 to i32
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  br label %float16a_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  br label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i, %if.then.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.else49.i.i
  %pa.sroa.13.0 = phi i32 [ %add.i.i, %frac64_normalize.exit.i.i ], [ 0, %if.then10.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ 31, %if.else49.i.i ], [ 0, %if.then.i.i ], [ 31, %lor.lhs.false.i.i ]
  %pa.sroa.0.0 = phi i8 [ 2, %frac64_normalize.exit.i.i ], [ 1, %if.then10.i.i ], [ 2, %if.then33.i.i ], [ %conv53.i.i, %if.else49.i.i ], [ 1, %if.then.i.i ], [ 3, %lor.lhs.false.i.i ]
  %pa.sroa.17.0 = phi i64 [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ 0, %if.then10.i.i ], [ %or.i.i, %if.then33.i.i ], [ %shl.i31.i.i, %if.else49.i.i ], [ 0, %if.then.i.i ], [ 0, %lor.lhs.false.i.i ]
  %f.lobit.i.i27 = lshr i16 %b, 15
  %7 = lshr i16 %b, 10
  %8 = and i16 %7, 31
  %9 = and i16 %b, 1023
  %and.i10.i.i30 = zext nneg i16 %9 to i64
  switch i16 %8, label %if.then33.i.i44 [
    i16 0, label %if.then.i.i48
    i16 31, label %lor.lhs.false.i.i37
  ]

if.then.i.i48:                                    ; preds = %float16a_unpack_canonical.exit
  %cmp.i.i.i49 = icmp eq i16 %9, 0
  br i1 %cmp.i.i.i49, label %float16a_unpack_canonical.exit61, label %if.else.i.i50

if.else.i.i50:                                    ; preds = %if.then.i.i48
  %flush_inputs_to_zero.i.i51 = getelementptr inbounds i8, ptr %s, i64 6
  %10 = load i8, ptr %flush_inputs_to_zero.i.i51, align 2
  %11 = and i8 %10, 1
  %tobool9.not.i.i52 = icmp eq i8 %11, 0
  br i1 %tobool9.not.i.i52, label %frac64_normalize.exit.i.i55, label %if.then10.i.i53

if.then10.i.i53:                                  ; preds = %if.else.i.i50
  %12 = load i16, ptr %s, align 2
  %or1.i.i.i54 = or i16 %12, 32
  store i16 %or1.i.i.i54, ptr %s, align 2
  br label %float16a_unpack_canonical.exit61

frac64_normalize.exit.i.i55:                      ; preds = %if.else.i.i50
  %13 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i30, i1 true), !range !5
  %cast.i.i.i.i56 = trunc i64 %13 to i32
  %shl.i.i.i57 = shl i64 %and.i10.i.i30, %13
  %add.i.i59 = sub nsw i32 39, %cast.i.i.i.i56
  br label %float16a_unpack_canonical.exit61

lor.lhs.false.i.i37:                              ; preds = %float16a_unpack_canonical.exit
  %cmp.i29.i.i38 = icmp eq i16 %9, 0
  br i1 %cmp.i29.i.i38, label %float16a_unpack_canonical.exit61, label %if.else49.i.i39

if.then33.i.i44:                                  ; preds = %float16a_unpack_canonical.exit
  %conv.i.i.i29 = zext nneg i16 %8 to i32
  %sub37.i.i45 = add nsw i32 %conv.i.i.i29, -15
  %shl.i28.i.i46 = shl nuw nsw i64 %and.i10.i.i30, 53
  %or.i.i47 = or disjoint i64 %shl.i28.i.i46, -9223372036854775808
  br label %float16a_unpack_canonical.exit61

if.else49.i.i39:                                  ; preds = %lor.lhs.false.i.i37
  %shl.i31.i.i40 = shl nuw nsw i64 %and.i10.i.i30, 53
  %tobool.not.i32.i.i41 = icmp ult i16 %9, 512
  %conv53.i.i42 = select i1 %tobool.not.i32.i.i41, i8 5, i8 4
  br label %float16a_unpack_canonical.exit61

float16a_unpack_canonical.exit61:                 ; preds = %lor.lhs.false.i.i37, %if.then.i.i48, %if.then10.i.i53, %frac64_normalize.exit.i.i55, %if.then33.i.i44, %if.else49.i.i39
  %pb.sroa.16.0 = phi i64 [ %shl.i.i.i57, %frac64_normalize.exit.i.i55 ], [ 0, %if.then10.i.i53 ], [ %or.i.i47, %if.then33.i.i44 ], [ %shl.i31.i.i40, %if.else49.i.i39 ], [ 0, %if.then.i.i48 ], [ 0, %lor.lhs.false.i.i37 ]
  %pb.sroa.12.0 = phi i32 [ %add.i.i59, %frac64_normalize.exit.i.i55 ], [ 0, %if.then10.i.i53 ], [ %sub37.i.i45, %if.then33.i.i44 ], [ 31, %if.else49.i.i39 ], [ 0, %if.then.i.i48 ], [ 31, %lor.lhs.false.i.i37 ]
  %pb.sroa.0.0 = phi i8 [ 2, %frac64_normalize.exit.i.i55 ], [ 1, %if.then10.i.i53 ], [ 2, %if.then33.i.i44 ], [ %conv53.i.i42, %if.else49.i.i39 ], [ 1, %if.then.i.i48 ], [ 3, %lor.lhs.false.i.i37 ]
  %conv.i = zext nneg i8 %pa.sroa.0.0 to i32
  %shl.i = shl nuw nsw i32 1, %conv.i
  %conv2.i = zext nneg i8 %pb.sroa.0.0 to i32
  %shl3.i = shl nuw nsw i32 1, %conv2.i
  %or.i = or i32 %shl3.i, %shl.i
  %cmp.i = icmp eq i32 %or.i, 4
  br i1 %cmp.i, label %if.then.i, label %if.end32.i

if.then.i:                                        ; preds = %float16a_unpack_canonical.exit61
  %cmp13.i.not = icmp eq i16 %f.lobit.i.i, %f.lobit.i.i27
  br i1 %cmp13.i.not, label %if.end.i, label %a_sign.i

if.end.i:                                         ; preds = %if.then.i
  %cmp17.i = icmp eq i32 %pa.sroa.13.0, %pb.sroa.12.0
  br i1 %cmp17.i, label %if.then19.i, label %if.else.i

if.then19.i:                                      ; preds = %if.end.i
  %cmp.i62 = icmp eq i64 %pa.sroa.17.0, %pb.sroa.16.0
  %cmp1.i = icmp ult i64 %pa.sroa.17.0, %pb.sroa.16.0
  %cond.i63 = select i1 %cmp1.i, i32 -1, i32 1
  %cond2.i = select i1 %cmp.i62, i32 0, i32 %cond.i63
  br label %if.end27.i

if.else.i:                                        ; preds = %if.end.i
  %cmp22.i = icmp slt i32 %pa.sroa.13.0, %pb.sroa.12.0
  %. = select i1 %cmp22.i, i32 -1, i32 1
  br label %if.end27.i

if.end27.i:                                       ; preds = %if.else.i, %if.then19.i
  %cmp7.i.0 = phi i32 [ %cond2.i, %if.then19.i ], [ %., %if.else.i ]
  %sub.i = sub nsw i32 0, %cmp7.i.0
  %tobool29.i.not70 = icmp slt i16 %a, 0
  %spec.select = select i1 %tobool29.i.not70, i32 %sub.i, i32 %cmp7.i.0
  br label %parts64_compare.exit

if.end32.i:                                       ; preds = %float16a_unpack_canonical.exit61
  %and.i = and i32 %or.i, 48
  %tobool33.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool33.i.not, label %if.end49.i, label %if.then40.i

if.then40.i:                                      ; preds = %if.end32.i
  %and41.i = and i32 %or.i, 32
  %tobool42.i.not = icmp eq i32 %and41.i, 0
  br i1 %tobool42.i.not, label %if.else44.i, label %if.then43.i

if.then43.i:                                      ; preds = %if.then40.i
  %14 = load i16, ptr %s, align 2
  %or1.i = or i16 %14, 8193
  store i16 %or1.i, ptr %s, align 2
  br label %parts64_compare.exit

if.else44.i:                                      ; preds = %if.then40.i
  br i1 %is_quiet, label %parts64_compare.exit, label %if.then46.i

if.then46.i:                                      ; preds = %if.else44.i
  %15 = load i16, ptr %s, align 2
  %or1.i64 = or i16 %15, 1
  store i16 %or1.i64, ptr %s, align 2
  br label %parts64_compare.exit

if.end49.i:                                       ; preds = %if.end32.i
  %and50.i = and i32 %or.i, 2
  %tobool51.i.not = icmp eq i32 %and50.i, 0
  br i1 %tobool51.i.not, label %if.end63.i, label %if.then52.i

if.then52.i:                                      ; preds = %if.end49.i
  %cmp53.i = icmp eq i32 %or.i, 2
  br i1 %cmp53.i, label %parts64_compare.exit, label %if.else56.i

if.else56.i:                                      ; preds = %if.then52.i
  %cmp59.i = icmp eq i8 %pa.sroa.0.0, 1
  br i1 %cmp59.i, label %b_sign.i, label %a_sign.i

if.end63.i:                                       ; preds = %if.end49.i
  %cmp64.i = icmp eq i32 %or.i, 8
  br i1 %cmp64.i, label %if.then66.i, label %if.else77.i

if.then66.i:                                      ; preds = %if.end63.i
  %cmp73.i = icmp eq i16 %f.lobit.i.i, %f.lobit.i.i27
  br i1 %cmp73.i, label %parts64_compare.exit, label %a_sign.i

if.else77.i:                                      ; preds = %if.end63.i
  %cmp80.i = icmp eq i8 %pb.sroa.0.0, 3
  br i1 %cmp80.i, label %b_sign.i, label %if.else83.i

if.else83.i:                                      ; preds = %if.else77.i
  %cmp86.i = icmp eq i8 %pa.sroa.0.0, 3
  br i1 %cmp86.i, label %a_sign.i, label %if.else89.i

if.else89.i:                                      ; preds = %if.else83.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1472, ptr noundef nonnull @__func__.parts64_compare, ptr noundef nonnull @.str.15) #16
  unreachable

a_sign.i:                                         ; preds = %if.then66.i, %if.else83.i, %if.else56.i, %if.then.i
  %tobool94.i.not = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool94.i.not, i32 1, i32 -1
  br label %parts64_compare.exit

b_sign.i:                                         ; preds = %if.else77.i, %if.else56.i
  %tobool97.i.not = icmp sgt i16 %b, -1
  %cond99.i = select i1 %tobool97.i.not, i32 -1, i32 1
  br label %parts64_compare.exit

parts64_compare.exit:                             ; preds = %if.then66.i, %if.then52.i, %if.then43.i, %if.then46.i, %if.else44.i, %b_sign.i, %a_sign.i, %if.end27.i
  %retval.i.0 = phi i32 [ %cond.i, %a_sign.i ], [ %spec.select, %if.end27.i ], [ %cond99.i, %b_sign.i ], [ 2, %if.else44.i ], [ 2, %if.then46.i ], [ 2, %if.then43.i ], [ 0, %if.then52.i ], [ 0, %if.then66.i ]
  ret i32 %retval.i.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float16_compare_quiet(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float16_do_compare(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i1 noundef zeroext true), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_compare(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float32_hs_compare(i32 noundef %a, i32 noundef %b, ptr noundef %s, i1 noundef zeroext false), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @float32_hs_compare(i32 noundef %xa, i32 noundef %xb, ptr nocapture noundef %s, i1 noundef zeroext %is_quiet) unnamed_addr #3 {
entry:
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %s, i64 6
  %0 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %1 = and i8 %0, 1
  %tobool.i.not = icmp eq i8 %1, 0
  br i1 %tobool.i.not, label %float32_input_flush2.exit, label %if.end.i

if.end.i:                                         ; preds = %entry
  %and.i.i.i = and i32 %xa, 2139095040
  %cmp.i.i.i = icmp eq i32 %and.i.i.i, 0
  %and.i2.i.i = and i32 %xa, 2147483647
  %cmp.i3.i.i = icmp ne i32 %and.i2.i.i, 0
  %2 = and i1 %cmp.i.i.i, %cmp.i3.i.i
  br i1 %2, label %if.then.i, label %float32_input_flush__nocheck.exit

if.then.i:                                        ; preds = %if.end.i
  %.lobit.i = and i32 %xa, -2147483648
  %3 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %3, 32
  store i16 %or1.i.i, ptr %s, align 2
  br label %float32_input_flush__nocheck.exit

float32_input_flush__nocheck.exit:                ; preds = %if.end.i, %if.then.i
  %ua.sroa.0.0 = phi i32 [ %.lobit.i, %if.then.i ], [ %xa, %if.end.i ]
  %and.i.i.i7 = and i32 %xb, 2139095040
  %cmp.i.i.i8 = icmp eq i32 %and.i.i.i7, 0
  %and.i2.i.i9 = and i32 %xb, 2147483647
  %cmp.i3.i.i10 = icmp ne i32 %and.i2.i.i9, 0
  %4 = and i1 %cmp.i.i.i8, %cmp.i3.i.i10
  br i1 %4, label %if.then.i12, label %float32_input_flush2.exit

if.then.i12:                                      ; preds = %float32_input_flush__nocheck.exit
  %.lobit.i13 = and i32 %xb, -2147483648
  %5 = load i16, ptr %s, align 2
  %or1.i.i14 = or i16 %5, 32
  store i16 %or1.i.i14, ptr %s, align 2
  br label %float32_input_flush2.exit

float32_input_flush2.exit:                        ; preds = %if.then.i12, %float32_input_flush__nocheck.exit, %entry
  %ua.sroa.0.1 = phi i32 [ %xa, %entry ], [ %ua.sroa.0.0, %float32_input_flush__nocheck.exit ], [ %ua.sroa.0.0, %if.then.i12 ]
  %ub.sroa.0.1 = phi i32 [ %xb, %entry ], [ %xb, %float32_input_flush__nocheck.exit ], [ %.lobit.i13, %if.then.i12 ]
  %6 = bitcast i32 %ua.sroa.0.1 to float
  %7 = bitcast i32 %ub.sroa.0.1 to float
  %cmp = fcmp ult float %6, %7
  br i1 %cmp, label %if.end3, label %if.then

if.then:                                          ; preds = %float32_input_flush2.exit
  %cmp1 = fcmp ogt float %6, %7
  %. = zext i1 %cmp1 to i32
  br label %return

if.end3:                                          ; preds = %float32_input_flush2.exit
  %cmp4 = fcmp olt float %6, %7
  br i1 %cmp4, label %return, label %soft

soft:                                             ; preds = %if.end3
  %f.lobit.i.i = lshr i32 %ua.sroa.0.1, 31
  %shr.i8.i.i = lshr i32 %ua.sroa.0.1, 23
  %8 = and i32 %ua.sroa.0.1, 8388607
  %and.i10.i.i = zext nneg i32 %8 to i64
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %if.then33.i.i [
    i8 0, label %if.then.i32.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i32.i:                                    ; preds = %soft
  %cmp.i.i.i17 = icmp eq i32 %8, 0
  br i1 %cmp.i.i.i17, label %parts64_canonicalize.exit.i, label %if.else.i33.i

if.else.i33.i:                                    ; preds = %if.then.i32.i
  br i1 %tobool.i.not, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i33.i
  %9 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %9, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_canonicalize.exit.i

frac64_normalize.exit.i.i:                        ; preds = %if.else.i33.i
  %10 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %10 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %10
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  br label %parts64_canonicalize.exit.i

lor.lhs.false.i.i:                                ; preds = %soft
  %cmp.i29.i.i = icmp eq i32 %8, 0
  br i1 %cmp.i29.i.i, label %parts64_canonicalize.exit.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %soft
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i31.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  br label %parts64_canonicalize.exit.i

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %tobool.not.i32.i.i = icmp ult i32 %8, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  br label %parts64_canonicalize.exit.i

parts64_canonicalize.exit.i:                      ; preds = %if.else49.i.i, %if.then33.i.i, %lor.lhs.false.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then.i32.i
  %pa.sroa.13.0.i = phi i32 [ %add.i.i, %frac64_normalize.exit.i.i ], [ 0, %if.then10.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ 255, %if.else49.i.i ], [ 0, %if.then.i32.i ], [ 255, %lor.lhs.false.i.i ]
  %pa.sroa.0.0.i = phi i8 [ 2, %frac64_normalize.exit.i.i ], [ 1, %if.then10.i.i ], [ 2, %if.then33.i.i ], [ %conv53.i.i, %if.else49.i.i ], [ 1, %if.then.i32.i ], [ 3, %lor.lhs.false.i.i ]
  %pa.sroa.18.0.i = phi i64 [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ 0, %if.then10.i.i ], [ %or.i31.i, %if.then33.i.i ], [ %shl.i31.i.i, %if.else49.i.i ], [ 0, %if.then.i32.i ], [ 0, %lor.lhs.false.i.i ]
  %f.lobit.i34.i = lshr i32 %ub.sroa.0.1, 31
  %shr.i8.i36.i = lshr i32 %ub.sroa.0.1, 23
  %11 = and i32 %ub.sroa.0.1, 8388607
  %and.i10.i38.i = zext nneg i32 %11 to i64
  %trunc90.i = trunc i32 %shr.i8.i36.i to i8
  switch i8 %trunc90.i, label %if.then33.i54.i [
    i8 0, label %if.then.i58.i
    i8 -1, label %lor.lhs.false.i46.i
  ]

if.then.i58.i:                                    ; preds = %parts64_canonicalize.exit.i
  %cmp.i.i60.i = icmp eq i32 %11, 0
  br i1 %cmp.i.i60.i, label %parts64_canonicalize.exit72.i, label %if.else.i61.i

if.else.i61.i:                                    ; preds = %if.then.i58.i
  br i1 %tobool.i.not, label %frac64_normalize.exit.i66.i, label %if.then10.i64.i

if.then10.i64.i:                                  ; preds = %if.else.i61.i
  %12 = load i16, ptr %s, align 2
  %or1.i.i65.i = or i16 %12, 32
  store i16 %or1.i.i65.i, ptr %s, align 2
  br label %parts64_canonicalize.exit72.i

frac64_normalize.exit.i66.i:                      ; preds = %if.else.i61.i
  %13 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i38.i, i1 true), !range !5
  %cast.i.i.i67.i = trunc i64 %13 to i32
  %shl.i.i68.i = shl i64 %and.i10.i38.i, %13
  %add.i70.i = sub nuw nsw i32 -86, %cast.i.i.i67.i
  br label %parts64_canonicalize.exit72.i

lor.lhs.false.i46.i:                              ; preds = %parts64_canonicalize.exit.i
  %cmp.i29.i48.i = icmp eq i32 %11, 0
  br i1 %cmp.i29.i48.i, label %parts64_canonicalize.exit72.i, label %if.else49.i49.i

if.then33.i54.i:                                  ; preds = %parts64_canonicalize.exit.i
  %and.i9.i37.i = and i32 %shr.i8.i36.i, 255
  %sub37.i55.i = add nsw i32 %and.i9.i37.i, -127
  %shl.i28.i56.i = shl nuw nsw i64 %and.i10.i38.i, 40
  %or.i57.i = or disjoint i64 %shl.i28.i56.i, -9223372036854775808
  br label %parts64_canonicalize.exit72.i

if.else49.i49.i:                                  ; preds = %lor.lhs.false.i46.i
  %shl.i31.i50.i = shl nuw nsw i64 %and.i10.i38.i, 40
  %tobool.not.i32.i51.i = icmp ult i32 %11, 4194304
  %conv53.i52.i = select i1 %tobool.not.i32.i51.i, i8 5, i8 4
  br label %parts64_canonicalize.exit72.i

parts64_canonicalize.exit72.i:                    ; preds = %if.else49.i49.i, %if.then33.i54.i, %lor.lhs.false.i46.i, %frac64_normalize.exit.i66.i, %if.then10.i64.i, %if.then.i58.i
  %pb.sroa.17.0.i = phi i64 [ %shl.i.i68.i, %frac64_normalize.exit.i66.i ], [ 0, %if.then10.i64.i ], [ %or.i57.i, %if.then33.i54.i ], [ %shl.i31.i50.i, %if.else49.i49.i ], [ 0, %if.then.i58.i ], [ 0, %lor.lhs.false.i46.i ]
  %pb.sroa.12.0.i = phi i32 [ %add.i70.i, %frac64_normalize.exit.i66.i ], [ 0, %if.then10.i64.i ], [ %sub37.i55.i, %if.then33.i54.i ], [ 255, %if.else49.i49.i ], [ 0, %if.then.i58.i ], [ 255, %lor.lhs.false.i46.i ]
  %pb.sroa.0.0.i = phi i8 [ 2, %frac64_normalize.exit.i66.i ], [ 1, %if.then10.i64.i ], [ 2, %if.then33.i54.i ], [ %conv53.i52.i, %if.else49.i49.i ], [ 1, %if.then.i58.i ], [ 3, %lor.lhs.false.i46.i ]
  %conv.i.i = zext nneg i8 %pa.sroa.0.0.i to i32
  %shl.i.i = shl nuw nsw i32 1, %conv.i.i
  %conv2.i.i = zext nneg i8 %pb.sroa.0.0.i to i32
  %shl3.i.i = shl nuw nsw i32 1, %conv2.i.i
  %or.i.i = or i32 %shl3.i.i, %shl.i.i
  %cmp.i.i = icmp eq i32 %or.i.i, 4
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end32.i.i

if.then.i.i:                                      ; preds = %parts64_canonicalize.exit72.i
  %cmp13.i.not.i = icmp eq i32 %f.lobit.i.i, %f.lobit.i34.i
  br i1 %cmp13.i.not.i, label %if.end.i.i, label %a_sign.i.i

if.end.i.i:                                       ; preds = %if.then.i.i
  %cmp17.i.i = icmp eq i32 %pa.sroa.13.0.i, %pb.sroa.12.0.i
  br i1 %cmp17.i.i, label %if.then19.i.i, label %if.else.i.i

if.then19.i.i:                                    ; preds = %if.end.i.i
  %cmp.i73.i = icmp eq i64 %pa.sroa.18.0.i, %pb.sroa.17.0.i
  %cmp1.i.i = icmp ult i64 %pa.sroa.18.0.i, %pb.sroa.17.0.i
  %cond.i74.i = select i1 %cmp1.i.i, i32 -1, i32 1
  %cond2.i.i = select i1 %cmp.i73.i, i32 0, i32 %cond.i74.i
  br label %if.end27.i.i

if.else.i.i:                                      ; preds = %if.end.i.i
  %cmp22.i.i = icmp slt i32 %pa.sroa.13.0.i, %pb.sroa.12.0.i
  %..i = select i1 %cmp22.i.i, i32 -1, i32 1
  br label %if.end27.i.i

if.end27.i.i:                                     ; preds = %if.else.i.i, %if.then19.i.i
  %cmp7.i.0.i = phi i32 [ %cond2.i.i, %if.then19.i.i ], [ %..i, %if.else.i.i ]
  %sub.i.i = sub nsw i32 0, %cmp7.i.0.i
  %tobool29.i.not89.i = icmp slt i32 %ua.sroa.0.1, 0
  %spec.select.i = select i1 %tobool29.i.not89.i, i32 %sub.i.i, i32 %cmp7.i.0.i
  br label %return

if.end32.i.i:                                     ; preds = %parts64_canonicalize.exit72.i
  %and.i.i = and i32 %or.i.i, 48
  %tobool33.i.not.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool33.i.not.i, label %if.end49.i.i, label %if.then40.i.i

if.then40.i.i:                                    ; preds = %if.end32.i.i
  %and41.i.i = and i32 %or.i.i, 32
  %tobool42.i.not.i = icmp eq i32 %and41.i.i, 0
  br i1 %tobool42.i.not.i, label %if.else44.i.i, label %if.then43.i.i

if.then43.i.i:                                    ; preds = %if.then40.i.i
  %14 = load i16, ptr %s, align 2
  %or1.i.i16 = or i16 %14, 8193
  store i16 %or1.i.i16, ptr %s, align 2
  br label %return

if.else44.i.i:                                    ; preds = %if.then40.i.i
  br i1 %is_quiet, label %return, label %if.then46.i.i

if.then46.i.i:                                    ; preds = %if.else44.i.i
  %15 = load i16, ptr %s, align 2
  %or1.i75.i = or i16 %15, 1
  store i16 %or1.i75.i, ptr %s, align 2
  br label %return

if.end49.i.i:                                     ; preds = %if.end32.i.i
  %and50.i.i = and i32 %or.i.i, 2
  %tobool51.i.not.i = icmp eq i32 %and50.i.i, 0
  br i1 %tobool51.i.not.i, label %if.end63.i.i, label %if.then52.i.i

if.then52.i.i:                                    ; preds = %if.end49.i.i
  %cmp53.i.i = icmp eq i32 %or.i.i, 2
  br i1 %cmp53.i.i, label %return, label %if.else56.i.i

if.else56.i.i:                                    ; preds = %if.then52.i.i
  %cmp59.i.i = icmp eq i8 %pa.sroa.0.0.i, 1
  br i1 %cmp59.i.i, label %b_sign.i.i, label %a_sign.i.i

if.end63.i.i:                                     ; preds = %if.end49.i.i
  %cmp64.i.i = icmp eq i32 %or.i.i, 8
  br i1 %cmp64.i.i, label %if.then66.i.i, label %if.else77.i.i

if.then66.i.i:                                    ; preds = %if.end63.i.i
  %cmp73.i.i = icmp eq i32 %f.lobit.i.i, %f.lobit.i34.i
  br i1 %cmp73.i.i, label %return, label %a_sign.i.i

if.else77.i.i:                                    ; preds = %if.end63.i.i
  %cmp80.i.i = icmp eq i8 %pb.sroa.0.0.i, 3
  br i1 %cmp80.i.i, label %b_sign.i.i, label %if.else83.i.i

if.else83.i.i:                                    ; preds = %if.else77.i.i
  %cmp86.i.i = icmp eq i8 %pa.sroa.0.0.i, 3
  br i1 %cmp86.i.i, label %a_sign.i.i, label %if.else89.i.i

if.else89.i.i:                                    ; preds = %if.else83.i.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1472, ptr noundef nonnull @__func__.parts64_compare, ptr noundef nonnull @.str.15) #16
  unreachable

a_sign.i.i:                                       ; preds = %if.else83.i.i, %if.then66.i.i, %if.else56.i.i, %if.then.i.i
  %tobool94.i.not.i = icmp sgt i32 %ua.sroa.0.1, -1
  %cond.i.i = select i1 %tobool94.i.not.i, i32 1, i32 -1
  br label %return

b_sign.i.i:                                       ; preds = %if.else77.i.i, %if.else56.i.i
  %tobool97.i.not.i = icmp sgt i32 %ub.sroa.0.1, -1
  %cond99.i.i = select i1 %tobool97.i.not.i, i32 -1, i32 1
  br label %return

return:                                           ; preds = %b_sign.i.i, %a_sign.i.i, %if.then66.i.i, %if.then52.i.i, %if.then46.i.i, %if.else44.i.i, %if.then43.i.i, %if.end27.i.i, %if.end3, %if.then
  %retval.0 = phi i32 [ %., %if.then ], [ -1, %if.end3 ], [ %cond.i.i, %a_sign.i.i ], [ %spec.select.i, %if.end27.i.i ], [ %cond99.i.i, %b_sign.i.i ], [ 2, %if.else44.i.i ], [ 2, %if.then46.i.i ], [ 2, %if.then43.i.i ], [ 0, %if.then52.i.i ], [ 0, %if.then66.i.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_compare_quiet(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float32_hs_compare(i32 noundef %a, i32 noundef %b, ptr noundef %s, i1 noundef zeroext true), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float64_compare(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float64_hs_compare(i64 noundef %a, i64 noundef %b, ptr noundef %s, i1 noundef zeroext false), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @float64_hs_compare(i64 noundef %xa, i64 noundef %xb, ptr nocapture noundef %s, i1 noundef zeroext %is_quiet) unnamed_addr #3 {
entry:
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %s, i64 6
  %0 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %1 = and i8 %0, 1
  %tobool.i.not = icmp eq i8 %1, 0
  br i1 %tobool.i.not, label %float64_input_flush2.exit, label %if.end.i

if.end.i:                                         ; preds = %entry
  %and.i.i.i = and i64 %xa, 9218868437227405312
  %cmp.i.i.i = icmp eq i64 %and.i.i.i, 0
  %and.i2.i.i = and i64 %xa, 9223372036854775807
  %cmp.i3.i.i = icmp ne i64 %and.i2.i.i, 0
  %2 = and i1 %cmp.i.i.i, %cmp.i3.i.i
  br i1 %2, label %if.then.i, label %float64_input_flush__nocheck.exit

if.then.i:                                        ; preds = %if.end.i
  %.lobit.i = and i64 %xa, -9223372036854775808
  %3 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %3, 32
  store i16 %or1.i.i, ptr %s, align 2
  br label %float64_input_flush__nocheck.exit

float64_input_flush__nocheck.exit:                ; preds = %if.end.i, %if.then.i
  %ua.sroa.0.0 = phi i64 [ %.lobit.i, %if.then.i ], [ %xa, %if.end.i ]
  %and.i.i.i7 = and i64 %xb, 9218868437227405312
  %cmp.i.i.i8 = icmp eq i64 %and.i.i.i7, 0
  %and.i2.i.i9 = and i64 %xb, 9223372036854775807
  %cmp.i3.i.i10 = icmp ne i64 %and.i2.i.i9, 0
  %4 = and i1 %cmp.i.i.i8, %cmp.i3.i.i10
  br i1 %4, label %if.then.i12, label %float64_input_flush2.exit

if.then.i12:                                      ; preds = %float64_input_flush__nocheck.exit
  %.lobit.i13 = and i64 %xb, -9223372036854775808
  %5 = load i16, ptr %s, align 2
  %or1.i.i14 = or i16 %5, 32
  store i16 %or1.i.i14, ptr %s, align 2
  br label %float64_input_flush2.exit

float64_input_flush2.exit:                        ; preds = %if.then.i12, %float64_input_flush__nocheck.exit, %entry
  %ua.sroa.0.1 = phi i64 [ %xa, %entry ], [ %ua.sroa.0.0, %float64_input_flush__nocheck.exit ], [ %ua.sroa.0.0, %if.then.i12 ]
  %ub.sroa.0.1 = phi i64 [ %xb, %entry ], [ %xb, %float64_input_flush__nocheck.exit ], [ %.lobit.i13, %if.then.i12 ]
  %6 = bitcast i64 %ua.sroa.0.1 to double
  %7 = bitcast i64 %ub.sroa.0.1 to double
  %cmp = fcmp ult double %6, %7
  br i1 %cmp, label %if.end3, label %if.then

if.then:                                          ; preds = %float64_input_flush2.exit
  %cmp1 = fcmp ogt double %6, %7
  %. = zext i1 %cmp1 to i32
  br label %return

if.end3:                                          ; preds = %float64_input_flush2.exit
  %cmp4 = fcmp olt double %6, %7
  br i1 %cmp4, label %return, label %soft

soft:                                             ; preds = %if.end3
  %f.lobit.i.i = lshr i64 %ua.sroa.0.1, 63
  %shr.i8.i.i = lshr i64 %ua.sroa.0.1, 52
  %8 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %8, 2047
  %and.i9.i.i = and i64 %ua.sroa.0.1, 4503599627370495
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i32.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i32.i:                                    ; preds = %soft
  %cmp.i.i.i17 = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i17, label %parts64_canonicalize.exit.i, label %if.else.i33.i

if.else.i33.i:                                    ; preds = %if.then.i32.i
  br i1 %tobool.i.not, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i33.i
  %9 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %9, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  br label %parts64_canonicalize.exit.i

frac64_normalize.exit.i.i:                        ; preds = %if.else.i33.i
  %10 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %10 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %10
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  br label %parts64_canonicalize.exit.i

lor.lhs.false.i.i:                                ; preds = %soft
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %parts64_canonicalize.exit.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %soft
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i31.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  br label %parts64_canonicalize.exit.i

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  br label %parts64_canonicalize.exit.i

parts64_canonicalize.exit.i:                      ; preds = %if.else49.i.i, %if.then33.i.i, %lor.lhs.false.i.i, %frac64_normalize.exit.i.i, %if.then10.i.i, %if.then.i32.i
  %pa.sroa.13.0.i = phi i32 [ %add.i.i, %frac64_normalize.exit.i.i ], [ 0, %if.then10.i.i ], [ %sub37.i.i, %if.then33.i.i ], [ 2047, %if.else49.i.i ], [ 0, %if.then.i32.i ], [ 2047, %lor.lhs.false.i.i ]
  %pa.sroa.0.0.i = phi i8 [ 2, %frac64_normalize.exit.i.i ], [ 1, %if.then10.i.i ], [ 2, %if.then33.i.i ], [ %conv53.i.i, %if.else49.i.i ], [ 1, %if.then.i32.i ], [ 3, %lor.lhs.false.i.i ]
  %pa.sroa.18.0.i = phi i64 [ %shl.i.i.i, %frac64_normalize.exit.i.i ], [ 0, %if.then10.i.i ], [ %or.i31.i, %if.then33.i.i ], [ %shl.i31.i.i, %if.else49.i.i ], [ 0, %if.then.i32.i ], [ 0, %lor.lhs.false.i.i ]
  %f.lobit.i34.i = lshr i64 %ub.sroa.0.1, 63
  %shr.i8.i36.i = lshr i64 %ub.sroa.0.1, 52
  %11 = trunc i64 %shr.i8.i36.i to i32
  %conv.i.i37.i = and i32 %11, 2047
  %and.i9.i38.i = and i64 %ub.sroa.0.1, 4503599627370495
  switch i32 %conv.i.i37.i, label %if.then33.i54.i [
    i32 0, label %if.then.i58.i
    i32 2047, label %lor.lhs.false.i46.i
  ]

if.then.i58.i:                                    ; preds = %parts64_canonicalize.exit.i
  %cmp.i.i60.i = icmp eq i64 %and.i9.i38.i, 0
  br i1 %cmp.i.i60.i, label %parts64_canonicalize.exit72.i, label %if.else.i61.i

if.else.i61.i:                                    ; preds = %if.then.i58.i
  br i1 %tobool.i.not, label %frac64_normalize.exit.i66.i, label %if.then10.i64.i

if.then10.i64.i:                                  ; preds = %if.else.i61.i
  %12 = load i16, ptr %s, align 2
  %or1.i.i65.i = or i16 %12, 32
  store i16 %or1.i.i65.i, ptr %s, align 2
  br label %parts64_canonicalize.exit72.i

frac64_normalize.exit.i66.i:                      ; preds = %if.else.i61.i
  %13 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i38.i, i1 true), !range !5
  %cast.i.i.i67.i = trunc i64 %13 to i32
  %shl.i.i68.i = shl i64 %and.i9.i38.i, %13
  %add.i70.i = sub nuw nsw i32 -1011, %cast.i.i.i67.i
  br label %parts64_canonicalize.exit72.i

lor.lhs.false.i46.i:                              ; preds = %parts64_canonicalize.exit.i
  %cmp.i29.i48.i = icmp eq i64 %and.i9.i38.i, 0
  br i1 %cmp.i29.i48.i, label %parts64_canonicalize.exit72.i, label %if.else49.i49.i

if.then33.i54.i:                                  ; preds = %parts64_canonicalize.exit.i
  %sub37.i55.i = add nsw i32 %conv.i.i37.i, -1023
  %shl.i28.i56.i = shl nuw nsw i64 %and.i9.i38.i, 11
  %or.i57.i = or disjoint i64 %shl.i28.i56.i, -9223372036854775808
  br label %parts64_canonicalize.exit72.i

if.else49.i49.i:                                  ; preds = %lor.lhs.false.i46.i
  %shl.i31.i50.i = shl nuw nsw i64 %and.i9.i38.i, 11
  %tobool.not.i32.i51.i = icmp ult i64 %and.i9.i38.i, 2251799813685248
  %conv53.i52.i = select i1 %tobool.not.i32.i51.i, i8 5, i8 4
  br label %parts64_canonicalize.exit72.i

parts64_canonicalize.exit72.i:                    ; preds = %if.else49.i49.i, %if.then33.i54.i, %lor.lhs.false.i46.i, %frac64_normalize.exit.i66.i, %if.then10.i64.i, %if.then.i58.i
  %pb.sroa.17.0.i = phi i64 [ %shl.i.i68.i, %frac64_normalize.exit.i66.i ], [ 0, %if.then10.i64.i ], [ %or.i57.i, %if.then33.i54.i ], [ %shl.i31.i50.i, %if.else49.i49.i ], [ 0, %if.then.i58.i ], [ 0, %lor.lhs.false.i46.i ]
  %pb.sroa.12.0.i = phi i32 [ %add.i70.i, %frac64_normalize.exit.i66.i ], [ 0, %if.then10.i64.i ], [ %sub37.i55.i, %if.then33.i54.i ], [ 2047, %if.else49.i49.i ], [ 0, %if.then.i58.i ], [ 2047, %lor.lhs.false.i46.i ]
  %pb.sroa.0.0.i = phi i8 [ 2, %frac64_normalize.exit.i66.i ], [ 1, %if.then10.i64.i ], [ 2, %if.then33.i54.i ], [ %conv53.i52.i, %if.else49.i49.i ], [ 1, %if.then.i58.i ], [ 3, %lor.lhs.false.i46.i ]
  %conv.i.i = zext nneg i8 %pa.sroa.0.0.i to i32
  %shl.i.i = shl nuw nsw i32 1, %conv.i.i
  %conv2.i.i = zext nneg i8 %pb.sroa.0.0.i to i32
  %shl3.i.i = shl nuw nsw i32 1, %conv2.i.i
  %or.i.i = or i32 %shl3.i.i, %shl.i.i
  %cmp.i.i = icmp eq i32 %or.i.i, 4
  br i1 %cmp.i.i, label %if.then.i.i, label %if.end32.i.i

if.then.i.i:                                      ; preds = %parts64_canonicalize.exit72.i
  %cmp13.i.not.i = icmp eq i64 %f.lobit.i.i, %f.lobit.i34.i
  br i1 %cmp13.i.not.i, label %if.end.i.i, label %a_sign.i.i

if.end.i.i:                                       ; preds = %if.then.i.i
  %cmp17.i.i = icmp eq i32 %pa.sroa.13.0.i, %pb.sroa.12.0.i
  br i1 %cmp17.i.i, label %if.then19.i.i, label %if.else.i.i

if.then19.i.i:                                    ; preds = %if.end.i.i
  %cmp.i73.i = icmp eq i64 %pa.sroa.18.0.i, %pb.sroa.17.0.i
  %cmp1.i.i = icmp ult i64 %pa.sroa.18.0.i, %pb.sroa.17.0.i
  %cond.i74.i = select i1 %cmp1.i.i, i32 -1, i32 1
  %cond2.i.i = select i1 %cmp.i73.i, i32 0, i32 %cond.i74.i
  br label %if.end27.i.i

if.else.i.i:                                      ; preds = %if.end.i.i
  %cmp22.i.i = icmp slt i32 %pa.sroa.13.0.i, %pb.sroa.12.0.i
  %..i = select i1 %cmp22.i.i, i32 -1, i32 1
  br label %if.end27.i.i

if.end27.i.i:                                     ; preds = %if.else.i.i, %if.then19.i.i
  %cmp7.i.0.i = phi i32 [ %cond2.i.i, %if.then19.i.i ], [ %..i, %if.else.i.i ]
  %sub.i.i = sub nsw i32 0, %cmp7.i.0.i
  %tobool29.i.not89.i = icmp slt i64 %ua.sroa.0.1, 0
  %spec.select.i = select i1 %tobool29.i.not89.i, i32 %sub.i.i, i32 %cmp7.i.0.i
  br label %return

if.end32.i.i:                                     ; preds = %parts64_canonicalize.exit72.i
  %and.i.i = and i32 %or.i.i, 48
  %tobool33.i.not.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool33.i.not.i, label %if.end49.i.i, label %if.then40.i.i

if.then40.i.i:                                    ; preds = %if.end32.i.i
  %and41.i.i = and i32 %or.i.i, 32
  %tobool42.i.not.i = icmp eq i32 %and41.i.i, 0
  br i1 %tobool42.i.not.i, label %if.else44.i.i, label %if.then43.i.i

if.then43.i.i:                                    ; preds = %if.then40.i.i
  %14 = load i16, ptr %s, align 2
  %or1.i.i16 = or i16 %14, 8193
  store i16 %or1.i.i16, ptr %s, align 2
  br label %return

if.else44.i.i:                                    ; preds = %if.then40.i.i
  br i1 %is_quiet, label %return, label %if.then46.i.i

if.then46.i.i:                                    ; preds = %if.else44.i.i
  %15 = load i16, ptr %s, align 2
  %or1.i75.i = or i16 %15, 1
  store i16 %or1.i75.i, ptr %s, align 2
  br label %return

if.end49.i.i:                                     ; preds = %if.end32.i.i
  %and50.i.i = and i32 %or.i.i, 2
  %tobool51.i.not.i = icmp eq i32 %and50.i.i, 0
  br i1 %tobool51.i.not.i, label %if.end63.i.i, label %if.then52.i.i

if.then52.i.i:                                    ; preds = %if.end49.i.i
  %cmp53.i.i = icmp eq i32 %or.i.i, 2
  br i1 %cmp53.i.i, label %return, label %if.else56.i.i

if.else56.i.i:                                    ; preds = %if.then52.i.i
  %cmp59.i.i = icmp eq i8 %pa.sroa.0.0.i, 1
  br i1 %cmp59.i.i, label %b_sign.i.i, label %a_sign.i.i

if.end63.i.i:                                     ; preds = %if.end49.i.i
  %cmp64.i.i = icmp eq i32 %or.i.i, 8
  br i1 %cmp64.i.i, label %if.then66.i.i, label %if.else77.i.i

if.then66.i.i:                                    ; preds = %if.end63.i.i
  %cmp73.i.i = icmp eq i64 %f.lobit.i.i, %f.lobit.i34.i
  br i1 %cmp73.i.i, label %return, label %a_sign.i.i

if.else77.i.i:                                    ; preds = %if.end63.i.i
  %cmp80.i.i = icmp eq i8 %pb.sroa.0.0.i, 3
  br i1 %cmp80.i.i, label %b_sign.i.i, label %if.else83.i.i

if.else83.i.i:                                    ; preds = %if.else77.i.i
  %cmp86.i.i = icmp eq i8 %pa.sroa.0.0.i, 3
  br i1 %cmp86.i.i, label %a_sign.i.i, label %if.else89.i.i

if.else89.i.i:                                    ; preds = %if.else83.i.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1472, ptr noundef nonnull @__func__.parts64_compare, ptr noundef nonnull @.str.15) #16
  unreachable

a_sign.i.i:                                       ; preds = %if.else83.i.i, %if.then66.i.i, %if.else56.i.i, %if.then.i.i
  %tobool94.i.not.i = icmp sgt i64 %ua.sroa.0.1, -1
  %cond.i.i = select i1 %tobool94.i.not.i, i32 1, i32 -1
  br label %return

b_sign.i.i:                                       ; preds = %if.else77.i.i, %if.else56.i.i
  %tobool97.i.not.i = icmp sgt i64 %ub.sroa.0.1, -1
  %cond99.i.i = select i1 %tobool97.i.not.i, i32 -1, i32 1
  br label %return

return:                                           ; preds = %b_sign.i.i, %a_sign.i.i, %if.then66.i.i, %if.then52.i.i, %if.then46.i.i, %if.else44.i.i, %if.then43.i.i, %if.end27.i.i, %if.end3, %if.then
  %retval.0 = phi i32 [ %., %if.then ], [ -1, %if.end3 ], [ %cond.i.i, %a_sign.i.i ], [ %spec.select.i, %if.end27.i.i ], [ %cond99.i.i, %b_sign.i.i ], [ 2, %if.else44.i.i ], [ 2, %if.then46.i.i ], [ 2, %if.then43.i.i ], [ 0, %if.then52.i.i ], [ 0, %if.then66.i.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float64_compare_quiet(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float64_hs_compare(i64 noundef %a, i64 noundef %b, ptr noundef %s, i1 noundef zeroext true), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bfloat16_compare(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @bfloat16_do_compare(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i1 noundef zeroext false), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @bfloat16_do_compare(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s, i1 noundef zeroext %is_quiet) unnamed_addr #3 {
entry:
  %f.lobit.i = lshr i16 %a, 15
  %0 = lshr i16 %a, 7
  %1 = and i16 %a, 127
  %and.i10.i = zext nneg i16 %1 to i64
  %trunc = trunc i16 %0 to i8
  switch i8 %trunc, label %if.then33.i [
    i8 0, label %if.then.i32
    i8 -1, label %lor.lhs.false.i
  ]

if.then.i32:                                      ; preds = %entry
  %cmp.i.i = icmp eq i16 %1, 0
  br i1 %cmp.i.i, label %parts64_canonicalize.exit, label %if.else.i33

if.else.i33:                                      ; preds = %if.then.i32
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %s, i64 6
  %2 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %3 = and i8 %2, 1
  %tobool9.not.i = icmp eq i8 %3, 0
  br i1 %tobool9.not.i, label %frac64_normalize.exit.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.else.i33
  %4 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %4, 32
  store i16 %or1.i.i, ptr %s, align 2
  br label %parts64_canonicalize.exit

frac64_normalize.exit.i:                          ; preds = %if.else.i33
  %5 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i, i1 true), !range !5
  %cast.i.i.i = trunc i64 %5 to i32
  %shl.i.i = shl i64 %and.i10.i, %5
  %add.i = sub nuw nsw i32 -70, %cast.i.i.i
  br label %parts64_canonicalize.exit

lor.lhs.false.i:                                  ; preds = %entry
  %cmp.i29.i = icmp eq i16 %1, 0
  br i1 %cmp.i29.i, label %parts64_canonicalize.exit, label %if.else49.i

if.then33.i:                                      ; preds = %entry
  %6 = and i16 %0, 255
  %conv.i.i = zext nneg i16 %6 to i32
  %sub37.i = add nsw i32 %conv.i.i, -127
  %shl.i28.i = shl nuw nsw i64 %and.i10.i, 56
  %or.i31 = or disjoint i64 %shl.i28.i, -9223372036854775808
  br label %parts64_canonicalize.exit

if.else49.i:                                      ; preds = %lor.lhs.false.i
  %shl.i31.i = shl nuw nsw i64 %and.i10.i, 56
  %tobool.not.i32.i = icmp ult i16 %1, 64
  %conv53.i = select i1 %tobool.not.i32.i, i8 5, i8 4
  br label %parts64_canonicalize.exit

parts64_canonicalize.exit:                        ; preds = %lor.lhs.false.i, %if.then.i32, %if.then10.i, %frac64_normalize.exit.i, %if.then33.i, %if.else49.i
  %pa.sroa.13.0 = phi i32 [ %add.i, %frac64_normalize.exit.i ], [ 0, %if.then10.i ], [ %sub37.i, %if.then33.i ], [ 255, %if.else49.i ], [ 0, %if.then.i32 ], [ 255, %lor.lhs.false.i ]
  %pa.sroa.0.0 = phi i8 [ 2, %frac64_normalize.exit.i ], [ 1, %if.then10.i ], [ 2, %if.then33.i ], [ %conv53.i, %if.else49.i ], [ 1, %if.then.i32 ], [ 3, %lor.lhs.false.i ]
  %pa.sroa.18.0 = phi i64 [ %shl.i.i, %frac64_normalize.exit.i ], [ 0, %if.then10.i ], [ %or.i31, %if.then33.i ], [ %shl.i31.i, %if.else49.i ], [ 0, %if.then.i32 ], [ 0, %lor.lhs.false.i ]
  %f.lobit.i34 = lshr i16 %b, 15
  %7 = lshr i16 %b, 7
  %8 = and i16 %b, 127
  %and.i10.i37 = zext nneg i16 %8 to i64
  %trunc89 = trunc i16 %7 to i8
  switch i8 %trunc89, label %if.then33.i53 [
    i8 0, label %if.then.i57
    i8 -1, label %lor.lhs.false.i45
  ]

if.then.i57:                                      ; preds = %parts64_canonicalize.exit
  %cmp.i.i59 = icmp eq i16 %8, 0
  br i1 %cmp.i.i59, label %parts64_canonicalize.exit71, label %if.else.i60

if.else.i60:                                      ; preds = %if.then.i57
  %flush_inputs_to_zero.i61 = getelementptr inbounds i8, ptr %s, i64 6
  %9 = load i8, ptr %flush_inputs_to_zero.i61, align 2
  %10 = and i8 %9, 1
  %tobool9.not.i62 = icmp eq i8 %10, 0
  br i1 %tobool9.not.i62, label %frac64_normalize.exit.i65, label %if.then10.i63

if.then10.i63:                                    ; preds = %if.else.i60
  %11 = load i16, ptr %s, align 2
  %or1.i.i64 = or i16 %11, 32
  store i16 %or1.i.i64, ptr %s, align 2
  br label %parts64_canonicalize.exit71

frac64_normalize.exit.i65:                        ; preds = %if.else.i60
  %12 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i37, i1 true), !range !5
  %cast.i.i.i66 = trunc i64 %12 to i32
  %shl.i.i67 = shl i64 %and.i10.i37, %12
  %add.i69 = sub nuw nsw i32 -70, %cast.i.i.i66
  br label %parts64_canonicalize.exit71

lor.lhs.false.i45:                                ; preds = %parts64_canonicalize.exit
  %cmp.i29.i47 = icmp eq i16 %8, 0
  br i1 %cmp.i29.i47, label %parts64_canonicalize.exit71, label %if.else49.i48

if.then33.i53:                                    ; preds = %parts64_canonicalize.exit
  %13 = and i16 %7, 255
  %conv.i.i36 = zext nneg i16 %13 to i32
  %sub37.i54 = add nsw i32 %conv.i.i36, -127
  %shl.i28.i55 = shl nuw nsw i64 %and.i10.i37, 56
  %or.i56 = or disjoint i64 %shl.i28.i55, -9223372036854775808
  br label %parts64_canonicalize.exit71

if.else49.i48:                                    ; preds = %lor.lhs.false.i45
  %shl.i31.i49 = shl nuw nsw i64 %and.i10.i37, 56
  %tobool.not.i32.i50 = icmp ult i16 %8, 64
  %conv53.i51 = select i1 %tobool.not.i32.i50, i8 5, i8 4
  br label %parts64_canonicalize.exit71

parts64_canonicalize.exit71:                      ; preds = %lor.lhs.false.i45, %if.then.i57, %if.then10.i63, %frac64_normalize.exit.i65, %if.then33.i53, %if.else49.i48
  %pb.sroa.17.0 = phi i64 [ %shl.i.i67, %frac64_normalize.exit.i65 ], [ 0, %if.then10.i63 ], [ %or.i56, %if.then33.i53 ], [ %shl.i31.i49, %if.else49.i48 ], [ 0, %if.then.i57 ], [ 0, %lor.lhs.false.i45 ]
  %pb.sroa.12.0 = phi i32 [ %add.i69, %frac64_normalize.exit.i65 ], [ 0, %if.then10.i63 ], [ %sub37.i54, %if.then33.i53 ], [ 255, %if.else49.i48 ], [ 0, %if.then.i57 ], [ 255, %lor.lhs.false.i45 ]
  %pb.sroa.0.0 = phi i8 [ 2, %frac64_normalize.exit.i65 ], [ 1, %if.then10.i63 ], [ 2, %if.then33.i53 ], [ %conv53.i51, %if.else49.i48 ], [ 1, %if.then.i57 ], [ 3, %lor.lhs.false.i45 ]
  %conv.i = zext nneg i8 %pa.sroa.0.0 to i32
  %shl.i = shl nuw nsw i32 1, %conv.i
  %conv2.i = zext nneg i8 %pb.sroa.0.0 to i32
  %shl3.i = shl nuw nsw i32 1, %conv2.i
  %or.i = or i32 %shl3.i, %shl.i
  %cmp.i = icmp eq i32 %or.i, 4
  br i1 %cmp.i, label %if.then.i, label %if.end32.i

if.then.i:                                        ; preds = %parts64_canonicalize.exit71
  %cmp13.i.not = icmp eq i16 %f.lobit.i, %f.lobit.i34
  br i1 %cmp13.i.not, label %if.end.i, label %a_sign.i

if.end.i:                                         ; preds = %if.then.i
  %cmp17.i = icmp eq i32 %pa.sroa.13.0, %pb.sroa.12.0
  br i1 %cmp17.i, label %if.then19.i, label %if.else.i

if.then19.i:                                      ; preds = %if.end.i
  %cmp.i72 = icmp eq i64 %pa.sroa.18.0, %pb.sroa.17.0
  %cmp1.i = icmp ult i64 %pa.sroa.18.0, %pb.sroa.17.0
  %cond.i73 = select i1 %cmp1.i, i32 -1, i32 1
  %cond2.i = select i1 %cmp.i72, i32 0, i32 %cond.i73
  br label %if.end27.i

if.else.i:                                        ; preds = %if.end.i
  %cmp22.i = icmp slt i32 %pa.sroa.13.0, %pb.sroa.12.0
  %. = select i1 %cmp22.i, i32 -1, i32 1
  br label %if.end27.i

if.end27.i:                                       ; preds = %if.else.i, %if.then19.i
  %cmp7.i.0 = phi i32 [ %cond2.i, %if.then19.i ], [ %., %if.else.i ]
  %sub.i = sub nsw i32 0, %cmp7.i.0
  %tobool29.i.not88 = icmp slt i16 %a, 0
  %spec.select = select i1 %tobool29.i.not88, i32 %sub.i, i32 %cmp7.i.0
  br label %parts64_compare.exit

if.end32.i:                                       ; preds = %parts64_canonicalize.exit71
  %and.i = and i32 %or.i, 48
  %tobool33.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool33.i.not, label %if.end49.i, label %if.then40.i

if.then40.i:                                      ; preds = %if.end32.i
  %and41.i = and i32 %or.i, 32
  %tobool42.i.not = icmp eq i32 %and41.i, 0
  br i1 %tobool42.i.not, label %if.else44.i, label %if.then43.i

if.then43.i:                                      ; preds = %if.then40.i
  %14 = load i16, ptr %s, align 2
  %or1.i = or i16 %14, 8193
  store i16 %or1.i, ptr %s, align 2
  br label %parts64_compare.exit

if.else44.i:                                      ; preds = %if.then40.i
  br i1 %is_quiet, label %parts64_compare.exit, label %if.then46.i

if.then46.i:                                      ; preds = %if.else44.i
  %15 = load i16, ptr %s, align 2
  %or1.i74 = or i16 %15, 1
  store i16 %or1.i74, ptr %s, align 2
  br label %parts64_compare.exit

if.end49.i:                                       ; preds = %if.end32.i
  %and50.i = and i32 %or.i, 2
  %tobool51.i.not = icmp eq i32 %and50.i, 0
  br i1 %tobool51.i.not, label %if.end63.i, label %if.then52.i

if.then52.i:                                      ; preds = %if.end49.i
  %cmp53.i = icmp eq i32 %or.i, 2
  br i1 %cmp53.i, label %parts64_compare.exit, label %if.else56.i

if.else56.i:                                      ; preds = %if.then52.i
  %cmp59.i = icmp eq i8 %pa.sroa.0.0, 1
  br i1 %cmp59.i, label %b_sign.i, label %a_sign.i

if.end63.i:                                       ; preds = %if.end49.i
  %cmp64.i = icmp eq i32 %or.i, 8
  br i1 %cmp64.i, label %if.then66.i, label %if.else77.i

if.then66.i:                                      ; preds = %if.end63.i
  %cmp73.i = icmp eq i16 %f.lobit.i, %f.lobit.i34
  br i1 %cmp73.i, label %parts64_compare.exit, label %a_sign.i

if.else77.i:                                      ; preds = %if.end63.i
  %cmp80.i = icmp eq i8 %pb.sroa.0.0, 3
  br i1 %cmp80.i, label %b_sign.i, label %if.else83.i

if.else83.i:                                      ; preds = %if.else77.i
  %cmp86.i = icmp eq i8 %pa.sroa.0.0, 3
  br i1 %cmp86.i, label %a_sign.i, label %if.else89.i

if.else89.i:                                      ; preds = %if.else83.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1472, ptr noundef nonnull @__func__.parts64_compare, ptr noundef nonnull @.str.15) #16
  unreachable

a_sign.i:                                         ; preds = %if.then66.i, %if.else83.i, %if.else56.i, %if.then.i
  %tobool94.i.not = icmp sgt i16 %a, -1
  %cond.i = select i1 %tobool94.i.not, i32 1, i32 -1
  br label %parts64_compare.exit

b_sign.i:                                         ; preds = %if.else77.i, %if.else56.i
  %tobool97.i.not = icmp sgt i16 %b, -1
  %cond99.i = select i1 %tobool97.i.not, i32 -1, i32 1
  br label %parts64_compare.exit

parts64_compare.exit:                             ; preds = %if.then66.i, %if.then52.i, %if.then43.i, %if.then46.i, %if.else44.i, %b_sign.i, %a_sign.i, %if.end27.i
  %retval.i.0 = phi i32 [ %cond.i, %a_sign.i ], [ %spec.select, %if.end27.i ], [ %cond99.i, %b_sign.i ], [ 2, %if.else44.i ], [ 2, %if.then46.i ], [ 2, %if.then43.i ], [ 0, %if.then52.i ], [ 0, %if.then66.i ]
  ret i32 %retval.i.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bfloat16_compare_quiet(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @bfloat16_do_compare(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %s, i1 noundef zeroext true), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float128_compare(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float128_do_compare(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr noundef %s, i1 noundef zeroext false), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @float128_do_compare(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %s, i1 noundef zeroext %is_quiet) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts128, align 8
  %pb = alloca %struct.FloatParts128, align 8
  %shr.i16.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i to i32
  %conv.i29 = and i32 %0, 32767
  %f.coerce1.lobit.i = lshr i64 %a.coerce1, 63
  %frombool.i = trunc i64 %f.coerce1.lobit.i to i8
  %and.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %pa, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i29, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pa, ptr noundef %s, ptr noundef nonnull @float128_params)
  %shr.i16.i30 = lshr i64 %b.coerce1, 48
  %1 = trunc i64 %shr.i16.i30 to i32
  %conv.i31 = and i32 %1, 32767
  %f.coerce1.lobit.i32 = lshr i64 %b.coerce1, 63
  %frombool.i33 = trunc i64 %f.coerce1.lobit.i32 to i8
  %and.i.i34 = and i64 %b.coerce1, 281474976710655
  store i8 0, ptr %pb, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i35 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i33, ptr %.compoundliteral.sroa.2.0..sroa_idx.i35, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i36 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i31, ptr %.compoundliteral.sroa.33.0..sroa_idx.i36, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i37 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i.i34, ptr %.compoundliteral.sroa.4.0..sroa_idx.i37, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i38 = getelementptr inbounds i8, ptr %pb, i64 16
  store i64 %b.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i38, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pb, ptr noundef %s, ptr noundef nonnull @float128_params)
  %2 = load i8, ptr %pa, align 8
  %conv.i = zext nneg i8 %2 to i32
  %shl.i = shl nuw i32 1, %conv.i
  %3 = load i8, ptr %pb, align 8
  %conv2.i = zext nneg i8 %3 to i32
  %shl3.i = shl nuw i32 1, %conv2.i
  %or.i = or i32 %shl3.i, %shl.i
  %cmp.i = icmp eq i32 %or.i, 4
  br i1 %cmp.i, label %if.then.i, label %if.end32.i

if.then.i:                                        ; preds = %entry
  %4 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %5 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i35, align 1
  %6 = xor i8 %5, %4
  %7 = and i8 %6, 1
  %cmp13.i.not = icmp eq i8 %7, 0
  br i1 %cmp13.i.not, label %if.end.i, label %a_sign.i

if.end.i:                                         ; preds = %if.then.i
  %8 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %9 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i36, align 4
  %cmp17.i = icmp eq i32 %8, %9
  br i1 %cmp17.i, label %if.then19.i, label %if.else.i

if.then19.i:                                      ; preds = %if.end.i
  %10 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %11 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i37, align 8
  %cmp.i39 = icmp eq i64 %10, %11
  br i1 %cmp.i39, label %if.then.i41, label %if.end5.i

if.then.i41:                                      ; preds = %if.then19.i
  %12 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %13 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i38, align 8
  %cmp3.i = icmp eq i64 %12, %13
  br i1 %cmp3.i, label %if.end27.i, label %if.end5.i

if.end5.i:                                        ; preds = %if.then.i41, %if.then19.i
  %ta.0.i = phi i64 [ %12, %if.then.i41 ], [ %10, %if.then19.i ]
  %tb.0.i = phi i64 [ %13, %if.then.i41 ], [ %11, %if.then19.i ]
  %cmp6.i = icmp ult i64 %ta.0.i, %tb.0.i
  %cond.i40 = select i1 %cmp6.i, i32 -1, i32 1
  br label %if.end27.i

if.else.i:                                        ; preds = %if.end.i
  %cmp22.i = icmp slt i32 %8, %9
  %. = select i1 %cmp22.i, i32 -1, i32 1
  br label %if.end27.i

if.end27.i:                                       ; preds = %if.end5.i, %if.then.i41, %if.else.i
  %cmp7.i.0 = phi i32 [ %., %if.else.i ], [ %cond.i40, %if.end5.i ], [ 0, %if.then.i41 ]
  %14 = and i8 %4, 1
  %tobool29.i.not = icmp eq i8 %14, 0
  %sub.i = sub nsw i32 0, %cmp7.i.0
  %spec.select = select i1 %tobool29.i.not, i32 %cmp7.i.0, i32 %sub.i
  br label %parts128_compare.exit

if.end32.i:                                       ; preds = %entry
  %and.i = and i32 %or.i, 48
  %tobool33.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool33.i.not, label %if.end49.i, label %if.then40.i

if.then40.i:                                      ; preds = %if.end32.i
  %and41.i = and i32 %or.i, 32
  %tobool42.i.not = icmp eq i32 %and41.i, 0
  br i1 %tobool42.i.not, label %if.else44.i, label %if.then43.i

if.then43.i:                                      ; preds = %if.then40.i
  %15 = load i16, ptr %s, align 2
  %or1.i = or i16 %15, 8193
  store i16 %or1.i, ptr %s, align 2
  br label %parts128_compare.exit

if.else44.i:                                      ; preds = %if.then40.i
  br i1 %is_quiet, label %parts128_compare.exit, label %if.then46.i

if.then46.i:                                      ; preds = %if.else44.i
  %16 = load i16, ptr %s, align 2
  %or1.i42 = or i16 %16, 1
  store i16 %or1.i42, ptr %s, align 2
  br label %parts128_compare.exit

if.end49.i:                                       ; preds = %if.end32.i
  %and50.i = and i32 %or.i, 2
  %tobool51.i.not = icmp eq i32 %and50.i, 0
  br i1 %tobool51.i.not, label %if.end63.i, label %if.then52.i

if.then52.i:                                      ; preds = %if.end49.i
  %cmp53.i = icmp eq i32 %or.i, 2
  br i1 %cmp53.i, label %parts128_compare.exit, label %if.else56.i

if.else56.i:                                      ; preds = %if.then52.i
  %cmp59.i = icmp eq i8 %2, 1
  br i1 %cmp59.i, label %b_sign.i, label %a_sign.i

if.end63.i:                                       ; preds = %if.end49.i
  %cmp64.i = icmp eq i32 %or.i, 8
  br i1 %cmp64.i, label %if.then66.i, label %if.else77.i

if.then66.i:                                      ; preds = %if.end63.i
  %17 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %18 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i35, align 1
  %19 = xor i8 %18, %17
  %20 = and i8 %19, 1
  %cmp73.i = icmp eq i8 %20, 0
  br i1 %cmp73.i, label %parts128_compare.exit, label %a_sign.i

if.else77.i:                                      ; preds = %if.end63.i
  %cmp80.i = icmp eq i8 %3, 3
  br i1 %cmp80.i, label %b_sign.i, label %if.else83.i

if.else83.i:                                      ; preds = %if.else77.i
  %cmp86.i = icmp eq i8 %2, 3
  br i1 %cmp86.i, label %a_sign.i, label %if.else89.i

if.else89.i:                                      ; preds = %if.else83.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1472, ptr noundef nonnull @__func__.parts128_compare, ptr noundef nonnull @.str.15) #16
  unreachable

a_sign.i:                                         ; preds = %if.then66.i, %if.else83.i, %if.else56.i, %if.then.i
  %21 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %22 = and i8 %21, 1
  %tobool94.i.not = icmp eq i8 %22, 0
  %cond.i = select i1 %tobool94.i.not, i32 1, i32 -1
  br label %parts128_compare.exit

b_sign.i:                                         ; preds = %if.else77.i, %if.else56.i
  %23 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i35, align 1
  %24 = and i8 %23, 1
  %tobool97.i.not = icmp eq i8 %24, 0
  %cond99.i = select i1 %tobool97.i.not, i32 -1, i32 1
  br label %parts128_compare.exit

parts128_compare.exit:                            ; preds = %if.then66.i, %if.then52.i, %if.then43.i, %if.then46.i, %if.else44.i, %b_sign.i, %a_sign.i, %if.end27.i
  %retval.i.0 = phi i32 [ %cond.i, %a_sign.i ], [ %spec.select, %if.end27.i ], [ %cond99.i, %b_sign.i ], [ 2, %if.else44.i ], [ 2, %if.then46.i ], [ 2, %if.then43.i ], [ 0, %if.then52.i ], [ 0, %if.then66.i ]
  ret i32 %retval.i.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float128_compare_quiet(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @float128_do_compare(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1, ptr noundef %s, i1 noundef zeroext true), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @floatx80_compare(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @floatx80_do_compare(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr noundef %s, i1 noundef zeroext false), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @floatx80_do_compare(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr nocapture noundef %s, i1 noundef zeroext %is_quiet) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts128, align 8
  %pb = alloca %struct.FloatParts128, align 8
  %floatx80_rounding_precision.i7 = getelementptr inbounds i8, ptr %s, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i7, align 1
  %switch = icmp ult i8 %0, 3
  br i1 %switch, label %sw.bb.i9, label %sw.default.i36

sw.bb.i9:                                         ; preds = %entry
  %cmp.i = icmp sgt i64 %a.coerce0, -1
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i = icmp ne i16 %1, 0
  %2 = select i1 %cmp.i, i1 %cmp2.i, i1 false
  br i1 %2, label %floatx80_unpack_canonical.exit37, label %if.end.i14

sw.default.i36:                                   ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

if.end.i14:                                       ; preds = %sw.bb.i9
  %f.coerce1.lobit.i = lshr i16 %a.coerce1, 15
  %frombool.i = trunc i16 %f.coerce1.lobit.i to i8
  %and.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %pa, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %and.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %cmp.i16.not = icmp eq i16 %1, 32767
  br i1 %cmp.i16.not, label %lor.lhs.false.thread, label %lor.lhs.false

lor.lhs.false.thread:                             ; preds = %if.end.i14
  %and.i22 = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i22, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %cmp12.i24 = icmp eq i64 %and.i22, 0
  %3 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i = icmp eq i64 %3, 0
  %cond.i28 = select i1 %tobool.not.i, i8 5, i8 4
  %cond17.i30 = select i1 %cmp12.i24, i8 3, i8 %cond.i28
  store i8 %cond17.i30, ptr %pa, align 8
  br label %sw.bb.i

floatx80_unpack_canonical.exit37:                 ; preds = %sw.bb.i9
  %4 = load i16, ptr %s, align 2
  %or1.i = or i16 %4, 1
  store i16 %or1.i, ptr %s, align 2
  br label %return

lor.lhs.false:                                    ; preds = %if.end.i14
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pa, ptr noundef nonnull %s, ptr noundef nonnull @floatx80_params)
  %.pre = load i8, ptr %floatx80_rounding_precision.i7, align 1
  %switch49 = icmp ult i8 %.pre, 3
  br i1 %switch49, label %sw.bb.i, label %sw.default.i

sw.bb.i:                                          ; preds = %lor.lhs.false.thread, %lor.lhs.false
  %cmp.i50 = icmp sgt i64 %b.coerce0, -1
  %5 = and i16 %b.coerce1, 32767
  %cmp2.i51 = icmp ne i16 %5, 0
  %6 = select i1 %cmp.i50, i1 %cmp2.i51, i1 false
  br i1 %6, label %floatx80_unpack_canonical.exit, label %if.end.i

sw.default.i:                                     ; preds = %lor.lhs.false
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

if.end.i:                                         ; preds = %sw.bb.i
  %f.coerce1.lobit.i53 = lshr i16 %b.coerce1, 15
  %frombool.i54 = trunc i16 %f.coerce1.lobit.i53 to i8
  %and.i.i55 = zext nneg i16 %5 to i32
  store i8 0, ptr %pb, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i56 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i54, ptr %.compoundliteral.sroa.2.0..sroa_idx.i56, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i57 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %and.i.i55, ptr %.compoundliteral.sroa.32.0..sroa_idx.i57, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i58 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %b.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i58, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i59 = getelementptr inbounds i8, ptr %pb, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i59, align 8
  %cmp.i.not = icmp eq i16 %5, 32767
  br i1 %cmp.i.not, label %if.else.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %pb, ptr noundef nonnull %s, ptr noundef nonnull @floatx80_params)
  %.pr = load i8, ptr %pb, align 8
  br label %if.end

if.else.i:                                        ; preds = %if.end.i
  %and.i = and i64 %b.coerce0, 9223372036854775807
  store i64 %and.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i58, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %7 = and i64 %b.coerce0, 4611686018427387904
  %tobool.not.i60 = icmp eq i64 %7, 0
  %cond.i = select i1 %tobool.not.i60, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %cond.i
  br label %if.end

floatx80_unpack_canonical.exit:                   ; preds = %sw.bb.i
  %8 = load i16, ptr %s, align 2
  %or1.i52 = or i16 %8, 1
  store i16 %or1.i52, ptr %s, align 2
  br label %return

if.end:                                           ; preds = %if.then10.i, %if.else.i
  %9 = phi i8 [ %.pr, %if.then10.i ], [ %cond17.i, %if.else.i ]
  %10 = load i8, ptr %pa, align 8
  %conv.i40 = zext nneg i8 %10 to i32
  %shl.i = shl nuw i32 1, %conv.i40
  %conv2.i41 = zext nneg i8 %9 to i32
  %shl3.i = shl nuw i32 1, %conv2.i41
  %or.i = or i32 %shl.i, %shl3.i
  %cmp.i42 = icmp eq i32 %or.i, 4
  br i1 %cmp.i42, label %if.then.i47, label %if.end32.i

if.then.i47:                                      ; preds = %if.end
  %11 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %12 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i56, align 1
  %13 = xor i8 %12, %11
  %14 = and i8 %13, 1
  %cmp13.i.not = icmp eq i8 %14, 0
  br i1 %cmp13.i.not, label %if.end.i48, label %a_sign.i

if.end.i48:                                       ; preds = %if.then.i47
  %15 = load i32, ptr %.compoundliteral.sroa.32.0..sroa_idx.i, align 4
  %16 = load i32, ptr %.compoundliteral.sroa.32.0..sroa_idx.i57, align 4
  %cmp17.i = icmp eq i32 %15, %16
  br i1 %cmp17.i, label %if.then19.i, label %if.else.i50

if.then19.i:                                      ; preds = %if.end.i48
  %17 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %18 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i58, align 8
  %cmp.i62 = icmp eq i64 %17, %18
  br i1 %cmp.i62, label %if.then.i64, label %if.end5.i

if.then.i64:                                      ; preds = %if.then19.i
  %19 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %20 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i59, align 8
  %cmp3.i = icmp eq i64 %19, %20
  br i1 %cmp3.i, label %if.end27.i, label %if.end5.i

if.end5.i:                                        ; preds = %if.then.i64, %if.then19.i
  %ta.0.i = phi i64 [ %19, %if.then.i64 ], [ %17, %if.then19.i ]
  %tb.0.i = phi i64 [ %20, %if.then.i64 ], [ %18, %if.then19.i ]
  %cmp6.i = icmp ult i64 %ta.0.i, %tb.0.i
  %cond.i63 = select i1 %cmp6.i, i32 -1, i32 1
  br label %if.end27.i

if.else.i50:                                      ; preds = %if.end.i48
  %cmp22.i = icmp slt i32 %15, %16
  %. = select i1 %cmp22.i, i32 -1, i32 1
  br label %if.end27.i

if.end27.i:                                       ; preds = %if.end5.i, %if.then.i64, %if.else.i50
  %cmp7.i.0 = phi i32 [ %., %if.else.i50 ], [ %cond.i63, %if.end5.i ], [ 0, %if.then.i64 ]
  %21 = and i8 %11, 1
  %tobool29.i.not = icmp eq i8 %21, 0
  %sub.i = sub nsw i32 0, %cmp7.i.0
  %spec.select = select i1 %tobool29.i.not, i32 %cmp7.i.0, i32 %sub.i
  br label %return

if.end32.i:                                       ; preds = %if.end
  %and.i45 = and i32 %or.i, 48
  %tobool33.i.not = icmp eq i32 %and.i45, 0
  br i1 %tobool33.i.not, label %if.end49.i, label %if.then40.i

if.then40.i:                                      ; preds = %if.end32.i
  %and41.i = and i32 %or.i, 32
  %tobool42.i.not = icmp eq i32 %and41.i, 0
  br i1 %tobool42.i.not, label %if.else44.i, label %if.then43.i

if.then43.i:                                      ; preds = %if.then40.i
  %22 = load i16, ptr %s, align 2
  %or1.i65 = or i16 %22, 8193
  store i16 %or1.i65, ptr %s, align 2
  br label %return

if.else44.i:                                      ; preds = %if.then40.i
  br i1 %is_quiet, label %return, label %if.then46.i

if.then46.i:                                      ; preds = %if.else44.i
  %23 = load i16, ptr %s, align 2
  %or1.i66 = or i16 %23, 1
  store i16 %or1.i66, ptr %s, align 2
  br label %return

if.end49.i:                                       ; preds = %if.end32.i
  %and50.i = and i32 %or.i, 2
  %tobool51.i.not = icmp eq i32 %and50.i, 0
  br i1 %tobool51.i.not, label %if.end63.i, label %if.then52.i

if.then52.i:                                      ; preds = %if.end49.i
  %cmp53.i = icmp eq i32 %or.i, 2
  br i1 %cmp53.i, label %return, label %if.else56.i

if.else56.i:                                      ; preds = %if.then52.i
  %cmp59.i = icmp eq i8 %10, 1
  br i1 %cmp59.i, label %b_sign.i, label %a_sign.i

if.end63.i:                                       ; preds = %if.end49.i
  %cmp64.i = icmp eq i32 %or.i, 8
  br i1 %cmp64.i, label %if.then66.i, label %if.else77.i

if.then66.i:                                      ; preds = %if.end63.i
  %24 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %25 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i56, align 1
  %26 = xor i8 %25, %24
  %27 = and i8 %26, 1
  %cmp73.i = icmp eq i8 %27, 0
  br i1 %cmp73.i, label %return, label %a_sign.i

if.else77.i:                                      ; preds = %if.end63.i
  %cmp80.i = icmp eq i8 %9, 3
  br i1 %cmp80.i, label %b_sign.i, label %if.else83.i

if.else83.i:                                      ; preds = %if.else77.i
  %cmp86.i = icmp eq i8 %10, 3
  br i1 %cmp86.i, label %a_sign.i, label %if.else89.i

if.else89.i:                                      ; preds = %if.else83.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1472, ptr noundef nonnull @__func__.parts128_compare, ptr noundef nonnull @.str.15) #16
  unreachable

a_sign.i:                                         ; preds = %if.then66.i, %if.else83.i, %if.else56.i, %if.then.i47
  %28 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %29 = and i8 %28, 1
  %tobool94.i.not = icmp eq i8 %29, 0
  %cond.i46 = select i1 %tobool94.i.not, i32 1, i32 -1
  br label %return

b_sign.i:                                         ; preds = %if.else77.i, %if.else56.i
  %30 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i56, align 1
  %31 = and i8 %30, 1
  %tobool97.i.not = icmp eq i8 %31, 0
  %cond99.i = select i1 %tobool97.i.not, i32 -1, i32 1
  br label %return

return:                                           ; preds = %floatx80_unpack_canonical.exit, %floatx80_unpack_canonical.exit37, %if.end27.i, %a_sign.i, %b_sign.i, %if.else44.i, %if.then46.i, %if.then43.i, %if.then52.i, %if.then66.i
  %retval.0 = phi i32 [ 2, %floatx80_unpack_canonical.exit ], [ 2, %floatx80_unpack_canonical.exit37 ], [ %cond.i46, %a_sign.i ], [ %spec.select, %if.end27.i ], [ %cond99.i, %b_sign.i ], [ 2, %if.else44.i ], [ 2, %if.then46.i ], [ 2, %if.then43.i ], [ 0, %if.then52.i ], [ 0, %if.then66.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @floatx80_compare_quiet(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %call = tail call fastcc i32 @floatx80_do_compare(i64 %a.coerce0, i16 %a.coerce1, i64 %b.coerce0, i16 %b.coerce1, ptr noundef %s, i1 noundef zeroext true), !range !14
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_scalbn(i16 noundef zeroext %a, i32 noundef %n, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %conv.i.i.i3 = zext nneg i16 %1 to i32
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i3, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i16 %1, label %float16a_unpack_canonical.exit.thread [
    i16 0, label %if.then.i.i4
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i4:                                     ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i5

if.then8.i.i:                                     ; preds = %if.then.i.i4
  store i8 1, ptr %p, align 8
  br label %parts64_scalbn.exit

if.else.i.i5:                                     ; preds = %if.then.i.i4
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %float16a_unpack_canonical.exit.thread7, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i5
  %5 = load i16, ptr %status, align 2
  %or1.i.i.i6 = or i16 %5, 32
  store i16 %or1.i.i.i6, ptr %status, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_scalbn.exit

float16a_unpack_canonical.exit.thread7:           ; preds = %if.else.i.i5
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  br label %sw.bb2.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit.thread:            ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i3, -15
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb2.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_scalbn.exit

float16a_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %float16a_unpack_canonical.exit
  %7 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %7, 8193
  store i16 %or1.i.i.i, ptr %status, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %8 = load i8, ptr %default_nan_mode.i.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_scalbn.exit

if.else.i.i:                                      ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_scalbn.exit

sw.bb1.i.i:                                       ; preds = %float16a_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %parts64_scalbn.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_scalbn.exit

sw.bb2.i:                                         ; preds = %float16a_unpack_canonical.exit.thread, %float16a_unpack_canonical.exit.thread7
  %12 = phi i32 [ %add.i.i, %float16a_unpack_canonical.exit.thread7 ], [ %sub37.i.i, %float16a_unpack_canonical.exit.thread ]
  %cond.i = tail call i32 @llvm.smax.i32(i32 %n, i32 -65536)
  %cond10.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %add.i = add nsw i32 %12, %cond10.i
  store i32 %add.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_scalbn.exit

parts64_scalbn.exit:                              ; preds = %if.then47.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i, %if.else.i.i, %sw.bb1.i.i, %if.then4.i.i, %sw.bb2.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float16_params)
  %13 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i.i = zext i8 %13 to i64
  %shl.i.i.i.i = shl nuw nsw i64 %conv.i.i.i.i, 15
  %14 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %15 = shl i32 %14, 10
  %16 = and i32 %15, 31744
  %and8.i.i.i.i = zext nneg i32 %16 to i64
  %or.i.i.i.i = or disjoint i64 %shl.i.i.i.i, %and8.i.i.i.i
  %17 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i.i = and i64 %17, 1023
  %or.i10.i.i.i = or disjoint i64 %or.i.i.i.i, %shl77.i9.i.i.i
  %conv.i.i.i = trunc i64 %or.i10.i.i.i to i16
  ret i16 %conv.i.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_scalbn(i32 noundef %a, i32 noundef %n, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %and.i9.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %float32_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_scalbn.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float32_unpack_canonical.exit.thread7, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_scalbn.exit

float32_unpack_canonical.exit.thread7:            ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  br label %sw.bb2.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %float32_unpack_canonical.exit

float32_unpack_canonical.exit.thread:             ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb2.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_scalbn.exit

float32_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %float32_unpack_canonical.exit
  %5 = load i16, ptr %status, align 2
  %or1.i.i.i3 = or i16 %5, 8193
  store i16 %or1.i.i.i3, ptr %status, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_scalbn.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_scalbn.exit

sw.bb1.i.i:                                       ; preds = %float32_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %8 = load i8, ptr %default_nan_mode2.i.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i, label %parts64_scalbn.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_scalbn.exit

sw.bb2.i:                                         ; preds = %float32_unpack_canonical.exit.thread, %float32_unpack_canonical.exit.thread7
  %10 = phi i32 [ %add.i.i, %float32_unpack_canonical.exit.thread7 ], [ %sub37.i.i, %float32_unpack_canonical.exit.thread ]
  %cond.i = tail call i32 @llvm.smax.i32(i32 %n, i32 -65536)
  %cond10.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %add.i = add nsw i32 %10, %cond10.i
  store i32 %add.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_scalbn.exit

parts64_scalbn.exit:                              ; preds = %if.then47.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i, %sw.bb2.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float32_params)
  %11 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i = zext i8 %11 to i64
  %shl.i.i.i6 = shl nuw nsw i64 %conv.i.i.i, 31
  %12 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %13 = shl i32 %12, 23
  %14 = and i32 %13, 2139095040
  %and8.i.i.i = zext nneg i32 %14 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i6, %and8.i.i.i
  %15 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %15, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  ret i32 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_scalbn(i64 noundef %a, i32 noundef %n, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %float64_unpack_canonical.exit.thread [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_scalbn.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float64_unpack_canonical.exit.thread8, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_scalbn.exit

float64_unpack_canonical.exit.thread8:            ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  br label %sw.bb2.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %float64_unpack_canonical.exit

float64_unpack_canonical.exit.thread:             ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb2.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_scalbn.exit

float64_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %float64_unpack_canonical.exit
  %5 = load i16, ptr %status, align 2
  %or1.i.i.i3 = or i16 %5, 8193
  store i16 %or1.i.i.i3, ptr %status, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_scalbn.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_scalbn.exit

sw.bb1.i.i:                                       ; preds = %float64_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %8 = load i8, ptr %default_nan_mode2.i.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i, label %parts64_scalbn.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_scalbn.exit

sw.bb2.i:                                         ; preds = %float64_unpack_canonical.exit.thread, %float64_unpack_canonical.exit.thread8
  %10 = phi i32 [ %add.i.i, %float64_unpack_canonical.exit.thread8 ], [ %sub37.i.i, %float64_unpack_canonical.exit.thread ]
  %cond.i = tail call i32 @llvm.smax.i32(i32 %n, i32 -65536)
  %cond10.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %add.i = add nsw i32 %10, %cond10.i
  store i32 %add.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_scalbn.exit

parts64_scalbn.exit:                              ; preds = %if.then47.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i, %sw.bb2.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float64_params)
  %11 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %12 = and i8 %11, 1
  %conv.i.i.i6 = zext nneg i8 %12 to i64
  %shl.i.i.i7 = shl nuw i64 %conv.i.i.i6, 63
  %13 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %14 = and i32 %13, 2047
  %shl77.i.i.i = zext nneg i32 %14 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i.i7
  %15 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %15, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  ret i64 %or.i10.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_scalbn(i16 noundef zeroext %a, i32 noundef %n, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %0, 255
  %conv.i.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 127
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i16 %0 to i8
  switch i8 %trunc.i, label %bfloat16_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_scalbn.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %bfloat16_unpack_canonical.exit.thread8, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_scalbn.exit

bfloat16_unpack_canonical.exit.thread8:           ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -70, %cast.i.i.i.i
  br label %sw.bb2.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %bfloat16_unpack_canonical.exit

bfloat16_unpack_canonical.exit.thread:            ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -127
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %sw.bb2.i

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %parts64_scalbn.exit

bfloat16_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 56
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 64
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %bfloat16_unpack_canonical.exit
  %7 = load i16, ptr %status, align 2
  %or1.i.i.i3 = or i16 %7, 8193
  store i16 %or1.i.i.i3, ptr %status, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %8 = load i8, ptr %default_nan_mode.i.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_scalbn.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_scalbn.exit

sw.bb1.i.i:                                       ; preds = %bfloat16_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %parts64_scalbn.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_scalbn.exit

sw.bb2.i:                                         ; preds = %bfloat16_unpack_canonical.exit.thread, %bfloat16_unpack_canonical.exit.thread8
  %12 = phi i32 [ %add.i.i, %bfloat16_unpack_canonical.exit.thread8 ], [ %sub37.i.i, %bfloat16_unpack_canonical.exit.thread ]
  %cond.i = tail call i32 @llvm.smax.i32(i32 %n, i32 -65536)
  %cond10.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %add.i = add nsw i32 %12, %cond10.i
  store i32 %add.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_scalbn.exit

parts64_scalbn.exit:                              ; preds = %if.then47.i.i, %if.then10.i.i, %if.then8.i.i, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i, %sw.bb2.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %13 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i6 = zext i8 %13 to i64
  %shl.i.i.i7 = shl nuw nsw i64 %conv.i.i.i6, 15
  %14 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %15 = shl i32 %14, 7
  %16 = and i32 %15, 32640
  %and8.i.i.i = zext nneg i32 %16 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i7, %and8.i.i.i
  %17 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %17, 127
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i16
  ret i16 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_scalbn(i64 %a.coerce0, i64 %a.coerce1, i32 noundef %n, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %shr.i16.i.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i.i to i32
  %conv.i.i = and i32 %0, 32767
  %f.coerce1.lobit.i.i = lshr i64 %a.coerce1, 63
  %frombool.i.i = trunc i64 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float128_params)
  %1 = load i8, ptr %p, align 8
  switch i8 %1, label %do.body.i [
    i8 2, label %sw.bb2.i
    i8 3, label %parts128_scalbn.exit
    i8 1, label %parts128_scalbn.exit
    i8 5, label %sw.bb.i.i
    i8 4, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %entry
  %2 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %2, 8193
  store i16 %or1.i.i.i, ptr %status, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %3 = load i8, ptr %default_nan_mode.i.i, align 1
  %4 = and i8 %3, 1
  %tobool.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %parts128_scalbn.exit

if.else.i.i:                                      ; preds = %sw.bb.i.i
  %5 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %or4.i.i.i.i = or i64 %5, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts128_scalbn.exit

sw.bb1.i.i:                                       ; preds = %entry
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %6 = load i8, ptr %default_nan_mode2.i.i, align 1
  %7 = and i8 %6, 1
  %tobool3.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool3.not.i.i, label %parts128_scalbn.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %parts128_scalbn.exit

sw.bb2.i:                                         ; preds = %entry
  %cond.i = tail call i32 @llvm.smax.i32(i32 %n, i32 -65536)
  %cond10.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %8 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  %add.i = add i32 %8, %cond10.i
  store i32 %add.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i.i, align 4
  br label %parts128_scalbn.exit

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1498, ptr noundef nonnull @__func__.parts128_scalbn, ptr noundef null) #16
  unreachable

parts128_scalbn.exit:                             ; preds = %entry, %entry, %if.then.i.i, %if.else.i.i, %sw.bb1.i.i, %if.then4.i.i, %sw.bb2.i
  %call = call fastcc { i64, i64 } @float128_round_pack_canonical(ptr noundef nonnull %p, ptr noundef %status)
  ret { i64, i64 } %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @floatx80_scalbn(i64 %a.coerce0, i16 %a.coerce1, i32 noundef %n, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %floatx80_rounding_precision.i = getelementptr inbounds i8, ptr %status, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i = icmp ult i8 %0, 3
  br i1 %switch.i, label %sw.epilog.i, label %do.body.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %entry
  %cmp.i.i = icmp slt i64 %a.coerce0, 0
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i.i = icmp eq i16 %1, 0
  %.not.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  br i1 %.not.i, label %if.end.i, label %if.then

if.end.i:                                         ; preds = %sw.epilog.i
  %f.coerce1.lobit.i.i = lshr i16 %a.coerce1, 15
  %frombool.i.i = trunc i16 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %and.i.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.not.i = icmp eq i16 %1, 32767
  br i1 %cmp.not.i, label %if.else.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef nonnull %status, ptr noundef nonnull @floatx80_params)
  %.pr = load i8, ptr %p, align 8
  br label %if.end

if.else.i:                                        ; preds = %if.end.i
  %and.i = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %2 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i.i = icmp eq i64 %2, 0
  %3 = select i1 %tobool.not.i.i, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %3
  store i8 %cond17.i, ptr %p, align 8
  br label %if.end

if.then:                                          ; preds = %sw.epilog.i
  %4 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %4, 1
  store i16 %or1.i.i, ptr %status, align 2
  br label %return

if.end:                                           ; preds = %if.then10.i, %if.else.i
  %5 = phi i8 [ %.pr, %if.then10.i ], [ %cond17.i, %if.else.i ]
  switch i8 %5, label %do.body.i6 [
    i8 2, label %sw.bb2.i
    i8 3, label %parts128_scalbn.exit
    i8 1, label %parts128_scalbn.exit
    i8 5, label %sw.bb.i.i
    i8 4, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end
  %6 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %6, 8193
  store i16 %or1.i.i.i, ptr %status, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %7 = load i8, ptr %default_nan_mode.i.i, align 1
  %8 = and i8 %7, 1
  %tobool.not.i.i5 = icmp eq i8 %8, 0
  br i1 %tobool.not.i.i5, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %parts128_scalbn.exit

if.else.i.i:                                      ; preds = %sw.bb.i.i
  %9 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %or4.i.i.i.i = or i64 %9, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts128_scalbn.exit

sw.bb1.i.i:                                       ; preds = %if.end
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %parts128_scalbn.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %parts128_scalbn.exit

sw.bb2.i:                                         ; preds = %if.end
  %cond.i = tail call i32 @llvm.smax.i32(i32 %n, i32 -65536)
  %cond10.i = tail call i32 @llvm.smin.i32(i32 %cond.i, i32 65536)
  %12 = load i32, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %add.i = add i32 %12, %cond10.i
  store i32 %add.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  br label %parts128_scalbn.exit

do.body.i6:                                       ; preds = %if.end
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1498, ptr noundef nonnull @__func__.parts128_scalbn, ptr noundef null) #16
  unreachable

parts128_scalbn.exit:                             ; preds = %if.end, %if.end, %if.then.i.i, %if.else.i.i, %sw.bb1.i.i, %if.then4.i.i, %sw.bb2.i
  %call2 = call fastcc { i64, i16 } @floatx80_round_pack_canonical(ptr noundef nonnull %p, ptr noundef nonnull %status)
  %13 = extractvalue { i64, i16 } %call2, 0
  %14 = extractvalue { i64, i16 } %call2, 1
  br label %return

return:                                           ; preds = %parts128_scalbn.exit, %if.then
  %retval.sroa.0.0 = phi i64 [ %13, %parts128_scalbn.exit ], [ -4611686018427387904, %if.then ]
  %retval.sroa.3.0 = phi i16 [ %14, %parts128_scalbn.exit ], [ -1, %if.then ]
  %.fca.0.insert = insertvalue { i64, i16 } poison, i64 %retval.sroa.0.0, 0
  %.fca.1.insert = insertvalue { i64, i16 } %.fca.0.insert, i16 %retval.sroa.3.0, 1
  ret { i64, i16 } %.fca.1.insert
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @float16_sqrt(i16 noundef zeroext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i16 %a, 15
  %frombool.i.i.i = trunc i16 %f.lobit.i.i to i8
  %0 = lshr i16 %a, 10
  %1 = and i16 %0, 31
  %conv.i.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 1023
  %and.i10.i.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i16 %1, label %float16a_unpack_canonical.exit.thread [
    i16 0, label %if.then.i.i
    i16 31, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_sqrt.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i.i, label %float16a_unpack_canonical.exit.thread61, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %5 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %5, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_sqrt.exit

float16a_unpack_canonical.exit.thread61:          ; preds = %if.else.i.i
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %6 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %6
  store i8 2, ptr %p, align 8
  %add.i.i = sub nsw i32 39, %cast.i.i.i.i
  br label %if.end16.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i.i, label %float16a_unpack_canonical.exit.thread62, label %float16a_unpack_canonical.exit

float16a_unpack_canonical.exit.thread:            ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -15
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  br label %if.end16.i

float16a_unpack_canonical.exit.thread62:          ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  %tobool8.i.not = icmp sgt i16 %a, -1
  br i1 %tobool8.i.not, label %parts64_sqrt.exit, label %d_nan.i

float16a_unpack_canonical.exit:                   ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 53
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i16 %2, 512
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i54, label %sw.bb1.i

sw.bb.i54:                                        ; preds = %float16a_unpack_canonical.exit
  %7 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %7, 8193
  store i16 %or1.i.i, ptr %status, align 2
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %8 = load i8, ptr %default_nan_mode.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i, label %if.else.i55, label %if.then.i

if.then.i:                                        ; preds = %sw.bb.i54
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_sqrt.exit

if.else.i55:                                      ; preds = %sw.bb.i54
  %or4.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_sqrt.exit

sw.bb1.i:                                         ; preds = %float16a_unpack_canonical.exit
  %default_nan_mode2.i = getelementptr inbounds i8, ptr %status, i64 7
  %10 = load i8, ptr %default_nan_mode2.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i, label %parts64_sqrt.exit, label %if.then4.i

if.then4.i:                                       ; preds = %sw.bb1.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_sqrt.exit

if.end16.i:                                       ; preds = %float16a_unpack_canonical.exit.thread, %float16a_unpack_canonical.exit.thread61
  %12 = phi i64 [ %shl.i.i.i, %float16a_unpack_canonical.exit.thread61 ], [ %or.i.i, %float16a_unpack_canonical.exit.thread ]
  %13 = phi i32 [ %add.i.i, %float16a_unpack_canonical.exit.thread61 ], [ %sub37.i.i, %float16a_unpack_canonical.exit.thread ]
  %tobool18.i.not = icmp sgt i16 %a, -1
  br i1 %tobool18.i.not, label %if.end26.i, label %d_nan.i

if.end26.i:                                       ; preds = %if.end16.i
  %and.i = and i32 %13, 1
  %shr.i56 = lshr i64 %12, 57
  %and.i57 = and i64 %shr.i56, 63
  %lnot.ext30.i = shl nuw nsw i32 %and.i, 6
  %shl.i = xor i32 %lnot.ext30.i, 64
  %conv31.i = zext nneg i32 %shl.i to i64
  %or.i = or disjoint i64 %and.i57, %conv31.i
  %14 = xor i32 %and.i, 1
  %15 = zext nneg i32 %14 to i64
  %spec.select = lshr i64 %12, %15
  %shr.i = lshr i64 %spec.select, 32
  %arrayidx.i = getelementptr [128 x i16], ptr @rsqrt_tab, i64 0, i64 %or.i
  %16 = load i16, ptr %arrayidx.i, align 2
  %conv36.i = zext i16 %16 to i64
  %shl37.i = shl nuw nsw i64 %conv36.i, 16
  %mul.i = mul nuw i64 %shl37.i, %shr.i
  %shr40.i = lshr i64 %mul.i, 32
  %mul44.i = mul nuw i64 %shr40.i, %shl37.i
  %shr45.i = lshr i64 %mul44.i, 32
  %sub.i = sub nsw i64 3221225472, %shr45.i
  %conv48.i = and i64 %sub.i, 4294967295
  %mul49.i = mul nuw i64 %conv48.i, %shl37.i
  %shr50.i = lshr i64 %mul49.i, 31
  %conv53.i = and i64 %shr50.i, 4294967295
  %mul54.i = mul nuw i64 %conv53.i, %shr.i
  %shr55.i = lshr i64 %mul54.i, 32
  %mul59.i = mul nuw i64 %shr55.i, %conv53.i
  %shr60.i = lshr i64 %mul59.i, 32
  %sub62.i = sub nsw i64 3221225472, %shr60.i
  %conv35.i = trunc i64 %shr.i to i32
  %conv67.i = and i64 %sub62.i, 4294967295
  %mul68.i = mul nuw i64 %conv67.i, %shr55.i
  %shr69.i = lshr i64 %mul68.i, 32
  %conv70.i = trunc i64 %shr69.i to i32
  %sub71.i = add i32 %conv70.i, -1
  %shr72.i = lshr i32 %sub71.i, 6
  %shl73.i = shl i32 %conv35.i, 16
  %mul74.i = mul i32 %shr72.i, %shr72.i
  %sub75.i.neg = sub i32 %mul74.i, %shl73.i
  %sub76.i = add i32 %sub75.i.neg, %shr72.i
  %add.i = add nuw nsw i32 %shr72.i, 1
  %add77.i = add i32 %add.i, %sub76.i
  %shr78.i = lshr i32 %sub76.i, 31
  %add79.i = add nuw nsw i32 %shr78.i, %shr72.i
  %conv80.i = zext nneg i32 %add79.i to i64
  %shl81.i = shl i64 %conv80.i, 39
  %cmp82.i.not = icmp eq i32 %add77.i, 0
  %xor.i = xor i32 %add77.i, %sub76.i
  %cmp85.i.inv = icmp sgt i32 %xor.i, -1
  %cond.i = select i1 %cmp85.i.inv, i64 1, i64 -1
  %add88.i = select i1 %cmp82.i.not, i64 0, i64 %cond.i
  %storemerge = add i64 %add88.i, %shl81.i
  store i64 %storemerge, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shr121.i = ashr i32 %13, 1
  store i32 %shr121.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %tobool123.i.not = icmp sgt i64 %storemerge, -1
  br i1 %tobool123.i.not, label %if.then124.i, label %if.else.i

if.then124.i:                                     ; preds = %if.end26.i
  %17 = shl nuw i64 %storemerge, 1
  store i64 %17, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_sqrt.exit

if.else.i:                                        ; preds = %if.end26.i
  %add127.i = add nsw i32 %shr121.i, 1
  store i32 %add127.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_sqrt.exit

d_nan.i:                                          ; preds = %if.end16.i, %float16a_unpack_canonical.exit.thread62
  %18 = load i16, ptr %status, align 2
  %or1.i = or i16 %18, 2049
  store i16 %or1.i, ptr %status, align 2
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_sqrt.exit

parts64_sqrt.exit:                                ; preds = %if.then10.i.i, %if.then8.i.i, %if.then4.i, %sw.bb1.i, %if.else.i55, %if.then.i, %if.then124.i, %if.else.i, %float16a_unpack_canonical.exit.thread62, %d_nan.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float16_params)
  %19 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i59 = zext i8 %19 to i64
  %shl.i.i.i60 = shl nuw nsw i64 %conv.i.i.i59, 15
  %20 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %21 = shl i32 %20, 10
  %22 = and i32 %21, 31744
  %and8.i.i.i = zext nneg i32 %22 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i60, %and8.i.i.i
  %23 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %23, 1023
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i16
  ret i16 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_sqrt(i32 noundef %xa, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %0 = load i16, ptr %s, align 2
  %1 = and i16 %0, 16
  %tobool.i.not = icmp eq i16 %1, 0
  br i1 %tobool.i.not, label %soft, label %land.rhs.i

land.rhs.i:                                       ; preds = %entry
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %s, i64 2
  %2 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp.i.not = icmp eq i8 %2, 0
  br i1 %cmp.i.not, label %if.end, label %soft

if.end:                                           ; preds = %land.rhs.i
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool.i19.not = icmp eq i8 %4, 0
  br i1 %tobool.i19.not, label %float32_input_flush1.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %and.i.i.i = and i32 %xa, 2139095040
  %cmp.i.i.i = icmp eq i32 %and.i.i.i, 0
  %and.i2.i.i = and i32 %xa, 2147483647
  %cmp.i3.i.i = icmp ne i32 %and.i2.i.i, 0
  %5 = and i1 %cmp.i.i.i, %cmp.i3.i.i
  br i1 %5, label %if.then.i, label %float32_input_flush1.exit

if.then.i:                                        ; preds = %if.end.i
  %.lobit.i = and i32 %xa, -2147483648
  %or1.i.i = or i16 %0, 32
  store i16 %or1.i.i, ptr %s, align 2
  br label %float32_input_flush1.exit

float32_input_flush1.exit:                        ; preds = %if.then.i, %if.end.i, %if.end
  %6 = phi i16 [ %0, %if.end ], [ %or1.i.i, %if.then.i ], [ %0, %if.end.i ]
  %ua.sroa.0.1 = phi i32 [ %xa, %if.end ], [ %.lobit.i, %if.then.i ], [ %xa, %if.end.i ]
  %shr.i = lshr i32 %ua.sroa.0.1, 23
  %add.i = add nuw nsw i32 %shr.i, 1
  %and.i = and i32 %add.i, 254
  %cmp.i8.not = icmp eq i32 %and.i, 0
  br i1 %cmp.i8.not, label %lor.rhs.i, label %lor.rhs

lor.rhs.i:                                        ; preds = %float32_input_flush1.exit
  %or.cond.not = icmp eq i32 %ua.sroa.0.1, 0
  br i1 %or.cond.not, label %if.end13, label %soft

lor.rhs:                                          ; preds = %float32_input_flush1.exit
  %tobool.i16.old = icmp slt i32 %ua.sroa.0.1, 0
  br i1 %tobool.i16.old, label %soft, label %if.end13

if.end13:                                         ; preds = %lor.rhs.i, %lor.rhs
  %7 = bitcast i32 %ua.sroa.0.1 to float
  %call14 = tail call float @sqrtf(float noundef %7) #19
  %8 = bitcast float %call14 to i32
  br label %return

soft:                                             ; preds = %lor.rhs.i, %entry, %lor.rhs, %land.rhs.i
  %9 = phi i16 [ %0, %entry ], [ %0, %land.rhs.i ], [ %6, %lor.rhs ], [ %6, %lor.rhs.i ]
  %ua.sroa.0.2 = phi i32 [ %xa, %entry ], [ %xa, %land.rhs.i ], [ %ua.sroa.0.1, %lor.rhs ], [ %ua.sroa.0.1, %lor.rhs.i ]
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %f.lobit.i.i = lshr i32 %ua.sroa.0.2, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %ua.sroa.0.2, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %10 = and i32 %ua.sroa.0.2, 8388607
  %and.i10.i.i = zext nneg i32 %10 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %and.i9.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %parts64_canonicalize.exit.thread.i [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %soft
  %cmp.i.i.i12 = icmp eq i32 %10, 0
  br i1 %cmp.i.i.i12, label %if.then8.i.i, label %if.else.i60.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p.i, align 8
  br label %soft_f32_sqrt.exit

if.else.i60.i:                                    ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %11 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %12 = and i8 %11, 1
  %tobool9.not.i.i = icmp eq i8 %12, 0
  br i1 %tobool9.not.i.i, label %parts64_canonicalize.exit.thread70.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i60.i
  %or1.i.i.i = or i16 %9, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p.i, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_f32_sqrt.exit

parts64_canonicalize.exit.thread70.i:             ; preds = %if.else.i60.i
  %13 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %13 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %13
  store i8 2, ptr %p.i, align 8
  %add.i61.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  br label %if.end16.i.i

lor.lhs.false.i.i:                                ; preds = %soft
  %cmp.i29.i.i = icmp eq i32 %10, 0
  br i1 %cmp.i29.i.i, label %parts64_canonicalize.exit.thread71.i, label %parts64_canonicalize.exit.i

parts64_canonicalize.exit.thread.i:               ; preds = %soft
  store i8 2, ptr %p.i, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i59.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  br label %if.end16.i.i

parts64_canonicalize.exit.thread71.i:             ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p.i, align 8
  %tobool8.i.not.i = icmp sgt i32 %ua.sroa.0.2, -1
  br i1 %tobool8.i.not.i, label %soft_f32_sqrt.exit, label %d_nan.i.i

parts64_canonicalize.exit.i:                      ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i32 %10, 4194304
  %conv53.i57.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i57.i, ptr %p.i, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i62.i, label %sw.bb1.i.i

sw.bb.i62.i:                                      ; preds = %parts64_canonicalize.exit.i
  %or1.i.i63.i = or i16 %9, 8193
  store i16 %or1.i.i63.i, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %14 = load i8, ptr %default_nan_mode.i.i, align 1
  %15 = and i8 %14, 1
  %tobool.not.i.i = icmp eq i8 %15, 0
  br i1 %tobool.not.i.i, label %if.else.i65.i, label %if.then.i64.i

if.then.i64.i:                                    ; preds = %sw.bb.i62.i
  store i8 4, ptr %p.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_f32_sqrt.exit

if.else.i65.i:                                    ; preds = %sw.bb.i62.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p.i, align 8
  br label %soft_f32_sqrt.exit

sw.bb1.i.i:                                       ; preds = %parts64_canonicalize.exit.i
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %16 = load i8, ptr %default_nan_mode2.i.i, align 1
  %17 = and i8 %16, 1
  %tobool3.not.i.i = icmp eq i8 %17, 0
  br i1 %tobool3.not.i.i, label %soft_f32_sqrt.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_f32_sqrt.exit

if.end16.i.i:                                     ; preds = %parts64_canonicalize.exit.thread.i, %parts64_canonicalize.exit.thread70.i
  %18 = phi i64 [ %shl.i.i.i, %parts64_canonicalize.exit.thread70.i ], [ %or.i59.i, %parts64_canonicalize.exit.thread.i ]
  %19 = phi i32 [ %add.i61.i, %parts64_canonicalize.exit.thread70.i ], [ %sub37.i.i, %parts64_canonicalize.exit.thread.i ]
  %tobool18.i.not.i = icmp sgt i32 %ua.sroa.0.2, -1
  br i1 %tobool18.i.not.i, label %if.end26.i.i, label %d_nan.i.i

if.end26.i.i:                                     ; preds = %if.end16.i.i
  %and.i.i = and i32 %19, 1
  %shr.i66.i = lshr i64 %18, 57
  %and.i67.i = and i64 %shr.i66.i, 63
  %lnot.ext30.i.i = shl nuw nsw i32 %and.i.i, 6
  %shl.i.i = xor i32 %lnot.ext30.i.i, 64
  %conv31.i.i = zext nneg i32 %shl.i.i to i64
  %or.i.i = or disjoint i64 %and.i67.i, %conv31.i.i
  %20 = xor i32 %and.i.i, 1
  %21 = zext nneg i32 %20 to i64
  %spec.select.i = lshr i64 %18, %21
  %shr.i.i = lshr i64 %spec.select.i, 32
  %arrayidx.i.i = getelementptr [128 x i16], ptr @rsqrt_tab, i64 0, i64 %or.i.i
  %22 = load i16, ptr %arrayidx.i.i, align 2
  %conv36.i.i = zext i16 %22 to i64
  %shl37.i.i = shl nuw nsw i64 %conv36.i.i, 16
  %mul.i.i = mul nuw i64 %shl37.i.i, %shr.i.i
  %shr40.i.i = lshr i64 %mul.i.i, 32
  %mul44.i.i = mul nuw i64 %shr40.i.i, %shl37.i.i
  %shr45.i.i = lshr i64 %mul44.i.i, 32
  %sub.i.i = sub nsw i64 3221225472, %shr45.i.i
  %conv48.i.i = and i64 %sub.i.i, 4294967295
  %mul49.i.i = mul nuw i64 %conv48.i.i, %shl37.i.i
  %shr50.i.i = lshr i64 %mul49.i.i, 31
  %conv53.i.i = and i64 %shr50.i.i, 4294967295
  %mul54.i.i = mul nuw i64 %conv53.i.i, %shr.i.i
  %shr55.i.i = lshr i64 %mul54.i.i, 32
  %mul59.i.i = mul nuw i64 %shr55.i.i, %conv53.i.i
  %shr60.i.i = lshr i64 %mul59.i.i, 32
  %sub62.i.i = sub nsw i64 3221225472, %shr60.i.i
  %conv35.i.i = trunc i64 %shr.i.i to i32
  %conv67.i.i = and i64 %sub62.i.i, 4294967295
  %mul68.i.i = mul nuw i64 %conv67.i.i, %shr55.i.i
  %shr69.i.i = lshr i64 %mul68.i.i, 32
  %conv70.i.i = trunc i64 %shr69.i.i to i32
  %sub71.i.i = add i32 %conv70.i.i, -1
  %shr72.i.i = lshr i32 %sub71.i.i, 6
  %shl73.i.i = shl i32 %conv35.i.i, 16
  %mul74.i.i = mul i32 %shr72.i.i, %shr72.i.i
  %sub75.i.neg.i = sub i32 %mul74.i.i, %shl73.i.i
  %sub76.i.i = add i32 %sub75.i.neg.i, %shr72.i.i
  %add.i.i = add nuw nsw i32 %shr72.i.i, 1
  %add77.i.i = add i32 %add.i.i, %sub76.i.i
  %shr78.i.i = lshr i32 %sub76.i.i, 31
  %add79.i.i = add nuw nsw i32 %shr78.i.i, %shr72.i.i
  %conv80.i.i = zext nneg i32 %add79.i.i to i64
  %shl81.i.i = shl i64 %conv80.i.i, 39
  %cmp82.i.not.i = icmp eq i32 %add77.i.i, 0
  %xor.i.i = xor i32 %add77.i.i, %sub76.i.i
  %cmp85.i.inv.i = icmp sgt i32 %xor.i.i, -1
  %cond.i.i = select i1 %cmp85.i.inv.i, i64 1, i64 -1
  %add88.i.i = select i1 %cmp82.i.not.i, i64 0, i64 %cond.i.i
  %storemerge.i = add i64 %add88.i.i, %shl81.i.i
  store i64 %storemerge.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shr121.i.i = ashr i32 %19, 1
  store i32 %shr121.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %tobool123.i.not.i = icmp sgt i64 %storemerge.i, -1
  br i1 %tobool123.i.not.i, label %if.then124.i.i, label %if.else.i.i

if.then124.i.i:                                   ; preds = %if.end26.i.i
  %23 = shl nuw i64 %storemerge.i, 1
  store i64 %23, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_f32_sqrt.exit

if.else.i.i:                                      ; preds = %if.end26.i.i
  %add127.i.i = add nsw i32 %shr121.i.i, 1
  store i32 %add127.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %soft_f32_sqrt.exit

d_nan.i.i:                                        ; preds = %if.end16.i.i, %parts64_canonicalize.exit.thread71.i
  %or1.i.i11 = or i16 %9, 2049
  store i16 %or1.i.i11, ptr %s, align 2
  store i8 4, ptr %p.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_f32_sqrt.exit

soft_f32_sqrt.exit:                               ; preds = %if.then8.i.i, %if.then10.i.i, %parts64_canonicalize.exit.thread71.i, %if.then.i64.i, %if.else.i65.i, %sw.bb1.i.i, %if.then4.i.i, %if.then124.i.i, %if.else.i.i, %d_nan.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %s, ptr noundef nonnull @float32_params)
  %24 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i = zext i8 %24 to i64
  %shl.i.i69.i = shl nuw nsw i64 %conv.i.i.i, 31
  %25 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %26 = shl i32 %25, 23
  %27 = and i32 %26, 2139095040
  %and8.i.i.i = zext nneg i32 %27 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i69.i, %and8.i.i.i
  %28 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %28, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  br label %return

return:                                           ; preds = %soft_f32_sqrt.exit, %if.end13
  %retval.0 = phi i32 [ %conv.i.i, %soft_f32_sqrt.exit ], [ %8, %if.end13 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(write)
declare float @sqrtf(float noundef) local_unnamed_addr #6

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_sqrt(i64 noundef %xa, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p.i = alloca %struct.FloatParts64, align 8
  %0 = load i16, ptr %s, align 2
  %1 = and i16 %0, 16
  %tobool.i.not = icmp eq i16 %1, 0
  br i1 %tobool.i.not, label %soft, label %land.rhs.i

land.rhs.i:                                       ; preds = %entry
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %s, i64 2
  %2 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp.i.not = icmp eq i8 %2, 0
  br i1 %cmp.i.not, label %if.end, label %soft

if.end:                                           ; preds = %land.rhs.i
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %s, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool.i27.not = icmp eq i8 %4, 0
  br i1 %tobool.i27.not, label %float64_input_flush1.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %and.i.i.i = and i64 %xa, 9218868437227405312
  %cmp.i.i.i = icmp eq i64 %and.i.i.i, 0
  %and.i2.i.i = and i64 %xa, 9223372036854775807
  %cmp.i3.i.i = icmp ne i64 %and.i2.i.i, 0
  %5 = and i1 %cmp.i.i.i, %cmp.i3.i.i
  br i1 %5, label %if.then.i, label %float64_input_flush1.exit

if.then.i:                                        ; preds = %if.end.i
  %.lobit.i = and i64 %xa, -9223372036854775808
  %or1.i.i = or i16 %0, 32
  store i16 %or1.i.i, ptr %s, align 2
  br label %float64_input_flush1.exit

float64_input_flush1.exit:                        ; preds = %if.then.i, %if.end.i, %if.end
  %6 = phi i16 [ %0, %if.end ], [ %or1.i.i, %if.then.i ], [ %0, %if.end.i ]
  %ua.sroa.0.1 = phi i64 [ %xa, %if.end ], [ %.lobit.i, %if.then.i ], [ %xa, %if.end.i ]
  %7 = bitcast i64 %ua.sroa.0.1 to double
  %iszero = fcmp oeq double %7, 0.000000e+00
  %or.cond = fcmp ueq double %7, 0.000000e+00
  br i1 %or.cond, label %lor.lhs.false, label %fpclassify_not_nan

lor.lhs.false:                                    ; preds = %float64_input_flush1.exit
  %.old11.old = icmp sgt i64 %ua.sroa.0.1, -1
  %or.cond22.not = and i1 %.old11.old, %iszero
  br i1 %or.cond22.not, label %if.end23, label %soft

fpclassify_not_nan:                               ; preds = %float64_input_flush1.exit
  %or.cond10 = tail call i1 @llvm.is.fpclass.f64(double %7, i32 267)
  %brmerge = or i1 %or.cond10, %iszero
  %.old11 = icmp sgt i64 %ua.sroa.0.1, -1
  %or.cond21.not = and i1 %.old11, %brmerge
  br i1 %or.cond21.not, label %if.end23, label %soft

if.end23:                                         ; preds = %lor.lhs.false, %fpclassify_not_nan
  %call24 = tail call double @sqrt(double noundef %7) #19
  %8 = bitcast double %call24 to i64
  br label %return

soft:                                             ; preds = %lor.lhs.false, %fpclassify_not_nan, %entry, %land.rhs.i
  %9 = phi i16 [ %0, %entry ], [ %0, %land.rhs.i ], [ %6, %fpclassify_not_nan ], [ %6, %lor.lhs.false ]
  %ua.sroa.0.2 = phi i64 [ %xa, %entry ], [ %xa, %land.rhs.i ], [ %ua.sroa.0.1, %fpclassify_not_nan ], [ %ua.sroa.0.1, %lor.lhs.false ]
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %p.i)
  %f.lobit.i.i = lshr i64 %ua.sroa.0.2, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %ua.sroa.0.2, 52
  %10 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %10, 2047
  %and.i9.i.i = and i64 %ua.sroa.0.2, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p.i, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p.i, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p.i, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %parts64_canonicalize.exit.thread.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %soft
  %cmp.i.i.i15 = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i15, label %if.then8.i.i, label %if.else.i60.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p.i, align 8
  br label %soft_f64_sqrt.exit

if.else.i60.i:                                    ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %s, i64 6
  %11 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %12 = and i8 %11, 1
  %tobool9.not.i.i = icmp eq i8 %12, 0
  br i1 %tobool9.not.i.i, label %parts64_canonicalize.exit.thread85.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i60.i
  %or1.i.i.i = or i16 %9, 32
  store i16 %or1.i.i.i, ptr %s, align 2
  store i8 1, ptr %p.i, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_f64_sqrt.exit

parts64_canonicalize.exit.thread85.i:             ; preds = %if.else.i60.i
  %13 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %13 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %13
  store i8 2, ptr %p.i, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  br label %if.end16.i.i

lor.lhs.false.i.i:                                ; preds = %soft
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %parts64_canonicalize.exit.thread86.i, label %parts64_canonicalize.exit.i

parts64_canonicalize.exit.thread.i:               ; preds = %soft
  store i8 2, ptr %p.i, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i59.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  br label %if.end16.i.i

parts64_canonicalize.exit.thread86.i:             ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p.i, align 8
  %tobool8.i.not.i = icmp sgt i64 %ua.sroa.0.2, -1
  br i1 %tobool8.i.not.i, label %soft_f64_sqrt.exit, label %d_nan.i.i

parts64_canonicalize.exit.i:                      ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i57.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i57.i, ptr %p.i, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i61.i, label %sw.bb1.i.i

sw.bb.i61.i:                                      ; preds = %parts64_canonicalize.exit.i
  %or1.i.i62.i = or i16 %9, 8193
  store i16 %or1.i.i62.i, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %14 = load i8, ptr %default_nan_mode.i.i, align 1
  %15 = and i8 %14, 1
  %tobool.not.i.i = icmp eq i8 %15, 0
  br i1 %tobool.not.i.i, label %if.else.i64.i, label %if.then.i63.i

if.then.i63.i:                                    ; preds = %sw.bb.i61.i
  store i8 4, ptr %p.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_f64_sqrt.exit

if.else.i64.i:                                    ; preds = %sw.bb.i61.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p.i, align 8
  br label %soft_f64_sqrt.exit

sw.bb1.i.i:                                       ; preds = %parts64_canonicalize.exit.i
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %16 = load i8, ptr %default_nan_mode2.i.i, align 1
  %17 = and i8 %16, 1
  %tobool3.not.i.i = icmp eq i8 %17, 0
  br i1 %tobool3.not.i.i, label %soft_f64_sqrt.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_f64_sqrt.exit

if.end16.i.i:                                     ; preds = %parts64_canonicalize.exit.thread.i, %parts64_canonicalize.exit.thread85.i
  %18 = phi i64 [ %shl.i.i.i, %parts64_canonicalize.exit.thread85.i ], [ %or.i59.i, %parts64_canonicalize.exit.thread.i ]
  %19 = phi i32 [ %add.i.i, %parts64_canonicalize.exit.thread85.i ], [ %sub37.i.i, %parts64_canonicalize.exit.thread.i ]
  %tobool18.i.not.i = icmp sgt i64 %ua.sroa.0.2, -1
  br i1 %tobool18.i.not.i, label %if.end26.i.i, label %d_nan.i.i

if.end26.i.i:                                     ; preds = %if.end16.i.i
  %and.i.i = and i32 %19, 1
  %shr.i65.i = lshr i64 %18, 57
  %and.i66.i = and i64 %shr.i65.i, 63
  %lnot.ext30.i.i = shl nuw nsw i32 %and.i.i, 6
  %shl.i.i = xor i32 %lnot.ext30.i.i, 64
  %conv31.i.i = zext nneg i32 %shl.i.i to i64
  %or.i.i = or disjoint i64 %and.i66.i, %conv31.i.i
  %20 = xor i32 %and.i.i, 1
  %21 = zext nneg i32 %20 to i64
  %spec.select.i = lshr i64 %18, %21
  %shr.i.i = lshr i64 %spec.select.i, 32
  %arrayidx.i.i = getelementptr [128 x i16], ptr @rsqrt_tab, i64 0, i64 %or.i.i
  %22 = load i16, ptr %arrayidx.i.i, align 2
  %conv36.i.i = zext i16 %22 to i64
  %shl37.i.i = shl nuw nsw i64 %conv36.i.i, 16
  %mul.i.i = mul nuw i64 %shl37.i.i, %shr.i.i
  %shr40.i.i = lshr i64 %mul.i.i, 32
  %mul44.i.i = mul nuw i64 %shr40.i.i, %shl37.i.i
  %shr45.i.i = lshr i64 %mul44.i.i, 32
  %sub.i.i = sub nsw i64 3221225472, %shr45.i.i
  %conv48.i.i = and i64 %sub.i.i, 4294967295
  %mul49.i.i = mul nuw i64 %conv48.i.i, %shl37.i.i
  %shr50.i.i = lshr i64 %mul49.i.i, 31
  %conv53.i.i = and i64 %shr50.i.i, 4294967295
  %mul54.i.i = mul nuw i64 %conv53.i.i, %shr.i.i
  %shr55.i.i = lshr i64 %mul54.i.i, 32
  %mul59.i.i = mul nuw i64 %shr55.i.i, %conv53.i.i
  %shr60.i.i = lshr i64 %mul59.i.i, 32
  %sub62.i.i = sub nsw i64 3221225472, %shr60.i.i
  %conv92.i.i = and i64 %sub62.i.i, 4294967295
  %mul93.i.i = shl nuw nsw i64 %conv53.i.i, 1
  %mul94.i.i = mul i64 %mul93.i.i, %conv92.i.i
  %conv.i.i68.i = zext i64 %spec.select.i to i128
  %conv1.i.i.i = zext i64 %mul94.i.i to i128
  %mul.i.i.i = mul nuw i128 %conv1.i.i.i, %conv.i.i68.i
  %shr.i.i.i = lshr i128 %mul.i.i.i, 64
  %mul.i.i71.i = mul nuw i128 %shr.i.i.i, %conv1.i.i.i
  %shr.i.i73.i = lshr i128 %mul.i.i71.i, 64
  %conv3.i.i74.i = trunc i128 %shr.i.i73.i to i64
  %sub95.i.i = sub i64 -4611686018427387904, %conv3.i.i74.i
  %conv1.i.i76.i = zext i64 %sub95.i.i to i128
  %mul.i.i77.i = mul nuw i128 %shr.i.i.i, %conv1.i.i76.i
  %shr.i.i79.i = lshr i128 %mul.i.i77.i, 64
  %conv3.i.i80.i = trunc i128 %shr.i.i79.i to i64
  %sub96.i.i = add i64 %conv3.i.i80.i, -2
  %shr97.i.i = lshr i64 %sub96.i.i, 9
  %shl99.i.i = shl i64 %spec.select.i, 42
  %mul100.i.i = mul i64 %shr97.i.i, %shr97.i.i
  %sub101.i.neg.i = sub i64 %mul100.i.i, %shl99.i.i
  %sub103.i.i = add i64 %sub101.i.neg.i, %shr97.i.i
  %add105.i.i = add nuw nsw i64 %shr97.i.i, 1
  %add106.i.i = add i64 %add105.i.i, %sub103.i.i
  %shr107.i.i = lshr i64 %sub103.i.i, 63
  %add108.i.i = add nuw nsw i64 %shr107.i.i, %shr97.i.i
  %shl109.i.i = shl i64 %add108.i.i, 10
  %cmp110.i.not.i = icmp eq i64 %add106.i.i, 0
  %xor113.i.i = xor i64 %add106.i.i, %sub103.i.i
  %cmp114.i.inv.i = icmp sgt i64 %xor113.i.i, -1
  %conv117.i.i = select i1 %cmp114.i.inv.i, i64 1, i64 -1
  %add118.i.i = select i1 %cmp110.i.not.i, i64 0, i64 %conv117.i.i
  %storemerge.i = add i64 %add118.i.i, %shl109.i.i
  store i64 %storemerge.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shr121.i.i = ashr i32 %19, 1
  store i32 %shr121.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %tobool123.i.not.i = icmp sgt i64 %storemerge.i, -1
  br i1 %tobool123.i.not.i, label %if.then124.i.i, label %if.else.i.i

if.then124.i.i:                                   ; preds = %if.end26.i.i
  %23 = shl nuw i64 %storemerge.i, 1
  store i64 %23, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_f64_sqrt.exit

if.else.i.i:                                      ; preds = %if.end26.i.i
  %add127.i.i = add nsw i32 %shr121.i.i, 1
  store i32 %add127.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %soft_f64_sqrt.exit

d_nan.i.i:                                        ; preds = %if.end16.i.i, %parts64_canonicalize.exit.thread86.i
  %or1.i.i14 = or i16 %9, 2049
  store i16 %or1.i.i14, ptr %s, align 2
  store i8 4, ptr %p.i, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %soft_f64_sqrt.exit

soft_f64_sqrt.exit:                               ; preds = %if.then8.i.i, %if.then10.i.i, %parts64_canonicalize.exit.thread86.i, %if.then.i63.i, %if.else.i64.i, %sw.bb1.i.i, %if.then4.i.i, %if.then124.i.i, %if.else.i.i, %d_nan.i.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p.i, ptr noundef nonnull %s, ptr noundef nonnull @float64_params)
  %24 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %25 = and i8 %24, 1
  %conv.i.i81.i = zext nneg i8 %25 to i64
  %shl.i.i82.i = shl nuw i64 %conv.i.i81.i, 63
  %26 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %27 = and i32 %26, 2047
  %shl77.i.i.i = zext nneg i32 %27 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i82.i
  %28 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %28, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %p.i)
  br label %return

return:                                           ; preds = %soft_f64_sqrt.exit, %if.end23
  %retval.0 = phi i64 [ %or.i10.i.i, %soft_f64_sqrt.exit ], [ %8, %if.end23 ]
  ret i64 %retval.0
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(write)
declare double @sqrt(double noundef) local_unnamed_addr #6

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64r32_sqrt(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %float64_unpack_canonical.exit.thread [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %parts64_sqrt.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float64_unpack_canonical.exit.thread7, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_sqrt.exit

float64_unpack_canonical.exit.thread7:            ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  br label %if.end16.i

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %float64_unpack_canonical.exit.thread8, label %float64_unpack_canonical.exit

float64_unpack_canonical.exit.thread:             ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  br label %if.end16.i

float64_unpack_canonical.exit.thread8:            ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  %tobool8.not.i = icmp sgt i64 %a, -1
  br i1 %tobool8.not.i, label %parts64_sqrt.exit, label %d_nan.i

float64_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i.i, label %sw.bb1.i.i

sw.bb.i.i:                                        ; preds = %float64_unpack_canonical.exit
  %5 = load i16, ptr %status, align 2
  %or1.i.i.i3 = or i16 %5, 8193
  store i16 %or1.i.i.i3, ptr %status, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %6 = load i8, ptr %default_nan_mode.i.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i.i, label %if.else.i.i5, label %if.then.i.i4

if.then.i.i4:                                     ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_sqrt.exit

if.else.i.i5:                                     ; preds = %sw.bb.i.i
  %or4.i.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_sqrt.exit

sw.bb1.i.i:                                       ; preds = %float64_unpack_canonical.exit
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %status, i64 7
  %8 = load i8, ptr %default_nan_mode2.i.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i.i, label %parts64_sqrt.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_sqrt.exit

if.end16.i:                                       ; preds = %float64_unpack_canonical.exit.thread, %float64_unpack_canonical.exit.thread7
  %10 = phi i64 [ %shl.i.i.i, %float64_unpack_canonical.exit.thread7 ], [ %or.i.i, %float64_unpack_canonical.exit.thread ]
  %11 = phi i32 [ %add.i.i, %float64_unpack_canonical.exit.thread7 ], [ %sub37.i.i, %float64_unpack_canonical.exit.thread ]
  %tobool18.not.i = icmp sgt i64 %a, -1
  br i1 %tobool18.not.i, label %if.end26.i, label %d_nan.i

if.end26.i:                                       ; preds = %if.end16.i
  %and.i = and i32 %11, 1
  %shr.i.i = lshr i64 %10, 57
  %and.i.i = and i64 %shr.i.i, 63
  %lnot.ext30.i = shl nuw nsw i32 %and.i, 6
  %shl.i = xor i32 %lnot.ext30.i, 64
  %conv31.i = zext nneg i32 %shl.i to i64
  %or.i = or disjoint i64 %and.i.i, %conv31.i
  %12 = xor i32 %and.i, 1
  %13 = zext nneg i32 %12 to i64
  %spec.select.i = lshr i64 %10, %13
  %shr.i = lshr i64 %spec.select.i, 32
  %arrayidx.i = getelementptr [128 x i16], ptr @rsqrt_tab, i64 0, i64 %or.i
  %14 = load i16, ptr %arrayidx.i, align 2
  %conv36.i = zext i16 %14 to i64
  %shl37.i = shl nuw nsw i64 %conv36.i, 16
  %mul.i = mul nuw i64 %shr.i, %shl37.i
  %shr40.i = lshr i64 %mul.i, 32
  %mul44.i = mul nuw i64 %shr40.i, %shl37.i
  %shr45.i = lshr i64 %mul44.i, 32
  %sub.i = sub nsw i64 3221225472, %shr45.i
  %conv48.i = and i64 %sub.i, 4294967295
  %mul49.i = mul nuw i64 %conv48.i, %shl37.i
  %shr50.i = lshr i64 %mul49.i, 31
  %conv53.i = and i64 %shr50.i, 4294967295
  %mul54.i = mul nuw i64 %conv53.i, %shr.i
  %shr55.i = lshr i64 %mul54.i, 32
  %mul59.i = mul nuw i64 %shr55.i, %conv53.i
  %shr60.i = lshr i64 %mul59.i, 32
  %sub62.i = sub nsw i64 3221225472, %shr60.i
  %conv92.i = and i64 %sub62.i, 4294967295
  %mul93.i = shl nuw nsw i64 %conv53.i, 1
  %mul94.i = mul i64 %mul93.i, %conv92.i
  %conv.i.i.i6 = zext i64 %spec.select.i to i128
  %conv1.i.i.i = zext i64 %mul94.i to i128
  %mul.i.i.i = mul nuw i128 %conv1.i.i.i, %conv.i.i.i6
  %shr.i.i.i = lshr i128 %mul.i.i.i, 64
  %mul.i.i55.i = mul nuw i128 %shr.i.i.i, %conv1.i.i.i
  %shr.i.i57.i = lshr i128 %mul.i.i55.i, 64
  %conv3.i.i58.i = trunc i128 %shr.i.i57.i to i64
  %sub95.i = sub i64 -4611686018427387904, %conv3.i.i58.i
  %conv1.i.i60.i = zext i64 %sub95.i to i128
  %mul.i.i61.i = mul nuw i128 %shr.i.i.i, %conv1.i.i60.i
  %shr.i.i63.i = lshr i128 %mul.i.i61.i, 64
  %conv3.i.i64.i = trunc i128 %shr.i.i63.i to i64
  %sub96.i = add i64 %conv3.i.i64.i, -2
  %shr97.i = lshr i64 %sub96.i, 9
  %shl99.i = shl i64 %spec.select.i, 42
  %mul100.i = mul i64 %shr97.i, %shr97.i
  %sub101.neg.i = sub i64 %mul100.i, %shl99.i
  %sub103.i = add i64 %sub101.neg.i, %shr97.i
  %add105.i = add nuw nsw i64 %shr97.i, 1
  %add106.i = add i64 %add105.i, %sub103.i
  %shr107.i = lshr i64 %sub103.i, 63
  %add108.i = add nuw nsw i64 %shr107.i, %shr97.i
  %shl109.i = shl i64 %add108.i, 10
  %cmp110.not.i = icmp eq i64 %add106.i, 0
  %xor113.i = xor i64 %add106.i, %sub103.i
  %cmp114.inv.i = icmp sgt i64 %xor113.i, -1
  %conv117.i = select i1 %cmp114.inv.i, i64 1, i64 -1
  %add118.i = select i1 %cmp110.not.i, i64 0, i64 %conv117.i
  %storemerge.i = add i64 %add118.i, %shl109.i
  store i64 %storemerge.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shr121.i = ashr i32 %11, 1
  store i32 %shr121.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %tobool123.not.i = icmp sgt i64 %storemerge.i, -1
  br i1 %tobool123.not.i, label %if.then124.i, label %if.else.i

if.then124.i:                                     ; preds = %if.end26.i
  %15 = shl nuw i64 %storemerge.i, 1
  store i64 %15, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_sqrt.exit

if.else.i:                                        ; preds = %if.end26.i
  %add127.i = add nsw i32 %shr121.i, 1
  store i32 %add127.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %parts64_sqrt.exit

d_nan.i:                                          ; preds = %if.end16.i, %float64_unpack_canonical.exit.thread8
  %16 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %16, 2049
  store i16 %or1.i.i, ptr %status, align 2
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_sqrt.exit

parts64_sqrt.exit:                                ; preds = %if.then10.i.i, %if.then8.i.i, %if.then.i.i4, %if.else.i.i5, %sw.bb1.i.i, %if.then4.i.i, %float64_unpack_canonical.exit.thread8, %if.then124.i, %if.else.i, %d_nan.i
  %call = call fastcc i64 @float64r32_round_pack_canonical(ptr noundef nonnull %p, ptr noundef %status)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i16 @bfloat16_sqrt(i16 noundef zeroext %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i = lshr i16 %a, 15
  %frombool.i.i = trunc i16 %f.lobit.i to i8
  %0 = lshr i16 %a, 7
  %1 = and i16 %0, 255
  %conv.i.i = zext nneg i16 %1 to i32
  %2 = and i16 %a, 127
  %and.i10.i = zext nneg i16 %2 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %trunc = trunc i16 %0 to i8
  switch i8 %trunc, label %parts64_canonicalize.exit.thread [
    i8 0, label %if.then.i
    i8 -1, label %lor.lhs.false.i
  ]

if.then.i:                                        ; preds = %entry
  %cmp.i.i = icmp eq i16 %2, 0
  br i1 %cmp.i.i, label %if.then8.i, label %if.else.i60

if.then8.i:                                       ; preds = %if.then.i
  store i8 1, ptr %p, align 8
  br label %parts64_sqrt.exit

if.else.i60:                                      ; preds = %if.then.i
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %4 = and i8 %3, 1
  %tobool9.not.i = icmp eq i8 %4, 0
  br i1 %tobool9.not.i, label %parts64_canonicalize.exit.thread71, label %if.then10.i

if.then10.i:                                      ; preds = %if.else.i60
  %5 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %5, 32
  store i16 %or1.i.i, ptr %status, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_sqrt.exit

parts64_canonicalize.exit.thread71:               ; preds = %if.else.i60
  %6 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i, i1 true), !range !5
  %cast.i.i.i = trunc i64 %6 to i32
  %shl.i.i = shl i64 %and.i10.i, %6
  store i8 2, ptr %p, align 8
  %add.i61 = sub nuw nsw i32 -70, %cast.i.i.i
  br label %if.end16.i

lor.lhs.false.i:                                  ; preds = %entry
  %cmp.i29.i = icmp eq i16 %2, 0
  br i1 %cmp.i29.i, label %parts64_canonicalize.exit.thread72, label %parts64_canonicalize.exit

parts64_canonicalize.exit.thread:                 ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i = add nsw i32 %conv.i.i, -127
  %shl.i28.i = shl nuw nsw i64 %and.i10.i, 56
  %or.i59 = or disjoint i64 %shl.i28.i, -9223372036854775808
  br label %if.end16.i

parts64_canonicalize.exit.thread72:               ; preds = %lor.lhs.false.i
  store i8 3, ptr %p, align 8
  %tobool8.i.not = icmp sgt i16 %a, -1
  br i1 %tobool8.i.not, label %parts64_sqrt.exit, label %d_nan.i

parts64_canonicalize.exit:                        ; preds = %lor.lhs.false.i
  %shl.i31.i = shl nuw nsw i64 %and.i10.i, 56
  store i64 %shl.i31.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %tobool.not.i32.i = icmp ult i16 %2, 64
  %conv53.i57 = select i1 %tobool.not.i32.i, i8 5, i8 4
  store i8 %conv53.i57, ptr %p, align 8
  br i1 %tobool.not.i32.i, label %sw.bb.i62, label %sw.bb1.i

sw.bb.i62:                                        ; preds = %parts64_canonicalize.exit
  %7 = load i16, ptr %status, align 2
  %or1.i.i63 = or i16 %7, 8193
  store i16 %or1.i.i63, ptr %status, align 2
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %8 = load i8, ptr %default_nan_mode.i, align 1
  %9 = and i8 %8, 1
  %tobool.not.i = icmp eq i8 %9, 0
  br i1 %tobool.not.i, label %if.else.i65, label %if.then.i64

if.then.i64:                                      ; preds = %sw.bb.i62
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_sqrt.exit

if.else.i65:                                      ; preds = %sw.bb.i62
  %or4.i.i.i = or disjoint i64 %shl.i31.i, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts64_sqrt.exit

sw.bb1.i:                                         ; preds = %parts64_canonicalize.exit
  %default_nan_mode2.i = getelementptr inbounds i8, ptr %status, i64 7
  %10 = load i8, ptr %default_nan_mode2.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i, label %parts64_sqrt.exit, label %if.then4.i

if.then4.i:                                       ; preds = %sw.bb1.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_sqrt.exit

if.end16.i:                                       ; preds = %parts64_canonicalize.exit.thread, %parts64_canonicalize.exit.thread71
  %12 = phi i64 [ %shl.i.i, %parts64_canonicalize.exit.thread71 ], [ %or.i59, %parts64_canonicalize.exit.thread ]
  %13 = phi i32 [ %add.i61, %parts64_canonicalize.exit.thread71 ], [ %sub37.i, %parts64_canonicalize.exit.thread ]
  %tobool18.i.not = icmp sgt i16 %a, -1
  br i1 %tobool18.i.not, label %if.end26.i, label %d_nan.i

if.end26.i:                                       ; preds = %if.end16.i
  %and.i = and i32 %13, 1
  %shr.i66 = lshr i64 %12, 57
  %and.i67 = and i64 %shr.i66, 63
  %lnot.ext30.i = shl nuw nsw i32 %and.i, 6
  %shl.i = xor i32 %lnot.ext30.i, 64
  %conv31.i = zext nneg i32 %shl.i to i64
  %or.i = or disjoint i64 %and.i67, %conv31.i
  %14 = xor i32 %and.i, 1
  %15 = zext nneg i32 %14 to i64
  %spec.select = lshr i64 %12, %15
  %shr.i = lshr i64 %spec.select, 32
  %arrayidx.i = getelementptr [128 x i16], ptr @rsqrt_tab, i64 0, i64 %or.i
  %16 = load i16, ptr %arrayidx.i, align 2
  %conv36.i = zext i16 %16 to i64
  %shl37.i = shl nuw nsw i64 %conv36.i, 16
  %mul.i = mul nuw i64 %shl37.i, %shr.i
  %shr40.i = lshr i64 %mul.i, 32
  %mul44.i = mul nuw i64 %shr40.i, %shl37.i
  %shr45.i = lshr i64 %mul44.i, 32
  %sub.i = sub nsw i64 3221225472, %shr45.i
  %conv48.i = and i64 %sub.i, 4294967295
  %mul49.i = mul nuw i64 %conv48.i, %shl37.i
  %shr50.i = lshr i64 %mul49.i, 31
  %conv53.i = and i64 %shr50.i, 4294967295
  %mul54.i = mul nuw i64 %conv53.i, %shr.i
  %shr55.i = lshr i64 %mul54.i, 32
  %mul59.i = mul nuw i64 %shr55.i, %conv53.i
  %shr60.i = lshr i64 %mul59.i, 32
  %sub62.i = sub nsw i64 3221225472, %shr60.i
  %conv35.i = trunc i64 %shr.i to i32
  %conv67.i = and i64 %sub62.i, 4294967295
  %mul68.i = mul nuw i64 %conv67.i, %shr55.i
  %shr69.i = lshr i64 %mul68.i, 32
  %conv70.i = trunc i64 %shr69.i to i32
  %sub71.i = add i32 %conv70.i, -1
  %shr72.i = lshr i32 %sub71.i, 6
  %shl73.i = shl i32 %conv35.i, 16
  %mul74.i = mul i32 %shr72.i, %shr72.i
  %sub75.i.neg = sub i32 %mul74.i, %shl73.i
  %sub76.i = add i32 %sub75.i.neg, %shr72.i
  %add.i = add nuw nsw i32 %shr72.i, 1
  %add77.i = add i32 %add.i, %sub76.i
  %shr78.i = lshr i32 %sub76.i, 31
  %add79.i = add nuw nsw i32 %shr78.i, %shr72.i
  %conv80.i = zext nneg i32 %add79.i to i64
  %shl81.i = shl i64 %conv80.i, 39
  %cmp82.i.not = icmp eq i32 %add77.i, 0
  %xor.i = xor i32 %add77.i, %sub76.i
  %cmp85.i.inv = icmp sgt i32 %xor.i, -1
  %cond.i = select i1 %cmp85.i.inv, i64 1, i64 -1
  %add88.i = select i1 %cmp82.i.not, i64 0, i64 %cond.i
  %storemerge = add i64 %add88.i, %shl81.i
  store i64 %storemerge, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %shr121.i = ashr i32 %13, 1
  store i32 %shr121.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %tobool123.i.not = icmp sgt i64 %storemerge, -1
  br i1 %tobool123.i.not, label %if.then124.i, label %if.else.i

if.then124.i:                                     ; preds = %if.end26.i
  %17 = shl nuw i64 %storemerge, 1
  store i64 %17, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_sqrt.exit

if.else.i:                                        ; preds = %if.end26.i
  %add127.i = add nsw i32 %shr121.i, 1
  store i32 %add127.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_sqrt.exit

d_nan.i:                                          ; preds = %if.end16.i, %parts64_canonicalize.exit.thread72
  %18 = load i16, ptr %status, align 2
  %or1.i = or i16 %18, 2049
  store i16 %or1.i, ptr %status, align 2
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_sqrt.exit

parts64_sqrt.exit:                                ; preds = %if.then10.i, %if.then8.i, %if.then4.i, %sw.bb1.i, %if.else.i65, %if.then.i64, %if.then124.i, %if.else.i, %parts64_canonicalize.exit.thread72, %d_nan.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @bfloat16_params)
  %19 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  %conv.i.i69 = zext i8 %19 to i64
  %shl.i.i70 = shl nuw nsw i64 %conv.i.i69, 15
  %20 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %21 = shl i32 %20, 7
  %22 = and i32 %21, 32640
  %and8.i.i = zext nneg i32 %22 to i64
  %or.i.i = or disjoint i64 %shl.i.i70, %and8.i.i
  %23 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %shl77.i9.i = and i64 %23, 127
  %or.i10.i = or disjoint i64 %or.i.i, %shl77.i9.i
  %conv.i = trunc i64 %or.i10.i to i16
  ret i16 %conv.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i64 } @float128_sqrt(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %shr.i16.i = lshr i64 %a.coerce1, 48
  %0 = trunc i64 %shr.i16.i to i32
  %conv.i = and i32 %0, 32767
  %f.coerce1.lobit.i = lshr i64 %a.coerce1, 63
  %frombool.i = trunc i64 %f.coerce1.lobit.i to i8
  %and.i.i = and i64 %a.coerce1, 281474976710655
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.33.0..sroa_idx.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float128_params)
  %1 = load i8, ptr %p, align 8
  switch i8 %1, label %sw.default.i [
    i8 2, label %if.end16.i
    i8 3, label %sw.bb7.i
    i8 1, label %parts128_uncanon.exit
    i8 5, label %sw.bb.i35
    i8 4, label %sw.bb1.i
  ]

sw.bb.i35:                                        ; preds = %entry
  %2 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %2, 8193
  store i16 %or1.i.i, ptr %status, align 2
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %3 = load i8, ptr %default_nan_mode.i, align 1
  %4 = and i8 %3, 1
  %tobool.not.i = icmp eq i8 %4, 0
  br i1 %tobool.not.i, label %if.else.i36, label %if.then.i

if.then.i:                                        ; preds = %sw.bb.i35
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %do.end18.i

if.else.i36:                                      ; preds = %sw.bb.i35
  %5 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %or4.i.i.i = or i64 %5, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  br label %do.end18.i

sw.bb1.i:                                         ; preds = %entry
  %default_nan_mode2.i = getelementptr inbounds i8, ptr %status, i64 7
  %6 = load i8, ptr %default_nan_mode2.i, align 1
  %7 = and i8 %6, 1
  %tobool3.not.i = icmp eq i8 %7, 0
  br i1 %tobool3.not.i, label %parts128_sqrt.exit, label %if.then4.i

if.then4.i:                                       ; preds = %sw.bb1.i
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %do.end18.i

sw.bb7.i:                                         ; preds = %entry
  %8 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %9 = and i8 %8, 1
  %tobool8.i.not = icmp eq i8 %9, 0
  br i1 %tobool8.i.not, label %do.end.i, label %d_nan.i

sw.default.i:                                     ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 724, ptr noundef nonnull @__func__.parts128_sqrt, ptr noundef null) #16
  unreachable

if.end16.i:                                       ; preds = %entry
  %10 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %11 = and i8 %10, 1
  %tobool18.i.not = icmp eq i8 %11, 0
  br i1 %tobool18.i.not, label %if.end26.i, label %d_nan.i

if.end26.i:                                       ; preds = %if.end16.i
  %12 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %and.i = and i32 %12, 1
  %tobool27.i.not = icmp eq i32 %and.i, 0
  %13 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %shr.i37 = lshr i64 %13, 57
  %and.i38 = and i64 %shr.i37, 63
  %lnot.ext30.i = shl nuw nsw i32 %and.i, 6
  %shl.i = xor i32 %lnot.ext30.i, 64
  %conv31.i = zext nneg i32 %shl.i to i64
  %or.i = or disjoint i64 %and.i38, %conv31.i
  %.pre = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br i1 %tobool27.i.not, label %if.then33.i, label %if.end34.i

if.then33.i:                                      ; preds = %if.end26.i
  %14 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %13, i32 1, i64 %.pre) #15, !srcloc !6
  %shr.i41 = lshr i64 %13, 1
  br label %if.end34.i

if.end34.i:                                       ; preds = %if.then33.i, %if.end26.i
  %15 = phi i64 [ %14, %if.then33.i ], [ %.pre, %if.end26.i ]
  %16 = phi i64 [ %shr.i41, %if.then33.i ], [ %13, %if.end26.i ]
  %shr.i = lshr i64 %16, 32
  %arrayidx.i = getelementptr [128 x i16], ptr @rsqrt_tab, i64 0, i64 %or.i
  %17 = load i16, ptr %arrayidx.i, align 2
  %conv37.i = zext i16 %17 to i64
  %shl38.i = shl nuw nsw i64 %conv37.i, 16
  %mul.i = mul nuw i64 %shl38.i, %shr.i
  %shr41.i = lshr i64 %mul.i, 32
  %mul45.i = mul nuw i64 %shr41.i, %shl38.i
  %shr46.i = lshr i64 %mul45.i, 32
  %sub.i = sub nsw i64 3221225472, %shr46.i
  %conv49.i = and i64 %sub.i, 4294967295
  %mul50.i = shl nuw nsw i64 %conv37.i, 17
  %mul51.i = mul i64 %mul50.i, %conv49.i
  %conv.i.i = zext i64 %16 to i128
  %conv1.i.i = zext i64 %mul51.i to i128
  %mul.i.i = mul nuw i128 %conv1.i.i, %conv.i.i
  %shr.i.i = lshr i128 %mul.i.i, 64
  %mul.i.i44 = mul nuw i128 %shr.i.i, %conv1.i.i
  %shr.i.i46 = lshr i128 %mul.i.i44, 64
  %conv3.i.i47 = trunc i128 %shr.i.i46 to i64
  %sub52.i = sub i64 -4611686018427387904, %conv3.i.i47
  %conv.i.i48 = zext i64 %sub52.i to i128
  %mul.i.i50 = mul nuw i128 %conv.i.i48, %conv1.i.i
  %sh.diff = lshr i128 %mul.i.i50, 63
  %conv1.i.i55 = and i128 %sh.diff, 18446744073709551614
  %mul.i.i56 = mul nuw i128 %conv1.i.i55, %conv.i.i
  %shr.i.i58 = lshr i128 %mul.i.i56, 64
  %mul.i.i62 = mul nuw i128 %shr.i.i58, %conv1.i.i55
  %shr.i.i64 = lshr i128 %mul.i.i62, 64
  %conv3.i.i65 = trunc i128 %shr.i.i64 to i64
  %sub54.i = sub i64 -4611686018427387904, %conv3.i.i65
  %conv.i.i66 = zext i64 %sub54.i to i128
  %mul.i.i68 = mul nuw i128 %conv1.i.i55, %conv.i.i66
  %conv2.i.i69 = trunc i128 %mul.i.i68 to i64
  %18 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i69, i64 %conv2.i.i69)
  %19 = extractvalue { i64, i1 } %18, 1
  %20 = extractvalue { i64, i1 } %18, 0
  %conv.i1.i = zext i1 %19 to i64
  %sh.diff195 = lshr i128 %mul.i.i68, 63
  %tr.sh.diff = trunc i128 %sh.diff195 to i64
  %21 = and i64 %tr.sh.diff, -2
  %22 = or disjoint i64 %21, %conv.i1.i
  %conv.i.i.i = zext i64 %15 to i128
  %conv1.i.i.i = zext i64 %22 to i128
  %mul.i.i.i = mul nuw i128 %conv1.i.i.i, %conv.i.i.i
  %conv2.i.i.i = trunc i128 %mul.i.i.i to i64
  %shr.i.i.i = lshr i128 %mul.i.i.i, 64
  %conv3.i.i.i = trunc i128 %shr.i.i.i to i64
  %conv1.i.i6.i = zext i64 %20 to i128
  %mul.i.i7.i = mul nuw i128 %conv1.i.i6.i, %conv.i.i
  %conv2.i.i8.i = trunc i128 %mul.i.i7.i to i64
  %shr.i.i9.i = lshr i128 %mul.i.i7.i, 64
  %conv3.i.i10.i = trunc i128 %shr.i.i9.i to i64
  %mul.i.i13.i = mul nuw i128 %conv1.i.i6.i, %conv.i.i.i
  %shr.i.i15.i = lshr i128 %mul.i.i13.i, 64
  %conv3.i.i16.i = trunc i128 %shr.i.i15.i to i64
  %mul.i.i19.i = mul nuw i128 %conv1.i.i.i, %conv.i.i
  %conv2.i.i20.i = trunc i128 %mul.i.i19.i to i64
  %shr.i.i21.i = lshr i128 %mul.i.i19.i, 64
  %conv3.i.i22.i = trunc i128 %shr.i.i21.i to i64
  %23 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i.i, i64 %conv2.i.i8.i)
  %24 = extractvalue { i64, i1 } %23, 1
  %25 = extractvalue { i64, i1 } %23, 0
  %conv.i1.i.i = zext i1 %24 to i64
  %26 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv3.i.i.i, i64 %conv3.i.i10.i)
  %27 = extractvalue { i64, i1 } %26, 1
  %28 = extractvalue { i64, i1 } %26, 0
  %29 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %28, i64 %conv.i1.i.i)
  %30 = extractvalue { i64, i1 } %29, 1
  %31 = extractvalue { i64, i1 } %29, 0
  %32 = or i1 %27, %30
  %conv.i3.i.i = zext i1 %32 to i64
  %33 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %25, i64 %conv3.i.i16.i)
  %34 = extractvalue { i64, i1 } %33, 1
  %conv.i1.i23.i = zext i1 %34 to i64
  %35 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %31, i64 %conv2.i.i20.i)
  %36 = extractvalue { i64, i1 } %35, 1
  %37 = extractvalue { i64, i1 } %35, 0
  %38 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %37, i64 %conv.i1.i23.i)
  %39 = extractvalue { i64, i1 } %38, 1
  %40 = extractvalue { i64, i1 } %38, 0
  %41 = or i1 %36, %39
  %conv.i3.i24.i = zext i1 %41 to i64
  %42 = add nuw i64 %conv.i3.i.i, %conv3.i.i22.i
  %43 = add i64 %42, %conv.i3.i24.i
  %conv.i.i.i72 = zext i64 %40 to i128
  %mul.i.i.i74 = mul nuw i128 %conv.i.i.i72, %conv1.i.i.i
  %conv2.i.i.i75 = trunc i128 %mul.i.i.i74 to i64
  %shr.i.i.i76 = lshr i128 %mul.i.i.i74, 64
  %conv3.i.i.i77 = trunc i128 %shr.i.i.i76 to i64
  %conv.i.i5.i78 = zext i64 %43 to i128
  %mul.i.i7.i80 = mul nuw i128 %conv.i.i5.i78, %conv1.i.i6.i
  %conv2.i.i8.i81 = trunc i128 %mul.i.i7.i80 to i64
  %shr.i.i9.i82 = lshr i128 %mul.i.i7.i80, 64
  %conv3.i.i10.i83 = trunc i128 %shr.i.i9.i82 to i64
  %mul.i.i13.i84 = mul nuw i128 %conv.i.i.i72, %conv1.i.i6.i
  %shr.i.i15.i86 = lshr i128 %mul.i.i13.i84, 64
  %conv3.i.i16.i87 = trunc i128 %shr.i.i15.i86 to i64
  %mul.i.i19.i88 = mul nuw i128 %conv.i.i5.i78, %conv1.i.i.i
  %conv2.i.i20.i89 = trunc i128 %mul.i.i19.i88 to i64
  %shr.i.i21.i90 = lshr i128 %mul.i.i19.i88, 64
  %conv3.i.i22.i91 = trunc i128 %shr.i.i21.i90 to i64
  %44 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i.i75, i64 %conv2.i.i8.i81)
  %45 = extractvalue { i64, i1 } %44, 1
  %46 = extractvalue { i64, i1 } %44, 0
  %conv.i1.i.i92 = zext i1 %45 to i64
  %47 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv3.i.i.i77, i64 %conv3.i.i10.i83)
  %48 = extractvalue { i64, i1 } %47, 1
  %49 = extractvalue { i64, i1 } %47, 0
  %50 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %49, i64 %conv.i1.i.i92)
  %51 = extractvalue { i64, i1 } %50, 1
  %52 = extractvalue { i64, i1 } %50, 0
  %53 = or i1 %48, %51
  %conv.i3.i.i93.neg199 = sext i1 %53 to i64
  %54 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %46, i64 %conv3.i.i16.i87)
  %55 = extractvalue { i64, i1 } %54, 1
  %conv.i1.i23.i94 = zext i1 %55 to i64
  %56 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %52, i64 %conv2.i.i20.i89)
  %57 = extractvalue { i64, i1 } %56, 1
  %58 = extractvalue { i64, i1 } %56, 0
  %59 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %58, i64 %conv.i1.i23.i94)
  %60 = extractvalue { i64, i1 } %59, 1
  %61 = extractvalue { i64, i1 } %59, 0
  %62 = or i1 %57, %60
  %conv.i3.i24.i95.neg200 = sext i1 %62 to i64
  %63 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 0, i64 %61)
  %64 = extractvalue { i64, i1 } %63, 1
  %65 = extractvalue { i64, i1 } %63, 0
  %conv.i1.neg.i = sext i1 %64 to i64
  %reass.sub201 = sub i64 %conv.i3.i.i93.neg199, %conv3.i.i22.i91
  %.neg198 = add i64 %reass.sub201, -4611686018427387904
  %reass.sub = add i64 %.neg198, %conv.i3.i24.i95.neg200
  %66 = add i64 %reass.sub, %conv.i1.neg.i
  %conv.i.i.i96 = zext i64 %65 to i128
  %mul.i.i.i98 = mul nuw i128 %conv.i.i.i96, %conv.i.i5.i78
  %conv2.i.i.i99 = trunc i128 %mul.i.i.i98 to i64
  %shr.i.i.i100 = lshr i128 %mul.i.i.i98, 64
  %conv3.i.i.i101 = trunc i128 %shr.i.i.i100 to i64
  %conv.i.i5.i102 = zext i64 %66 to i128
  %mul.i.i7.i104 = mul nuw i128 %conv.i.i5.i102, %conv.i.i.i72
  %conv2.i.i8.i105 = trunc i128 %mul.i.i7.i104 to i64
  %shr.i.i9.i106 = lshr i128 %mul.i.i7.i104, 64
  %conv3.i.i10.i107 = trunc i128 %shr.i.i9.i106 to i64
  %mul.i.i13.i108 = mul nuw i128 %conv.i.i.i96, %conv.i.i.i72
  %shr.i.i15.i110 = lshr i128 %mul.i.i13.i108, 64
  %conv3.i.i16.i111 = trunc i128 %shr.i.i15.i110 to i64
  %mul.i.i19.i112 = mul nuw i128 %conv.i.i5.i102, %conv.i.i5.i78
  %conv2.i.i20.i113 = trunc i128 %mul.i.i19.i112 to i64
  %shr.i.i21.i114 = lshr i128 %mul.i.i19.i112, 64
  %conv3.i.i22.i115 = trunc i128 %shr.i.i21.i114 to i64
  %67 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i.i99, i64 %conv2.i.i8.i105)
  %68 = extractvalue { i64, i1 } %67, 1
  %69 = extractvalue { i64, i1 } %67, 0
  %conv.i1.i.i116 = zext i1 %68 to i64
  %70 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv3.i.i.i101, i64 %conv3.i.i10.i107)
  %71 = extractvalue { i64, i1 } %70, 1
  %72 = extractvalue { i64, i1 } %70, 0
  %73 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %72, i64 %conv.i1.i.i116)
  %74 = extractvalue { i64, i1 } %73, 1
  %75 = extractvalue { i64, i1 } %73, 0
  %76 = or i1 %71, %74
  %conv.i3.i.i117 = zext i1 %76 to i64
  %77 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %69, i64 %conv3.i.i16.i111)
  %78 = extractvalue { i64, i1 } %77, 1
  %conv.i1.i23.i118 = zext i1 %78 to i64
  %79 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %75, i64 %conv2.i.i20.i113)
  %80 = extractvalue { i64, i1 } %79, 1
  %81 = extractvalue { i64, i1 } %79, 0
  %82 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %81, i64 %conv.i1.i23.i118)
  %83 = extractvalue { i64, i1 } %82, 1
  %84 = extractvalue { i64, i1 } %82, 0
  %85 = or i1 %80, %83
  %conv.i3.i24.i119 = zext i1 %85 to i64
  %86 = add nuw i64 %conv.i3.i.i117, %conv3.i.i22.i115
  %87 = add i64 %86, %conv.i3.i24.i119
  %88 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %84, i64 4)
  %89 = extractvalue { i64, i1 } %88, 1
  %90 = extractvalue { i64, i1 } %88, 0
  %conv.i1.neg.i120 = sext i1 %89 to i64
  %91 = add i64 %87, %conv.i1.neg.i120
  %shr8.i = lshr i64 %91, 13
  %or.i123 = tail call i64 @llvm.fshl.i64(i64 %91, i64 %90, i64 51)
  %conv.i.i124 = zext i64 %or.i123 to i128
  %mul.i.i126 = mul nuw i128 %conv.i.i124, %conv.i.i124
  %conv2.i.i127 = trunc i128 %mul.i.i126 to i64
  %shr.i.i128 = lshr i128 %mul.i.i126, 64
  %conv3.i.i129 = trunc i128 %shr.i.i128 to i64
  %mul56.i = shl nuw nsw i64 %shr8.i, 1
  %mul57.i = mul i64 %mul56.i, %or.i123
  %92 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 0, i64 %conv2.i.i127)
  %93 = extractvalue { i64, i1 } %92, 1
  %94 = extractvalue { i64, i1 } %92, 0
  %conv.i1.neg.i130.neg = zext i1 %93 to i64
  %95 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %or.i123, i64 %94)
  %96 = extractvalue { i64, i1 } %95, 1
  %97 = extractvalue { i64, i1 } %95, 0
  %conv.i1.neg.i131 = sext i1 %96 to i64
  %98 = shl i64 %15, 34
  %add.i = sub i64 %shr8.i, %98
  %.neg = add i64 %add.i, %mul57.i
  %.neg196 = add i64 %.neg, %conv3.i.i129
  %99 = add i64 %.neg196, %conv.i1.neg.i130.neg
  %100 = add i64 %99, %conv.i1.neg.i131
  %101 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %or.i123, i64 1)
  %102 = extractvalue { i64, i1 } %101, 1
  %103 = extractvalue { i64, i1 } %101, 0
  %conv.i1.i132 = zext i1 %102 to i64
  %104 = add nuw nsw i64 %shr8.i, %conv.i1.i132
  %105 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %103, i64 %97)
  %106 = extractvalue { i64, i1 } %105, 1
  %107 = extractvalue { i64, i1 } %105, 0
  %conv.i1.i133 = zext i1 %106 to i64
  %108 = add i64 %104, %100
  %109 = add i64 %108, %conv.i1.i133
  %shr60.i = lshr i64 %100, 63
  %110 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %or.i123, i64 %shr60.i)
  %111 = extractvalue { i64, i1 } %110, 1
  %112 = extractvalue { i64, i1 } %110, 0
  %conv.i1.i134 = zext i1 %111 to i64
  %113 = add nuw nsw i64 %shr8.i, %conv.i1.i134
  %shl.i135 = shl i64 %112, 14
  %or.i136 = tail call i64 @llvm.fshl.i64(i64 %113, i64 %112, i64 14)
  %or61.i = or i64 %109, %107
  %tobool62.i.not = icmp eq i64 %or61.i, 0
  br i1 %tobool62.i.not, label %if.end68.i, label %if.then63.i

if.then63.i:                                      ; preds = %if.end34.i
  %xor.i = xor i64 %109, %100
  %cmp64.i = icmp slt i64 %xor.i, 0
  br i1 %cmp64.i, label %if.then66.i, label %if.else.i

if.then66.i:                                      ; preds = %if.then63.i
  %114 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %shl.i135, i64 1)
  %115 = extractvalue { i64, i1 } %114, 1
  %116 = extractvalue { i64, i1 } %114, 0
  %conv.i1.neg.i137 = sext i1 %115 to i64
  %117 = add i64 %or.i136, %conv.i1.neg.i137
  br label %if.end68.i

if.else.i:                                        ; preds = %if.then63.i
  %118 = or disjoint i64 %shl.i135, 1
  br label %if.end68.i

if.end68.i:                                       ; preds = %if.then66.i, %if.else.i, %if.end34.i
  %sl.i.0 = phi i64 [ %shl.i135, %if.end34.i ], [ %116, %if.then66.i ], [ %118, %if.else.i ]
  %sh.i.0 = phi i64 [ %or.i136, %if.end34.i ], [ %117, %if.then66.i ], [ %or.i136, %if.else.i ]
  store i64 %sl.i.0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  store i64 %sh.i.0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %shr72.i = ashr i32 %12, 1
  store i32 %shr72.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %tobool75.i.not = icmp sgt i64 %sh.i.0, -1
  br i1 %tobool75.i.not, label %if.then76.i, label %if.else78.i

if.then76.i:                                      ; preds = %if.end68.i
  %119 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %sl.i.0, i64 %sl.i.0)
  %120 = extractvalue { i64, i1 } %119, 1
  %121 = extractvalue { i64, i1 } %119, 0
  store i64 %121, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %conv.i4.i = zext i1 %120 to i64
  %122 = shl nuw i64 %sh.i.0, 1
  %123 = or disjoint i64 %122, %conv.i4.i
  store i64 %123, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  br label %parts128_sqrt.exit

if.else78.i:                                      ; preds = %if.end68.i
  %add80.i = add nsw i32 %shr72.i, 1
  store i32 %add80.i, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  br label %parts128_sqrt.exit

d_nan.i:                                          ; preds = %if.end16.i, %sw.bb7.i
  %124 = load i16, ptr %status, align 2
  %or1.i = or i16 %124, 2049
  store i16 %or1.i, ptr %status, align 2
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  br label %do.end18.i

parts128_sqrt.exit:                               ; preds = %sw.bb1.i, %if.then76.i, %if.else78.i
  %.pr = load i8, ptr %p, align 8
  switch i8 %.pr, label %do.body21.i [
    i8 2, label %if.then.i147
    i8 1, label %parts128_uncanon.exit
    i8 3, label %do.end.i
    i8 4, label %do.end18.i
    i8 5, label %do.end18.i
  ]

if.then.i147:                                     ; preds = %parts128_sqrt.exit
  call fastcc void @parts128_uncanon_normal(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float128_params)
  %.pre203 = load i32, ptr %.compoundliteral.sroa.33.0..sroa_idx.i, align 4
  %.pre204 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %.pre205 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %125 = zext i32 %.pre203 to i64
  %126 = shl i64 %125, 48
  %127 = and i64 %126, 9223090561878065152
  br label %parts128_uncanon.exit

do.end.i:                                         ; preds = %sw.bb7.i, %parts128_sqrt.exit
  br label %parts128_uncanon.exit

do.end18.i:                                       ; preds = %d_nan.i, %if.then.i, %if.else.i36, %if.then4.i, %parts128_sqrt.exit, %parts128_sqrt.exit
  %128 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  %129 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i, align 8
  %130 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %128, i32 15, i64 %129) #15, !srcloc !6
  %shr.i.i144 = lshr i64 %128, 15
  br label %parts128_uncanon.exit

do.body21.i:                                      ; preds = %parts128_sqrt.exit
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 330, ptr noundef nonnull @__func__.parts128_uncanon, ptr noundef null) #16
  unreachable

parts128_uncanon.exit:                            ; preds = %parts128_sqrt.exit, %entry, %if.then.i147, %do.end.i, %do.end18.i
  %131 = phi i64 [ %.pre205, %if.then.i147 ], [ 0, %do.end.i ], [ %130, %do.end18.i ], [ 0, %entry ], [ 0, %parts128_sqrt.exit ]
  %132 = phi i64 [ %.pre204, %if.then.i147 ], [ 0, %do.end.i ], [ %shr.i.i144, %do.end18.i ], [ 0, %entry ], [ 0, %parts128_sqrt.exit ]
  %conv1.i = phi i64 [ %127, %if.then.i147 ], [ 9223090561878065152, %do.end.i ], [ 9223090561878065152, %do.end18.i ], [ 0, %entry ], [ 0, %parts128_sqrt.exit ]
  %133 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %134 = and i8 %133, 1
  %conv.i151 = zext nneg i8 %134 to i64
  %shl.i152 = shl nuw i64 %conv.i151, 63
  %or.i25.i = or disjoint i64 %conv1.i, %shl.i152
  %and8.i.i = and i64 %132, 281474976710655
  %or.i.i = or disjoint i64 %or.i25.i, %and8.i.i
  %.fca.0.insert.i = insertvalue { i64, i64 } poison, i64 %131, 0
  %.fca.1.insert.i = insertvalue { i64, i64 } %.fca.0.insert.i, i64 %or.i.i, 1
  ret { i64, i64 } %.fca.1.insert.i
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @floatx80_sqrt(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef %s) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %floatx80_rounding_precision.i = getelementptr inbounds i8, ptr %s, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i = icmp ult i8 %0, 3
  br i1 %switch.i, label %sw.epilog.i, label %do.body.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %entry
  %cmp.i.i = icmp slt i64 %a.coerce0, 0
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i.i = icmp eq i16 %1, 0
  %.not.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  br i1 %.not.i, label %if.end.i, label %if.then

if.end.i:                                         ; preds = %sw.epilog.i
  %f.coerce1.lobit.i.i = lshr i16 %a.coerce1, 15
  %frombool.i.i = trunc i16 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %and.i.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.not.i = icmp eq i16 %1, 32767
  br i1 %cmp.not.i, label %if.else.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef nonnull %s, ptr noundef nonnull @floatx80_params)
  %.pr = load i8, ptr %p, align 8
  br label %if.end

if.else.i:                                        ; preds = %if.end.i
  %and.i = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %2 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i.i = icmp eq i64 %2, 0
  %3 = select i1 %tobool.not.i.i, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %3
  store i8 %cond17.i, ptr %p, align 8
  br label %if.end

if.then:                                          ; preds = %sw.epilog.i
  %4 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %4, 1
  store i16 %or1.i.i, ptr %s, align 2
  br label %return

if.end:                                           ; preds = %if.then10.i, %if.else.i
  %5 = phi i8 [ %.pr, %if.then10.i ], [ %cond17.i, %if.else.i ]
  switch i8 %5, label %do.body.i12 [
    i8 2, label %if.end16.i
    i8 3, label %sw.bb7.i
    i8 1, label %parts128_sqrt.exit
    i8 5, label %sw.bb.i.i
    i8 4, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end
  %6 = load i16, ptr %s, align 2
  %or1.i.i.i = or i16 %6, 8193
  store i16 %or1.i.i.i, ptr %s, align 2
  %default_nan_mode.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %7 = load i8, ptr %default_nan_mode.i.i, align 1
  %8 = and i8 %7, 1
  %tobool.not.i.i5 = icmp eq i8 %8, 0
  br i1 %tobool.not.i.i5, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %sw.bb.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %parts128_sqrt.exit

if.else.i.i:                                      ; preds = %sw.bb.i.i
  %9 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %or4.i.i.i.i = or i64 %9, 4611686018427387904
  store i64 %or4.i.i.i.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %p, align 8
  br label %parts128_sqrt.exit

sw.bb1.i.i:                                       ; preds = %if.end
  %default_nan_mode2.i.i = getelementptr inbounds i8, ptr %s, i64 7
  %10 = load i8, ptr %default_nan_mode2.i.i, align 1
  %11 = and i8 %10, 1
  %tobool3.not.i.i = icmp eq i8 %11, 0
  br i1 %tobool3.not.i.i, label %parts128_sqrt.exit, label %if.then4.i.i

if.then4.i.i:                                     ; preds = %sw.bb1.i.i
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %parts128_sqrt.exit

sw.bb7.i:                                         ; preds = %if.end
  %12 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %13 = and i8 %12, 1
  %tobool8.not.i = icmp eq i8 %13, 0
  br i1 %tobool8.not.i, label %parts128_sqrt.exit, label %d_nan.i

do.body.i12:                                      ; preds = %if.end
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 724, ptr noundef nonnull @__func__.parts128_sqrt, ptr noundef null) #16
  unreachable

if.end16.i:                                       ; preds = %if.end
  %14 = load i8, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %15 = and i8 %14, 1
  %tobool18.not.i = icmp eq i8 %15, 0
  br i1 %tobool18.not.i, label %if.end26.i, label %d_nan.i

if.end26.i:                                       ; preds = %if.end16.i
  %16 = load i32, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %and.i10 = and i32 %16, 1
  %tobool27.not.i = icmp eq i32 %and.i10, 0
  %17 = load i64, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %shr.i.i = lshr i64 %17, 57
  %and.i.i = and i64 %shr.i.i, 63
  %lnot.ext30.i = shl nuw nsw i32 %and.i10, 6
  %shl.i = xor i32 %lnot.ext30.i, 64
  %conv31.i = zext nneg i32 %shl.i to i64
  %or.i = or disjoint i64 %and.i.i, %conv31.i
  %18 = load i64, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br i1 %tobool27.not.i, label %if.then33.i, label %if.end34.i

if.then33.i:                                      ; preds = %if.end26.i
  %19 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %17, i32 1, i64 %18) #15, !srcloc !6
  %shr.i29.i = lshr i64 %17, 1
  br label %if.end34.i

if.end34.i:                                       ; preds = %if.then33.i, %if.end26.i
  %20 = phi i64 [ %19, %if.then33.i ], [ %18, %if.end26.i ]
  %21 = phi i64 [ %shr.i29.i, %if.then33.i ], [ %17, %if.end26.i ]
  %shr.i = lshr i64 %21, 32
  %arrayidx.i = getelementptr [128 x i16], ptr @rsqrt_tab, i64 0, i64 %or.i
  %22 = load i16, ptr %arrayidx.i, align 2
  %conv37.i = zext i16 %22 to i64
  %shl38.i = shl nuw nsw i64 %conv37.i, 16
  %mul.i = mul nuw i64 %shl38.i, %shr.i
  %shr41.i = lshr i64 %mul.i, 32
  %mul45.i = mul nuw i64 %shr41.i, %shl38.i
  %shr46.i = lshr i64 %mul45.i, 32
  %sub.i = sub nsw i64 3221225472, %shr46.i
  %conv49.i = and i64 %sub.i, 4294967295
  %mul50.i = shl nuw nsw i64 %conv37.i, 17
  %mul51.i = mul i64 %mul50.i, %conv49.i
  %conv.i.i.i = zext i64 %21 to i128
  %conv1.i.i.i = zext i64 %mul51.i to i128
  %mul.i.i.i = mul nuw i128 %conv1.i.i.i, %conv.i.i.i
  %shr.i.i.i = lshr i128 %mul.i.i.i, 64
  %mul.i.i32.i = mul nuw i128 %shr.i.i.i, %conv1.i.i.i
  %shr.i.i34.i = lshr i128 %mul.i.i32.i, 64
  %conv3.i.i35.i = trunc i128 %shr.i.i34.i to i64
  %sub52.i = sub i64 -4611686018427387904, %conv3.i.i35.i
  %conv.i.i36.i = zext i64 %sub52.i to i128
  %mul.i.i38.i = mul nuw i128 %conv.i.i36.i, %conv1.i.i.i
  %sh.diff.i = lshr i128 %mul.i.i38.i, 63
  %conv1.i.i43.i = and i128 %sh.diff.i, 18446744073709551614
  %mul.i.i44.i = mul nuw i128 %conv1.i.i43.i, %conv.i.i.i
  %shr.i.i46.i = lshr i128 %mul.i.i44.i, 64
  %mul.i.i50.i = mul nuw i128 %shr.i.i46.i, %conv1.i.i43.i
  %shr.i.i52.i = lshr i128 %mul.i.i50.i, 64
  %conv3.i.i53.i = trunc i128 %shr.i.i52.i to i64
  %sub54.i = sub i64 -4611686018427387904, %conv3.i.i53.i
  %conv.i.i54.i = zext i64 %sub54.i to i128
  %mul.i.i56.i = mul nuw i128 %conv1.i.i43.i, %conv.i.i54.i
  %conv2.i.i57.i = trunc i128 %mul.i.i56.i to i64
  %23 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i57.i, i64 %conv2.i.i57.i)
  %24 = extractvalue { i64, i1 } %23, 1
  %25 = extractvalue { i64, i1 } %23, 0
  %conv.i1.i.i = zext i1 %24 to i64
  %sh.diff40.i = lshr i128 %mul.i.i56.i, 63
  %tr.sh.diff.i = trunc i128 %sh.diff40.i to i64
  %26 = and i64 %tr.sh.diff.i, -2
  %27 = or disjoint i64 %26, %conv.i1.i.i
  %conv.i.i.i.i = zext i64 %20 to i128
  %conv1.i.i.i.i = zext i64 %27 to i128
  %mul.i.i.i.i = mul nuw i128 %conv1.i.i.i.i, %conv.i.i.i.i
  %conv2.i.i.i.i = trunc i128 %mul.i.i.i.i to i64
  %shr.i.i.i.i = lshr i128 %mul.i.i.i.i, 64
  %conv3.i.i.i.i = trunc i128 %shr.i.i.i.i to i64
  %conv1.i.i6.i.i = zext i64 %25 to i128
  %mul.i.i7.i.i = mul nuw i128 %conv1.i.i6.i.i, %conv.i.i.i
  %conv2.i.i8.i.i = trunc i128 %mul.i.i7.i.i to i64
  %shr.i.i9.i.i = lshr i128 %mul.i.i7.i.i, 64
  %conv3.i.i10.i.i = trunc i128 %shr.i.i9.i.i to i64
  %mul.i.i13.i.i = mul nuw i128 %conv1.i.i6.i.i, %conv.i.i.i.i
  %shr.i.i15.i.i = lshr i128 %mul.i.i13.i.i, 64
  %conv3.i.i16.i.i = trunc i128 %shr.i.i15.i.i to i64
  %mul.i.i19.i.i = mul nuw i128 %conv1.i.i.i.i, %conv.i.i.i
  %conv2.i.i20.i.i = trunc i128 %mul.i.i19.i.i to i64
  %shr.i.i21.i.i = lshr i128 %mul.i.i19.i.i, 64
  %conv3.i.i22.i.i = trunc i128 %shr.i.i21.i.i to i64
  %28 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i.i.i, i64 %conv2.i.i8.i.i)
  %29 = extractvalue { i64, i1 } %28, 1
  %30 = extractvalue { i64, i1 } %28, 0
  %conv.i1.i.i.i = zext i1 %29 to i64
  %31 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv3.i.i.i.i, i64 %conv3.i.i10.i.i)
  %32 = extractvalue { i64, i1 } %31, 1
  %33 = extractvalue { i64, i1 } %31, 0
  %34 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %33, i64 %conv.i1.i.i.i)
  %35 = extractvalue { i64, i1 } %34, 1
  %36 = extractvalue { i64, i1 } %34, 0
  %37 = or i1 %32, %35
  %conv.i3.i.i.i = zext i1 %37 to i64
  %38 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %30, i64 %conv3.i.i16.i.i)
  %39 = extractvalue { i64, i1 } %38, 1
  %conv.i1.i23.i.i = zext i1 %39 to i64
  %40 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %36, i64 %conv2.i.i20.i.i)
  %41 = extractvalue { i64, i1 } %40, 1
  %42 = extractvalue { i64, i1 } %40, 0
  %43 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %42, i64 %conv.i1.i23.i.i)
  %44 = extractvalue { i64, i1 } %43, 1
  %45 = extractvalue { i64, i1 } %43, 0
  %46 = or i1 %41, %44
  %conv.i3.i24.i.i = zext i1 %46 to i64
  %47 = add nuw i64 %conv.i3.i.i.i, %conv3.i.i22.i.i
  %48 = add i64 %47, %conv.i3.i24.i.i
  %conv.i.i.i60.i = zext i64 %45 to i128
  %mul.i.i.i62.i = mul nuw i128 %conv.i.i.i60.i, %conv1.i.i.i.i
  %conv2.i.i.i63.i = trunc i128 %mul.i.i.i62.i to i64
  %shr.i.i.i64.i = lshr i128 %mul.i.i.i62.i, 64
  %conv3.i.i.i65.i = trunc i128 %shr.i.i.i64.i to i64
  %conv.i.i5.i66.i = zext i64 %48 to i128
  %mul.i.i7.i68.i = mul nuw i128 %conv.i.i5.i66.i, %conv1.i.i6.i.i
  %conv2.i.i8.i69.i = trunc i128 %mul.i.i7.i68.i to i64
  %shr.i.i9.i70.i = lshr i128 %mul.i.i7.i68.i, 64
  %conv3.i.i10.i71.i = trunc i128 %shr.i.i9.i70.i to i64
  %mul.i.i13.i72.i = mul nuw i128 %conv.i.i.i60.i, %conv1.i.i6.i.i
  %shr.i.i15.i74.i = lshr i128 %mul.i.i13.i72.i, 64
  %conv3.i.i16.i75.i = trunc i128 %shr.i.i15.i74.i to i64
  %mul.i.i19.i76.i = mul nuw i128 %conv.i.i5.i66.i, %conv1.i.i.i.i
  %conv2.i.i20.i77.i = trunc i128 %mul.i.i19.i76.i to i64
  %shr.i.i21.i78.i = lshr i128 %mul.i.i19.i76.i, 64
  %conv3.i.i22.i79.i = trunc i128 %shr.i.i21.i78.i to i64
  %49 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i.i63.i, i64 %conv2.i.i8.i69.i)
  %50 = extractvalue { i64, i1 } %49, 1
  %51 = extractvalue { i64, i1 } %49, 0
  %conv.i1.i.i80.i = zext i1 %50 to i64
  %52 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv3.i.i.i65.i, i64 %conv3.i.i10.i71.i)
  %53 = extractvalue { i64, i1 } %52, 1
  %54 = extractvalue { i64, i1 } %52, 0
  %55 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %54, i64 %conv.i1.i.i80.i)
  %56 = extractvalue { i64, i1 } %55, 1
  %57 = extractvalue { i64, i1 } %55, 0
  %58 = or i1 %53, %56
  %conv.i3.i.i81.neg44.i = sext i1 %58 to i64
  %59 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %51, i64 %conv3.i.i16.i75.i)
  %60 = extractvalue { i64, i1 } %59, 1
  %conv.i1.i23.i82.i = zext i1 %60 to i64
  %61 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %57, i64 %conv2.i.i20.i77.i)
  %62 = extractvalue { i64, i1 } %61, 1
  %63 = extractvalue { i64, i1 } %61, 0
  %64 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %63, i64 %conv.i1.i23.i82.i)
  %65 = extractvalue { i64, i1 } %64, 1
  %66 = extractvalue { i64, i1 } %64, 0
  %67 = or i1 %62, %65
  %conv.i3.i24.i83.neg45.i = sext i1 %67 to i64
  %68 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 0, i64 %66)
  %69 = extractvalue { i64, i1 } %68, 1
  %70 = extractvalue { i64, i1 } %68, 0
  %conv.i1.neg.i.i = sext i1 %69 to i64
  %reass.sub = sub i64 %conv.i3.i.i81.neg44.i, %conv3.i.i22.i79.i
  %.neg43.i = add i64 %reass.sub, -4611686018427387904
  %reass.sub.i = add i64 %.neg43.i, %conv.i3.i24.i83.neg45.i
  %71 = add i64 %reass.sub.i, %conv.i1.neg.i.i
  %conv.i.i.i84.i = zext i64 %70 to i128
  %mul.i.i.i86.i = mul nuw i128 %conv.i.i.i84.i, %conv.i.i5.i66.i
  %conv2.i.i.i87.i = trunc i128 %mul.i.i.i86.i to i64
  %shr.i.i.i88.i = lshr i128 %mul.i.i.i86.i, 64
  %conv3.i.i.i89.i = trunc i128 %shr.i.i.i88.i to i64
  %conv.i.i5.i90.i = zext i64 %71 to i128
  %mul.i.i7.i92.i = mul nuw i128 %conv.i.i5.i90.i, %conv.i.i.i60.i
  %conv2.i.i8.i93.i = trunc i128 %mul.i.i7.i92.i to i64
  %shr.i.i9.i94.i = lshr i128 %mul.i.i7.i92.i, 64
  %conv3.i.i10.i95.i = trunc i128 %shr.i.i9.i94.i to i64
  %mul.i.i13.i96.i = mul nuw i128 %conv.i.i.i84.i, %conv.i.i.i60.i
  %shr.i.i15.i98.i = lshr i128 %mul.i.i13.i96.i, 64
  %conv3.i.i16.i99.i = trunc i128 %shr.i.i15.i98.i to i64
  %mul.i.i19.i100.i = mul nuw i128 %conv.i.i5.i90.i, %conv.i.i5.i66.i
  %conv2.i.i20.i101.i = trunc i128 %mul.i.i19.i100.i to i64
  %shr.i.i21.i102.i = lshr i128 %mul.i.i19.i100.i, 64
  %conv3.i.i22.i103.i = trunc i128 %shr.i.i21.i102.i to i64
  %72 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i.i87.i, i64 %conv2.i.i8.i93.i)
  %73 = extractvalue { i64, i1 } %72, 1
  %74 = extractvalue { i64, i1 } %72, 0
  %conv.i1.i.i104.i = zext i1 %73 to i64
  %75 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv3.i.i.i89.i, i64 %conv3.i.i10.i95.i)
  %76 = extractvalue { i64, i1 } %75, 1
  %77 = extractvalue { i64, i1 } %75, 0
  %78 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %77, i64 %conv.i1.i.i104.i)
  %79 = extractvalue { i64, i1 } %78, 1
  %80 = extractvalue { i64, i1 } %78, 0
  %81 = or i1 %76, %79
  %conv.i3.i.i105.i = zext i1 %81 to i64
  %82 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %74, i64 %conv3.i.i16.i99.i)
  %83 = extractvalue { i64, i1 } %82, 1
  %conv.i1.i23.i106.i = zext i1 %83 to i64
  %84 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %80, i64 %conv2.i.i20.i101.i)
  %85 = extractvalue { i64, i1 } %84, 1
  %86 = extractvalue { i64, i1 } %84, 0
  %87 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %86, i64 %conv.i1.i23.i106.i)
  %88 = extractvalue { i64, i1 } %87, 1
  %89 = extractvalue { i64, i1 } %87, 0
  %90 = or i1 %85, %88
  %conv.i3.i24.i107.i = zext i1 %90 to i64
  %91 = add nuw i64 %conv.i3.i.i105.i, %conv3.i.i22.i103.i
  %92 = add i64 %91, %conv.i3.i24.i107.i
  %93 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %89, i64 4)
  %94 = extractvalue { i64, i1 } %93, 1
  %95 = extractvalue { i64, i1 } %93, 0
  %conv.i1.neg.i108.i = sext i1 %94 to i64
  %96 = add i64 %92, %conv.i1.neg.i108.i
  %shr8.i.i = lshr i64 %96, 13
  %or.i.i = tail call i64 @llvm.fshl.i64(i64 %96, i64 %95, i64 51)
  %conv.i.i110.i = zext i64 %or.i.i to i128
  %mul.i.i112.i = mul nuw i128 %conv.i.i110.i, %conv.i.i110.i
  %conv2.i.i113.i = trunc i128 %mul.i.i112.i to i64
  %shr.i.i114.i = lshr i128 %mul.i.i112.i, 64
  %conv3.i.i115.i = trunc i128 %shr.i.i114.i to i64
  %mul56.i = shl nuw nsw i64 %shr8.i.i, 1
  %mul57.i = mul i64 %mul56.i, %or.i.i
  %97 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 0, i64 %conv2.i.i113.i)
  %98 = extractvalue { i64, i1 } %97, 1
  %99 = extractvalue { i64, i1 } %97, 0
  %conv.i1.neg.i116.neg.i = zext i1 %98 to i64
  %100 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %or.i.i, i64 %99)
  %101 = extractvalue { i64, i1 } %100, 1
  %102 = extractvalue { i64, i1 } %100, 0
  %conv.i1.neg.i117.i = sext i1 %101 to i64
  %103 = shl i64 %20, 34
  %add.i = sub i64 %shr8.i.i, %103
  %.neg.i = add i64 %add.i, %mul57.i
  %.neg41.i = add i64 %.neg.i, %conv3.i.i115.i
  %104 = add i64 %.neg41.i, %conv.i1.neg.i116.neg.i
  %105 = add i64 %104, %conv.i1.neg.i117.i
  %106 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %or.i.i, i64 1)
  %107 = extractvalue { i64, i1 } %106, 1
  %108 = extractvalue { i64, i1 } %106, 0
  %conv.i1.i118.i = zext i1 %107 to i64
  %109 = add nuw nsw i64 %shr8.i.i, %conv.i1.i118.i
  %110 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %108, i64 %102)
  %111 = extractvalue { i64, i1 } %110, 1
  %112 = extractvalue { i64, i1 } %110, 0
  %conv.i1.i119.i = zext i1 %111 to i64
  %113 = add i64 %109, %105
  %114 = add i64 %113, %conv.i1.i119.i
  %shr60.i = lshr i64 %105, 63
  %115 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %or.i.i, i64 %shr60.i)
  %116 = extractvalue { i64, i1 } %115, 1
  %117 = extractvalue { i64, i1 } %115, 0
  %conv.i1.i120.i = zext i1 %116 to i64
  %118 = add nuw nsw i64 %shr8.i.i, %conv.i1.i120.i
  %shl.i121.i = shl i64 %117, 14
  %or.i122.i = tail call i64 @llvm.fshl.i64(i64 %118, i64 %117, i64 14)
  %or61.i = or i64 %114, %112
  %tobool62.not.i = icmp eq i64 %or61.i, 0
  br i1 %tobool62.not.i, label %if.end68.i, label %if.then63.i

if.then63.i:                                      ; preds = %if.end34.i
  %xor.i = xor i64 %114, %105
  %cmp64.i = icmp slt i64 %xor.i, 0
  br i1 %cmp64.i, label %if.then66.i, label %if.else.i11

if.then66.i:                                      ; preds = %if.then63.i
  %119 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %shl.i121.i, i64 1)
  %120 = extractvalue { i64, i1 } %119, 1
  %121 = extractvalue { i64, i1 } %119, 0
  %conv.i1.neg.i123.i = sext i1 %120 to i64
  %122 = add i64 %or.i122.i, %conv.i1.neg.i123.i
  br label %if.end68.i

if.else.i11:                                      ; preds = %if.then63.i
  %123 = or disjoint i64 %shl.i121.i, 1
  br label %if.end68.i

if.end68.i:                                       ; preds = %if.else.i11, %if.then66.i, %if.end34.i
  %sl.0.i = phi i64 [ %shl.i121.i, %if.end34.i ], [ %121, %if.then66.i ], [ %123, %if.else.i11 ]
  %sh.0.i = phi i64 [ %or.i122.i, %if.end34.i ], [ %122, %if.then66.i ], [ %or.i122.i, %if.else.i11 ]
  store i64 %sl.0.i, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  store i64 %sh.0.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %shr72.i = ashr i32 %16, 1
  store i32 %shr72.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %tobool75.not.i = icmp sgt i64 %sh.0.i, -1
  br i1 %tobool75.not.i, label %if.then76.i, label %if.else78.i

if.then76.i:                                      ; preds = %if.end68.i
  %124 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %sl.0.i, i64 %sl.0.i)
  %125 = extractvalue { i64, i1 } %124, 1
  %126 = extractvalue { i64, i1 } %124, 0
  store i64 %126, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %conv.i4.i.i = zext i1 %125 to i64
  %127 = shl nuw i64 %sh.0.i, 1
  %128 = or disjoint i64 %127, %conv.i4.i.i
  store i64 %128, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts128_sqrt.exit

if.else78.i:                                      ; preds = %if.end68.i
  %add80.i = add nsw i32 %shr72.i, 1
  store i32 %add80.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  br label %parts128_sqrt.exit

d_nan.i:                                          ; preds = %if.end16.i, %sw.bb7.i
  %129 = load i16, ptr %s, align 2
  %or1.i.i6 = or i16 %129, 2049
  store i16 %or1.i.i6, ptr %s, align 2
  store i8 4, ptr %p, align 8
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  br label %parts128_sqrt.exit

parts128_sqrt.exit:                               ; preds = %if.end, %if.then.i.i, %if.else.i.i, %sw.bb1.i.i, %if.then4.i.i, %sw.bb7.i, %if.then76.i, %if.else78.i, %d_nan.i
  %call2 = call fastcc { i64, i16 } @floatx80_round_pack_canonical(ptr noundef nonnull %p, ptr noundef nonnull %s)
  %130 = extractvalue { i64, i16 } %call2, 0
  %131 = extractvalue { i64, i16 } %call2, 1
  br label %return

return:                                           ; preds = %parts128_sqrt.exit, %if.then
  %retval.sroa.0.0 = phi i64 [ %130, %parts128_sqrt.exit ], [ -4611686018427387904, %if.then ]
  %retval.sroa.3.0 = phi i16 [ %131, %parts128_sqrt.exit ], [ -1, %if.then ]
  %.fca.0.insert = insertvalue { i64, i16 } poison, i64 %retval.sroa.0.0, 0
  %.fca.1.insert = insertvalue { i64, i16 } %.fca.0.insert, i16 %retval.sroa.3.0, 1
  ret { i64, i16 } %.fca.1.insert
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_log2(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %and.i9.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i10.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %if.then33.i.i [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %float32_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float32_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float32_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float32_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %float32_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br label %float32_unpack_canonical.exit

float32_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  call fastcc void @parts64_log2(ptr noundef nonnull %p, ptr noundef %status, i32 23)
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float32_params)
  %5 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i = zext i8 %5 to i64
  %shl.i.i.i3 = shl nuw nsw i64 %conv.i.i.i, 31
  %6 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %7 = shl i32 %6, 23
  %8 = and i32 %7, 2139095040
  %and8.i.i.i = zext nneg i32 %8 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i3, %and8.i.i.i
  %9 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %9, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  ret i32 %conv.i.i
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @parts64_log2(ptr nocapture noundef %a, ptr nocapture noundef %s, i32 %fmt.16.val) unnamed_addr #3 {
entry:
  %0 = load i8, ptr %a, align 8
  switch i8 %0, label %do.body [
    i8 2, label %if.end18
    i8 3, label %sw.bb8
    i8 1, label %sw.bb6
    i8 5, label %sw.bb.i
    i8 4, label %sw.bb1.i
  ]

sw.bb.i:                                          ; preds = %entry
  %1 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %1, 8193
  store i16 %or1.i.i, ptr %s, align 2
  %default_nan_mode.i = getelementptr inbounds i8, ptr %s, i64 7
  %2 = load i8, ptr %default_nan_mode.i, align 1
  %3 = and i8 %2, 1
  %tobool.not.i = icmp eq i8 %3, 0
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %sw.bb.i
  store i8 4, ptr %a, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  br label %return

if.else.i:                                        ; preds = %sw.bb.i
  %4 = getelementptr inbounds i8, ptr %a, i64 8
  %5 = load i64, ptr %4, align 8
  %or4.i.i.i = or i64 %5, 4611686018427387904
  store i64 %or4.i.i.i, ptr %4, align 8
  store i8 4, ptr %a, align 8
  br label %return

sw.bb1.i:                                         ; preds = %entry
  %default_nan_mode2.i = getelementptr inbounds i8, ptr %s, i64 7
  %6 = load i8, ptr %default_nan_mode2.i, align 1
  %7 = and i8 %6, 1
  %tobool3.not.i = icmp eq i8 %7, 0
  br i1 %tobool3.not.i, label %return, label %if.then4.i

if.then4.i:                                       ; preds = %sw.bb1.i
  store i8 4, ptr %a, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i9.i = getelementptr inbounds i8, ptr %a, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i9.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i10.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i10.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i11.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i11.i, align 8
  br label %return

sw.bb6:                                           ; preds = %entry
  %8 = load i16, ptr %s, align 2
  %or1.i = or i16 %8, 2
  store i16 %or1.i, ptr %s, align 2
  store i8 3, ptr %a, align 8
  %sign = getelementptr inbounds i8, ptr %a, i64 1
  store i8 1, ptr %sign, align 1
  br label %return

sw.bb8:                                           ; preds = %entry
  %sign9 = getelementptr inbounds i8, ptr %a, i64 1
  %9 = load i8, ptr %sign9, align 1
  %10 = and i8 %9, 1
  %tobool10.not = icmp eq i8 %10, 0
  br i1 %tobool10.not, label %return, label %d_nan

do.body:                                          ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1531, ptr noundef nonnull @__func__.parts64_log2, ptr noundef null) #16
  unreachable

if.end18:                                         ; preds = %entry
  %sign19 = getelementptr inbounds i8, ptr %a, i64 1
  %11 = load i8, ptr %sign19, align 1
  %12 = and i8 %11, 1
  %tobool20.not = icmp eq i8 %12, 0
  br i1 %tobool20.not, label %do.end30, label %d_nan

do.end30:                                         ; preds = %if.end18
  %exp = getelementptr inbounds i8, ptr %a, i64 4
  %13 = load i32, ptr %exp, align 4
  %14 = getelementptr inbounds i8, ptr %a, i64 8
  %15 = load i64, ptr %14, align 8
  %add = add i32 %fmt.16.val, 2
  %cmp31 = icmp eq i32 %13, -1
  br i1 %cmp31, label %if.then39, label %if.end44

if.then39:                                        ; preds = %do.end30
  %mul = shl i32 %fmt.16.val, 1
  %add41 = add i32 %mul, 2
  %cond = tail call i32 @llvm.smin.i32(i32 %add41, i32 62)
  br label %if.end44

if.end44:                                         ; preds = %if.then39, %do.end30
  %n.0 = phi i32 [ %cond, %if.then39 ], [ %add, %do.end30 ]
  %cmp4522 = icmp sgt i32 %n.0, 0
  br i1 %cmp4522, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %if.end44
  %cmp63 = icmp eq i32 %13, 0
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %if.end77
  %r.028 = phi i64 [ 0, %for.body.lr.ph ], [ %r.1, %if.end77 ]
  %t.027 = phi i64 [ -9223372036854775808, %for.body.lr.ph ], [ %shr78, %if.end77 ]
  %i.026 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %if.end77 ]
  %f_exp.025 = phi i32 [ -1, %for.body.lr.ph ], [ %f_exp.1, %if.end77 ]
  %a0.024 = phi i64 [ %15, %for.body.lr.ph ], [ %a0.2, %if.end77 ]
  %a1.023 = phi i64 [ 0, %for.body.lr.ph ], [ %a1.2, %if.end77 ]
  %tobool47.not = icmp eq i64 %a1.023, 0
  br i1 %tobool47.not, label %if.else, label %if.then48

if.then48:                                        ; preds = %for.body
  %conv.i.i.i = zext i64 %a1.023 to i128
  %conv1.i.i.i = zext i64 %a0.024 to i128
  %mul.i.i.i = mul nuw i128 %conv1.i.i.i, %conv.i.i.i
  %conv2.i.i.i = trunc i128 %mul.i.i.i to i64
  %shr.i.i.i = lshr i128 %mul.i.i.i, 64
  %conv3.i.i.i = trunc i128 %shr.i.i.i to i64
  %mul.i.i13.i = mul nuw i128 %conv.i.i.i, %conv.i.i.i
  %shr.i.i15.i = lshr i128 %mul.i.i13.i, 64
  %conv3.i.i16.i = trunc i128 %shr.i.i15.i to i64
  %mul.i.i19.i = mul nuw i128 %conv1.i.i.i, %conv1.i.i.i
  %conv2.i.i20.i = trunc i128 %mul.i.i19.i to i64
  %shr.i.i21.i = lshr i128 %mul.i.i19.i, 64
  %conv3.i.i22.i = trunc i128 %shr.i.i21.i to i64
  %16 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i.i, i64 %conv2.i.i.i)
  %17 = extractvalue { i64, i1 } %16, 1
  %18 = extractvalue { i64, i1 } %16, 0
  %conv.i1.i.i = zext i1 %17 to i64
  %19 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv3.i.i.i, i64 %conv3.i.i.i)
  %20 = extractvalue { i64, i1 } %19, 1
  %21 = extractvalue { i64, i1 } %19, 0
  %22 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %21, i64 %conv.i1.i.i)
  %23 = extractvalue { i64, i1 } %22, 1
  %24 = extractvalue { i64, i1 } %22, 0
  %25 = or i1 %20, %23
  %conv.i3.i.i = zext i1 %25 to i64
  %26 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %18, i64 %conv3.i.i16.i)
  %27 = extractvalue { i64, i1 } %26, 1
  %conv.i1.i23.i = zext i1 %27 to i64
  %28 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %24, i64 %conv2.i.i20.i)
  %29 = extractvalue { i64, i1 } %28, 1
  %30 = extractvalue { i64, i1 } %28, 0
  %31 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %30, i64 %conv.i1.i23.i)
  %32 = extractvalue { i64, i1 } %31, 1
  %33 = extractvalue { i64, i1 } %31, 0
  %34 = or i1 %29, %32
  %conv.i3.i24.i = zext i1 %34 to i64
  %35 = add nuw i64 %conv.i3.i.i, %conv3.i.i22.i
  %36 = add i64 %35, %conv.i3.i24.i
  br label %if.end59

if.else:                                          ; preds = %for.body
  %and = and i64 %a0.024, 4294967295
  %tobool49.not = icmp eq i64 %and, 0
  br i1 %tobool49.not, label %if.else51, label %if.then50

if.then50:                                        ; preds = %if.else
  %conv.i.i = zext i64 %a0.024 to i128
  %mul.i.i = mul nuw i128 %conv.i.i, %conv.i.i
  %conv2.i.i = trunc i128 %mul.i.i to i64
  %shr.i.i = lshr i128 %mul.i.i, 64
  %conv3.i.i = trunc i128 %shr.i.i to i64
  br label %if.end59

if.else51:                                        ; preds = %if.else
  %and52 = and i64 %a0.024, 9223372032559808512
  %tobool53.not = icmp eq i64 %and52, 0
  br i1 %tobool53.not, label %exact, label %if.then54

if.then54:                                        ; preds = %if.else51
  %shr = lshr exact i64 %a0.024, 32
  %mul55 = mul nuw i64 %shr, %shr
  br label %if.end59

if.end59:                                         ; preds = %if.then50, %if.then54, %if.then48
  %a1.1 = phi i64 [ 0, %if.then54 ], [ %conv2.i.i, %if.then50 ], [ %33, %if.then48 ]
  %a0.1 = phi i64 [ %mul55, %if.then54 ], [ %conv3.i.i, %if.then50 ], [ %36, %if.then48 ]
  %tobool61.not = icmp sgt i64 %a0.1, -1
  br i1 %tobool61.not, label %if.else76, label %if.then62

if.then62:                                        ; preds = %if.end59
  %cmp65 = icmp eq i64 %r.028, 0
  %37 = select i1 %cmp63, i1 %cmp65, i1 false
  br i1 %37, label %if.then73, label %if.else74

if.then73:                                        ; preds = %if.then62
  %sub = sub i32 %f_exp.025, %i.026
  br label %if.end77

if.else74:                                        ; preds = %if.then62
  %or = or i64 %r.028, %t.027
  br label %if.end77

if.else76:                                        ; preds = %if.end59
  %38 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %a1.1, i64 %a1.1)
  %39 = extractvalue { i64, i1 } %38, 1
  %40 = extractvalue { i64, i1 } %38, 0
  %conv.i1.i = zext i1 %39 to i64
  %41 = shl nuw i64 %a0.1, 1
  %42 = or disjoint i64 %41, %conv.i1.i
  br label %if.end77

if.end77:                                         ; preds = %if.then73, %if.else74, %if.else76
  %a1.2 = phi i64 [ %40, %if.else76 ], [ %a1.1, %if.then73 ], [ %a1.1, %if.else74 ]
  %a0.2 = phi i64 [ %42, %if.else76 ], [ %a0.1, %if.then73 ], [ %a0.1, %if.else74 ]
  %f_exp.1 = phi i32 [ %f_exp.025, %if.else76 ], [ %sub, %if.then73 ], [ %f_exp.025, %if.else74 ]
  %i.1 = phi i32 [ %i.026, %if.else76 ], [ 0, %if.then73 ], [ %i.026, %if.else74 ]
  %t.1 = phi i64 [ %t.027, %if.else76 ], [ -9223372036854775808, %if.then73 ], [ %t.027, %if.else74 ]
  %r.1 = phi i64 [ %r.028, %if.else76 ], [ -9223372036854775808, %if.then73 ], [ %or, %if.else74 ]
  %shr78 = lshr i64 %t.1, 1
  %inc = add nsw i32 %i.1, 1
  %cmp45 = icmp slt i32 %inc, %n.0
  br i1 %cmp45, label %for.body, label %for.end, !llvm.loop !15

for.end:                                          ; preds = %if.end77, %if.end44
  %a1.0.lcssa = phi i64 [ 0, %if.end44 ], [ %a1.2, %if.end77 ]
  %a0.0.lcssa = phi i64 [ %15, %if.end44 ], [ %a0.2, %if.end77 ]
  %f_exp.0.lcssa = phi i32 [ -1, %if.end44 ], [ %f_exp.1, %if.end77 ]
  %r.0.lcssa = phi i64 [ 0, %if.end44 ], [ %r.1, %if.end77 ]
  %tobool79 = icmp ne i64 %a1.0.lcssa, 0
  %and80 = and i64 %a0.0.lcssa, 9223372036854775807
  %tobool81 = icmp ne i64 %and80, 0
  %43 = select i1 %tobool79, i1 true, i1 %tobool81
  %conv82 = zext i1 %43 to i64
  %or83 = or i64 %r.0.lcssa, %conv82
  br label %exact

exact:                                            ; preds = %if.else51, %for.end
  %f_exp.019 = phi i32 [ %f_exp.0.lcssa, %for.end ], [ %f_exp.025, %if.else51 ]
  %r.2 = phi i64 [ %or83, %for.end ], [ %r.028, %if.else51 ]
  %conv84 = sext i32 %13 to i64
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %a, i8 0, i64 16, i1 false)
  %cmp.i = icmp eq i32 %13, 0
  br i1 %cmp.i, label %if.then.i35, label %if.end.i

if.then.i35:                                      ; preds = %exact
  store i8 1, ptr %a, align 8
  br label %parts64_sint_to_float.exit

if.end.i:                                         ; preds = %exact
  store i8 2, ptr %a, align 8
  %cmp2.i = icmp slt i32 %13, 0
  br i1 %cmp2.i, label %if.then3.i, label %if.end4.i

if.then3.i:                                       ; preds = %if.end.i
  %sub.i = sub nsw i64 0, %conv84
  store i8 1, ptr %sign19, align 1
  br label %if.end4.i

if.end4.i:                                        ; preds = %if.then3.i, %if.end.i
  %44 = phi i8 [ 0, %if.then3.i ], [ 1, %if.end.i ]
  %f.0.i = phi i64 [ %sub.i, %if.then3.i ], [ %conv84, %if.end.i ]
  %45 = tail call i64 @llvm.ctlz.i64(i64 %f.0.i, i1 false), !range !5
  %cast.i.i = trunc i64 %45 to i32
  %add.i = sub nsw i32 63, %cast.i.i
  store i32 %add.i, ptr %exp, align 4
  %shl.i = shl i64 %f.0.i, %45
  store i64 %shl.i, ptr %14, align 8
  br label %parts64_sint_to_float.exit

parts64_sint_to_float.exit:                       ; preds = %if.then.i35, %if.end4.i
  %frombool.i = phi i8 [ 1, %if.then.i35 ], [ %44, %if.end4.i ]
  %a.val.i = phi i64 [ 0, %if.then.i35 ], [ %shl.i, %if.end4.i ]
  %46 = phi i32 [ 0, %if.then.i35 ], [ %add.i, %if.end4.i ]
  %cmp85 = icmp eq i64 %r.2, 0
  br i1 %cmp85, label %return, label %frac64_normalize.exit

frac64_normalize.exit:                            ; preds = %parts64_sint_to_float.exit
  %47 = tail call i64 @llvm.ctlz.i64(i64 %r.2, i1 true), !range !5
  %cast.i.i38 = trunc i64 %47 to i32
  %shl.i39 = shl i64 %r.2, %47
  %sub90 = sub i32 %f_exp.019, %cast.i.i38
  %cmp92 = icmp slt i32 %13, 0
  br i1 %cmp92, label %if.then94, label %if.else96

if.then94:                                        ; preds = %frac64_normalize.exit
  %sub.i41 = sub i32 %46, %sub90
  %cmp.i42 = icmp sgt i32 %sub.i41, 0
  br i1 %cmp.i42, label %if.then.i.i, label %if.else.i43

if.then.i.i:                                      ; preds = %if.then94
  %cmp2.i.i = icmp ult i32 %sub.i41, 64
  br i1 %cmp2.i.i, label %if.then10.i.i, label %if.else.i.i

if.then10.i.i:                                    ; preds = %if.then.i.i
  %sh_prom.i.i = zext nneg i32 %sub.i41 to i64
  %shr.i.i46 = lshr i64 %shl.i39, %sh_prom.i.i
  %48 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %shl.i39, i32 %sub.i41, i64 0) #15, !srcloc !6
  %cmp11.i.i = icmp ne i64 %48, 0
  %conv13.i.i = zext i1 %cmp11.i.i to i64
  %or.i.i = or i64 %shr.i.i46, %conv13.i.i
  br label %frac64_shrjam.exit.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %cmp14.i.i = icmp ne i64 %shl.i39, 0
  %conv16.i.i = zext i1 %cmp14.i.i to i64
  br label %frac64_shrjam.exit.i

frac64_shrjam.exit.i:                             ; preds = %if.else.i.i, %if.then10.i.i
  %a0.0.i.i = phi i64 [ %or.i.i, %if.then10.i.i ], [ %conv16.i.i, %if.else.i.i ]
  %49 = sub i64 %a.val.i, %a0.0.i.i
  store i64 %49, ptr %14, align 8
  br label %if.end19.i

if.else.i43:                                      ; preds = %if.then94
  %cmp2.i44 = icmp slt i32 %sub.i41, 0
  br i1 %cmp2.i44, label %if.then.i29.i, label %if.else9.i

if.then.i29.i:                                    ; preds = %if.else.i43
  store i32 %sub90, ptr %exp, align 4
  store i8 %frombool.i, ptr %sign19, align 1
  %sub7.i = sub i32 0, %sub.i41
  %cmp2.i30.i = icmp slt i32 %sub7.i, 64
  br i1 %cmp2.i30.i, label %if.then10.i36.i, label %if.else.i31.i

if.then10.i36.i:                                  ; preds = %if.then.i29.i
  %sh_prom.i37.i = zext nneg i32 %sub7.i to i64
  %shr.i38.i = lshr i64 %a.val.i, %sh_prom.i37.i
  %50 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.val.i, i32 %sub7.i, i64 0) #15, !srcloc !6
  %cmp11.i39.i = icmp ne i64 %50, 0
  %conv13.i40.i = zext i1 %cmp11.i39.i to i64
  %or.i41.i = or i64 %shr.i38.i, %conv13.i40.i
  br label %frac64_shrjam.exit42.i

if.else.i31.i:                                    ; preds = %if.then.i29.i
  %cmp14.i32.i = icmp ne i64 %a.val.i, 0
  %conv16.i33.i = zext i1 %cmp14.i32.i to i64
  br label %frac64_shrjam.exit42.i

frac64_shrjam.exit42.i:                           ; preds = %if.else.i31.i, %if.then10.i36.i
  %a0.0.i35.i = phi i64 [ %or.i41.i, %if.then10.i36.i ], [ %conv16.i33.i, %if.else.i31.i ]
  %51 = sub i64 %shl.i39, %a0.0.i35.i
  store i64 %51, ptr %14, align 8
  br label %if.end19.i

if.else9.i:                                       ; preds = %if.else.i43
  %52 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a.val.i, i64 %shl.i39)
  %53 = extractvalue { i64, i1 } %52, 1
  %54 = extractvalue { i64, i1 } %52, 0
  store i64 %54, ptr %14, align 8
  br i1 %53, label %if.then11.i, label %if.end19.i

if.then11.i:                                      ; preds = %if.else9.i
  %sub.i.i = sub i64 0, %54
  store i64 %sub.i.i, ptr %14, align 8
  store i8 %frombool.i, ptr %sign19, align 1
  br label %if.end19.i

if.end19.i:                                       ; preds = %if.then11.i, %if.else9.i, %frac64_shrjam.exit42.i, %frac64_shrjam.exit.i
  %55 = phi i32 [ %sub90, %frac64_shrjam.exit42.i ], [ %46, %if.then11.i ], [ %46, %if.else9.i ], [ %46, %frac64_shrjam.exit.i ]
  %56 = phi i64 [ %51, %frac64_shrjam.exit42.i ], [ %sub.i.i, %if.then11.i ], [ %54, %if.else9.i ], [ %49, %frac64_shrjam.exit.i ]
  %tobool.not.i.i.not = icmp eq i64 %56, 0
  br i1 %tobool.not.i.i.not, label %if.end29.i, label %if.then26.i

if.then26.i:                                      ; preds = %if.end19.i
  %57 = tail call i64 @llvm.ctlz.i64(i64 %56, i1 true), !range !5
  %cast.i.i.i = trunc i64 %57 to i32
  %shl.i.i = shl i64 %56, %57
  store i64 %shl.i.i, ptr %14, align 8
  %sub28.i = sub i32 %55, %cast.i.i.i
  store i32 %sub28.i, ptr %exp, align 4
  br label %return

if.end29.i:                                       ; preds = %if.end19.i
  store i8 1, ptr %a, align 8
  br label %return

if.else96:                                        ; preds = %frac64_normalize.exit
  br i1 %cmp.i, label %if.else100, label %if.then99

if.then99:                                        ; preds = %if.else96
  %sub.i49 = sub i32 %46, %sub90
  %cmp.i50 = icmp sgt i32 %sub.i49, 0
  br i1 %cmp.i50, label %if.then.i.i55, label %if.else.i51

if.then.i.i55:                                    ; preds = %if.then99
  %cmp2.i.i56 = icmp ult i32 %sub.i49, 64
  br i1 %cmp2.i.i56, label %if.then10.i.i62, label %if.else.i.i57

if.then10.i.i62:                                  ; preds = %if.then.i.i55
  %sh_prom.i.i63 = zext nneg i32 %sub.i49 to i64
  %shr.i.i64 = lshr i64 %shl.i39, %sh_prom.i.i63
  %58 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %shl.i39, i32 %sub.i49, i64 0) #15, !srcloc !6
  %cmp11.i.i65 = icmp ne i64 %58, 0
  %conv13.i.i66 = zext i1 %cmp11.i.i65 to i64
  %or.i.i67 = or i64 %shr.i.i64, %conv13.i.i66
  br label %if.end7.i

if.else.i.i57:                                    ; preds = %if.then.i.i55
  %cmp14.i.i58 = icmp ne i64 %shl.i39, 0
  %conv16.i.i59 = zext i1 %cmp14.i.i58 to i64
  br label %if.end7.i

if.else.i51:                                      ; preds = %if.then99
  %cmp2.i52 = icmp slt i32 %sub.i49, 0
  br i1 %cmp2.i52, label %if.then.i15.i, label %if.end7.i

if.then.i15.i:                                    ; preds = %if.else.i51
  %sub4.i = sub i32 0, %sub.i49
  %cmp2.i16.i = icmp slt i32 %sub4.i, 64
  br i1 %cmp2.i16.i, label %if.then10.i22.i, label %if.else.i17.i

if.then10.i22.i:                                  ; preds = %if.then.i15.i
  %sh_prom.i23.i = zext nneg i32 %sub4.i to i64
  %shr.i24.i = lshr i64 %a.val.i, %sh_prom.i23.i
  %59 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.val.i, i32 %sub4.i, i64 0) #15, !srcloc !6
  %cmp11.i25.i = icmp ne i64 %59, 0
  %conv13.i26.i = zext i1 %cmp11.i25.i to i64
  %or.i27.i = or i64 %shr.i24.i, %conv13.i26.i
  br label %frac64_shrjam.exit28.i

if.else.i17.i:                                    ; preds = %if.then.i15.i
  %cmp14.i18.i = icmp ne i64 %a.val.i, 0
  %conv16.i19.i = zext i1 %cmp14.i18.i to i64
  br label %frac64_shrjam.exit28.i

frac64_shrjam.exit28.i:                           ; preds = %if.else.i17.i, %if.then10.i22.i
  %a0.0.i21.i = phi i64 [ %or.i27.i, %if.then10.i22.i ], [ %conv16.i19.i, %if.else.i17.i ]
  store i32 %sub90, ptr %exp, align 4
  br label %if.end7.i

if.end7.i:                                        ; preds = %if.then10.i.i62, %if.else.i.i57, %frac64_shrjam.exit28.i, %if.else.i51
  %60 = phi i32 [ %sub90, %frac64_shrjam.exit28.i ], [ %46, %if.else.i51 ], [ %46, %if.then10.i.i62 ], [ %46, %if.else.i.i57 ]
  %a.val.i53 = phi i64 [ %a0.0.i21.i, %frac64_shrjam.exit28.i ], [ %a.val.i, %if.else.i51 ], [ %a.val.i, %if.then10.i.i62 ], [ %a.val.i, %if.else.i.i57 ]
  %f.sroa.7.1 = phi i64 [ %shl.i39, %frac64_shrjam.exit28.i ], [ %shl.i39, %if.else.i51 ], [ %or.i.i67, %if.then10.i.i62 ], [ %conv16.i.i59, %if.else.i.i57 ]
  %61 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %a.val.i53, i64 %f.sroa.7.1)
  %62 = extractvalue { i64, i1 } %61, 1
  %63 = extractvalue { i64, i1 } %61, 0
  store i64 %63, ptr %14, align 8
  br i1 %62, label %if.then8.i, label %return

if.then8.i:                                       ; preds = %if.end7.i
  %shr.i31.i = lshr i64 %63, 1
  %64 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %63, i32 1, i64 0) #15, !srcloc !6
  %cmp11.i32.i = icmp ne i64 %64, 0
  %conv13.i33.i = zext i1 %cmp11.i32.i to i64
  %or.i34.i = or i64 %shr.i31.i, %conv13.i33.i
  %or.i = or disjoint i64 %or.i34.i, -9223372036854775808
  store i64 %or.i, ptr %14, align 8
  %add.i54 = add i32 %60, 1
  store i32 %add.i54, ptr %exp, align 4
  br label %return

if.else100:                                       ; preds = %if.else96
  store i8 2, ptr %a, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %sign19, i8 0, i64 3, i1 false)
  store i32 %sub90, ptr %exp, align 4
  store i64 %shl.i39, ptr %14, align 8
  br label %return

d_nan:                                            ; preds = %if.end18, %sw.bb8
  %65 = load i16, ptr %s, align 2
  %or1.i68 = or i16 %65, 1
  store i16 %or1.i68, ptr %s, align 2
  store i8 4, ptr %a, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i, align 8
  br label %return

return:                                           ; preds = %if.then8.i, %if.end7.i, %if.end29.i, %if.then26.i, %if.then4.i, %sw.bb1.i, %if.else.i, %if.then.i, %if.else100, %parts64_sint_to_float.exit, %sw.bb8, %d_nan, %sw.bb6
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @float64_log2(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i64 %a, 63
  %frombool.i.i.i = trunc i64 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i.i to i32
  %conv.i.i.i = and i32 %0, 2047
  %and.i9.i.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %conv.i.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %and.i9.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  switch i32 %conv.i.i.i, label %if.then33.i.i [
    i32 0, label %if.then.i.i
    i32 2047, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i.i.i, label %if.then8.i.i, label %if.else.i.i

if.then8.i.i:                                     ; preds = %if.then.i.i
  store i8 1, ptr %p, align 8
  br label %float64_unpack_canonical.exit

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %frac64_normalize.exit.i.i, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  store i8 1, ptr %p, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

frac64_normalize.exit.i.i:                        ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i9.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %p, align 8
  %add.i.i = sub nuw nsw i32 -1011, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %float64_unpack_canonical.exit

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i64 %and.i9.i.i, 0
  br i1 %cmp.i29.i.i, label %if.then47.i.i, label %if.else49.i.i

if.then33.i.i:                                    ; preds = %entry
  store i8 2, ptr %p, align 8
  %sub37.i.i = add nsw i32 %conv.i.i.i, -1023
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %float64_unpack_canonical.exit

if.then47.i.i:                                    ; preds = %lor.lhs.false.i.i
  store i8 3, ptr %p, align 8
  br label %float64_unpack_canonical.exit

if.else49.i.i:                                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i9.i.i, 11
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i64 %and.i9.i.i, 2251799813685248
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %p, align 8
  br label %float64_unpack_canonical.exit

float64_unpack_canonical.exit:                    ; preds = %if.then8.i.i, %if.then10.i.i, %frac64_normalize.exit.i.i, %if.then33.i.i, %if.then47.i.i, %if.else49.i.i
  call fastcc void @parts64_log2(ptr noundef nonnull %p, ptr noundef %status, i32 52)
  call fastcc void @parts64_uncanon(ptr noundef nonnull %p, ptr noundef %status, ptr noundef nonnull @float64_params)
  %5 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %6 = and i8 %5, 1
  %conv.i.i.i3 = zext nneg i8 %6 to i64
  %shl.i.i.i4 = shl nuw i64 %conv.i.i.i3, 63
  %7 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %8 = and i32 %7, 2047
  %shl77.i.i.i = zext nneg i32 %8 to i64
  %and8.i.i.i = shl nuw nsw i64 %shl77.i.i.i, 52
  %or.i.i.i = or disjoint i64 %and8.i.i.i, %shl.i.i.i4
  %9 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %9, 4503599627370495
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  ret i64 %or.i10.i.i
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i16 @float16_default_nan(ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  ret i16 32256
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local i32 @float32_default_nan(ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  ret i32 2143289344
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local i64 @float64_default_nan(ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  ret i64 9221120237041090560
}

; Function Attrs: nofree nosync nounwind sspstrong memory(none) uwtable
define dso_local { i64, i64 } @float128_default_nan(ptr nocapture noundef readnone %status) local_unnamed_addr #7 {
entry:
  %0 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 4611686018427387904, i32 15, i64 0) #15, !srcloc !6
  %.fca.0.insert.i = insertvalue { i64, i64 } poison, i64 %0, 0
  %.fca.1.insert.i = insertvalue { i64, i64 } %.fca.0.insert.i, i64 9223231299366420480, 1
  ret { i64, i64 } %.fca.1.insert.i
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i16 @bfloat16_default_nan(ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  ret i16 32704
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i16 @float16_silence_nan(i16 noundef zeroext %a, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %or.i10.i6 = or i16 %a, 512
  ret i16 %or.i10.i6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local i32 @float32_silence_nan(i32 noundef %a, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %or.i10.i5 = or i32 %a, 4194304
  ret i32 %or.i10.i5
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local i64 @float64_silence_nan(i64 noundef %a, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %or.i10.i = or i64 %a, 2251799813685248
  ret i64 %or.i10.i
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable
define dso_local zeroext i16 @bfloat16_silence_nan(i16 noundef zeroext %a, ptr nocapture noundef readnone %status) local_unnamed_addr #0 {
entry:
  %or.i10.i6 = or i16 %a, 64
  ret i16 %or.i10.i6
}

; Function Attrs: nofree nosync nounwind sspstrong memory(none) uwtable
define dso_local { i64, i64 } @float128_silence_nan(i64 %a.coerce0, i64 %a.coerce1, ptr nocapture noundef readnone %status) local_unnamed_addr #7 {
entry:
  %and.i.i = and i64 %a.coerce1, 281474976710655
  %0 = tail call i64 asm "shld ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.coerce0, i32 15, i64 %and.i.i) #15, !srcloc !16
  %shl.i = shl i64 %a.coerce0, 15
  %or4.i.i = or i64 %0, 4611686018427387904
  %1 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %or4.i.i, i32 15, i64 %shl.i) #15, !srcloc !6
  %shr.i = lshr i64 %or4.i.i, 15
  %or.i25.i = and i64 %a.coerce1, -281474976710656
  %and8.i.i = and i64 %shr.i, 281474976710655
  %or.i.i = or disjoint i64 %and8.i.i, %or.i25.i
  %.fca.0.insert.i = insertvalue { i64, i64 } poison, i64 %1, 0
  %.fca.1.insert.i = insertvalue { i64, i64 } %.fca.0.insert.i, i64 %or.i.i, 1
  ret { i64, i64 } %.fca.1.insert.i
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: readwrite) uwtable
define dso_local zeroext i16 @float16_squash_input_denormal(i16 noundef zeroext %a, ptr nocapture noundef %status) local_unnamed_addr #2 {
entry:
  %flush_inputs_to_zero = getelementptr inbounds i8, ptr %status, i64 6
  %0 = load i8, ptr %flush_inputs_to_zero, align 2
  %1 = and i8 %0, 1
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %return, label %if.then

if.then:                                          ; preds = %entry
  %2 = and i16 %a, 1023
  %3 = and i16 %a, 31744
  %cmp.i = icmp eq i16 %3, 0
  %cmp1.i = icmp ne i16 %2, 0
  %or.cond.i = and i1 %cmp.i, %cmp1.i
  br i1 %or.cond.i, label %if.then1, label %return

if.then1:                                         ; preds = %if.then
  %f.lobit.i = and i16 %a, -32768
  %4 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %4, 32
  store i16 %or1.i.i, ptr %status, align 2
  br label %return

return:                                           ; preds = %if.then, %entry, %if.then1
  %retval.0 = phi i16 [ %f.lobit.i, %if.then1 ], [ %a, %entry ], [ %a, %if.then ]
  ret i16 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: readwrite) uwtable
define dso_local i32 @float32_squash_input_denormal(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #2 {
entry:
  %flush_inputs_to_zero = getelementptr inbounds i8, ptr %status, i64 6
  %0 = load i8, ptr %flush_inputs_to_zero, align 2
  %1 = and i8 %0, 1
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %return, label %if.then

if.then:                                          ; preds = %entry
  %2 = and i32 %a, 8388607
  %3 = and i32 %a, 2139095040
  %cmp.i = icmp eq i32 %3, 0
  %cmp1.i = icmp ne i32 %2, 0
  %or.cond.i = and i1 %cmp.i, %cmp1.i
  br i1 %or.cond.i, label %if.then1, label %return

if.then1:                                         ; preds = %if.then
  %f.lobit.i = and i32 %a, -2147483648
  %4 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %4, 32
  store i16 %or1.i.i, ptr %status, align 2
  br label %return

return:                                           ; preds = %if.then, %entry, %if.then1
  %retval.0 = phi i32 [ %f.lobit.i, %if.then1 ], [ %a, %entry ], [ %a, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: readwrite) uwtable
define dso_local i64 @float64_squash_input_denormal(i64 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #2 {
entry:
  %flush_inputs_to_zero = getelementptr inbounds i8, ptr %status, i64 6
  %0 = load i8, ptr %flush_inputs_to_zero, align 2
  %1 = and i8 %0, 1
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %return, label %if.then

if.then:                                          ; preds = %entry
  %and.i9.i = and i64 %a, 4503599627370495
  %2 = and i64 %a, 9218868437227405312
  %cmp.i = icmp eq i64 %2, 0
  %cmp1.i = icmp ne i64 %and.i9.i, 0
  %or.cond.i = and i1 %cmp.i, %cmp1.i
  br i1 %or.cond.i, label %if.then1, label %return

if.then1:                                         ; preds = %if.then
  %f.lobit.i = and i64 %a, -9223372036854775808
  %3 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %3, 32
  store i16 %or1.i.i, ptr %status, align 2
  br label %return

return:                                           ; preds = %if.then, %entry, %if.then1
  %retval.0 = phi i64 [ %f.lobit.i, %if.then1 ], [ %a, %entry ], [ %a, %if.then ]
  ret i64 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: readwrite) uwtable
define dso_local zeroext i16 @bfloat16_squash_input_denormal(i16 noundef zeroext %a, ptr nocapture noundef %status) local_unnamed_addr #2 {
entry:
  %flush_inputs_to_zero = getelementptr inbounds i8, ptr %status, i64 6
  %0 = load i8, ptr %flush_inputs_to_zero, align 2
  %1 = and i8 %0, 1
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %return, label %if.then

if.then:                                          ; preds = %entry
  %2 = and i16 %a, 127
  %3 = and i16 %a, 32640
  %cmp.i = icmp eq i16 %3, 0
  %cmp1.i = icmp ne i16 %2, 0
  %or.cond.i = and i1 %cmp.i, %cmp1.i
  br i1 %or.cond.i, label %if.then1, label %return

if.then1:                                         ; preds = %if.then
  %f.lobit.i = and i16 %a, -32768
  %4 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %4, 32
  store i16 %or1.i.i, ptr %status, align 2
  br label %return

return:                                           ; preds = %if.then, %entry, %if.then1
  %retval.0 = phi i16 [ %f.lobit.i, %if.then1 ], [ %a, %entry ], [ %a, %if.then ]
  ret i16 %retval.0
}

; Function Attrs: mustprogress nofree nosync nounwind sspstrong willreturn memory(argmem: write) uwtable
define dso_local void @normalizeFloatx80Subnormal(i64 noundef %aSig, ptr nocapture noundef writeonly %zExpPtr, ptr nocapture noundef writeonly %zSigPtr) local_unnamed_addr #8 {
entry:
  %0 = tail call i64 @llvm.ctlz.i64(i64 %aSig, i1 false), !range !5
  %cast.i = trunc i64 %0 to i32
  %shl = shl i64 %aSig, %0
  store i64 %shl, ptr %zSigPtr, align 8
  %sub = sub nsw i32 1, %cast.i
  store i32 %sub, ptr %zExpPtr, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @roundAndPackFloatx80(i8 noundef zeroext %roundingPrecision, i1 noundef zeroext %zSign, i32 noundef %zExp, i64 noundef %zSig0, i64 noundef %zSig1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %float_rounding_mode = getelementptr inbounds i8, ptr %status, i64 2
  %0 = load i8, ptr %float_rounding_mode, align 2
  %cmp = icmp eq i8 %0, 0
  switch i8 %roundingPrecision, label %do.body [
    i8 0, label %precision80
    i8 1, label %sw.epilog
    i8 2, label %sw.bb5
  ]

sw.bb5:                                           ; preds = %entry
  br label %sw.epilog

do.body:                                          ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 4969, ptr noundef nonnull @__func__.roundAndPackFloatx80, ptr noundef null) #16
  unreachable

sw.epilog:                                        ; preds = %entry, %sw.bb5
  %roundIncrement.0 = phi i64 [ 549755813888, %sw.bb5 ], [ 1024, %entry ]
  %roundMask.0 = phi i64 [ 1099511627775, %sw.bb5 ], [ 2047, %entry ]
  %cmp6 = icmp ne i64 %zSig1, 0
  %conv8 = zext i1 %cmp6 to i64
  %or = or i64 %conv8, %zSig0
  switch i8 %0, label %sw.default21 [
    i8 0, label %sw.epilog22
    i8 4, label %sw.epilog22
    i8 3, label %sw.bb11
    i8 2, label %sw.bb12
    i8 1, label %sw.bb14
  ]

sw.bb11:                                          ; preds = %sw.epilog
  br label %sw.epilog22

sw.bb12:                                          ; preds = %sw.epilog
  %cond = select i1 %zSign, i64 0, i64 %roundMask.0
  br label %sw.epilog22

sw.bb14:                                          ; preds = %sw.epilog
  %cond20 = select i1 %zSign, i64 %roundMask.0, i64 0
  br label %sw.epilog22

sw.default21:                                     ; preds = %sw.epilog
  tail call void @abort() #16
  unreachable

sw.epilog22:                                      ; preds = %sw.epilog, %sw.epilog, %sw.bb14, %sw.bb12, %sw.bb11
  %roundIncrement.1 = phi i64 [ %cond20, %sw.bb14 ], [ %cond, %sw.bb12 ], [ 0, %sw.bb11 ], [ %roundIncrement.0, %sw.epilog ], [ %roundIncrement.0, %sw.epilog ]
  %and = and i64 %roundMask.0, %or
  %1 = add i32 %zExp, -32766
  %cmp23 = icmp ult i32 %1, -32765
  br i1 %cmp23, label %if.then, label %if.end77

if.then:                                          ; preds = %sw.epilog22
  %cmp25 = icmp sgt i32 %zExp, 32766
  br i1 %cmp25, label %overflow, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %cmp27 = icmp eq i32 %zExp, 32766
  %2 = xor i64 %or, -1
  %cmp29 = icmp ugt i64 %roundIncrement.1, %2
  %or.cond87 = and i1 %cmp27, %cmp29
  br i1 %or.cond87, label %overflow, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %cmp32 = icmp slt i32 %zExp, 1
  br i1 %cmp32, label %if.then34, label %if.end77

if.then34:                                        ; preds = %if.end
  %flush_to_zero = getelementptr inbounds i8, ptr %status, i64 5
  %3 = load i8, ptr %flush_to_zero, align 1
  %4 = and i8 %3, 1
  %tobool35.not = icmp eq i8 %4, 0
  br i1 %tobool35.not, label %if.end38, label %if.then36

if.then36:                                        ; preds = %if.then34
  %5 = load i16, ptr %status, align 2
  %or1.i = or i16 %5, 64
  store i16 %or1.i, ptr %status, align 2
  %conv2.i = select i1 %zSign, i16 -32768, i16 0
  br label %return

if.end38:                                         ; preds = %if.then34
  %tininess_before_rounding = getelementptr inbounds i8, ptr %status, i64 4
  %6 = load i8, ptr %tininess_before_rounding, align 2
  %7 = and i8 %6, 1
  %tobool39 = icmp ne i8 %7, 0
  %cmp42 = icmp ne i32 %zExp, 0
  %or.cond = or i1 %cmp42, %tobool39
  %cmp45 = icmp ule i64 %roundIncrement.1, %2
  %spec.select174 = or i1 %cmp45, %or.cond
  %sub48 = sub i32 1, %zExp
  %cmp1.i = icmp slt i32 %sub48, 64
  br i1 %cmp1.i, label %if.then2.i, label %if.else6.i

if.then2.i:                                       ; preds = %if.end38
  %sub48.neg = add nsw i32 %zExp, 63
  %sh_prom.i = zext nneg i32 %sub48 to i64
  %shr.i = lshr i64 %or, %sh_prom.i
  %and.i = and i32 %sub48.neg, 63
  %sh_prom3.i = zext nneg i32 %and.i to i64
  %shl.i100 = shl i64 %or, %sh_prom3.i
  %cmp4.i = icmp ne i64 %shl.i100, 0
  %conv5.i = zext i1 %cmp4.i to i64
  %or.i = or i64 %shr.i, %conv5.i
  br label %shift64RightJamming.exit

if.else6.i:                                       ; preds = %if.end38
  %cmp7.i = icmp ne i64 %or, 0
  %conv9.i = zext i1 %cmp7.i to i64
  br label %shift64RightJamming.exit

shift64RightJamming.exit:                         ; preds = %if.then2.i, %if.else6.i
  %z.0.i = phi i64 [ %or.i, %if.then2.i ], [ %conv9.i, %if.else6.i ]
  %and49 = and i64 %z.0.i, %roundMask.0
  %tobool53 = icmp ne i64 %and49, 0
  %or.cond1 = select i1 %spec.select174, i1 %tobool53, i1 false
  br i1 %or.cond1, label %if.end55.thread, label %if.end55

if.end55.thread:                                  ; preds = %shift64RightJamming.exit
  %8 = load i16, ptr %status, align 2
  %or1.i101 = or i16 %8, 8
  br label %if.then57

if.end55:                                         ; preds = %shift64RightJamming.exit
  br i1 %tobool53, label %if.end55.if.then57_crit_edge, label %if.end58

if.end55.if.then57_crit_edge:                     ; preds = %if.end55
  %.pre = load i16, ptr %status, align 2
  br label %if.then57

if.then57:                                        ; preds = %if.end55.if.then57_crit_edge, %if.end55.thread
  %9 = phi i16 [ %.pre, %if.end55.if.then57_crit_edge ], [ %or1.i101, %if.end55.thread ]
  %or1.i102 = or i16 %9, 16
  store i16 %or1.i102, ptr %status, align 2
  br label %if.end58

if.end58:                                         ; preds = %if.then57, %if.end55
  %add59 = add nuw i64 %z.0.i, %roundIncrement.1
  %add59.lobit = lshr i64 %add59, 63
  %spec.select = trunc i64 %add59.lobit to i16
  %add64 = add nuw nsw i64 %roundMask.0, 1
  %shl = shl nuw nsw i64 %and49, 1
  %cmp68 = icmp eq i64 %shl, %add64
  %or.cond88 = select i1 %cmp, i1 %cmp68, i1 false
  %or71 = select i1 %or.cond88, i64 %add64, i64 0
  %roundMask.1 = or i64 %or71, %roundMask.0
  %not = xor i64 %roundMask.1, -1
  %and73 = and i64 %add59, %not
  %shl.i103 = select i1 %zSign, i16 -32768, i16 0
  %add.i = or disjoint i16 %shl.i103, %spec.select
  %.fca.0.insert.i = insertvalue { i64, i16 } poison, i64 %and73, 0
  br label %return

if.end77:                                         ; preds = %if.end, %sw.epilog22
  %tobool78.not = icmp eq i64 %and, 0
  br i1 %tobool78.not, label %if.end80, label %if.then79

if.then79:                                        ; preds = %if.end77
  %10 = load i16, ptr %status, align 2
  %or1.i106 = or i16 %10, 16
  store i16 %or1.i106, ptr %status, align 2
  br label %if.end80

if.end80:                                         ; preds = %if.then79, %if.end77
  %add81 = add i64 %roundIncrement.1, %or
  %cmp82 = icmp ult i64 %add81, %roundIncrement.1
  %spec.select89 = select i1 %cmp82, i64 -9223372036854775808, i64 %add81
  %inc = zext i1 %cmp82 to i32
  %spec.select90 = add nuw nsw i32 %inc, %zExp
  %add86 = add nuw nsw i64 %roundMask.0, 1
  %shl90 = shl nuw nsw i64 %and, 1
  %cmp91 = icmp eq i64 %shl90, %add86
  %or.cond91 = select i1 %cmp, i1 %cmp91, i1 false
  %or94 = select i1 %or.cond91, i64 %add86, i64 0
  %roundMask.2 = or i64 %or94, %roundMask.0
  %not96 = xor i64 %roundMask.2, -1
  %and97 = and i64 %spec.select89, %not96
  %cmp98 = icmp eq i64 %and97, 0
  %zExp.addr.2 = select i1 %cmp98, i32 0, i32 %spec.select90
  %shl.i107 = select i1 %zSign, i32 32768, i32 0
  %add.i108 = add nuw nsw i32 %zExp.addr.2, %shl.i107
  %conv2.i109 = trunc i32 %add.i108 to i16
  %.fca.0.insert.i110 = insertvalue { i64, i16 } poison, i64 %and97, 0
  br label %return

precision80:                                      ; preds = %entry
  switch i8 %0, label %sw.default121 [
    i8 0, label %sw.bb105
    i8 4, label %sw.bb105
    i8 3, label %sw.epilog122
    i8 2, label %sw.bb110
    i8 1, label %sw.bb114
  ]

sw.bb105:                                         ; preds = %precision80, %precision80
  %.lobit = lshr i64 %zSig1, 63
  %frombool108 = trunc i64 %.lobit to i8
  br label %sw.epilog122

sw.bb110:                                         ; preds = %precision80
  %tobool112 = icmp ne i64 %zSig1, 0
  %not.zSign = xor i1 %zSign, true
  %11 = and i1 %tobool112, %not.zSign
  %frombool113 = zext i1 %11 to i8
  br label %sw.epilog122

sw.bb114:                                         ; preds = %precision80
  %tobool118 = icmp ne i64 %zSig1, 0
  %12 = and i1 %tobool118, %zSign
  %frombool120 = zext i1 %12 to i8
  br label %sw.epilog122

sw.default121:                                    ; preds = %precision80
  tail call void @abort() #16
  unreachable

sw.epilog122:                                     ; preds = %precision80, %sw.bb114, %sw.bb110, %sw.bb105
  %increment.0 = phi i8 [ %frombool120, %sw.bb114 ], [ %frombool113, %sw.bb110 ], [ %frombool108, %sw.bb105 ], [ 0, %precision80 ]
  %13 = add i32 %zExp, -32766
  %cmp124 = icmp ult i32 %13, -32765
  br i1 %cmp124, label %if.then126, label %if.end229

if.then126:                                       ; preds = %sw.epilog122
  %cmp127 = icmp sgt i32 %zExp, 32766
  br i1 %cmp127, label %overflow, label %lor.lhs.false129

lor.lhs.false129:                                 ; preds = %if.then126
  %cmp130 = icmp ne i32 %zExp, 32766
  %cmp133 = icmp ne i64 %zSig0, -1
  %or.cond2.not178 = or i1 %cmp130, %cmp133
  %tobool136.not = icmp eq i8 %increment.0, 0
  %or.cond92 = or i1 %or.cond2.not178, %tobool136.not
  br i1 %or.cond92, label %if.end162, label %overflow

overflow:                                         ; preds = %if.then126, %lor.lhs.false129, %lor.lhs.false, %if.then
  %roundMask.3 = phi i64 [ %roundMask.0, %if.then ], [ %roundMask.0, %lor.lhs.false ], [ 0, %lor.lhs.false129 ], [ 0, %if.then126 ]
  %14 = load i16, ptr %status, align 2
  %or1.i112 = or i16 %14, 20
  store i16 %or1.i112, ptr %status, align 2
  %cmp140 = icmp eq i8 %0, 3
  %cmp147 = icmp eq i8 %0, 2
  %or.cond3 = select i1 %zSign, i1 %cmp147, i1 false
  %or.cond93 = or i1 %cmp140, %or.cond3
  %or.cond93.not = xor i1 %or.cond93, true
  %cmp153 = icmp ne i8 %0, 1
  %or.cond4.not = select i1 %zSign, i1 true, i1 %cmp153
  %or.cond94 = select i1 %or.cond93.not, i1 %or.cond4.not, i1 false
  br i1 %or.cond94, label %if.end159, label %if.then155

if.then155:                                       ; preds = %overflow
  %not157 = xor i64 %roundMask.3, -1
  %conv2.i115 = select i1 %zSign, i16 -2, i16 32766
  %.fca.0.insert.i116 = insertvalue { i64, i16 } poison, i64 %not157, 0
  br label %return

if.end159:                                        ; preds = %overflow
  %conv2.i120 = select i1 %zSign, i16 -1, i16 32767
  br label %return

if.end162:                                        ; preds = %lor.lhs.false129
  %cmp163 = icmp slt i32 %zExp, 1
  br i1 %cmp163, label %if.then165, label %if.end229

if.then165:                                       ; preds = %if.end162
  %tininess_before_rounding166 = getelementptr inbounds i8, ptr %status, i64 4
  %15 = load i8, ptr %tininess_before_rounding166, align 2
  %16 = and i8 %15, 1
  %tobool167 = icmp ne i8 %16, 0
  %cmp170 = icmp ne i32 %zExp, 0
  %or.cond5 = or i1 %cmp170, %tobool167
  %17 = or i1 %cmp133, %or.cond5
  %spec.select175 = or i1 %tobool136.not, %17
  %sub179 = sub i32 1, %zExp
  %cmp2.i = icmp slt i32 %sub179, 64
  br i1 %cmp2.i, label %if.then4.i, label %if.else10.i

if.then4.i:                                       ; preds = %if.then165
  %sub179.neg = add nsw i32 %zExp, 63
  %conv.i = and i32 %sub179.neg, 63
  %sh_prom.i122 = zext nneg i32 %conv.i to i64
  %shl.i123 = shl i64 %zSig0, %sh_prom.i122
  %cmp6.i = icmp ne i64 %zSig1, 0
  %conv8.i = zext i1 %cmp6.i to i64
  %or.i124 = or i64 %shl.i123, %conv8.i
  %sh_prom9.i = zext nneg i32 %sub179 to i64
  %shr.i125 = lshr i64 %zSig0, %sh_prom9.i
  br label %shift64ExtraRightJamming.exit

if.else10.i:                                      ; preds = %if.then165
  %cmp11.i = icmp eq i32 %zExp, -63
  br i1 %cmp11.i, label %if.then13.i, label %if.else18.i

if.then13.i:                                      ; preds = %if.else10.i
  %cmp14.i = icmp ne i64 %zSig1, 0
  %conv16.i = zext i1 %cmp14.i to i64
  %or17.i = or i64 %conv16.i, %zSig0
  br label %shift64ExtraRightJamming.exit

if.else18.i:                                      ; preds = %if.else10.i
  %or19.i = or i64 %zSig1, %zSig0
  %cmp20.i = icmp ne i64 %or19.i, 0
  %conv22.i = zext i1 %cmp20.i to i64
  br label %shift64ExtraRightJamming.exit

shift64ExtraRightJamming.exit:                    ; preds = %if.then4.i, %if.then13.i, %if.else18.i
  %z1.1.i = phi i64 [ %or.i124, %if.then4.i ], [ %or17.i, %if.then13.i ], [ %conv22.i, %if.else18.i ]
  %z0.0.i = phi i64 [ %shr.i125, %if.then4.i ], [ 0, %if.then13.i ], [ 0, %if.else18.i ]
  %tobool183 = icmp ne i64 %z1.1.i, 0
  %or.cond6 = select i1 %spec.select175, i1 %tobool183, i1 false
  br i1 %or.cond6, label %if.end185.thread, label %if.end185

if.end185.thread:                                 ; preds = %shift64ExtraRightJamming.exit
  %18 = load i16, ptr %status, align 2
  %or1.i126 = or i16 %18, 8
  br label %if.then187

if.end185:                                        ; preds = %shift64ExtraRightJamming.exit
  %tobool186.not = icmp eq i64 %z1.1.i, 0
  br i1 %tobool186.not, label %if.end188, label %if.end185.if.then187_crit_edge

if.end185.if.then187_crit_edge:                   ; preds = %if.end185
  %.pre179 = load i16, ptr %status, align 2
  br label %if.then187

if.then187:                                       ; preds = %if.end185.if.then187_crit_edge, %if.end185.thread
  %19 = phi i16 [ %.pre179, %if.end185.if.then187_crit_edge ], [ %or1.i126, %if.end185.thread ]
  %or1.i127 = or i16 %19, 16
  store i16 %or1.i127, ptr %status, align 2
  br label %if.end188

if.end188:                                        ; preds = %if.then187, %if.end185
  switch i8 %0, label %sw.default208 [
    i8 0, label %sw.epilog209
    i8 4, label %sw.epilog209
    i8 3, label %if.end225
    i8 2, label %sw.bb195
    i8 1, label %sw.bb201
  ]

sw.bb195:                                         ; preds = %if.end188
  %not.zSign84 = xor i1 %zSign, true
  %20 = select i1 %not.zSign84, i1 %tobool183, i1 false
  br i1 %20, label %if.then211.thread, label %if.end225

sw.bb201:                                         ; preds = %if.end188
  %21 = select i1 %zSign, i1 %tobool183, i1 false
  br i1 %21, label %if.then211.thread, label %if.end225

sw.default208:                                    ; preds = %if.end188
  tail call void @abort() #16
  unreachable

sw.epilog209:                                     ; preds = %if.end188, %if.end188
  %22 = icmp slt i64 %z1.1.i, 0
  br i1 %22, label %if.then211, label %if.end225

if.then211.thread:                                ; preds = %sw.bb195, %sw.bb201
  %inc212168 = add nuw i64 %z0.0.i, 1
  br label %if.end220

if.then211:                                       ; preds = %sw.epilog209
  %inc212 = add nuw i64 %z0.0.i, 1
  %shl213.mask = and i64 %z1.1.i, 9223372036854775807
  %tobool214.not = icmp eq i64 %shl213.mask, 0
  %brmerge.not = select i1 %tobool214.not, i1 %cmp, i1 false
  %and219 = and i64 %inc212, -2
  %spec.select176 = select i1 %brmerge.not, i64 %and219, i64 %inc212
  br label %if.end220

if.end220:                                        ; preds = %if.then211, %if.then211.thread
  %zSig0.addr.0 = phi i64 [ %inc212168, %if.then211.thread ], [ %spec.select176, %if.then211 ]
  %zSig0.addr.0.lobit = lshr i64 %zSig0.addr.0, 63
  %spec.select96 = trunc i64 %zSig0.addr.0.lobit to i16
  br label %if.end225

if.end225:                                        ; preds = %sw.bb195, %sw.bb201, %if.end220, %if.end188, %sw.epilog209
  %zSig0.addr.1 = phi i64 [ %zSig0.addr.0, %if.end220 ], [ %z0.0.i, %sw.epilog209 ], [ %z0.0.i, %if.end188 ], [ %z0.0.i, %sw.bb201 ], [ %z0.0.i, %sw.bb195 ]
  %zExp.addr.3 = phi i16 [ %spec.select96, %if.end220 ], [ 0, %sw.epilog209 ], [ 0, %if.end188 ], [ 0, %sw.bb201 ], [ 0, %sw.bb195 ]
  %shl.i128 = select i1 %zSign, i16 -32768, i16 0
  %add.i129 = add nuw i16 %zExp.addr.3, %shl.i128
  %.fca.0.insert.i131 = insertvalue { i64, i16 } poison, i64 %zSig0.addr.1, 0
  br label %return

if.end229:                                        ; preds = %if.end162, %sw.epilog122
  %tobool230.not = icmp eq i64 %zSig1, 0
  br i1 %tobool230.not, label %if.end232, label %if.then231

if.then231:                                       ; preds = %if.end229
  %23 = load i16, ptr %status, align 2
  %or1.i133 = or i16 %23, 16
  store i16 %or1.i133, ptr %status, align 2
  br label %if.end232

if.end232:                                        ; preds = %if.then231, %if.end229
  %tobool233.not = icmp eq i8 %increment.0, 0
  br i1 %tobool233.not, label %if.else249, label %if.then234

if.then234:                                       ; preds = %if.end232
  %inc235 = add i64 %zSig0, 1
  %cmp236 = icmp eq i64 %inc235, 0
  br i1 %cmp236, label %if.then238, label %if.else

if.then238:                                       ; preds = %if.then234
  %inc239 = add nuw nsw i32 %zExp, 1
  br label %if.end254

if.else:                                          ; preds = %if.then234
  %shl240.mask = and i64 %zSig1, 9223372036854775807
  %tobool241.not = icmp eq i64 %shl240.mask, 0
  %brmerge98.not = select i1 %tobool241.not, i1 %cmp, i1 false
  %and246 = and i64 %inc235, -2
  %spec.select177 = select i1 %brmerge98.not, i64 %and246, i64 %inc235
  br label %if.end254

if.else249:                                       ; preds = %if.end232
  %cmp250 = icmp eq i64 %zSig0, 0
  %spec.select99 = select i1 %cmp250, i32 0, i32 %zExp
  br label %if.end254

if.end254:                                        ; preds = %if.else, %if.else249, %if.then238
  %zSig0.addr.2 = phi i64 [ %zSig0, %if.else249 ], [ -9223372036854775808, %if.then238 ], [ %spec.select177, %if.else ]
  %zExp.addr.4 = phi i32 [ %spec.select99, %if.else249 ], [ %inc239, %if.then238 ], [ %zExp, %if.else ]
  %shl.i134 = select i1 %zSign, i32 32768, i32 0
  %add.i135 = add nuw nsw i32 %zExp.addr.4, %shl.i134
  %conv2.i136 = trunc i32 %add.i135 to i16
  %.fca.0.insert.i137 = insertvalue { i64, i16 } poison, i64 %zSig0.addr.2, 0
  br label %return

return:                                           ; preds = %if.end254, %if.end225, %if.end159, %if.then155, %if.end80, %if.end58, %if.then36
  %.fca.0.insert.i116.pn = phi { i64, i16 } [ %.fca.0.insert.i116, %if.then155 ], [ { i64 -9223372036854775808, i16 poison }, %if.end159 ], [ { i64 0, i16 poison }, %if.then36 ], [ %.fca.0.insert.i, %if.end58 ], [ %.fca.0.insert.i110, %if.end80 ], [ %.fca.0.insert.i131, %if.end225 ], [ %.fca.0.insert.i137, %if.end254 ]
  %conv2.i115.pn = phi i16 [ %conv2.i115, %if.then155 ], [ %conv2.i120, %if.end159 ], [ %conv2.i, %if.then36 ], [ %add.i, %if.end58 ], [ %conv2.i109, %if.end80 ], [ %add.i129, %if.end225 ], [ %conv2.i136, %if.end254 ]
  %call158.pn = insertvalue { i64, i16 } %.fca.0.insert.i116.pn, i16 %conv2.i115.pn, 1
  ret { i64, i16 } %call158.pn
}

; Function Attrs: noreturn
declare void @g_assertion_message_expr(ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #9

; Function Attrs: noreturn nounwind
declare void @abort() local_unnamed_addr #10

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @normalizeRoundAndPackFloatx80(i8 noundef zeroext %roundingPrecision, i1 noundef zeroext %zSign, i32 noundef %zExp, i64 noundef %zSig0, i64 noundef %zSig1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %cmp = icmp eq i64 %zSig0, 0
  %zSig0.addr.0 = select i1 %cmp, i64 %zSig1, i64 %zSig0
  %zSig1.addr.0 = select i1 %cmp, i64 0, i64 %zSig1
  %0 = tail call i64 @llvm.ctlz.i64(i64 %zSig0.addr.0, i1 false), !range !5
  %cast.i = trunc i64 %0 to i32
  %cmp.i = icmp eq i32 %cast.i, 0
  br i1 %cmp.i, label %shortShift128Left.exit, label %cond.false.i

cond.false.i:                                     ; preds = %entry
  %shl2.i = shl i64 %zSig0.addr.0, %0
  %sub.i = sub nsw i64 0, %0
  %and.i = and i64 %sub.i, 63
  %shr.i = lshr i64 %zSig1.addr.0, %and.i
  %or.i = or i64 %shr.i, %shl2.i
  br label %shortShift128Left.exit

shortShift128Left.exit:                           ; preds = %entry, %cond.false.i
  %cond.i = phi i64 [ %or.i, %cond.false.i ], [ %zSig0.addr.0, %entry ]
  %shl.i = shl i64 %zSig1.addr.0, %0
  %sub = add i32 %zExp, -64
  %zExp.addr.0 = select i1 %cmp, i32 %sub, i32 %zExp
  %sub3 = sub i32 %zExp.addr.0, %cast.i
  %call4 = tail call { i64, i16 } @roundAndPackFloatx80(i8 noundef zeroext %roundingPrecision, i1 noundef zeroext %zSign, i32 noundef %sub3, i64 noundef %cond.i, i64 noundef %shl.i, ptr noundef %status)
  ret { i64, i16 } %call4
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @float32_exp2(i32 noundef %a, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %xp = alloca %struct.FloatParts64, align 8
  %xnp = alloca %struct.FloatParts64, align 8
  %tp = alloca %struct.FloatParts64, align 8
  %rp = alloca %struct.FloatParts64, align 8
  %f.lobit.i.i = lshr i32 %a, 31
  %frombool.i.i.i = trunc i32 %f.lobit.i.i to i8
  %shr.i8.i.i = lshr i32 %a, 23
  %and.i9.i.i = and i32 %shr.i8.i.i, 255
  %0 = and i32 %a, 8388607
  %and.i10.i.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %xp, i64 1
  store i8 %frombool.i.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %xp, i64 4
  store i32 %and.i9.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %xp, i64 8
  %trunc.i = trunc i32 %shr.i8.i.i to i8
  switch i8 %trunc.i, label %float32_unpack_canonical.exit.thread [
    i8 0, label %if.then.i.i
    i8 -1, label %lor.lhs.false.i.i
  ]

if.then.i.i:                                      ; preds = %entry
  %cmp.i.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i.i, label %return, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %flush_inputs_to_zero.i.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i.i, label %float32_unpack_canonical.exit.thread63, label %if.then10.i.i

if.then10.i.i:                                    ; preds = %if.else.i.i
  %3 = load i16, ptr %status, align 2
  %or1.i.i.i = or i16 %3, 32
  store i16 %or1.i.i.i, ptr %status, align 2
  br label %return

float32_unpack_canonical.exit.thread63:           ; preds = %if.else.i.i
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i.i, i1 true), !range !5
  %cast.i.i.i.i = trunc i64 %4 to i32
  %shl.i.i.i = shl i64 %and.i10.i.i, %4
  store i64 %shl.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 2, ptr %xp, align 8
  %add.i.i = sub nuw nsw i32 -86, %cast.i.i.i.i
  store i32 %add.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  br label %if.end

lor.lhs.false.i.i:                                ; preds = %entry
  %cmp.i29.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i.i, label %sw.bb6, label %float32_unpack_canonical.exit

float32_unpack_canonical.exit.thread:             ; preds = %entry
  store i8 2, ptr %xp, align 8
  %sub37.i.i = add nsw i32 %and.i9.i.i, -127
  store i32 %sub37.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %shl.i28.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  %or.i.i = or disjoint i64 %shl.i28.i.i, -9223372036854775808
  store i64 %or.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %if.end

float32_unpack_canonical.exit:                    ; preds = %lor.lhs.false.i.i
  %shl.i31.i.i = shl nuw nsw i64 %and.i10.i.i, 40
  store i64 %shl.i31.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %tobool.not.i32.i.i = icmp ult i32 %0, 4194304
  %conv53.i.i = select i1 %tobool.not.i32.i.i, i8 5, i8 4
  store i8 %conv53.i.i, ptr %xp, align 8
  br i1 %tobool.not.i32.i.i, label %sw.bb.i, label %sw.bb1.i

sw.bb.i:                                          ; preds = %float32_unpack_canonical.exit
  %5 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %5, 8193
  store i16 %or1.i.i, ptr %status, align 2
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %6 = load i8, ptr %default_nan_mode.i, align 1
  %7 = and i8 %6, 1
  %tobool.not.i = icmp eq i8 %7, 0
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %sw.bb.i
  store i8 4, ptr %xp, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_return_nan.exit

if.else.i:                                        ; preds = %sw.bb.i
  %or4.i.i.i = or disjoint i64 %shl.i31.i.i, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  store i8 4, ptr %xp, align 8
  br label %parts64_return_nan.exit

sw.bb1.i:                                         ; preds = %float32_unpack_canonical.exit
  %default_nan_mode2.i = getelementptr inbounds i8, ptr %status, i64 7
  %8 = load i8, ptr %default_nan_mode2.i, align 1
  %9 = and i8 %8, 1
  %tobool3.not.i = icmp eq i8 %9, 0
  br i1 %tobool3.not.i, label %parts64_return_nan.exit, label %if.then4.i

if.then4.i:                                       ; preds = %sw.bb1.i
  store i8 4, ptr %xp, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  br label %parts64_return_nan.exit

parts64_return_nan.exit:                          ; preds = %if.then.i, %if.else.i, %sw.bb1.i, %if.then4.i
  call fastcc void @parts64_uncanon(ptr noundef nonnull %xp, ptr noundef nonnull %status, ptr noundef nonnull @float32_params)
  %10 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i, align 1
  %conv.i.i.i = zext i8 %10 to i64
  %shl.i.i.i14 = shl nuw nsw i64 %conv.i.i.i, 31
  %11 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i, align 4
  %12 = shl i32 %11, 23
  %13 = and i32 %12, 2139095040
  %and8.i.i.i = zext nneg i32 %13 to i64
  %or.i.i.i = or disjoint i64 %shl.i.i.i14, %and8.i.i.i
  %14 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i, align 8
  %shl77.i9.i.i = and i64 %14, 8388607
  %or.i10.i.i = or disjoint i64 %or.i.i.i, %shl77.i9.i.i
  %conv.i.i = trunc i64 %or.i10.i.i to i32
  br label %return

sw.bb6:                                           ; preds = %lor.lhs.false.i.i
  %cond = tail call i32 @llvm.smax.i32(i32 %a, i32 0)
  br label %return

if.end:                                           ; preds = %float32_unpack_canonical.exit.thread, %float32_unpack_canonical.exit.thread63
  %15 = load i16, ptr %status, align 2
  %or1.i = or i16 %15, 16
  store i16 %or1.i, ptr %status, align 2
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i15 = getelementptr inbounds i8, ptr %tp, i64 1
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i15, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i16 = getelementptr inbounds i8, ptr %tp, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i17 = getelementptr inbounds i8, ptr %tp, i64 8
  store i8 2, ptr %tp, align 8
  store i32 -1, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i16, align 4
  store i64 -5660435428506896384, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i17, align 8
  %call10 = call fastcc ptr @parts64_mul(ptr noundef nonnull %xp, ptr noundef nonnull %tp, ptr noundef nonnull %status)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %xp, ptr noundef nonnull align 8 dereferenceable(16) %call10, i64 16, i1 false)
  call void @llvm.memmove.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %xnp, ptr noundef nonnull align 8 dereferenceable(16) %call10, i64 16, i1 false)
  %.compoundliteral.i.sroa.2.0..sroa_idx.i.i19 = getelementptr inbounds i8, ptr %rp, i64 1
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i19, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i.i20 = getelementptr inbounds i8, ptr %rp, i64 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i.i21 = getelementptr inbounds i8, ptr %rp, i64 8
  store i8 2, ptr %rp, align 8
  store i32 0, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i20, align 4
  store i64 -9223372036854775808, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i21, align 8
  %flush_inputs_to_zero.i.i41 = getelementptr inbounds i8, ptr %status, i64 6
  br label %for.body

for.body:                                         ; preds = %if.end, %float64_unpack_canonical.exit
  %indvars.iv = phi i64 [ 0, %if.end ], [ %indvars.iv.next, %float64_unpack_canonical.exit ]
  %arrayidx = getelementptr [15 x i64], ptr @float32_exp2_coefficients, i64 0, i64 %indvars.iv
  %16 = load i64, ptr %arrayidx, align 8
  %f.lobit.i.i23 = lshr i64 %16, 63
  %frombool.i.i.i24 = trunc i64 %f.lobit.i.i23 to i8
  %shr.i8.i.i25 = lshr i64 %16, 52
  %17 = trunc i64 %shr.i8.i.i25 to i32
  %conv.i.i.i26 = and i32 %17, 2047
  %and.i9.i.i27 = and i64 %16, 4503599627370495
  store i8 %frombool.i.i.i24, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i15, align 1
  store i32 %conv.i.i.i26, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i16, align 4
  store i64 %and.i9.i.i27, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i17, align 8
  switch i32 %conv.i.i.i26, label %if.then33.i.i50 [
    i32 0, label %if.then.i.i38
    i32 2047, label %lor.lhs.false.i.i31
  ]

if.then.i.i38:                                    ; preds = %for.body
  %cmp.i.i.i39 = icmp ult i64 %indvars.iv, 2
  br i1 %cmp.i.i.i39, label %if.then8.i.i49, label %if.else.i.i40

if.then8.i.i49:                                   ; preds = %if.then.i.i38
  store i8 1, ptr %tp, align 8
  br label %float64_unpack_canonical.exit

if.else.i.i40:                                    ; preds = %if.then.i.i38
  %18 = load i8, ptr %flush_inputs_to_zero.i.i41, align 2
  %19 = and i8 %18, 1
  %tobool9.not.i.i42 = icmp eq i8 %19, 0
  br i1 %tobool9.not.i.i42, label %frac64_normalize.exit.i.i45, label %if.then10.i.i43

if.then10.i.i43:                                  ; preds = %if.else.i.i40
  %20 = load i16, ptr %status, align 2
  %or1.i.i.i44 = or i16 %20, 32
  store i16 %or1.i.i.i44, ptr %status, align 2
  store i8 1, ptr %tp, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i17, align 8
  br label %float64_unpack_canonical.exit

frac64_normalize.exit.i.i45:                      ; preds = %if.else.i.i40
  %21 = call i64 @llvm.ctlz.i64(i64 %and.i9.i.i27, i1 true), !range !5
  %cast.i.i.i.i46 = trunc i64 %21 to i32
  %shl.i.i.i47 = shl i64 %and.i9.i.i27, %21
  store i64 %shl.i.i.i47, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i17, align 8
  store i8 2, ptr %tp, align 8
  %add.i.i48 = sub nuw nsw i32 -1011, %cast.i.i.i.i46
  store i32 %add.i.i48, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i16, align 4
  br label %float64_unpack_canonical.exit

lor.lhs.false.i.i31:                              ; preds = %for.body
  %cmp.i29.i.i32 = icmp ult i64 %indvars.iv, 2
  br i1 %cmp.i29.i.i32, label %if.then47.i.i37, label %if.else49.i.i33

if.then33.i.i50:                                  ; preds = %for.body
  store i8 2, ptr %tp, align 8
  %sub37.i.i51 = add nsw i32 %conv.i.i.i26, -1023
  store i32 %sub37.i.i51, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i16, align 4
  %shl.i28.i.i52 = shl nuw nsw i64 %and.i9.i.i27, 11
  %or.i.i53 = or disjoint i64 %shl.i28.i.i52, -9223372036854775808
  store i64 %or.i.i53, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i17, align 8
  br label %float64_unpack_canonical.exit

if.then47.i.i37:                                  ; preds = %lor.lhs.false.i.i31
  store i8 3, ptr %tp, align 8
  br label %float64_unpack_canonical.exit

if.else49.i.i33:                                  ; preds = %lor.lhs.false.i.i31
  %shl.i31.i.i34 = shl nuw nsw i64 %and.i9.i.i27, 11
  store i64 %shl.i31.i.i34, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i17, align 8
  %22 = lshr i64 6975, %indvars.iv
  %23 = and i64 %22, 1
  %tobool.not.i32.i.i35.not = icmp eq i64 %23, 0
  %conv53.i.i36 = select i1 %tobool.not.i32.i.i35.not, i8 4, i8 5
  store i8 %conv53.i.i36, ptr %tp, align 8
  br label %float64_unpack_canonical.exit

float64_unpack_canonical.exit:                    ; preds = %if.then8.i.i49, %if.then10.i.i43, %frac64_normalize.exit.i.i45, %if.then33.i.i50, %if.then47.i.i37, %if.else49.i.i33
  %call13 = call fastcc ptr @parts64_muladd(ptr noundef nonnull %tp, ptr noundef nonnull %xnp, ptr noundef nonnull %rp, i32 noundef 0, ptr noundef nonnull %status)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %rp, ptr noundef nonnull align 8 dereferenceable(16) %tp, i64 16, i1 false)
  %call14 = call fastcc ptr @parts64_mul(ptr noundef nonnull %xnp, ptr noundef nonnull %xp, ptr noundef nonnull %status)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %xnp, ptr noundef nonnull align 8 dereferenceable(16) %call14, i64 16, i1 false)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 15
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !17

for.end:                                          ; preds = %float64_unpack_canonical.exit
  call fastcc void @parts64_uncanon(ptr noundef nonnull %rp, ptr noundef nonnull %status, ptr noundef nonnull @float32_params)
  %24 = load i8, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i.i19, align 1
  %conv.i.i.i55 = zext i8 %24 to i64
  %shl.i.i.i56 = shl nuw nsw i64 %conv.i.i.i55, 31
  %25 = load i32, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i.i20, align 4
  %26 = shl i32 %25, 23
  %27 = and i32 %26, 2139095040
  %and8.i.i.i58 = zext nneg i32 %27 to i64
  %or.i.i.i59 = or disjoint i64 %shl.i.i.i56, %and8.i.i.i58
  %28 = load i64, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i.i21, align 8
  %shl77.i9.i.i60 = and i64 %28, 8388607
  %or.i10.i.i61 = or disjoint i64 %or.i.i.i59, %shl77.i9.i.i60
  %conv.i.i62 = trunc i64 %or.i10.i.i61 to i32
  br label %return

return:                                           ; preds = %if.then.i.i, %if.then10.i.i, %for.end, %sw.bb6, %parts64_return_nan.exit
  %retval.0 = phi i32 [ %cond, %sw.bb6 ], [ %conv.i.i, %parts64_return_nan.exit ], [ %conv.i.i62, %for.end ], [ 1065353216, %if.then10.i.i ], [ 1065353216, %if.then.i.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local { i64, i16 } @floatx80_round(i64 %a.coerce0, i16 %a.coerce1, ptr nocapture noundef %status) local_unnamed_addr #3 {
entry:
  %p = alloca %struct.FloatParts128, align 8
  %floatx80_rounding_precision.i = getelementptr inbounds i8, ptr %status, i64 3
  %0 = load i8, ptr %floatx80_rounding_precision.i, align 1
  %switch.i = icmp ult i8 %0, 3
  br i1 %switch.i, label %sw.epilog.i, label %do.body.i

do.body.i:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.2, i32 noundef 1789, ptr noundef nonnull @__func__.floatx80_unpack_canonical, ptr noundef null) #16
  unreachable

sw.epilog.i:                                      ; preds = %entry
  %cmp.i.i = icmp slt i64 %a.coerce0, 0
  %1 = and i16 %a.coerce1, 32767
  %cmp2.i.i = icmp eq i16 %1, 0
  %.not.i = select i1 %cmp.i.i, i1 true, i1 %cmp2.i.i
  br i1 %.not.i, label %if.end.i, label %if.then

if.end.i:                                         ; preds = %sw.epilog.i
  %f.coerce1.lobit.i.i = lshr i16 %a.coerce1, 15
  %frombool.i.i = trunc i16 %f.coerce1.lobit.i.i to i8
  %and.i.i.i = zext nneg i16 %1 to i32
  store i8 0, ptr %p, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.32.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %and.i.i.i, ptr %.compoundliteral.sroa.32.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 8
  store i64 %a.coerce0, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %.compoundliteral.sroa.5.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %p, i64 16
  store i64 0, ptr %.compoundliteral.sroa.5.0..sroa_idx.i.i, align 8
  %cmp.not.i = icmp eq i16 %1, 32767
  br i1 %cmp.not.i, label %if.else.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.end.i
  call fastcc void @parts128_canonicalize(ptr noundef nonnull %p, ptr noundef nonnull %status, ptr noundef nonnull @floatx80_params)
  br label %if.end

if.else.i:                                        ; preds = %if.end.i
  %and.i = and i64 %a.coerce0, 9223372036854775807
  store i64 %and.i, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  %cmp12.i = icmp eq i64 %and.i, 0
  %2 = and i64 %a.coerce0, 4611686018427387904
  %tobool.not.i.i = icmp eq i64 %2, 0
  %3 = select i1 %tobool.not.i.i, i8 5, i8 4
  %cond17.i = select i1 %cmp12.i, i8 3, i8 %3
  store i8 %cond17.i, ptr %p, align 8
  br label %if.end

if.then:                                          ; preds = %sw.epilog.i
  %4 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %4, 1
  store i16 %or1.i.i, ptr %status, align 2
  br label %return

if.end:                                           ; preds = %if.then10.i, %if.else.i
  %call2 = call fastcc { i64, i16 } @floatx80_round_pack_canonical(ptr noundef nonnull %p, ptr noundef nonnull %status)
  %5 = extractvalue { i64, i16 } %call2, 0
  %6 = extractvalue { i64, i16 } %call2, 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.sroa.0.0 = phi i64 [ %5, %if.end ], [ -4611686018427387904, %if.then ]
  %retval.sroa.3.0 = phi i16 [ %6, %if.end ], [ -1, %if.then ]
  %.fca.0.insert = insertvalue { i64, i16 } poison, i64 %retval.sroa.0.0, 0
  %.fca.1.insert = insertvalue { i64, i16 } %.fca.0.insert, i16 %retval.sroa.3.0, 1
  ret { i64, i16 } %.fca.1.insert
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i64, i1 } @llvm.usub.with.overflow.i64(i64, i64) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i64, i1 } @llvm.uadd.with.overflow.i64(i64, i64) #4

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i32 @soft_f32_addsub(i32 noundef %a, i32 noundef %b, ptr nocapture noundef %status, i1 noundef zeroext %subtract) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts64, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %f.lobit.i = lshr i32 %a, 31
  %frombool.i.i = trunc i32 %f.lobit.i to i8
  %shr.i8.i = lshr i32 %a, 23
  %and.i9.i = and i32 %shr.i8.i, 255
  %0 = and i32 %a, 8388607
  %and.i10.i = zext nneg i32 %0 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %and.i9.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i10.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %trunc = trunc i32 %shr.i8.i to i8
  switch i8 %trunc, label %if.then33.i [
    i8 0, label %if.then.i47
    i8 -1, label %lor.lhs.false.i
  ]

if.then.i47:                                      ; preds = %entry
  %cmp.i.i = icmp eq i32 %0, 0
  br i1 %cmp.i.i, label %if.then8.i, label %if.else.i48

if.then8.i:                                       ; preds = %if.then.i47
  store i8 1, ptr %pa, align 8
  br label %parts64_canonicalize.exit

if.else.i48:                                      ; preds = %if.then.i47
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i, label %frac64_normalize.exit.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.else.i48
  %3 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %3, 32
  store i16 %or1.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_canonicalize.exit

frac64_normalize.exit.i:                          ; preds = %if.else.i48
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i, i1 true), !range !5
  %cast.i.i.i = trunc i64 %4 to i32
  %shl.i.i = shl i64 %and.i10.i, %4
  store i64 %shl.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i = sub nuw nsw i32 -86, %cast.i.i.i
  store i32 %add.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_canonicalize.exit

lor.lhs.false.i:                                  ; preds = %entry
  %cmp.i29.i = icmp eq i32 %0, 0
  br i1 %cmp.i29.i, label %if.then47.i, label %if.else49.i

if.then33.i:                                      ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i = add nsw i32 %and.i9.i, -127
  store i32 %sub37.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %shl.i28.i = shl nuw nsw i64 %and.i10.i, 40
  %or.i46 = or disjoint i64 %shl.i28.i, -9223372036854775808
  store i64 %or.i46, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_canonicalize.exit

if.then47.i:                                      ; preds = %lor.lhs.false.i
  store i8 3, ptr %pa, align 8
  br label %parts64_canonicalize.exit

if.else49.i:                                      ; preds = %lor.lhs.false.i
  %shl.i31.i = shl nuw nsw i64 %and.i10.i, 40
  store i64 %shl.i31.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %tobool.not.i32.i = icmp ult i32 %0, 4194304
  %conv53.i = select i1 %tobool.not.i32.i, i8 5, i8 4
  store i8 %conv53.i, ptr %pa, align 8
  br label %parts64_canonicalize.exit

parts64_canonicalize.exit:                        ; preds = %if.then8.i, %if.then10.i, %frac64_normalize.exit.i, %if.then33.i, %if.then47.i, %if.else49.i
  %a.val.i120 = phi i64 [ 0, %if.then8.i ], [ 0, %if.then10.i ], [ %shl.i.i, %frac64_normalize.exit.i ], [ %or.i46, %if.then33.i ], [ 0, %if.then47.i ], [ %shl.i31.i, %if.else49.i ]
  %5 = phi i32 [ %and.i9.i, %if.then8.i ], [ %and.i9.i, %if.then10.i ], [ %add.i, %frac64_normalize.exit.i ], [ %sub37.i, %if.then33.i ], [ %and.i9.i, %if.then47.i ], [ %and.i9.i, %if.else49.i ]
  %6 = phi i8 [ 1, %if.then8.i ], [ 1, %if.then10.i ], [ 2, %frac64_normalize.exit.i ], [ 2, %if.then33.i ], [ 3, %if.then47.i ], [ %conv53.i, %if.else49.i ]
  %f.lobit.i49 = lshr i32 %b, 31
  %frombool.i.i50 = trunc i32 %f.lobit.i49 to i8
  %shr.i8.i51 = lshr i32 %b, 23
  %and.i9.i52 = and i32 %shr.i8.i51, 255
  %7 = and i32 %b, 8388607
  %and.i10.i53 = zext nneg i32 %7 to i64
  %.compoundliteral.i.sroa.2.0..sroa_idx.i54 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i50, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i54, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i55 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %and.i9.i52, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i55, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i56 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i10.i53, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  %trunc129 = trunc i32 %shr.i8.i51 to i8
  switch i8 %trunc129, label %if.then33.i69 [
    i8 0, label %if.then.i73
    i8 -1, label %lor.lhs.false.i61
  ]

if.then.i73:                                      ; preds = %parts64_canonicalize.exit
  %cmp.i.i75 = icmp eq i32 %7, 0
  br i1 %cmp.i.i75, label %if.then8.i86, label %if.else.i76

if.then8.i86:                                     ; preds = %if.then.i73
  store i8 1, ptr %pb, align 8
  br label %parts64_canonicalize.exit87

if.else.i76:                                      ; preds = %if.then.i73
  %flush_inputs_to_zero.i77 = getelementptr inbounds i8, ptr %status, i64 6
  %8 = load i8, ptr %flush_inputs_to_zero.i77, align 2
  %9 = and i8 %8, 1
  %tobool9.not.i78 = icmp eq i8 %9, 0
  br i1 %tobool9.not.i78, label %frac64_normalize.exit.i81, label %if.then10.i79

if.then10.i79:                                    ; preds = %if.else.i76
  %10 = load i16, ptr %status, align 2
  %or1.i.i80 = or i16 %10, 32
  store i16 %or1.i.i80, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  br label %parts64_canonicalize.exit87

frac64_normalize.exit.i81:                        ; preds = %if.else.i76
  %11 = tail call i64 @llvm.ctlz.i64(i64 %and.i10.i53, i1 true), !range !5
  %cast.i.i.i82 = trunc i64 %11 to i32
  %shl.i.i83 = shl i64 %and.i10.i53, %11
  store i64 %shl.i.i83, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  store i8 2, ptr %pb, align 8
  %add.i85 = sub nuw nsw i32 -86, %cast.i.i.i82
  store i32 %add.i85, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i55, align 4
  br label %parts64_canonicalize.exit87

lor.lhs.false.i61:                                ; preds = %parts64_canonicalize.exit
  %cmp.i29.i63 = icmp eq i32 %7, 0
  br i1 %cmp.i29.i63, label %if.then47.i68, label %if.else49.i64

if.then33.i69:                                    ; preds = %parts64_canonicalize.exit
  store i8 2, ptr %pb, align 8
  %sub37.i70 = add nsw i32 %and.i9.i52, -127
  store i32 %sub37.i70, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i55, align 4
  %shl.i28.i71 = shl nuw nsw i64 %and.i10.i53, 40
  %or.i72 = or disjoint i64 %shl.i28.i71, -9223372036854775808
  store i64 %or.i72, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  br label %parts64_canonicalize.exit87

if.then47.i68:                                    ; preds = %lor.lhs.false.i61
  store i8 3, ptr %pb, align 8
  br label %parts64_canonicalize.exit87

if.else49.i64:                                    ; preds = %lor.lhs.false.i61
  %shl.i31.i65 = shl nuw nsw i64 %and.i10.i53, 40
  store i64 %shl.i31.i65, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  %tobool.not.i32.i66 = icmp ult i32 %7, 4194304
  %conv53.i67 = select i1 %tobool.not.i32.i66, i8 5, i8 4
  store i8 %conv53.i67, ptr %pb, align 8
  br label %parts64_canonicalize.exit87

parts64_canonicalize.exit87:                      ; preds = %if.then8.i86, %if.then10.i79, %frac64_normalize.exit.i81, %if.then33.i69, %if.then47.i68, %if.else49.i64
  %b.val.i121 = phi i64 [ 0, %if.then8.i86 ], [ 0, %if.then10.i79 ], [ %shl.i.i83, %frac64_normalize.exit.i81 ], [ %or.i72, %if.then33.i69 ], [ 0, %if.then47.i68 ], [ %shl.i31.i65, %if.else49.i64 ]
  %12 = phi i32 [ %and.i9.i52, %if.then8.i86 ], [ %and.i9.i52, %if.then10.i79 ], [ %add.i85, %frac64_normalize.exit.i81 ], [ %sub37.i70, %if.then33.i69 ], [ %and.i9.i52, %if.then47.i68 ], [ %and.i9.i52, %if.else49.i64 ]
  %.pr.i.pre = phi i8 [ 1, %if.then8.i86 ], [ 1, %if.then10.i79 ], [ 2, %frac64_normalize.exit.i81 ], [ 2, %if.then33.i69 ], [ 3, %if.then47.i68 ], [ %conv53.i67, %if.else49.i64 ]
  %13 = icmp slt i32 %b, 0
  %tobool3.i = xor i1 %13, %subtract
  %frombool4.i = zext i1 %tobool3.i to i8
  %conv5.i = zext nneg i8 %6 to i32
  %shl.i = shl nuw nsw i32 1, %conv5.i
  %conv7.i = zext nneg i8 %.pr.i.pre to i32
  %shl8.i = shl nuw nsw i32 1, %conv7.i
  %or.i = or i32 %shl8.i, %shl.i
  %14 = icmp sgt i32 %a, -1
  %cmp.i.not = xor i1 %14, %tobool3.i
  %trunc136 = trunc i32 %or.i to i8
  br i1 %cmp.i.not, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %parts64_canonicalize.exit87
  switch i8 %trunc136, label %if.end31.i [
    i8 4, label %if.then20.i
    i8 2, label %if.then25.i
  ]

if.then20.i:                                      ; preds = %if.then.i
  %sub.i = sub nsw i32 %5, %12
  %cmp.i89 = icmp sgt i32 %sub.i, 0
  br i1 %cmp.i89, label %if.then.i.i, label %if.else.i90

if.then.i.i:                                      ; preds = %if.then20.i
  %cmp2.i.i = icmp ult i32 %sub.i, 64
  br i1 %cmp2.i.i, label %if.then10.i.i, label %if.else.i.i

if.then10.i.i:                                    ; preds = %if.then.i.i
  %sh_prom.i.i = zext nneg i32 %sub.i to i64
  %shr.i.i = lshr i64 %b.val.i121, %sh_prom.i.i
  %15 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %b.val.i121, i32 %sub.i, i64 0) #15, !srcloc !6
  %cmp11.i.i = icmp ne i64 %15, 0
  %conv13.i.i = zext i1 %cmp11.i.i to i64
  %or.i.i = or i64 %shr.i.i, %conv13.i.i
  br label %frac64_shrjam.exit.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %cmp14.i.i = icmp ne i64 %b.val.i121, 0
  %conv16.i.i = zext i1 %cmp14.i.i to i64
  br label %frac64_shrjam.exit.i

frac64_shrjam.exit.i:                             ; preds = %if.else.i.i, %if.then10.i.i
  %a0.0.i.i = phi i64 [ %or.i.i, %if.then10.i.i ], [ %conv16.i.i, %if.else.i.i ]
  store i64 %a0.0.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  %16 = sub i64 %a.val.i120, %a0.0.i.i
  store i64 %16, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %if.end19.i

if.else.i90:                                      ; preds = %if.then20.i
  %cmp2.i = icmp slt i32 %sub.i, 0
  br i1 %cmp2.i, label %if.then.i29.i, label %if.else9.i

if.then.i29.i:                                    ; preds = %if.else.i90
  store i32 %12, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %frombool.i = xor i8 %frombool.i.i, 1
  store i8 %frombool.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  %cmp2.i30.i = icmp ugt i32 %sub.i, -64
  br i1 %cmp2.i30.i, label %if.then10.i36.i, label %if.else.i31.i

if.then10.i36.i:                                  ; preds = %if.then.i29.i
  %sub7.i = sub nsw i32 0, %sub.i
  %sh_prom.i37.i = zext nneg i32 %sub7.i to i64
  %shr.i38.i = lshr i64 %a.val.i120, %sh_prom.i37.i
  %17 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.val.i120, i32 %sub7.i, i64 0) #15, !srcloc !6
  %cmp11.i39.i = icmp ne i64 %17, 0
  %conv13.i40.i = zext i1 %cmp11.i39.i to i64
  %or.i41.i = or i64 %shr.i38.i, %conv13.i40.i
  br label %frac64_shrjam.exit42.i

if.else.i31.i:                                    ; preds = %if.then.i29.i
  %cmp14.i32.i = icmp ne i64 %a.val.i120, 0
  %conv16.i33.i = zext i1 %cmp14.i32.i to i64
  br label %frac64_shrjam.exit42.i

frac64_shrjam.exit42.i:                           ; preds = %if.else.i31.i, %if.then10.i36.i
  %a0.0.i35.i = phi i64 [ %or.i41.i, %if.then10.i36.i ], [ %conv16.i33.i, %if.else.i31.i ]
  %18 = sub i64 %b.val.i121, %a0.0.i35.i
  store i64 %18, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %if.end19.i

if.else9.i:                                       ; preds = %if.else.i90
  %19 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a.val.i120, i64 %b.val.i121)
  %20 = extractvalue { i64, i1 } %19, 1
  %21 = extractvalue { i64, i1 } %19, 0
  store i64 %21, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br i1 %20, label %if.then11.i, label %if.end19.i

if.then11.i:                                      ; preds = %if.else9.i
  %sub.i.i = sub i64 0, %21
  store i64 %sub.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %frombool17.i = xor i8 %frombool.i.i, 1
  store i8 %frombool17.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  br label %if.end19.i

if.end19.i:                                       ; preds = %if.then11.i, %if.else9.i, %frac64_shrjam.exit42.i, %frac64_shrjam.exit.i
  %22 = phi i32 [ %12, %frac64_shrjam.exit42.i ], [ %5, %if.then11.i ], [ %5, %if.else9.i ], [ %5, %frac64_shrjam.exit.i ]
  %23 = phi i64 [ %18, %frac64_shrjam.exit42.i ], [ %sub.i.i, %if.then11.i ], [ %21, %if.else9.i ], [ %16, %frac64_shrjam.exit.i ]
  %tobool.not.i.i.not = icmp eq i64 %23, 0
  br i1 %tobool.not.i.i.not, label %if.end22.i.thread, label %parts64_sub_normal.exit.thread

parts64_sub_normal.exit.thread:                   ; preds = %if.end19.i
  %24 = tail call i64 @llvm.ctlz.i64(i64 %23, i1 true), !range !5
  %cast.i.i.i91 = trunc i64 %24 to i32
  %shl.i.i92 = shl i64 %23, %24
  store i64 %shl.i.i92, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %sub28.i = sub nsw i32 %22, %cast.i.i.i91
  store i32 %sub28.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_addsub.exit

if.end22.i.thread:                                ; preds = %if.end19.i
  store i8 1, ptr %pa, align 8
  br label %if.then25.i

if.then25.i:                                      ; preds = %if.then.i, %if.end22.i.thread
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %25 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp27.i = icmp eq i8 %25, 1
  %frombool30.i = zext i1 %cmp27.i to i8
  store i8 %frombool30.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  br label %parts64_addsub.exit

if.end31.i:                                       ; preds = %if.then.i
  %and.i = and i32 %or.i, 48
  %tobool32.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool32.i.not, label %if.end40.i, label %p_nan.i

if.end40.i:                                       ; preds = %if.end31.i
  %and41.i = and i32 %or.i, 8
  %tobool42.i.not = icmp eq i32 %and41.i, 0
  br i1 %tobool42.i.not, label %if.end86.i, label %if.then43.i

if.then43.i:                                      ; preds = %if.end40.i
  %cmp46.i.not = icmp eq i8 %6, 3
  br i1 %cmp46.i.not, label %if.end49.i, label %return_b.i

if.end49.i:                                       ; preds = %if.then43.i
  %cmp52.i.not = icmp eq i8 %.pr.i.pre, 3
  br i1 %cmp52.i.not, label %if.end55.i, label %parts64_addsub.exit

if.end55.i:                                       ; preds = %if.end49.i
  %26 = load i16, ptr %status, align 2
  %or1.i = or i16 %26, 129
  store i16 %or1.i, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_addsub.exit

if.else.i:                                        ; preds = %parts64_canonicalize.exit87
  switch i8 %trunc136, label %if.end70.i [
    i8 4, label %if.then65.i
    i8 2, label %parts64_addsub.exit
  ]

if.then65.i:                                      ; preds = %if.else.i
  %sub.i96 = sub nsw i32 %5, %12
  %cmp.i97 = icmp sgt i32 %sub.i96, 0
  br i1 %cmp.i97, label %if.then.i.i104, label %if.else.i98

if.then.i.i104:                                   ; preds = %if.then65.i
  %cmp2.i.i105 = icmp ult i32 %sub.i96, 64
  br i1 %cmp2.i.i105, label %if.then10.i.i111, label %if.else.i.i106

if.then10.i.i111:                                 ; preds = %if.then.i.i104
  %sh_prom.i.i112 = zext nneg i32 %sub.i96 to i64
  %shr.i.i113 = lshr i64 %b.val.i121, %sh_prom.i.i112
  %27 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %b.val.i121, i32 %sub.i96, i64 0) #15, !srcloc !6
  %cmp11.i.i114 = icmp ne i64 %27, 0
  %conv13.i.i115 = zext i1 %cmp11.i.i114 to i64
  %or.i.i116 = or i64 %shr.i.i113, %conv13.i.i115
  br label %frac64_shrjam.exit.i109

if.else.i.i106:                                   ; preds = %if.then.i.i104
  %cmp14.i.i107 = icmp ne i64 %b.val.i121, 0
  %conv16.i.i108 = zext i1 %cmp14.i.i107 to i64
  br label %frac64_shrjam.exit.i109

frac64_shrjam.exit.i109:                          ; preds = %if.else.i.i106, %if.then10.i.i111
  %a0.0.i.i110 = phi i64 [ %or.i.i116, %if.then10.i.i111 ], [ %conv16.i.i108, %if.else.i.i106 ]
  store i64 %a0.0.i.i110, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  br label %if.end7.i

if.else.i98:                                      ; preds = %if.then65.i
  %cmp2.i99 = icmp slt i32 %sub.i96, 0
  br i1 %cmp2.i99, label %if.then.i15.i, label %if.end7.i

if.then.i15.i:                                    ; preds = %if.else.i98
  %cmp2.i16.i = icmp ugt i32 %sub.i96, -64
  br i1 %cmp2.i16.i, label %if.then10.i22.i, label %if.else.i17.i

if.then10.i22.i:                                  ; preds = %if.then.i15.i
  %sub4.i = sub nsw i32 0, %sub.i96
  %sh_prom.i23.i = zext nneg i32 %sub4.i to i64
  %shr.i24.i = lshr i64 %a.val.i120, %sh_prom.i23.i
  %28 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.val.i120, i32 %sub4.i, i64 0) #15, !srcloc !6
  %cmp11.i25.i = icmp ne i64 %28, 0
  %conv13.i26.i = zext i1 %cmp11.i25.i to i64
  %or.i27.i = or i64 %shr.i24.i, %conv13.i26.i
  br label %frac64_shrjam.exit28.i

if.else.i17.i:                                    ; preds = %if.then.i15.i
  %cmp14.i18.i = icmp ne i64 %a.val.i120, 0
  %conv16.i19.i = zext i1 %cmp14.i18.i to i64
  br label %frac64_shrjam.exit28.i

frac64_shrjam.exit28.i:                           ; preds = %if.else.i17.i, %if.then10.i22.i
  %a0.0.i21.i = phi i64 [ %or.i27.i, %if.then10.i22.i ], [ %conv16.i19.i, %if.else.i17.i ]
  store i32 %12, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %if.end7.i

if.end7.i:                                        ; preds = %frac64_shrjam.exit28.i, %if.else.i98, %frac64_shrjam.exit.i109
  %29 = phi i32 [ %12, %frac64_shrjam.exit28.i ], [ %5, %if.else.i98 ], [ %5, %frac64_shrjam.exit.i109 ]
  %b.val.i = phi i64 [ %b.val.i121, %frac64_shrjam.exit28.i ], [ %b.val.i121, %if.else.i98 ], [ %a0.0.i.i110, %frac64_shrjam.exit.i109 ]
  %a.val.i100 = phi i64 [ %a0.0.i21.i, %frac64_shrjam.exit28.i ], [ %a.val.i120, %if.else.i98 ], [ %a.val.i120, %frac64_shrjam.exit.i109 ]
  %30 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %a.val.i100, i64 %b.val.i)
  %31 = extractvalue { i64, i1 } %30, 1
  %32 = extractvalue { i64, i1 } %30, 0
  store i64 %32, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br i1 %31, label %if.then8.i101, label %parts64_addsub.exit

if.then8.i101:                                    ; preds = %if.end7.i
  %shr.i31.i = lshr i64 %32, 1
  %33 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %32, i32 1, i64 0) #15, !srcloc !6
  %cmp11.i32.i = icmp ne i64 %33, 0
  %conv13.i33.i = zext i1 %cmp11.i32.i to i64
  %or.i34.i = or i64 %shr.i31.i, %conv13.i33.i
  %or.i102 = or disjoint i64 %or.i34.i, -9223372036854775808
  store i64 %or.i102, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %add.i103 = add nsw i32 %29, 1
  store i32 %add.i103, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_addsub.exit

if.end70.i:                                       ; preds = %if.else.i
  %and71.i = and i32 %or.i, 48
  %tobool72.i.not = icmp eq i32 %and71.i, 0
  br i1 %tobool72.i.not, label %if.end80.i, label %p_nan.i

if.end80.i:                                       ; preds = %if.end70.i
  %and81.i = and i32 %or.i, 8
  %tobool82.i.not = icmp eq i32 %and81.i, 0
  br i1 %tobool82.i.not, label %if.end86.i, label %if.then83.i

if.then83.i:                                      ; preds = %if.end80.i
  store i8 3, ptr %pa, align 8
  br label %parts64_addsub.exit

if.end86.i:                                       ; preds = %if.end80.i, %if.end40.i
  %cmp89.i = icmp eq i8 %.pr.i.pre, 1
  br i1 %cmp89.i, label %if.then91.i, label %if.end99.i

if.then91.i:                                      ; preds = %if.end86.i
  %cmp94.i = icmp eq i8 %6, 2
  br i1 %cmp94.i, label %parts64_addsub.exit, label %if.else97.i

if.else97.i:                                      ; preds = %if.then91.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 401, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.4) #16
  unreachable

if.end99.i:                                       ; preds = %if.end86.i
  %cmp103.i = icmp eq i8 %6, 1
  br i1 %cmp103.i, label %if.then105.i, label %if.else106.i

if.then105.i:                                     ; preds = %if.end99.i
  %cmp112.i = icmp eq i8 %.pr.i.pre, 2
  br i1 %cmp112.i, label %return_b.i, label %if.else115.i

if.else106.i:                                     ; preds = %if.end99.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 405, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.5) #16
  unreachable

if.else115.i:                                     ; preds = %if.then105.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 406, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.6) #16
  unreachable

return_b.i:                                       ; preds = %if.then105.i, %if.then43.i
  store i8 %frombool4.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i54, align 1
  br label %parts64_addsub.exit

p_nan.i:                                          ; preds = %if.end70.i, %if.end31.i
  %cmp.i.i117 = icmp eq i8 %6, 5
  %cmp.i17.i = icmp eq i8 %.pr.i.pre, 5
  %or.cond = or i1 %cmp.i.i117, %cmp.i17.i
  br i1 %or.cond, label %if.then.i123, label %if.end.i

if.then.i123:                                     ; preds = %p_nan.i
  %34 = load i16, ptr %status, align 2
  %or1.i.i124 = or i16 %34, 8193
  store i16 %or1.i.i124, ptr %status, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %p_nan.i, %if.then.i123
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %35 = load i8, ptr %default_nan_mode.i, align 1
  %36 = and i8 %35, 1
  %tobool.not.i = icmp eq i8 %36, 0
  br i1 %tobool.not.i, label %if.else.i119, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_addsub.exit

if.else.i119:                                     ; preds = %if.end.i
  %cmp.i18.i = icmp eq i64 %a.val.i120, %b.val.i121
  %cmp1.i.i = icmp ult i64 %a.val.i120, %b.val.i121
  %cmp11.i = icmp uge i32 %f.lobit.i, %f.lobit.i49
  %cmp.0.i = select i1 %cmp.i18.i, i1 %cmp11.i, i1 %cmp1.i.i
  %cmp.0.i.fr = freeze i1 %cmp.0.i
  switch i8 %6, label %37 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.else.i119
  br i1 %cmp.i17.i, label %parts64_addsub.exit, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select.i.i = and i1 %cmp.i11.i.i, %cmp.0.i.fr
  %spec.select = select i1 %spec.select.i.i, ptr %pb, ptr %pa
  br label %parts64_addsub.exit

pickNaN.exit.i:                                   ; preds = %if.else.i119
  %cmp.i8.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select20.i = select i1 %cmp.i17.i, i1 %cmp.0.i.fr, i1 %cmp.i8.i.i
  br i1 %spec.select20.i, label %37, label %if.then24.i

37:                                               ; preds = %if.else.i119, %pickNaN.exit.i
  %38 = icmp eq i8 %.pr.i.pre, 5
  br i1 %38, label %if.then24.i, label %parts64_addsub.exit

if.then24.i:                                      ; preds = %pickNaN.exit.i, %37
  %.ph.i139 = phi ptr [ %pb, %37 ], [ %pa, %pickNaN.exit.i ]
  %.ph.i139.sroa.phi = phi ptr [ %pb.sroa.gep, %37 ], [ %pa.sroa.gep, %pickNaN.exit.i ]
  %39 = load i64, ptr %.ph.i139.sroa.phi, align 8
  %or4.i.i.i = or i64 %39, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.ph.i139.sroa.phi, align 8
  store i8 4, ptr %.ph.i139, align 8
  br label %parts64_addsub.exit

parts64_addsub.exit:                              ; preds = %lor.lhs.false.i.i, %if.then24.i, %37, %if.then6.i.i, %if.then3.i, %if.then8.i101, %if.end7.i, %parts64_sub_normal.exit.thread, %if.then91.i, %if.else.i, %if.end49.i, %return_b.i, %if.then83.i, %if.end55.i, %if.then25.i
  %retval.i.0 = phi ptr [ %pa, %if.then25.i ], [ %pb, %return_b.i ], [ %pa, %if.end55.i ], [ %pa, %if.then83.i ], [ %pa, %if.end49.i ], [ %pa, %if.else.i ], [ %pa, %if.then91.i ], [ %pa, %parts64_sub_normal.exit.thread ], [ %pa, %if.end7.i ], [ %pa, %if.then8.i101 ], [ %pa, %if.then3.i ], [ %.ph.i139, %if.then24.i ], [ %pb, %37 ], [ %pa, %if.then6.i.i ], [ %spec.select, %lor.lhs.false.i.i ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %retval.i.0, ptr noundef %status, ptr noundef nonnull @float32_params)
  %sign.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 1
  %40 = load i8, ptr %sign.i.i, align 1
  %conv.i.i = zext i8 %40 to i64
  %shl.i.i125 = shl nuw nsw i64 %conv.i.i, 31
  %exp.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 4
  %41 = load i32, ptr %exp.i.i, align 4
  %42 = shl i32 %41, 23
  %43 = and i32 %42, 2139095040
  %and8.i.i = zext nneg i32 %43 to i64
  %or.i.i126 = or disjoint i64 %shl.i.i125, %and8.i.i
  %44 = getelementptr inbounds i8, ptr %retval.i.0, i64 8
  %45 = load i64, ptr %44, align 8
  %shl77.i9.i = and i64 %45, 8388607
  %or.i10.i = or disjoint i64 %or.i.i126, %shl77.i9.i
  %conv.i = trunc i64 %or.i10.i to i32
  ret i32 %conv.i
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc i64 @soft_f64_addsub(i64 noundef %a, i64 noundef %b, ptr nocapture noundef %status, i1 noundef zeroext %subtract) unnamed_addr #3 {
entry:
  %pa = alloca %struct.FloatParts64, align 8
  %pa.sroa.gep = getelementptr inbounds i8, ptr %pa, i64 8
  %pb = alloca %struct.FloatParts64, align 8
  %pb.sroa.gep = getelementptr inbounds i8, ptr %pb, i64 8
  %f.lobit.i = lshr i64 %a, 63
  %frombool.i.i = trunc i64 %f.lobit.i to i8
  %shr.i8.i = lshr i64 %a, 52
  %0 = trunc i64 %shr.i8.i to i32
  %conv.i.i = and i32 %0, 2047
  %and.i9.i = and i64 %a, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 1
  store i8 %frombool.i.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 4
  store i32 %conv.i.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i = getelementptr inbounds i8, ptr %pa, i64 8
  store i64 %and.i9.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  switch i32 %conv.i.i, label %if.then33.i [
    i32 0, label %if.then.i47
    i32 2047, label %lor.lhs.false.i
  ]

if.then.i47:                                      ; preds = %entry
  %cmp.i.i = icmp eq i64 %and.i9.i, 0
  br i1 %cmp.i.i, label %if.then8.i, label %if.else.i48

if.then8.i:                                       ; preds = %if.then.i47
  store i8 1, ptr %pa, align 8
  br label %parts64_canonicalize.exit

if.else.i48:                                      ; preds = %if.then.i47
  %flush_inputs_to_zero.i = getelementptr inbounds i8, ptr %status, i64 6
  %1 = load i8, ptr %flush_inputs_to_zero.i, align 2
  %2 = and i8 %1, 1
  %tobool9.not.i = icmp eq i8 %2, 0
  br i1 %tobool9.not.i, label %frac64_normalize.exit.i, label %if.then10.i

if.then10.i:                                      ; preds = %if.else.i48
  %3 = load i16, ptr %status, align 2
  %or1.i.i = or i16 %3, 32
  store i16 %or1.i.i, ptr %status, align 2
  store i8 1, ptr %pa, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_canonicalize.exit

frac64_normalize.exit.i:                          ; preds = %if.else.i48
  %4 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i, i1 true), !range !5
  %cast.i.i.i = trunc i64 %4 to i32
  %shl.i.i = shl i64 %and.i9.i, %4
  store i64 %shl.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  store i8 2, ptr %pa, align 8
  %add.i = sub nuw nsw i32 -1011, %cast.i.i.i
  store i32 %add.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_canonicalize.exit

lor.lhs.false.i:                                  ; preds = %entry
  %cmp.i29.i = icmp eq i64 %and.i9.i, 0
  br i1 %cmp.i29.i, label %if.then47.i, label %if.else49.i

if.then33.i:                                      ; preds = %entry
  store i8 2, ptr %pa, align 8
  %sub37.i = add nsw i32 %conv.i.i, -1023
  store i32 %sub37.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %shl.i28.i = shl nuw nsw i64 %and.i9.i, 11
  %or.i46 = or disjoint i64 %shl.i28.i, -9223372036854775808
  store i64 %or.i46, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_canonicalize.exit

if.then47.i:                                      ; preds = %lor.lhs.false.i
  store i8 3, ptr %pa, align 8
  br label %parts64_canonicalize.exit

if.else49.i:                                      ; preds = %lor.lhs.false.i
  %shl.i31.i = shl nuw nsw i64 %and.i9.i, 11
  store i64 %shl.i31.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %tobool.not.i32.i = icmp ult i64 %and.i9.i, 2251799813685248
  %conv53.i = select i1 %tobool.not.i32.i, i8 5, i8 4
  store i8 %conv53.i, ptr %pa, align 8
  br label %parts64_canonicalize.exit

parts64_canonicalize.exit:                        ; preds = %if.then8.i, %if.then10.i, %frac64_normalize.exit.i, %if.then33.i, %if.then47.i, %if.else49.i
  %a.val.i120 = phi i64 [ 0, %if.then8.i ], [ 0, %if.then10.i ], [ %shl.i.i, %frac64_normalize.exit.i ], [ %or.i46, %if.then33.i ], [ 0, %if.then47.i ], [ %shl.i31.i, %if.else49.i ]
  %5 = phi i32 [ 0, %if.then8.i ], [ 0, %if.then10.i ], [ %add.i, %frac64_normalize.exit.i ], [ %sub37.i, %if.then33.i ], [ 2047, %if.then47.i ], [ 2047, %if.else49.i ]
  %6 = phi i8 [ 1, %if.then8.i ], [ 1, %if.then10.i ], [ 2, %frac64_normalize.exit.i ], [ 2, %if.then33.i ], [ 3, %if.then47.i ], [ %conv53.i, %if.else49.i ]
  %f.lobit.i49 = lshr i64 %b, 63
  %frombool.i.i50 = trunc i64 %f.lobit.i49 to i8
  %shr.i8.i51 = lshr i64 %b, 52
  %7 = trunc i64 %shr.i8.i51 to i32
  %conv.i.i52 = and i32 %7, 2047
  %and.i9.i53 = and i64 %b, 4503599627370495
  %.compoundliteral.i.sroa.2.0..sroa_idx.i54 = getelementptr inbounds i8, ptr %pb, i64 1
  store i8 %frombool.i.i50, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i54, align 1
  %.compoundliteral.i.sroa.31.0..sroa_idx.i55 = getelementptr inbounds i8, ptr %pb, i64 4
  store i32 %conv.i.i52, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i55, align 4
  %.compoundliteral.i.sroa.4.0..sroa_idx.i56 = getelementptr inbounds i8, ptr %pb, i64 8
  store i64 %and.i9.i53, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  switch i32 %conv.i.i52, label %if.then33.i69 [
    i32 0, label %if.then.i73
    i32 2047, label %lor.lhs.false.i61
  ]

if.then.i73:                                      ; preds = %parts64_canonicalize.exit
  %cmp.i.i75 = icmp eq i64 %and.i9.i53, 0
  br i1 %cmp.i.i75, label %if.then8.i86, label %if.else.i76

if.then8.i86:                                     ; preds = %if.then.i73
  store i8 1, ptr %pb, align 8
  br label %parts64_canonicalize.exit87

if.else.i76:                                      ; preds = %if.then.i73
  %flush_inputs_to_zero.i77 = getelementptr inbounds i8, ptr %status, i64 6
  %8 = load i8, ptr %flush_inputs_to_zero.i77, align 2
  %9 = and i8 %8, 1
  %tobool9.not.i78 = icmp eq i8 %9, 0
  br i1 %tobool9.not.i78, label %frac64_normalize.exit.i81, label %if.then10.i79

if.then10.i79:                                    ; preds = %if.else.i76
  %10 = load i16, ptr %status, align 2
  %or1.i.i80 = or i16 %10, 32
  store i16 %or1.i.i80, ptr %status, align 2
  store i8 1, ptr %pb, align 8
  store i64 0, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  br label %parts64_canonicalize.exit87

frac64_normalize.exit.i81:                        ; preds = %if.else.i76
  %11 = tail call i64 @llvm.ctlz.i64(i64 %and.i9.i53, i1 true), !range !5
  %cast.i.i.i82 = trunc i64 %11 to i32
  %shl.i.i83 = shl i64 %and.i9.i53, %11
  store i64 %shl.i.i83, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  store i8 2, ptr %pb, align 8
  %add.i85 = sub nuw nsw i32 -1011, %cast.i.i.i82
  store i32 %add.i85, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i55, align 4
  br label %parts64_canonicalize.exit87

lor.lhs.false.i61:                                ; preds = %parts64_canonicalize.exit
  %cmp.i29.i63 = icmp eq i64 %and.i9.i53, 0
  br i1 %cmp.i29.i63, label %if.then47.i68, label %if.else49.i64

if.then33.i69:                                    ; preds = %parts64_canonicalize.exit
  store i8 2, ptr %pb, align 8
  %sub37.i70 = add nsw i32 %conv.i.i52, -1023
  store i32 %sub37.i70, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i55, align 4
  %shl.i28.i71 = shl nuw nsw i64 %and.i9.i53, 11
  %or.i72 = or disjoint i64 %shl.i28.i71, -9223372036854775808
  store i64 %or.i72, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  br label %parts64_canonicalize.exit87

if.then47.i68:                                    ; preds = %lor.lhs.false.i61
  store i8 3, ptr %pb, align 8
  br label %parts64_canonicalize.exit87

if.else49.i64:                                    ; preds = %lor.lhs.false.i61
  %shl.i31.i65 = shl nuw nsw i64 %and.i9.i53, 11
  store i64 %shl.i31.i65, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  %tobool.not.i32.i66 = icmp ult i64 %and.i9.i53, 2251799813685248
  %conv53.i67 = select i1 %tobool.not.i32.i66, i8 5, i8 4
  store i8 %conv53.i67, ptr %pb, align 8
  br label %parts64_canonicalize.exit87

parts64_canonicalize.exit87:                      ; preds = %if.then8.i86, %if.then10.i79, %frac64_normalize.exit.i81, %if.then33.i69, %if.then47.i68, %if.else49.i64
  %b.val.i121 = phi i64 [ 0, %if.then8.i86 ], [ 0, %if.then10.i79 ], [ %shl.i.i83, %frac64_normalize.exit.i81 ], [ %or.i72, %if.then33.i69 ], [ 0, %if.then47.i68 ], [ %shl.i31.i65, %if.else49.i64 ]
  %12 = phi i32 [ 0, %if.then8.i86 ], [ 0, %if.then10.i79 ], [ %add.i85, %frac64_normalize.exit.i81 ], [ %sub37.i70, %if.then33.i69 ], [ 2047, %if.then47.i68 ], [ 2047, %if.else49.i64 ]
  %.pr.i.pre = phi i8 [ 1, %if.then8.i86 ], [ 1, %if.then10.i79 ], [ 2, %frac64_normalize.exit.i81 ], [ 2, %if.then33.i69 ], [ 3, %if.then47.i68 ], [ %conv53.i67, %if.else49.i64 ]
  %13 = icmp slt i64 %b, 0
  %tobool3.i = xor i1 %13, %subtract
  %frombool4.i = zext i1 %tobool3.i to i8
  %conv5.i = zext nneg i8 %6 to i32
  %shl.i = shl nuw nsw i32 1, %conv5.i
  %conv7.i = zext nneg i8 %.pr.i.pre to i32
  %shl8.i = shl nuw nsw i32 1, %conv7.i
  %or.i = or i32 %shl8.i, %shl.i
  %14 = icmp sgt i64 %a, -1
  %cmp.i.not = xor i1 %14, %tobool3.i
  %trunc135 = trunc i32 %or.i to i8
  br i1 %cmp.i.not, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %parts64_canonicalize.exit87
  switch i8 %trunc135, label %if.end31.i [
    i8 4, label %if.then20.i
    i8 2, label %if.then25.i
  ]

if.then20.i:                                      ; preds = %if.then.i
  %sub.i = sub nsw i32 %5, %12
  %cmp.i89 = icmp sgt i32 %sub.i, 0
  br i1 %cmp.i89, label %if.then.i.i, label %if.else.i90

if.then.i.i:                                      ; preds = %if.then20.i
  %cmp2.i.i = icmp ult i32 %sub.i, 64
  br i1 %cmp2.i.i, label %if.then10.i.i, label %if.else.i.i

if.then10.i.i:                                    ; preds = %if.then.i.i
  %sh_prom.i.i = zext nneg i32 %sub.i to i64
  %shr.i.i = lshr i64 %b.val.i121, %sh_prom.i.i
  %15 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %b.val.i121, i32 %sub.i, i64 0) #15, !srcloc !6
  %cmp11.i.i = icmp ne i64 %15, 0
  %conv13.i.i = zext i1 %cmp11.i.i to i64
  %or.i.i = or i64 %shr.i.i, %conv13.i.i
  br label %frac64_shrjam.exit.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %cmp14.i.i = icmp ne i64 %b.val.i121, 0
  %conv16.i.i = zext i1 %cmp14.i.i to i64
  br label %frac64_shrjam.exit.i

frac64_shrjam.exit.i:                             ; preds = %if.else.i.i, %if.then10.i.i
  %a0.0.i.i = phi i64 [ %or.i.i, %if.then10.i.i ], [ %conv16.i.i, %if.else.i.i ]
  store i64 %a0.0.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  %16 = sub i64 %a.val.i120, %a0.0.i.i
  store i64 %16, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %if.end19.i

if.else.i90:                                      ; preds = %if.then20.i
  %cmp2.i = icmp slt i32 %sub.i, 0
  br i1 %cmp2.i, label %if.then.i29.i, label %if.else9.i

if.then.i29.i:                                    ; preds = %if.else.i90
  store i32 %12, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  %frombool.i = xor i8 %frombool.i.i, 1
  store i8 %frombool.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  %cmp2.i30.i = icmp ugt i32 %sub.i, -64
  br i1 %cmp2.i30.i, label %if.then10.i36.i, label %if.else.i31.i

if.then10.i36.i:                                  ; preds = %if.then.i29.i
  %sub7.i = sub nsw i32 0, %sub.i
  %sh_prom.i37.i = zext nneg i32 %sub7.i to i64
  %shr.i38.i = lshr i64 %a.val.i120, %sh_prom.i37.i
  %17 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.val.i120, i32 %sub7.i, i64 0) #15, !srcloc !6
  %cmp11.i39.i = icmp ne i64 %17, 0
  %conv13.i40.i = zext i1 %cmp11.i39.i to i64
  %or.i41.i = or i64 %shr.i38.i, %conv13.i40.i
  br label %frac64_shrjam.exit42.i

if.else.i31.i:                                    ; preds = %if.then.i29.i
  %cmp14.i32.i = icmp ne i64 %a.val.i120, 0
  %conv16.i33.i = zext i1 %cmp14.i32.i to i64
  br label %frac64_shrjam.exit42.i

frac64_shrjam.exit42.i:                           ; preds = %if.else.i31.i, %if.then10.i36.i
  %a0.0.i35.i = phi i64 [ %or.i41.i, %if.then10.i36.i ], [ %conv16.i33.i, %if.else.i31.i ]
  %18 = sub i64 %b.val.i121, %a0.0.i35.i
  store i64 %18, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %if.end19.i

if.else9.i:                                       ; preds = %if.else.i90
  %19 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a.val.i120, i64 %b.val.i121)
  %20 = extractvalue { i64, i1 } %19, 1
  %21 = extractvalue { i64, i1 } %19, 0
  store i64 %21, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br i1 %20, label %if.then11.i, label %if.end19.i

if.then11.i:                                      ; preds = %if.else9.i
  %sub.i.i = sub i64 0, %21
  store i64 %sub.i.i, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %frombool17.i = xor i8 %frombool.i.i, 1
  store i8 %frombool17.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  br label %if.end19.i

if.end19.i:                                       ; preds = %if.then11.i, %if.else9.i, %frac64_shrjam.exit42.i, %frac64_shrjam.exit.i
  %22 = phi i32 [ %12, %frac64_shrjam.exit42.i ], [ %5, %if.then11.i ], [ %5, %if.else9.i ], [ %5, %frac64_shrjam.exit.i ]
  %23 = phi i64 [ %18, %frac64_shrjam.exit42.i ], [ %sub.i.i, %if.then11.i ], [ %21, %if.else9.i ], [ %16, %frac64_shrjam.exit.i ]
  %tobool.not.i.i.not = icmp eq i64 %23, 0
  br i1 %tobool.not.i.i.not, label %if.end22.i.thread, label %parts64_sub_normal.exit.thread

parts64_sub_normal.exit.thread:                   ; preds = %if.end19.i
  %24 = tail call i64 @llvm.ctlz.i64(i64 %23, i1 true), !range !5
  %cast.i.i.i91 = trunc i64 %24 to i32
  %shl.i.i92 = shl i64 %23, %24
  store i64 %shl.i.i92, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %sub28.i = sub nsw i32 %22, %cast.i.i.i91
  store i32 %sub28.i, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_addsub.exit

if.end22.i.thread:                                ; preds = %if.end19.i
  store i8 1, ptr %pa, align 8
  br label %if.then25.i

if.then25.i:                                      ; preds = %if.then.i, %if.end22.i.thread
  %float_rounding_mode.i = getelementptr inbounds i8, ptr %status, i64 2
  %25 = load i8, ptr %float_rounding_mode.i, align 2
  %cmp27.i = icmp eq i8 %25, 1
  %frombool30.i = zext i1 %cmp27.i to i8
  store i8 %frombool30.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  br label %parts64_addsub.exit

if.end31.i:                                       ; preds = %if.then.i
  %and.i = and i32 %or.i, 48
  %tobool32.i.not = icmp eq i32 %and.i, 0
  br i1 %tobool32.i.not, label %if.end40.i, label %p_nan.i

if.end40.i:                                       ; preds = %if.end31.i
  %and41.i = and i32 %or.i, 8
  %tobool42.i.not = icmp eq i32 %and41.i, 0
  br i1 %tobool42.i.not, label %if.end86.i, label %if.then43.i

if.then43.i:                                      ; preds = %if.end40.i
  %cmp46.i.not = icmp eq i8 %6, 3
  br i1 %cmp46.i.not, label %if.end49.i, label %return_b.i

if.end49.i:                                       ; preds = %if.then43.i
  %cmp52.i.not = icmp eq i8 %.pr.i.pre, 3
  br i1 %cmp52.i.not, label %if.end55.i, label %parts64_addsub.exit

if.end55.i:                                       ; preds = %if.end49.i
  %26 = load i16, ptr %status, align 2
  %or1.i = or i16 %26, 129
  store i16 %or1.i, ptr %status, align 2
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_addsub.exit

if.else.i:                                        ; preds = %parts64_canonicalize.exit87
  switch i8 %trunc135, label %if.end70.i [
    i8 4, label %if.then65.i
    i8 2, label %parts64_addsub.exit
  ]

if.then65.i:                                      ; preds = %if.else.i
  %sub.i96 = sub nsw i32 %5, %12
  %cmp.i97 = icmp sgt i32 %sub.i96, 0
  br i1 %cmp.i97, label %if.then.i.i104, label %if.else.i98

if.then.i.i104:                                   ; preds = %if.then65.i
  %cmp2.i.i105 = icmp ult i32 %sub.i96, 64
  br i1 %cmp2.i.i105, label %if.then10.i.i111, label %if.else.i.i106

if.then10.i.i111:                                 ; preds = %if.then.i.i104
  %sh_prom.i.i112 = zext nneg i32 %sub.i96 to i64
  %shr.i.i113 = lshr i64 %b.val.i121, %sh_prom.i.i112
  %27 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %b.val.i121, i32 %sub.i96, i64 0) #15, !srcloc !6
  %cmp11.i.i114 = icmp ne i64 %27, 0
  %conv13.i.i115 = zext i1 %cmp11.i.i114 to i64
  %or.i.i116 = or i64 %shr.i.i113, %conv13.i.i115
  br label %frac64_shrjam.exit.i109

if.else.i.i106:                                   ; preds = %if.then.i.i104
  %cmp14.i.i107 = icmp ne i64 %b.val.i121, 0
  %conv16.i.i108 = zext i1 %cmp14.i.i107 to i64
  br label %frac64_shrjam.exit.i109

frac64_shrjam.exit.i109:                          ; preds = %if.else.i.i106, %if.then10.i.i111
  %a0.0.i.i110 = phi i64 [ %or.i.i116, %if.then10.i.i111 ], [ %conv16.i.i108, %if.else.i.i106 ]
  store i64 %a0.0.i.i110, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i56, align 8
  br label %if.end7.i

if.else.i98:                                      ; preds = %if.then65.i
  %cmp2.i99 = icmp slt i32 %sub.i96, 0
  br i1 %cmp2.i99, label %if.then.i15.i, label %if.end7.i

if.then.i15.i:                                    ; preds = %if.else.i98
  %cmp2.i16.i = icmp ugt i32 %sub.i96, -64
  br i1 %cmp2.i16.i, label %if.then10.i22.i, label %if.else.i17.i

if.then10.i22.i:                                  ; preds = %if.then.i15.i
  %sub4.i = sub nsw i32 0, %sub.i96
  %sh_prom.i23.i = zext nneg i32 %sub4.i to i64
  %shr.i24.i = lshr i64 %a.val.i120, %sh_prom.i23.i
  %28 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a.val.i120, i32 %sub4.i, i64 0) #15, !srcloc !6
  %cmp11.i25.i = icmp ne i64 %28, 0
  %conv13.i26.i = zext i1 %cmp11.i25.i to i64
  %or.i27.i = or i64 %shr.i24.i, %conv13.i26.i
  br label %frac64_shrjam.exit28.i

if.else.i17.i:                                    ; preds = %if.then.i15.i
  %cmp14.i18.i = icmp ne i64 %a.val.i120, 0
  %conv16.i19.i = zext i1 %cmp14.i18.i to i64
  br label %frac64_shrjam.exit28.i

frac64_shrjam.exit28.i:                           ; preds = %if.else.i17.i, %if.then10.i22.i
  %a0.0.i21.i = phi i64 [ %or.i27.i, %if.then10.i22.i ], [ %conv16.i19.i, %if.else.i17.i ]
  store i32 %12, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %if.end7.i

if.end7.i:                                        ; preds = %frac64_shrjam.exit28.i, %if.else.i98, %frac64_shrjam.exit.i109
  %29 = phi i32 [ %12, %frac64_shrjam.exit28.i ], [ %5, %if.else.i98 ], [ %5, %frac64_shrjam.exit.i109 ]
  %b.val.i = phi i64 [ %b.val.i121, %frac64_shrjam.exit28.i ], [ %b.val.i121, %if.else.i98 ], [ %a0.0.i.i110, %frac64_shrjam.exit.i109 ]
  %a.val.i100 = phi i64 [ %a0.0.i21.i, %frac64_shrjam.exit28.i ], [ %a.val.i120, %if.else.i98 ], [ %a.val.i120, %frac64_shrjam.exit.i109 ]
  %30 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %a.val.i100, i64 %b.val.i)
  %31 = extractvalue { i64, i1 } %30, 1
  %32 = extractvalue { i64, i1 } %30, 0
  store i64 %32, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br i1 %31, label %if.then8.i101, label %parts64_addsub.exit

if.then8.i101:                                    ; preds = %if.end7.i
  %shr.i31.i = lshr i64 %32, 1
  %33 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %32, i32 1, i64 0) #15, !srcloc !6
  %cmp11.i32.i = icmp ne i64 %33, 0
  %conv13.i33.i = zext i1 %cmp11.i32.i to i64
  %or.i34.i = or i64 %shr.i31.i, %conv13.i33.i
  %or.i102 = or disjoint i64 %or.i34.i, -9223372036854775808
  store i64 %or.i102, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  %add.i103 = add nsw i32 %29, 1
  store i32 %add.i103, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  br label %parts64_addsub.exit

if.end70.i:                                       ; preds = %if.else.i
  %and71.i = and i32 %or.i, 48
  %tobool72.i.not = icmp eq i32 %and71.i, 0
  br i1 %tobool72.i.not, label %if.end80.i, label %p_nan.i

if.end80.i:                                       ; preds = %if.end70.i
  %and81.i = and i32 %or.i, 8
  %tobool82.i.not = icmp eq i32 %and81.i, 0
  br i1 %tobool82.i.not, label %if.end86.i, label %if.then83.i

if.then83.i:                                      ; preds = %if.end80.i
  store i8 3, ptr %pa, align 8
  br label %parts64_addsub.exit

if.end86.i:                                       ; preds = %if.end80.i, %if.end40.i
  %cmp89.i = icmp eq i8 %.pr.i.pre, 1
  br i1 %cmp89.i, label %if.then91.i, label %if.end99.i

if.then91.i:                                      ; preds = %if.end86.i
  %cmp94.i = icmp eq i8 %6, 2
  br i1 %cmp94.i, label %parts64_addsub.exit, label %if.else97.i

if.else97.i:                                      ; preds = %if.then91.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 401, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.4) #16
  unreachable

if.end99.i:                                       ; preds = %if.end86.i
  %cmp103.i = icmp eq i8 %6, 1
  br i1 %cmp103.i, label %if.then105.i, label %if.else106.i

if.then105.i:                                     ; preds = %if.end99.i
  %cmp112.i = icmp eq i8 %.pr.i.pre, 2
  br i1 %cmp112.i, label %return_b.i, label %if.else115.i

if.else106.i:                                     ; preds = %if.end99.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 405, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.5) #16
  unreachable

if.else115.i:                                     ; preds = %if.then105.i
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 406, ptr noundef nonnull @__func__.parts64_addsub, ptr noundef nonnull @.str.6) #16
  unreachable

return_b.i:                                       ; preds = %if.then105.i, %if.then43.i
  store i8 %frombool4.i, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i54, align 1
  br label %parts64_addsub.exit

p_nan.i:                                          ; preds = %if.end70.i, %if.end31.i
  %cmp.i.i117 = icmp eq i8 %6, 5
  %cmp.i17.i = icmp eq i8 %.pr.i.pre, 5
  %or.cond = or i1 %cmp.i.i117, %cmp.i17.i
  br i1 %or.cond, label %if.then.i123, label %if.end.i

if.then.i123:                                     ; preds = %p_nan.i
  %34 = load i16, ptr %status, align 2
  %or1.i.i124 = or i16 %34, 8193
  store i16 %or1.i.i124, ptr %status, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %p_nan.i, %if.then.i123
  %default_nan_mode.i = getelementptr inbounds i8, ptr %status, i64 7
  %35 = load i8, ptr %default_nan_mode.i, align 1
  %36 = and i8 %35, 1
  %tobool.not.i = icmp eq i8 %36, 0
  br i1 %tobool.not.i, label %if.else.i119, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  store i8 4, ptr %pa, align 8
  store i8 0, ptr %.compoundliteral.i.sroa.2.0..sroa_idx.i, align 1
  store i32 2147483647, ptr %.compoundliteral.i.sroa.31.0..sroa_idx.i, align 4
  store i64 4611686018427387904, ptr %.compoundliteral.i.sroa.4.0..sroa_idx.i, align 8
  br label %parts64_addsub.exit

if.else.i119:                                     ; preds = %if.end.i
  %cmp.i18.i = icmp eq i64 %a.val.i120, %b.val.i121
  %cmp1.i.i = icmp ult i64 %a.val.i120, %b.val.i121
  %cmp11.i = icmp uge i64 %f.lobit.i, %f.lobit.i49
  %cmp.0.i = select i1 %cmp.i18.i, i1 %cmp11.i, i1 %cmp1.i.i
  %cmp.0.i.fr = freeze i1 %cmp.0.i
  switch i8 %6, label %37 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.else.i119
  br i1 %cmp.i17.i, label %parts64_addsub.exit, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select.i.i = and i1 %cmp.i11.i.i, %cmp.0.i.fr
  %spec.select = select i1 %spec.select.i.i, ptr %pb, ptr %pa
  br label %parts64_addsub.exit

pickNaN.exit.i:                                   ; preds = %if.else.i119
  %cmp.i8.i.i = icmp eq i8 %.pr.i.pre, 4
  %spec.select20.i = select i1 %cmp.i17.i, i1 %cmp.0.i.fr, i1 %cmp.i8.i.i
  br i1 %spec.select20.i, label %37, label %if.then24.i

37:                                               ; preds = %if.else.i119, %pickNaN.exit.i
  %38 = icmp eq i8 %.pr.i.pre, 5
  br i1 %38, label %if.then24.i, label %parts64_addsub.exit

if.then24.i:                                      ; preds = %pickNaN.exit.i, %37
  %.ph.i138 = phi ptr [ %pb, %37 ], [ %pa, %pickNaN.exit.i ]
  %.ph.i138.sroa.phi = phi ptr [ %pb.sroa.gep, %37 ], [ %pa.sroa.gep, %pickNaN.exit.i ]
  %39 = load i64, ptr %.ph.i138.sroa.phi, align 8
  %or4.i.i.i = or i64 %39, 4611686018427387904
  store i64 %or4.i.i.i, ptr %.ph.i138.sroa.phi, align 8
  store i8 4, ptr %.ph.i138, align 8
  br label %parts64_addsub.exit

parts64_addsub.exit:                              ; preds = %lor.lhs.false.i.i, %if.then24.i, %37, %if.then6.i.i, %if.then3.i, %if.then8.i101, %if.end7.i, %parts64_sub_normal.exit.thread, %if.then91.i, %if.else.i, %if.end49.i, %return_b.i, %if.then83.i, %if.end55.i, %if.then25.i
  %retval.i.0 = phi ptr [ %pa, %if.then25.i ], [ %pb, %return_b.i ], [ %pa, %if.end55.i ], [ %pa, %if.then83.i ], [ %pa, %if.end49.i ], [ %pa, %if.else.i ], [ %pa, %if.then91.i ], [ %pa, %parts64_sub_normal.exit.thread ], [ %pa, %if.end7.i ], [ %pa, %if.then8.i101 ], [ %pa, %if.then3.i ], [ %.ph.i138, %if.then24.i ], [ %pb, %37 ], [ %pa, %if.then6.i.i ], [ %spec.select, %lor.lhs.false.i.i ]
  call fastcc void @parts64_uncanon(ptr noundef nonnull %retval.i.0, ptr noundef %status, ptr noundef nonnull @float64_params)
  %sign.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 1
  %40 = load i8, ptr %sign.i.i, align 1
  %41 = and i8 %40, 1
  %conv.i.i125 = zext nneg i8 %41 to i64
  %shl.i.i126 = shl nuw i64 %conv.i.i125, 63
  %exp.i.i = getelementptr inbounds i8, ptr %retval.i.0, i64 4
  %42 = load i32, ptr %exp.i.i, align 4
  %43 = and i32 %42, 2047
  %shl77.i.i = zext nneg i32 %43 to i64
  %and8.i.i = shl nuw nsw i64 %shl77.i.i, 52
  %or.i.i127 = or disjoint i64 %and8.i.i, %shl.i.i126
  %44 = getelementptr inbounds i8, ptr %retval.i.0, i64 8
  %45 = load i64, ptr %44, align 8
  %shl77.i9.i = and i64 %45, 4503599627370495
  %or.i10.i = or disjoint i64 %or.i.i127, %shl77.i9.i
  ret i64 %or.i10.i
}

; Function Attrs: nounwind sspstrong memory(argmem: readwrite) uwtable
define internal fastcc zeroext i1 @parts128_sub_normal(ptr nocapture noundef %a, ptr nocapture noundef %b) unnamed_addr #11 {
entry:
  %exp = getelementptr inbounds i8, ptr %a, i64 4
  %0 = load i32, ptr %exp, align 4
  %exp1 = getelementptr inbounds i8, ptr %b, i64 4
  %1 = load i32, ptr %exp1, align 4
  %sub = sub i32 %0, %1
  %cmp = icmp sgt i32 %sub, 0
  br i1 %cmp, label %if.else.i, label %if.else

if.else.i:                                        ; preds = %entry
  %frac_hi.i = getelementptr inbounds i8, ptr %b, i64 8
  %2 = load i64, ptr %frac_hi.i, align 8
  %frac_lo.i = getelementptr inbounds i8, ptr %b, i64 16
  %3 = load i64, ptr %frac_lo.i, align 8
  %cmp2.i = icmp ult i32 %sub, 64
  br i1 %cmp2.i, label %if.end27.i, label %if.else11.i

if.else11.i:                                      ; preds = %if.else.i
  %cmp12.i = icmp ult i32 %sub, 128
  br i1 %cmp12.i, label %if.then20.i, label %if.else24.i

if.then20.i:                                      ; preds = %if.else11.i
  %and.i = and i32 %sub, 63
  %cmp21.i = icmp eq i32 %and.i, 0
  br i1 %cmp21.i, label %frac128_shrjam.exit, label %if.end27.i

if.else24.i:                                      ; preds = %if.else11.i
  %or.i = or i64 %3, %2
  br label %frac128_shrjam.exit

if.end27.i:                                       ; preds = %if.then20.i, %if.else.i
  %c.addr.0.i = phi i32 [ %sub, %if.else.i ], [ %and.i, %if.then20.i ]
  %a0.0.i = phi i64 [ %2, %if.else.i ], [ 0, %if.then20.i ]
  %a1.0.i = phi i64 [ %3, %if.else.i ], [ %2, %if.then20.i ]
  %sticky.0.i = phi i64 [ 0, %if.else.i ], [ %3, %if.then20.i ]
  %4 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a1.0.i, i32 %c.addr.0.i, i64 0) #15, !srcloc !6
  %or28.i = or i64 %4, %sticky.0.i
  %5 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a0.0.i, i32 %c.addr.0.i, i64 %a1.0.i) #15, !srcloc !6
  %sh_prom.i = zext nneg i32 %c.addr.0.i to i64
  %shr.i = lshr i64 %a0.0.i, %sh_prom.i
  br label %frac128_shrjam.exit

frac128_shrjam.exit:                              ; preds = %if.then20.i, %if.else24.i, %if.end27.i
  %a0.1.i = phi i64 [ %shr.i, %if.end27.i ], [ 0, %if.then20.i ], [ 0, %if.else24.i ]
  %a1.1.i = phi i64 [ %5, %if.end27.i ], [ %2, %if.then20.i ], [ 0, %if.else24.i ]
  %sticky.1.i = phi i64 [ %or28.i, %if.end27.i ], [ %3, %if.then20.i ], [ %or.i, %if.else24.i ]
  %cmp30.i = icmp ne i64 %sticky.1.i, 0
  %conv32.i = zext i1 %cmp30.i to i64
  %or33.i = or i64 %a1.1.i, %conv32.i
  store i64 %or33.i, ptr %frac_lo.i, align 8
  store i64 %a0.1.i, ptr %frac_hi.i, align 8
  %frac_lo.i24 = getelementptr inbounds i8, ptr %a, i64 16
  %6 = load i64, ptr %frac_lo.i24, align 8
  %7 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %6, i64 %or33.i)
  %8 = extractvalue { i64, i1 } %7, 1
  %9 = extractvalue { i64, i1 } %7, 0
  store i64 %9, ptr %frac_lo.i24, align 8
  %frac_hi.i25 = getelementptr inbounds i8, ptr %a, i64 8
  %10 = load i64, ptr %frac_hi.i25, align 8
  %11 = load i64, ptr %frac_hi.i, align 8
  %conv.i4.i.neg = sext i1 %8 to i64
  %12 = sub i64 %10, %11
  %13 = add i64 %12, %conv.i4.i.neg
  store i64 %13, ptr %frac_hi.i25, align 8
  br label %if.end19

if.else:                                          ; preds = %entry
  %cmp2 = icmp slt i32 %sub, 0
  br i1 %cmp2, label %if.else.i29, label %if.else9

if.else.i29:                                      ; preds = %if.else
  store i32 %1, ptr %exp, align 4
  %sign = getelementptr inbounds i8, ptr %a, i64 1
  %14 = load i8, ptr %sign, align 1
  %15 = and i8 %14, 1
  %frombool = xor i8 %15, 1
  store i8 %frombool, ptr %sign, align 1
  %sub7 = sub i32 0, %sub
  %frac_hi.i26 = getelementptr inbounds i8, ptr %a, i64 8
  %16 = load i64, ptr %frac_hi.i26, align 8
  %frac_lo.i27 = getelementptr inbounds i8, ptr %a, i64 16
  %17 = load i64, ptr %frac_lo.i27, align 8
  %cmp2.i30 = icmp slt i32 %sub7, 64
  br i1 %cmp2.i30, label %if.end27.i45, label %if.else11.i31

if.else11.i31:                                    ; preds = %if.else.i29
  %cmp12.i32 = icmp ult i32 %sub7, 128
  br i1 %cmp12.i32, label %if.then20.i42, label %if.else24.i33

if.then20.i42:                                    ; preds = %if.else11.i31
  %and.i43 = and i32 %sub7, 63
  %cmp21.i44 = icmp eq i32 %and.i43, 0
  br i1 %cmp21.i44, label %frac128_shrjam.exit53, label %if.end27.i45

if.else24.i33:                                    ; preds = %if.else11.i31
  %or.i34 = or i64 %17, %16
  br label %frac128_shrjam.exit53

if.end27.i45:                                     ; preds = %if.then20.i42, %if.else.i29
  %c.addr.0.i46 = phi i32 [ %sub7, %if.else.i29 ], [ %and.i43, %if.then20.i42 ]
  %a0.0.i47 = phi i64 [ %16, %if.else.i29 ], [ 0, %if.then20.i42 ]
  %a1.0.i48 = phi i64 [ %17, %if.else.i29 ], [ %16, %if.then20.i42 ]
  %sticky.0.i49 = phi i64 [ 0, %if.else.i29 ], [ %17, %if.then20.i42 ]
  %18 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a1.0.i48, i32 %c.addr.0.i46, i64 0) #15, !srcloc !6
  %or28.i50 = or i64 %18, %sticky.0.i49
  %19 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a0.0.i47, i32 %c.addr.0.i46, i64 %a1.0.i48) #15, !srcloc !6
  %sh_prom.i51 = zext nneg i32 %c.addr.0.i46 to i64
  %shr.i52 = lshr i64 %a0.0.i47, %sh_prom.i51
  br label %frac128_shrjam.exit53

frac128_shrjam.exit53:                            ; preds = %if.then20.i42, %if.else24.i33, %if.end27.i45
  %a0.1.i36 = phi i64 [ %shr.i52, %if.end27.i45 ], [ 0, %if.then20.i42 ], [ 0, %if.else24.i33 ]
  %a1.1.i37 = phi i64 [ %19, %if.end27.i45 ], [ %16, %if.then20.i42 ], [ 0, %if.else24.i33 ]
  %sticky.1.i38 = phi i64 [ %or28.i50, %if.end27.i45 ], [ %17, %if.then20.i42 ], [ %or.i34, %if.else24.i33 ]
  %cmp30.i39 = icmp ne i64 %sticky.1.i38, 0
  %conv32.i40 = zext i1 %cmp30.i39 to i64
  %or33.i41 = or i64 %a1.1.i37, %conv32.i40
  store i64 %or33.i41, ptr %frac_lo.i27, align 8
  store i64 %a0.1.i36, ptr %frac_hi.i26, align 8
  %frac_lo.i54 = getelementptr inbounds i8, ptr %b, i64 16
  %20 = load i64, ptr %frac_lo.i54, align 8
  %21 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %20, i64 %or33.i41)
  %22 = extractvalue { i64, i1 } %21, 1
  %23 = extractvalue { i64, i1 } %21, 0
  store i64 %23, ptr %frac_lo.i27, align 8
  %frac_hi.i57 = getelementptr inbounds i8, ptr %b, i64 8
  %24 = load i64, ptr %frac_hi.i57, align 8
  %conv.i4.i59.neg = sext i1 %22 to i64
  %25 = sub i64 %24, %a0.1.i36
  %26 = add i64 %25, %conv.i4.i59.neg
  store i64 %26, ptr %frac_hi.i26, align 8
  br label %if.end19

if.else9:                                         ; preds = %if.else
  %frac_lo.i61 = getelementptr inbounds i8, ptr %a, i64 16
  %27 = load i64, ptr %frac_lo.i61, align 8
  %frac_lo1.i62 = getelementptr inbounds i8, ptr %b, i64 16
  %28 = load i64, ptr %frac_lo1.i62, align 8
  %29 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %27, i64 %28)
  %30 = extractvalue { i64, i1 } %29, 1
  %31 = extractvalue { i64, i1 } %29, 0
  store i64 %31, ptr %frac_lo.i61, align 8
  %frac_hi.i64 = getelementptr inbounds i8, ptr %a, i64 8
  %32 = load i64, ptr %frac_hi.i64, align 8
  %frac_hi3.i65 = getelementptr inbounds i8, ptr %b, i64 8
  %33 = load i64, ptr %frac_hi3.i65, align 8
  %conv.i4.i66 = zext i1 %30 to i64
  %34 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %32, i64 %33)
  %35 = extractvalue { i64, i1 } %34, 1
  %36 = extractvalue { i64, i1 } %34, 0
  %37 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %36, i64 %conv.i4.i66)
  %38 = extractvalue { i64, i1 } %37, 1
  %39 = extractvalue { i64, i1 } %37, 0
  %40 = or i1 %35, %38
  store i64 %39, ptr %frac_hi.i64, align 8
  br i1 %40, label %if.then11, label %if.end19

if.then11:                                        ; preds = %if.else9
  %41 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 0, i64 %31)
  %42 = extractvalue { i64, i1 } %41, 1
  %43 = extractvalue { i64, i1 } %41, 0
  store i64 %43, ptr %frac_lo.i61, align 8
  %conv.i4.neg.i = sext i1 %42 to i64
  %44 = sub i64 %conv.i4.neg.i, %39
  store i64 %44, ptr %frac_hi.i64, align 8
  %sign12 = getelementptr inbounds i8, ptr %a, i64 1
  %45 = load i8, ptr %sign12, align 1
  %46 = and i8 %45, 1
  %frombool17 = xor i8 %46, 1
  store i8 %frombool17, ptr %sign12, align 1
  br label %if.end19

if.end19:                                         ; preds = %frac128_shrjam.exit53, %if.then11, %if.else9, %frac128_shrjam.exit
  %47 = phi i64 [ %23, %frac128_shrjam.exit53 ], [ %43, %if.then11 ], [ %31, %if.else9 ], [ %9, %frac128_shrjam.exit ]
  %48 = phi i64 [ %26, %frac128_shrjam.exit53 ], [ %44, %if.then11 ], [ %39, %if.else9 ], [ %13, %frac128_shrjam.exit ]
  %frac_hi.i70 = getelementptr inbounds i8, ptr %a, i64 8
  %tobool.not.i = icmp eq i64 %48, 0
  br i1 %tobool.not.i, label %if.else.i72, label %if.then.i

if.then.i:                                        ; preds = %if.end19
  %49 = tail call i64 @llvm.ctlz.i64(i64 %48, i1 true), !range !5
  %cast.i.i = trunc i64 %49 to i32
  %frac_lo.i71 = getelementptr inbounds i8, ptr %a, i64 16
  %50 = tail call i64 asm "shld ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %47, i32 %cast.i.i, i64 %48) #15, !srcloc !16
  store i64 %50, ptr %frac_hi.i70, align 8
  %shl6.i = shl i64 %47, %49
  store i64 %shl6.i, ptr %frac_lo.i71, align 8
  br label %if.then26

if.else.i72:                                      ; preds = %if.end19
  %tobool8.not.i = icmp eq i64 %47, 0
  br i1 %tobool8.not.i, label %if.end29, label %if.then9.i

if.then9.i:                                       ; preds = %if.else.i72
  %frac_lo7.i = getelementptr inbounds i8, ptr %a, i64 16
  %51 = tail call i64 @llvm.ctlz.i64(i64 %47, i1 true), !range !5
  %cast.i15.i = trunc i64 %51 to i32
  %shl15.i = shl i64 %47, %51
  store i64 %shl15.i, ptr %frac_hi.i70, align 8
  store i64 0, ptr %frac_lo7.i, align 8
  %add.i = or disjoint i32 %cast.i15.i, 64
  br label %if.then26

if.then26:                                        ; preds = %if.then.i, %if.then9.i
  %retval.0.i.ph = phi i32 [ %add.i, %if.then9.i ], [ %cast.i.i, %if.then.i ]
  %52 = load i32, ptr %exp, align 4
  %sub28 = sub i32 %52, %retval.0.i.ph
  store i32 %sub28, ptr %exp, align 4
  br label %return

if.end29:                                         ; preds = %if.else.i72
  store i8 1, ptr %a, align 8
  br label %return

return:                                           ; preds = %if.end29, %if.then26
  %cmp2176 = phi i1 [ false, %if.end29 ], [ true, %if.then26 ]
  ret i1 %cmp2176
}

; Function Attrs: nounwind sspstrong memory(argmem: readwrite) uwtable
define internal fastcc void @parts128_add_normal(ptr nocapture noundef %a, ptr nocapture noundef %b) unnamed_addr #11 {
entry:
  %exp = getelementptr inbounds i8, ptr %a, i64 4
  %0 = load i32, ptr %exp, align 4
  %exp1 = getelementptr inbounds i8, ptr %b, i64 4
  %1 = load i32, ptr %exp1, align 4
  %sub = sub i32 %0, %1
  %cmp = icmp sgt i32 %sub, 0
  br i1 %cmp, label %if.else.i, label %if.else

if.else.i:                                        ; preds = %entry
  %frac_hi.i = getelementptr inbounds i8, ptr %b, i64 8
  %2 = load i64, ptr %frac_hi.i, align 8
  %frac_lo.i = getelementptr inbounds i8, ptr %b, i64 16
  %3 = load i64, ptr %frac_lo.i, align 8
  %cmp2.i = icmp ult i32 %sub, 64
  br i1 %cmp2.i, label %if.end27.i, label %if.else11.i

if.else11.i:                                      ; preds = %if.else.i
  %cmp12.i = icmp ult i32 %sub, 128
  br i1 %cmp12.i, label %if.then20.i, label %if.else24.i

if.then20.i:                                      ; preds = %if.else11.i
  %and.i = and i32 %sub, 63
  %cmp21.i = icmp eq i32 %and.i, 0
  br i1 %cmp21.i, label %frac128_shrjam.exit, label %if.end27.i

if.else24.i:                                      ; preds = %if.else11.i
  %or.i = or i64 %3, %2
  br label %frac128_shrjam.exit

if.end27.i:                                       ; preds = %if.then20.i, %if.else.i
  %c.addr.0.i = phi i32 [ %sub, %if.else.i ], [ %and.i, %if.then20.i ]
  %a0.0.i = phi i64 [ %2, %if.else.i ], [ 0, %if.then20.i ]
  %a1.0.i = phi i64 [ %3, %if.else.i ], [ %2, %if.then20.i ]
  %sticky.0.i = phi i64 [ 0, %if.else.i ], [ %3, %if.then20.i ]
  %4 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a1.0.i, i32 %c.addr.0.i, i64 0) #15, !srcloc !6
  %or28.i = or i64 %4, %sticky.0.i
  %5 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a0.0.i, i32 %c.addr.0.i, i64 %a1.0.i) #15, !srcloc !6
  %sh_prom.i = zext nneg i32 %c.addr.0.i to i64
  %shr.i = lshr i64 %a0.0.i, %sh_prom.i
  br label %frac128_shrjam.exit

frac128_shrjam.exit:                              ; preds = %if.then20.i, %if.else24.i, %if.end27.i
  %a0.1.i = phi i64 [ %shr.i, %if.end27.i ], [ 0, %if.then20.i ], [ 0, %if.else24.i ]
  %a1.1.i = phi i64 [ %5, %if.end27.i ], [ %2, %if.then20.i ], [ 0, %if.else24.i ]
  %sticky.1.i = phi i64 [ %or28.i, %if.end27.i ], [ %3, %if.then20.i ], [ %or.i, %if.else24.i ]
  %cmp30.i = icmp ne i64 %sticky.1.i, 0
  %conv32.i = zext i1 %cmp30.i to i64
  %or33.i = or i64 %a1.1.i, %conv32.i
  store i64 %or33.i, ptr %frac_lo.i, align 8
  store i64 %a0.1.i, ptr %frac_hi.i, align 8
  br label %if.end7

if.else:                                          ; preds = %entry
  %cmp2 = icmp slt i32 %sub, 0
  br i1 %cmp2, label %if.else.i17, label %if.end7

if.else.i17:                                      ; preds = %if.else
  %sub4 = sub i32 0, %sub
  %frac_hi.i14 = getelementptr inbounds i8, ptr %a, i64 8
  %6 = load i64, ptr %frac_hi.i14, align 8
  %frac_lo.i15 = getelementptr inbounds i8, ptr %a, i64 16
  %7 = load i64, ptr %frac_lo.i15, align 8
  %cmp2.i18 = icmp slt i32 %sub4, 64
  br i1 %cmp2.i18, label %if.end27.i33, label %if.else11.i19

if.else11.i19:                                    ; preds = %if.else.i17
  %cmp12.i20 = icmp ult i32 %sub4, 128
  br i1 %cmp12.i20, label %if.then20.i30, label %if.else24.i21

if.then20.i30:                                    ; preds = %if.else11.i19
  %and.i31 = and i32 %sub4, 63
  %cmp21.i32 = icmp eq i32 %and.i31, 0
  br i1 %cmp21.i32, label %frac128_shrjam.exit41, label %if.end27.i33

if.else24.i21:                                    ; preds = %if.else11.i19
  %or.i22 = or i64 %7, %6
  br label %frac128_shrjam.exit41

if.end27.i33:                                     ; preds = %if.then20.i30, %if.else.i17
  %c.addr.0.i34 = phi i32 [ %sub4, %if.else.i17 ], [ %and.i31, %if.then20.i30 ]
  %a0.0.i35 = phi i64 [ %6, %if.else.i17 ], [ 0, %if.then20.i30 ]
  %a1.0.i36 = phi i64 [ %7, %if.else.i17 ], [ %6, %if.then20.i30 ]
  %sticky.0.i37 = phi i64 [ 0, %if.else.i17 ], [ %7, %if.then20.i30 ]
  %8 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a1.0.i36, i32 %c.addr.0.i34, i64 0) #15, !srcloc !6
  %or28.i38 = or i64 %8, %sticky.0.i37
  %9 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a0.0.i35, i32 %c.addr.0.i34, i64 %a1.0.i36) #15, !srcloc !6
  %sh_prom.i39 = zext nneg i32 %c.addr.0.i34 to i64
  %shr.i40 = lshr i64 %a0.0.i35, %sh_prom.i39
  br label %frac128_shrjam.exit41

frac128_shrjam.exit41:                            ; preds = %if.then20.i30, %if.else24.i21, %if.end27.i33
  %a0.1.i24 = phi i64 [ %shr.i40, %if.end27.i33 ], [ 0, %if.then20.i30 ], [ 0, %if.else24.i21 ]
  %a1.1.i25 = phi i64 [ %9, %if.end27.i33 ], [ %6, %if.then20.i30 ], [ 0, %if.else24.i21 ]
  %sticky.1.i26 = phi i64 [ %or28.i38, %if.end27.i33 ], [ %7, %if.then20.i30 ], [ %or.i22, %if.else24.i21 ]
  %cmp30.i27 = icmp ne i64 %sticky.1.i26, 0
  %conv32.i28 = zext i1 %cmp30.i27 to i64
  %or33.i29 = or i64 %a1.1.i25, %conv32.i28
  store i64 %or33.i29, ptr %frac_lo.i15, align 8
  store i64 %a0.1.i24, ptr %frac_hi.i14, align 8
  %10 = load i32, ptr %exp1, align 4
  store i32 %10, ptr %exp, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.else, %frac128_shrjam.exit41, %frac128_shrjam.exit
  %frac_lo.i42 = getelementptr inbounds i8, ptr %a, i64 16
  %11 = load i64, ptr %frac_lo.i42, align 8
  %frac_lo1.i = getelementptr inbounds i8, ptr %b, i64 16
  %12 = load i64, ptr %frac_lo1.i, align 8
  %13 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %11, i64 %12)
  %14 = extractvalue { i64, i1 } %13, 1
  %15 = extractvalue { i64, i1 } %13, 0
  store i64 %15, ptr %frac_lo.i42, align 8
  %frac_hi.i43 = getelementptr inbounds i8, ptr %a, i64 8
  %16 = load i64, ptr %frac_hi.i43, align 8
  %frac_hi3.i = getelementptr inbounds i8, ptr %b, i64 8
  %17 = load i64, ptr %frac_hi3.i, align 8
  %conv.i4.i = zext i1 %14 to i64
  %18 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %16, i64 %17)
  %19 = extractvalue { i64, i1 } %18, 1
  %20 = extractvalue { i64, i1 } %18, 0
  %21 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %20, i64 %conv.i4.i)
  %22 = extractvalue { i64, i1 } %21, 1
  %23 = extractvalue { i64, i1 } %21, 0
  %24 = or i1 %19, %22
  store i64 %23, ptr %frac_hi.i43, align 8
  br i1 %24, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end7
  %25 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %15, i32 1, i64 0) #15, !srcloc !6
  %26 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %23, i32 1, i64 %15) #15, !srcloc !6
  %shr.i54 = lshr i64 %23, 1
  %cmp30.i59 = icmp ne i64 %25, 0
  %conv32.i60 = zext i1 %cmp30.i59 to i64
  %or33.i61 = or i64 %26, %conv32.i60
  store i64 %or33.i61, ptr %frac_lo.i42, align 8
  %or = or disjoint i64 %shr.i54, -9223372036854775808
  store i64 %or, ptr %frac_hi.i43, align 8
  %27 = load i32, ptr %exp, align 4
  %add = add i32 %27, 1
  store i32 %add, ptr %exp, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end7
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @parts64_uncanon(ptr nocapture noundef %p, ptr nocapture noundef %s, ptr nocapture noundef readonly %fmt) unnamed_addr #3 {
entry:
  %0 = load i8, ptr %p, align 8
  switch i8 %0, label %do.body21 [
    i8 2, label %if.then
    i8 1, label %sw.bb
    i8 3, label %do.body
    i8 4, label %do.body12
    i8 5, label %do.body12
  ]

if.then:                                          ; preds = %entry
  tail call fastcc void @parts64_uncanon_normal(ptr noundef nonnull %p, ptr noundef %s, ptr noundef %fmt)
  br label %if.end23

sw.bb:                                            ; preds = %entry
  %exp = getelementptr inbounds i8, ptr %p, i64 4
  store i32 0, ptr %exp, align 4
  %1 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 0, ptr %1, align 8
  br label %if.end23

do.body:                                          ; preds = %entry
  %arm_althp = getelementptr inbounds i8, ptr %fmt, i64 24
  %2 = load i8, ptr %arm_althp, align 8
  %3 = and i8 %2, 1
  %tobool7.not = icmp eq i8 %3, 0
  br i1 %tobool7.not, label %do.end, label %if.else9

if.else9:                                         ; preds = %do.body
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 317, ptr noundef nonnull @__func__.parts64_uncanon, ptr noundef nonnull @.str.10) #16
  unreachable

do.end:                                           ; preds = %do.body
  %exp_max = getelementptr inbounds i8, ptr %fmt, i64 12
  %4 = load i32, ptr %exp_max, align 4
  %exp10 = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %4, ptr %exp10, align 4
  %5 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 0, ptr %5, align 8
  br label %if.end23

do.body12:                                        ; preds = %entry, %entry
  %arm_althp13 = getelementptr inbounds i8, ptr %fmt, i64 24
  %6 = load i8, ptr %arm_althp13, align 8
  %7 = and i8 %6, 1
  %tobool14.not = icmp eq i8 %7, 0
  br i1 %tobool14.not, label %do.end18, label %if.else16

if.else16:                                        ; preds = %do.body12
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 323, ptr noundef nonnull @__func__.parts64_uncanon, ptr noundef nonnull @.str.10) #16
  unreachable

do.end18:                                         ; preds = %do.body12
  %exp_max19 = getelementptr inbounds i8, ptr %fmt, i64 12
  %8 = load i32, ptr %exp_max19, align 4
  %exp20 = getelementptr inbounds i8, ptr %p, i64 4
  store i32 %8, ptr %exp20, align 4
  %frac_shift = getelementptr inbounds i8, ptr %fmt, i64 20
  %9 = load i32, ptr %frac_shift, align 4
  %10 = getelementptr inbounds i8, ptr %p, i64 8
  %11 = load i64, ptr %10, align 8
  %sh_prom.i = zext nneg i32 %9 to i64
  %shr.i = lshr i64 %11, %sh_prom.i
  store i64 %shr.i, ptr %10, align 8
  br label %if.end23

do.body21:                                        ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 330, ptr noundef nonnull @__func__.parts64_uncanon, ptr noundef null) #16
  unreachable

if.end23:                                         ; preds = %do.end18, %do.end, %sw.bb, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @parts64_uncanon_normal(ptr nocapture noundef %p, ptr nocapture noundef %s, ptr nocapture noundef readonly %fmt) unnamed_addr #3 {
entry:
  %exp_max1 = getelementptr inbounds i8, ptr %fmt, i64 12
  %0 = load i32, ptr %exp_max1, align 4
  %frac_shift2 = getelementptr inbounds i8, ptr %fmt, i64 20
  %1 = load i32, ptr %frac_shift2, align 4
  %round_mask3 = getelementptr inbounds i8, ptr %fmt, i64 32
  %2 = load i64, ptr %round_mask3, align 8
  %add = add i64 %2, 1
  %shr = lshr i64 %2, 1
  %xor = xor i64 %shr, %2
  %or = or i64 %add, %2
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %3 = load i8, ptr %float_rounding_mode, align 2
  switch i8 %3, label %do.body [
    i8 0, label %sw.bb
    i8 4, label %sw.epilog
    i8 3, label %sw.bb6
    i8 2, label %sw.bb7
    i8 1, label %sw.bb15
    i8 5, label %sw.bb26
    i8 6, label %sw.bb27
  ]

sw.bb:                                            ; preds = %entry
  %4 = getelementptr inbounds i8, ptr %p, i64 8
  %5 = load i64, ptr %4, align 8
  %and = and i64 %5, %or
  %cmp.not = icmp eq i64 %and, %xor
  %cond = select i1 %cmp.not, i64 0, i64 %xor
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  %sign = getelementptr inbounds i8, ptr %p, i64 1
  %6 = load i8, ptr %sign, align 1
  %7 = and i8 %6, 1
  %tobool.not = icmp eq i8 %7, 0
  %cond12 = select i1 %tobool.not, i64 %2, i64 0
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry
  %sign16 = getelementptr inbounds i8, ptr %p, i64 1
  %8 = load i8, ptr %sign16, align 1
  %9 = and i8 %8, 1
  %tobool17.not = icmp eq i8 %9, 0
  %cond22 = select i1 %tobool17.not, i64 0, i64 %2
  %frombool25 = xor i8 %9, 1
  br label %sw.epilog

sw.bb26:                                          ; preds = %entry
  br label %sw.bb27

sw.bb27:                                          ; preds = %sw.bb26, %entry
  %overflow_norm.0 = phi i8 [ 0, %entry ], [ 1, %sw.bb26 ]
  %10 = getelementptr inbounds i8, ptr %p, i64 8
  %11 = load i64, ptr %10, align 8
  %and28 = and i64 %11, %add
  %tobool29.not = icmp eq i64 %and28, 0
  %cond33 = select i1 %tobool29.not, i64 %2, i64 0
  br label %sw.epilog

do.body:                                          ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 193, ptr noundef nonnull @__func__.parts64_uncanon_normal, ptr noundef null) #16
  unreachable

sw.epilog:                                        ; preds = %entry, %sw.bb27, %sw.bb15, %sw.bb7, %sw.bb6, %sw.bb
  %inc.0 = phi i64 [ %cond33, %sw.bb27 ], [ %cond22, %sw.bb15 ], [ %cond12, %sw.bb7 ], [ 0, %sw.bb6 ], [ %cond, %sw.bb ], [ %xor, %entry ]
  %overflow_norm.1 = phi i8 [ %overflow_norm.0, %sw.bb27 ], [ %frombool25, %sw.bb15 ], [ %7, %sw.bb7 ], [ 1, %sw.bb6 ], [ 0, %sw.bb ], [ 0, %entry ]
  %exp34 = getelementptr inbounds i8, ptr %p, i64 4
  %12 = load i32, ptr %exp34, align 4
  %exp_bias = getelementptr inbounds i8, ptr %fmt, i64 4
  %13 = load i32, ptr %exp_bias, align 4
  %add35 = add i32 %13, %12
  %cmp36 = icmp sgt i32 %add35, 0
  br i1 %cmp36, label %if.then, label %if.else90

if.then:                                          ; preds = %sw.epilog
  %14 = getelementptr inbounds i8, ptr %p, i64 8
  %15 = load i64, ptr %14, align 8
  %and42 = and i64 %15, %2
  %tobool43.not = icmp eq i64 %and42, 0
  br i1 %tobool43.not, label %if.end50, label %if.then44

if.then44:                                        ; preds = %if.then
  %16 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %15, i64 %inc.0)
  %17 = extractvalue { i64, i1 } %16, 1
  %18 = extractvalue { i64, i1 } %16, 0
  %shr.i = lshr i64 %18, 1
  %or47 = or disjoint i64 %shr.i, -9223372036854775808
  %19 = select i1 %17, i64 %or47, i64 %18
  %inc48 = zext i1 %17 to i32
  %exp.0 = add nuw i32 %add35, %inc48
  %not = xor i64 %2, -1
  %and49 = and i64 %19, %not
  store i64 %and49, ptr %14, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then44, %if.then
  %20 = phi i64 [ %and49, %if.then44 ], [ %15, %if.then ]
  %exp.1 = phi i32 [ %exp.0, %if.then44 ], [ %add35, %if.then ]
  %flags.0 = phi i16 [ 16, %if.then44 ], [ 0, %if.then ]
  %arm_althp = getelementptr inbounds i8, ptr %fmt, i64 24
  %21 = load i8, ptr %arm_althp, align 8
  %22 = and i8 %21, 1
  %tobool51.not = icmp eq i8 %22, 0
  br i1 %tobool51.not, label %if.else, label %if.then52

if.then52:                                        ; preds = %if.end50
  %cmp53 = icmp sgt i32 %exp.1, %0
  br i1 %cmp53, label %if.then61, label %if.end89

if.then61:                                        ; preds = %if.then52
  %not62 = xor i64 %2, -1
  br label %if.end89

if.else:                                          ; preds = %if.end50
  %cmp65.not = icmp slt i32 %exp.1, %0
  br i1 %cmp65.not, label %if.end89, label %if.then73

if.then73:                                        ; preds = %if.else
  %rebias_overflow = getelementptr inbounds i8, ptr %s, i64 11
  %23 = load i8, ptr %rebias_overflow, align 1
  %24 = and i8 %23, 1
  %tobool75.not = icmp eq i8 %24, 0
  br i1 %tobool75.not, label %if.else77, label %if.then76

if.then76:                                        ; preds = %if.then73
  %or74 = or disjoint i16 %flags.0, 4
  %exp_re_bias = getelementptr inbounds i8, ptr %fmt, i64 8
  %25 = load i32, ptr %exp_re_bias, align 8
  %sub = sub i32 %exp.1, %25
  br label %if.end89

if.else77:                                        ; preds = %if.then73
  %tobool78.not = icmp eq i8 %overflow_norm.1, 0
  br i1 %tobool78.not, label %if.else84, label %if.then79

if.then79:                                        ; preds = %if.else77
  %sub81 = add i32 %0, -1
  %not82 = xor i64 %2, -1
  br label %if.end89

if.else84:                                        ; preds = %if.else77
  store i8 3, ptr %p, align 8
  br label %if.end89

if.end89:                                         ; preds = %if.else, %if.then79, %if.else84, %if.then76, %if.then52, %if.then61
  %26 = phi i64 [ %not62, %if.then61 ], [ %20, %if.then52 ], [ %20, %if.then76 ], [ %not82, %if.then79 ], [ 0, %if.else84 ], [ %20, %if.else ]
  %exp.2 = phi i32 [ %0, %if.then61 ], [ %exp.1, %if.then52 ], [ %sub, %if.then76 ], [ %sub81, %if.then79 ], [ %0, %if.else84 ], [ %exp.1, %if.else ]
  %flags.1 = phi i16 [ 1, %if.then61 ], [ %flags.0, %if.then52 ], [ %or74, %if.then76 ], [ 20, %if.then79 ], [ 20, %if.else84 ], [ %flags.0, %if.else ]
  %sh_prom.i = zext nneg i32 %1 to i64
  %shr.i112 = lshr i64 %26, %sh_prom.i
  store i64 %shr.i112, ptr %14, align 8
  br label %if.end186

if.else90:                                        ; preds = %sw.epilog
  %rebias_underflow = getelementptr inbounds i8, ptr %s, i64 12
  %27 = load i8, ptr %rebias_underflow, align 2
  %28 = and i8 %27, 1
  %tobool91.not = icmp eq i8 %28, 0
  br i1 %tobool91.not, label %if.else114, label %if.then98

if.then98:                                        ; preds = %if.else90
  %exp_re_bias100 = getelementptr inbounds i8, ptr %fmt, i64 8
  %29 = load i32, ptr %exp_re_bias100, align 8
  %add101 = add i32 %29, %add35
  %30 = getelementptr inbounds i8, ptr %p, i64 8
  %31 = load i64, ptr %30, align 8
  %and102 = and i64 %31, %2
  %tobool103.not = icmp eq i64 %and102, 0
  br i1 %tobool103.not, label %if.end113, label %if.then104

if.then104:                                       ; preds = %if.then98
  %32 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %31, i64 %inc.0)
  %33 = extractvalue { i64, i1 } %32, 1
  %34 = extractvalue { i64, i1 } %32, 0
  %shr.i113 = lshr i64 %34, 1
  %or108 = or disjoint i64 %shr.i113, -9223372036854775808
  %35 = select i1 %33, i64 %or108, i64 %34
  %inc109 = zext i1 %33 to i32
  %exp.3 = add i32 %add101, %inc109
  %not111 = xor i64 %2, -1
  %and112 = and i64 %35, %not111
  br label %if.end113

if.end113:                                        ; preds = %if.then104, %if.then98
  %36 = phi i64 [ %and112, %if.then104 ], [ %31, %if.then98 ]
  %exp.4 = phi i32 [ %exp.3, %if.then104 ], [ %add101, %if.then98 ]
  %flags.2 = phi i16 [ 24, %if.then104 ], [ 8, %if.then98 ]
  %sh_prom.i114 = zext nneg i32 %1 to i64
  %shr.i115 = lshr i64 %36, %sh_prom.i114
  store i64 %shr.i115, ptr %30, align 8
  br label %if.end186

if.else114:                                       ; preds = %if.else90
  %flush_to_zero = getelementptr inbounds i8, ptr %s, i64 5
  %37 = load i8, ptr %flush_to_zero, align 1
  %38 = and i8 %37, 1
  %tobool115.not = icmp eq i8 %38, 0
  br i1 %tobool115.not, label %if.else119, label %if.then116

if.then116:                                       ; preds = %if.else114
  store i8 1, ptr %p, align 8
  %39 = getelementptr inbounds i8, ptr %p, i64 8
  store i64 0, ptr %39, align 8
  br label %if.end186

if.else119:                                       ; preds = %if.else114
  %tininess_before_rounding = getelementptr inbounds i8, ptr %s, i64 4
  %40 = load i8, ptr %tininess_before_rounding, align 2
  %41 = and i8 %40, 1
  %tobool120 = icmp ne i8 %41, 0
  %cmp122 = icmp ne i32 %add35, 0
  %42 = or i1 %cmp122, %tobool120
  %.phi.trans.insert = getelementptr i8, ptr %p, i64 8
  %.pre = load i64, ptr %.phi.trans.insert, align 8
  %43 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %.pre, i64 %inc.0)
  %44 = extractvalue { i64, i1 } %43, 1
  %lnot128 = xor i1 %44, true
  %is_tiny.0.in = select i1 %42, i1 true, i1 %lnot128
  %m68k_denormal = getelementptr inbounds i8, ptr %fmt, i64 25
  %45 = load i8, ptr %m68k_denormal, align 1
  %46 = and i8 %45, 1
  %47 = xor i8 %46, 1
  %lnot.ext134 = zext nneg i8 %47 to i32
  %sub135 = sub i32 %lnot.ext134, %add35
  %48 = getelementptr inbounds i8, ptr %p, i64 8
  %cmp.not.i = icmp eq i32 %add35, %lnot.ext134
  br i1 %cmp.not.i, label %frac64_shrjam.exit, label %if.then.i

if.then.i:                                        ; preds = %if.else119
  %cmp2.i = icmp slt i32 %sub135, 64
  br i1 %cmp2.i, label %if.then10.i, label %if.else.i

if.then10.i:                                      ; preds = %if.then.i
  %sh_prom.i116 = zext nneg i32 %sub135 to i64
  %shr.i117 = lshr i64 %.pre, %sh_prom.i116
  %49 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %.pre, i32 %sub135, i64 0) #15, !srcloc !6
  %cmp11.i = icmp ne i64 %49, 0
  %conv13.i = zext i1 %cmp11.i to i64
  %or.i = or i64 %shr.i117, %conv13.i
  br label %if.end.i

if.else.i:                                        ; preds = %if.then.i
  %cmp14.i = icmp ne i64 %.pre, 0
  %conv16.i = zext i1 %cmp14.i to i64
  br label %if.end.i

if.end.i:                                         ; preds = %if.else.i, %if.then10.i
  %a0.0.i = phi i64 [ %or.i, %if.then10.i ], [ %conv16.i, %if.else.i ]
  store i64 %a0.0.i, ptr %48, align 8
  br label %frac64_shrjam.exit

frac64_shrjam.exit:                               ; preds = %if.else119, %if.end.i
  %50 = phi i64 [ %.pre, %if.else119 ], [ %a0.0.i, %if.end.i ]
  %and136 = and i64 %50, %2
  %tobool137.not = icmp eq i64 %and136, 0
  br i1 %tobool137.not, label %if.end162, label %if.then138

if.then138:                                       ; preds = %frac64_shrjam.exit
  %51 = load i8, ptr %float_rounding_mode, align 2
  switch i8 %51, label %sw.epilog157 [
    i8 0, label %sw.bb141
    i8 5, label %sw.bb149
    i8 6, label %sw.bb149
  ]

sw.bb141:                                         ; preds = %if.then138
  %and142 = and i64 %50, %or
  %cmp143.not = icmp eq i64 %and142, %xor
  %cond148 = select i1 %cmp143.not, i64 0, i64 %xor
  br label %sw.epilog157

sw.bb149:                                         ; preds = %if.then138, %if.then138
  %and150 = and i64 %50, %add
  %tobool151.not = icmp eq i64 %and150, 0
  %cond155 = select i1 %tobool151.not, i64 %2, i64 0
  br label %sw.epilog157

sw.epilog157:                                     ; preds = %if.then138, %sw.bb149, %sw.bb141
  %inc.1 = phi i64 [ %inc.0, %if.then138 ], [ %cond155, %sw.bb149 ], [ %cond148, %sw.bb141 ]
  %52 = add i64 %inc.1, %50
  %not160 = xor i64 %2, -1
  %and161 = and i64 %52, %not160
  store i64 %and161, ptr %48, align 8
  br label %if.end162

if.end162:                                        ; preds = %sw.epilog157, %frac64_shrjam.exit
  %53 = phi i64 [ %and161, %sw.epilog157 ], [ %50, %frac64_shrjam.exit ]
  %flags.3 = phi i16 [ 16, %sw.epilog157 ], [ 0, %frac64_shrjam.exit ]
  %tobool164.not = icmp sgt i64 %53, -1
  br i1 %tobool164.not, label %land.end.thread, label %land.end

land.end.thread:                                  ; preds = %if.end162
  %sh_prom.i118121 = zext nneg i32 %1 to i64
  %shr.i119122 = lshr i64 %53, %sh_prom.i118121
  store i64 %shr.i119122, ptr %48, align 8
  %or174123 = or disjoint i16 %flags.3, 8
  %spec.select124 = select i1 %tobool137.not, i16 %flags.3, i16 %or174123
  %flags.4125 = select i1 %is_tiny.0.in, i16 %spec.select124, i16 %flags.3
  br label %land.lhs.true178

land.end:                                         ; preds = %if.end162
  %54 = load i8, ptr %m68k_denormal, align 1
  %55 = and i8 %54, 1
  %.not = icmp eq i8 %55, 0
  %sh_prom.i118 = zext nneg i32 %1 to i64
  %shr.i119 = lshr i64 %53, %sh_prom.i118
  store i64 %shr.i119, ptr %48, align 8
  %or174 = or disjoint i16 %flags.3, 8
  %spec.select = select i1 %tobool137.not, i16 %flags.3, i16 %or174
  %flags.4 = select i1 %is_tiny.0.in, i16 %spec.select, i16 %flags.3
  br i1 %.not, label %if.end186, label %land.lhs.true178

land.lhs.true178:                                 ; preds = %land.end.thread, %land.end
  %flags.4127 = phi i16 [ %flags.4125, %land.end.thread ], [ %flags.4, %land.end ]
  %shr.i119126 = phi i64 [ %shr.i119122, %land.end.thread ], [ %shr.i119, %land.end ]
  %cmp.i = icmp eq i64 %shr.i119126, 0
  br i1 %cmp.i, label %if.then181, label %if.end186

if.then181:                                       ; preds = %land.lhs.true178
  store i8 1, ptr %p, align 8
  br label %if.end186

if.end186:                                        ; preds = %if.end113, %land.end, %land.lhs.true178, %if.then181, %if.then116, %if.end89
  %exp.5 = phi i32 [ %exp.2, %if.end89 ], [ %exp.4, %if.end113 ], [ 0, %if.then116 ], [ 0, %if.then181 ], [ 0, %land.lhs.true178 ], [ 1, %land.end ]
  %flags.5 = phi i16 [ %flags.1, %if.end89 ], [ %flags.2, %if.end113 ], [ 64, %if.then116 ], [ %flags.4127, %if.then181 ], [ %flags.4127, %land.lhs.true178 ], [ %flags.4, %land.end ]
  store i32 %exp.5, ptr %exp34, align 4
  %56 = load i16, ptr %s, align 2
  %or1.i = or i16 %56, %flags.5
  store i16 %or1.i, ptr %s, align 2
  ret void
}

; Function Attrs: nounwind sspstrong memory(argmem: readwrite) uwtable
define internal fastcc void @parts128_canonicalize(ptr nocapture noundef %p, ptr nocapture noundef %status, ptr nocapture noundef readonly %fmt) unnamed_addr #11 {
entry:
  %exp = getelementptr inbounds i8, ptr %p, i64 4
  %0 = load i32, ptr %exp, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else21

if.then:                                          ; preds = %entry
  %1 = getelementptr i8, ptr %p, i64 8
  %p.val = load i64, ptr %1, align 8
  %2 = getelementptr i8, ptr %p, i64 16
  %p.val27 = load i64, ptr %2, align 8
  %or.i = or i64 %p.val27, %p.val
  %cmp.i = icmp eq i64 %or.i, 0
  br i1 %cmp.i, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store i8 1, ptr %p, align 8
  br label %if.end58

if.else:                                          ; preds = %if.then
  %flush_inputs_to_zero = getelementptr inbounds i8, ptr %status, i64 6
  %3 = load i8, ptr %flush_inputs_to_zero, align 2
  %4 = and i8 %3, 1
  %tobool9.not = icmp eq i8 %4, 0
  br i1 %tobool9.not, label %if.else12, label %if.then10

if.then10:                                        ; preds = %if.else
  %5 = load i16, ptr %status, align 2
  %or1.i = or i16 %5, 32
  store i16 %or1.i, ptr %status, align 2
  store i8 1, ptr %p, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %1, i8 0, i64 16, i1 false)
  br label %if.end58

if.else12:                                        ; preds = %if.else
  %tobool.not.i = icmp eq i64 %p.val, 0
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.else12
  %6 = tail call i64 @llvm.ctlz.i64(i64 %p.val, i1 true), !range !5
  %cast.i.i = trunc i64 %6 to i32
  %7 = tail call i64 asm "shld ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %p.val27, i32 %cast.i.i, i64 %p.val) #15, !srcloc !16
  store i64 %7, ptr %1, align 8
  %shl6.i = shl i64 %p.val27, %6
  store i64 %shl6.i, ptr %2, align 8
  br label %frac128_normalize.exit

if.else.i:                                        ; preds = %if.else12
  %tobool8.not.i = icmp eq i64 %p.val27, 0
  br i1 %tobool8.not.i, label %frac128_normalize.exit, label %if.then9.i

if.then9.i:                                       ; preds = %if.else.i
  %8 = tail call i64 @llvm.ctlz.i64(i64 %p.val27, i1 true), !range !5
  %cast.i15.i = trunc i64 %8 to i32
  %shl15.i = shl i64 %p.val27, %8
  store i64 %shl15.i, ptr %1, align 8
  store i64 0, ptr %2, align 8
  %add.i = or disjoint i32 %cast.i15.i, 64
  br label %frac128_normalize.exit

frac128_normalize.exit:                           ; preds = %if.then.i, %if.else.i, %if.then9.i
  %retval.0.i = phi i32 [ %cast.i.i, %if.then.i ], [ %add.i, %if.then9.i ], [ 128, %if.else.i ]
  store i8 2, ptr %p, align 8
  %frac_shift = getelementptr inbounds i8, ptr %fmt, i64 20
  %9 = load i32, ptr %frac_shift, align 4
  %exp_bias = getelementptr inbounds i8, ptr %fmt, i64 4
  %10 = load i32, ptr %exp_bias, align 4
  %m68k_denormal = getelementptr inbounds i8, ptr %fmt, i64 25
  %11 = load i8, ptr %m68k_denormal, align 1
  %12 = and i8 %11, 1
  %13 = xor i8 %12, 1
  %lnot.ext18 = zext nneg i8 %13 to i32
  %14 = add i32 %retval.0.i, %10
  %sub15 = sub i32 %9, %14
  %add = add i32 %sub15, %lnot.ext18
  store i32 %add, ptr %exp, align 4
  br label %if.end58

if.else21:                                        ; preds = %entry
  %exp_max = getelementptr inbounds i8, ptr %fmt, i64 12
  %15 = load i32, ptr %exp_max, align 4
  %cmp23 = icmp slt i32 %0, %15
  br i1 %cmp23, label %if.then33, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else21
  %arm_althp = getelementptr inbounds i8, ptr %fmt, i64 24
  %16 = load i8, ptr %arm_althp, align 8
  %17 = and i8 %16, 1
  %tobool31.not = icmp eq i8 %17, 0
  br i1 %tobool31.not, label %if.else39, label %if.then33

if.then33:                                        ; preds = %lor.lhs.false, %if.else21
  store i8 2, ptr %p, align 8
  %exp_bias35 = getelementptr inbounds i8, ptr %fmt, i64 4
  %18 = load i32, ptr %exp_bias35, align 4
  %sub37 = sub i32 %0, %18
  store i32 %sub37, ptr %exp, align 4
  %frac_shift38 = getelementptr inbounds i8, ptr %fmt, i64 20
  %19 = load i32, ptr %frac_shift38, align 4
  %frac_hi.i31 = getelementptr inbounds i8, ptr %p, i64 8
  %20 = load i64, ptr %frac_hi.i31, align 8
  %frac_lo.i32 = getelementptr inbounds i8, ptr %p, i64 16
  %21 = load i64, ptr %frac_lo.i32, align 8
  %and.i = and i32 %19, 64
  %tobool.not.i33 = icmp eq i32 %and.i, 0
  %spec.select.i = select i1 %tobool.not.i33, i64 %20, i64 %21
  %spec.select12.i = select i1 %tobool.not.i33, i64 %21, i64 0
  %and1.i = and i32 %19, 63
  %tobool2.not.i = icmp eq i32 %and1.i, 0
  br i1 %tobool2.not.i, label %frac128_shl.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then33
  %22 = tail call i64 asm "shld ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %spec.select12.i, i32 %and1.i, i64 %spec.select.i) #15, !srcloc !16
  %sh_prom.i = zext nneg i32 %and1.i to i64
  %shl.i = shl i64 %spec.select12.i, %sh_prom.i
  br label %frac128_shl.exit

frac128_shl.exit:                                 ; preds = %if.then33, %if.then3.i
  %a0.1.i = phi i64 [ %22, %if.then3.i ], [ %spec.select.i, %if.then33 ]
  %a1.1.i = phi i64 [ %shl.i, %if.then3.i ], [ %spec.select12.i, %if.then33 ]
  store i64 %a1.1.i, ptr %frac_lo.i32, align 8
  %or = or i64 %a0.1.i, -9223372036854775808
  store i64 %or, ptr %frac_hi.i31, align 8
  br label %if.end58

if.else39:                                        ; preds = %lor.lhs.false
  %23 = getelementptr i8, ptr %p, i64 8
  %p.val28 = load i64, ptr %23, align 8
  %24 = getelementptr i8, ptr %p, i64 16
  %p.val29 = load i64, ptr %24, align 8
  %or.i34 = or i64 %p.val29, %p.val28
  %cmp.i35 = icmp eq i64 %or.i34, 0
  br i1 %cmp.i35, label %if.then47, label %if.else49

if.then47:                                        ; preds = %if.else39
  store i8 3, ptr %p, align 8
  br label %if.end58

if.else49:                                        ; preds = %if.else39
  %frac_shift50 = getelementptr inbounds i8, ptr %fmt, i64 20
  %25 = load i32, ptr %frac_shift50, align 4
  %and.i38 = and i32 %25, 64
  %tobool.not.i39 = icmp eq i32 %and.i38, 0
  %spec.select.i40 = select i1 %tobool.not.i39, i64 %p.val28, i64 %p.val29
  %spec.select12.i41 = select i1 %tobool.not.i39, i64 %p.val29, i64 0
  %and1.i42 = and i32 %25, 63
  %tobool2.not.i43 = icmp eq i32 %and1.i42, 0
  br i1 %tobool2.not.i43, label %frac128_shl.exit49, label %if.then3.i44

if.then3.i44:                                     ; preds = %if.else49
  %26 = tail call i64 asm "shld ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %spec.select12.i41, i32 %and1.i42, i64 %spec.select.i40) #15, !srcloc !16
  %sh_prom.i45 = zext nneg i32 %and1.i42 to i64
  %shl.i46 = shl i64 %spec.select12.i41, %sh_prom.i45
  br label %frac128_shl.exit49

frac128_shl.exit49:                               ; preds = %if.else49, %if.then3.i44
  %a0.1.i47 = phi i64 [ %26, %if.then3.i44 ], [ %spec.select.i40, %if.else49 ]
  %a1.1.i48 = phi i64 [ %shl.i46, %if.then3.i44 ], [ %spec.select12.i41, %if.else49 ]
  store i64 %a0.1.i47, ptr %23, align 8
  store i64 %a1.1.i48, ptr %24, align 8
  %27 = and i64 %a0.1.i47, 4611686018427387904
  %tobool.not.i50 = icmp eq i64 %27, 0
  %conv54 = select i1 %tobool.not.i50, i8 5, i8 4
  store i8 %conv54, ptr %p, align 8
  br label %if.end58

if.end58:                                         ; preds = %frac128_shl.exit, %frac128_shl.exit49, %if.then47, %if.then8, %frac128_normalize.exit, %if.then10
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc void @parts128_uncanon_normal(ptr nocapture noundef %p, ptr nocapture noundef %s, ptr nocapture noundef readonly %fmt) unnamed_addr #3 {
entry:
  %exp_max1 = getelementptr inbounds i8, ptr %fmt, i64 12
  %0 = load i32, ptr %exp_max1, align 4
  %frac_shift2 = getelementptr inbounds i8, ptr %fmt, i64 20
  %1 = load i32, ptr %frac_shift2, align 4
  %round_mask3 = getelementptr inbounds i8, ptr %fmt, i64 32
  %2 = load i64, ptr %round_mask3, align 8
  %add = add i64 %2, 1
  %shr = lshr i64 %2, 1
  %xor = xor i64 %shr, %2
  %or = or i64 %add, %2
  %float_rounding_mode = getelementptr inbounds i8, ptr %s, i64 2
  %3 = load i8, ptr %float_rounding_mode, align 2
  switch i8 %3, label %do.body [
    i8 0, label %sw.bb
    i8 4, label %sw.epilog
    i8 3, label %sw.bb17
    i8 2, label %sw.bb18
    i8 1, label %sw.bb27
    i8 5, label %sw.bb38
    i8 6, label %sw.bb39
  ]

sw.bb:                                            ; preds = %entry
  %cmp = icmp eq i64 %add, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %frac_hi = getelementptr inbounds i8, ptr %p, i64 8
  %4 = load i64, ptr %frac_hi, align 8
  %and = and i64 %4, 1
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %lor.lhs.false, label %cond.true

lor.lhs.false:                                    ; preds = %if.then
  %frac_lo = getelementptr inbounds i8, ptr %p, i64 16
  %5 = load i64, ptr %frac_lo, align 8
  %and5 = and i64 %5, %2
  %cmp6.not = icmp eq i64 %and5, %xor
  br i1 %cmp6.not, label %sw.epilog, label %cond.true

cond.true:                                        ; preds = %lor.lhs.false, %if.then
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb
  %frac_lo8 = getelementptr inbounds i8, ptr %p, i64 16
  %6 = load i64, ptr %frac_lo8, align 8
  %and9 = and i64 %6, %or
  %cmp10.not = icmp eq i64 %and9, %xor
  %cond15 = select i1 %cmp10.not, i64 0, i64 %xor
  br label %sw.epilog

sw.bb17:                                          ; preds = %entry
  br label %sw.epilog

sw.bb18:                                          ; preds = %entry
  %sign = getelementptr inbounds i8, ptr %p, i64 1
  %7 = load i8, ptr %sign, align 1
  %8 = and i8 %7, 1
  %tobool19.not = icmp eq i8 %8, 0
  %cond24 = select i1 %tobool19.not, i64 %2, i64 0
  br label %sw.epilog

sw.bb27:                                          ; preds = %entry
  %sign28 = getelementptr inbounds i8, ptr %p, i64 1
  %9 = load i8, ptr %sign28, align 1
  %10 = and i8 %9, 1
  %tobool29.not = icmp eq i8 %10, 0
  %cond34 = select i1 %tobool29.not, i64 0, i64 %2
  %frombool37 = xor i8 %10, 1
  br label %sw.epilog

sw.bb38:                                          ; preds = %entry
  br label %sw.bb39

sw.bb39:                                          ; preds = %sw.bb38, %entry
  %overflow_norm.0 = phi i8 [ 0, %entry ], [ 1, %sw.bb38 ]
  %cmp40 = icmp eq i64 %add, 0
  br i1 %cmp40, label %if.then42, label %if.else50

if.then42:                                        ; preds = %sw.bb39
  %frac_hi43 = getelementptr inbounds i8, ptr %p, i64 8
  %11 = load i64, ptr %frac_hi43, align 8
  %and44 = and i64 %11, 1
  %tobool45.not = icmp eq i64 %and44, 0
  %cond49 = select i1 %tobool45.not, i64 %2, i64 0
  br label %sw.epilog

if.else50:                                        ; preds = %sw.bb39
  %frac_lo51 = getelementptr inbounds i8, ptr %p, i64 16
  %12 = load i64, ptr %frac_lo51, align 8
  %and52 = and i64 %12, %add
  %tobool53.not = icmp eq i64 %and52, 0
  %cond57 = select i1 %tobool53.not, i64 %2, i64 0
  br label %sw.epilog

do.body:                                          ; preds = %entry
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 193, ptr noundef nonnull @__func__.parts128_uncanon_normal, ptr noundef null) #16
  unreachable

sw.epilog:                                        ; preds = %entry, %cond.true, %lor.lhs.false, %if.then42, %if.else50, %if.else, %sw.bb27, %sw.bb18, %sw.bb17
  %inc.0 = phi i64 [ %cond49, %if.then42 ], [ %cond57, %if.else50 ], [ %cond34, %sw.bb27 ], [ %cond24, %sw.bb18 ], [ 0, %sw.bb17 ], [ %cond15, %if.else ], [ %xor, %cond.true ], [ 0, %lor.lhs.false ], [ %xor, %entry ]
  %overflow_norm.1 = phi i8 [ %overflow_norm.0, %if.then42 ], [ %overflow_norm.0, %if.else50 ], [ %frombool37, %sw.bb27 ], [ %8, %sw.bb18 ], [ 1, %sw.bb17 ], [ 0, %if.else ], [ 0, %cond.true ], [ 0, %lor.lhs.false ], [ 0, %entry ]
  %exp59 = getelementptr inbounds i8, ptr %p, i64 4
  %13 = load i32, ptr %exp59, align 4
  %exp_bias = getelementptr inbounds i8, ptr %fmt, i64 4
  %14 = load i32, ptr %exp_bias, align 4
  %add60 = add i32 %14, %13
  %cmp61 = icmp sgt i32 %add60, 0
  br i1 %cmp61, label %if.then67, label %if.else123

if.then67:                                        ; preds = %sw.epilog
  %frac_lo68 = getelementptr inbounds i8, ptr %p, i64 16
  %15 = load i64, ptr %frac_lo68, align 8
  %and69 = and i64 %15, %2
  %tobool70.not = icmp eq i64 %and69, 0
  br i1 %tobool70.not, label %if.end80, label %if.then71

if.then71:                                        ; preds = %if.then67
  %16 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %15, i64 %inc.0)
  %17 = extractvalue { i64, i1 } %16, 1
  %18 = extractvalue { i64, i1 } %16, 0
  %conv.i = zext i1 %17 to i64
  %frac_hi.i = getelementptr inbounds i8, ptr %p, i64 8
  %19 = load i64, ptr %frac_hi.i, align 8
  %20 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %19, i64 %conv.i)
  %21 = extractvalue { i64, i1 } %20, 1
  %22 = extractvalue { i64, i1 } %20, 0
  store i64 %22, ptr %frac_hi.i, align 8
  br i1 %21, label %if.then73, label %if.end77

if.then73:                                        ; preds = %if.then71
  %23 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %22, i32 1, i64 %18) #15, !srcloc !6
  %shr.i = lshr i64 %22, 1
  %or75 = or disjoint i64 %shr.i, -9223372036854775808
  store i64 %or75, ptr %frac_hi.i, align 8
  %inc76 = add nuw i32 %add60, 1
  br label %if.end77

if.end77:                                         ; preds = %if.then73, %if.then71
  %24 = phi i64 [ %23, %if.then73 ], [ %18, %if.then71 ]
  %exp.0 = phi i32 [ %inc76, %if.then73 ], [ %add60, %if.then71 ]
  %not = xor i64 %2, -1
  %and79 = and i64 %24, %not
  store i64 %and79, ptr %frac_lo68, align 8
  br label %if.end80

if.end80:                                         ; preds = %if.end77, %if.then67
  %25 = phi i64 [ %and79, %if.end77 ], [ %15, %if.then67 ]
  %exp.1 = phi i32 [ %exp.0, %if.end77 ], [ %add60, %if.then67 ]
  %flags.0 = phi i16 [ 16, %if.end77 ], [ 0, %if.then67 ]
  %arm_althp = getelementptr inbounds i8, ptr %fmt, i64 24
  %26 = load i8, ptr %arm_althp, align 8
  %27 = and i8 %26, 1
  %tobool81.not = icmp eq i8 %27, 0
  br i1 %tobool81.not, label %if.else96, label %if.then82

if.then82:                                        ; preds = %if.end80
  %cmp83 = icmp sgt i32 %exp.1, %0
  br i1 %cmp83, label %if.then91, label %if.end122

if.then91:                                        ; preds = %if.then82
  %frac_hi.i129 = getelementptr inbounds i8, ptr %p, i64 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %frac_hi.i129, i8 -1, i64 16, i1 false)
  %not92 = xor i64 %2, -1
  br label %if.end122

if.else96:                                        ; preds = %if.end80
  %cmp97.not = icmp slt i32 %exp.1, %0
  br i1 %cmp97.not, label %if.end122, label %if.then105

if.then105:                                       ; preds = %if.else96
  %rebias_overflow = getelementptr inbounds i8, ptr %s, i64 11
  %28 = load i8, ptr %rebias_overflow, align 1
  %29 = and i8 %28, 1
  %tobool107.not = icmp eq i8 %29, 0
  br i1 %tobool107.not, label %if.else109, label %if.then108

if.then108:                                       ; preds = %if.then105
  %or106 = or disjoint i16 %flags.0, 4
  %exp_re_bias = getelementptr inbounds i8, ptr %fmt, i64 8
  %30 = load i32, ptr %exp_re_bias, align 8
  %sub = sub i32 %exp.1, %30
  br label %if.end122

if.else109:                                       ; preds = %if.then105
  %tobool110.not = icmp eq i8 %overflow_norm.1, 0
  %frac_hi.i131 = getelementptr inbounds i8, ptr %p, i64 8
  br i1 %tobool110.not, label %if.else117, label %if.then111

if.then111:                                       ; preds = %if.else109
  %sub113 = add i32 %0, -1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %frac_hi.i131, i8 -1, i64 16, i1 false)
  %not114 = xor i64 %2, -1
  br label %if.end122

if.else117:                                       ; preds = %if.else109
  store i8 3, ptr %p, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %frac_hi.i131, i8 0, i64 16, i1 false)
  br label %if.end122

if.end122:                                        ; preds = %if.else96, %if.then111, %if.else117, %if.then108, %if.then82, %if.then91
  %31 = phi i64 [ %not92, %if.then91 ], [ %25, %if.then82 ], [ %25, %if.then108 ], [ %not114, %if.then111 ], [ 0, %if.else117 ], [ %25, %if.else96 ]
  %exp.2 = phi i32 [ %0, %if.then91 ], [ %exp.1, %if.then82 ], [ %sub, %if.then108 ], [ %sub113, %if.then111 ], [ %0, %if.else117 ], [ %exp.1, %if.else96 ]
  %flags.1 = phi i16 [ 1, %if.then91 ], [ %flags.0, %if.then82 ], [ %or106, %if.then108 ], [ 20, %if.then111 ], [ 20, %if.else117 ], [ %flags.0, %if.else96 ]
  %frac_hi.i132 = getelementptr inbounds i8, ptr %p, i64 8
  %32 = load i64, ptr %frac_hi.i132, align 8
  %and.i = and i32 %1, 64
  %tobool.not.i = icmp eq i32 %and.i, 0
  %spec.select.i = select i1 %tobool.not.i, i64 %32, i64 0
  %spec.select12.i = select i1 %tobool.not.i, i64 %31, i64 %32
  %and1.i = and i32 %1, 63
  %tobool2.not.i = icmp eq i32 %and1.i, 0
  br i1 %tobool2.not.i, label %frac128_shr.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.end122
  %33 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %spec.select.i, i32 %and1.i, i64 %spec.select12.i) #15, !srcloc !6
  %sh_prom.i = zext nneg i32 %and1.i to i64
  %shr.i134 = lshr i64 %spec.select.i, %sh_prom.i
  br label %frac128_shr.exit

frac128_shr.exit:                                 ; preds = %if.end122, %if.then3.i
  %a0.1.i = phi i64 [ %shr.i134, %if.then3.i ], [ %spec.select.i, %if.end122 ]
  %a1.1.i = phi i64 [ %33, %if.then3.i ], [ %spec.select12.i, %if.end122 ]
  store i64 %a0.1.i, ptr %frac_hi.i132, align 8
  store i64 %a1.1.i, ptr %frac_lo68, align 8
  br label %if.end256

if.else123:                                       ; preds = %sw.epilog
  %rebias_underflow = getelementptr inbounds i8, ptr %s, i64 12
  %34 = load i8, ptr %rebias_underflow, align 2
  %35 = and i8 %34, 1
  %tobool124.not = icmp eq i8 %35, 0
  br i1 %tobool124.not, label %if.else150, label %if.then131

if.then131:                                       ; preds = %if.else123
  %exp_re_bias133 = getelementptr inbounds i8, ptr %fmt, i64 8
  %36 = load i32, ptr %exp_re_bias133, align 8
  %add134 = add i32 %36, %add60
  %frac_lo135 = getelementptr inbounds i8, ptr %p, i64 16
  %37 = load i64, ptr %frac_lo135, align 8
  %and136 = and i64 %37, %2
  %tobool137.not = icmp eq i64 %and136, 0
  br i1 %tobool137.not, label %if.then131.if.end149_crit_edge, label %if.then138

if.then131.if.end149_crit_edge:                   ; preds = %if.then131
  %frac_hi.i146.phi.trans.insert = getelementptr inbounds i8, ptr %p, i64 8
  %.pre = load i64, ptr %frac_hi.i146.phi.trans.insert, align 8
  br label %if.end149

if.then138:                                       ; preds = %if.then131
  %38 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %37, i64 %inc.0)
  %39 = extractvalue { i64, i1 } %38, 1
  %40 = extractvalue { i64, i1 } %38, 0
  %conv.i137 = zext i1 %39 to i64
  %frac_hi.i138 = getelementptr inbounds i8, ptr %p, i64 8
  %41 = load i64, ptr %frac_hi.i138, align 8
  %42 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %41, i64 %conv.i137)
  %43 = extractvalue { i64, i1 } %42, 1
  %44 = extractvalue { i64, i1 } %42, 0
  br i1 %43, label %if.then141, label %if.end145

if.then141:                                       ; preds = %if.then138
  %45 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %44, i32 1, i64 %40) #15, !srcloc !6
  %shr.i143 = lshr i64 %44, 1
  %or143 = or disjoint i64 %shr.i143, -9223372036854775808
  %inc144 = add i32 %add134, 1
  br label %if.end145

if.end145:                                        ; preds = %if.then141, %if.then138
  %46 = phi i64 [ %or143, %if.then141 ], [ %44, %if.then138 ]
  %47 = phi i64 [ %45, %if.then141 ], [ %40, %if.then138 ]
  %exp.3 = phi i32 [ %inc144, %if.then141 ], [ %add134, %if.then138 ]
  %not146 = xor i64 %2, -1
  %and148 = and i64 %47, %not146
  br label %if.end149

if.end149:                                        ; preds = %if.then131.if.end149_crit_edge, %if.end145
  %48 = phi i64 [ %and148, %if.end145 ], [ %37, %if.then131.if.end149_crit_edge ]
  %49 = phi i64 [ %46, %if.end145 ], [ %.pre, %if.then131.if.end149_crit_edge ]
  %exp.4 = phi i32 [ %exp.3, %if.end145 ], [ %add134, %if.then131.if.end149_crit_edge ]
  %flags.2 = phi i16 [ 24, %if.end145 ], [ 8, %if.then131.if.end149_crit_edge ]
  %frac_hi.i146 = getelementptr inbounds i8, ptr %p, i64 8
  %and.i148 = and i32 %1, 64
  %tobool.not.i149 = icmp eq i32 %and.i148, 0
  %spec.select.i150 = select i1 %tobool.not.i149, i64 %49, i64 0
  %spec.select12.i151 = select i1 %tobool.not.i149, i64 %48, i64 %49
  %and1.i152 = and i32 %1, 63
  %tobool2.not.i153 = icmp eq i32 %and1.i152, 0
  br i1 %tobool2.not.i153, label %frac128_shr.exit159, label %if.then3.i154

if.then3.i154:                                    ; preds = %if.end149
  %50 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %spec.select.i150, i32 %and1.i152, i64 %spec.select12.i151) #15, !srcloc !6
  %sh_prom.i155 = zext nneg i32 %and1.i152 to i64
  %shr.i156 = lshr i64 %spec.select.i150, %sh_prom.i155
  br label %frac128_shr.exit159

frac128_shr.exit159:                              ; preds = %if.end149, %if.then3.i154
  %a0.1.i157 = phi i64 [ %shr.i156, %if.then3.i154 ], [ %spec.select.i150, %if.end149 ]
  %a1.1.i158 = phi i64 [ %50, %if.then3.i154 ], [ %spec.select12.i151, %if.end149 ]
  store i64 %a0.1.i157, ptr %frac_hi.i146, align 8
  store i64 %a1.1.i158, ptr %frac_lo135, align 8
  br label %if.end256

if.else150:                                       ; preds = %if.else123
  %flush_to_zero = getelementptr inbounds i8, ptr %s, i64 5
  %51 = load i8, ptr %flush_to_zero, align 1
  %52 = and i8 %51, 1
  %tobool151.not = icmp eq i8 %52, 0
  br i1 %tobool151.not, label %if.else155, label %if.then152

if.then152:                                       ; preds = %if.else150
  store i8 1, ptr %p, align 8
  %frac_hi.i160 = getelementptr inbounds i8, ptr %p, i64 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %frac_hi.i160, i8 0, i64 16, i1 false)
  br label %if.end256

if.else155:                                       ; preds = %if.else150
  %tininess_before_rounding = getelementptr inbounds i8, ptr %s, i64 4
  %53 = load i8, ptr %tininess_before_rounding, align 2
  %54 = and i8 %53, 1
  %tobool156 = icmp ne i8 %54, 0
  %cmp158 = icmp ne i32 %add60, 0
  %55 = or i1 %cmp158, %tobool156
  br i1 %55, label %if.else155.if.end167_crit_edge, label %if.then162

if.else155.if.end167_crit_edge:                   ; preds = %if.else155
  %frac_hi.i166.phi.trans.insert = getelementptr inbounds i8, ptr %p, i64 8
  %.pre194 = load i64, ptr %frac_hi.i166.phi.trans.insert, align 8
  %frac_lo.i167.phi.trans.insert = getelementptr inbounds i8, ptr %p, i64 16
  %.pre195 = load i64, ptr %frac_lo.i167.phi.trans.insert, align 8
  br label %if.end167

if.then162:                                       ; preds = %if.else155
  %frac_lo.i161 = getelementptr inbounds i8, ptr %p, i64 16
  %56 = load i64, ptr %frac_lo.i161, align 8
  %57 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %56, i64 %inc.0)
  %58 = extractvalue { i64, i1 } %57, 1
  %conv.i163 = zext i1 %58 to i64
  %frac_hi.i164 = getelementptr inbounds i8, ptr %p, i64 8
  %59 = load i64, ptr %frac_hi.i164, align 8
  %60 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %59, i64 %conv.i163)
  %61 = extractvalue { i64, i1 } %60, 1
  %lnot164 = xor i1 %61, true
  br label %if.end167

if.end167:                                        ; preds = %if.else155.if.end167_crit_edge, %if.then162
  %.pre196 = phi i64 [ %.pre195, %if.else155.if.end167_crit_edge ], [ %56, %if.then162 ]
  %62 = phi i64 [ %.pre194, %if.else155.if.end167_crit_edge ], [ %59, %if.then162 ]
  %is_tiny.0.in = phi i1 [ true, %if.else155.if.end167_crit_edge ], [ %lnot164, %if.then162 ]
  %m68k_denormal = getelementptr inbounds i8, ptr %fmt, i64 25
  %63 = load i8, ptr %m68k_denormal, align 1
  %64 = and i8 %63, 1
  %65 = xor i8 %64, 1
  %lnot.ext170 = zext nneg i8 %65 to i32
  %sub171 = sub i32 %lnot.ext170, %add60
  %frac_hi.i166 = getelementptr inbounds i8, ptr %p, i64 8
  %frac_lo.i167 = getelementptr inbounds i8, ptr %p, i64 16
  %cmp.i = icmp eq i32 %sub171, 0
  br i1 %cmp.i, label %frac128_shrjam.exit, label %if.else.i

if.else.i:                                        ; preds = %if.end167
  %cmp2.i = icmp slt i32 %sub171, 64
  br i1 %cmp2.i, label %if.end27.i, label %if.else11.i

if.else11.i:                                      ; preds = %if.else.i
  %cmp12.i = icmp ult i32 %sub171, 128
  br i1 %cmp12.i, label %if.then20.i, label %if.else24.i

if.then20.i:                                      ; preds = %if.else11.i
  %and.i170 = and i32 %sub171, 63
  %cmp21.i = icmp eq i32 %and.i170, 0
  br i1 %cmp21.i, label %done.i, label %if.end27.i

if.else24.i:                                      ; preds = %if.else11.i
  %or.i = or i64 %.pre196, %62
  br label %done.i

if.end27.i:                                       ; preds = %if.then20.i, %if.else.i
  %c.addr.0.i = phi i32 [ %sub171, %if.else.i ], [ %and.i170, %if.then20.i ]
  %a0.0.i = phi i64 [ %62, %if.else.i ], [ 0, %if.then20.i ]
  %a1.0.i = phi i64 [ %.pre196, %if.else.i ], [ %62, %if.then20.i ]
  %sticky.0.i = phi i64 [ 0, %if.else.i ], [ %.pre196, %if.then20.i ]
  %66 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a1.0.i, i32 %c.addr.0.i, i64 0) #15, !srcloc !6
  %or28.i = or i64 %66, %sticky.0.i
  %67 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a0.0.i, i32 %c.addr.0.i, i64 %a1.0.i) #15, !srcloc !6
  %sh_prom.i171 = zext nneg i32 %c.addr.0.i to i64
  %shr.i172 = lshr i64 %a0.0.i, %sh_prom.i171
  br label %done.i

done.i:                                           ; preds = %if.end27.i, %if.else24.i, %if.then20.i
  %a0.1.i168 = phi i64 [ %shr.i172, %if.end27.i ], [ 0, %if.then20.i ], [ 0, %if.else24.i ]
  %a1.1.i169 = phi i64 [ %67, %if.end27.i ], [ %62, %if.then20.i ], [ 0, %if.else24.i ]
  %sticky.1.i = phi i64 [ %or28.i, %if.end27.i ], [ %.pre196, %if.then20.i ], [ %or.i, %if.else24.i ]
  %cmp30.i = icmp ne i64 %sticky.1.i, 0
  %conv32.i = zext i1 %cmp30.i to i64
  %or33.i = or i64 %a1.1.i169, %conv32.i
  store i64 %or33.i, ptr %frac_lo.i167, align 8
  store i64 %a0.1.i168, ptr %frac_hi.i166, align 8
  br label %frac128_shrjam.exit

frac128_shrjam.exit:                              ; preds = %if.end167, %done.i
  %.pr = phi i64 [ %a0.1.i168, %done.i ], [ %62, %if.end167 ]
  %68 = phi i64 [ %or33.i, %done.i ], [ %.pre196, %if.end167 ]
  %and173 = and i64 %68, %2
  %tobool174.not = icmp eq i64 %and173, 0
  br i1 %tobool174.not, label %if.end231, label %if.then175

if.then175:                                       ; preds = %frac128_shrjam.exit
  %69 = load i8, ptr %float_rounding_mode, align 2
  switch i8 %69, label %sw.epilog225 [
    i8 0, label %sw.bb178
    i8 5, label %sw.bb204
    i8 6, label %sw.bb204
  ]

sw.bb178:                                         ; preds = %if.then175
  %cmp179 = icmp eq i64 %add, 0
  br i1 %cmp179, label %if.then181, label %if.else194

if.then181:                                       ; preds = %sw.bb178
  %and183 = and i64 %.pr, 1
  %tobool184.not = icmp eq i64 %and183, 0
  %cmp188.not = icmp eq i64 %and173, %xor
  %or.cond = select i1 %tobool184.not, i1 %cmp188.not, i1 false
  %cond193 = select i1 %or.cond, i64 0, i64 %xor
  br label %sw.epilog225

if.else194:                                       ; preds = %sw.bb178
  %and196 = and i64 %68, %or
  %cmp197.not = icmp eq i64 %and196, %xor
  %cond202 = select i1 %cmp197.not, i64 0, i64 %xor
  br label %sw.epilog225

sw.bb204:                                         ; preds = %if.then175, %if.then175
  %cmp205 = icmp eq i64 %add, 0
  br i1 %cmp205, label %if.then207, label %if.else215

if.then207:                                       ; preds = %sw.bb204
  %and209 = and i64 %.pr, 1
  %tobool210.not = icmp eq i64 %and209, 0
  %cond214 = select i1 %tobool210.not, i64 %2, i64 0
  br label %sw.epilog225

if.else215:                                       ; preds = %sw.bb204
  %and217 = and i64 %68, %add
  %tobool218.not = icmp eq i64 %and217, 0
  %cond222 = select i1 %tobool218.not, i64 %2, i64 0
  br label %sw.epilog225

sw.epilog225:                                     ; preds = %if.then175, %if.then207, %if.else215, %if.then181, %if.else194
  %inc.1 = phi i64 [ %inc.0, %if.then175 ], [ %cond214, %if.then207 ], [ %cond222, %if.else215 ], [ %cond193, %if.then181 ], [ %cond202, %if.else194 ]
  %70 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %68, i64 %inc.1)
  %71 = extractvalue { i64, i1 } %70, 1
  %72 = extractvalue { i64, i1 } %70, 0
  %conv.i175 = zext i1 %71 to i64
  %73 = add i64 %.pr, %conv.i175
  store i64 %73, ptr %frac_hi.i166, align 8
  %not228 = xor i64 %2, -1
  %and230 = and i64 %72, %not228
  store i64 %and230, ptr %frac_lo.i167, align 8
  br label %if.end231

if.end231:                                        ; preds = %frac128_shrjam.exit, %sw.epilog225
  %74 = phi i64 [ %and230, %sw.epilog225 ], [ %68, %frac128_shrjam.exit ]
  %75 = phi i64 [ %73, %sw.epilog225 ], [ %.pr, %frac128_shrjam.exit ]
  %flags.3 = phi i16 [ 16, %sw.epilog225 ], [ 0, %frac128_shrjam.exit ]
  %tobool234.not = icmp sgt i64 %75, -1
  br i1 %tobool234.not, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end231
  %76 = load i8, ptr %m68k_denormal, align 1
  %77 = and i8 %76, 1
  %78 = icmp ne i8 %77, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end231
  %land.ext = phi i1 [ true, %if.end231 ], [ %78, %land.rhs ]
  %and.i180 = and i32 %1, 64
  %tobool.not.i181 = icmp eq i32 %and.i180, 0
  %spec.select.i182 = select i1 %tobool.not.i181, i64 %75, i64 0
  %spec.select12.i183 = select i1 %tobool.not.i181, i64 %74, i64 %75
  %and1.i184 = and i32 %1, 63
  %tobool2.not.i185 = icmp eq i32 %and1.i184, 0
  br i1 %tobool2.not.i185, label %frac128_shr.exit191, label %if.then3.i186

if.then3.i186:                                    ; preds = %land.end
  %79 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %spec.select.i182, i32 %and1.i184, i64 %spec.select12.i183) #15, !srcloc !6
  %sh_prom.i187 = zext nneg i32 %and1.i184 to i64
  %shr.i188 = lshr i64 %spec.select.i182, %sh_prom.i187
  br label %frac128_shr.exit191

frac128_shr.exit191:                              ; preds = %land.end, %if.then3.i186
  %a0.1.i189 = phi i64 [ %shr.i188, %if.then3.i186 ], [ %spec.select.i182, %land.end ]
  %a1.1.i190 = phi i64 [ %79, %if.then3.i186 ], [ %spec.select12.i183, %land.end ]
  store i64 %a0.1.i189, ptr %frac_hi.i166, align 8
  store i64 %a1.1.i190, ptr %frac_lo.i167, align 8
  %or244 = or disjoint i16 %flags.3, 8
  %spec.select = select i1 %tobool174.not, i16 %flags.3, i16 %or244
  %flags.4 = select i1 %is_tiny.0.in, i16 %spec.select, i16 %flags.3
  br i1 %land.ext, label %land.lhs.true248, label %if.end256

land.lhs.true248:                                 ; preds = %frac128_shr.exit191
  %or.i192 = or i64 %a1.1.i190, %a0.1.i189
  %cmp.i193 = icmp eq i64 %or.i192, 0
  br i1 %cmp.i193, label %if.then251, label %if.end256

if.then251:                                       ; preds = %land.lhs.true248
  store i8 1, ptr %p, align 8
  br label %if.end256

if.end256:                                        ; preds = %frac128_shr.exit159, %frac128_shr.exit191, %land.lhs.true248, %if.then251, %if.then152, %frac128_shr.exit
  %exp.5 = phi i32 [ %exp.2, %frac128_shr.exit ], [ %exp.4, %frac128_shr.exit159 ], [ 0, %if.then152 ], [ 0, %if.then251 ], [ 0, %land.lhs.true248 ], [ 1, %frac128_shr.exit191 ]
  %flags.5 = phi i16 [ %flags.1, %frac128_shr.exit ], [ %flags.2, %frac128_shr.exit159 ], [ 64, %if.then152 ], [ %flags.4, %if.then251 ], [ %flags.4, %land.lhs.true248 ], [ %flags.4, %frac128_shr.exit191 ]
  store i32 %exp.5, ptr %exp59, align 4
  %80 = load i16, ptr %s, align 2
  %or1.i = or i16 %80, %flags.5
  store i16 %or1.i, ptr %s, align 2
  ret void
}

; Function Attrs: nounwind sspstrong memory(argmem: readwrite) uwtable
define internal fastcc void @parts256_add_normal(ptr nocapture noundef %a, ptr nocapture noundef %b) unnamed_addr #11 {
entry:
  %exp = getelementptr inbounds i8, ptr %a, i64 4
  %0 = load i32, ptr %exp, align 4
  %exp1 = getelementptr inbounds i8, ptr %b, i64 4
  %1 = load i32, ptr %exp1, align 4
  %sub = sub i32 %0, %1
  %cmp = icmp sgt i32 %sub, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %frac_hi.i = getelementptr inbounds i8, ptr %b, i64 8
  %2 = load i64, ptr %frac_hi.i, align 8
  %frac_hm.i = getelementptr inbounds i8, ptr %b, i64 16
  %3 = load i64, ptr %frac_hm.i, align 8
  %frac_lm.i = getelementptr inbounds i8, ptr %b, i64 24
  %4 = load i64, ptr %frac_lm.i, align 8
  %frac_lo.i = getelementptr inbounds i8, ptr %b, i64 32
  %5 = load i64, ptr %frac_lo.i, align 8
  %cmp2.i = icmp ult i32 %sub, 64
  br i1 %cmp2.i, label %if.end52.i, label %if.else11.i

if.else11.i:                                      ; preds = %if.then
  %cmp12.i = icmp ult i32 %sub, 256
  br i1 %cmp12.i, label %if.then20.i, label %if.else46.i

if.then20.i:                                      ; preds = %if.else11.i
  %tobool21.not.i = icmp ult i32 %sub, 128
  br i1 %tobool21.not.i, label %if.end.i, label %if.then28.i

if.then28.i:                                      ; preds = %if.then20.i
  %or.i = or i64 %5, %4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then28.i, %if.then20.i
  %a0.0.i = phi i64 [ 0, %if.then28.i ], [ %2, %if.then20.i ]
  %a1.0.i = phi i64 [ 0, %if.then28.i ], [ %3, %if.then20.i ]
  %a2.0.i = phi i64 [ %2, %if.then28.i ], [ %4, %if.then20.i ]
  %a3.0.i = phi i64 [ %3, %if.then28.i ], [ %5, %if.then20.i ]
  %sticky.0.i = phi i64 [ %or.i, %if.then28.i ], [ 0, %if.then20.i ]
  %and30.i = and i32 %sub, 64
  %tobool31.not.i = icmp eq i32 %and30.i, 0
  br i1 %tobool31.not.i, label %if.end40.i, label %if.then38.i

if.then38.i:                                      ; preds = %if.end.i
  %or39.i = or i64 %sticky.0.i, %a3.0.i
  br label %if.end40.i

if.end40.i:                                       ; preds = %if.then38.i, %if.end.i
  %a0.1.i = phi i64 [ 0, %if.then38.i ], [ %a0.0.i, %if.end.i ]
  %a1.1.i = phi i64 [ %a0.0.i, %if.then38.i ], [ %a1.0.i, %if.end.i ]
  %a2.1.i = phi i64 [ %a1.0.i, %if.then38.i ], [ %a2.0.i, %if.end.i ]
  %a3.1.i = phi i64 [ %a2.0.i, %if.then38.i ], [ %a3.0.i, %if.end.i ]
  %sticky.1.i = phi i64 [ %or39.i, %if.then38.i ], [ %sticky.0.i, %if.end.i ]
  %and41.i = and i32 %sub, 63
  %cmp42.i = icmp eq i32 %and41.i, 0
  br i1 %cmp42.i, label %frac256_shrjam.exit, label %if.end52.i

if.else46.i:                                      ; preds = %if.else11.i
  %or47.i = or i64 %5, %4
  %or48.i = or i64 %or47.i, %2
  %or49.i = or i64 %or48.i, %3
  br label %frac256_shrjam.exit

if.end52.i:                                       ; preds = %if.end40.i, %if.then
  %c.addr.0.i = phi i32 [ %sub, %if.then ], [ %and41.i, %if.end40.i ]
  %a0.2.i = phi i64 [ %2, %if.then ], [ %a0.1.i, %if.end40.i ]
  %a1.2.i = phi i64 [ %3, %if.then ], [ %a1.1.i, %if.end40.i ]
  %a2.2.i = phi i64 [ %4, %if.then ], [ %a2.1.i, %if.end40.i ]
  %a3.2.i = phi i64 [ %5, %if.then ], [ %a3.1.i, %if.end40.i ]
  %sticky.2.i = phi i64 [ 0, %if.then ], [ %sticky.1.i, %if.end40.i ]
  %6 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a3.2.i, i32 %c.addr.0.i, i64 0) #15, !srcloc !6
  %or53.i = or i64 %6, %sticky.2.i
  %7 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a2.2.i, i32 %c.addr.0.i, i64 %a3.2.i) #15, !srcloc !6
  %8 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a1.2.i, i32 %c.addr.0.i, i64 %a2.2.i) #15, !srcloc !6
  %9 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a0.2.i, i32 %c.addr.0.i, i64 %a1.2.i) #15, !srcloc !6
  %sh_prom.i = zext nneg i32 %c.addr.0.i to i64
  %shr.i = lshr i64 %a0.2.i, %sh_prom.i
  br label %frac256_shrjam.exit

frac256_shrjam.exit:                              ; preds = %if.end40.i, %if.else46.i, %if.end52.i
  %a0.3.i = phi i64 [ %shr.i, %if.end52.i ], [ %a0.1.i, %if.end40.i ], [ 0, %if.else46.i ]
  %a1.3.i = phi i64 [ %9, %if.end52.i ], [ %a1.1.i, %if.end40.i ], [ 0, %if.else46.i ]
  %a2.3.i = phi i64 [ %8, %if.end52.i ], [ %a2.1.i, %if.end40.i ], [ 0, %if.else46.i ]
  %a3.3.i = phi i64 [ %7, %if.end52.i ], [ %a3.1.i, %if.end40.i ], [ 0, %if.else46.i ]
  %sticky.3.i = phi i64 [ %or53.i, %if.end52.i ], [ %sticky.1.i, %if.end40.i ], [ %or49.i, %if.else46.i ]
  %cmp57.i = icmp ne i64 %sticky.3.i, 0
  %conv59.i = zext i1 %cmp57.i to i64
  %or60.i = or i64 %a3.3.i, %conv59.i
  store i64 %or60.i, ptr %frac_lo.i, align 8
  store i64 %a2.3.i, ptr %frac_lm.i, align 8
  store i64 %a1.3.i, ptr %frac_hm.i, align 8
  store i64 %a0.3.i, ptr %frac_hi.i, align 8
  br label %if.end7

if.else:                                          ; preds = %entry
  %cmp2 = icmp slt i32 %sub, 0
  br i1 %cmp2, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.else
  %sub4 = sub i32 0, %sub
  %frac_hi.i14 = getelementptr inbounds i8, ptr %a, i64 8
  %10 = load i64, ptr %frac_hi.i14, align 8
  %frac_hm.i15 = getelementptr inbounds i8, ptr %a, i64 16
  %11 = load i64, ptr %frac_hm.i15, align 8
  %frac_lm.i16 = getelementptr inbounds i8, ptr %a, i64 24
  %12 = load i64, ptr %frac_lm.i16, align 8
  %frac_lo.i17 = getelementptr inbounds i8, ptr %a, i64 32
  %13 = load i64, ptr %frac_lo.i17, align 8
  %cmp2.i18 = icmp slt i32 %sub4, 64
  br i1 %cmp2.i18, label %if.end52.i55, label %if.else11.i19

if.else11.i19:                                    ; preds = %if.then3
  %cmp12.i20 = icmp ult i32 %sub4, 256
  br i1 %cmp12.i20, label %if.then20.i33, label %if.else46.i21

if.then20.i33:                                    ; preds = %if.else11.i19
  %tobool21.not.i34 = icmp ult i32 %sub4, 128
  br i1 %tobool21.not.i34, label %if.end.i37, label %if.then28.i35

if.then28.i35:                                    ; preds = %if.then20.i33
  %or.i36 = or i64 %13, %12
  br label %if.end.i37

if.end.i37:                                       ; preds = %if.then28.i35, %if.then20.i33
  %a0.0.i38 = phi i64 [ 0, %if.then28.i35 ], [ %10, %if.then20.i33 ]
  %a1.0.i39 = phi i64 [ 0, %if.then28.i35 ], [ %11, %if.then20.i33 ]
  %a2.0.i40 = phi i64 [ %10, %if.then28.i35 ], [ %12, %if.then20.i33 ]
  %a3.0.i41 = phi i64 [ %11, %if.then28.i35 ], [ %13, %if.then20.i33 ]
  %sticky.0.i42 = phi i64 [ %or.i36, %if.then28.i35 ], [ 0, %if.then20.i33 ]
  %and30.i43 = and i32 %sub4, 64
  %tobool31.not.i44 = icmp eq i32 %and30.i43, 0
  br i1 %tobool31.not.i44, label %if.end40.i47, label %if.then38.i45

if.then38.i45:                                    ; preds = %if.end.i37
  %or39.i46 = or i64 %sticky.0.i42, %a3.0.i41
  br label %if.end40.i47

if.end40.i47:                                     ; preds = %if.then38.i45, %if.end.i37
  %a0.1.i48 = phi i64 [ 0, %if.then38.i45 ], [ %a0.0.i38, %if.end.i37 ]
  %a1.1.i49 = phi i64 [ %a0.0.i38, %if.then38.i45 ], [ %a1.0.i39, %if.end.i37 ]
  %a2.1.i50 = phi i64 [ %a1.0.i39, %if.then38.i45 ], [ %a2.0.i40, %if.end.i37 ]
  %a3.1.i51 = phi i64 [ %a2.0.i40, %if.then38.i45 ], [ %a3.0.i41, %if.end.i37 ]
  %sticky.1.i52 = phi i64 [ %or39.i46, %if.then38.i45 ], [ %sticky.0.i42, %if.end.i37 ]
  %and41.i53 = and i32 %sub4, 63
  %cmp42.i54 = icmp eq i32 %and41.i53, 0
  br i1 %cmp42.i54, label %frac256_shrjam.exit65, label %if.end52.i55

if.else46.i21:                                    ; preds = %if.else11.i19
  %or47.i22 = or i64 %13, %12
  %or48.i23 = or i64 %or47.i22, %10
  %or49.i24 = or i64 %or48.i23, %11
  br label %frac256_shrjam.exit65

if.end52.i55:                                     ; preds = %if.end40.i47, %if.then3
  %c.addr.0.i56 = phi i32 [ %sub4, %if.then3 ], [ %and41.i53, %if.end40.i47 ]
  %a0.2.i57 = phi i64 [ %10, %if.then3 ], [ %a0.1.i48, %if.end40.i47 ]
  %a1.2.i58 = phi i64 [ %11, %if.then3 ], [ %a1.1.i49, %if.end40.i47 ]
  %a2.2.i59 = phi i64 [ %12, %if.then3 ], [ %a2.1.i50, %if.end40.i47 ]
  %a3.2.i60 = phi i64 [ %13, %if.then3 ], [ %a3.1.i51, %if.end40.i47 ]
  %sticky.2.i61 = phi i64 [ 0, %if.then3 ], [ %sticky.1.i52, %if.end40.i47 ]
  %14 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a3.2.i60, i32 %c.addr.0.i56, i64 0) #15, !srcloc !6
  %or53.i62 = or i64 %14, %sticky.2.i61
  %15 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a2.2.i59, i32 %c.addr.0.i56, i64 %a3.2.i60) #15, !srcloc !6
  %16 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a1.2.i58, i32 %c.addr.0.i56, i64 %a2.2.i59) #15, !srcloc !6
  %17 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a0.2.i57, i32 %c.addr.0.i56, i64 %a1.2.i58) #15, !srcloc !6
  %sh_prom.i63 = zext nneg i32 %c.addr.0.i56 to i64
  %shr.i64 = lshr i64 %a0.2.i57, %sh_prom.i63
  br label %frac256_shrjam.exit65

frac256_shrjam.exit65:                            ; preds = %if.end40.i47, %if.else46.i21, %if.end52.i55
  %a0.3.i25 = phi i64 [ %shr.i64, %if.end52.i55 ], [ %a0.1.i48, %if.end40.i47 ], [ 0, %if.else46.i21 ]
  %a1.3.i26 = phi i64 [ %17, %if.end52.i55 ], [ %a1.1.i49, %if.end40.i47 ], [ 0, %if.else46.i21 ]
  %a2.3.i27 = phi i64 [ %16, %if.end52.i55 ], [ %a2.1.i50, %if.end40.i47 ], [ 0, %if.else46.i21 ]
  %a3.3.i28 = phi i64 [ %15, %if.end52.i55 ], [ %a3.1.i51, %if.end40.i47 ], [ 0, %if.else46.i21 ]
  %sticky.3.i29 = phi i64 [ %or53.i62, %if.end52.i55 ], [ %sticky.1.i52, %if.end40.i47 ], [ %or49.i24, %if.else46.i21 ]
  %cmp57.i30 = icmp ne i64 %sticky.3.i29, 0
  %conv59.i31 = zext i1 %cmp57.i30 to i64
  %or60.i32 = or i64 %a3.3.i28, %conv59.i31
  store i64 %or60.i32, ptr %frac_lo.i17, align 8
  store i64 %a2.3.i27, ptr %frac_lm.i16, align 8
  store i64 %a1.3.i26, ptr %frac_hm.i15, align 8
  store i64 %a0.3.i25, ptr %frac_hi.i14, align 8
  %18 = load i32, ptr %exp1, align 4
  store i32 %18, ptr %exp, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.else, %frac256_shrjam.exit65, %frac256_shrjam.exit
  %frac_lo.i66 = getelementptr inbounds i8, ptr %a, i64 32
  %19 = load i64, ptr %frac_lo.i66, align 8
  %frac_lo1.i = getelementptr inbounds i8, ptr %b, i64 32
  %20 = load i64, ptr %frac_lo1.i, align 8
  %21 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %19, i64 %20)
  %22 = extractvalue { i64, i1 } %21, 1
  %23 = extractvalue { i64, i1 } %21, 0
  store i64 %23, ptr %frac_lo.i66, align 8
  %frac_lm.i67 = getelementptr inbounds i8, ptr %a, i64 24
  %24 = load i64, ptr %frac_lm.i67, align 8
  %frac_lm3.i = getelementptr inbounds i8, ptr %b, i64 24
  %25 = load i64, ptr %frac_lm3.i, align 8
  %conv.i10.i = zext i1 %22 to i64
  %26 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %24, i64 %25)
  %27 = extractvalue { i64, i1 } %26, 1
  %28 = extractvalue { i64, i1 } %26, 0
  %29 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %28, i64 %conv.i10.i)
  %30 = extractvalue { i64, i1 } %29, 1
  %31 = extractvalue { i64, i1 } %29, 0
  %32 = or i1 %27, %30
  store i64 %31, ptr %frac_lm.i67, align 8
  %frac_hm.i68 = getelementptr inbounds i8, ptr %a, i64 16
  %33 = load i64, ptr %frac_hm.i68, align 8
  %frac_hm6.i = getelementptr inbounds i8, ptr %b, i64 16
  %34 = load i64, ptr %frac_hm6.i, align 8
  %conv.i12.i = zext i1 %32 to i64
  %35 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %33, i64 %34)
  %36 = extractvalue { i64, i1 } %35, 1
  %37 = extractvalue { i64, i1 } %35, 0
  %38 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %37, i64 %conv.i12.i)
  %39 = extractvalue { i64, i1 } %38, 1
  %40 = extractvalue { i64, i1 } %38, 0
  %41 = or i1 %36, %39
  store i64 %40, ptr %frac_hm.i68, align 8
  %frac_hi.i69 = getelementptr inbounds i8, ptr %a, i64 8
  %42 = load i64, ptr %frac_hi.i69, align 8
  %frac_hi9.i = getelementptr inbounds i8, ptr %b, i64 8
  %43 = load i64, ptr %frac_hi9.i, align 8
  %conv.i14.i = zext i1 %41 to i64
  %44 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %42, i64 %43)
  %45 = extractvalue { i64, i1 } %44, 1
  %46 = extractvalue { i64, i1 } %44, 0
  %47 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %46, i64 %conv.i14.i)
  %48 = extractvalue { i64, i1 } %47, 1
  %49 = extractvalue { i64, i1 } %47, 0
  %50 = or i1 %45, %48
  store i64 %49, ptr %frac_hi.i69, align 8
  br i1 %50, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end7
  %51 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %23, i32 1, i64 0) #15, !srcloc !6
  %52 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %31, i32 1, i64 %23) #15, !srcloc !6
  %53 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %40, i32 1, i64 %31) #15, !srcloc !6
  %54 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %49, i32 1, i64 %40) #15, !srcloc !6
  %shr.i83 = lshr i64 %49, 1
  %cmp57.i89 = icmp ne i64 %51, 0
  %conv59.i90 = zext i1 %cmp57.i89 to i64
  %or60.i91 = or i64 %52, %conv59.i90
  store i64 %or60.i91, ptr %frac_lo.i66, align 8
  store i64 %53, ptr %frac_lm.i67, align 8
  store i64 %54, ptr %frac_hm.i68, align 8
  %or = or disjoint i64 %shr.i83, -9223372036854775808
  store i64 %or, ptr %frac_hi.i69, align 8
  %55 = load i32, ptr %exp, align 4
  %add = add i32 %55, 1
  store i32 %add, ptr %exp, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end7
  ret void
}

; Function Attrs: nounwind sspstrong memory(argmem: readwrite) uwtable
define internal fastcc zeroext i1 @parts256_sub_normal(ptr nocapture noundef %a, ptr nocapture noundef %b) unnamed_addr #11 {
entry:
  %exp = getelementptr inbounds i8, ptr %a, i64 4
  %0 = load i32, ptr %exp, align 4
  %exp1 = getelementptr inbounds i8, ptr %b, i64 4
  %1 = load i32, ptr %exp1, align 4
  %sub = sub i32 %0, %1
  %cmp = icmp sgt i32 %sub, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %frac_hi.i = getelementptr inbounds i8, ptr %b, i64 8
  %2 = load i64, ptr %frac_hi.i, align 8
  %frac_hm.i = getelementptr inbounds i8, ptr %b, i64 16
  %3 = load i64, ptr %frac_hm.i, align 8
  %frac_lm.i = getelementptr inbounds i8, ptr %b, i64 24
  %4 = load i64, ptr %frac_lm.i, align 8
  %frac_lo.i = getelementptr inbounds i8, ptr %b, i64 32
  %5 = load i64, ptr %frac_lo.i, align 8
  %cmp2.i = icmp ult i32 %sub, 64
  br i1 %cmp2.i, label %if.end52.i, label %if.else11.i

if.else11.i:                                      ; preds = %if.then
  %cmp12.i = icmp ult i32 %sub, 256
  br i1 %cmp12.i, label %if.then20.i, label %if.else46.i

if.then20.i:                                      ; preds = %if.else11.i
  %tobool21.not.i = icmp ult i32 %sub, 128
  br i1 %tobool21.not.i, label %if.end.i, label %if.then28.i

if.then28.i:                                      ; preds = %if.then20.i
  %or.i = or i64 %5, %4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then28.i, %if.then20.i
  %a0.0.i = phi i64 [ 0, %if.then28.i ], [ %2, %if.then20.i ]
  %a1.0.i = phi i64 [ 0, %if.then28.i ], [ %3, %if.then20.i ]
  %a2.0.i = phi i64 [ %2, %if.then28.i ], [ %4, %if.then20.i ]
  %a3.0.i = phi i64 [ %3, %if.then28.i ], [ %5, %if.then20.i ]
  %sticky.0.i = phi i64 [ %or.i, %if.then28.i ], [ 0, %if.then20.i ]
  %and30.i = and i32 %sub, 64
  %tobool31.not.i = icmp eq i32 %and30.i, 0
  br i1 %tobool31.not.i, label %if.end40.i, label %if.then38.i

if.then38.i:                                      ; preds = %if.end.i
  %or39.i = or i64 %sticky.0.i, %a3.0.i
  br label %if.end40.i

if.end40.i:                                       ; preds = %if.then38.i, %if.end.i
  %a0.1.i = phi i64 [ 0, %if.then38.i ], [ %a0.0.i, %if.end.i ]
  %a1.1.i = phi i64 [ %a0.0.i, %if.then38.i ], [ %a1.0.i, %if.end.i ]
  %a2.1.i = phi i64 [ %a1.0.i, %if.then38.i ], [ %a2.0.i, %if.end.i ]
  %a3.1.i = phi i64 [ %a2.0.i, %if.then38.i ], [ %a3.0.i, %if.end.i ]
  %sticky.1.i = phi i64 [ %or39.i, %if.then38.i ], [ %sticky.0.i, %if.end.i ]
  %and41.i = and i32 %sub, 63
  %cmp42.i = icmp eq i32 %and41.i, 0
  br i1 %cmp42.i, label %frac256_shrjam.exit, label %if.end52.i

if.else46.i:                                      ; preds = %if.else11.i
  %or47.i = or i64 %5, %4
  %or48.i = or i64 %or47.i, %2
  %or49.i = or i64 %or48.i, %3
  br label %frac256_shrjam.exit

if.end52.i:                                       ; preds = %if.end40.i, %if.then
  %c.addr.0.i = phi i32 [ %sub, %if.then ], [ %and41.i, %if.end40.i ]
  %a0.2.i = phi i64 [ %2, %if.then ], [ %a0.1.i, %if.end40.i ]
  %a1.2.i = phi i64 [ %3, %if.then ], [ %a1.1.i, %if.end40.i ]
  %a2.2.i = phi i64 [ %4, %if.then ], [ %a2.1.i, %if.end40.i ]
  %a3.2.i = phi i64 [ %5, %if.then ], [ %a3.1.i, %if.end40.i ]
  %sticky.2.i = phi i64 [ 0, %if.then ], [ %sticky.1.i, %if.end40.i ]
  %6 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a3.2.i, i32 %c.addr.0.i, i64 0) #15, !srcloc !6
  %or53.i = or i64 %6, %sticky.2.i
  %7 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a2.2.i, i32 %c.addr.0.i, i64 %a3.2.i) #15, !srcloc !6
  %8 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a1.2.i, i32 %c.addr.0.i, i64 %a2.2.i) #15, !srcloc !6
  %9 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a0.2.i, i32 %c.addr.0.i, i64 %a1.2.i) #15, !srcloc !6
  %sh_prom.i = zext nneg i32 %c.addr.0.i to i64
  %shr.i = lshr i64 %a0.2.i, %sh_prom.i
  br label %frac256_shrjam.exit

frac256_shrjam.exit:                              ; preds = %if.end40.i, %if.else46.i, %if.end52.i
  %a0.3.i = phi i64 [ %shr.i, %if.end52.i ], [ %a0.1.i, %if.end40.i ], [ 0, %if.else46.i ]
  %a1.3.i = phi i64 [ %9, %if.end52.i ], [ %a1.1.i, %if.end40.i ], [ 0, %if.else46.i ]
  %a2.3.i = phi i64 [ %8, %if.end52.i ], [ %a2.1.i, %if.end40.i ], [ 0, %if.else46.i ]
  %a3.3.i = phi i64 [ %7, %if.end52.i ], [ %a3.1.i, %if.end40.i ], [ 0, %if.else46.i ]
  %sticky.3.i = phi i64 [ %or53.i, %if.end52.i ], [ %sticky.1.i, %if.end40.i ], [ %or49.i, %if.else46.i ]
  %cmp57.i = icmp ne i64 %sticky.3.i, 0
  %conv59.i = zext i1 %cmp57.i to i64
  %or60.i = or i64 %a3.3.i, %conv59.i
  store i64 %or60.i, ptr %frac_lo.i, align 8
  store i64 %a2.3.i, ptr %frac_lm.i, align 8
  store i64 %a1.3.i, ptr %frac_hm.i, align 8
  store i64 %a0.3.i, ptr %frac_hi.i, align 8
  %frac_lo.i24 = getelementptr inbounds i8, ptr %a, i64 32
  %10 = load i64, ptr %frac_lo.i24, align 8
  %11 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %10, i64 %or60.i)
  %12 = extractvalue { i64, i1 } %11, 1
  %13 = extractvalue { i64, i1 } %11, 0
  store i64 %13, ptr %frac_lo.i24, align 8
  %frac_lm.i25 = getelementptr inbounds i8, ptr %a, i64 24
  %14 = load i64, ptr %frac_lm.i25, align 8
  %15 = load i64, ptr %frac_lm.i, align 8
  %conv.i10.i = zext i1 %12 to i64
  %16 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %14, i64 %15)
  %17 = extractvalue { i64, i1 } %16, 1
  %18 = extractvalue { i64, i1 } %16, 0
  %19 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %18, i64 %conv.i10.i)
  %20 = extractvalue { i64, i1 } %19, 1
  %21 = extractvalue { i64, i1 } %19, 0
  %22 = or i1 %17, %20
  store i64 %21, ptr %frac_lm.i25, align 8
  %frac_hm.i26 = getelementptr inbounds i8, ptr %a, i64 16
  %23 = load i64, ptr %frac_hm.i26, align 8
  %24 = load i64, ptr %frac_hm.i, align 8
  %conv.i12.i = zext i1 %22 to i64
  %25 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %23, i64 %24)
  %26 = extractvalue { i64, i1 } %25, 1
  %27 = extractvalue { i64, i1 } %25, 0
  %28 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %27, i64 %conv.i12.i)
  %29 = extractvalue { i64, i1 } %28, 1
  %30 = extractvalue { i64, i1 } %28, 0
  %31 = or i1 %26, %29
  store i64 %30, ptr %frac_hm.i26, align 8
  %frac_hi.i27 = getelementptr inbounds i8, ptr %a, i64 8
  %32 = load i64, ptr %frac_hi.i27, align 8
  %33 = load i64, ptr %frac_hi.i, align 8
  %conv.i14.i.neg = sext i1 %31 to i64
  %34 = sub i64 %32, %33
  %35 = add i64 %34, %conv.i14.i.neg
  store i64 %35, ptr %frac_hi.i27, align 8
  br label %if.end19

if.else:                                          ; preds = %entry
  %cmp2 = icmp slt i32 %sub, 0
  br i1 %cmp2, label %if.then3, label %if.else9

if.then3:                                         ; preds = %if.else
  store i32 %1, ptr %exp, align 4
  %sign = getelementptr inbounds i8, ptr %a, i64 1
  %36 = load i8, ptr %sign, align 1
  %37 = and i8 %36, 1
  %frombool = xor i8 %37, 1
  store i8 %frombool, ptr %sign, align 1
  %sub7 = sub i32 0, %sub
  %frac_hi.i28 = getelementptr inbounds i8, ptr %a, i64 8
  %38 = load i64, ptr %frac_hi.i28, align 8
  %frac_hm.i29 = getelementptr inbounds i8, ptr %a, i64 16
  %39 = load i64, ptr %frac_hm.i29, align 8
  %frac_lm.i30 = getelementptr inbounds i8, ptr %a, i64 24
  %40 = load i64, ptr %frac_lm.i30, align 8
  %frac_lo.i31 = getelementptr inbounds i8, ptr %a, i64 32
  %41 = load i64, ptr %frac_lo.i31, align 8
  %cmp2.i32 = icmp slt i32 %sub7, 64
  br i1 %cmp2.i32, label %if.end52.i69, label %if.else11.i33

if.else11.i33:                                    ; preds = %if.then3
  %cmp12.i34 = icmp ult i32 %sub7, 256
  br i1 %cmp12.i34, label %if.then20.i47, label %if.else46.i35

if.then20.i47:                                    ; preds = %if.else11.i33
  %tobool21.not.i48 = icmp ult i32 %sub7, 128
  br i1 %tobool21.not.i48, label %if.end.i51, label %if.then28.i49

if.then28.i49:                                    ; preds = %if.then20.i47
  %or.i50 = or i64 %41, %40
  br label %if.end.i51

if.end.i51:                                       ; preds = %if.then28.i49, %if.then20.i47
  %a0.0.i52 = phi i64 [ 0, %if.then28.i49 ], [ %38, %if.then20.i47 ]
  %a1.0.i53 = phi i64 [ 0, %if.then28.i49 ], [ %39, %if.then20.i47 ]
  %a2.0.i54 = phi i64 [ %38, %if.then28.i49 ], [ %40, %if.then20.i47 ]
  %a3.0.i55 = phi i64 [ %39, %if.then28.i49 ], [ %41, %if.then20.i47 ]
  %sticky.0.i56 = phi i64 [ %or.i50, %if.then28.i49 ], [ 0, %if.then20.i47 ]
  %and30.i57 = and i32 %sub7, 64
  %tobool31.not.i58 = icmp eq i32 %and30.i57, 0
  br i1 %tobool31.not.i58, label %if.end40.i61, label %if.then38.i59

if.then38.i59:                                    ; preds = %if.end.i51
  %or39.i60 = or i64 %sticky.0.i56, %a3.0.i55
  br label %if.end40.i61

if.end40.i61:                                     ; preds = %if.then38.i59, %if.end.i51
  %a0.1.i62 = phi i64 [ 0, %if.then38.i59 ], [ %a0.0.i52, %if.end.i51 ]
  %a1.1.i63 = phi i64 [ %a0.0.i52, %if.then38.i59 ], [ %a1.0.i53, %if.end.i51 ]
  %a2.1.i64 = phi i64 [ %a1.0.i53, %if.then38.i59 ], [ %a2.0.i54, %if.end.i51 ]
  %a3.1.i65 = phi i64 [ %a2.0.i54, %if.then38.i59 ], [ %a3.0.i55, %if.end.i51 ]
  %sticky.1.i66 = phi i64 [ %or39.i60, %if.then38.i59 ], [ %sticky.0.i56, %if.end.i51 ]
  %and41.i67 = and i32 %sub7, 63
  %cmp42.i68 = icmp eq i32 %and41.i67, 0
  br i1 %cmp42.i68, label %frac256_shrjam.exit79, label %if.end52.i69

if.else46.i35:                                    ; preds = %if.else11.i33
  %or47.i36 = or i64 %41, %40
  %or48.i37 = or i64 %or47.i36, %38
  %or49.i38 = or i64 %or48.i37, %39
  br label %frac256_shrjam.exit79

if.end52.i69:                                     ; preds = %if.end40.i61, %if.then3
  %c.addr.0.i70 = phi i32 [ %sub7, %if.then3 ], [ %and41.i67, %if.end40.i61 ]
  %a0.2.i71 = phi i64 [ %38, %if.then3 ], [ %a0.1.i62, %if.end40.i61 ]
  %a1.2.i72 = phi i64 [ %39, %if.then3 ], [ %a1.1.i63, %if.end40.i61 ]
  %a2.2.i73 = phi i64 [ %40, %if.then3 ], [ %a2.1.i64, %if.end40.i61 ]
  %a3.2.i74 = phi i64 [ %41, %if.then3 ], [ %a3.1.i65, %if.end40.i61 ]
  %sticky.2.i75 = phi i64 [ 0, %if.then3 ], [ %sticky.1.i66, %if.end40.i61 ]
  %42 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a3.2.i74, i32 %c.addr.0.i70, i64 0) #15, !srcloc !6
  %or53.i76 = or i64 %42, %sticky.2.i75
  %43 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a2.2.i73, i32 %c.addr.0.i70, i64 %a3.2.i74) #15, !srcloc !6
  %44 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a1.2.i72, i32 %c.addr.0.i70, i64 %a2.2.i73) #15, !srcloc !6
  %45 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a0.2.i71, i32 %c.addr.0.i70, i64 %a1.2.i72) #15, !srcloc !6
  %sh_prom.i77 = zext nneg i32 %c.addr.0.i70 to i64
  %shr.i78 = lshr i64 %a0.2.i71, %sh_prom.i77
  br label %frac256_shrjam.exit79

frac256_shrjam.exit79:                            ; preds = %if.end40.i61, %if.else46.i35, %if.end52.i69
  %a0.3.i39 = phi i64 [ %shr.i78, %if.end52.i69 ], [ %a0.1.i62, %if.end40.i61 ], [ 0, %if.else46.i35 ]
  %a1.3.i40 = phi i64 [ %45, %if.end52.i69 ], [ %a1.1.i63, %if.end40.i61 ], [ 0, %if.else46.i35 ]
  %a2.3.i41 = phi i64 [ %44, %if.end52.i69 ], [ %a2.1.i64, %if.end40.i61 ], [ 0, %if.else46.i35 ]
  %a3.3.i42 = phi i64 [ %43, %if.end52.i69 ], [ %a3.1.i65, %if.end40.i61 ], [ 0, %if.else46.i35 ]
  %sticky.3.i43 = phi i64 [ %or53.i76, %if.end52.i69 ], [ %sticky.1.i66, %if.end40.i61 ], [ %or49.i38, %if.else46.i35 ]
  %cmp57.i44 = icmp ne i64 %sticky.3.i43, 0
  %conv59.i45 = zext i1 %cmp57.i44 to i64
  %or60.i46 = or i64 %a3.3.i42, %conv59.i45
  store i64 %or60.i46, ptr %frac_lo.i31, align 8
  store i64 %a2.3.i41, ptr %frac_lm.i30, align 8
  store i64 %a1.3.i40, ptr %frac_hm.i29, align 8
  store i64 %a0.3.i39, ptr %frac_hi.i28, align 8
  %frac_lo.i80 = getelementptr inbounds i8, ptr %b, i64 32
  %46 = load i64, ptr %frac_lo.i80, align 8
  %47 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %46, i64 %or60.i46)
  %48 = extractvalue { i64, i1 } %47, 1
  %49 = extractvalue { i64, i1 } %47, 0
  store i64 %49, ptr %frac_lo.i31, align 8
  %frac_lm.i83 = getelementptr inbounds i8, ptr %b, i64 24
  %50 = load i64, ptr %frac_lm.i83, align 8
  %conv.i10.i85 = zext i1 %48 to i64
  %51 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %50, i64 %a2.3.i41)
  %52 = extractvalue { i64, i1 } %51, 1
  %53 = extractvalue { i64, i1 } %51, 0
  %54 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %53, i64 %conv.i10.i85)
  %55 = extractvalue { i64, i1 } %54, 1
  %56 = extractvalue { i64, i1 } %54, 0
  %57 = or i1 %52, %55
  store i64 %56, ptr %frac_lm.i30, align 8
  %frac_hm.i87 = getelementptr inbounds i8, ptr %b, i64 16
  %58 = load i64, ptr %frac_hm.i87, align 8
  %conv.i12.i89 = zext i1 %57 to i64
  %59 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %58, i64 %a1.3.i40)
  %60 = extractvalue { i64, i1 } %59, 1
  %61 = extractvalue { i64, i1 } %59, 0
  %62 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %61, i64 %conv.i12.i89)
  %63 = extractvalue { i64, i1 } %62, 1
  %64 = extractvalue { i64, i1 } %62, 0
  %65 = or i1 %60, %63
  store i64 %64, ptr %frac_hm.i29, align 8
  %frac_hi.i91 = getelementptr inbounds i8, ptr %b, i64 8
  %66 = load i64, ptr %frac_hi.i91, align 8
  %conv.i14.i93.neg = sext i1 %65 to i64
  %67 = sub i64 %66, %a0.3.i39
  %68 = add i64 %67, %conv.i14.i93.neg
  store i64 %68, ptr %frac_hi.i28, align 8
  br label %if.end19

if.else9:                                         ; preds = %if.else
  %frac_lo.i95 = getelementptr inbounds i8, ptr %a, i64 32
  %69 = load i64, ptr %frac_lo.i95, align 8
  %frac_lo1.i96 = getelementptr inbounds i8, ptr %b, i64 32
  %70 = load i64, ptr %frac_lo1.i96, align 8
  %71 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %69, i64 %70)
  %72 = extractvalue { i64, i1 } %71, 1
  %73 = extractvalue { i64, i1 } %71, 0
  store i64 %73, ptr %frac_lo.i95, align 8
  %frac_lm.i98 = getelementptr inbounds i8, ptr %a, i64 24
  %74 = load i64, ptr %frac_lm.i98, align 8
  %frac_lm3.i99 = getelementptr inbounds i8, ptr %b, i64 24
  %75 = load i64, ptr %frac_lm3.i99, align 8
  %conv.i10.i100 = zext i1 %72 to i64
  %76 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %74, i64 %75)
  %77 = extractvalue { i64, i1 } %76, 1
  %78 = extractvalue { i64, i1 } %76, 0
  %79 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %78, i64 %conv.i10.i100)
  %80 = extractvalue { i64, i1 } %79, 1
  %81 = extractvalue { i64, i1 } %79, 0
  %82 = or i1 %77, %80
  store i64 %81, ptr %frac_lm.i98, align 8
  %frac_hm.i102 = getelementptr inbounds i8, ptr %a, i64 16
  %83 = load i64, ptr %frac_hm.i102, align 8
  %frac_hm6.i103 = getelementptr inbounds i8, ptr %b, i64 16
  %84 = load i64, ptr %frac_hm6.i103, align 8
  %conv.i12.i104 = zext i1 %82 to i64
  %85 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %83, i64 %84)
  %86 = extractvalue { i64, i1 } %85, 1
  %87 = extractvalue { i64, i1 } %85, 0
  %88 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %87, i64 %conv.i12.i104)
  %89 = extractvalue { i64, i1 } %88, 1
  %90 = extractvalue { i64, i1 } %88, 0
  %91 = or i1 %86, %89
  store i64 %90, ptr %frac_hm.i102, align 8
  %frac_hi.i106 = getelementptr inbounds i8, ptr %a, i64 8
  %92 = load i64, ptr %frac_hi.i106, align 8
  %frac_hi9.i107 = getelementptr inbounds i8, ptr %b, i64 8
  %93 = load i64, ptr %frac_hi9.i107, align 8
  %conv.i14.i108 = zext i1 %91 to i64
  %94 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %92, i64 %93)
  %95 = extractvalue { i64, i1 } %94, 1
  %96 = extractvalue { i64, i1 } %94, 0
  %97 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %96, i64 %conv.i14.i108)
  %98 = extractvalue { i64, i1 } %97, 1
  %99 = extractvalue { i64, i1 } %97, 0
  %100 = or i1 %95, %98
  store i64 %99, ptr %frac_hi.i106, align 8
  br i1 %100, label %if.then11, label %if.end19

if.then11:                                        ; preds = %if.else9
  %101 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 0, i64 %73)
  %102 = extractvalue { i64, i1 } %101, 1
  %103 = extractvalue { i64, i1 } %101, 0
  store i64 %103, ptr %frac_lo.i95, align 8
  %conv.i8.i = zext i1 %102 to i64
  %104 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 0, i64 %81)
  %105 = extractvalue { i64, i1 } %104, 1
  %106 = extractvalue { i64, i1 } %104, 0
  %107 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %106, i64 %conv.i8.i)
  %108 = extractvalue { i64, i1 } %107, 1
  %109 = extractvalue { i64, i1 } %107, 0
  %110 = or i1 %105, %108
  store i64 %109, ptr %frac_lm.i98, align 8
  %conv.i10.i113 = zext i1 %110 to i64
  %111 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 0, i64 %90)
  %112 = extractvalue { i64, i1 } %111, 1
  %113 = extractvalue { i64, i1 } %111, 0
  %114 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %113, i64 %conv.i10.i113)
  %115 = extractvalue { i64, i1 } %114, 1
  %116 = extractvalue { i64, i1 } %114, 0
  %117 = or i1 %112, %115
  store i64 %116, ptr %frac_hm.i102, align 8
  %conv.i12.neg.i = sext i1 %117 to i64
  %118 = sub i64 %conv.i12.neg.i, %99
  store i64 %118, ptr %frac_hi.i106, align 8
  %sign12 = getelementptr inbounds i8, ptr %a, i64 1
  %119 = load i8, ptr %sign12, align 1
  %120 = and i8 %119, 1
  %frombool17 = xor i8 %120, 1
  store i8 %frombool17, ptr %sign12, align 1
  br label %if.end19

if.end19:                                         ; preds = %frac256_shrjam.exit79, %if.then11, %if.else9, %frac256_shrjam.exit
  %121 = phi i64 [ %49, %frac256_shrjam.exit79 ], [ %103, %if.then11 ], [ %73, %if.else9 ], [ %13, %frac256_shrjam.exit ]
  %122 = phi i64 [ %56, %frac256_shrjam.exit79 ], [ %109, %if.then11 ], [ %81, %if.else9 ], [ %21, %frac256_shrjam.exit ]
  %123 = phi i64 [ %64, %frac256_shrjam.exit79 ], [ %116, %if.then11 ], [ %90, %if.else9 ], [ %30, %frac256_shrjam.exit ]
  %124 = phi i64 [ %68, %frac256_shrjam.exit79 ], [ %118, %if.then11 ], [ %99, %if.else9 ], [ %35, %frac256_shrjam.exit ]
  %frac_hi.i115 = getelementptr inbounds i8, ptr %a, i64 8
  %frac_hm.i116 = getelementptr inbounds i8, ptr %a, i64 16
  %frac_lm.i117 = getelementptr inbounds i8, ptr %a, i64 24
  %frac_lo.i118 = getelementptr inbounds i8, ptr %a, i64 32
  %tobool.not.i = icmp eq i64 %124, 0
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.end19
  %125 = tail call i64 @llvm.ctlz.i64(i64 %124, i1 true), !range !5
  %cast.i.i = trunc i64 %125 to i32
  %cmp.i = icmp eq i32 %cast.i.i, 0
  br i1 %cmp.i, label %if.then26, label %if.end22.i

if.else.i:                                        ; preds = %if.end19
  %tobool5.not.i = icmp eq i64 %123, 0
  br i1 %tobool5.not.i, label %if.else7.i, label %if.end16.i

if.else7.i:                                       ; preds = %if.else.i
  %tobool8.not.i = icmp eq i64 %122, 0
  br i1 %tobool8.not.i, label %if.else10.i, label %if.end16.i

if.else10.i:                                      ; preds = %if.else7.i
  %tobool11.not.i = icmp eq i64 %121, 0
  br i1 %tobool11.not.i, label %if.end29, label %if.end16.i

if.end16.i:                                       ; preds = %if.else10.i, %if.else7.i, %if.else.i
  %a0.0.i128 = phi i64 [ %123, %if.else.i ], [ %122, %if.else7.i ], [ %121, %if.else10.i ]
  %a1.0.i129 = phi i64 [ %122, %if.else.i ], [ %121, %if.else7.i ], [ 0, %if.else10.i ]
  %a2.0.i130 = phi i64 [ %121, %if.else.i ], [ 0, %if.else7.i ], [ 0, %if.else10.i ]
  %ret.0.i = phi i32 [ 64, %if.else.i ], [ 128, %if.else7.i ], [ 192, %if.else10.i ]
  %126 = tail call i64 @llvm.ctlz.i64(i64 %a0.0.i128, i1 true), !range !5
  %cast.i38.i = trunc i64 %126 to i32
  %cmp18.i = icmp eq i32 %cast.i38.i, 0
  br i1 %cmp18.i, label %frac256_normalize.exit.thread136, label %if.end21.i

if.end21.i:                                       ; preds = %if.end16.i
  %add.i = or disjoint i32 %ret.0.i, %cast.i38.i
  br label %if.end22.i

if.end22.i:                                       ; preds = %if.end21.i, %if.then.i
  %a0.1.i119 = phi i64 [ %a0.0.i128, %if.end21.i ], [ %124, %if.then.i ]
  %a1.1.i120 = phi i64 [ %a1.0.i129, %if.end21.i ], [ %123, %if.then.i ]
  %a2.1.i121 = phi i64 [ %a2.0.i130, %if.end21.i ], [ %122, %if.then.i ]
  %a3.1.i122 = phi i64 [ 0, %if.end21.i ], [ %121, %if.then.i ]
  %ret.1.i = phi i32 [ %add.i, %if.end21.i ], [ %cast.i.i, %if.then.i ]
  %shl.0.i = phi i32 [ %cast.i38.i, %if.end21.i ], [ %cast.i.i, %if.then.i ]
  %127 = tail call i64 asm "shld ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a1.1.i120, i32 %shl.0.i, i64 %a0.1.i119) #15, !srcloc !16
  %128 = tail call i64 asm "shld ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a2.1.i121, i32 %shl.0.i, i64 %a1.1.i120) #15, !srcloc !16
  %129 = tail call i64 asm "shld ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a3.1.i122, i32 %shl.0.i, i64 %a2.1.i121) #15, !srcloc !16
  %sh_prom.i123 = zext nneg i32 %shl.0.i to i64
  %shl26.i = shl i64 %a3.1.i122, %sh_prom.i123
  br label %frac256_normalize.exit.thread136

frac256_normalize.exit.thread136:                 ; preds = %if.end22.i, %if.end16.i
  %a0.2.i124.ph = phi i64 [ %a0.0.i128, %if.end16.i ], [ %127, %if.end22.i ]
  %a1.2.i125.ph = phi i64 [ %a1.0.i129, %if.end16.i ], [ %128, %if.end22.i ]
  %a2.2.i126.ph = phi i64 [ %a2.0.i130, %if.end16.i ], [ %129, %if.end22.i ]
  %a3.2.i127.ph = phi i64 [ 0, %if.end16.i ], [ %shl26.i, %if.end22.i ]
  %ret.2.i.ph = phi i32 [ %ret.0.i, %if.end16.i ], [ %ret.1.i, %if.end22.i ]
  store i64 %a0.2.i124.ph, ptr %frac_hi.i115, align 8
  store i64 %a1.2.i125.ph, ptr %frac_hm.i116, align 8
  store i64 %a2.2.i126.ph, ptr %frac_lm.i117, align 8
  store i64 %a3.2.i127.ph, ptr %frac_lo.i118, align 8
  br label %if.then26

if.then26:                                        ; preds = %if.then.i, %frac256_normalize.exit.thread136
  %retval.0.i133 = phi i32 [ %ret.2.i.ph, %frac256_normalize.exit.thread136 ], [ 0, %if.then.i ]
  %130 = load i32, ptr %exp, align 4
  %sub28 = sub i32 %130, %retval.0.i133
  store i32 %sub28, ptr %exp, align 4
  br label %return

if.end29:                                         ; preds = %if.else10.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %frac_hi.i115, i8 0, i64 32, i1 false)
  store i8 1, ptr %a, align 8
  br label %return

return:                                           ; preds = %if.end29, %if.then26
  %cmp21134 = phi i1 [ false, %if.end29 ], [ true, %if.then26 ]
  ret i1 %cmp21134
}

; Function Attrs: nounwind sspstrong memory(argmem: readwrite) uwtable
define internal fastcc zeroext i1 @frac128_div(ptr nocapture noundef %a, i64 %b.8.val, i64 %b.16.val) unnamed_addr #11 {
entry:
  %frac_hi = getelementptr inbounds i8, ptr %a, i64 8
  %0 = load i64, ptr %frac_hi, align 8
  %frac_lo = getelementptr inbounds i8, ptr %a, i64 16
  %1 = load i64, ptr %frac_lo, align 8
  %cmp.i = icmp ult i64 %0, %b.8.val
  br i1 %cmp.i, label %if.end, label %lt128.exit

lt128.exit:                                       ; preds = %entry
  %cmp1.i = icmp eq i64 %0, %b.8.val
  %cmp2.i = icmp ult i64 %1, %b.16.val
  %2 = and i1 %cmp1.i, %cmp2.i
  br i1 %2, label %if.end.estimateDiv128To64.exit_crit_edge, label %if.then

if.then:                                          ; preds = %lt128.exit
  %3 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %0, i32 1, i64 %1) #15, !srcloc !6
  %shr = lshr i64 %0, 1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %a0.0 = phi i64 [ %shr, %if.then ], [ %0, %entry ]
  %a1.0 = phi i64 [ %3, %if.then ], [ %1, %entry ]
  %cmp.not.i = icmp ult i64 %a0.0, %b.8.val
  br i1 %cmp.not.i, label %if.end.i, label %if.end.estimateDiv128To64.exit_crit_edge

if.end.estimateDiv128To64.exit_crit_edge:         ; preds = %lt128.exit, %if.end
  %a1.048 = phi i64 [ %a1.0, %if.end ], [ %1, %lt128.exit ]
  %a0.046 = phi i64 [ %a0.0, %if.end ], [ %b.8.val, %lt128.exit ]
  %4 = phi i1 [ %cmp.i, %if.end ], [ true, %lt128.exit ]
  %.pre = zext i64 %b.8.val to i128
  br label %estimateDiv128To64.exit

if.end.i:                                         ; preds = %if.end
  %shr.i = lshr i64 %b.8.val, 32
  %shl.i = and i64 %b.8.val, -4294967296
  %cmp1.not.i = icmp ugt i64 %shl.i, %a0.0
  br i1 %cmp1.not.i, label %cond.false.i, label %cond.end.i

cond.false.i:                                     ; preds = %if.end.i
  %div.i = udiv i64 %a0.0, %shr.i
  %shl2.i = shl i64 %div.i, 32
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.false.i, %if.end.i
  %cond.i = phi i64 [ %shl2.i, %cond.false.i ], [ -4294967296, %if.end.i ]
  %conv.i.i.i = zext i64 %b.8.val to i128
  %conv1.i.i.i = zext i64 %cond.i to i128
  %mul.i.i.i = mul nuw i128 %conv1.i.i.i, %conv.i.i.i
  %conv2.i.i.i = trunc i128 %mul.i.i.i to i64
  %shr.i.i.i = lshr i128 %mul.i.i.i, 64
  %conv3.i.i.i = trunc i128 %shr.i.i.i to i64
  %5 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.0, i64 %conv2.i.i.i)
  %6 = extractvalue { i64, i1 } %5, 1
  %conv.i1.neg.i.i = sext i1 %6 to i64
  %7 = sub i64 %a0.0, %conv3.i.i.i
  %8 = add i64 %7, %conv.i1.neg.i.i
  %rem1.015.i = extractvalue { i64, i1 } %5, 0
  %cmp316.i = icmp slt i64 %8, 0
  br i1 %cmp316.i, label %while.body.lr.ph.i, label %while.end.i

while.body.lr.ph.i:                               ; preds = %cond.end.i
  %shl4.i = shl i64 %b.8.val, 32
  br label %while.body.i

while.body.i:                                     ; preds = %while.body.i, %while.body.lr.ph.i
  %rem1.019.i = phi i64 [ %rem1.015.i, %while.body.lr.ph.i ], [ %rem1.0.i, %while.body.i ]
  %z.018.i = phi i64 [ %cond.i, %while.body.lr.ph.i ], [ %sub.i, %while.body.i ]
  %rem0.017.i = phi i64 [ %8, %while.body.lr.ph.i ], [ %12, %while.body.i ]
  %sub.i = add i64 %z.018.i, -4294967296
  %9 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %rem1.019.i, i64 %shl4.i)
  %10 = extractvalue { i64, i1 } %9, 1
  %conv.i1.i.i = zext i1 %10 to i64
  %11 = add nsw i64 %rem0.017.i, %shr.i
  %12 = add nsw i64 %11, %conv.i1.i.i
  %rem1.0.i = extractvalue { i64, i1 } %9, 0
  %cmp3.i = icmp slt i64 %12, 0
  br i1 %cmp3.i, label %while.body.i, label %while.end.i, !llvm.loop !8

while.end.i:                                      ; preds = %while.body.i, %cond.end.i
  %rem0.0.lcssa.i = phi i64 [ %8, %cond.end.i ], [ %12, %while.body.i ]
  %z.0.lcssa.i = phi i64 [ %cond.i, %cond.end.i ], [ %sub.i, %while.body.i ]
  %rem1.0.lcssa.i = phi i64 [ %rem1.015.i, %cond.end.i ], [ %rem1.0.i, %while.body.i ]
  %or.i = tail call i64 @llvm.fshl.i64(i64 %rem0.0.lcssa.i, i64 %rem1.0.lcssa.i, i64 32)
  %cmp8.not.i = icmp ugt i64 %shl.i, %or.i
  br i1 %cmp8.not.i, label %cond.false10.i, label %cond.end12.i

cond.false10.i:                                   ; preds = %while.end.i
  %div11.i = udiv i64 %or.i, %shr.i
  br label %cond.end12.i

cond.end12.i:                                     ; preds = %cond.false10.i, %while.end.i
  %cond13.i = phi i64 [ %div11.i, %cond.false10.i ], [ 4294967295, %while.end.i ]
  %or14.i = or i64 %cond13.i, %z.0.lcssa.i
  br label %estimateDiv128To64.exit

estimateDiv128To64.exit:                          ; preds = %if.end.estimateDiv128To64.exit_crit_edge, %cond.end12.i
  %a1.047 = phi i64 [ %a1.048, %if.end.estimateDiv128To64.exit_crit_edge ], [ %a1.0, %cond.end12.i ]
  %a0.045 = phi i64 [ %a0.046, %if.end.estimateDiv128To64.exit_crit_edge ], [ %a0.0, %cond.end12.i ]
  %13 = phi i1 [ %4, %if.end.estimateDiv128To64.exit_crit_edge ], [ %cmp.i, %cond.end12.i ]
  %conv.i.i2.i.pre-phi = phi i128 [ %.pre, %if.end.estimateDiv128To64.exit_crit_edge ], [ %conv.i.i.i, %cond.end12.i ]
  %retval.0.i = phi i64 [ -1, %if.end.estimateDiv128To64.exit_crit_edge ], [ %or14.i, %cond.end12.i ]
  %conv.i.i.i29 = zext i64 %b.16.val to i128
  %conv1.i.i.i30 = zext i64 %retval.0.i to i128
  %mul.i.i.i31 = mul nuw i128 %conv1.i.i.i30, %conv.i.i.i29
  %conv2.i.i.i32 = trunc i128 %mul.i.i.i31 to i64
  %shr.i.i.i33 = lshr i128 %mul.i.i.i31, 64
  %conv3.i.i.i34 = trunc i128 %shr.i.i.i33 to i64
  %mul.i.i4.i = mul nuw i128 %conv.i.i2.i.pre-phi, %conv1.i.i.i30
  %conv2.i.i5.i = trunc i128 %mul.i.i4.i to i64
  %shr.i.i6.i = lshr i128 %mul.i.i4.i, 64
  %conv3.i.i7.i = trunc i128 %shr.i.i6.i to i64
  %14 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i5.i, i64 %conv3.i.i.i34)
  %15 = extractvalue { i64, i1 } %14, 1
  %16 = extractvalue { i64, i1 } %14, 0
  %conv.i1.i.i35.neg35 = sext i1 %15 to i64
  %17 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 0, i64 %conv2.i.i.i32)
  %18 = extractvalue { i64, i1 } %17, 1
  %conv.i1.i = zext i1 %18 to i64
  %19 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %a1.047, i64 %16)
  %20 = extractvalue { i64, i1 } %19, 1
  %21 = extractvalue { i64, i1 } %19, 0
  %22 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %21, i64 %conv.i1.i)
  %23 = extractvalue { i64, i1 } %22, 1
  %24 = or i1 %20, %23
  %conv.i3.neg.i = sext i1 %24 to i64
  %.neg = sub i64 %a0.045, %conv3.i.i7.i
  %25 = add i64 %.neg, %conv.i1.i.i35.neg35
  %26 = add i64 %25, %conv.i3.neg.i
  %r1.016 = extractvalue { i64, i1 } %22, 0
  %r2.017 = extractvalue { i64, i1 } %17, 0
  %cmp.not18 = icmp eq i64 %26, 0
  br i1 %cmp.not18, label %while.end, label %while.body

while.body:                                       ; preds = %estimateDiv128To64.exit, %while.body
  %r2.022 = phi i64 [ %r2.0, %while.body ], [ %r2.017, %estimateDiv128To64.exit ]
  %r1.021 = phi i64 [ %r1.0, %while.body ], [ %r1.016, %estimateDiv128To64.exit ]
  %q0.020 = phi i64 [ %dec, %while.body ], [ %retval.0.i, %estimateDiv128To64.exit ]
  %r0.019 = phi i64 [ %35, %while.body ], [ %26, %estimateDiv128To64.exit ]
  %dec = add i64 %q0.020, -1
  %27 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %r2.022, i64 %b.16.val)
  %28 = extractvalue { i64, i1 } %27, 1
  %conv.i1.i36 = zext i1 %28 to i64
  %29 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %r1.021, i64 %b.8.val)
  %30 = extractvalue { i64, i1 } %29, 1
  %31 = extractvalue { i64, i1 } %29, 0
  %32 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %31, i64 %conv.i1.i36)
  %33 = extractvalue { i64, i1 } %32, 1
  %34 = or i1 %30, %33
  %conv.i3.i = zext i1 %34 to i64
  %35 = add i64 %r0.019, %conv.i3.i
  %r1.0 = extractvalue { i64, i1 } %32, 0
  %r2.0 = extractvalue { i64, i1 } %27, 0
  %cmp.not = icmp eq i64 %35, 0
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !18

while.end:                                        ; preds = %while.body, %estimateDiv128To64.exit
  %q0.0.lcssa = phi i64 [ %retval.0.i, %estimateDiv128To64.exit ], [ %dec, %while.body ]
  %r1.0.lcssa = phi i64 [ %r1.016, %estimateDiv128To64.exit ], [ %r1.0, %while.body ]
  %r2.0.lcssa = phi i64 [ %r2.017, %estimateDiv128To64.exit ], [ %r2.0, %while.body ]
  %cmp.not.i37 = icmp ult i64 %r1.0.lcssa, %b.8.val
  br i1 %cmp.not.i37, label %if.end.i39, label %estimateDiv128To64.exit78

if.end.i39:                                       ; preds = %while.end
  %shr.i40 = lshr i64 %b.8.val, 32
  %shl.i41 = and i64 %b.8.val, -4294967296
  %cmp1.not.i42 = icmp ugt i64 %shl.i41, %r1.0.lcssa
  br i1 %cmp1.not.i42, label %cond.false.i75, label %cond.end.i43

cond.false.i75:                                   ; preds = %if.end.i39
  %div.i76 = udiv i64 %r1.0.lcssa, %shr.i40
  %shl2.i77 = shl i64 %div.i76, 32
  br label %cond.end.i43

cond.end.i43:                                     ; preds = %cond.false.i75, %if.end.i39
  %cond.i44 = phi i64 [ %shl2.i77, %cond.false.i75 ], [ -4294967296, %if.end.i39 ]
  %conv1.i.i.i46 = zext i64 %cond.i44 to i128
  %mul.i.i.i47 = mul nuw i128 %conv.i.i2.i.pre-phi, %conv1.i.i.i46
  %conv2.i.i.i48 = trunc i128 %mul.i.i.i47 to i64
  %shr.i.i.i49 = lshr i128 %mul.i.i.i47, 64
  %conv3.i.i.i50 = trunc i128 %shr.i.i.i49 to i64
  %36 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %r2.0.lcssa, i64 %conv2.i.i.i48)
  %37 = extractvalue { i64, i1 } %36, 1
  %conv.i1.neg.i.i51 = sext i1 %37 to i64
  %38 = sub i64 %r1.0.lcssa, %conv3.i.i.i50
  %39 = add i64 %38, %conv.i1.neg.i.i51
  %rem1.015.i52 = extractvalue { i64, i1 } %36, 0
  %cmp316.i53 = icmp slt i64 %39, 0
  br i1 %cmp316.i53, label %while.body.lr.ph.i65, label %while.end.i54

while.body.lr.ph.i65:                             ; preds = %cond.end.i43
  %shl4.i66 = shl i64 %b.8.val, 32
  br label %while.body.i67

while.body.i67:                                   ; preds = %while.body.i67, %while.body.lr.ph.i65
  %rem1.019.i68 = phi i64 [ %rem1.015.i52, %while.body.lr.ph.i65 ], [ %rem1.0.i73, %while.body.i67 ]
  %z.018.i69 = phi i64 [ %cond.i44, %while.body.lr.ph.i65 ], [ %sub.i71, %while.body.i67 ]
  %rem0.017.i70 = phi i64 [ %39, %while.body.lr.ph.i65 ], [ %43, %while.body.i67 ]
  %sub.i71 = add i64 %z.018.i69, -4294967296
  %40 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %rem1.019.i68, i64 %shl4.i66)
  %41 = extractvalue { i64, i1 } %40, 1
  %conv.i1.i.i72 = zext i1 %41 to i64
  %42 = add nsw i64 %rem0.017.i70, %shr.i40
  %43 = add nsw i64 %42, %conv.i1.i.i72
  %rem1.0.i73 = extractvalue { i64, i1 } %40, 0
  %cmp3.i74 = icmp slt i64 %43, 0
  br i1 %cmp3.i74, label %while.body.i67, label %while.end.i54, !llvm.loop !8

while.end.i54:                                    ; preds = %while.body.i67, %cond.end.i43
  %rem0.0.lcssa.i55 = phi i64 [ %39, %cond.end.i43 ], [ %43, %while.body.i67 ]
  %z.0.lcssa.i56 = phi i64 [ %cond.i44, %cond.end.i43 ], [ %sub.i71, %while.body.i67 ]
  %rem1.0.lcssa.i57 = phi i64 [ %rem1.015.i52, %cond.end.i43 ], [ %rem1.0.i73, %while.body.i67 ]
  %or.i58 = tail call i64 @llvm.fshl.i64(i64 %rem0.0.lcssa.i55, i64 %rem1.0.lcssa.i57, i64 32)
  %cmp8.not.i59 = icmp ugt i64 %shl.i41, %or.i58
  br i1 %cmp8.not.i59, label %cond.false10.i63, label %cond.end12.i60

cond.false10.i63:                                 ; preds = %while.end.i54
  %div11.i64 = udiv i64 %or.i58, %shr.i40
  br label %cond.end12.i60

cond.end12.i60:                                   ; preds = %cond.false10.i63, %while.end.i54
  %cond13.i61 = phi i64 [ %div11.i64, %cond.false10.i63 ], [ 4294967295, %while.end.i54 ]
  %or14.i62 = or i64 %cond13.i61, %z.0.lcssa.i56
  br label %estimateDiv128To64.exit78

estimateDiv128To64.exit78:                        ; preds = %while.end, %cond.end12.i60
  %retval.0.i38 = phi i64 [ %or14.i62, %cond.end12.i60 ], [ -1, %while.end ]
  %conv1.i.i.i80 = zext i64 %retval.0.i38 to i128
  %mul.i.i.i81 = mul nuw i128 %conv1.i.i.i80, %conv.i.i.i29
  %conv2.i.i.i82 = trunc i128 %mul.i.i.i81 to i64
  %shr.i.i.i83 = lshr i128 %mul.i.i.i81, 64
  %conv3.i.i.i84 = trunc i128 %shr.i.i.i83 to i64
  %mul.i.i4.i86 = mul nuw i128 %conv.i.i2.i.pre-phi, %conv1.i.i.i80
  %conv2.i.i5.i87 = trunc i128 %mul.i.i4.i86 to i64
  %shr.i.i6.i88 = lshr i128 %mul.i.i4.i86, 64
  %conv3.i.i7.i89 = trunc i128 %shr.i.i6.i88 to i64
  %44 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %conv2.i.i5.i87, i64 %conv3.i.i.i84)
  %45 = extractvalue { i64, i1 } %44, 1
  %46 = extractvalue { i64, i1 } %44, 0
  %conv.i1.i.i90.neg36 = sext i1 %45 to i64
  %47 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 0, i64 %conv2.i.i.i82)
  %48 = extractvalue { i64, i1 } %47, 1
  %conv.i1.i91 = zext i1 %48 to i64
  %49 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %r2.0.lcssa, i64 %46)
  %50 = extractvalue { i64, i1 } %49, 1
  %51 = extractvalue { i64, i1 } %49, 0
  %52 = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %51, i64 %conv.i1.i91)
  %53 = extractvalue { i64, i1 } %52, 1
  %54 = or i1 %50, %53
  %conv.i3.neg.i92 = sext i1 %54 to i64
  %.neg14 = sub i64 %r1.0.lcssa, %conv3.i.i7.i89
  %55 = add i64 %.neg14, %conv.i1.i.i90.neg36
  %56 = add i64 %55, %conv.i3.neg.i92
  %r3.025 = extractvalue { i64, i1 } %47, 0
  %r2.126 = extractvalue { i64, i1 } %52, 0
  %cmp7.not27 = icmp eq i64 %56, 0
  br i1 %cmp7.not27, label %while.end10, label %while.body8

while.body8:                                      ; preds = %estimateDiv128To64.exit78, %while.body8
  %r2.131 = phi i64 [ %r2.1, %while.body8 ], [ %r2.126, %estimateDiv128To64.exit78 ]
  %r3.030 = phi i64 [ %r3.0, %while.body8 ], [ %r3.025, %estimateDiv128To64.exit78 ]
  %q1.029 = phi i64 [ %dec9, %while.body8 ], [ %retval.0.i38, %estimateDiv128To64.exit78 ]
  %r1.128 = phi i64 [ %65, %while.body8 ], [ %56, %estimateDiv128To64.exit78 ]
  %dec9 = add i64 %q1.029, -1
  %57 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %r3.030, i64 %b.16.val)
  %58 = extractvalue { i64, i1 } %57, 1
  %conv.i1.i93 = zext i1 %58 to i64
  %59 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %r2.131, i64 %b.8.val)
  %60 = extractvalue { i64, i1 } %59, 1
  %61 = extractvalue { i64, i1 } %59, 0
  %62 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %61, i64 %conv.i1.i93)
  %63 = extractvalue { i64, i1 } %62, 1
  %64 = or i1 %60, %63
  %conv.i3.i94 = zext i1 %64 to i64
  %65 = add i64 %r1.128, %conv.i3.i94
  %r3.0 = extractvalue { i64, i1 } %57, 0
  %r2.1 = extractvalue { i64, i1 } %62, 0
  %cmp7.not = icmp eq i64 %65, 0
  br i1 %cmp7.not, label %while.end10, label %while.body8, !llvm.loop !19

while.end10:                                      ; preds = %while.body8, %estimateDiv128To64.exit78
  %q1.0.lcssa = phi i64 [ %retval.0.i38, %estimateDiv128To64.exit78 ], [ %dec9, %while.body8 ]
  %r3.0.lcssa = phi i64 [ %r3.025, %estimateDiv128To64.exit78 ], [ %r3.0, %while.body8 ]
  %r2.1.lcssa = phi i64 [ %r2.126, %estimateDiv128To64.exit78 ], [ %r2.1, %while.body8 ]
  %or = or i64 %r3.0.lcssa, %r2.1.lcssa
  %cmp11 = icmp ne i64 %or, 0
  %conv12 = zext i1 %cmp11 to i64
  %or13 = or i64 %q1.0.lcssa, %conv12
  store i64 %q0.0.lcssa, ptr %frac_hi, align 8
  store i64 %or13, ptr %frac_lo, align 8
  ret i1 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc zeroext i1 @parts64_round_to_int_normal(ptr nocapture noundef %a, i8 noundef zeroext %rmode, i32 noundef %scale, i32 noundef %frac_size) unnamed_addr #3 {
entry:
  %cond = tail call i32 @llvm.smax.i32(i32 %scale, i32 -65536)
  %cond6 = tail call i32 @llvm.smin.i32(i32 %cond, i32 65536)
  %exp = getelementptr inbounds i8, ptr %a, i64 4
  %0 = load i32, ptr %exp, align 4
  %add = add i32 %0, %cond6
  store i32 %add, ptr %exp, align 4
  %cmp8 = icmp slt i32 %add, 0
  br i1 %cmp8, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  switch i8 %rmode, label %do.body [
    i8 0, label %sw.bb
    i8 4, label %sw.bb15
    i8 3, label %sw.epilog.thread
    i8 2, label %sw.bb21
    i8 1, label %sw.bb24
    i8 5, label %sw.epilog.thread59
  ]

sw.bb:                                            ; preds = %if.then
  %cmp10 = icmp eq i32 %add, -1
  br i1 %cmp10, label %if.then12, label %sw.epilog.thread

if.then12:                                        ; preds = %sw.bb
  %1 = getelementptr i8, ptr %a, i64 8
  %a.val = load i64, ptr %1, align 8
  %.mask = and i64 %a.val, 9223372036854775807
  %cmp.i = icmp ne i64 %.mask, 0
  %frombool = zext i1 %cmp.i to i8
  br label %sw.epilog

sw.bb15:                                          ; preds = %if.then
  %cmp17 = icmp eq i32 %add, -1
  %frombool19 = zext i1 %cmp17 to i8
  br label %sw.epilog

sw.bb21:                                          ; preds = %if.then
  %sign = getelementptr inbounds i8, ptr %a, i64 1
  %2 = load i8, ptr %sign, align 1
  %3 = and i8 %2, 1
  %frombool23 = xor i8 %3, 1
  br label %sw.epilog

sw.bb24:                                          ; preds = %if.then
  %sign25 = getelementptr inbounds i8, ptr %a, i64 1
  %4 = load i8, ptr %sign25, align 1
  %5 = and i8 %4, 1
  br label %sw.epilog

sw.epilog.thread59:                               ; preds = %if.then
  %6 = getelementptr inbounds i8, ptr %a, i64 8
  store i32 0, ptr %exp, align 4
  br label %if.then31

do.body:                                          ; preds = %if.then
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 944, ptr noundef nonnull @__func__.parts64_round_to_int_normal, ptr noundef null) #16
  unreachable

sw.epilog.thread:                                 ; preds = %sw.bb, %if.then
  %7 = getelementptr inbounds i8, ptr %a, i64 8
  store i64 0, ptr %7, align 8
  store i32 0, ptr %exp, align 4
  br label %if.else

sw.epilog:                                        ; preds = %if.then12, %sw.bb24, %sw.bb21, %sw.bb15
  %one.0 = phi i8 [ %5, %sw.bb24 ], [ %frombool23, %sw.bb21 ], [ %frombool19, %sw.bb15 ], [ %frombool, %if.then12 ]
  %8 = getelementptr inbounds i8, ptr %a, i64 8
  store i64 0, ptr %8, align 8
  store i32 0, ptr %exp, align 4
  %tobool30.not = icmp eq i8 %one.0, 0
  br i1 %tobool30.not, label %if.else, label %if.then31

if.then31:                                        ; preds = %sw.epilog.thread59, %sw.epilog
  %9 = phi ptr [ %6, %sw.epilog.thread59 ], [ %8, %sw.epilog ]
  store i64 -9223372036854775808, ptr %9, align 8
  br label %return

if.else:                                          ; preds = %sw.epilog.thread, %sw.epilog
  store i8 1, ptr %a, align 8
  br label %return

if.end33:                                         ; preds = %entry
  %cmp35.not = icmp slt i32 %add, %frac_size
  br i1 %cmp35.not, label %if.end38, label %return

if.end38:                                         ; preds = %if.end33
  %and = and i32 %add, 63
  %sh_prom = zext nneg i32 %and to i64
  %shr = lshr exact i64 -9223372036854775808, %sh_prom
  %shr40 = lshr i64 4611686018427387904, %sh_prom
  %sub = add i64 %shr, -1
  %or = or i64 %sub, %shr
  %10 = getelementptr inbounds i8, ptr %a, i64 8
  %11 = load i64, ptr %10, align 8
  %and41 = and i64 %11, %sub
  %tobool42.not = icmp eq i64 %and41, 0
  br i1 %tobool42.not, label %return, label %if.end44

if.end44:                                         ; preds = %if.end38
  switch i8 %rmode, label %do.body80 [
    i8 0, label %sw.bb46
    i8 4, label %if.then85
    i8 3, label %sw.bb55
    i8 2, label %sw.bb56
    i8 1, label %sw.bb64
    i8 5, label %sw.bb72
  ]

sw.bb46:                                          ; preds = %if.end44
  %and47 = and i64 %11, %or
  %cmp48.not = icmp eq i64 %and47, %shr40
  %cond53 = select i1 %cmp48.not, i64 0, i64 %shr40
  br label %if.then85

sw.bb55:                                          ; preds = %if.end44
  br label %if.then85

sw.bb56:                                          ; preds = %if.end44
  %sign57 = getelementptr inbounds i8, ptr %a, i64 1
  %12 = load i8, ptr %sign57, align 1
  %13 = and i8 %12, 1
  %tobool58.not = icmp eq i8 %13, 0
  %cond63 = select i1 %tobool58.not, i64 %sub, i64 0
  br label %if.then85

sw.bb64:                                          ; preds = %if.end44
  %sign65 = getelementptr inbounds i8, ptr %a, i64 1
  %14 = load i8, ptr %sign65, align 1
  %15 = and i8 %14, 1
  %tobool66.not = icmp eq i8 %15, 0
  %cond71 = select i1 %tobool66.not, i64 0, i64 %sub
  br label %if.then85

sw.bb72:                                          ; preds = %if.end44
  %and73 = and i64 %11, %shr
  %tobool74.not = icmp eq i64 %and73, 0
  %cond78 = select i1 %tobool74.not, i64 %sub, i64 0
  br label %if.then85

do.body80:                                        ; preds = %if.end44
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1005, ptr noundef nonnull @__func__.parts64_round_to_int_normal, ptr noundef null) #16
  unreachable

if.then85:                                        ; preds = %sw.bb46, %sw.bb55, %sw.bb56, %sw.bb64, %sw.bb72, %if.end44
  %inc.0 = phi i64 [ %cond78, %sw.bb72 ], [ %cond71, %sw.bb64 ], [ %cond63, %sw.bb56 ], [ 0, %sw.bb55 ], [ %cond53, %sw.bb46 ], [ %shr40, %if.end44 ]
  %16 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %11, i64 %inc.0)
  %17 = extractvalue { i64, i1 } %16, 1
  %18 = extractvalue { i64, i1 } %16, 0
  br i1 %17, label %if.then87, label %if.end91

if.then87:                                        ; preds = %if.then85
  %shr.i = lshr i64 %18, 1
  %or88 = or disjoint i64 %shr.i, -9223372036854775808
  %inc90 = add nuw nsw i32 %add, 1
  store i32 %inc90, ptr %exp, align 4
  br label %if.end91

if.end91:                                         ; preds = %if.then87, %if.then85
  %19 = phi i64 [ %or88, %if.then87 ], [ %18, %if.then85 ]
  %not = sub i64 0, %shr
  %and92 = and i64 %19, %not
  store i64 %and92, ptr %10, align 8
  br label %return

return:                                           ; preds = %if.end38, %if.end33, %if.then31, %if.else, %if.end91
  %retval.0 = phi i1 [ true, %if.end91 ], [ true, %if.else ], [ true, %if.then31 ], [ false, %if.end33 ], [ false, %if.end38 ]
  ret i1 %retval.0
}

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc zeroext i1 @parts128_round_to_int_normal(ptr nocapture noundef %a, i8 noundef zeroext %rmode, i32 noundef %frac_size) unnamed_addr #3 {
entry:
  %exp = getelementptr inbounds i8, ptr %a, i64 4
  %0 = load i32, ptr %exp, align 4
  %cmp8 = icmp slt i32 %0, 0
  br i1 %cmp8, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  switch i8 %rmode, label %do.body [
    i8 0, label %sw.bb
    i8 4, label %sw.bb15
    i8 3, label %sw.epilog.thread
    i8 2, label %sw.bb21
    i8 1, label %sw.bb24
    i8 5, label %sw.epilog.thread109
  ]

sw.bb:                                            ; preds = %if.then
  %cmp10 = icmp eq i32 %0, -1
  br i1 %cmp10, label %if.then12, label %sw.epilog.thread

if.then12:                                        ; preds = %sw.bb
  %frac_lo.i = getelementptr inbounds i8, ptr %a, i64 16
  %1 = load i64, ptr %frac_lo.i, align 8
  %2 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %1, i64 %1)
  %3 = extractvalue { i64, i1 } %2, 1
  %4 = extractvalue { i64, i1 } %2, 0
  %frac_hi.i = getelementptr inbounds i8, ptr %a, i64 8
  %5 = load i64, ptr %frac_hi.i, align 8
  %conv.i4.i = zext i1 %3 to i64
  %6 = shl i64 %5, 1
  %7 = or disjoint i64 %6, %conv.i4.i
  %or.i = or i64 %7, %4
  %cmp.i = icmp ne i64 %or.i, 0
  %frombool = zext i1 %cmp.i to i8
  br label %sw.epilog

sw.bb15:                                          ; preds = %if.then
  %cmp17 = icmp eq i32 %0, -1
  %frombool19 = zext i1 %cmp17 to i8
  br label %sw.epilog

sw.bb21:                                          ; preds = %if.then
  %sign = getelementptr inbounds i8, ptr %a, i64 1
  %8 = load i8, ptr %sign, align 1
  %9 = and i8 %8, 1
  %frombool23 = xor i8 %9, 1
  br label %sw.epilog

sw.bb24:                                          ; preds = %if.then
  %sign25 = getelementptr inbounds i8, ptr %a, i64 1
  %10 = load i8, ptr %sign25, align 1
  %11 = and i8 %10, 1
  br label %sw.epilog

sw.epilog.thread109:                              ; preds = %if.then
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(20) %exp, i8 0, i64 20, i1 false)
  br label %if.then31

do.body:                                          ; preds = %if.then
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 944, ptr noundef nonnull @__func__.parts128_round_to_int_normal, ptr noundef null) #16
  unreachable

sw.epilog.thread:                                 ; preds = %sw.bb, %if.then
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(20) %exp, i8 0, i64 20, i1 false)
  br label %if.else

sw.epilog:                                        ; preds = %if.then12, %sw.bb24, %sw.bb21, %sw.bb15
  %one.0 = phi i8 [ %11, %sw.bb24 ], [ %frombool23, %sw.bb21 ], [ %frombool19, %sw.bb15 ], [ %frombool, %if.then12 ]
  %tobool30.not = icmp eq i8 %one.0, 0
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(20) %exp, i8 0, i64 20, i1 false)
  br i1 %tobool30.not, label %if.else, label %if.then31

if.then31:                                        ; preds = %sw.epilog.thread109, %sw.epilog
  %frac_hi.i60113 = getelementptr inbounds i8, ptr %a, i64 8
  store i64 -9223372036854775808, ptr %frac_hi.i60113, align 8
  br label %return

if.else:                                          ; preds = %sw.epilog.thread, %sw.epilog
  store i8 1, ptr %a, align 8
  br label %return

if.end33:                                         ; preds = %entry
  %cmp35.not = icmp slt i32 %0, %frac_size
  br i1 %cmp35.not, label %if.end38, label %return

if.end38:                                         ; preds = %if.end33
  %cmp40 = icmp ult i32 %0, 64
  %frac_lo.i62 = getelementptr inbounds i8, ptr %a, i64 16
  %12 = load i64, ptr %frac_lo.i62, align 8
  br i1 %cmp40, label %if.then42, label %if.else45

if.then42:                                        ; preds = %if.end38
  %sub = sub nuw nsw i32 125, %0
  %frac_hi.i61 = getelementptr inbounds i8, ptr %a, i64 8
  %13 = load i64, ptr %frac_hi.i61, align 8
  %cmp2.i = icmp ugt i32 %0, 61
  br i1 %cmp2.i, label %if.end27.i, label %if.then20.i

if.then20.i:                                      ; preds = %if.then42
  %and.i = and i32 %sub, 63
  %cmp21.i = icmp eq i32 %and.i, 0
  br i1 %cmp21.i, label %done.i, label %if.end27.i

if.end27.i:                                       ; preds = %if.then20.i, %if.then42
  %c.addr.0.i = phi i32 [ %sub, %if.then42 ], [ %and.i, %if.then20.i ]
  %a0.0.i = phi i64 [ %13, %if.then42 ], [ 0, %if.then20.i ]
  %a1.0.i = phi i64 [ %12, %if.then42 ], [ %13, %if.then20.i ]
  %sticky.0.i = phi i64 [ 0, %if.then42 ], [ %12, %if.then20.i ]
  %14 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a1.0.i, i32 %c.addr.0.i, i64 0) #15, !srcloc !6
  %or28.i = or i64 %14, %sticky.0.i
  %15 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %a0.0.i, i32 %c.addr.0.i, i64 %a1.0.i) #15, !srcloc !6
  %sh_prom.i = zext nneg i32 %c.addr.0.i to i64
  %shr.i = lshr i64 %a0.0.i, %sh_prom.i
  br label %done.i

done.i:                                           ; preds = %if.end27.i, %if.then20.i
  %a0.1.i = phi i64 [ %shr.i, %if.end27.i ], [ 0, %if.then20.i ]
  %a1.1.i = phi i64 [ %15, %if.end27.i ], [ %13, %if.then20.i ]
  %sticky.1.i = phi i64 [ %or28.i, %if.end27.i ], [ %12, %if.then20.i ]
  %cmp30.i = icmp ne i64 %sticky.1.i, 0
  %conv32.i = zext i1 %cmp30.i to i64
  %or33.i = or i64 %a1.1.i, %conv32.i
  store i64 %or33.i, ptr %frac_lo.i62, align 8
  store i64 %a0.1.i, ptr %frac_hi.i61, align 8
  br label %if.end47

if.else45:                                        ; preds = %if.end38
  %and = and i32 %0, 63
  %sh_prom = zext nneg i32 %and to i64
  %shr = lshr exact i64 -9223372036854775808, %sh_prom
  br label %if.end47

if.end47:                                         ; preds = %done.i, %if.else45
  %16 = phi i64 [ %12, %if.else45 ], [ %or33.i, %done.i ]
  %shift_adj.0 = phi i32 [ 0, %if.else45 ], [ %sub, %done.i ]
  %frac_lsb.0 = phi i64 [ %shr, %if.else45 ], [ 4, %done.i ]
  %shr48 = lshr i64 %frac_lsb.0, 1
  %sub49 = add i64 %frac_lsb.0, -1
  %or = or i64 %sub49, %frac_lsb.0
  %frac_lo = getelementptr inbounds i8, ptr %a, i64 16
  %and50 = and i64 %16, %sub49
  %tobool51.not = icmp eq i64 %and50, 0
  br i1 %tobool51.not, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end47
  %frac_hi.i65 = getelementptr inbounds i8, ptr %a, i64 8
  %17 = load i64, ptr %frac_hi.i65, align 8
  %and.i67 = and i32 %shift_adj.0, 64
  %tobool.not.i = icmp eq i32 %and.i67, 0
  %spec.select.i = select i1 %tobool.not.i, i64 %17, i64 %16
  %spec.select12.i = select i1 %tobool.not.i, i64 %16, i64 0
  %and1.i = and i32 %shift_adj.0, 63
  %tobool2.not.i = icmp eq i32 %and1.i, 0
  br i1 %tobool2.not.i, label %frac128_shl.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then52
  %18 = tail call i64 asm "shld ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %spec.select12.i, i32 %and1.i, i64 %spec.select.i) #15, !srcloc !16
  %sh_prom.i68 = zext nneg i32 %and1.i to i64
  %shl.i = shl i64 %spec.select12.i, %sh_prom.i68
  br label %frac128_shl.exit

frac128_shl.exit:                                 ; preds = %if.then52, %if.then3.i
  %a0.1.i69 = phi i64 [ %18, %if.then3.i ], [ %spec.select.i, %if.then52 ]
  %a1.1.i70 = phi i64 [ %shl.i, %if.then3.i ], [ %spec.select12.i, %if.then52 ]
  store i64 %a0.1.i69, ptr %frac_hi.i65, align 8
  store i64 %a1.1.i70, ptr %frac_lo, align 8
  br label %return

if.end53:                                         ; preds = %if.end47
  switch i8 %rmode, label %do.body91 [
    i8 0, label %sw.bb55
    i8 4, label %sw.epilog93
    i8 3, label %sw.bb65
    i8 2, label %sw.bb66
    i8 1, label %sw.bb74
    i8 5, label %sw.bb82
  ]

sw.bb55:                                          ; preds = %if.end53
  %and57 = and i64 %or, %16
  %cmp58.not = icmp eq i64 %and57, %shr48
  %cond63 = select i1 %cmp58.not, i64 0, i64 %shr48
  br label %sw.epilog93

sw.bb65:                                          ; preds = %if.end53
  br label %sw.epilog93

sw.bb66:                                          ; preds = %if.end53
  %sign67 = getelementptr inbounds i8, ptr %a, i64 1
  %19 = load i8, ptr %sign67, align 1
  %20 = and i8 %19, 1
  %tobool68.not = icmp eq i8 %20, 0
  %cond73 = select i1 %tobool68.not, i64 %sub49, i64 0
  br label %sw.epilog93

sw.bb74:                                          ; preds = %if.end53
  %sign75 = getelementptr inbounds i8, ptr %a, i64 1
  %21 = load i8, ptr %sign75, align 1
  %22 = and i8 %21, 1
  %tobool76.not = icmp eq i8 %22, 0
  %cond81 = select i1 %tobool76.not, i64 0, i64 %sub49
  br label %sw.epilog93

sw.bb82:                                          ; preds = %if.end53
  %and84 = and i64 %16, %frac_lsb.0
  %tobool85.not = icmp eq i64 %and84, 0
  %cond89 = select i1 %tobool85.not, i64 %sub49, i64 0
  br label %sw.epilog93

do.body91:                                        ; preds = %if.end53
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1005, ptr noundef nonnull @__func__.parts128_round_to_int_normal, ptr noundef null) #16
  unreachable

sw.epilog93:                                      ; preds = %if.end53, %sw.bb82, %sw.bb74, %sw.bb66, %sw.bb65, %sw.bb55
  %inc.0 = phi i64 [ %cond89, %sw.bb82 ], [ %cond81, %sw.bb74 ], [ %cond73, %sw.bb66 ], [ 0, %sw.bb65 ], [ %cond63, %sw.bb55 ], [ %shr48, %if.end53 ]
  %cmp94 = icmp eq i32 %shift_adj.0, 0
  %23 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %16, i64 %inc.0)
  %24 = extractvalue { i64, i1 } %23, 1
  %25 = extractvalue { i64, i1 } %23, 0
  %conv.i = zext i1 %24 to i64
  %frac_hi.i73 = getelementptr inbounds i8, ptr %a, i64 8
  %26 = load i64, ptr %frac_hi.i73, align 8
  br i1 %cmp94, label %if.then96, label %if.else106

if.then96:                                        ; preds = %sw.epilog93
  %27 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %26, i64 %conv.i)
  %28 = extractvalue { i64, i1 } %27, 1
  %29 = extractvalue { i64, i1 } %27, 0
  store i64 %29, ptr %frac_hi.i73, align 8
  br i1 %28, label %if.then98, label %if.end103

if.then98:                                        ; preds = %if.then96
  %30 = tail call i64 asm "shrd ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %29, i32 1, i64 %25) #15, !srcloc !6
  %shr.i77 = lshr i64 %29, 1
  %or100 = or disjoint i64 %shr.i77, -9223372036854775808
  store i64 %or100, ptr %frac_hi.i73, align 8
  %inc102 = add nuw nsw i32 %0, 1
  store i32 %inc102, ptr %exp, align 4
  br label %if.end103

if.end103:                                        ; preds = %if.then98, %if.then96
  %31 = phi i64 [ %30, %if.then98 ], [ %25, %if.then96 ]
  %not = sub i64 0, %frac_lsb.0
  %and105 = and i64 %31, %not
  store i64 %and105, ptr %frac_lo, align 8
  br label %return

if.else106:                                       ; preds = %sw.epilog93
  %32 = add i64 %26, %conv.i
  %not108 = sub i64 0, %frac_lsb.0
  %and110 = and i64 %25, %not108
  %sub111 = add nsw i32 %shift_adj.0, -1
  %and.i87 = and i32 %sub111, 64
  %tobool.not.i88 = icmp eq i32 %and.i87, 0
  %spec.select.i89 = select i1 %tobool.not.i88, i64 %32, i64 %and110
  %spec.select12.i90 = select i1 %tobool.not.i88, i64 %and110, i64 0
  %and1.i91 = and i32 %sub111, 63
  %tobool2.not.i92 = icmp eq i32 %and1.i91, 0
  br i1 %tobool2.not.i92, label %frac128_shl.exit98, label %if.then3.i93

if.then3.i93:                                     ; preds = %if.else106
  %33 = tail call i64 asm "shld ${2:b}, $1, $0", "=r,r,{cx}i,0,~{dirflag},~{fpsr},~{flags}"(i64 %spec.select12.i90, i32 %and1.i91, i64 %spec.select.i89) #15, !srcloc !16
  %sh_prom.i94 = zext nneg i32 %and1.i91 to i64
  %shl.i95 = shl i64 %spec.select12.i90, %sh_prom.i94
  br label %frac128_shl.exit98

frac128_shl.exit98:                               ; preds = %if.else106, %if.then3.i93
  %a0.1.i96 = phi i64 [ %33, %if.then3.i93 ], [ %spec.select.i89, %if.else106 ]
  %a1.1.i97 = phi i64 [ %shl.i95, %if.then3.i93 ], [ %spec.select12.i90, %if.else106 ]
  store i64 %a0.1.i96, ptr %frac_hi.i73, align 8
  store i64 %a1.1.i97, ptr %frac_lo, align 8
  %tobool114.not = icmp sgt i64 %a0.1.i96, -1
  br i1 %tobool114.not, label %if.else118, label %if.then115

if.then115:                                       ; preds = %frac128_shl.exit98
  %inc117 = add nuw nsw i32 %0, 1
  store i32 %inc117, ptr %exp, align 4
  br label %return

if.else118:                                       ; preds = %frac128_shl.exit98
  %34 = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %a1.1.i97, i64 %a1.1.i97)
  %35 = extractvalue { i64, i1 } %34, 1
  %36 = extractvalue { i64, i1 } %34, 0
  store i64 %36, ptr %frac_lo, align 8
  %conv.i4.i104 = zext i1 %35 to i64
  %37 = shl nuw i64 %a0.1.i96, 1
  %38 = or disjoint i64 %37, %conv.i4.i104
  store i64 %38, ptr %frac_hi.i73, align 8
  br label %return

return:                                           ; preds = %if.end103, %if.else118, %if.then115, %if.end33, %if.then31, %if.else, %frac128_shl.exit
  %retval.0 = phi i1 [ false, %frac128_shl.exit ], [ true, %if.else ], [ true, %if.then31 ], [ false, %if.end33 ], [ true, %if.then115 ], [ true, %if.else118 ], [ true, %if.end103 ]
  ret i1 %retval.0
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.ctlz.i64(i64, i1 immarg) #4

; Function Attrs: nounwind sspstrong uwtable
define internal fastcc ptr @parts64_minmax(ptr noundef %a, ptr noundef %b, ptr nocapture noundef %s, i32 noundef %flags) unnamed_addr #3 {
entry:
  %0 = load i8, ptr %a, align 8
  %conv = zext nneg i8 %0 to i32
  %shl = shl nuw i32 1, %conv
  %1 = load i8, ptr %b, align 8
  %conv2 = zext nneg i8 %1 to i32
  %shl3 = shl nuw i32 1, %conv2
  %or = or i32 %shl3, %shl
  %and = and i32 %or, 48
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end35, label %if.then

if.then:                                          ; preds = %entry
  %and7 = and i32 %flags, 10
  %tobool8.not = icmp ne i32 %and7, 0
  %and9 = and i32 %or, 32
  %tobool10.not = icmp eq i32 %and9, 0
  %or.cond34 = and i1 %tobool8.not, %tobool10.not
  %or.cond34.not = xor i1 %or.cond34, true
  %and12 = and i32 %or, -49
  %tobool13.not = icmp eq i32 %and12, 0
  %or.cond35 = or i1 %tobool13.not, %or.cond34.not
  br i1 %or.cond35, label %if.end, label %if.then14

if.then14:                                        ; preds = %if.then
  %cmp.i = icmp ugt i8 %0, 3
  %cond = select i1 %cmp.i, ptr %b, ptr %a
  br label %return

if.end:                                           ; preds = %if.then
  %and17 = and i32 %flags, 8
  %tobool18.not = icmp eq i32 %and17, 0
  %or.cond36 = or i1 %tobool18.not, %tobool10.not
  %or.cond37 = or i1 %tobool13.not, %or.cond36
  br i1 %or.cond37, label %if.end33, label %if.then25

if.then25:                                        ; preds = %if.end
  %2 = load i16, ptr %s, align 2
  %or1.i = or i16 %2, 1
  store i16 %or1.i, ptr %s, align 2
  %3 = load i8, ptr %a, align 8
  %cmp.i39 = icmp ugt i8 %3, 3
  %cond32 = select i1 %cmp.i39, ptr %b, ptr %a
  br label %return

if.end33:                                         ; preds = %if.end
  %cmp.i.i = icmp eq i8 %0, 5
  %cmp.i17.i = icmp eq i8 %1, 5
  %or.cond41 = or i1 %cmp.i.i, %cmp.i17.i
  br i1 %or.cond41, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end33
  %4 = load i16, ptr %s, align 2
  %or1.i.i = or i16 %4, 8193
  store i16 %or1.i.i, ptr %s, align 2
  br label %if.end.i

if.end.i:                                         ; preds = %if.end33, %if.then.i
  %default_nan_mode.i = getelementptr inbounds i8, ptr %s, i64 7
  %5 = load i8, ptr %default_nan_mode.i, align 1
  %6 = and i8 %5, 1
  %tobool.not.i = icmp eq i8 %6, 0
  br i1 %tobool.not.i, label %if.else.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  store i8 4, ptr %a, align 8
  %.compoundliteral.sroa.2.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 1
  store i8 0, ptr %.compoundliteral.sroa.2.0..sroa_idx.i.i, align 1
  %.compoundliteral.sroa.31.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 4
  store i32 2147483647, ptr %.compoundliteral.sroa.31.0..sroa_idx.i.i, align 4
  %.compoundliteral.sroa.4.0..sroa_idx.i.i = getelementptr inbounds i8, ptr %a, i64 8
  store i64 4611686018427387904, ptr %.compoundliteral.sroa.4.0..sroa_idx.i.i, align 8
  br label %return

if.else.i:                                        ; preds = %if.end.i
  %7 = getelementptr i8, ptr %a, i64 8
  %a.val.i = load i64, ptr %7, align 8
  %8 = getelementptr i8, ptr %b, i64 8
  %b.val.i = load i64, ptr %8, align 8
  %cmp.i18.i = icmp eq i64 %a.val.i, %b.val.i
  %cmp1.i.i = icmp ult i64 %a.val.i, %b.val.i
  br i1 %cmp.i18.i, label %if.then6.i, label %if.end13.i

if.then6.i:                                       ; preds = %if.else.i
  %sign.i = getelementptr inbounds i8, ptr %a, i64 1
  %9 = load i8, ptr %sign.i, align 1
  %10 = and i8 %9, 1
  %sign8.i = getelementptr inbounds i8, ptr %b, i64 1
  %11 = load i8, ptr %sign8.i, align 1
  %12 = and i8 %11, 1
  %cmp11.i = icmp uge i8 %10, %12
  br label %if.end13.i

if.end13.i:                                       ; preds = %if.then6.i, %if.else.i
  %cmp.0.i = phi i1 [ %cmp11.i, %if.then6.i ], [ %cmp1.i.i, %if.else.i ]
  %13 = load i8, ptr %a, align 8
  %14 = load i8, ptr %b, align 8
  switch i8 %13, label %15 [
    i8 5, label %pickNaN.exit.i
    i8 4, label %if.then6.i.i
  ]

if.then6.i.i:                                     ; preds = %if.end13.i
  %cmp.i10.i.i = icmp eq i8 %14, 5
  br i1 %cmp.i10.i.i, label %return, label %lor.lhs.false.i.i

lor.lhs.false.i.i:                                ; preds = %if.then6.i.i
  %cmp.i11.i.i = icmp eq i8 %14, 4
  %spec.select.i.i = and i1 %cmp.0.i, %cmp.i11.i.i
  %cond.fr26.i = freeze i1 %spec.select.i.i
  %spec.select50 = select i1 %cond.fr26.i, ptr %b, ptr %a
  br label %return

pickNaN.exit.i:                                   ; preds = %if.end13.i
  %cmp.i7.i.i = icmp eq i8 %14, 5
  %cmp.i8.i.i = icmp eq i8 %14, 4
  %spec.select20.i = select i1 %cmp.i7.i.i, i1 %cmp.0.i, i1 %cmp.i8.i.i
  %cond.fr.i = freeze i1 %spec.select20.i
  br i1 %cond.fr.i, label %15, label %if.then24.i

15:                                               ; preds = %if.end13.i, %pickNaN.exit.i
  %16 = icmp eq i8 %14, 5
  br i1 %16, label %if.then24.i, label %return

if.then24.i:                                      ; preds = %pickNaN.exit.i, %15
  %.ph.i45 = phi ptr [ %b, %15 ], [ %a, %pickNaN.exit.i ]
  %17 = getelementptr inbounds i8, ptr %.ph.i45, i64 8
  %18 = load i64, ptr %17, align 8
  %or4.i.i.i = or i64 %18, 4611686018427387904
  store i64 %or4.i.i.i, ptr %17, align 8
  store i8 4, ptr %.ph.i45, align 8
  br label %return

if.end35:                                         ; preds = %entry
  %exp = getelementptr inbounds i8, ptr %a, i64 4
  %19 = load i32, ptr %exp, align 4
  %exp36 = getelementptr inbounds i8, ptr %b, i64 4
  %20 = load i32, ptr %exp36, align 4
  %cmp37.not = icmp eq i32 %or, 4
  br i1 %cmp37.not, label %if.end59, label %if.then45

if.then45:                                        ; preds = %if.end35
  switch i8 %0, label %do.body [
    i8 2, label %sw.epilog
    i8 3, label %sw.bb48
    i8 1, label %sw.bb49
  ]

sw.bb48:                                          ; preds = %if.then45
  br label %sw.epilog

sw.bb49:                                          ; preds = %if.then45
  br label %sw.epilog

do.body:                                          ; preds = %if.then45
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1375, ptr noundef nonnull @__func__.parts64_minmax, ptr noundef null) #16
  unreachable

sw.epilog:                                        ; preds = %if.then45, %sw.bb49, %sw.bb48
  %a_exp.0 = phi i32 [ -32768, %sw.bb49 ], [ 32767, %sw.bb48 ], [ %19, %if.then45 ]
  switch i8 %1, label %do.body56 [
    i8 2, label %if.end59
    i8 3, label %sw.bb53
    i8 1, label %sw.bb54
  ]

sw.bb53:                                          ; preds = %sw.epilog
  br label %if.end59

sw.bb54:                                          ; preds = %sw.epilog
  br label %if.end59

do.body56:                                        ; preds = %sw.epilog
  tail call void @g_assertion_message_expr(ptr noundef null, ptr noundef nonnull @.str.3, i32 noundef 1388, ptr noundef nonnull @__func__.parts64_minmax, ptr noundef null) #16
  unreachable

if.end59:                                         ; preds = %sw.bb53, %sw.bb54, %sw.epilog, %if.end35
  %a_exp.1 = phi i32 [ %a_exp.0, %sw.bb54 ], [ %a_exp.0, %sw.bb53 ], [ %a_exp.0, %sw.epilog ], [ %19, %if.end35 ]
  %b_exp.0 = phi i32 [ -32768, %sw.bb54 ], [ 32767, %sw.bb53 ], [ %20, %sw.epilog ], [ %20, %if.end35 ]
  %sub = sub i32 %a_exp.1, %b_exp.0
  %cmp60 = icmp eq i32 %sub, 0
  br i1 %cmp60, label %if.then62, label %if.end64

if.then62:                                        ; preds = %if.end59
  %21 = getelementptr i8, ptr %a, i64 8
  %a.val = load i64, ptr %21, align 8
  %22 = getelementptr i8, ptr %b, i64 8
  %b.val = load i64, ptr %22, align 8
  %cmp.i40 = icmp eq i64 %a.val, %b.val
  %cmp1.i = icmp ult i64 %a.val, %b.val
  %cond.i = select i1 %cmp1.i, i32 -1, i32 1
  %cond2.i = select i1 %cmp.i40, i32 0, i32 %cond.i
  br label %if.end64

if.end64:                                         ; preds = %if.then62, %if.end59
  %cmp.0 = phi i32 [ %cond2.i, %if.then62 ], [ %sub, %if.end59 ]
  %and65 = and i32 %flags, 4
  %tobool66 = icmp eq i32 %and65, 0
  %cmp67 = icmp eq i32 %cmp.0, 0
  %or.cond = select i1 %tobool66, i1 true, i1 %cmp67
  br i1 %or.cond, label %if.then69, label %if.end88

if.then69:                                        ; preds = %if.end64
  %sign = getelementptr inbounds i8, ptr %a, i64 1
  %23 = load i8, ptr %sign, align 1
  %24 = and i8 %23, 1
  %tobool70.not = icmp eq i8 %24, 0
  %sign72 = getelementptr inbounds i8, ptr %b, i64 1
  %25 = load i8, ptr %sign72, align 1
  %26 = and i8 %25, 1
  %cmp75.not = icmp eq i8 %24, %26
  br i1 %cmp75.not, label %if.else, label %if.then77

if.then77:                                        ; preds = %if.then69
  %cond81 = select i1 %tobool70.not, i32 1, i32 -1
  br label %if.end88

if.else:                                          ; preds = %if.then69
  %sub85 = sub i32 0, %cmp.0
  %spec.select = select i1 %tobool70.not, i32 %cmp.0, i32 %sub85
  br label %if.end88

if.end88:                                         ; preds = %if.else, %if.then77, %if.end64
  %cmp.1 = phi i32 [ %cond81, %if.then77 ], [ %cmp.0, %if.end64 ], [ %spec.select, %if.else ]
  %and89 = and i32 %flags, 1
  %tobool90.not = icmp eq i32 %and89, 0
  %sub92 = sub i32 0, %cmp.1
  %spec.select38 = select i1 %tobool90.not, i32 %cmp.1, i32 %sub92
  %cmp94 = icmp slt i32 %spec.select38, 0
  %cond99 = select i1 %cmp94, ptr %b, ptr %a
  br label %return

return:                                           ; preds = %lor.lhs.false.i.i, %if.then24.i, %15, %if.then6.i.i, %if.then3.i, %if.end88, %if.then25, %if.then14
  %retval.0 = phi ptr [ %cond32, %if.then25 ], [ %cond, %if.then14 ], [ %cond99, %if.end88 ], [ %a, %if.then3.i ], [ %.ph.i45, %if.then24.i ], [ %b, %15 ], [ %a, %if.then6.i.i ], [ %spec.select50, %lor.lhs.false.i.i ]
  ret ptr %retval.0
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.fshl.i64(i64, i64, i64) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.usub.sat.i64(i64, i64) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i1 @llvm.is.fpclass.f64(double, i32 immarg) #12

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #13

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #13

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umin.i64(i64, i64) #12

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #14

attributes #0 = { mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { mustprogress nofree norecurse nosync nounwind sspstrong willreturn memory(argmem: readwrite) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #5 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #6 = { mustprogress nofree nounwind willreturn memory(write) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { nofree nosync nounwind sspstrong memory(none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { mustprogress nofree nosync nounwind sspstrong willreturn memory(argmem: write) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { noreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { nounwind sspstrong memory(argmem: readwrite) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #13 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #14 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #15 = { nounwind memory(none) }
attributes #16 = { noreturn nounwind }
attributes #17 = { memory(none) }
attributes #18 = { nounwind memory(read) }
attributes #19 = { alwaysinline nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i64 0, i64 65}
!6 = !{i64 3398715}
!7 = !{i64 3259110}
!8 = distinct !{!8, !9}
!9 = !{!"llvm.loop.mustprogress"}
!10 = distinct !{!10, !9}
!11 = distinct !{!11, !9}
!12 = distinct !{!12, !9}
!13 = distinct !{!13, !9}
!14 = !{i32 -1, i32 3}
!15 = distinct !{!15, !9}
!16 = !{i64 3398281}
!17 = distinct !{!17, !9}
!18 = distinct !{!18, !9}
!19 = distinct !{!19, !9}
